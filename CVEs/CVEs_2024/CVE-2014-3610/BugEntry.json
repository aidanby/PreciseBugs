{"buggy_code": ["/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This header defines architecture specific interfaces, x86 version\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#ifndef _ASM_X86_KVM_HOST_H\n#define _ASM_X86_KVM_HOST_H\n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/tracepoint.h>\n#include <linux/cpumask.h>\n#include <linux/irq_work.h>\n\n#include <linux/kvm.h>\n#include <linux/kvm_para.h>\n#include <linux/kvm_types.h>\n#include <linux/perf_event.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/clocksource.h>\n\n#include <asm/pvclock-abi.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/msr-index.h>\n#include <asm/asm.h>\n\n#define KVM_MAX_VCPUS 255\n#define KVM_SOFT_MAX_VCPUS 160\n#define KVM_USER_MEM_SLOTS 125\n/* memory slots that are not exposed to userspace */\n#define KVM_PRIVATE_MEM_SLOTS 3\n#define KVM_MEM_SLOTS_NUM (KVM_USER_MEM_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\n#define KVM_MMIO_SIZE 16\n\n#define KVM_PIO_PAGE_OFFSET 1\n#define KVM_COALESCED_MMIO_PAGE_OFFSET 2\n\n#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS\n\n#define CR0_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR0_PE | X86_CR0_MP | X86_CR0_EM | X86_CR0_TS \\\n\t\t\t  | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM \\\n\t\t\t  | X86_CR0_NW | X86_CR0_CD | X86_CR0_PG))\n\n#define CR3_L_MODE_RESERVED_BITS 0xFFFFFF0000000000ULL\n#define CR4_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\\\n\t\t\t  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \\\n\t\t\t  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \\\n\t\t\t  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \\\n\t\t\t  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE | X86_CR4_SMAP))\n\n#define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)\n\n\n\n#define INVALID_PAGE (~(hpa_t)0)\n#define VALID_PAGE(x) ((x) != INVALID_PAGE)\n\n#define UNMAPPED_GVA (~(gpa_t)0)\n\n/* KVM Hugepage definitions for x86 */\n#define KVM_NR_PAGE_SIZES\t3\n#define KVM_HPAGE_GFN_SHIFT(x)\t(((x) - 1) * 9)\n#define KVM_HPAGE_SHIFT(x)\t(PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))\n#define KVM_HPAGE_SIZE(x)\t(1UL << KVM_HPAGE_SHIFT(x))\n#define KVM_HPAGE_MASK(x)\t(~(KVM_HPAGE_SIZE(x) - 1))\n#define KVM_PAGES_PER_HPAGE(x)\t(KVM_HPAGE_SIZE(x) / PAGE_SIZE)\n\nstatic inline gfn_t gfn_to_index(gfn_t gfn, gfn_t base_gfn, int level)\n{\n\t/* KVM_HPAGE_GFN_SHIFT(PT_PAGE_TABLE_LEVEL) must be 0. */\n\treturn (gfn >> KVM_HPAGE_GFN_SHIFT(level)) -\n\t\t(base_gfn >> KVM_HPAGE_GFN_SHIFT(level));\n}\n\n#define SELECTOR_TI_MASK (1 << 2)\n#define SELECTOR_RPL_MASK 0x03\n\n#define IOPL_SHIFT 12\n\n#define KVM_PERMILLE_MMU_PAGES 20\n#define KVM_MIN_ALLOC_MMU_PAGES 64\n#define KVM_MMU_HASH_SHIFT 10\n#define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)\n#define KVM_MIN_FREE_MMU_PAGES 5\n#define KVM_REFILL_PAGES 25\n#define KVM_MAX_CPUID_ENTRIES 80\n#define KVM_NR_FIXED_MTRR_REGION 88\n#define KVM_NR_VAR_MTRR 8\n\n#define ASYNC_PF_PER_VCPU 64\n\nenum kvm_reg {\n\tVCPU_REGS_RAX = 0,\n\tVCPU_REGS_RCX = 1,\n\tVCPU_REGS_RDX = 2,\n\tVCPU_REGS_RBX = 3,\n\tVCPU_REGS_RSP = 4,\n\tVCPU_REGS_RBP = 5,\n\tVCPU_REGS_RSI = 6,\n\tVCPU_REGS_RDI = 7,\n#ifdef CONFIG_X86_64\n\tVCPU_REGS_R8 = 8,\n\tVCPU_REGS_R9 = 9,\n\tVCPU_REGS_R10 = 10,\n\tVCPU_REGS_R11 = 11,\n\tVCPU_REGS_R12 = 12,\n\tVCPU_REGS_R13 = 13,\n\tVCPU_REGS_R14 = 14,\n\tVCPU_REGS_R15 = 15,\n#endif\n\tVCPU_REGS_RIP,\n\tNR_VCPU_REGS\n};\n\nenum kvm_reg_ex {\n\tVCPU_EXREG_PDPTR = NR_VCPU_REGS,\n\tVCPU_EXREG_CR3,\n\tVCPU_EXREG_RFLAGS,\n\tVCPU_EXREG_SEGMENTS,\n};\n\nenum {\n\tVCPU_SREG_ES,\n\tVCPU_SREG_CS,\n\tVCPU_SREG_SS,\n\tVCPU_SREG_DS,\n\tVCPU_SREG_FS,\n\tVCPU_SREG_GS,\n\tVCPU_SREG_TR,\n\tVCPU_SREG_LDTR,\n};\n\n#include <asm/kvm_emulate.h>\n\n#define KVM_NR_MEM_OBJS 40\n\n#define KVM_NR_DB_REGS\t4\n\n#define DR6_BD\t\t(1 << 13)\n#define DR6_BS\t\t(1 << 14)\n#define DR6_RTM\t\t(1 << 16)\n#define DR6_FIXED_1\t0xfffe0ff0\n#define DR6_INIT\t0xffff0ff0\n#define DR6_VOLATILE\t0x0001e00f\n\n#define DR7_BP_EN_MASK\t0x000000ff\n#define DR7_GE\t\t(1 << 9)\n#define DR7_GD\t\t(1 << 13)\n#define DR7_FIXED_1\t0x00000400\n#define DR7_VOLATILE\t0xffff2bff\n\n/* apic attention bits */\n#define KVM_APIC_CHECK_VAPIC\t0\n/*\n * The following bit is set with PV-EOI, unset on EOI.\n * We detect PV-EOI changes by guest by comparing\n * this bit with PV-EOI in guest memory.\n * See the implementation in apic_update_pv_eoi.\n */\n#define KVM_APIC_PV_EOI_PENDING\t1\n\n/*\n * We don't want allocation failures within the mmu code, so we preallocate\n * enough memory for a single page fault in a cache.\n */\nstruct kvm_mmu_memory_cache {\n\tint nobjs;\n\tvoid *objects[KVM_NR_MEM_OBJS];\n};\n\n/*\n * kvm_mmu_page_role, below, is defined as:\n *\n *   bits 0:3 - total guest paging levels (2-4, or zero for real mode)\n *   bits 4:7 - page table level for this shadow (1-4)\n *   bits 8:9 - page table quadrant for 2-level guests\n *   bit   16 - direct mapping of virtual to physical mapping at gfn\n *              used for real mode and two-dimensional paging\n *   bits 17:19 - common access permissions for all ptes in this shadow page\n */\nunion kvm_mmu_page_role {\n\tunsigned word;\n\tstruct {\n\t\tunsigned level:4;\n\t\tunsigned cr4_pae:1;\n\t\tunsigned quadrant:2;\n\t\tunsigned pad_for_nice_hex_output:6;\n\t\tunsigned direct:1;\n\t\tunsigned access:3;\n\t\tunsigned invalid:1;\n\t\tunsigned nxe:1;\n\t\tunsigned cr0_wp:1;\n\t\tunsigned smep_andnot_wp:1;\n\t};\n};\n\nstruct kvm_mmu_page {\n\tstruct list_head link;\n\tstruct hlist_node hash_link;\n\n\t/*\n\t * The following two entries are used to key the shadow page in the\n\t * hash table.\n\t */\n\tgfn_t gfn;\n\tunion kvm_mmu_page_role role;\n\n\tu64 *spt;\n\t/* hold the gfn of each spte inside spt */\n\tgfn_t *gfns;\n\tbool unsync;\n\tint root_count;          /* Currently serving as active root */\n\tunsigned int unsync_children;\n\tunsigned long parent_ptes;\t/* Reverse mapping for parent_pte */\n\n\t/* The page is obsolete if mmu_valid_gen != kvm->arch.mmu_valid_gen.  */\n\tunsigned long mmu_valid_gen;\n\n\tDECLARE_BITMAP(unsync_child_bitmap, 512);\n\n#ifdef CONFIG_X86_32\n\t/*\n\t * Used out of the mmu-lock to avoid reading spte values while an\n\t * update is in progress; see the comments in __get_spte_lockless().\n\t */\n\tint clear_spte_count;\n#endif\n\n\t/* Number of writes since the last time traversal visited this page.  */\n\tint write_flooding_count;\n};\n\nstruct kvm_pio_request {\n\tunsigned long count;\n\tint in;\n\tint port;\n\tint size;\n};\n\n/*\n * x86 supports 3 paging modes (4-level 64-bit, 3-level 64-bit, and 2-level\n * 32-bit).  The kvm_mmu structure abstracts the details of the current mmu\n * mode.\n */\nstruct kvm_mmu {\n\tvoid (*set_cr3)(struct kvm_vcpu *vcpu, unsigned long root);\n\tunsigned long (*get_cr3)(struct kvm_vcpu *vcpu);\n\tu64 (*get_pdptr)(struct kvm_vcpu *vcpu, int index);\n\tint (*page_fault)(struct kvm_vcpu *vcpu, gva_t gva, u32 err,\n\t\t\t  bool prefault);\n\tvoid (*inject_page_fault)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_exception *fault);\n\tgpa_t (*gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t gva, u32 access,\n\t\t\t    struct x86_exception *exception);\n\tgpa_t (*translate_gpa)(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t       struct x86_exception *exception);\n\tint (*sync_page)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_mmu_page *sp);\n\tvoid (*invlpg)(struct kvm_vcpu *vcpu, gva_t gva);\n\tvoid (*update_pte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t   u64 *spte, const void *pte);\n\thpa_t root_hpa;\n\tint root_level;\n\tint shadow_root_level;\n\tunion kvm_mmu_page_role base_role;\n\tbool direct_map;\n\n\t/*\n\t * Bitmap; bit set = permission fault\n\t * Byte index: page fault error code [4:1]\n\t * Bit index: pte permissions in ACC_* format\n\t */\n\tu8 permissions[16];\n\n\tu64 *pae_root;\n\tu64 *lm_root;\n\tu64 rsvd_bits_mask[2][4];\n\tu64 bad_mt_xwr;\n\n\t/*\n\t * Bitmap: bit set = last pte in walk\n\t * index[0:1]: level (zero-based)\n\t * index[2]: pte.ps\n\t */\n\tu8 last_pte_bitmap;\n\n\tbool nx;\n\n\tu64 pdptrs[4]; /* pae */\n};\n\nenum pmc_type {\n\tKVM_PMC_GP = 0,\n\tKVM_PMC_FIXED,\n};\n\nstruct kvm_pmc {\n\tenum pmc_type type;\n\tu8 idx;\n\tu64 counter;\n\tu64 eventsel;\n\tstruct perf_event *perf_event;\n\tstruct kvm_vcpu *vcpu;\n};\n\nstruct kvm_pmu {\n\tunsigned nr_arch_gp_counters;\n\tunsigned nr_arch_fixed_counters;\n\tunsigned available_event_types;\n\tu64 fixed_ctr_ctrl;\n\tu64 global_ctrl;\n\tu64 global_status;\n\tu64 global_ovf_ctrl;\n\tu64 counter_bitmask[2];\n\tu64 global_ctrl_mask;\n\tu64 reserved_bits;\n\tu8 version;\n\tstruct kvm_pmc gp_counters[INTEL_PMC_MAX_GENERIC];\n\tstruct kvm_pmc fixed_counters[INTEL_PMC_MAX_FIXED];\n\tstruct irq_work irq_work;\n\tu64 reprogram_pmi;\n};\n\nenum {\n\tKVM_DEBUGREG_BP_ENABLED = 1,\n\tKVM_DEBUGREG_WONT_EXIT = 2,\n};\n\nstruct kvm_vcpu_arch {\n\t/*\n\t * rip and regs accesses must go through\n\t * kvm_{register,rip}_{read,write} functions.\n\t */\n\tunsigned long regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n\n\tunsigned long cr0;\n\tunsigned long cr0_guest_owned_bits;\n\tunsigned long cr2;\n\tunsigned long cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr8;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tbool tpr_access_reporting;\n\n\t/*\n\t * Paging state of the vcpu\n\t *\n\t * If the vcpu runs in guest mode with two level paging this still saves\n\t * the paging mode of the l1 guest. This context is always used to\n\t * handle faults.\n\t */\n\tstruct kvm_mmu mmu;\n\n\t/*\n\t * Paging state of an L2 guest (used for nested npt)\n\t *\n\t * This context will save all necessary information to walk page tables\n\t * of the an L2 guest. This context is only initialized for page table\n\t * walking and not for faulting since we never handle l2 page faults on\n\t * the host.\n\t */\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t * Pointer to the mmu context currently used for\n\t * gva_to_gpa translations.\n\t */\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\tstruct fpu guest_fpu;\n\tu64 xcr0;\n\tu64 guest_supported_xcr0;\n\tu32 guest_xstate_size;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool has_error_code;\n\t\tbool reinject;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool pending;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\t/* emulate context */\n\n\tstruct x86_emulate_ctxt emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_hva_cache pv_time;\n\tbool pv_time_enabled;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tu64 accum_steal;\n\t\tstruct gfn_to_hva_cache stime;\n\t\tstruct kvm_steal_time steal;\n\t} st;\n\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\n\tstruct mtrr_state_type mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_vapic;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_val;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\t/*\n\t * Indicate whether the access faults on its page table in guest\n\t * which is set when fix page fault and used to detect unhandeable\n\t * instruction.\n\t */\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n};\n\nstruct kvm_lpage_info {\n\tint write_count;\n};\n\nstruct kvm_arch_memory_slot {\n\tunsigned long *rmap[KVM_NR_PAGE_SIZES];\n\tstruct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];\n};\n\nstruct kvm_apic_map {\n\tstruct rcu_head rcu;\n\tu8 ldr_bits;\n\t/* fields bellow are used to decode ldr values in different modes */\n\tu32 cid_shift, cid_mask, lid_mask;\n\tstruct kvm_lapic *phys_map[256];\n\t/* first index is cluster id second is cpu id in a cluster */\n\tstruct kvm_lapic *logical_map[16][16];\n};\n\nstruct kvm_arch {\n\tunsigned int n_used_mmu_pages;\n\tunsigned int n_requested_mmu_pages;\n\tunsigned int n_max_mmu_pages;\n\tunsigned int indirect_shadow_pages;\n\tunsigned long mmu_valid_gen;\n\tstruct hlist_head mmu_page_hash[KVM_NUM_MMU_PAGES];\n\t/*\n\t * Hash table of struct kvm_mmu_page.\n\t */\n\tstruct list_head active_mmu_pages;\n\tstruct list_head zapped_obsolete_pages;\n\n\tstruct list_head assigned_dev_head;\n\tstruct iommu_domain *iommu_domain;\n\tbool iommu_noncoherent;\n#define __KVM_HAVE_ARCH_NONCOHERENT_DMA\n\tatomic_t noncoherent_dma_count;\n\tstruct kvm_pic *vpic;\n\tstruct kvm_ioapic *vioapic;\n\tstruct kvm_pit *vpit;\n\tint vapics_in_nmi_mode;\n\tstruct mutex apic_map_lock;\n\tstruct kvm_apic_map *apic_map;\n\n\tunsigned int tss_addr;\n\tbool apic_access_page_done;\n\n\tgpa_t wall_clock;\n\n\tbool ept_identity_pagetable_done;\n\tgpa_t ept_identity_map_addr;\n\n\tunsigned long irq_sources_bitmap;\n\ts64 kvmclock_offset;\n\traw_spinlock_t tsc_write_lock;\n\tu64 last_tsc_nsec;\n\tu64 last_tsc_write;\n\tu32 last_tsc_khz;\n\tu64 cur_tsc_nsec;\n\tu64 cur_tsc_write;\n\tu64 cur_tsc_offset;\n\tu64 cur_tsc_generation;\n\tint nr_vcpus_matched_tsc;\n\n\tspinlock_t pvclock_gtod_sync_lock;\n\tbool use_master_clock;\n\tu64 master_kernel_ns;\n\tcycle_t master_cycle_now;\n\tstruct delayed_work kvmclock_update_work;\n\tstruct delayed_work kvmclock_sync_work;\n\n\tstruct kvm_xen_hvm_config xen_hvm_config;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_guest_os_id;\n\tu64 hv_hypercall;\n\tu64 hv_tsc_page;\n\n\t#ifdef CONFIG_KVM_MMU_AUDIT\n\tint audit_point;\n\t#endif\n};\n\nstruct kvm_vm_stat {\n\tu32 mmu_shadow_zapped;\n\tu32 mmu_pte_write;\n\tu32 mmu_pte_updated;\n\tu32 mmu_pde_zapped;\n\tu32 mmu_flooded;\n\tu32 mmu_recycled;\n\tu32 mmu_cache_miss;\n\tu32 mmu_unsync;\n\tu32 remote_tlb_flush;\n\tu32 lpages;\n};\n\nstruct kvm_vcpu_stat {\n\tu32 pf_fixed;\n\tu32 pf_guest;\n\tu32 tlb_flush;\n\tu32 invlpg;\n\n\tu32 exits;\n\tu32 io_exits;\n\tu32 mmio_exits;\n\tu32 signal_exits;\n\tu32 irq_window_exits;\n\tu32 nmi_window_exits;\n\tu32 halt_exits;\n\tu32 halt_wakeup;\n\tu32 request_irq_exits;\n\tu32 irq_exits;\n\tu32 host_state_reload;\n\tu32 efer_reload;\n\tu32 fpu_reload;\n\tu32 insn_emulation;\n\tu32 insn_emulation_fail;\n\tu32 hypercalls;\n\tu32 irq_injections;\n\tu32 nmi_injections;\n};\n\nstruct x86_instruction_info;\n\nstruct msr_data {\n\tbool host_initiated;\n\tu32 index;\n\tu64 data;\n};\n\nstruct kvm_x86_ops {\n\tint (*cpu_has_kvm_support)(void);          /* __init */\n\tint (*disabled_by_bios)(void);             /* __init */\n\tint (*hardware_enable)(void);\n\tvoid (*hardware_disable)(void);\n\tvoid (*check_processor_compatibility)(void *rtn);\n\tint (*hardware_setup)(void);               /* __init */\n\tvoid (*hardware_unsetup)(void);            /* __exit */\n\tbool (*cpu_has_accelerated_tpr)(void);\n\tvoid (*cpuid_update)(struct kvm_vcpu *vcpu);\n\n\t/* Create, but do not attach this VCPU */\n\tstruct kvm_vcpu *(*vcpu_create)(struct kvm *kvm, unsigned id);\n\tvoid (*vcpu_free)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_reset)(struct kvm_vcpu *vcpu);\n\n\tvoid (*prepare_guest_switch)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_load)(struct kvm_vcpu *vcpu, int cpu);\n\tvoid (*vcpu_put)(struct kvm_vcpu *vcpu);\n\n\tvoid (*update_db_bp_intercept)(struct kvm_vcpu *vcpu);\n\tint (*get_msr)(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata);\n\tint (*set_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tu64 (*get_segment_base)(struct kvm_vcpu *vcpu, int seg);\n\tvoid (*get_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tint (*get_cpl)(struct kvm_vcpu *vcpu);\n\tvoid (*set_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tvoid (*get_cs_db_l_bits)(struct kvm_vcpu *vcpu, int *db, int *l);\n\tvoid (*decache_cr0_guest_bits)(struct kvm_vcpu *vcpu);\n\tvoid (*decache_cr3)(struct kvm_vcpu *vcpu);\n\tvoid (*decache_cr4_guest_bits)(struct kvm_vcpu *vcpu);\n\tvoid (*set_cr0)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*set_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\tint (*set_cr4)(struct kvm_vcpu *vcpu, unsigned long cr4);\n\tvoid (*set_efer)(struct kvm_vcpu *vcpu, u64 efer);\n\tvoid (*get_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*get_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tu64 (*get_dr6)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr6)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*sync_dirty_debug_regs)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr7)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);\n\tunsigned long (*get_rflags)(struct kvm_vcpu *vcpu);\n\tvoid (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);\n\tvoid (*fpu_deactivate)(struct kvm_vcpu *vcpu);\n\n\tvoid (*tlb_flush)(struct kvm_vcpu *vcpu);\n\n\tvoid (*run)(struct kvm_vcpu *vcpu);\n\tint (*handle_exit)(struct kvm_vcpu *vcpu);\n\tvoid (*skip_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*set_interrupt_shadow)(struct kvm_vcpu *vcpu, int mask);\n\tu32 (*get_interrupt_shadow)(struct kvm_vcpu *vcpu);\n\tvoid (*patch_hypercall)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned char *hypercall_addr);\n\tvoid (*set_irq)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi)(struct kvm_vcpu *vcpu);\n\tvoid (*queue_exception)(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject);\n\tvoid (*cancel_injection)(struct kvm_vcpu *vcpu);\n\tint (*interrupt_allowed)(struct kvm_vcpu *vcpu);\n\tint (*nmi_allowed)(struct kvm_vcpu *vcpu);\n\tbool (*get_nmi_mask)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi_mask)(struct kvm_vcpu *vcpu, bool masked);\n\tvoid (*enable_nmi_window)(struct kvm_vcpu *vcpu);\n\tvoid (*enable_irq_window)(struct kvm_vcpu *vcpu);\n\tvoid (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);\n\tint (*vm_has_apicv)(struct kvm *kvm);\n\tvoid (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);\n\tvoid (*hwapic_isr_update)(struct kvm *kvm, int isr);\n\tvoid (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);\n\tvoid (*set_virtual_x2apic_mode)(struct kvm_vcpu *vcpu, bool set);\n\tvoid (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu, hpa_t hpa);\n\tvoid (*deliver_posted_interrupt)(struct kvm_vcpu *vcpu, int vector);\n\tvoid (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);\n\tint (*set_tss_addr)(struct kvm *kvm, unsigned int addr);\n\tint (*get_tdp_level)(void);\n\tu64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);\n\tint (*get_lpage_level)(void);\n\tbool (*rdtscp_supported)(void);\n\tbool (*invpcid_supported)(void);\n\tvoid (*adjust_tsc_offset)(struct kvm_vcpu *vcpu, s64 adjustment, bool host);\n\n\tvoid (*set_tdp_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\n\tvoid (*set_supported_cpuid)(u32 func, struct kvm_cpuid_entry2 *entry);\n\n\tbool (*has_wbinvd_exit)(void);\n\n\tvoid (*set_tsc_khz)(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale);\n\tu64 (*read_tsc_offset)(struct kvm_vcpu *vcpu);\n\tvoid (*write_tsc_offset)(struct kvm_vcpu *vcpu, u64 offset);\n\n\tu64 (*compute_tsc_offset)(struct kvm_vcpu *vcpu, u64 target_tsc);\n\tu64 (*read_l1_tsc)(struct kvm_vcpu *vcpu, u64 host_tsc);\n\n\tvoid (*get_exit_info)(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2);\n\n\tint (*check_intercept)(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage);\n\tvoid (*handle_external_intr)(struct kvm_vcpu *vcpu);\n\tbool (*mpx_supported)(void);\n\n\tint (*check_nested_events)(struct kvm_vcpu *vcpu, bool external_intr);\n\n\tvoid (*sched_in)(struct kvm_vcpu *kvm, int cpu);\n};\n\nstruct kvm_arch_async_pf {\n\tu32 token;\n\tgfn_t gfn;\n\tunsigned long cr3;\n\tbool direct_map;\n};\n\nextern struct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset(vcpu, adjustment, false);\n}\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset(vcpu, adjustment, true);\n}\n\nint kvm_mmu_module_init(void);\nvoid kvm_mmu_module_exit(void);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu);\nint kvm_mmu_create(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_setup(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm, int slot);\nvoid kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask);\nvoid kvm_mmu_zap_all(struct kvm *kvm);\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm);\nunsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm);\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int kvm_nr_mmu_pages);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes);\nu8 kvm_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nextern bool tdp_enabled;\n\nu64 vcpu_tsc_khz(struct kvm_vcpu *vcpu);\n\n/* control of guest tsc rate supported? */\nextern bool kvm_has_tsc_control;\n/* minimum supported tsc_khz for guests */\nextern u32  kvm_min_guest_tsc_khz;\n/* maximum supported tsc_khz for guests */\nextern u32  kvm_max_guest_tsc_khz;\n\nenum emulation_result {\n\tEMULATE_DONE,         /* no further processing */\n\tEMULATE_USER_EXIT,    /* kvm_run ready for userspace exit */\n\tEMULATE_FAIL,         /* can't emulate this instruction */\n};\n\n#define EMULTYPE_NO_DECODE\t    (1 << 0)\n#define EMULTYPE_TRAP_UD\t    (1 << 1)\n#define EMULTYPE_SKIP\t\t    (1 << 2)\n#define EMULTYPE_RETRY\t\t    (1 << 3)\n#define EMULTYPE_NO_REEXECUTE\t    (1 << 4)\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, unsigned long cr2,\n\t\t\t    int emulation_type, void *insn, int insn_len);\n\nstatic inline int emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\tint emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}\n\nvoid kvm_enable_efer_bits(u64);\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer);\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *data);\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nstruct x86_emulate_ctxt;\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port);\nvoid kvm_emulate_cpuid(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt(struct kvm_vcpu *vcpu);\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu);\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nint kvm_load_segment_descriptor(struct kvm_vcpu *vcpu, u16 selector, int seg);\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3);\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val);\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val);\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l);\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata);\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu);\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nbool kvm_rdpmc(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault);\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t gfn, void *data, int offset, int len,\n\t\t\t    u32 access);\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl);\n\nstatic inline int __kvm_irq_line_state(unsigned long *irq_state,\n\t\t\t\t       int irq_source_id, int level)\n{\n\t/* Logical OR for level trig interrupt */\n\tif (level)\n\t\t__set_bit(irq_source_id, irq_state);\n\telse\n\t\t__clear_bit(irq_source_id, irq_state);\n\n\treturn !!(*irq_state);\n}\n\nint kvm_pic_set_irq(struct kvm_pic *pic, int irq, int irq_source_id, int level);\nvoid kvm_pic_clear_all(struct kvm_pic *pic, int irq_source_id);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu);\n\nint fx_init(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t       const u8 *new, int bytes);\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva);\nvoid __kvm_mmu_free_some_pages(struct kvm_vcpu *vcpu);\nint kvm_mmu_load(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu);\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception);\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t gva, u32 error_code,\n\t\t       void *insn, int insn_len);\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);\nvoid kvm_mmu_new_cr3(struct kvm_vcpu *vcpu);\n\nvoid kvm_enable_tdp(void);\nvoid kvm_disable_tdp(void);\n\nstatic inline gpa_t translate_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn gpa;\n}\n\nstatic inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n{\n\tstruct page *page = pfn_to_page(shadow_page >> PAGE_SHIFT);\n\n\treturn (struct kvm_mmu_page *)page_private(page);\n}\n\nstatic inline u16 kvm_read_ldt(void)\n{\n\tu16 ldt;\n\tasm(\"sldt %0\" : \"=g\"(ldt));\n\treturn ldt;\n}\n\nstatic inline void kvm_load_ldt(u16 sel)\n{\n\tasm(\"lldt %0\" : : \"rm\"(sel));\n}\n\n#ifdef CONFIG_X86_64\nstatic inline unsigned long read_msr(unsigned long msr)\n{\n\tu64 value;\n\n\trdmsrl(msr, value);\n\treturn value;\n}\n#endif\n\nstatic inline u32 get_rdx_init_val(void)\n{\n\treturn 0x600; /* P6 family */\n}\n\nstatic inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n{\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n}\n\n#define TSS_IOPB_BASE_OFFSET 0x66\n#define TSS_BASE_SIZE 0x68\n#define TSS_IOPB_SIZE (65536 / 8)\n#define TSS_REDIRECTION_SIZE (256 / 8)\n#define RMODE_TSS_SIZE\t\t\t\t\t\t\t\\\n\t(TSS_BASE_SIZE + TSS_REDIRECTION_SIZE + TSS_IOPB_SIZE + 1)\n\nenum {\n\tTASK_SWITCH_CALL = 0,\n\tTASK_SWITCH_IRET = 1,\n\tTASK_SWITCH_JMP = 2,\n\tTASK_SWITCH_GATE = 3,\n};\n\n#define HF_GIF_MASK\t\t(1 << 0)\n#define HF_HIF_MASK\t\t(1 << 1)\n#define HF_VINTR_MASK\t\t(1 << 2)\n#define HF_NMI_MASK\t\t(1 << 3)\n#define HF_IRET_MASK\t\t(1 << 4)\n#define HF_GUEST_MASK\t\t(1 << 5) /* VCPU is in guest-mode */\n\n/*\n * Hardware virtualization extension instructions may fault if a\n * reboot turns off virtualization while processes are running.\n * Trap the fault and ignore the instruction if that happens.\n */\nasmlinkage void kvm_spurious_fault(void);\n\n#define ____kvm_handle_fault_on_reboot(insn, cleanup_insn)\t\\\n\t\"666: \" insn \"\\n\\t\" \\\n\t\"668: \\n\\t\"                           \\\n\t\".pushsection .fixup, \\\"ax\\\" \\n\" \\\n\t\"667: \\n\\t\" \\\n\tcleanup_insn \"\\n\\t\"\t\t      \\\n\t\"cmpb $0, kvm_rebooting \\n\\t\"\t      \\\n\t\"jne 668b \\n\\t\"      \t\t      \\\n\t__ASM_SIZE(push) \" $666b \\n\\t\"\t      \\\n\t\"call kvm_spurious_fault \\n\\t\"\t      \\\n\t\".popsection \\n\\t\" \\\n\t_ASM_EXTABLE(666b, 667b)\n\n#define __kvm_handle_fault_on_reboot(insn)\t\t\\\n\t____kvm_handle_fault_on_reboot(insn, \"\")\n\n#define KVM_ARCH_WANT_MMU_NOTIFIER\nint kvm_unmap_hva(struct kvm *kvm, unsigned long hva);\nint kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end);\nint kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end);\nint kvm_test_age_hva(struct kvm *kvm, unsigned long hva);\nvoid kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte);\nint cpuid_maxphyaddr(struct kvm_vcpu *vcpu);\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v);\nint kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v);\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu);\nvoid kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address);\n\nvoid kvm_define_shared_msr(unsigned index, u32 msr);\nvoid kvm_set_shared_msr(unsigned index, u64 val, u64 mask);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip);\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work);\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_async_pf *work);\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu);\nextern bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err);\n\nint kvm_is_in_guest(void);\n\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_cpuid_update(struct kvm_vcpu *vcpu);\nbool kvm_pmu_msr(struct kvm_vcpu *vcpu, u32 msr);\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\nint kvm_pmu_check_pmc(struct kvm_vcpu *vcpu, unsigned pmc);\nint kvm_pmu_read_pmc(struct kvm_vcpu *vcpu, unsigned pmc, u64 *data);\nvoid kvm_handle_pmu_event(struct kvm_vcpu *vcpu);\nvoid kvm_deliver_pmi(struct kvm_vcpu *vcpu);\n\n#endif /* _ASM_X86_KVM_HOST_H */\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * AMD SVM support\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Avi Kivity   <avi@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/ftrace_event.h>\n#include <linux/slab.h>\n\n#include <asm/perf_event.h>\n#include <asm/tlbflush.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/kvm_para.h>\n\n#include <asm/virtext.h>\n#include \"trace.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id svm_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_SVM),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, svm_cpu_id);\n\n#define IOPM_ALLOC_ORDER 2\n#define MSRPM_ALLOC_ORDER 1\n\n#define SEG_TYPE_LDT 2\n#define SEG_TYPE_BUSY_TSS16 3\n\n#define SVM_FEATURE_NPT            (1 <<  0)\n#define SVM_FEATURE_LBRV           (1 <<  1)\n#define SVM_FEATURE_SVML           (1 <<  2)\n#define SVM_FEATURE_NRIP           (1 <<  3)\n#define SVM_FEATURE_TSC_RATE       (1 <<  4)\n#define SVM_FEATURE_VMCB_CLEAN     (1 <<  5)\n#define SVM_FEATURE_FLUSH_ASID     (1 <<  6)\n#define SVM_FEATURE_DECODE_ASSIST  (1 <<  7)\n#define SVM_FEATURE_PAUSE_FILTER   (1 << 10)\n\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n\n#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))\n\n#define TSC_RATIO_RSVD          0xffffff0000000000ULL\n#define TSC_RATIO_MIN\t\t0x0000000000000001ULL\n#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL\n\nstatic bool erratum_383_found __read_mostly;\n\nstatic const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n};\n\n#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)\n\nstruct kvm_vcpu;\n\nstruct nested_state {\n\tstruct vmcb *hsave;\n\tu64 hsave_msr;\n\tu64 vm_cr_msr;\n\tu64 vmcb;\n\n\t/* These are the merged vectors */\n\tu32 *msrpm;\n\n\t/* gpa pointers to the real vectors */\n\tu64 vmcb_msrpm;\n\tu64 vmcb_iopm;\n\n\t/* A VMEXIT is required but not yet emulated */\n\tbool exit_required;\n\n\t/* cache for intercepts of the guest */\n\tu32 intercept_cr;\n\tu32 intercept_dr;\n\tu32 intercept_exceptions;\n\tu64 intercept;\n\n\t/* Nested Paging related state */\n\tu64 nested_cr3;\n};\n\n#define MSRPM_OFFSETS\t16\nstatic u32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;\n\n/*\n * Set osvw_len to higher value when updated Revision Guides\n * are published and we know what the new status bits are\n */\nstatic uint64_t osvw_len = 4, osvw_status;\n\nstruct vcpu_svm {\n\tstruct kvm_vcpu vcpu;\n\tstruct vmcb *vmcb;\n\tunsigned long vmcb_pa;\n\tstruct svm_cpu_data *svm_data;\n\tuint64_t asid_generation;\n\tuint64_t sysenter_esp;\n\tuint64_t sysenter_eip;\n\n\tu64 next_rip;\n\n\tu64 host_user_msrs[NR_HOST_SAVE_USER_MSRS];\n\tstruct {\n\t\tu16 fs;\n\t\tu16 gs;\n\t\tu16 ldt;\n\t\tu64 gs_base;\n\t} host;\n\n\tu32 *msrpm;\n\n\tulong nmi_iret_rip;\n\n\tstruct nested_state nested;\n\n\tbool nmi_singlestep;\n\n\tunsigned int3_injected;\n\tunsigned long int3_rip;\n\tu32 apf_reason;\n\n\tu64  tsc_ratio;\n};\n\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\n/* enable NPT for AMD64 and X86 with PAE */\n#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)\nstatic bool npt_enabled = true;\n#else\nstatic bool npt_enabled;\n#endif\n\n/* allow nested paging (virtualized MMU) for all guests */\nstatic int npt = true;\nmodule_param(npt, int, S_IRUGO);\n\n/* allow nested virtualization in KVM/SVM */\nstatic int nested = true;\nmodule_param(nested, int, S_IRUGO);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\nstatic u64 __scale_tsc(u64 ratio, u64 tsc);\n\nenum {\n\tVMCB_INTERCEPTS, /* Intercept vectors, TSC offset,\n\t\t\t    pause filter count */\n\tVMCB_PERM_MAP,   /* IOPM Base and MSRPM Base */\n\tVMCB_ASID,\t /* ASID */\n\tVMCB_INTR,\t /* int_ctl, int_vector */\n\tVMCB_NPT,        /* npt_en, nCR3, gPAT */\n\tVMCB_CR,\t /* CR0, CR3, CR4, EFER */\n\tVMCB_DR,         /* DR6, DR7 */\n\tVMCB_DT,         /* GDT, IDT */\n\tVMCB_SEG,        /* CS, DS, SS, ES, CPL */\n\tVMCB_CR2,        /* CR2 only */\n\tVMCB_LBR,        /* DBGCTL, BR_FROM, BR_TO, LAST_EX_FROM, LAST_EX_TO */\n\tVMCB_DIRTY_MAX,\n};\n\n/* TPR and CR2 are always written before VMRUN */\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}\n\nstatic unsigned long iopm_base;\n\nstruct kvm_ldttss_desc {\n\tu16 limit0;\n\tu16 base0;\n\tunsigned base1:8, type:5, dpl:2, p:1;\n\tunsigned limit1:4, zero0:3, g:1, base2:8;\n\tu32 base3;\n\tu32 zero1;\n} __attribute__((packed));\n\nstruct svm_cpu_data {\n\tint cpu;\n\n\tu64 asid_generation;\n\tu32 max_asid;\n\tu32 next_asid;\n\tstruct kvm_ldttss_desc *tss_desc;\n\n\tstruct page *save_area;\n};\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstruct svm_init_data {\n\tint cpu;\n\tint r;\n};\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSRS_RANGE_SIZE 2048\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}\n\n#define MAX_INST_SIZE 15\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}\n\nstatic inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(SVM_INVLPGA) : : \"a\"(addr), \"c\"(asid));\n}\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0)\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tif (nr == BP_VECTOR && !static_cpu_has(X86_FEATURE_NRIPS)) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_ptr gdt_descr;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\n\tnative_store_gdt(&gdt_descr);\n\tgdt = (struct desc_struct *)gdt_descr.address;\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 max;\n\n\t\tkvm_has_tsc_control = true;\n\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated needed because it will always\n\t\t * be 1 on all machines and a value of 0 is used to disable\n\t\t * tsc-scaling for the vcpu.\n\t\t */\n\t\tmax = min(0x7fffffffULL, __scale_tsc(tsc_khz, TSC_RATIO_MAX));\n\n\t\tkvm_max_guest_tsc_khz = max;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging disabled\\n\");\n\t\tnpt_enabled = false;\n\t}\n\n\tif (npt_enabled) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging enabled\\n\");\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\treturn 0;\n\nerr:\n\t__free_pages(iopm_pages, IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n\treturn r;\n}\n\nstatic __exit void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\tu64 mult, frac, _tsc;\n\n\tmult  = ratio >> 32;\n\tfrac  = ratio & ((1ULL << 32) - 1);\n\n\t_tsc  = tsc;\n\t_tsc *= mult;\n\t_tsc += (tsc >> 32) * frac;\n\t_tsc += ((tsc & ((1ULL << 32) - 1)) * frac) >> 32;\n\n\treturn _tsc;\n}\n\nstatic u64 svm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 _tsc = tsc;\n\n\tif (svm->tsc_ratio != TSC_RATIO_DEFAULT)\n\t\t_tsc = __scale_tsc(svm->tsc_ratio, tsc);\n\n\treturn _tsc;\n}\n\nstatic void svm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 ratio;\n\tu64 khz;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tsvm->tsc_ratio = TSC_RATIO_DEFAULT;\n\t\treturn;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t} else\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\treturn;\n\t}\n\n\tkhz = user_tsc_khz;\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = khz << 32;\n\tdo_div(ratio, tsc_khz);\n\n\tif (ratio == 0 || ratio & TSC_RATIO_RSVD) {\n\t\tWARN_ONCE(1, \"Invalid TSC ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t\tuser_tsc_khz);\n\t\treturn;\n\t}\n\tsvm->tsc_ratio             = ratio;\n}\n\nstatic u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}\n\nstatic void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic void svm_adjust_tsc_offset(struct kvm_vcpu *vcpu, s64 adjustment, bool host)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tWARN_ON(adjustment < 0);\n\tif (host)\n\t\tadjustment = svm_scale_tsc(vcpu, adjustment);\n\n\tsvm->vmcb->control.tsc_offset += adjustment;\n\tif (is_guest_mode(vcpu))\n\t\tsvm->nested.hsave->control.tsc_offset += adjustment;\n\telse\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t     svm->vmcb->control.tsc_offset - adjustment,\n\t\t\t\t     svm->vmcb->control.tsc_offset);\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic u64 svm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = svm_scale_tsc(vcpu, native_read_tsc());\n\n\treturn target_tsc - tsc;\n}\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * This is the guest-visible cr0 value.\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t */\n\tsvm->vcpu.arch.cr0 = 0;\n\t(void)kvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = 0x0007040600070406ULL;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n}\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, eax);\n}\n\nstatic struct kvm_vcpu *svm_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tsvm = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tif (!svm) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsvm->tsc_ratio = TSC_RATIO_DEFAULT;\n\n\terr = kvm_vcpu_init(&svm->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_svm;\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto uninit;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = page_to_pfn(page) << PAGE_SHIFT;\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\tif (kvm_vcpu_is_bsp(&svm->vcpu))\n\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\n\tsvm_init_osvw(&svm->vcpu);\n\n\treturn &svm->vcpu;\n\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nuninit:\n\tkvm_vcpu_uninit(&svm->vcpu);\nfree_svm:\n\tkmem_cache_free(kvm_vcpu_cache, svm);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t__free_page(pfn_to_page(svm->vmcb_pa >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, svm);\n}\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR) &&\n\t    svm->tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t__this_cpu_write(current_tsc_ratio, svm->tsc_ratio);\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, svm->tsc_ratio);\n\t}\n}\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.rflags;\n}\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n       /*\n        * Any change of EFLAGS.VM is accompained by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present || (var->type == 0);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_decache_cr3(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}\n\nstatic int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = read_cr4() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}\n\nstatic void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}\n\nstatic void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu32 error_code;\n\tint r = 1;\n\n\tswitch (svm->apf_reason) {\n\tdefault:\n\t\terror_code = svm->vmcb->control.exit_info_1;\n\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\t\tif (!npt_enabled && kvm_event_needs_reinjection(&svm->vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(&svm->vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tsvm->vmcb->control.insn_bytes,\n\t\t\tsvm->vmcb->control.insn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}\n\nstatic int ud_interception(struct vcpu_svm *svm)\n{\n\tint er;\n\n\ter = emulate_instruction(&svm->vcpu, EMULTYPE_TRAP_UD);\n\tif (er != EMULATE_DONE)\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}\n\nstatic int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}\n\nstatic int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}\n\nstatic int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}\n\nstatic int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int halt_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 1;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_emulate_halt(&svm->vcpu);\n}\n\nstatic int vmmcall_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_emulate_hypercall(&svm->vcpu);\n\treturn 1;\n}\n\nstatic unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.nested_cr3;\n}\n\nstatic u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr3 = svm->nested.nested_cr3;\n\tu64 pdpte;\n\tint ret;\n\n\tret = kvm_read_guest_page(vcpu->kvm, gpa_to_gfn(cr3), &pdpte,\n\t\t\t\t  offset_in_page(cr3) + index * 8, 8);\n\tif (ret)\n\t\treturn 0;\n\treturn pdpte;\n}\n\nstatic void nested_svm_set_tdp_cr3(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t/*\n\t\t * TODO: track the cause of the nested page fault, and\n\t\t * correctly fill in the high bits of exit_info_1.\n\t\t */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1 = (1ULL << 32);\n\t\tsvm->vmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tsvm->vmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tsvm->vmcb->control.exit_info_1 |= fault->error_code;\n\n\t/*\n\t * The present bit is always zero for page structure faults on real\n\t * hardware.\n\t */\n\tif (svm->vmcb->control.exit_info_1 & (2ULL << 32))\n\t\tsvm->vmcb->control.exit_info_1 &= ~1;\n\n\tnested_svm_vmexit(svm);\n}\n\nstatic void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_init_shadow_mmu(vcpu, &vcpu->arch.mmu);\n\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}\n\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}\n\n/* This function returns true if it is save to enable the irq window */\nstatic inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This function returns true if it is save to enable the nmi window */\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}\n\nstatic int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_read_guest(svm->vcpu.kvm, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_read_guest(svm->vcpu.kvm, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}\n\n/*\n * If this function returns true, this #vmexit was already handled\n */\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}\n\nstatic inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\tnested_vmcb->control.next_rip          = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}\n\nstatic bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_read_guest(svm->vcpu.kvm, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}\n\nstatic bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}\n\nstatic void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}\n\nstatic int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}\n\nstatic int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}\n\nstatic int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/* Save rip after vmrun instruction */\n\tkvm_rip_write(&svm->vcpu, kvm_rip_read(&svm->vcpu) + 3);\n\n\tif (!nested_svm_vmrun(svm))\n\t\treturn 1;\n\n\tif (!nested_svm_vmrun_msrpm(svm))\n\t\tgoto failed;\n\n\treturn 1;\n\nfailed:\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\n\treturn 1;\n}\n\nstatic int stgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn 1;\n}\n\nstatic int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\n\treturn 1;\n}\n\nstatic int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, vcpu->arch.regs[VCPU_REGS_RCX],\n\t\t\t  vcpu->arch.regs[VCPU_REGS_RAX]);\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, vcpu->arch.regs[VCPU_REGS_RAX]);\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, svm->vcpu.arch.regs[VCPU_REGS_RAX]);\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}\n\nstatic int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR)))\n\t\tskip_emulated_instruction(&svm->vcpu);\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\tif (kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t\thas_error_code, error_code) == EMULATE_FAIL) {\n\t\tsvm->vcpu.run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tsvm->vcpu.run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tsvm->vcpu.run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int cpuid_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tkvm_emulate_cpuid(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}\n\nstatic int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_NRIPS))\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}\n\nbool check_selective_cr0_intercepted(struct vcpu_svm *svm, unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}\n\n#define CR_VALID (1ULL << 63)\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}\n\nstatic int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\tint err;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\terr = kvm_get_dr(&svm->vcpu, dr, &val);\n\t\tif (!err)\n\t\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn 1;\n}\n\nstatic int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (irqchip_in_kernel(svm->vcpu.kvm))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}\n\nstatic u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(to_svm(vcpu));\n\treturn vmcb->control.tsc_offset +\n\t\tsvm_scale_tsc(vcpu, host_tsc);\n}\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 *data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC: {\n\t\t*data = svm->vmcb->control.tsc_offset +\n\t\t\tsvm_scale_tsc(vcpu, native_read_tsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\t*data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\t*data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\t*data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\t*data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\t*data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\t*data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\t*data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t*data = svm->sysenter_esp;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\t*data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\t*data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\t*data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\t*data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\t*data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\t*data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\t*data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\t*data = 0x01000065;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, ecx, data);\n\t}\n\treturn 0;\n}\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\n\tif (svm_get_msr(&svm->vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, data);\n\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RAX] = data & 0xffffffff;\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RDX] = data >> 32;\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr);\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n\nstatic int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}\n\nstatic int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\t/*\n\t * If the user space waits to inject interrupts, exit as soon as\n\t * possible\n\t */\n\tif (!irqchip_in_kernel(svm->vcpu.kvm) &&\n\t    kvm_run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(&svm->vcpu)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int pause_interception(struct vcpu_svm *svm)\n{\n\tkvm_vcpu_on_spin(&(svm->vcpu));\n\treturn 1;\n}\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}\n\nstatic int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}\n\nstatic int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}\n\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= emulate_on_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = emulate_on_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n};\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}\n\nstatic int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tkvm_run->hw.hardware_exit_reason = exit_code;\n\t\treturn 0;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}\n\nstatic inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}\n\nstatic void svm_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\treturn;\n}\n\nstatic int svm_vm_has_apicv(struct kvm *kvm)\n{\n\treturn 0;\n}\n\nstatic void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}\n\nstatic void svm_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\treturn;\n}\n\nstatic void svm_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tret = !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn ret && !(svm->vcpu.arch.hflags & HF_VINTR_MASK);\n\n\treturn ret;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept.\n\t */\n\tif (gif_set(svm) && nested_svm_intr(svm)) {\n\t\tsvm_set_vintr(svm);\n\t\tsvm_inject_irq(svm, 0x0);\n\t}\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}\n\nstatic int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}\n\nstatic void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}\n\nstatic void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\ttrace_kvm_exit(svm->vmcb->control.exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_handle_nmi(&svm->vcpu);\n\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_handle_nmi(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}\n\nstatic void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic void set_tdp_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t/* Also sync guest cr3 here in case we live migrate */\n\tsvm->vmcb->save.cr3 = kvm_read_cr3(vcpu);\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}\n\nstatic void svm_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = 0;\n}\n\nstatic bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}\n\nstatic void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tswitch (func) {\n\tcase 0x80000001:\n\t\tif (nested)\n\t\t\tentry->ecx |= (1 << 2); /* Set SVM bit */\n\t\tbreak;\n\tcase 0x8000000A:\n\t\tentry->eax = 1; /* SVM revision 1 */\n\t\tentry->ebx = 8; /* Lets support 8 ASIDs in case we add proper\n\t\t\t\t   ASID emulation to nested SVM */\n\t\tentry->ecx = 0; /* Reserved */\n\t\tentry->edx = 0; /* Per default do not support any\n\t\t\t\t   additional features */\n\n\t\t/* Support next_rip if host supports it */\n\t\tif (boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tentry->edx |= SVM_FEATURE_NRIP;\n\n\t\t/* Support NPT for the guest if enabled */\n\t\tif (npt_enabled)\n\t\t\tentry->edx |= SVM_FEATURE_NPT;\n\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_lpage_level(void)\n{\n\treturn PT_PDPE_LEVEL;\n}\n\nstatic bool svm_rdtscp_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_invpcid_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_mpx_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}\n\nstatic void svm_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tset_exception_intercept(svm, NM_VECTOR);\n\tupdate_cr0_intercept(svm);\n}\n\n#define PRE_EX(exit)  { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_PRE_EXCEPT, }\n#define POST_EX(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_EXCEPT, }\n#define POST_MEM(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_MEMACCESS, }\n\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n};\n\n#undef PRE_EX\n#undef POST_EX\n#undef POST_MEM\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}\n\nstatic void svm_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tlocal_irq_enable();\n}\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n}\n\nstatic struct kvm_x86_ops svm_x86_ops = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.cpu_has_accelerated_tpr = svm_cpu_has_accelerated_tpr,\n\n\t.vcpu_create = svm_create_vcpu,\n\t.vcpu_free = svm_free_vcpu,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.prepare_guest_switch = svm_prepare_guest_switch,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\n\t.update_db_bp_intercept = update_db_bp_intercept,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = kvm_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = svm_decache_cr0_guest_bits,\n\t.decache_cr3 = svm_decache_cr3,\n\t.decache_cr4_guest_bits = svm_decache_cr4_guest_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.set_cr3 = svm_set_cr3,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.get_dr6 = svm_get_dr6,\n\t.set_dr6 = svm_set_dr6,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\t.fpu_deactivate = svm_fpu_deactivate,\n\n\t.tlb_flush = svm_flush_tlb,\n\n\t.run = svm_vcpu_run,\n\t.handle_exit = handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.set_irq = svm_set_irq,\n\t.set_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,\n\t.vm_has_apicv = svm_vm_has_apicv,\n\t.load_eoi_exitmap = svm_load_eoi_exitmap,\n\t.hwapic_isr_update = svm_hwapic_isr_update,\n\t.sync_pir_to_irr = svm_sync_pir_to_irr,\n\n\t.set_tss_addr = svm_set_tss_addr,\n\t.get_tdp_level = get_npt_level,\n\t.get_mt_mask = svm_get_mt_mask,\n\n\t.get_exit_info = svm_get_exit_info,\n\n\t.get_lpage_level = svm_get_lpage_level,\n\n\t.cpuid_update = svm_cpuid_update,\n\n\t.rdtscp_supported = svm_rdtscp_supported,\n\t.invpcid_supported = svm_invpcid_supported,\n\t.mpx_supported = svm_mpx_supported,\n\n\t.set_supported_cpuid = svm_set_supported_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.set_tsc_khz = svm_set_tsc_khz,\n\t.read_tsc_offset = svm_read_tsc_offset,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.adjust_tsc_offset = svm_adjust_tsc_offset,\n\t.compute_tsc_offset = svm_compute_tsc_offset,\n\t.read_l1_tsc = svm_read_l1_tsc,\n\n\t.set_tdp_cr3 = set_tdp_cr3,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_external_intr = svm_handle_external_intr,\n\n\t.sched_in = svm_sched_in,\n};\n\nstatic int __init svm_init(void)\n{\n\treturn kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}\n\nmodule_init(svm_init)\nmodule_exit(svm_exit)\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"cpuid.h\"\n\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/ftrace_event.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/hrtimer.h>\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n\n#include <asm/io.h>\n#include <asm/desc.h>\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/xcr.h>\n#include <asm/perf_event.h>\n#include <asm/debugreg.h>\n#include <asm/kexec.h>\n\n#include \"trace.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n#define __ex_clear(x, reg) \\\n\t____kvm_handle_fault_on_reboot(x, \"xor \" reg \" , \" reg)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_VMX),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n\nstatic bool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly vmm_exclusive = 1;\nmodule_param(vmm_exclusive, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_apicv = 1;\nmodule_param(enable_apicv, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_shadow_vmcs = 1;\nmodule_param_named(enable_shadow_vmcs, enable_shadow_vmcs, bool, S_IRUGO);\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 0;\nmodule_param(nested, bool, S_IRUGO);\n\n#define KVM_GUEST_CR0_MASK (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST (X86_CR0_WP | X86_CR0_NE)\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT)\n\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE 5\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\n#define KVM_VMX_DEFAULT_PLE_GAP           128\n#define KVM_VMX_DEFAULT_PLE_WINDOW        4096\n#define KVM_VMX_DEFAULT_PLE_WINDOW_GROW   2\n#define KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK 0\n#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    \\\n\t\tINT_MAX / KVM_VMX_DEFAULT_PLE_WINDOW_GROW\n\nstatic int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, int, S_IRUGO);\n\nstatic int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, int, S_IRUGO);\n\n/* Default doubles per-vcpu window every exit. */\nstatic int ple_window_grow = KVM_VMX_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, int, S_IRUGO);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic int ple_window_shrink = KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, int, S_IRUGO);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic int ple_window_actual_max = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, int, S_IRUGO);\n\nextern const ulong vmx_return;\n\n#define NR_AUTOLOAD_MSRS 8\n#define VMCS02_POOL_SIZE 1\n\nstruct vmcs {\n\tu32 revision_id;\n\tu32 abort;\n\tchar data[0];\n};\n\n/*\n * Track a VMCS that may be loaded on a certain CPU. If it is (cpu!=-1), also\n * remember whether it was VMLAUNCHed, and maintain a linked list of all VMCSs\n * loaded on this CPU (so we can clear them if the CPU goes down).\n */\nstruct loaded_vmcs {\n\tstruct vmcs *vmcs;\n\tint cpu;\n\tint launched;\n\tstruct list_head loaded_vmcss_on_cpu_link;\n};\n\nstruct shared_msr_entry {\n\tunsigned index;\n\tu64 data;\n\tu64 mask;\n};\n\n/*\n * struct vmcs12 describes the state that our guest hypervisor (L1) keeps for a\n * single nested guest (L2), hence the name vmcs12. Any VMX implementation has\n * a VMCS structure, and vmcs12 is our emulated VMX's VMCS. This structure is\n * stored in guest memory specified by VMPTRLD, but is opaque to the guest,\n * which must access it using VMREAD/VMWRITE/VMCLEAR instructions.\n * More than one of these structures may exist, if L1 runs multiple L2 guests.\n * nested_vmx_run() will use the data here to build a vmcs02: a VMCS for the\n * underlying hardware which will be used to run L2.\n * This structure is packed to ensure that its layout is identical across\n * machines (necessary for live migration).\n * If there are changes in this struct, VMCS12_REVISION must be changed.\n */\ntypedef u64 natural_width;\nstruct __packed vmcs12 {\n\t/* According to the Intel spec, a VMCS region must start with the\n\t * following two fields. Then follow implementation-specific data.\n\t */\n\tu32 revision_id;\n\tu32 abort;\n\n\tu32 launch_state; /* set to 0 by VMCLEAR, to 1 by VMLAUNCH */\n\tu32 padding[7]; /* room for future expansion */\n\n\tu64 io_bitmap_a;\n\tu64 io_bitmap_b;\n\tu64 msr_bitmap;\n\tu64 vm_exit_msr_store_addr;\n\tu64 vm_exit_msr_load_addr;\n\tu64 vm_entry_msr_load_addr;\n\tu64 tsc_offset;\n\tu64 virtual_apic_page_addr;\n\tu64 apic_access_addr;\n\tu64 ept_pointer;\n\tu64 guest_physical_address;\n\tu64 vmcs_link_pointer;\n\tu64 guest_ia32_debugctl;\n\tu64 guest_ia32_pat;\n\tu64 guest_ia32_efer;\n\tu64 guest_ia32_perf_global_ctrl;\n\tu64 guest_pdptr0;\n\tu64 guest_pdptr1;\n\tu64 guest_pdptr2;\n\tu64 guest_pdptr3;\n\tu64 guest_bndcfgs;\n\tu64 host_ia32_pat;\n\tu64 host_ia32_efer;\n\tu64 host_ia32_perf_global_ctrl;\n\tu64 padding64[8]; /* room for future expansion */\n\t/*\n\t * To allow migration of L1 (complete with its L2 guests) between\n\t * machines of different natural widths (32 or 64 bit), we cannot have\n\t * unsigned long fields with no explict size. We use u64 (aliased\n\t * natural_width) instead. Luckily, x86 is little-endian.\n\t */\n\tnatural_width cr0_guest_host_mask;\n\tnatural_width cr4_guest_host_mask;\n\tnatural_width cr0_read_shadow;\n\tnatural_width cr4_read_shadow;\n\tnatural_width cr3_target_value0;\n\tnatural_width cr3_target_value1;\n\tnatural_width cr3_target_value2;\n\tnatural_width cr3_target_value3;\n\tnatural_width exit_qualification;\n\tnatural_width guest_linear_address;\n\tnatural_width guest_cr0;\n\tnatural_width guest_cr3;\n\tnatural_width guest_cr4;\n\tnatural_width guest_es_base;\n\tnatural_width guest_cs_base;\n\tnatural_width guest_ss_base;\n\tnatural_width guest_ds_base;\n\tnatural_width guest_fs_base;\n\tnatural_width guest_gs_base;\n\tnatural_width guest_ldtr_base;\n\tnatural_width guest_tr_base;\n\tnatural_width guest_gdtr_base;\n\tnatural_width guest_idtr_base;\n\tnatural_width guest_dr7;\n\tnatural_width guest_rsp;\n\tnatural_width guest_rip;\n\tnatural_width guest_rflags;\n\tnatural_width guest_pending_dbg_exceptions;\n\tnatural_width guest_sysenter_esp;\n\tnatural_width guest_sysenter_eip;\n\tnatural_width host_cr0;\n\tnatural_width host_cr3;\n\tnatural_width host_cr4;\n\tnatural_width host_fs_base;\n\tnatural_width host_gs_base;\n\tnatural_width host_tr_base;\n\tnatural_width host_gdtr_base;\n\tnatural_width host_idtr_base;\n\tnatural_width host_ia32_sysenter_esp;\n\tnatural_width host_ia32_sysenter_eip;\n\tnatural_width host_rsp;\n\tnatural_width host_rip;\n\tnatural_width paddingl[8]; /* room for future expansion */\n\tu32 pin_based_vm_exec_control;\n\tu32 cpu_based_vm_exec_control;\n\tu32 exception_bitmap;\n\tu32 page_fault_error_code_mask;\n\tu32 page_fault_error_code_match;\n\tu32 cr3_target_count;\n\tu32 vm_exit_controls;\n\tu32 vm_exit_msr_store_count;\n\tu32 vm_exit_msr_load_count;\n\tu32 vm_entry_controls;\n\tu32 vm_entry_msr_load_count;\n\tu32 vm_entry_intr_info_field;\n\tu32 vm_entry_exception_error_code;\n\tu32 vm_entry_instruction_len;\n\tu32 tpr_threshold;\n\tu32 secondary_vm_exec_control;\n\tu32 vm_instruction_error;\n\tu32 vm_exit_reason;\n\tu32 vm_exit_intr_info;\n\tu32 vm_exit_intr_error_code;\n\tu32 idt_vectoring_info_field;\n\tu32 idt_vectoring_error_code;\n\tu32 vm_exit_instruction_len;\n\tu32 vmx_instruction_info;\n\tu32 guest_es_limit;\n\tu32 guest_cs_limit;\n\tu32 guest_ss_limit;\n\tu32 guest_ds_limit;\n\tu32 guest_fs_limit;\n\tu32 guest_gs_limit;\n\tu32 guest_ldtr_limit;\n\tu32 guest_tr_limit;\n\tu32 guest_gdtr_limit;\n\tu32 guest_idtr_limit;\n\tu32 guest_es_ar_bytes;\n\tu32 guest_cs_ar_bytes;\n\tu32 guest_ss_ar_bytes;\n\tu32 guest_ds_ar_bytes;\n\tu32 guest_fs_ar_bytes;\n\tu32 guest_gs_ar_bytes;\n\tu32 guest_ldtr_ar_bytes;\n\tu32 guest_tr_ar_bytes;\n\tu32 guest_interruptibility_info;\n\tu32 guest_activity_state;\n\tu32 guest_sysenter_cs;\n\tu32 host_ia32_sysenter_cs;\n\tu32 vmx_preemption_timer_value;\n\tu32 padding32[7]; /* room for future expansion */\n\tu16 virtual_processor_id;\n\tu16 guest_es_selector;\n\tu16 guest_cs_selector;\n\tu16 guest_ss_selector;\n\tu16 guest_ds_selector;\n\tu16 guest_fs_selector;\n\tu16 guest_gs_selector;\n\tu16 guest_ldtr_selector;\n\tu16 guest_tr_selector;\n\tu16 host_es_selector;\n\tu16 host_cs_selector;\n\tu16 host_ss_selector;\n\tu16 host_ds_selector;\n\tu16 host_fs_selector;\n\tu16 host_gs_selector;\n\tu16 host_tr_selector;\n};\n\n/*\n * VMCS12_REVISION is an arbitrary id that should be changed if the content or\n * layout of struct vmcs12 is changed. MSR_IA32_VMX_BASIC returns this id, and\n * VMPTRLD verifies that the VMCS region that L1 is loading contains this id.\n */\n#define VMCS12_REVISION 0x11e57ed0\n\n/*\n * VMCS12_SIZE is the number of bytes L1 should allocate for the VMXON region\n * and any VMCS region. Although only sizeof(struct vmcs12) are used by the\n * current implementation, 4K are reserved to avoid future complications.\n */\n#define VMCS12_SIZE 0x1000\n\n/* Used to remember the last vmcs02 used for some recently used vmcs12s */\nstruct vmcs02_list {\n\tstruct list_head list;\n\tgpa_t vmptr;\n\tstruct loaded_vmcs vmcs02;\n};\n\n/*\n * The nested_vmx structure is part of vcpu_vmx, and holds information we need\n * for correct emulation of VMX (i.e., nested VMX) on this vcpu.\n */\nstruct nested_vmx {\n\t/* Has the level1 guest done vmxon? */\n\tbool vmxon;\n\tgpa_t vmxon_ptr;\n\n\t/* The guest-physical address of the current VMCS L1 keeps for L2 */\n\tgpa_t current_vmptr;\n\t/* The host-usable pointer to the above */\n\tstruct page *current_vmcs12_page;\n\tstruct vmcs12 *current_vmcs12;\n\tstruct vmcs *current_shadow_vmcs;\n\t/*\n\t * Indicates if the shadow vmcs must be updated with the\n\t * data hold by vmcs12\n\t */\n\tbool sync_shadow_vmcs;\n\n\t/* vmcs02_list cache of VMCSs recently used to run L2 guests */\n\tstruct list_head vmcs02_pool;\n\tint vmcs02_num;\n\tu64 vmcs01_tsc_offset;\n\t/* L2 must run next, and mustn't decide to exit to L1. */\n\tbool nested_run_pending;\n\t/*\n\t * Guest pages referred to in vmcs02 with host-physical pointers, so\n\t * we must keep them pinned while L2 runs.\n\t */\n\tstruct page *apic_access_page;\n\tstruct page *virtual_apic_page;\n\tu64 msr_ia32_feature_control;\n\n\tstruct hrtimer preemption_timer;\n\tbool preemption_timer_expired;\n\n\t/* to migrate it to L2 if VM_ENTRY_LOAD_DEBUG_CONTROLS is off */\n\tu64 vmcs01_debugctl;\n};\n\n#define POSTED_INTR_ON  0\n/* Posted-Interrupt Descriptor */\nstruct pi_desc {\n\tu32 pir[8];     /* Posted interrupt requested */\n\tu32 control;\t/* bit 0 of control is outstanding notification bit */\n\tu32 rsvd[7];\n} __aligned(64);\n\nstatic bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic bool pi_test_and_clear_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_clear_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}\n\nstruct vcpu_vmx {\n\tstruct kvm_vcpu       vcpu;\n\tunsigned long         host_rsp;\n\tu8                    fail;\n\tbool                  nmi_known_unmasked;\n\tu32                   exit_intr_info;\n\tu32                   idt_vectoring_info;\n\tulong                 rflags;\n\tstruct shared_msr_entry *guest_msrs;\n\tint                   nmsrs;\n\tint                   save_nmsrs;\n\tunsigned long\t      host_idt_base;\n#ifdef CONFIG_X86_64\n\tu64 \t\t      msr_host_kernel_gs_base;\n\tu64 \t\t      msr_guest_kernel_gs_base;\n#endif\n\tu32 vm_entry_controls_shadow;\n\tu32 vm_exit_controls_shadow;\n\t/*\n\t * loaded_vmcs points to the VMCS currently used in this vcpu. For a\n\t * non-nested (L1) guest, it always points to vmcs01. For a nested\n\t * guest (L2), it points to a different VMCS.\n\t */\n\tstruct loaded_vmcs    vmcs01;\n\tstruct loaded_vmcs   *loaded_vmcs;\n\tbool                  __launched; /* temporary, used in vmx_vcpu_run */\n\tstruct msr_autoload {\n\t\tunsigned nr;\n\t\tstruct vmx_msr_entry guest[NR_AUTOLOAD_MSRS];\n\t\tstruct vmx_msr_entry host[NR_AUTOLOAD_MSRS];\n\t} msr_autoload;\n\tstruct {\n\t\tint           loaded;\n\t\tu16           fs_sel, gs_sel, ldt_sel;\n#ifdef CONFIG_X86_64\n\t\tu16           ds_sel, es_sel;\n#endif\n\t\tint           gs_ldt_reload_needed;\n\t\tint           fs_reload_needed;\n\t\tu64           msr_host_bndcfgs;\n\t\tunsigned long vmcs_host_cr4;\t/* May not match real cr4 */\n\t} host_state;\n\tstruct {\n\t\tint vm86_active;\n\t\tulong save_rflags;\n\t\tstruct kvm_segment segs[8];\n\t} rmode;\n\tstruct {\n\t\tu32 bitmask; /* 4 bits per segment (1 bit per field) */\n\t\tstruct kvm_save_segment {\n\t\t\tu16 selector;\n\t\t\tunsigned long base;\n\t\t\tu32 limit;\n\t\t\tu32 ar;\n\t\t} seg[8];\n\t} segment_cache;\n\tint vpid;\n\tbool emulation_required;\n\n\t/* Support for vnmi-less CPUs */\n\tint soft_vnmi_blocked;\n\tktime_t entry_time;\n\ts64 vnmi_blocked_time;\n\tu32 exit_reason;\n\n\tbool rdtscp_enabled;\n\n\t/* Posted interrupt descriptor */\n\tstruct pi_desc pi_desc;\n\n\t/* Support for a guest hypervisor (nested VMX) */\n\tstruct nested_vmx nested;\n\n\t/* Dynamic PLE window. */\n\tint ple_window;\n\tbool ple_window_dirty;\n};\n\nenum segment_cache_field {\n\tSEG_FIELD_SEL = 0,\n\tSEG_FIELD_BASE = 1,\n\tSEG_FIELD_LIMIT = 2,\n\tSEG_FIELD_AR = 3,\n\n\tSEG_FIELD_NR = 4\n};\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}\n\n#define VMCS12_OFFSET(x) offsetof(struct vmcs12, x)\n#define FIELD(number, name)\t[number] = VMCS12_OFFSET(name)\n#define FIELD64(number, name)\t[number] = VMCS12_OFFSET(name), \\\n\t\t\t\t[number##_HIGH] = VMCS12_OFFSET(name)+4\n\n\nstatic unsigned long shadow_read_only_fields[] = {\n\t/*\n\t * We do NOT shadow fields that are modified when L0\n\t * traps and emulates any vmx instruction (e.g. VMPTRLD,\n\t * VMXON...) executed by L1.\n\t * For example, VM_INSTRUCTION_ERROR is read\n\t * by L1 if a vmx instruction fails (part of the error path).\n\t * Note the code assumes this logic. If for some reason\n\t * we start shadowing these fields then we need to\n\t * force a shadow sync when L0 emulates vmx instructions\n\t * (e.g. force a sync if VM_INSTRUCTION_ERROR is modified\n\t * by nested_vmx_failValid)\n\t */\n\tVM_EXIT_REASON,\n\tVM_EXIT_INTR_INFO,\n\tVM_EXIT_INSTRUCTION_LEN,\n\tIDT_VECTORING_INFO_FIELD,\n\tIDT_VECTORING_ERROR_CODE,\n\tVM_EXIT_INTR_ERROR_CODE,\n\tEXIT_QUALIFICATION,\n\tGUEST_LINEAR_ADDRESS,\n\tGUEST_PHYSICAL_ADDRESS\n};\nstatic int max_shadow_read_only_fields =\n\tARRAY_SIZE(shadow_read_only_fields);\n\nstatic unsigned long shadow_read_write_fields[] = {\n\tTPR_THRESHOLD,\n\tGUEST_RIP,\n\tGUEST_RSP,\n\tGUEST_CR0,\n\tGUEST_CR3,\n\tGUEST_CR4,\n\tGUEST_INTERRUPTIBILITY_INFO,\n\tGUEST_RFLAGS,\n\tGUEST_CS_SELECTOR,\n\tGUEST_CS_AR_BYTES,\n\tGUEST_CS_LIMIT,\n\tGUEST_CS_BASE,\n\tGUEST_ES_BASE,\n\tGUEST_BNDCFGS,\n\tCR0_GUEST_HOST_MASK,\n\tCR0_READ_SHADOW,\n\tCR4_READ_SHADOW,\n\tTSC_OFFSET,\n\tEXCEPTION_BITMAP,\n\tCPU_BASED_VM_EXEC_CONTROL,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tVM_ENTRY_INTR_INFO_FIELD,\n\tVM_ENTRY_INSTRUCTION_LEN,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tHOST_FS_BASE,\n\tHOST_GS_BASE,\n\tHOST_FS_SELECTOR,\n\tHOST_GS_SELECTOR\n};\nstatic int max_shadow_read_write_fields =\n\tARRAY_SIZE(shadow_read_write_fields);\n\nstatic const unsigned short vmcs_field_to_offset_table[] = {\n\tFIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id),\n\tFIELD(GUEST_ES_SELECTOR, guest_es_selector),\n\tFIELD(GUEST_CS_SELECTOR, guest_cs_selector),\n\tFIELD(GUEST_SS_SELECTOR, guest_ss_selector),\n\tFIELD(GUEST_DS_SELECTOR, guest_ds_selector),\n\tFIELD(GUEST_FS_SELECTOR, guest_fs_selector),\n\tFIELD(GUEST_GS_SELECTOR, guest_gs_selector),\n\tFIELD(GUEST_LDTR_SELECTOR, guest_ldtr_selector),\n\tFIELD(GUEST_TR_SELECTOR, guest_tr_selector),\n\tFIELD(HOST_ES_SELECTOR, host_es_selector),\n\tFIELD(HOST_CS_SELECTOR, host_cs_selector),\n\tFIELD(HOST_SS_SELECTOR, host_ss_selector),\n\tFIELD(HOST_DS_SELECTOR, host_ds_selector),\n\tFIELD(HOST_FS_SELECTOR, host_fs_selector),\n\tFIELD(HOST_GS_SELECTOR, host_gs_selector),\n\tFIELD(HOST_TR_SELECTOR, host_tr_selector),\n\tFIELD64(IO_BITMAP_A, io_bitmap_a),\n\tFIELD64(IO_BITMAP_B, io_bitmap_b),\n\tFIELD64(MSR_BITMAP, msr_bitmap),\n\tFIELD64(VM_EXIT_MSR_STORE_ADDR, vm_exit_msr_store_addr),\n\tFIELD64(VM_EXIT_MSR_LOAD_ADDR, vm_exit_msr_load_addr),\n\tFIELD64(VM_ENTRY_MSR_LOAD_ADDR, vm_entry_msr_load_addr),\n\tFIELD64(TSC_OFFSET, tsc_offset),\n\tFIELD64(VIRTUAL_APIC_PAGE_ADDR, virtual_apic_page_addr),\n\tFIELD64(APIC_ACCESS_ADDR, apic_access_addr),\n\tFIELD64(EPT_POINTER, ept_pointer),\n\tFIELD64(GUEST_PHYSICAL_ADDRESS, guest_physical_address),\n\tFIELD64(VMCS_LINK_POINTER, vmcs_link_pointer),\n\tFIELD64(GUEST_IA32_DEBUGCTL, guest_ia32_debugctl),\n\tFIELD64(GUEST_IA32_PAT, guest_ia32_pat),\n\tFIELD64(GUEST_IA32_EFER, guest_ia32_efer),\n\tFIELD64(GUEST_IA32_PERF_GLOBAL_CTRL, guest_ia32_perf_global_ctrl),\n\tFIELD64(GUEST_PDPTR0, guest_pdptr0),\n\tFIELD64(GUEST_PDPTR1, guest_pdptr1),\n\tFIELD64(GUEST_PDPTR2, guest_pdptr2),\n\tFIELD64(GUEST_PDPTR3, guest_pdptr3),\n\tFIELD64(GUEST_BNDCFGS, guest_bndcfgs),\n\tFIELD64(HOST_IA32_PAT, host_ia32_pat),\n\tFIELD64(HOST_IA32_EFER, host_ia32_efer),\n\tFIELD64(HOST_IA32_PERF_GLOBAL_CTRL, host_ia32_perf_global_ctrl),\n\tFIELD(PIN_BASED_VM_EXEC_CONTROL, pin_based_vm_exec_control),\n\tFIELD(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control),\n\tFIELD(EXCEPTION_BITMAP, exception_bitmap),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MASK, page_fault_error_code_mask),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MATCH, page_fault_error_code_match),\n\tFIELD(CR3_TARGET_COUNT, cr3_target_count),\n\tFIELD(VM_EXIT_CONTROLS, vm_exit_controls),\n\tFIELD(VM_EXIT_MSR_STORE_COUNT, vm_exit_msr_store_count),\n\tFIELD(VM_EXIT_MSR_LOAD_COUNT, vm_exit_msr_load_count),\n\tFIELD(VM_ENTRY_CONTROLS, vm_entry_controls),\n\tFIELD(VM_ENTRY_MSR_LOAD_COUNT, vm_entry_msr_load_count),\n\tFIELD(VM_ENTRY_INTR_INFO_FIELD, vm_entry_intr_info_field),\n\tFIELD(VM_ENTRY_EXCEPTION_ERROR_CODE, vm_entry_exception_error_code),\n\tFIELD(VM_ENTRY_INSTRUCTION_LEN, vm_entry_instruction_len),\n\tFIELD(TPR_THRESHOLD, tpr_threshold),\n\tFIELD(SECONDARY_VM_EXEC_CONTROL, secondary_vm_exec_control),\n\tFIELD(VM_INSTRUCTION_ERROR, vm_instruction_error),\n\tFIELD(VM_EXIT_REASON, vm_exit_reason),\n\tFIELD(VM_EXIT_INTR_INFO, vm_exit_intr_info),\n\tFIELD(VM_EXIT_INTR_ERROR_CODE, vm_exit_intr_error_code),\n\tFIELD(IDT_VECTORING_INFO_FIELD, idt_vectoring_info_field),\n\tFIELD(IDT_VECTORING_ERROR_CODE, idt_vectoring_error_code),\n\tFIELD(VM_EXIT_INSTRUCTION_LEN, vm_exit_instruction_len),\n\tFIELD(VMX_INSTRUCTION_INFO, vmx_instruction_info),\n\tFIELD(GUEST_ES_LIMIT, guest_es_limit),\n\tFIELD(GUEST_CS_LIMIT, guest_cs_limit),\n\tFIELD(GUEST_SS_LIMIT, guest_ss_limit),\n\tFIELD(GUEST_DS_LIMIT, guest_ds_limit),\n\tFIELD(GUEST_FS_LIMIT, guest_fs_limit),\n\tFIELD(GUEST_GS_LIMIT, guest_gs_limit),\n\tFIELD(GUEST_LDTR_LIMIT, guest_ldtr_limit),\n\tFIELD(GUEST_TR_LIMIT, guest_tr_limit),\n\tFIELD(GUEST_GDTR_LIMIT, guest_gdtr_limit),\n\tFIELD(GUEST_IDTR_LIMIT, guest_idtr_limit),\n\tFIELD(GUEST_ES_AR_BYTES, guest_es_ar_bytes),\n\tFIELD(GUEST_CS_AR_BYTES, guest_cs_ar_bytes),\n\tFIELD(GUEST_SS_AR_BYTES, guest_ss_ar_bytes),\n\tFIELD(GUEST_DS_AR_BYTES, guest_ds_ar_bytes),\n\tFIELD(GUEST_FS_AR_BYTES, guest_fs_ar_bytes),\n\tFIELD(GUEST_GS_AR_BYTES, guest_gs_ar_bytes),\n\tFIELD(GUEST_LDTR_AR_BYTES, guest_ldtr_ar_bytes),\n\tFIELD(GUEST_TR_AR_BYTES, guest_tr_ar_bytes),\n\tFIELD(GUEST_INTERRUPTIBILITY_INFO, guest_interruptibility_info),\n\tFIELD(GUEST_ACTIVITY_STATE, guest_activity_state),\n\tFIELD(GUEST_SYSENTER_CS, guest_sysenter_cs),\n\tFIELD(HOST_IA32_SYSENTER_CS, host_ia32_sysenter_cs),\n\tFIELD(VMX_PREEMPTION_TIMER_VALUE, vmx_preemption_timer_value),\n\tFIELD(CR0_GUEST_HOST_MASK, cr0_guest_host_mask),\n\tFIELD(CR4_GUEST_HOST_MASK, cr4_guest_host_mask),\n\tFIELD(CR0_READ_SHADOW, cr0_read_shadow),\n\tFIELD(CR4_READ_SHADOW, cr4_read_shadow),\n\tFIELD(CR3_TARGET_VALUE0, cr3_target_value0),\n\tFIELD(CR3_TARGET_VALUE1, cr3_target_value1),\n\tFIELD(CR3_TARGET_VALUE2, cr3_target_value2),\n\tFIELD(CR3_TARGET_VALUE3, cr3_target_value3),\n\tFIELD(EXIT_QUALIFICATION, exit_qualification),\n\tFIELD(GUEST_LINEAR_ADDRESS, guest_linear_address),\n\tFIELD(GUEST_CR0, guest_cr0),\n\tFIELD(GUEST_CR3, guest_cr3),\n\tFIELD(GUEST_CR4, guest_cr4),\n\tFIELD(GUEST_ES_BASE, guest_es_base),\n\tFIELD(GUEST_CS_BASE, guest_cs_base),\n\tFIELD(GUEST_SS_BASE, guest_ss_base),\n\tFIELD(GUEST_DS_BASE, guest_ds_base),\n\tFIELD(GUEST_FS_BASE, guest_fs_base),\n\tFIELD(GUEST_GS_BASE, guest_gs_base),\n\tFIELD(GUEST_LDTR_BASE, guest_ldtr_base),\n\tFIELD(GUEST_TR_BASE, guest_tr_base),\n\tFIELD(GUEST_GDTR_BASE, guest_gdtr_base),\n\tFIELD(GUEST_IDTR_BASE, guest_idtr_base),\n\tFIELD(GUEST_DR7, guest_dr7),\n\tFIELD(GUEST_RSP, guest_rsp),\n\tFIELD(GUEST_RIP, guest_rip),\n\tFIELD(GUEST_RFLAGS, guest_rflags),\n\tFIELD(GUEST_PENDING_DBG_EXCEPTIONS, guest_pending_dbg_exceptions),\n\tFIELD(GUEST_SYSENTER_ESP, guest_sysenter_esp),\n\tFIELD(GUEST_SYSENTER_EIP, guest_sysenter_eip),\n\tFIELD(HOST_CR0, host_cr0),\n\tFIELD(HOST_CR3, host_cr3),\n\tFIELD(HOST_CR4, host_cr4),\n\tFIELD(HOST_FS_BASE, host_fs_base),\n\tFIELD(HOST_GS_BASE, host_gs_base),\n\tFIELD(HOST_TR_BASE, host_tr_base),\n\tFIELD(HOST_GDTR_BASE, host_gdtr_base),\n\tFIELD(HOST_IDTR_BASE, host_idtr_base),\n\tFIELD(HOST_IA32_SYSENTER_ESP, host_ia32_sysenter_esp),\n\tFIELD(HOST_IA32_SYSENTER_EIP, host_ia32_sysenter_eip),\n\tFIELD(HOST_RSP, host_rsp),\n\tFIELD(HOST_RIP, host_rip),\n};\nstatic const int max_vmcs_field = ARRAY_SIZE(vmcs_field_to_offset_table);\n\nstatic inline short vmcs_field_to_offset(unsigned long field)\n{\n\tif (field >= max_vmcs_field || vmcs_field_to_offset_table[field] == 0)\n\t\treturn -1;\n\treturn vmcs_field_to_offset_table[field];\n}\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.current_vmcs12;\n}\n\nstatic struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)\n{\n\tstruct page *page = gfn_to_page(vcpu->kvm, addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}\n\nstatic void nested_release_page_clean(struct page *page)\n{\n\tkvm_release_page_clean(page);\n}\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic u64 construct_eptp(unsigned long root_hpa);\nstatic void kvm_cpu_vmxon(u64 addr);\nstatic void kvm_cpu_vmxoff(void);\nstatic bool vmx_mpx_supported(void);\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr);\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic void vmx_sync_pir_to_irr_dummy(struct kvm_vcpu *vcpu);\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx);\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx);\nstatic int alloc_identity_pagetable(struct kvm *kvm);\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nstatic DEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\nstatic DEFINE_PER_CPU(struct desc_ptr, host_gdt);\n\nstatic unsigned long *vmx_io_bitmap_a;\nstatic unsigned long *vmx_io_bitmap_b;\nstatic unsigned long *vmx_msr_bitmap_legacy;\nstatic unsigned long *vmx_msr_bitmap_longmode;\nstatic unsigned long *vmx_msr_bitmap_legacy_x2apic;\nstatic unsigned long *vmx_msr_bitmap_longmode_x2apic;\nstatic unsigned long *vmx_vmread_bitmap;\nstatic unsigned long *vmx_vmwrite_bitmap;\n\nstatic bool cpu_has_load_ia32_efer;\nstatic bool cpu_has_load_perf_global_ctrl;\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic struct vmx_capability {\n\tu32 ept;\n\tu32 vpid;\n} vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u64 host_efer;\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\n\n/*\n * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it\n * away by decrementing the array size.\n */\nstatic const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | PF_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_no_device(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | NM_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | UD_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_external_interrupt(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_EXT_INTR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}\n\nstatic inline bool vm_need_tpr_shadow(struct kvm *kvm)\n{\n\treturn (cpu_has_vmx_tpr_shadow()) && (irqchip_in_kernel(kvm));\n}\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_apic_accesses(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}\n\nstatic inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_virtual_intr_delivery(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY;\n}\n\nstatic inline bool cpu_has_vmx_posted_intr(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}\n\nstatic inline bool cpu_has_vmx_eptp_uncacheable(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_UC_BIT;\n}\n\nstatic inline bool cpu_has_vmx_eptp_writeback(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_EPT;\n}\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}\n\nstatic inline bool vm_need_virtualize_apic_accesses(struct kvm *kvm)\n{\n\treturn flexpriority_enabled && irqchip_in_kernel(kvm);\n}\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_shadow_vmcs(void)\n{\n\tu64 vmx_msr;\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t/* check if the cpu supports writing r/o exit information fields */\n\tif (!(vmx_msr & MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS))\n\t\treturn false;\n\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}\n\nstatic inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}\n\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification);\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification);\n\nstatic int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n\nstatic inline void __invept(int ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tasm volatile (__ex(ASM_VMX_INVEPT)\n\t\t\t/* CF==1 or ZF==1 --> rc = -1 */\n\t\t\t\"; ja 1f ; ud2 ; 1:\\n\"\n\t\t\t: : \"a\" (&operand), \"c\" (ext) : \"cc\", \"memory\");\n}\n\nstatic struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}\n\nstatic void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMCLEAR_RAX) \"; setna %0\"\n\t\t      : \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t      : \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmclear fail: %p/%llx\\n\",\n\t\t       vmcs, phys_addr);\n}\n\nstatic inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)\n{\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nstatic void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMPTRLD_RAX) \"; setna %0\"\n\t\t\t: \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t\t: \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmptrld %p/%llx failed\\n\",\n\t\t       vmcs, phys_addr);\n}\n\n#ifdef CONFIG_KEXEC\n/*\n * This bitmap is used to indicate whether the vmclear\n * operation is enabled on all cpus. All disabled by\n * default.\n */\nstatic cpumask_t crash_vmclear_enabled_bitmap = CPU_MASK_NONE;\n\nstatic inline void crash_enable_local_vmclear(int cpu)\n{\n\tcpumask_set_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline void crash_disable_local_vmclear(int cpu)\n{\n\tcpumask_clear_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline int crash_local_vmclear_enabled(int cpu)\n{\n\treturn cpumask_test_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tif (!crash_local_vmclear_enabled(cpu))\n\t\treturn;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#else\nstatic inline void crash_enable_local_vmclear(int cpu) { }\nstatic inline void crash_disable_local_vmclear(int cpu) { }\n#endif /* CONFIG_KEXEC */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\tcrash_disable_local_vmclear(cpu);\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * we should ensure updating loaded_vmcs->loaded_vmcss_on_cpu_link\n\t * is before setting loaded_vmcs->vcpu to -1 which is done in\n\t * loaded_vmcs_init. Otherwise, other cpu can see vcpu = -1 fist\n\t * then adds the vmcs into percpu list before it is deleted.\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs_init(loaded_vmcs);\n\tcrash_enable_local_vmclear(cpu);\n}\n\nstatic void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic inline void vpid_sync_vcpu_single(struct vcpu_vmx *vmx)\n{\n\tif (vmx->vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vmx->vpid, 0);\n}\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}\n\nstatic inline void vpid_sync_context(struct vcpu_vmx *vmx)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vmx);\n\telse\n\t\tvpid_sync_vcpu_global();\n}\n\nstatic inline void ept_sync_global(void)\n{\n\tif (cpu_has_vmx_invept_global())\n\t\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (enable_ept) {\n\t\tif (cpu_has_vmx_invept_context())\n\t\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\t\telse\n\t\t\tept_sync_global();\n\t}\n}\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, \"%0\")\n\t\t      : \"=a\"(value) : \"d\"(field) : \"cc\");\n\treturn value;\n}\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\treturn vmcs_readl(field);\n}\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\treturn vmcs_readl(field);\n}\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n#ifdef CONFIG_X86_64\n\treturn vmcs_readl(field);\n#else\n\treturn vmcs_readl(field) | ((u64)vmcs_readl(field+1) << 32);\n#endif\n}\n\nstatic noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tprintk(KERN_ERR \"vmwrite error: reg %lx value %lx (err %d)\\n\",\n\t       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n\tdump_stack();\n}\n\nstatic void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMWRITE_RAX_RDX) \"; setna %0\"\n\t\t       : \"=q\"(error) : \"a\"(value), \"d\"(field) : \"cc\");\n\tif (unlikely(error))\n\t\tvmwrite_error(field, value);\n}\n\nstatic void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_writel(field, value);\n}\n\nstatic void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_writel(field, value);\n}\n\nstatic void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\tasm volatile (\"\");\n\tvmcs_writel(field+1, value >> 32);\n#endif\n}\n\nstatic void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) & ~mask);\n}\n\nstatic void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) | mask);\n}\n\nstatic inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}\n\nstatic inline void vm_entry_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_entry_controls_shadow != val)\n\t\tvm_entry_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_entry_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_entry_controls_shadow;\n}\n\n\nstatic inline void vm_entry_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) | val);\n}\n\nstatic inline void vm_entry_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) & ~val);\n}\n\nstatic inline void vm_exit_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_EXIT_CONTROLS, val);\n\tvmx->vm_exit_controls_shadow = val;\n}\n\nstatic inline void vm_exit_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_exit_controls_shadow != val)\n\t\tvm_exit_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}\n\n\nstatic inline void vm_exit_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) | val);\n}\n\nstatic inline void vm_exit_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) & ~val);\n}\n\nstatic void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!(vmx->vcpu.arch.regs_avail & (1 << VCPU_EXREG_SEGMENTS))) {\n\t\tvmx->vcpu.arch.regs_avail |= (1 << VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nstatic void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); /* bypass_guest_pf = 0 */\n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == m->nr)\n\t\treturn;\n\t--m->nr;\n\tm->guest[i] = m->guest[m->nr];\n\tm->host[i] = m->host[m->nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == NR_AUTOLOAD_MSRS) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t} else if (i == m->nr) {\n\t\t++m->nr;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n\t}\n\n\tm->guest[i].index = msr;\n\tm->guest[i].value = guest_val;\n\tm->host[i].index = msr;\n\tm->host[i].value = host_val;\n}\n\nstatic void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer;\n\tu64 ignore_bits;\n\n\tguest_efer = vmx->vcpu.arch.efer;\n\n\t/*\n\t * NX is emulated; LMA and LME handled by hardware; SCE meaningless\n\t * outside long mode\n\t */\n\tignore_bits = EFER_NX | EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\tguest_efer &= ~ignore_bits;\n\tguest_efer |= host_efer & ignore_bits;\n\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t/* On ept, can't emulate nx, and must switch nx atomically */\n\tif (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX)) {\n\t\tguest_efer = vmx->vcpu.arch.efer;\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tadd_atomic_switch_msr(vmx, MSR_EFER, guest_efer, host_efer);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *d;\n\tunsigned long table_base;\n\tunsigned long v;\n\n\tif (!(selector & ~3))\n\t\treturn 0;\n\n\ttable_base = gdt->address;\n\n\tif (selector & 4) {           /* from ldt */\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~3))\n\t\t\treturn 0;\n\n\t\ttable_base = segment_base(ldt_selector);\n\t}\n\td = (struct desc_struct *)(table_base + (selector & ~7));\n\tv = get_desc_base(d);\n#ifdef CONFIG_X86_64\n       if (d->s == 0 && (d->type == 2 || d->type == 9 || d->type == 11))\n               v |= ((unsigned long)((struct ldttss_desc64 *)d)->base3) << 32;\n#endif\n\treturn v;\n}\n\nstatic inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n\nstatic void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (boot_cpu_has(X86_FEATURE_MPX))\n\t\trdmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n\nstatic void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu))\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(vmx->host_state.gs_sel);\n#else\n\t\tloadsegment(gs, vmx->host_state.gs_sel);\n#endif\n\t}\n\tif (vmx->host_state.fs_reload_needed)\n\t\tloadsegment(fs, vmx->host_state.fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(vmx->host_state.ds_sel | vmx->host_state.es_sel)) {\n\t\tloadsegment(ds, vmx->host_state.ds_sel);\n\t\tloadsegment(es, vmx->host_state.es_sel);\n\t}\n#endif\n\treload_tss();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tif (vmx->host_state.msr_host_bndcfgs)\n\t\twrmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\t/*\n\t * If the FPU is not active (through the host task or\n\t * the guest vcpu), then restore the cr0.TS bit.\n\t */\n\tif (!user_has_fpu() && !vmx->vcpu.guest_fpu_loaded)\n\t\tstts();\n\tload_gdt(this_cpu_ptr(&host_gdt));\n}\n\nstatic void vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\t__vmx_load_host_state(vmx);\n\tpreempt_enable();\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(phys_addr);\n\telse if (vmx->loaded_vmcs->cpu != cpu)\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t}\n\n\tif (vmx->loaded_vmcs->cpu != cpu) {\n\t\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tlocal_irq_disable();\n\t\tcrash_disable_local_vmclear(cpu);\n\n\t\t/*\n\t\t * Read loaded_vmcs->cpu should be before fetching\n\t\t * loaded_vmcs->loaded_vmcss_on_cpu_link.\n\t\t * See the comments in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tcrash_enable_local_vmclear(cpu);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE, kvm_read_tr_base()); /* 22.2.4 */\n\t\tvmcs_writel(HOST_GDTR_BASE, gdt->address);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\t__vmx_load_host_state(to_vmx(vcpu));\n\tif (!vmm_exclusive) {\n\t\t__loaded_vmcs_clear(to_vmx(vcpu)->loaded_vmcs);\n\t\tvcpu->cpu = -1;\n\t\tkvm_cpu_vmxoff();\n\t}\n}\n\nstatic void vmx_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tulong cr0;\n\n\tif (vcpu->fpu_active)\n\t\treturn;\n\tvcpu->fpu_active = 1;\n\tcr0 = vmcs_readl(GUEST_CR0);\n\tcr0 &= ~(X86_CR0_TS | X86_CR0_MP);\n\tcr0 |= kvm_read_cr0_bits(vcpu, X86_CR0_TS | X86_CR0_MP);\n\tvmcs_writel(GUEST_CR0, cr0);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.cr0_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\n\n/*\n * Return the cr0 value that a nested guest would read. This is a combination\n * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by\n * its hypervisor (cr0_read_shadow).\n */\nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n\nstatic void vmx_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\t/* Note that there is no vcpu->fpu_active = 0 here. The caller must\n\t * set this *before* calling this function.\n\t */\n\tvmx_decache_cr0_guest_bits(vcpu);\n\tvmcs_set_bits(GUEST_CR0, X86_CR0_TS | X86_CR0_MP);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = 0;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1's specified read shadow might not contain the TS bit,\n\t\t * so now that we turned on shadowing of this bit, we need to\n\t\t * set this bit of the shadow. Like in nested_vmx_run we need\n\t\t * nested_read_cr0(vmcs12), but vmcs12->guest_cr0 is not yet\n\t\t * up-to-date here because we just decached cr0.TS (and we'll\n\t\t * only update vmcs12->guest_cr0 on nested exit).\n\t\t */\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tvmcs12->guest_cr0 = (vmcs12->guest_cr0 & ~X86_CR0_TS) |\n\t\t\t(vcpu->arch.cr0 & X86_CR0_TS);\n\t\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\t} else\n\t\tvmcs_writel(CR0_READ_SHADOW, vcpu->arch.cr0);\n}\n\nstatic unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags, save_rflags;\n\n\tif (!test_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = to_vmx(vcpu)->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tto_vmx(vcpu)->rflags = rflags;\n\t}\n\treturn to_vmx(vcpu)->rflags;\n}\n\nstatic void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\tto_vmx(vcpu)->rflags = rflags;\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tto_vmx(vcpu)->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n}\n\nstatic u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nstatic void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}\n\n/*\n * KVM wants to inject page-faults which it got to the guest. This function\n * checks whether in a nested guest, we need to inject them to L1 or L2.\n */\nstatic int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (!(vmcs12->exception_bitmap & (1u << nr)))\n\t\treturn 0;\n\n\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}\n\nstatic bool vmx_invpcid_supported(void)\n{\n\treturn cpu_has_vmx_invpcid() && enable_ept;\n}\n\n/*\n * Swap MSR entry in host/guest MSR entry array.\n */\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}\n\nstatic void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (irqchip_in_kernel(vcpu->kvm) && apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n\n/*\n * Set up the vmcs to automatically save and restore system\n * msrs.  Don't touch the 64-bit msrs if the guest is in legacy\n * mode, as fiddling with msrs is very expensive.\n */\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && vmx->rdtscp_enabled)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\t/*\n\t\t * MSR_STAR is only needed on long mode guests, and only\n\t\t * if efer.sce is enabled.\n\t\t */\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}\n\n/*\n * reads and returns guest's timestamp counter \"register\"\n * guest_tsc = host_tsc + tsc_offset    -- 21.3\n */\nstatic u64 guest_read_tsc(void)\n{\n\tu64 host_tsc, tsc_offset;\n\n\trdtscll(host_tsc);\n\ttsc_offset = vmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}\n\n/*\n * Like guest_read_tsc, but always returns L1's notion of the timestamp\n * counter, even if a nested guest (L2) is currently running.\n */\nstatic u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}\n\n/*\n * Engage any workarounds for mis-matched TSC rates.  Currently limited to\n * software catchup for faster rates on slower CPUs.\n */\nstatic void vmx_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tif (!scale)\n\t\treturn;\n\n\tif (user_tsc_khz > tsc_khz) {\n\t\tvcpu->arch.tsc_catchup = 1;\n\t\tvcpu->arch.tsc_always_catchup = 1;\n\t} else\n\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n}\n\nstatic u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}\n\n/*\n * writes 'offset' into guest's timestamp counter offset register\n */\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t\t * to the spec, this should set L1's TSC; The offset that L1\n\t\t * set for L2 remains unchanged, and still needs to be added\n\t\t * to the newly set TSC to get L2's TSC.\n\t\t */\n\t\tstruct vmcs12 *vmcs12;\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset = offset;\n\t\t/* recalculate vmcs02.TSC_OFFSET: */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tvmcs_write64(TSC_OFFSET, offset +\n\t\t\t(nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETING) ?\n\t\t\t vmcs12->tsc_offset : 0));\n\t} else {\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   vmcs_read64(TSC_OFFSET), offset);\n\t\tvmcs_write64(TSC_OFFSET, offset);\n\t}\n}\n\nstatic void vmx_adjust_tsc_offset(struct kvm_vcpu *vcpu, s64 adjustment, bool host)\n{\n\tu64 offset = vmcs_read64(TSC_OFFSET);\n\n\tvmcs_write64(TSC_OFFSET, offset + adjustment);\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Even when running L2, the adjustment needs to apply to L1 */\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset += adjustment;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id, offset,\n\t\t\t\t\t   offset + adjustment);\n}\n\nstatic u64 vmx_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\treturn target_tsc - native_read_tsc();\n}\n\nstatic bool guest_cpuid_has_vmx(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & (1 << (X86_FEATURE_VMX & 31)));\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nstatic inline bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has_vmx(vcpu);\n}\n\n/*\n * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be\n * returned for the various VMX controls MSRs when nested VMX is enabled.\n * The same values should also be used to verify that vmcs12 control fields are\n * valid during nested entry from L1 to L2.\n * Each of these control msrs has a low and high 32-bit half: A low bit is on\n * if the corresponding bit in the (32-bit) control field *must* be on, and a\n * bit in the high half is on if the corresponding bit in the control field\n * may be on. See also vmx_control_verify().\n * TODO: allow these variables to be modified (downgraded) by module options\n * or other means.\n */\nstatic u32 nested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high;\nstatic u32 nested_vmx_true_procbased_ctls_low;\nstatic u32 nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high;\nstatic u32 nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high;\nstatic u32 nested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high;\nstatic u32 nested_vmx_true_exit_ctls_low;\nstatic u32 nested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high;\nstatic u32 nested_vmx_true_entry_ctls_low;\nstatic u32 nested_vmx_misc_low, nested_vmx_misc_high;\nstatic u32 nested_vmx_ept_caps;\nstatic __init void nested_vmx_setup_ctls_msrs(void)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high);\n\tnested_vmx_pinbased_ctls_low |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_pinbased_ctls_high &= PIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING | PIN_BASED_VIRTUAL_NMIS;\n\tnested_vmx_pinbased_ctls_high |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/* exit controls */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tnested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high);\n\tnested_vmx_exit_ctls_low = VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\n\tnested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tnested_vmx_exit_ctls_high |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER | VM_EXIT_ACK_INTR_ON_EXIT;\n\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* We support free control of debug control saving. */\n\tnested_vmx_true_exit_ctls_low = nested_vmx_exit_ctls_low &\n\t\t~VM_EXIT_SAVE_DEBUG_CONTROLS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tnested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high);\n\tnested_vmx_entry_ctls_low = VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tnested_vmx_entry_ctls_high |= (VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\t\t\t       VM_ENTRY_LOAD_IA32_EFER);\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* We support free control of debug control loading. */\n\tnested_vmx_true_entry_ctls_low = nested_vmx_entry_ctls_low &\n\t\t~VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tnested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high);\n\tnested_vmx_procbased_ctls_low = CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_EXITING |\n\t\tCPU_BASED_RDPMC_EXITING | CPU_BASED_RDTSC_EXITING |\n\t\tCPU_BASED_PAUSE_EXITING | CPU_BASED_TPR_SHADOW |\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tnested_vmx_procbased_ctls_high |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tCPU_BASED_USE_MSR_BITMAPS;\n\n\t/* We support free control of CR3 access interception. */\n\tnested_vmx_true_procbased_ctls_low = nested_vmx_procbased_ctls_low &\n\t\t~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tnested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);\n\tnested_vmx_secondary_ctls_low = 0;\n\tnested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tnested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;\n\t\tnested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tnested_vmx_ept_caps &= vmx_capability.ept;\n\t\t/*\n\t\t * For nested guests, we don't do anything specific\n\t\t * for single context invalidation. Hence, only advertise\n\t\t * support for global context invalidation.\n\t\t */\n\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;\n\t} else\n\t\tnested_vmx_ept_caps = 0;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);\n\tnested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tnested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tnested_vmx_misc_high = 0;\n}\n\nstatic inline bool vmx_control_verify(u32 control, u32 low, u32 high)\n{\n\t/*\n\t * Bits 0 in high must be 0, and bits 1 in low must be 1.\n\t */\n\treturn ((control & high) | low) == control;\n}\n\nstatic inline u64 vmx_control_msr(u32 low, u32 high)\n{\n\treturn low | ((u64)high << 32);\n}\n\n/* Returns 0 on success, non-0 otherwise. */\nstatic int vmx_get_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t/*\n\t\t * This MSR reports some information about VMX support. We\n\t\t * should return information about the VMX we emulate for the\n\t\t * guest, and the VMCS structure we give it - not about the\n\t\t * VMX support of the underlying hardware.\n\t\t */\n\t\t*pdata = VMCS12_REVISION | VMX_BASIC_TRUE_CTLS |\n\t\t\t   ((u64)VMCS12_SIZE << VMX_BASIC_VMCS_SIZE_SHIFT) |\n\t\t\t   (VMX_BASIC_MEM_TYPE_WB << VMX_BASIC_MEM_TYPE_SHIFT);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_pinbased_ctls_low,\n\t\t\t\t\tnested_vmx_pinbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_procbased_ctls_low,\n\t\t\t\t\tnested_vmx_procbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_procbased_ctls_low,\n\t\t\t\t\tnested_vmx_procbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_exit_ctls_low,\n\t\t\t\t\tnested_vmx_exit_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_exit_ctls_low,\n\t\t\t\t\tnested_vmx_exit_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_entry_ctls_low,\n\t\t\t\t\tnested_vmx_entry_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_entry_ctls_low,\n\t\t\t\t\tnested_vmx_entry_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(nested_vmx_misc_low,\n\t\t\t\t\t nested_vmx_misc_high);\n\t\tbreak;\n\t/*\n\t * These MSRs specify bits which the guest must keep fixed (on or off)\n\t * while L1 is in VMXON mode (in L1's root mode, or running an L2).\n\t * We picked the standard core2 setting.\n\t */\n#define VMXON_CR0_ALWAYSON\t(X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)\n#define VMXON_CR4_ALWAYSON\tX86_CR4_VMXE\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = VMXON_CR0_ALWAYSON;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = -1ULL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = VMXON_CR4_ALWAYSON;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = -1ULL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = 0x2e; /* highest index: VMX_PREEMPTION_TIMER_VALUE */\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(nested_vmx_secondary_ctls_low,\n\t\t\t\t\tnested_vmx_secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t/* Currently, no nested vpid support */\n\t\t*pdata = nested_vmx_ept_caps;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tu64 data;\n\tstruct shared_msr_entry *msr;\n\n\tif (!pdata) {\n\t\tprintk(KERN_ERR \"BUG: get_msr called with NULL pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tdata = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tdata = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(to_vmx(vcpu));\n\t\tdata = to_vmx(vcpu)->msr_guest_kernel_gs_base;\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_index, pdata);\n\tcase MSR_IA32_TSC:\n\t\tdata = guest_read_tsc();\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tdata = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tdata = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tdata = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!vmx_mpx_supported())\n\t\t\treturn 1;\n\t\tdata = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tdata = to_vmx(vcpu)->nested.msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(vcpu, msr_index, pdata);\n\tcase MSR_TSC_AUX:\n\t\tif (!to_vmx(vcpu)->rdtscp_enabled)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(to_vmx(vcpu), msr_index);\n\t\tif (msr) {\n\t\t\tdata = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_index, pdata);\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(vmx);\n\t\tvmx->msr_guest_kernel_gs_base = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!vmx_mpx_supported())\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\t\treturn 1;\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!nested_vmx_allowed(vcpu) ||\n\t\t    (to_vmx(vcpu)->nested.msr_ia32_feature_control &\n\t\t     FEATURE_CONTROL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->nested.msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn 1; /* they are read-only */\n\tcase MSR_TSC_AUX:\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\t\t\tpreempt_disable();\n\t\t\t\tkvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t\t   msr->mask);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\tu64 msr;\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, msr);\n\tif (msr & FEATURE_CONTROL_LOCKED) {\n\t\t/* launched w/ TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& tboot_enabled())\n\t\t\treturn 1;\n\t\t/* launched w/o TXT and VMX only enabled w/ TXT */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& !tboot_enabled()) {\n\t\t\tprintk(KERN_WARNING \"kvm: disable TXT in the BIOS or \"\n\t\t\t\t\"activate TXT before enabling KVM\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* launched w/o TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& !tboot_enabled())\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void kvm_cpu_vmxon(u64 addr)\n{\n\tasm volatile (ASM_VMX_VMXON_RAX\n\t\t\t: : \"a\"(&addr), \"m\"(addr)\n\t\t\t: \"memory\", \"cc\");\n}\n\nstatic int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\n\t/*\n\t * Now we can enable the vmclear operation in kdump\n\t * since the loaded_vmcss_on_cpu list on this cpu\n\t * has been initialized.\n\t *\n\t * Though the cpu is not in VMX operation now, there\n\t * is no problem to enable the vmclear operation\n\t * for the loaded_vmcss_on_cpu list is empty!\n\t */\n\tcrash_enable_local_vmclear(cpu);\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); /* FIXME: not cpu hotplug safe */\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\n\n/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()\n * tricks.\n */\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(ASM_VMX_VMXOFF) : : : \"cc\");\n}\n\nstatic void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\twrite_cr4(read_cr4() & ~X86_CR4_VMXE);\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init bool allow_1_setting(u32 msr, u32 ctl)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\treturn vmx_msr_high & ctl;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_USE_IO_BITMAPS |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t\trdmsr(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t      vmx_capability.ept, vmx_capability.vpid);\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_SAVE_IA32_PAT | VM_EXIT_LOAD_IA32_PAT |\n\t\tVM_EXIT_ACK_INTR_ON_EXIT | VM_EXIT_CLEAR_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) ||\n\t\t!(_vmexit_control & VM_EXIT_ACK_INTR_ON_EXIT))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->order = get_order(vmcs_config.size);\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n\tcpu_has_load_ia32_efer =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_EFER)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_EFER);\n\n\tcpu_has_load_perf_global_ctrl =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\n\t/*\n\t * Some cpus support VM_ENTRY_(LOAD|SAVE)_IA32_PERF_GLOBAL_CTRL\n\t * but due to arrata below it can't be used. Workaround is to use\n\t * msr load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t *\n\t * VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]\n\t *\n\t * AAK155             (model 26)\n\t * AAP115             (model 30)\n\t * AAT100             (model 37)\n\t * BC86,AAY89,BD102   (model 44)\n\t * BA97               (model 46)\n\t *\n\t */\n\tif (cpu_has_load_perf_global_ctrl && boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26:\n\t\tcase 30:\n\t\tcase 37:\n\t\tcase 44:\n\t\tcase 46:\n\t\t\tcpu_has_load_perf_global_ctrl = false;\n\t\t\tprintk_once(KERN_WARNING\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct vmcs *alloc_vmcs_cpu(int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = alloc_pages_exact_node(node, GFP_KERNEL, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\tvmcs->revision_id = vmcs_config.revision_id; /* vmcs revision id */\n\treturn vmcs;\n}\n\nstatic struct vmcs *alloc_vmcs(void)\n{\n\treturn alloc_vmcs_cpu(raw_smp_processor_id());\n}\n\nstatic void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nstatic void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\n\t/* No checks for read only fields yet */\n\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!vmx_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\n\t/* shadowed fields guest access without vmexit */\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(cpu);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic __init int hardware_setup(void)\n{\n\tif (setup_vmcs_config(&vmcs_config) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority()) {\n\t\tflexpriority_enabled = 0;\n\n\t\t/*\n\t\t * set_apic_access_page_addr() is used to reload apic access\n\t\t * page upon invalidation.  No need to do anything if the\n\t\t * processor does not have the APIC_ACCESS_ADDR VMCS field.\n\t\t */\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\t}\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (enable_apicv)\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\telse {\n\t\tkvm_x86_ops->hwapic_irr_update = NULL;\n\t\tkvm_x86_ops->deliver_posted_interrupt = NULL;\n\t\tkvm_x86_ops->sync_pir_to_irr = vmx_sync_pir_to_irr_dummy;\n\t}\n\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs();\n\n\treturn alloc_kvm_area();\n}\n\nstatic __exit void hardware_unsetup(void)\n{\n\tfree_kvm_area();\n}\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SELECTOR_RPL_MASK;\n\t\tsave->dpl = save->selector & SELECTOR_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_write32(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!vcpu->kvm->arch.tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, vcpu->kvm->arch.tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\t/*\n\t * Force kernel_gs_base reloading before EFER changes, as control\n\t * of this msr depends on is_long_mode().\n\t */\n\tvmx_load_host_state(to_vmx(vcpu));\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & AR_TYPE_MASK) != AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~AR_TYPE_MASK)\n\t\t\t     | AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic void vmx_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tvpid_sync_context(to_vmx(vcpu));\n\tif (enable_ept) {\n\t\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\t\treturn;\n\t\tept_sync_context(construct_eptp(vcpu->arch.mmu.root_hpa));\n\t}\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}\n\nstatic void vmx_decache_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (enable_ept && is_paging(vcpu))\n\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n}\n\nstatic void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_dirty))\n\t\treturn;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tvmx_decache_cr3(vcpu);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) |\n\t\t\t     (CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t      CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) &\n\t\t\t     ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t       CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}\n\nstatic void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_GUEST_CR0_MASK);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tif (!vcpu->fpu_active)\n\t\thw_cr0 |= X86_CR0_TS | X86_CR0_MP;\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic u64 construct_eptp(unsigned long root_hpa)\n{\n\tu64 eptp;\n\n\t/* TODO write the value reading from MSR */\n\teptp = VMX_EPT_DEFAULT_MT |\n\t\tVMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT;\n\tif (enable_ept_ad_bits)\n\t\teptp |= VMX_EPT_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}\n\nstatic void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (is_paging(vcpu) || is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = vcpu->kvm->arch.ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long hw_cr4 = cr4 | (to_vmx(vcpu)->rmode.vm86_active ?\n\t\t    KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t}\n\tif (to_vmx(vcpu)->nested.vmxon &&\n\t    ((cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\tif (enable_ept) {\n\t\tif (!is_paging(vcpu)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t/*\n\t\t\t * SMEP/SMAP is disabled if CPU is in non-paging mode\n\t\t\t * in hardware. However KVM always uses paging mode to\n\t\t\t * emulate guest non-paging mode with TDP.\n\t\t\t * To emulate this behavior, SMEP/SMAP needs to be\n\t\t\t * manually disabled when guest switches to non-paging\n\t\t\t * mode.\n\t\t\t */\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP);\n\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t}\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}\n\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nstatic int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SELECTOR_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (AR_TYPE_CODE_MASK|AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SELECTOR_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SELECTOR_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (AR_TYPE_CODE_MASK|AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SELECTOR_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SELECTOR_RPL_MASK) ==\n\t\t (ss.selector & SELECTOR_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = kvm->arch.tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tint i, idx, r = 0;\n\tpfn_t identity_map_pfn;\n\tu32 tmp;\n\n\tif (!enable_ept)\n\t\treturn 0;\n\n\t/* Protect kvm->arch.ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm->arch.ept_identity_pagetable_done))\n\t\tgoto out2;\n\n\tidentity_map_pfn = kvm->arch.ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = alloc_identity_pagetable(kvm);\n\tif (r < 0)\n\t\tgoto out2;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm->arch.ept_identity_pagetable_done = true;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\nout2:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tkvm_userspace_mem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\tkvm_userspace_mem.flags = 0;\n\tkvm_userspace_mem.guest_phys_addr = APIC_DEFAULT_PHYS_BASE;\n\tkvm_userspace_mem.memory_size = PAGE_SIZE;\n\tr = __kvm_set_memory_region(kvm, &kvm_userspace_mem);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic int alloc_identity_pagetable(struct kvm *kvm)\n{\n\t/* Called with kvm->slots_lock held. */\n\n\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\tint r = 0;\n\n\tBUG_ON(kvm->arch.ept_identity_pagetable_done);\n\n\tkvm_userspace_mem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\tkvm_userspace_mem.flags = 0;\n\tkvm_userspace_mem.guest_phys_addr =\n\t\tkvm->arch.ept_identity_map_addr;\n\tkvm_userspace_mem.memory_size = PAGE_SIZE;\n\tr = __kvm_set_memory_region(kvm, &kvm_userspace_mem);\n\n\treturn r;\n}\n\nstatic void allocate_vpid(struct vcpu_vmx *vmx)\n{\n\tint vpid;\n\n\tvmx->vpid = 0;\n\tif (!enable_vpid)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS) {\n\t\tvmx->vpid = vpid;\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\t}\n\tspin_unlock(&vmx_vpid_lock);\n}\n\nstatic void free_vpid(struct vcpu_vmx *vmx)\n{\n\tif (!enable_vpid)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\tif (vmx->vpid != 0)\n\t\t__clear_bit(vmx->vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\n#define MSR_TYPE_R\t1\n#define MSR_TYPE_W\t2\nstatic void __vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\nstatic void __vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\nstatic void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)\n{\n\tif (!longmode_only)\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n}\n\nstatic void vmx_enable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}\n\nstatic void vmx_disable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}\n\nstatic void vmx_disable_intercept_msr_write_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_W);\n}\n\nstatic int vmx_vm_has_apicv(struct kvm *kvm)\n{\n\treturn enable_apicv && irqchip_in_kernel(kvm);\n}\n\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn;\n\n\tr = pi_test_and_set_on(&vmx->pi_desc);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n#ifdef CONFIG_SMP\n\tif (!r && (vcpu->mode == IN_GUEST_MODE))\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu),\n\t\t\t\tPOSTED_INTR_VECTOR);\n\telse\n#endif\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!pi_test_and_clear_on(&vmx->pi_desc))\n\t\treturn;\n\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}\n\nstatic void vmx_sync_pir_to_irr_dummy(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nstatic void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}\n\nstatic void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!vmx_vm_has_apicv(vmx->vcpu.kvm))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\treturn pin_based_exec_ctrl;\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!vm_need_tpr_shadow(vmx->vcpu.kvm)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\treturn exec_control;\n}\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\tif (!vm_need_virtualize_apic_accesses(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t\t/* Enable INVPCID for non-ept guests may cause performance regression. */\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (!ple_gap)\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!vmx_vm_has_apicv(vmx->vcpu.kvm))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\treturn exec_control;\n}\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n\n/*\n * Sets up the vmcs for emulated real mode.\n */\nstatic int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (vmx_vm_has_apicv(vmx->vcpu.kvm)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write64(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tu32 msr_low, msr_high;\n\t\tu64 host_pat;\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\t/* Write the default value follow host pat */\n\t\tvmcs_write64(GUEST_IA32_PAT, host_pat);\n\t\t/* Keep arch.pat sync with GUEST_IA32_PAT */\n\t\tvmx->vcpu.arch.pat = host_pat;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\treturn 0;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx->soft_vnmi_blocked = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tkvm_set_cr8(&vmx->vcpu, 0);\n\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE;\n\tif (kvm_vcpu_is_bsp(&vmx->vcpu))\n\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(&vmx->vcpu, &apic_base_msr);\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_write32(GUEST_CS_BASE, 0xffff0000);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\n\tvmcs_writel(GUEST_RFLAGS, 0x02);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_write32(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\n\t/* Special registers */\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow()) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (vm_need_tpr_shadow(vmx->vcpu.kvm))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vmx->vcpu.arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_vcpu_reload_apic_access_page(vcpu);\n\n\tif (vmx_vm_has_apicv(vcpu->kvm))\n\t\tmemset(&vmx->pi_desc, 0, sizeof(struct pi_desc));\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tvmx->vcpu.arch.cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx_set_cr0(&vmx->vcpu, kvm_read_cr0(vcpu)); /* enter rmode */\n\tvmx_set_cr4(&vmx->vcpu, 0);\n\tvmx_set_efer(&vmx->vcpu, 0);\n\tvmx_fpu_activate(&vmx->vcpu);\n\tupdate_exception_bitmap(&vmx->vcpu);\n\n\tvpid_sync_context(vmx);\n}\n\n/*\n * In nested virtualization, check if L1 asked to exit on external interrupts.\n * For most existing hypervisors, this will always return true.\n */\nstatic bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}\n\n/*\n * In nested virtualization, check if L1 has set\n * VM_EXIT_ACK_INTR_ON_EXIT\n */\nstatic bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->vm_exit_controls &\n\t\tVM_EXIT_ACK_INTR_ON_EXIT;\n}\n\nstatic bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn;\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->soft_vnmi_blocked = 1;\n\t\tvmx->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->nmi_known_unmasked = false;\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n\nstatic bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tif (!cpu_has_virtual_nmis())\n\t\treturn to_vmx(vcpu)->soft_vnmi_blocked;\n\tif (to_vmx(vcpu)->nmi_known_unmasked)\n\t\treturn false;\n\treturn vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\t& GUEST_INTR_STATE_NMI;\n}\n\nstatic void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\tif (vmx->soft_vnmi_blocked != masked) {\n\t\t\tvmx->soft_vnmi_blocked = masked;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\tstruct kvm_userspace_memory_region tss_mem = {\n\t\t.slot = TSS_PRIVATE_MEMSLOT,\n\t\t.guest_phys_addr = addr,\n\t\t.memory_size = PAGE_SIZE * 3,\n\t\t.flags = 0,\n\t};\n\n\tret = kvm_set_memory_region(kvm, &tss_mem);\n\tif (ret)\n\t\treturn ret;\n\tkvm->arch.tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\tbreak;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (emulate_instruction(vcpu, 0) == EMULATE_DONE) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_emulate_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\n/*\n * Trigger machine check on the host. We assume all the MSRs are already set up\n * by the CPU and that we still run on the same CPU as the MCE occurred on.\n * We pass a fake environment to the machine check handler because we want\n * the guest to be always treated like user space, no matter what context\n * it used internally.\n */\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* already handled by vcpu_run */\n\treturn 1;\n}\n\nstatic int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\tin = (exit_qualification & 8) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tskip_emulated_instruction(vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\nstatic bool nested_cr0_valid(struct vmcs12 *vmcs12, unsigned long val)\n{\n\tunsigned long always_on = VMXON_CR0_ALWAYSON;\n\n\tif (nested_vmx_secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\talways_on &= ~(X86_CR0_PE | X86_CR0_PG);\n\treturn (val & always_on) == always_on;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_cr0_valid(vmcs12, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    ((val & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON))\n\t\t\treturn 1;\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\n/* called to set cr0 as approriate for clts instruction exit. */\nstatic void handle_clts(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We get here when L2 did CLTS, and L1 didn't shadow CR0.TS\n\t\t * but we did (!fpu_active). We need to keep GUEST_CR0.TS on,\n\t\t * just pretend it's off (also in arch.cr0 for fpu_activate).\n\t\t */\n\t\tvmcs_writel(CR0_READ_SHADOW,\n\t\t\tvmcs_readl(CR0_READ_SHADOW) & ~X86_CR0_TS);\n\t\tvcpu->arch.cr0 &= ~X86_CR0_TS;\n\t} else\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (irqchip_in_kernel(vcpu->kvm))\n\t\t\t\t\treturn 1;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn 1;\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\thandle_clts(vcpu);\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\tskip_emulated_instruction(vcpu);\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, reg;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr = vmcs_readl(GUEST_DR7);\n\tif (dr & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr;\n\t\t\tvcpu->run->debug.arch.pc =\n\t\t\t\tvmcs_readl(GUEST_CS_BASE) +\n\t\t\t\tvmcs_readl(GUEST_RIP);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tvmcs_writel(GUEST_DR7, vcpu->arch.dr7);\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\tu32 cpu_based_vm_exec_control;\n\n\t\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\t\tcpu_based_vm_exec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}\n\nstatic void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_MOV_DR_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_cpuid(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_cpuid(vcpu);\n\treturn 1;\n}\n\nstatic int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, data);\n\n\t/* FIXME: handling of bits 32:63 of rax, rdx */\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending irq */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\n\t/*\n\t * If the user space waits to inject interrupts, exit as soon as\n\t * possible\n\t */\n\tif (!irqchip_in_kernel(vcpu->kvm) &&\n\t    vcpu->run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_halt(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\treturn kvm_emulate_halt(vcpu);\n}\n\nstatic int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_hypercall(vcpu);\n\treturn 1;\n}\n\nstatic int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\tkvm_complete_insn_gp(vcpu, err);\n\n\treturn 1;\n}\n\nstatic int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_wbinvd(vcpu);\n\treturn 1;\n}\n\nstatic int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tskip_emulated_instruction(vcpu);\n\n\tif (kvm_task_switch(vcpu, tss_selector,\n\t\t\t    type == INTR_TYPE_SOFT_INTR ? idt_index : -1, reason,\n\t\t\t    has_error_code, error_code) == EMULATE_FAIL) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\t/* clear all local breakpoint enable flags */\n\tvmcs_writel(GUEST_DR7, vmcs_readl(GUEST_DR7) & ~0x55);\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\n\treturn 1;\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu32 error_code;\n\tint gla_validity;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tgla_validity = (exit_qualification >> 7) & 0x3;\n\tif (gla_validity != 0x3 && gla_validity != 0x1 && gla_validity != 0) {\n\t\tprintk(KERN_ERR \"EPT: Handling EPT violation failed!\\n\");\n\t\tprintk(KERN_ERR \"EPT: GPA: 0x%lx, GVA: 0x%lx\\n\",\n\t\t\t(long unsigned int)vmcs_read64(GUEST_PHYSICAL_ADDRESS),\n\t\t\tvmcs_readl(GUEST_LINEAR_ADDRESS));\n\t\tprintk(KERN_ERR \"EPT: Exit qualification is 0x%lx\\n\",\n\t\t\t(long unsigned int)exit_qualification);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_VIOLATION;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* It is a write fault? */\n\terror_code = exit_qualification & (1U << 1);\n\t/* It is a fetch fault? */\n\terror_code |= (exit_qualification & (1U << 2)) << 2;\n\t/* ept page table is present? */\n\terror_code |= (exit_qualification >> 3) & 0x1;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic u64 ept_rsvd_mask(u64 spte, int level)\n{\n\tint i;\n\tu64 mask = 0;\n\n\tfor (i = 51; i > boot_cpu_data.x86_phys_bits; i--)\n\t\tmask |= (1ULL << i);\n\n\tif (level == 4)\n\t\t/* bits 7:3 reserved */\n\t\tmask |= 0xf8;\n\telse if (spte & (1ULL << 7))\n\t\t/*\n\t\t * 1GB/2MB page, bits 29:12 or 20:12 reserved respectively,\n\t\t * level == 1 if the hypervisor is using the ignored bit 7.\n\t\t */\n\t\tmask |= (PAGE_SIZE << ((level - 1) * 9)) - PAGE_SIZE;\n\telse if (level > 1)\n\t\t/* bits 6:3 reserved */\n\t\tmask |= 0x78;\n\n\treturn mask;\n}\n\nstatic void ept_misconfig_inspect_spte(struct kvm_vcpu *vcpu, u64 spte,\n\t\t\t\t       int level)\n{\n\tprintk(KERN_ERR \"%s: spte 0x%llx level %d\\n\", __func__, spte, level);\n\n\t/* 010b (write-only) */\n\tWARN_ON((spte & 0x7) == 0x2);\n\n\t/* 110b (write/execute) */\n\tWARN_ON((spte & 0x7) == 0x6);\n\n\t/* 100b (execute-only) and value not supported by logical processor */\n\tif (!cpu_has_vmx_ept_execute_only())\n\t\tWARN_ON((spte & 0x7) == 0x4);\n\n\t/* not 000b */\n\tif ((spte & 0x7)) {\n\t\tu64 rsvd_bits = spte & ept_rsvd_mask(spte, level);\n\n\t\tif (rsvd_bits != 0) {\n\t\t\tprintk(KERN_ERR \"%s: rsvd_bits = 0x%llx\\n\",\n\t\t\t\t\t __func__, rsvd_bits);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/* bits 5:3 are _not_ reserved for large page or leaf page */\n\t\tif ((rsvd_bits & 0x38) == 0) {\n\t\t\tu64 ept_mem_type = (spte & 0x38) >> 3;\n\n\t\t\tif (ept_mem_type == 2 || ept_mem_type == 3 ||\n\t\t\t    ept_mem_type == 7) {\n\t\t\t\tprintk(KERN_ERR \"%s: ept_mem_type=0x%llx\\n\",\n\t\t\t\t\t\t__func__, ept_mem_type);\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tu64 sptes[4];\n\tint nr_sptes, i, ret;\n\tgpa_t gpa;\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!kvm_io_bus_write(vcpu->kvm, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tret = handle_mmio_page_fault_common(vcpu, gpa, true);\n\tif (likely(ret == RET_MMIO_PF_EMULATE))\n\t\treturn x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==\n\t\t\t\t\t      EMULATE_DONE;\n\n\tif (unlikely(ret == RET_MMIO_PF_INVALID))\n\t\treturn kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);\n\n\tif (unlikely(ret == RET_MMIO_PF_RETRY))\n\t\treturn 1;\n\n\t/* It is the real ept misconfig */\n\tprintk(KERN_ERR \"EPT: Misconfiguration.\\n\");\n\tprintk(KERN_ERR \"EPT: GPA: 0x%llx\\n\", gpa);\n\n\tnr_sptes = kvm_mmu_get_spte_hierarchy(vcpu, gpa, sptes);\n\n\tfor (i = PT64_ROOT_LEVEL; i > PT64_ROOT_LEVEL - nr_sptes; --i)\n\t\tept_misconfig_inspect_spte(vcpu, sptes[i-1], i);\n\n\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_MISCONFIG;\n\n\treturn 0;\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending NMI */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tenum emulation_result err = EMULATE_DONE;\n\tint ret = 1;\n\tu32 cpu_exec_ctrl;\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tcpu_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tintr_window_requested = cpu_exec_ctrl & CPU_BASED_VIRTUAL_INTR_PENDING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (test_bit(KVM_REQ_EVENT, &vcpu->requests))\n\t\t\treturn 1;\n\n\t\terr = emulate_instruction(vcpu, EMULTYPE_NO_REEXECUTE);\n\n\t\tif (err == EMULATE_USER_EXIT) {\n\t\t\t++vcpu->stat.mmio_exits;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (err != EMULATE_DONE) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\tret = kvm_emulate_halt(vcpu);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __grow_ple_window(int val)\n{\n\tif (ple_window_grow < 1)\n\t\treturn ple_window;\n\n\tval = min(val, ple_window_actual_max);\n\n\tif (ple_window_grow < ple_window)\n\t\tval *= ple_window_grow;\n\telse\n\t\tval += ple_window_grow;\n\n\treturn val;\n}\n\nstatic int __shrink_ple_window(int val, int modifier, int minimum)\n{\n\tif (modifier < 1)\n\t\treturn ple_window;\n\n\tif (modifier < ple_window)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, minimum);\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old,\n\t                                      ple_window_shrink, ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\n/*\n * ple_window_actual_max is computed to be one grow_ple_window() below\n * ple_window_max. (See __grow_ple_window for the reason.)\n * This prevents overflows, because ple_window_max is int.\n * ple_window_max effectively rounded down to a multiple of ple_window_grow in\n * this process.\n * ple_window_max is also prevented from setting vmx->ple_window < ple_window.\n */\nstatic void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\n\tskip_emulated_instruction(vcpu);\n\tkvm_vcpu_on_spin(vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\nstatic int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\n/*\n * To run an L2 guest, we need a vmcs02 based on the L1-specified vmcs12.\n * We could reuse a single VMCS for all the L2 guests, but we also want the\n * option to allocate a separate vmcs02 for each separate loaded vmcs12 - this\n * allows keeping them loaded on the processor, and in the future will allow\n * optimizations where prepare_vmcs02 doesn't need to set all the fields on\n * every entry if they never change.\n * So we keep, in vmx->nested.vmcs02_pool, a cache of size VMCS02_POOL_SIZE\n * (>=0) with a vmcs02 for each recently loaded vmcs12s, most recent first.\n *\n * The following functions allocate and free a vmcs02 in this pool.\n */\n\n/* Get a VMCS from the pool to use as vmcs02 for the current vmcs12. */\nstatic struct loaded_vmcs *nested_get_current_vmcs02(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmx->nested.current_vmptr) {\n\t\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\t\treturn &item->vmcs02;\n\t\t}\n\n\tif (vmx->nested.vmcs02_num >= max(VMCS02_POOL_SIZE, 1)) {\n\t\t/* Recycle the least recently used VMCS. */\n\t\titem = list_entry(vmx->nested.vmcs02_pool.prev,\n\t\t\tstruct vmcs02_list, list);\n\t\titem->vmptr = vmx->nested.current_vmptr;\n\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\treturn &item->vmcs02;\n\t}\n\n\t/* Create a new VMCS */\n\titem = kmalloc(sizeof(struct vmcs02_list), GFP_KERNEL);\n\tif (!item)\n\t\treturn NULL;\n\titem->vmcs02.vmcs = alloc_vmcs();\n\tif (!item->vmcs02.vmcs) {\n\t\tkfree(item);\n\t\treturn NULL;\n\t}\n\tloaded_vmcs_init(&item->vmcs02);\n\titem->vmptr = vmx->nested.current_vmptr;\n\tlist_add(&(item->list), &(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num++;\n\treturn &item->vmcs02;\n}\n\n/* Free and remove from pool a vmcs02 saved for a vmcs12 (if there is one) */\nstatic void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmptr) {\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t\tvmx->nested.vmcs02_num--;\n\t\t\treturn;\n\t\t}\n}\n\n/*\n * Free all VMCSs saved for this vcpu, except the one pointed by\n * vmx->loaded_vmcs. We must be running L1, so vmx->loaded_vmcs\n * must be &vmx->vmcs01.\n */\nstatic void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\n\tWARN_ON(vmx->loaded_vmcs != &vmx->vmcs01);\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\t/*\n\t\t * Something will leak if the above WARN triggers.  Better than\n\t\t * a use-after-free.\n\t\t */\n\t\tif (vmx->loaded_vmcs == &item->vmcs02)\n\t\t\tcontinue;\n\n\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t\tvmx->nested.vmcs02_num--;\n\t}\n}\n\n/*\n * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),\n * set the success or error code of an emulated VMX instruction, as specified\n * by Vol 2B, VMX Instruction Reference, \"Conventions\".\n */\nstatic void nested_vmx_succeed(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));\n}\n\nstatic void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}\n\nstatic void nested_vmx_failValid(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu32 vm_instruction_error)\n{\n\tif (to_vmx(vcpu)->nested.current_vmptr == -1ull) {\n\t\t/*\n\t\t * failValid writes the error number to the current VMCS, which\n\t\t * can't be done there isn't a current VMCS.\n\t\t */\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn;\n\t}\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_ZF);\n\tget_vmcs12(vcpu)->vm_instruction_error = vm_instruction_error;\n\t/*\n\t * We don't need to force a shadow sync because\n\t * VM_INSTRUCTION_ERROR is not shadowed\n\t */\n}\n\nstatic enum hrtimer_restart vmx_preemption_timer_fn(struct hrtimer *timer)\n{\n\tstruct vcpu_vmx *vmx =\n\t\tcontainer_of(timer, struct vcpu_vmx, nested.preemption_timer);\n\n\tvmx->nested.preemption_timer_expired = true;\n\tkvm_make_request(KVM_REQ_EVENT, &vmx->vcpu);\n\tkvm_vcpu_kick(&vmx->vcpu);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * Decode the memory-address operand of a vmx instruction, as recorded on an\n * exit caused by such an instruction (run by a guest hypervisor).\n * On success, returns 0. When the operand is invalid, returns 1 and throws\n * #UD or #GP.\n */\nstatic int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; /* holds the displacement */\n\n\tif (addr_size == 1) /* 32 bit */\n\t\t*ret &= 0xffffffff;\n\n\t/*\n\t * TODO: throw #GP (and return 1) in various cases that the VM*\n\t * instructions require it - e.g., offset beyond segment limit,\n\t * unusable or unreadable/unwritable segment, non-canonical 64-bit\n\t * address, and so on. Currently these are not checked.\n\t */\n\treturn 0;\n}\n\n/*\n * This function performs the various checks including\n * - if it's 4KB aligned\n * - No bits beyond the physical address width are set\n * - Returns 0 on success or else 1\n * (Intel SDM Section 30.3)\n */\nstatic int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,\n\t\t\t\t  gpa_t *vmpointer)\n{\n\tgva_t gva;\n\tgpa_t vmptr;\n\tstruct x86_exception e;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmcs_read32(VMX_INSTRUCTION_INFO), &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vmptr,\n\t\t\t\tsizeof(vmptr), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_VMON:\n\t\t/*\n\t\t * SDM 3: 24.11.5\n\t\t * The first 4 bytes of VMXON region contain the supported\n\t\t * VMCS revision identifier\n\t\t *\n\t\t * Note - IA32_VMX_BASIC[48] will never be 1\n\t\t * for the nested case;\n\t\t * which replaces physical address width with 32\n\t\t *\n\t\t */\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL ||\n\t\t    *(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tkunmap(page);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tkunmap(page);\n\t\tvmx->nested.vmxon_ptr = vmptr;\n\t\tbreak;\n\tcase EXIT_REASON_VMCLEAR:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_INVALID_ADDRESS);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase EXIT_REASON_VMPTRLD:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_INVALID_ADDRESS);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 1; /* shouldn't happen */\n\t}\n\n\tif (vmpointer)\n\t\t*vmpointer = vmptr;\n\treturn 0;\n}\n\n/*\n * Emulate the VMXON instruction.\n * Currently, we just remember that VMX is active, and do not save or even\n * inspect the argument to VMXON (the so-called \"VMXON pointer\") because we\n * do not currently need to store anything in that guest-allocated memory\n * region. Consequently, VMCLEAR and VMPTRLD also do not verify that the their\n * argument is different from the VMXON pointer (which the spec says they do).\n */\nstatic int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs *shadow_vmcs;\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\t/* The Intel VMX Instruction Reference lists a bunch of bits that\n\t * are prerequisite to running VMXON, most notably cr4.VMXE must be\n\t * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).\n\t * Otherwise, we should fail with #UD. We test these now:\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE) ||\n\t    !kvm_read_cr0_bits(vcpu, X86_CR0_PE) ||\n\t    (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif (is_long_mode(vcpu) && !cs.l) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMON, NULL))\n\t\treturn 1;\n\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif ((vmx->nested.msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (enable_shadow_vmcs) {\n\t\tshadow_vmcs = alloc_vmcs();\n\t\tif (!shadow_vmcs)\n\t\t\treturn -ENOMEM;\n\t\t/* mark vmcs as shadow */\n\t\tshadow_vmcs->revision_id |= (1u << 31);\n\t\t/* init shadow vmcs */\n\t\tvmcs_clear(shadow_vmcs);\n\t\tvmx->nested.current_shadow_vmcs = shadow_vmcs;\n\t}\n\n\tINIT_LIST_HEAD(&(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num = 0;\n\n\thrtimer_init(&vmx->nested.preemption_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tvmx->nested.preemption_timer.function = vmx_preemption_timer_fn;\n\n\tvmx->nested.vmxon = true;\n\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\n/*\n * Intel's VMX Instruction Reference specifies a common set of prerequisites\n * for running VMX instructions (except VMXON, whose prerequisites are\n * slightly different). It also specifies what exception to inject otherwise.\n */\nstatic int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif ((vmx_get_rflags(vcpu) & X86_EFLAGS_VM) ||\n\t    (is_long_mode(vcpu) && !cs.l)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline void nested_release_vmcs12(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control;\n\tif (vmx->nested.current_vmptr == -1ull)\n\t\treturn;\n\n\t/* current_vmptr and current_vmcs12 are always set/reset together */\n\tif (WARN_ON(vmx->nested.current_vmcs12 == NULL))\n\t\treturn;\n\n\tif (enable_shadow_vmcs) {\n\t\t/* copy to memory all shadowed fields in case\n\t\t   they were modified */\n\t\tcopy_shadow_to_vmcs12(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\t}\n\tkunmap(vmx->nested.current_vmcs12_page);\n\tnested_release_page(vmx->nested.current_vmcs12_page);\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n}\n\n/*\n * Free whatever needs to be freed from vmx->nested when L1 goes down, or\n * just stops using VMX.\n */\nstatic void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}\n\n/* Emulate the VMXOFF instruction */\nstatic int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMCLEAR instruction */\nstatic int handle_vmclear(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tstruct vmcs12 *vmcs12;\n\tstruct page *page;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMCLEAR, &vmptr))\n\t\treturn 1;\n\n\tif (vmptr == vmx->nested.current_vmptr)\n\t\tnested_release_vmcs12(vmx);\n\n\tpage = nested_get_page(vcpu, vmptr);\n\tif (page == NULL) {\n\t\t/*\n\t\t * For accurate processor emulation, VMCLEAR beyond available\n\t\t * physical memory should do nothing at all. However, it is\n\t\t * possible that a nested vmx bug, not a guest hypervisor bug,\n\t\t * resulted in this case, so let's shut down before doing any\n\t\t * more damage:\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn 1;\n\t}\n\tvmcs12 = kmap(page);\n\tvmcs12->launch_state = 0;\n\tkunmap(page);\n\tnested_release_page(page);\n\n\tnested_free_vmcs02(vmx, vmptr);\n\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch);\n\n/* Emulate the VMLAUNCH instruction */\nstatic int handle_vmlaunch(struct kvm_vcpu *vcpu)\n{\n\treturn nested_vmx_run(vcpu, true);\n}\n\n/* Emulate the VMRESUME instruction */\nstatic int handle_vmresume(struct kvm_vcpu *vcpu)\n{\n\n\treturn nested_vmx_run(vcpu, false);\n}\n\nenum vmcs_field_type {\n\tVMCS_FIELD_TYPE_U16 = 0,\n\tVMCS_FIELD_TYPE_U64 = 1,\n\tVMCS_FIELD_TYPE_U32 = 2,\n\tVMCS_FIELD_TYPE_NATURAL_WIDTH = 3\n};\n\nstatic inline int vmcs_field_type(unsigned long field)\n{\n\tif (0x1 & field)\t/* the *_HIGH fields are all 32 bit */\n\t\treturn VMCS_FIELD_TYPE_U32;\n\treturn (field >> 13) & 0x3 ;\n}\n\nstatic inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}\n\n/*\n * Read a vmcs12 field. Since these can have varying lengths and we return\n * one type, we chose the biggest type (u64) and zero-extend the return value\n * to that size. Note that the caller, handle_vmread, might need to use only\n * some of the bits we return here (e.g., on 32-bit guests, only 32 bits of\n * 64-bit fields are to be returned).\n */\nstatic inline bool vmcs12_read_any(struct kvm_vcpu *vcpu,\n\t\t\t\t\tunsigned long field, u64 *ret)\n{\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p;\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\tp = ((char *)(get_vmcs12(vcpu))) + offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*ret = *((natural_width *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*ret = *((u16 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*ret = *((u32 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*ret = *((u64 *)p);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0; /* can never happen. */\n\t}\n}\n\n\nstatic inline bool vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t    unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn false;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn true;\n\tdefault:\n\t\treturn false; /* can never happen. */\n\t}\n\n}\n\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)\n{\n\tint i;\n\tunsigned long field;\n\tu64 field_value;\n\tstruct vmcs *shadow_vmcs = vmx->nested.current_shadow_vmcs;\n\tconst unsigned long *fields = shadow_read_write_fields;\n\tconst int num_fields = max_shadow_read_write_fields;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tfield = fields[i];\n\t\tswitch (vmcs_field_type(field)) {\n\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\tfield_value = vmcs_read16(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\tfield_value = vmcs_read32(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\tfield_value = vmcs_read64(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\tfield_value = vmcs_readl(field);\n\t\t\tbreak;\n\t\t}\n\t\tvmcs12_write_any(&vmx->vcpu, field, field_value);\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long *fields[] = {\n\t\tshadow_read_write_fields,\n\t\tshadow_read_only_fields\n\t};\n\tconst int max_fields[] = {\n\t\tmax_shadow_read_write_fields,\n\t\tmax_shadow_read_only_fields\n\t};\n\tint i, q;\n\tunsigned long field;\n\tu64 field_value = 0;\n\tstruct vmcs *shadow_vmcs = vmx->nested.current_shadow_vmcs;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (q = 0; q < ARRAY_SIZE(fields); q++) {\n\t\tfor (i = 0; i < max_fields[q]; i++) {\n\t\t\tfield = fields[q][i];\n\t\t\tvmcs12_read_any(&vmx->vcpu, field, &field_value);\n\n\t\t\tswitch (vmcs_field_type(field)) {\n\t\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\t\tvmcs_write16(field, (u16)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\t\tvmcs_write32(field, (u32)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\t\tvmcs_write64(field, (u64)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\t\tvmcs_writel(field, (long)field_value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\n/*\n * VMX instructions which assume a current vmcs12 (i.e., that VMPTRLD was\n * used before) all generate the same failure when it is missing.\n */\nstatic int nested_vmx_check_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (vmx->nested.current_vmptr == -1ull) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\t/* Decode instruction info and find the field to read */\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\t/* Read the field, zero-extended to a u64 field_value */\n\tif (!vmcs12_read_any(vcpu, field, &field_value)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\t/*\n\t * Now copy part of this value to register or memory, as requested.\n\t * Note that the number of bits actually copied is 32 or 64 depending\n\t * on the guest's mode (32 or 64 bit), not on the given field's length.\n\t */\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, &gva))\n\t\t\treturn 1;\n\t\t/* _system ok, as nested_vmx_check_permission verified cpl=0 */\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n\nstatic int handle_vmwrite(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tgva_t gva;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\t/* The value to write might be 32 or 64 bits, depending on L1's long\n\t * mode, and eventually we need to write that into a field of several\n\t * possible lengths. The code below first zero-extends the value to 64\n\t * bit (field_value), and then copies only the approriate number of\n\t * bits into the vmcs12 field.\n\t */\n\tu64 field_value = 0;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\tif (vmx_instruction_info & (1u << 10))\n\t\tfield_value = kvm_register_readl(vcpu,\n\t\t\t(((vmx_instruction_info) >> 3) & 0xf));\n\telse {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, &gva))\n\t\t\treturn 1;\n\t\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t   &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {\n\t\t\tkvm_inject_page_fault(vcpu, &e);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs_field_readonly(field)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (!vmcs12_write_any(vcpu, field, field_value)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMPTRLD instruction */\nstatic int handle_vmptrld(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tu32 exec_control;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMPTRLD, &vmptr))\n\t\treturn 1;\n\n\tif (vmx->nested.current_vmptr != vmptr) {\n\t\tstruct vmcs12 *new_vmcs12;\n\t\tstruct page *page;\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tnew_vmcs12 = kmap(page);\n\t\tif (new_vmcs12->revision_id != VMCS12_REVISION) {\n\t\t\tkunmap(page);\n\t\t\tnested_release_page_clean(page);\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tnested_release_vmcs12(vmx);\n\t\tvmx->nested.current_vmptr = vmptr;\n\t\tvmx->nested.current_vmcs12 = new_vmcs12;\n\t\tvmx->nested.current_vmcs12_page = page;\n\t\tif (enable_shadow_vmcs) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control |= SECONDARY_EXEC_SHADOW_VMCS;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t\t\tvmcs_write64(VMCS_LINK_POINTER,\n\t\t\t\t     __pa(vmx->nested.current_shadow_vmcs));\n\t\t\tvmx->nested.sync_shadow_vmcs = true;\n\t\t}\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMPTRST instruction */\nstatic int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, &vmcs_gva))\n\t\treturn 1;\n\t/* ok to use *_system, as nested_vmx_check_permission verified cpl=0 */\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the INVEPT instruction */\nstatic int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\t/* Trap single context invalidation invept calls */\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n\t[EXIT_REASON_VMREAD]                  = handle_vmread,\n\t[EXIT_REASON_VMRESUME]                = handle_vmresume,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n\t[EXIT_REASON_VMOFF]                   = handle_vmoff,\n\t[EXIT_REASON_VMON]                    = handle_vmon,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_invept,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tgpa_t bitmap, last_bitmap;\n\tunsigned int port;\n\tint size;\n\tu8 b;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn 1;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_read_guest(vcpu->kvm, bitmap, &b, 1))\n\t\t\t\treturn 1;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn 1;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an MSR access access,\n * rather than handle it ourselves in L0. I.e., check whether L1 expressed\n * disinterest in the current event (read or write a specific MSR) by using an\n * MSR bitmap. This may be the case even when L0 doesn't use MSR bitmaps.\n */\nstatic bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12, u32 exit_reason)\n{\n\tu32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tgpa_t bitmap;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 1;\n\n\t/*\n\t * The MSR_BITMAP page is divided into four 1024-byte bitmaps,\n\t * for the four combinations of read/write and low/high MSR numbers.\n\t * First we need to figure out which of the four to use:\n\t */\n\tbitmap = vmcs12->msr_bitmap;\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\tbitmap += 2048;\n\tif (msr_index >= 0xc0000000) {\n\t\tmsr_index -= 0xc0000000;\n\t\tbitmap += 1024;\n\t}\n\n\t/* Then read the msr_index'th bit from this bitmap: */\n\tif (msr_index < 1024*8) {\n\t\tunsigned char b;\n\t\tif (kvm_read_guest(vcpu->kvm, bitmap + msr_index/8, &b, 1))\n\t\t\treturn 1;\n\t\treturn 1 & (b >> (msr_index & 7));\n\t} else\n\t\treturn 1; /* let L1 handle the wrong parameter */\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle a CR access exit,\n * rather than handle it ourselves in L0. I.e., check if L1 wanted to\n * intercept (via guest_host_mask etc.) the current event.\n */\nstatic bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint cr = exit_qualification & 15;\n\tint reg = (exit_qualification >> 8) & 15;\n\tunsigned long val = kvm_register_readl(vcpu, reg);\n\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (vmcs12->cr0_guest_host_mask &\n\t\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((vmcs12->cr3_target_count >= 1 &&\n\t\t\t\t\tvmcs12->cr3_target_value0 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 2 &&\n\t\t\t\t\tvmcs12->cr3_target_value1 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 3 &&\n\t\t\t\t\tvmcs12->cr3_target_value2 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 4 &&\n\t\t\t\t\tvmcs12->cr3_target_value3 == val))\n\t\t\t\treturn 0;\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR3_LOAD_EXITING))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (vmcs12->cr4_guest_host_mask &\n\t\t\t    (vmcs12->cr4_read_shadow ^ val))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tif ((vmcs12->cr0_guest_host_mask & X86_CR0_TS) &&\n\t\t    (vmcs12->cr0_read_shadow & X86_CR0_TS))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 1: /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR3_STORE_EXITING)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR8_STORE_EXITING)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\t/*\n\t\t * lmsw can change bits 1..3 of cr0, and only set bit 0 of\n\t\t * cr0. Other attempted changes are ignored, with no exit.\n\t\t */\n\t\tif (vmcs12->cr0_guest_host_mask & 0xe &\n\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\treturn 1;\n\t\tif ((vmcs12->cr0_guest_host_mask & 0x1) &&\n\t\t    !(vmcs12->cr0_read_shadow & 0x1) &&\n\t\t    (val & 0x1))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an exit, or 0 if we\n * should handle it ourselves in L0 (and then continue L2). Only call this\n * when in is_guest_mode (L2).\n */\nstatic bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn 0;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn 0;\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n\tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = exit_reason;\n\t}\n\treturn 0;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\tif (irr == -1 || tpr < irr) {\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(TPR_THRESHOLD, irr);\n}\n\nstatic void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\tu32 sec_exec_control;\n\n\t/*\n\t * There is not point to enable virtualize x2apic without enable\n\t * apicv\n\t */\n\tif (!cpu_has_vmx_virtualize_x2apic_mode() ||\n\t\t\t\t!vmx_vm_has_apicv(vcpu->kvm))\n\t\treturn;\n\n\tif (!vm_need_tpr_shadow(vcpu->kvm))\n\t\treturn;\n\n\tsec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tif (set) {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t} else {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t}\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);\n\n\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Currently we do not handle the nested case where L2 has an\n\t * APIC access page of its own; that page is still pinned.\n\t * Hence, we skip the case where the VCPU is in guest mode _and_\n\t * L1 prepared an APIC access page for L2.\n\t *\n\t * For the case where L1 and L2 share the same APIC access page\n\t * (flexpriority=Y but SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES clear\n\t * in the vmcs12), this function will only update either the vmcs01\n\t * or the vmcs02.  If the former, the vmcs02 will be updated by\n\t * prepare_vmcs02.  If the latter, the vmcs01 will be updated in\n\t * the next L2->L1 exit.\n\t */\n\tif (!is_guest_mode(vcpu) ||\n\t    !nested_cpu_has2(vmx->nested.current_vmcs12,\n\t\t\t     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (!vmx_vm_has_apicv(kvm))\n\t\treturn;\n\n\tif (isr == -1)\n\t\tisr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\tif (max_irr == -1)\n\t\treturn;\n\n\t/*\n\t * If a vmexit is needed, vmx_check_nested_events handles it.\n\t */\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn;\n\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmx_set_rvi(max_irr);\n\t\treturn;\n\t}\n\n\t/*\n\t * Fall back to pre-APICv interrupt injection since L2\n\t * is run without virtual interrupt delivery.\n\t */\n\tif (!kvm_event_needs_reinjection(vcpu) &&\n\t    vmx_interrupt_allowed(vcpu)) {\n\t\tkvm_queue_interrupt(vcpu, max_irr, false);\n\t\tvmx_inject_irq(vcpu);\n\t}\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!vmx_vm_has_apicv(vcpu->kvm))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n\nstatic void vmx_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * If external interrupt exists, IF bit is set in rflags/eflags on the\n\t * interrupt stack frame, and interrupt will be enabled on a return\n\t * from interrupt handler.\n\t */\n\tif ((exit_intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) {\n\t\tunsigned int vector;\n\t\tunsigned long entry;\n\t\tgate_desc *desc;\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n#ifdef CONFIG_X86_64\n\t\tunsigned long tmp;\n#endif\n\n\t\tvector =  exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\tdesc = (gate_desc *)vmx->host_idt_base + vector;\n\t\tentry = gate_offset(*desc);\n\t\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\t\"push $%c[ss]\\n\\t\"\n\t\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\t\"pushf\\n\\t\"\n\t\t\t\"orl $0x200, (%%\" _ASM_SP \")\\n\\t\"\n\t\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\t\t\"call *%[entry]\\n\\t\"\n\t\t\t:\n#ifdef CONFIG_X86_64\n\t\t\t[sp]\"=&r\"(tmp)\n#endif\n\t\t\t:\n\t\t\t[entry]\"r\"(entry),\n\t\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t\t[cs]\"i\"(__KERNEL_CS)\n\t\t\t);\n\t} else\n\t\tlocal_irq_enable();\n}\n\nstatic bool vmx_mpx_supported(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (cpu_has_virtual_nmis()) {\n\t\tif (vmx->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->soft_vnmi_blocked))\n\t\tvmx->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(), vmx->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}\n\nstatic void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\ttrace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n\nstatic void vmx_load_vmcs01(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\n\tif (vmx->loaded_vmcs == &vmx->vmcs01)\n\t\treturn;\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n}\n\nstatic void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tfree_vpid(vmx);\n\tleave_guest_mode(vcpu);\n\tvmx_load_vmcs01(vcpu);\n\tfree_nested(vmx);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n\tkfree(vmx->guest_msrs);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n}\n\nstatic struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tint err;\n\tstruct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tint cpu;\n\n\tif (!vmx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tallocate_vpid(vmx);\n\n\terr = kvm_vcpu_init(&vmx->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_vcpu;\n\n\tvmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) * sizeof(vmx->guest_msrs[0])\n\t\t     > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tif (!vmx->guest_msrs) {\n\t\tgoto uninit_vcpu;\n\t}\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx->loaded_vmcs->vmcs = alloc_vmcs();\n\tif (!vmx->loaded_vmcs->vmcs)\n\t\tgoto free_msrs;\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(__pa(per_cpu(vmxarea, raw_smp_processor_id())));\n\tloaded_vmcs_init(vmx->loaded_vmcs);\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxoff();\n\n\tcpu = get_cpu();\n\tvmx_vcpu_load(&vmx->vcpu, cpu);\n\tvmx->vcpu.cpu = cpu;\n\terr = vmx_vcpu_setup(vmx);\n\tvmx_vcpu_put(&vmx->vcpu);\n\tput_cpu();\n\tif (err)\n\t\tgoto free_vmcs;\n\tif (vm_need_virtualize_apic_accesses(kvm)) {\n\t\terr = alloc_apic_access_page(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept) {\n\t\tif (!kvm->arch.ept_identity_map_addr)\n\t\t\tkvm->arch.ept_identity_map_addr =\n\t\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t\terr = init_rmode_identity_map(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n\n\treturn &vmx->vcpu;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_msrs:\n\tkfree(vmx->guest_msrs);\nuninit_vcpu:\n\tkvm_vcpu_uninit(&vmx->vcpu);\nfree_vcpu:\n\tfree_vpid(vmx);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n\treturn ERR_PTR(err);\n}\n\nstatic void __init vmx_check_processor_compat(void *rtn)\n{\n\tstruct vmcs_config vmcs_conf;\n\n\t*(int *)rtn = 0;\n\tif (setup_vmcs_config(&vmcs_conf) < 0)\n\t\t*(int *)rtn = -EIO;\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\t*(int *)rtn = -EIO;\n\t}\n}\n\nstatic int get_ept_level(void)\n{\n\treturn VMX_EPT_DEFAULT_GAW + 1;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu64 ret;\n\n\t/* For VT-d and EPT combination\n\t * 1. MMIO: always map as UC\n\t * 2. EPT with VT-d:\n\t *   a. VT-d without snooping control feature: can't guarantee the\n\t *\tresult, try to trust guest.\n\t *   b. VT-d with snooping control feature: snooping control feature of\n\t *\tVT-d engine can guarantee the cache correctness. Just set it\n\t *\tto WB to keep consistent with host. So the same as item 3.\n\t * 3. EPT without VT-d: always map as WB and set IPAT=1 to keep\n\t *    consistent with host MTRR\n\t */\n\tif (is_mmio)\n\t\tret = MTRR_TYPE_UNCACHABLE << VMX_EPT_MT_EPTE_SHIFT;\n\telse if (kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\tret = kvm_get_guest_memory_type(vcpu, gfn) <<\n\t\t      VMX_EPT_MT_EPTE_SHIFT;\n\telse\n\t\tret = (MTRR_TYPE_WRBACK << VMX_EPT_MT_EPTE_SHIFT)\n\t\t\t| VMX_EPT_IPAT_BIT;\n\n\treturn ret;\n}\n\nstatic int vmx_get_lpage_level(void)\n{\n\tif (enable_ept && !cpu_has_vmx_ept_1g_page())\n\t\treturn PT_DIRECTORY_LEVEL;\n\telse\n\t\t/* For shadow and EPT supported 1GB page */\n\t\treturn PT_PDPE_LEVEL;\n}\n\nstatic void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmx->rdtscp_enabled = false;\n\tif (vmx_rdtscp_supported()) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\tif (exec_control & SECONDARY_EXEC_RDTSCP) {\n\t\t\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\t\tif (best && (best->edx & bit(X86_FEATURE_RDTSCP)))\n\t\t\t\tvmx->rdtscp_enabled = true;\n\t\t\telse {\n\t\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\t\texec_control);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Exposing INVPCID only when PCID is exposed */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    best && (best->ebx & bit(X86_FEATURE_INVPCID)) &&\n\t    guest_cpuid_has_pcid(vcpu)) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control |= SECONDARY_EXEC_ENABLE_INVPCID;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t     exec_control);\n\t} else {\n\t\tif (cpu_has_secondary_exec_ctrls()) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t     exec_control);\n\t\t}\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n}\n\nstatic void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}\n\nstatic void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason;\n\n\tif (fault->error_code & PFERR_RSVD_MASK)\n\t\texit_reason = EXIT_REASON_EPT_MISCONFIG;\n\telse\n\t\texit_reason = EXIT_REASON_EPT_VIOLATION;\n\tnested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);\n\tvmcs12->guest_physical_address = fault->address;\n}\n\n/* Callbacks for nested_ept_init_mmu_context: */\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}\n\nstatic void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_init_shadow_ept_mmu(vcpu, &vcpu->arch.mmu,\n\t\t\tnested_vmx_ept_caps & VMX_EPT_EXECUTE_ONLY_BIT);\n\n\tvcpu->arch.mmu.set_cr3           = vmx_set_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;\n\tvcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;\n\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic void vmx_inject_page_fault_nested(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON(!is_guest_mode(vcpu));\n\n\t/* TODO: also check PFEC_MATCH/MASK, not just EB.PF. */\n\tif (vmcs12->exception_bitmap & (1u << PF_VECTOR))\n\t\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\telse\n\t\tkvm_inject_page_fault(vcpu, fault);\n}\n\nstatic bool nested_get_vmcs12_pages(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {\n\t\t/* TODO: Also verify bits beyond physical address width are 0 */\n\t\tif (!PAGE_ALIGNED(vmcs12->apic_access_addr))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Translate L1 physical address to host physical\n\t\t * address for vmcs02. Keep the page pinned, so this\n\t\t * physical address remains valid. We keep a reference\n\t\t * to it so we can release it later.\n\t\t */\n\t\tif (vmx->nested.apic_access_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page =\n\t\t\tnested_get_page(vcpu, vmcs12->apic_access_addr);\n\t}\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\t/* TODO: Also verify bits beyond physical address width are 0 */\n\t\tif (!PAGE_ALIGNED(vmcs12->virtual_apic_page_addr))\n\t\t\treturn false;\n\n\t\tif (vmx->nested.virtual_apic_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page =\n\t\t\tnested_get_page(vcpu, vmcs12->virtual_apic_page_addr);\n\n\t\t/*\n\t\t * Failing the vm entry is _not_ what the processor does\n\t\t * but it's basically the only possibility we have.\n\t\t * We could still enter the guest if CR8 load exits are\n\t\t * enabled, CR8 store exits are enabled, and virtualize APIC\n\t\t * access is disabled; in this case the processor would never\n\t\t * use the TPR shadow and we could simply clear the bit from\n\t\t * the execution control.  But such a configuration is useless,\n\t\t * so let's keep the code simple.\n\t\t */\n\t\tif (!vmx->nested.virtual_apic_page)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void vmx_start_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tu64 preemption_timeout = get_vmcs12(vcpu)->vmx_preemption_timer_value;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vcpu->arch.virtual_tsc_khz == 0)\n\t\treturn;\n\n\t/* Make sure short timeouts reliably trigger an immediate vmexit.\n\t * hrtimer_start does not guarantee this. */\n\tif (preemption_timeout <= 1) {\n\t\tvmx_preemption_timer_fn(&vmx->nested.preemption_timer);\n\t\treturn;\n\t}\n\n\tpreemption_timeout <<= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n\tpreemption_timeout *= 1000000;\n\tdo_div(preemption_timeout, vcpu->arch.virtual_tsc_khz);\n\thrtimer_start(&vmx->nested.preemption_timer,\n\t\t      ns_to_ktime(preemption_timeout), HRTIMER_MODE_REL);\n}\n\n/*\n * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested\n * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function \"merges\" it\n * with L0's requirements for its guest (a.k.a. vmcs01), so we can run the L2\n * guest in a way that will both be appropriate to L1's requests, and our\n * needs. In addition to modifying the active vmcs (which is vmcs02), this\n * function also has additional necessary side-effects, like setting various\n * vcpu->arch fields.\n */\nstatic void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\texec_control &= ~(PIN_BASED_VMX_PREEMPTION_TIMER |\n                          PIN_BASED_POSTED_INTR);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (vm_need_virtualize_apic_accesses(vmx->vcpu.kvm)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\t/*\n\t * Merging of IO and MSR bitmaps not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvmx->nested.vmcs01_tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\t/* shadow page tables on either EPT or shadow page tables */\n\tkvm_set_cr3(vcpu, vmcs12->guest_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n}\n\n/*\n * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1\n * for running an L2 nested guest.\n */\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\tstruct loaded_vmcs *vmcs02;\n\tbool ia32e;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\tskip_emulated_instruction(vcpu);\n\tvmcs12 = get_vmcs12(vcpu);\n\n\tif (enable_shadow_vmcs)\n\t\tcopy_shadow_to_vmcs12(vmx);\n\n\t/*\n\t * The nested entry process starts with enforcing various prerequisites\n\t * on vmcs12 as required by the Intel SDM, and act appropriately when\n\t * they fail: As the SDM explains, some conditions should cause the\n\t * instruction to fail, while others will cause the instruction to seem\n\t * to succeed, but return an EXIT_REASON_INVALID_STATE.\n\t * To speed up the normal (success) code path, we should avoid checking\n\t * for misconfigurations which will anyway be caught by the processor\n\t * when using the merged vmcs02.\n\t */\n\tif (vmcs12->launch_state == launch) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tlaunch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS\n\t\t\t       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);\n\t\treturn 1;\n\t}\n\n\tif (vmcs12->guest_activity_state != GUEST_ACTIVITY_ACTIVE &&\n\t    vmcs12->guest_activity_state != GUEST_ACTIVITY_HLT) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif ((vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_MSR_BITMAPS) &&\n\t\t\t!PAGE_ALIGNED(vmcs12->msr_bitmap)) {\n\t\t/*TODO: Also verify bits beyond physical address width are 0*/\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!nested_get_vmcs12_pages(vcpu, vmcs12)) {\n\t\t/*TODO: Also verify bits beyond physical address width are 0*/\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (vmcs12->vm_entry_msr_load_count > 0 ||\n\t    vmcs12->vm_exit_msr_load_count > 0 ||\n\t    vmcs12->vm_exit_msr_store_count > 0) {\n\t\tpr_warn_ratelimited(\"%s: VMCS MSR_{LOAD,STORE} unsupported\\n\",\n\t\t\t\t    __func__);\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,\n\t\t\t\tnested_vmx_true_procbased_ctls_low,\n\t\t\t\tnested_vmx_procbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->secondary_vm_exec_control,\n\t      nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->pin_based_vm_exec_control,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_exit_controls,\n\t\t\t\tnested_vmx_true_exit_ctls_low,\n\t\t\t\tnested_vmx_exit_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_entry_controls,\n\t\t\t\tnested_vmx_true_entry_ctls_low,\n\t\t\t\tnested_vmx_entry_ctls_high))\n\t{\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (((vmcs12->host_cr0 & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON) ||\n\t    ((vmcs12->host_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_ENTRY_INVALID_HOST_STATE_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!nested_cr0_valid(vmcs12, vmcs12->guest_cr0) ||\n\t    ((vmcs12->guest_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\treturn 1;\n\t}\n\tif (vmcs12->vmcs_link_pointer != -1ull) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_VMCS_LINK_PTR);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-entry control is 1, the following checks\n\t * are performed on the field for the IA32_EFER MSR:\n\t * - Bits reserved in the IA32_EFER MSR must be 0.\n\t * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of\n\t *   the IA-32e mode guest VM-exit control. It must also be identical\n\t *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to\n\t *   CR0.PG) is 1.\n\t */\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-exit control is 1, bits reserved in the\n\t * IA32_EFER MSR must be 0 in the field for that register. In addition,\n\t * the values of the LMA and LME bits in the field must each be that of\n\t * the host address-space size VM-exit control.\n\t */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME)) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We're finally done with prerequisite checking, and can start with\n\t * the nested entry.\n\t */\n\n\tvmcs02 = nested_get_current_vmcs02(vmx);\n\tif (!vmcs02)\n\t\treturn -ENOMEM;\n\n\tenter_guest_mode(vcpu);\n\n\tvmx->nested.vmcs01_tsc_offset = vmcs_read64(TSC_OFFSET);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = vmcs02;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs12->launch_state = 1;\n\n\tprepare_vmcs02(vcpu, vmcs12);\n\n\tif (vmcs12->guest_activity_state == GUEST_ACTIVITY_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\n\tvmx->nested.nested_run_pending = 1;\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn 1;\n}\n\n/*\n * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date\n * because L2 may have changed some cr0 bits directly (CRO_GUEST_HOST_MASK).\n * This function returns the new value we should put in vmcs12.guest_cr0.\n * It's not enough to just return the vmcs02 GUEST_CR0. Rather,\n *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now\n *     available in vmcs02 GUEST_CR0. (Note: It's enough to check that L0\n *     didn't trap the bit, because if L1 did, so would L0).\n *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have\n *     been modified by L2, and L1 knows it. So just leave the old value of\n *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0\n *     isn't relevant, because if L0 traps this bit it can set it to anything.\n *  3. Bits that L1 didn't trap, but L0 did. L1 believes the guest could have\n *     changed these bits, and therefore they need to be updated, but L0\n *     didn't necessarily allow them to be changed in GUEST_CR0 - and rather\n *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.\n */\nstatic inline unsigned long\nvmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |\n\t\t\tvcpu->arch.cr0_guest_owned_bits));\n}\n\nstatic inline unsigned long\nvmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |\n\t\t\tvcpu->arch.cr4_guest_owned_bits));\n}\n\nstatic void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tu32 idt_vectoring;\n\tunsigned int nr;\n\n\tif (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) {\n\t\tnr = vcpu->arch.exception.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (kvm_exception_is_soft(nr)) {\n\t\t\tvmcs12->vm_exit_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_EXCEPTION;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_HARD_EXCEPTION;\n\n\t\tif (vcpu->arch.exception.has_error_code) {\n\t\t\tidt_vectoring |= VECTORING_INFO_DELIVER_CODE_MASK;\n\t\t\tvmcs12->idt_vectoring_error_code =\n\t\t\t\tvcpu->arch.exception.error_code;\n\t\t}\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t} else if (vcpu->arch.nmi_injected) {\n\t\tvmcs12->idt_vectoring_info_field =\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR;\n\t} else if (vcpu->arch.interrupt.pending) {\n\t\tnr = vcpu->arch.interrupt.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (vcpu->arch.interrupt.soft) {\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_INTR;\n\t\t\tvmcs12->vm_entry_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_EXT_INTR;\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t}\n}\n\nstatic int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending ||\n\t\t    vcpu->arch.interrupt.pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\t/*\n\t\t * The NMI-triggered VM exit counts as injection:\n\t\t * clear this one and block further NMIs.\n\t\t */\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)\n{\n\tktime_t remaining =\n\t\thrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);\n\tu64 value;\n\n\tif (ktime_to_ns(remaining) <= 0)\n\t\treturn 0;\n\n\tvalue = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;\n\tdo_div(value, 1000000);\n\treturn value >> VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n}\n\n/*\n * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits\n * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),\n * and this function updates it to reflect the changes to the guest state while\n * L2 was running (and perhaps made some exits which were handled directly by L0\n * without going back to L1), and to reflect the exit reason.\n * Note that we do not have to copy here all VMCS fields, just those that\n * could have changed by the L2 guest or the exit - i.e., the guest-state and\n * exit-information fields only. Other fields are modified by L1 with VMWRITE,\n * which already writes to vmcs12 directly.\n */\nstatic void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t   u32 exit_reason, u32 exit_intr_info,\n\t\t\t   unsigned long exit_qualification)\n{\n\t/* update guest state fields: */\n\tvmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);\n\tvmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);\n\n\tvmcs12->guest_rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tvmcs12->guest_rip = kvm_register_read(vcpu, VCPU_REGS_RIP);\n\tvmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);\n\n\tvmcs12->guest_es_selector = vmcs_read16(GUEST_ES_SELECTOR);\n\tvmcs12->guest_cs_selector = vmcs_read16(GUEST_CS_SELECTOR);\n\tvmcs12->guest_ss_selector = vmcs_read16(GUEST_SS_SELECTOR);\n\tvmcs12->guest_ds_selector = vmcs_read16(GUEST_DS_SELECTOR);\n\tvmcs12->guest_fs_selector = vmcs_read16(GUEST_FS_SELECTOR);\n\tvmcs12->guest_gs_selector = vmcs_read16(GUEST_GS_SELECTOR);\n\tvmcs12->guest_ldtr_selector = vmcs_read16(GUEST_LDTR_SELECTOR);\n\tvmcs12->guest_tr_selector = vmcs_read16(GUEST_TR_SELECTOR);\n\tvmcs12->guest_es_limit = vmcs_read32(GUEST_ES_LIMIT);\n\tvmcs12->guest_cs_limit = vmcs_read32(GUEST_CS_LIMIT);\n\tvmcs12->guest_ss_limit = vmcs_read32(GUEST_SS_LIMIT);\n\tvmcs12->guest_ds_limit = vmcs_read32(GUEST_DS_LIMIT);\n\tvmcs12->guest_fs_limit = vmcs_read32(GUEST_FS_LIMIT);\n\tvmcs12->guest_gs_limit = vmcs_read32(GUEST_GS_LIMIT);\n\tvmcs12->guest_ldtr_limit = vmcs_read32(GUEST_LDTR_LIMIT);\n\tvmcs12->guest_tr_limit = vmcs_read32(GUEST_TR_LIMIT);\n\tvmcs12->guest_gdtr_limit = vmcs_read32(GUEST_GDTR_LIMIT);\n\tvmcs12->guest_idtr_limit = vmcs_read32(GUEST_IDTR_LIMIT);\n\tvmcs12->guest_es_ar_bytes = vmcs_read32(GUEST_ES_AR_BYTES);\n\tvmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);\n\tvmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);\n\tvmcs12->guest_ds_ar_bytes = vmcs_read32(GUEST_DS_AR_BYTES);\n\tvmcs12->guest_fs_ar_bytes = vmcs_read32(GUEST_FS_AR_BYTES);\n\tvmcs12->guest_gs_ar_bytes = vmcs_read32(GUEST_GS_AR_BYTES);\n\tvmcs12->guest_ldtr_ar_bytes = vmcs_read32(GUEST_LDTR_AR_BYTES);\n\tvmcs12->guest_tr_ar_bytes = vmcs_read32(GUEST_TR_AR_BYTES);\n\tvmcs12->guest_es_base = vmcs_readl(GUEST_ES_BASE);\n\tvmcs12->guest_cs_base = vmcs_readl(GUEST_CS_BASE);\n\tvmcs12->guest_ss_base = vmcs_readl(GUEST_SS_BASE);\n\tvmcs12->guest_ds_base = vmcs_readl(GUEST_DS_BASE);\n\tvmcs12->guest_fs_base = vmcs_readl(GUEST_FS_BASE);\n\tvmcs12->guest_gs_base = vmcs_readl(GUEST_GS_BASE);\n\tvmcs12->guest_ldtr_base = vmcs_readl(GUEST_LDTR_BASE);\n\tvmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);\n\tvmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);\n\tvmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);\n\n\tvmcs12->guest_interruptibility_info =\n\t\tvmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tvmcs12->guest_pending_dbg_exceptions =\n\t\tvmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;\n\telse\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_ACTIVE;\n\n\tif (nested_cpu_has_preemption_timer(vmcs12)) {\n\t\tif (vmcs12->vm_exit_controls &\n\t\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER)\n\t\t\tvmcs12->vmx_preemption_timer_value =\n\t\t\t\tvmx_get_preemption_timer_value(vcpu);\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\t}\n\n\t/*\n\t * In some cases (usually, nested EPT), L2 is allowed to change its\n\t * own CR3 without exiting. If it has changed it, we must keep it.\n\t * Of course, if L0 is using shadow page tables, GUEST_CR3 was defined\n\t * by L0, not L1 or L2, so we mustn't unconditionally copy it to vmcs12.\n\t *\n\t * Additionally, restore L2's PDPTR to vmcs12.\n\t */\n\tif (enable_ept) {\n\t\tvmcs12->guest_cr3 = vmcs_read64(GUEST_CR3);\n\t\tvmcs12->guest_pdptr0 = vmcs_read64(GUEST_PDPTR0);\n\t\tvmcs12->guest_pdptr1 = vmcs_read64(GUEST_PDPTR1);\n\t\tvmcs12->guest_pdptr2 = vmcs_read64(GUEST_PDPTR2);\n\t\tvmcs12->guest_pdptr3 = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tvmcs12->vm_entry_controls =\n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_IA32E_MODE) |\n\t\t(vm_entry_controls_get(to_vmx(vcpu)) & VM_ENTRY_IA32E_MODE);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_DEBUG_CONTROLS) {\n\t\tkvm_get_dr(vcpu, 7, (unsigned long *)&vmcs12->guest_dr7);\n\t\tvmcs12->guest_ia32_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t}\n\n\t/* TODO: These cannot have changed unless we have MSR bitmaps and\n\t * the relevant bit asks not to trap the change */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\tvmcs12->guest_ia32_pat = vmcs_read64(GUEST_IA32_PAT);\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)\n\t\tvmcs12->guest_ia32_efer = vcpu->arch.efer;\n\tvmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);\n\tvmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);\n\tvmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);\n\tif (vmx_mpx_supported())\n\t\tvmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\n\t/* update exit information fields: */\n\n\tvmcs12->vm_exit_reason = exit_reason;\n\tvmcs12->exit_qualification = exit_qualification;\n\n\tvmcs12->vm_exit_intr_info = exit_intr_info;\n\tif ((vmcs12->vm_exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK))\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\tvmcs12->idt_vectoring_info_field = 0;\n\tvmcs12->vm_exit_instruction_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tvmcs12->vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\n\tif (!(vmcs12->vm_exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY)) {\n\t\t/* vm_entry_intr_info_field is cleared on exit. Emulate this\n\t\t * instead of reading the real value. */\n\t\tvmcs12->vm_entry_intr_info_field &= ~INTR_INFO_VALID_MASK;\n\n\t\t/*\n\t\t * Transfer the event that L0 or L1 may wanted to inject into\n\t\t * L2 to IDT_VECTORING_INFO_FIELD.\n\t\t */\n\t\tvmcs12_save_pending_event(vcpu, vmcs12);\n\t}\n\n\t/*\n\t * Drop what we picked up for L2 via vmx_complete_interrupts. It is\n\t * preserved above and would only end up incorrectly in L1.\n\t */\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n}\n\n/*\n * A part of what we need to when the nested L2 guest exits and we want to\n * run its L1 parent, is to reset L1's guest state to the host state specified\n * in vmcs12.\n * This function is to be called not only on normal nested exit, but also on\n * a nested entry failure, as explained in Intel's spec, 3B.23.7 (\"VM-Entry\n * Failures During or After Loading Guest State\").\n * This function should be called when the active VMCS is L1's (vmcs01).\n */\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tstruct kvm_segment seg;\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->host_ia32_efer;\n\telse if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->host_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->host_rip);\n\tvmx_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\t/*\n\t * Note that calling vmx_set_cr0 is important, even if cr0 hasn't\n\t * actually changed, because it depends on the current state of\n\t * fpu_active (which may have changed).\n\t * Note that vmx_set_cr0 refers to efer set above.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->host_cr0);\n\t/*\n\t * If we did fpu_activate()/fpu_deactivate() during L2's run, we need\n\t * to apply the same changes to L1's vmcs. We just set cr0 correctly,\n\t * but we also need to update cr0_guest_host_mask and exception_bitmap.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = (vcpu->fpu_active ? X86_CR0_TS : 0);\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/*\n\t * Note that CR4_GUEST_HOST_MASK is already set in the original vmcs01\n\t * (KVM doesn't change it)- no reason to call set_cr4_guest_host_mask();\n\t */\n\tvcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);\n\tkvm_set_cr4(vcpu, vmcs12->host_cr4);\n\n\tnested_ept_uninit_mmu_context(vcpu);\n\n\tkvm_set_cr3(vcpu, vmcs12->host_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = kvm_inject_page_fault;\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->host_idtr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->host_gdtr_base);\n\n\t/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_CLEAR_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->host_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->host_ia32_pat;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tvmcs_write64(GUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\tvmcs12->host_ia32_perf_global_ctrl);\n\n\t/* Set L1 segment info according to Intel SDM\n\t    27.5.2 Loading Host Segment and Descriptor-Table Registers */\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.selector = vmcs12->host_cs_selector,\n\t\t.type = 11,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.g = 1\n\t};\n\tif (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tseg.l = 1;\n\telse\n\t\tseg.db = 1;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_CS);\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.type = 3,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.db = 1,\n\t\t.g = 1\n\t};\n\tseg.selector = vmcs12->host_ds_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_DS);\n\tseg.selector = vmcs12->host_es_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_ES);\n\tseg.selector = vmcs12->host_ss_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_SS);\n\tseg.selector = vmcs12->host_fs_selector;\n\tseg.base = vmcs12->host_fs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_FS);\n\tseg.selector = vmcs12->host_gs_selector;\n\tseg.base = vmcs12->host_gs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_GS);\n\tseg = (struct kvm_segment) {\n\t\t.base = vmcs12->host_tr_base,\n\t\t.limit = 0x67,\n\t\t.selector = vmcs12->host_tr_selector,\n\t\t.type = 11,\n\t\t.present = 1\n\t};\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_TR);\n\n\tkvm_set_dr(vcpu, 7, 0x400);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n}\n\n/*\n * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1\n * and modify vmcs12 to make it see what it would expect to see there if\n * L2 was its real guest. Must only be called when in L2 (is_guest_mode())\n */\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t       exit_qualification);\n\n\tvmx_load_vmcs01(vcpu);\n\n\tif ((exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t    && nested_exit_intr_ack_set(vcpu)) {\n\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\tWARN_ON(irq < 0);\n\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t}\n\n\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t       KVM_ISA_VMX);\n\n\tvm_entry_controls_init(vmx, vmcs_read32(VM_ENTRY_CONTROLS));\n\tvm_exit_controls_init(vmx, vmcs_read32(VM_EXIT_CONTROLS));\n\tvmx_segment_cache_clear(vmx);\n\n\t/* if no vmcs02 cache requested, remove the one we used */\n\tif (VMCS02_POOL_SIZE == 0)\n\t\tnested_free_vmcs02(vmx, vmx->nested.current_vmptr);\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t/* Update TSC_OFFSET if TSC was changed while L2 ran */\n\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\t/* This is needed for same reason as it was needed in prepare_vmcs02 */\n\tvmx->host_rsp = 0;\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_vcpu_reload_apic_access_page(vcpu);\n\n\t/*\n\t * Exiting from L2 to L1, we're now back to L1 which thinks it just\n\t * finished a VMLAUNCH or VMRESUME instruction, so we need to set the\n\t * success or failure flag accordingly.\n\t */\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->fail = 0;\n\t\tnested_vmx_failValid(vcpu, vmcs_read32(VM_INSTRUCTION_ERROR));\n\t} else\n\t\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tvmx->nested.sync_shadow_vmcs = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\n/*\n * Forcibly leave nested mode in order to be able to reset the VCPU later on.\n */\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\tfree_nested(to_vmx(vcpu));\n}\n\n/*\n * L1's failure to enter L2 is a subset of a normal exit, as explained in\n * 23.7 \"VM-entry failures during or after loading guest state\" (this also\n * lists the acceptable exit-reason and exit-qualification parameters).\n * It should only be called before L2 actually succeeded to run, and when\n * vmcs01 is current (it doesn't leave_guest_mode() or switch vmcss).\n */\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (ple_gap)\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.hardware_setup = hardware_setup,\n\t.hardware_unsetup = hardware_unsetup,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_enable = hardware_enable,\n\t.hardware_disable = hardware_disable,\n\t.cpu_has_accelerated_tpr = report_flexpriority,\n\n\t.vcpu_create = vmx_create_vcpu,\n\t.vcpu_free = vmx_free_vcpu,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_guest_switch = vmx_save_host_state,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_db_bp_intercept = update_exception_bitmap,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = vmx_decache_cr0_guest_bits,\n\t.decache_cr3 = vmx_decache_cr3,\n\t.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.set_cr3 = vmx_set_cr3,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.get_dr6 = vmx_get_dr6,\n\t.set_dr6 = vmx_set_dr6,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\t.fpu_deactivate = vmx_fpu_deactivate,\n\n\t.tlb_flush = vmx_flush_tlb,\n\n\t.run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.set_irq = vmx_inject_irq,\n\t.set_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = vmx_set_virtual_x2apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.vm_has_apicv = vmx_vm_has_apicv,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_posted_interrupt = vmx_deliver_posted_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.get_tdp_level = get_ept_level,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.get_lpage_level = vmx_get_lpage_level,\n\n\t.cpuid_update = vmx_cpuid_update,\n\n\t.rdtscp_supported = vmx_rdtscp_supported,\n\t.invpcid_supported = vmx_invpcid_supported,\n\n\t.set_supported_cpuid = vmx_set_supported_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.set_tsc_khz = vmx_set_tsc_khz,\n\t.read_tsc_offset = vmx_read_tsc_offset,\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\t.adjust_tsc_offset = vmx_adjust_tsc_offset,\n\t.compute_tsc_offset = vmx_compute_tsc_offset,\n\t.read_l1_tsc = vmx_read_l1_tsc,\n\n\t.set_tdp_cr3 = vmx_set_cr3,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_external_intr = vmx_handle_external_intr,\n\t.mpx_supported = vmx_mpx_supported,\n\n\t.check_nested_events = vmx_check_nested_events,\n\n\t.sched_in = vmx_sched_in,\n};\n\nstatic int __init vmx_init(void)\n{\n\tint r, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tvmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_a)\n\t\treturn -ENOMEM;\n\n\tr = -ENOMEM;\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_b)\n\t\tgoto out;\n\n\tvmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy)\n\t\tgoto out1;\n\n\tvmx_msr_bitmap_legacy_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy_x2apic)\n\t\tgoto out2;\n\n\tvmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode)\n\t\tgoto out3;\n\n\tvmx_msr_bitmap_longmode_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode_x2apic)\n\t\tgoto out4;\n\tvmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmread_bitmap)\n\t\tgoto out5;\n\n\tvmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmwrite_bitmap)\n\t\tgoto out6;\n\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tr = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\tgoto out7;\n\n#ifdef CONFIG_KEXEC\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tif (enable_apicv) {\n\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n\n\t\t/* According SDM, in x2apic mode, the whole id reg is used.\n\t\t * But in KVM, it only use the highest eight bits. Need to\n\t\t * intercept it */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n\t\t/* TMCCT */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n\t\t/* TPR */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n\t\t/* EOI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n\t\t/* SELF-IPI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n\t}\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\treturn 0;\n\nout7:\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\nout6:\n\tfree_page((unsigned long)vmx_vmread_bitmap);\nout5:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\nout4:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\nout3:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\nout2:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\nout1:\n\tfree_page((unsigned long)vmx_io_bitmap_b);\nout:\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\treturn r;\n}\n\nstatic void __exit vmx_exit(void)\n{\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\n\tfree_page((unsigned long)vmx_io_bitmap_b);\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\n\tfree_page((unsigned long)vmx_vmread_bitmap);\n\n#ifdef CONFIG_KEXEC\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n}\n\nmodule_init(vmx_init)\nmodule_exit(vmx_exit)\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <trace/events/kvm.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/fpu-internal.h> /* Ugh! */\n#include <asm/xcr.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n\n#define emul_to_vcpu(ctxt) \\\n\tcontainer_of(ctxt, struct kvm_vcpu, arch.emulate_ctxt)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\n#define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM\n#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nstruct kvm_x86_ops *kvm_x86_ops;\nEXPORT_SYMBOL_GPL(kvm_x86_ops);\n\nstatic bool ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nunsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nbool kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\nstatic bool backwards_tsc_observed = false;\n\n#define KVM_NR_SHARED_MSRS 16\n\nstruct kvm_shared_msrs_global {\n\tint nr;\n\tu32 msrs[KVM_NR_SHARED_MSRS];\n};\n\nstruct kvm_shared_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_shared_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_NR_SHARED_MSRS];\n};\n\nstatic struct kvm_shared_msrs_global __read_mostly shared_msrs_global;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstruct kvm_stats_debugfs_item debugfs_entries[] = {\n\t{ \"pf_fixed\", VCPU_STAT(pf_fixed) },\n\t{ \"pf_guest\", VCPU_STAT(pf_guest) },\n\t{ \"tlb_flush\", VCPU_STAT(tlb_flush) },\n\t{ \"invlpg\", VCPU_STAT(invlpg) },\n\t{ \"exits\", VCPU_STAT(exits) },\n\t{ \"io_exits\", VCPU_STAT(io_exits) },\n\t{ \"mmio_exits\", VCPU_STAT(mmio_exits) },\n\t{ \"signal_exits\", VCPU_STAT(signal_exits) },\n\t{ \"irq_window\", VCPU_STAT(irq_window_exits) },\n\t{ \"nmi_window\", VCPU_STAT(nmi_window_exits) },\n\t{ \"halt_exits\", VCPU_STAT(halt_exits) },\n\t{ \"halt_wakeup\", VCPU_STAT(halt_wakeup) },\n\t{ \"hypercalls\", VCPU_STAT(hypercalls) },\n\t{ \"request_irq\", VCPU_STAT(request_irq_exits) },\n\t{ \"irq_exits\", VCPU_STAT(irq_exits) },\n\t{ \"host_state_reload\", VCPU_STAT(host_state_reload) },\n\t{ \"efer_reload\", VCPU_STAT(efer_reload) },\n\t{ \"fpu_reload\", VCPU_STAT(fpu_reload) },\n\t{ \"insn_emulation\", VCPU_STAT(insn_emulation) },\n\t{ \"insn_emulation_fail\", VCPU_STAT(insn_emulation_fail) },\n\t{ \"irq_injections\", VCPU_STAT(irq_injections) },\n\t{ \"nmi_injections\", VCPU_STAT(nmi_injections) },\n\t{ \"mmu_shadow_zapped\", VM_STAT(mmu_shadow_zapped) },\n\t{ \"mmu_pte_write\", VM_STAT(mmu_pte_write) },\n\t{ \"mmu_pte_updated\", VM_STAT(mmu_pte_updated) },\n\t{ \"mmu_pde_zapped\", VM_STAT(mmu_pde_zapped) },\n\t{ \"mmu_flooded\", VM_STAT(mmu_flooded) },\n\t{ \"mmu_recycled\", VM_STAT(mmu_recycled) },\n\t{ \"mmu_cache_miss\", VM_STAT(mmu_cache_miss) },\n\t{ \"mmu_unsync\", VM_STAT(mmu_unsync) },\n\t{ \"remote_tlb_flush\", VM_STAT(remote_tlb_flush) },\n\t{ \"largepages\", VM_STAT(lpages) },\n\t{ NULL }\n};\n\nu64 __read_mostly host_xcr0;\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\t/* we need ensured the shared_msr_global have been updated */\n\tsmp_wmb();\n}\nEXPORT_SYMBOL_GPL(kvm_define_shared_msr);\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}\n\nvoid kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn;\n\tsmsr->values[slot].curr = value;\n\twrmsrl(shared_msrs_global.msrs[slot], value);\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_set_shared_msr);\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\nasmlinkage __visible void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\n#define EXCPT_FAULT\t\t0\n#define EXCPT_TRAP\t\t1\n#define EXCPT_ABORT\t\t2\n#define EXCPT_INTERRUPT\t\t3\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\nstatic bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\n/*\n * This function will be used to read from the physical memory of the currently\n * running guest. The difference to kvm_read_guest_page is that this function\n * can read from guest physical or from the guest's guest physical memory.\n */\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_read_guest_page(vcpu->kvm, real_gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page_mmu);\n\nint kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}\n\n/*\n * Load the pae pdptrs.  Return true is they are all valid.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] & vcpu->arch.mmu.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP |\n\t\t\t\t    X86_CR0_CD | X86_CR0_NW;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}\n\nint __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XSTATE_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XSTATE_BNDREGS)) != (!(xcr0 & XSTATE_BNDCSR)))\n\t\treturn 1;\n\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XSTATE_EXTEND_MASK)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_xcr);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_SMAP)\n\t\tupdate_permission_bitmask(vcpu, vcpu->arch.walk_mmu, false);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tint res;\n\n\tres = __kvm_set_dr(vcpu, dr, val);\n\tif (res > 0)\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\telse if (res < 0)\n\t\tkvm_inject_gp(vcpu, 0);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nstatic int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tif (_kvm_get_dr(vcpu, dr, val)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_read_pmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kvm_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * This list is modified at module load time to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in the beginning of the list.\n */\n\n#define KVM_SAVE_MSRS_BEGIN\t12\nstatic u32 msrs_to_save[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS\n};\n\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs[] = {\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n};\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct { /* extract of a clocksource struct */\n\t\tint vclock_mode;\n\t\tcycle_t\tcycle_last;\n\t\tcycle_t\tmask;\n\t\tu32\tmult;\n\t\tu32\tshift;\n\t} clock;\n\n\tu64\t\tboot_ns;\n\tu64\t\tnsec_base;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr.base_mono, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr.mask;\n\tvdata->clock.mult\t\t= tk->tkr.mult;\n\tvdata->clock.shift\t\t= tk->tkr.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}\n#endif\n\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tuint32_t quotient, remainder;\n\n\t/* Don't try to replace with do_div(), this one calculates\n\t * \"(dividend << 32) / divisor\" */\n\t__asm__ ( \"divl %4\"\n\t\t  : \"=a\" (quotient), \"=d\" (remainder)\n\t\t  : \"0\" (0), \"1\" (dividend), \"r\" (divisor) );\n\treturn quotient;\n}\n\nstatic void kvm_get_time_scale(uint32_t scaled_khz, uint32_t base_khz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_khz * 1000LL;\n\tscaled64 = scaled_khz * 1000LL;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_khz %u => %u, shift %d, mul %u\\n\",\n\t\t __func__, base_khz, scaled_khz, shift, *pmultiplier);\n}\n\nstatic inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nunsigned long max_tsc_khz;\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 this_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (this_tsc_khz == 0)\n\t\treturn;\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(this_tsc_khz, NSEC_PER_SEC / 1000,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = this_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (this_tsc_khz < thresh_lo || this_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", this_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\tkvm_x86_ops->set_tsc_khz(vcpu, this_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\nvoid kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tbool do_request = false;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\tif (vcpus_matched && gtod->clock.vclock_mode == VCLOCK_TSC)\n\t\tif (!ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (!vcpus_matched && ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (do_request)\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\nstatic void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}\n\nvoid kvm_write_tsc(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\ts64 usdiff;\n\tbool matched;\n\tbool already_matched;\n\tu64 data = msr->data;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\tns = get_kernel_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tint faulted = 0;\n\n\t\t/* n.b - signed multiplication and division required */\n\t\tusdiff = data - kvm->arch.last_tsc_write;\n#ifdef CONFIG_X86_64\n\t\tusdiff = (usdiff * 1000) / vcpu->arch.virtual_tsc_khz;\n#else\n\t\t/* do_div() only does unsigned */\n\t\tasm(\"1: idivl %[divisor]\\n\"\n\t\t    \"2: xor %%edx, %%edx\\n\"\n\t\t    \"   movl $0, %[faulted]\\n\"\n\t\t    \"3:\\n\"\n\t\t    \".section .fixup,\\\"ax\\\"\\n\"\n\t\t    \"4: movl $1, %[faulted]\\n\"\n\t\t    \"   jmp  3b\\n\"\n\t\t    \".previous\\n\"\n\n\t\t_ASM_EXTABLE(1b, 4b)\n\n\t\t: \"=A\"(usdiff), [faulted] \"=r\" (faulted)\n\t\t: \"A\"(usdiff * 1000), [divisor] \"rm\"(vcpu->arch.virtual_tsc_khz));\n\n#endif\n\t\tdo_div(elapsed, 1000);\n\t\tusdiff -= elapsed;\n\t\tif (usdiff < 0)\n\t\t\tusdiff = -usdiff;\n\n\t\t/* idivl overflow => difference is larger than USEC_PER_SEC */\n\t\tif (faulted)\n\t\t\tusdiff = USEC_PER_SEC;\n\t} else\n\t\tusdiff = USEC_PER_SEC; /* disable TSC match window below */\n\n\t/*\n\t * Special case: TSC write with a small delta (1 second) of virtual\n\t * cycle time against real time is interpreted as an attempt to\n\t * synchronize the CPU.\n         *\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (usdiff < USEC_PER_SEC &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t\tpr_debug(\"kvm: matched tsc offset for %llu\\n\", data);\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\t\t\tpr_debug(\"kvm: adjusted tsc offset by %llu\\n\", delta);\n\t\t}\n\t\tmatched = true;\n\t\talready_matched = (vcpu->arch.this_tsc_generation == kvm->arch.cur_tsc_generation);\n\t} else {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = data;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tmatched = false;\n\t\tpr_debug(\"kvm: new tsc generation %llu, clock %llu\\n\",\n\t\t\t kvm->arch.cur_tsc_generation, data);\n\t}\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = data;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\n\tvcpu->arch.last_guest_tsc = data;\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tif (guest_cpuid_has_tsc_adjust(vcpu) && !msr->host_initiated)\n\t\tupdate_ia32_tsc_adjust_msr(vcpu, offset);\n\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tspin_lock(&kvm->arch.pvclock_gtod_sync_lock);\n\tif (!matched) {\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\t} else if (!already_matched) {\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\t}\n\n\tkvm_track_tsc_matching(vcpu);\n\tspin_unlock(&kvm->arch.pvclock_gtod_sync_lock);\n}\n\nEXPORT_SYMBOL_GPL(kvm_write_tsc);\n\n#ifdef CONFIG_X86_64\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret;\n\tu64 last;\n\n\t/*\n\t * Empirically, a fence (of type that depends on the CPU)\n\t * before rdtsc is enough to ensure that rdtsc is ordered\n\t * with respect to loads.  The various CPU manuals are unclear\n\t * as to whether rdtsc can be reordered with later loads,\n\t * but no one has ever seen it happen.\n\t */\n\trdtsc_barrier();\n\tret = (cycle_t)vget_cycles();\n\n\tlast = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a funciton of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}\n\nstatic int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}\n\n/* returns true if host is using tsc clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, this_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\tthis_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(this_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = native_read_tsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_x86_ops->read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (unlikely(vcpu->hw_tsc_khz != this_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC / 1000, this_tsc_khz,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = this_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/*\n\t * The interface expects us to write an even number signaling that the\n\t * update is finished. Since the guest won't see the intermediate\n\t * state, we just increase by 2 at the end.\n\t */\n\tvcpu->hv_clock.version += 2;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * We need to rate-limit these requests though, as they can\n * considerably slow guests that have a large number of vcpus.\n * The time for a remote vcpu to update its kvmclock is bound\n * by the delay we use to rate-limit the updates.\n */\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvmclock_update_fn(struct work_struct *work)\n{\n\tint i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}\n\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_mtrr_valid);\n\nstatic int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType) {\n\t\tvcpu->arch.mtrr_state.def_type = data;\n\t\tvcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;\n\t} else if (msr == MSR_MTRRfix64K_00000)\n\t\tp[0] = data;\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\tp[1 + msr - MSR_MTRRfix16K_80000] = data;\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\tp[3 + msr - MSR_MTRRfix4K_C0000] = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pt = data;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_write_guest(kvm, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}\n\nstatic bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int set_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tkvm->arch.hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tkvm->arch.hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\tkvm->arch.hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\tkvm->arch.hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\tkvm->arch.hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(kvm, gfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int set_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\tvcpu->arch.hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(vcpu->kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\tvcpu->arch.hv_vapic = data;\n\t\tmark_page_dirty(vcpu->kvm, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, gfn_to_gpa(gfn) | KVM_MSR_ENABLED))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}\n\nstatic void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tvcpu->arch.st.steal.steal += vcpu->arch.st.accum_steal;\n\tvcpu->arch.st.steal.version += 2;\n\tvcpu->arch.st.accum_steal = 0;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr_index, pdata);\n}\n\nstatic int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.def_type +\n\t\t\t (vcpu->arch.mtrr_state.enabled << 10);\n\telse if (msr == MSR_MTRRfix64K_00000)\n\t\t*pdata = p[0];\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\t*pdata = p[1 + msr - MSR_MTRRfix16K_80000];\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\t*pdata = p[3 + msr - MSR_MTRRfix4K_C0000];\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pdata = *pt;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = kvm->arch.hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = kvm->arch.hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT: {\n\t\tdata =\n\t\t     div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = kvm->arch.hv_tsc_page;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm) {\n\t\t\tif (v == vcpu) {\n\t\t\t\tdata = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = vcpu->arch.hv_vapic;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tdata = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\t\tdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn get_msr_mtrr(vcpu, msr, pdata);\n\tcase 0xcd: /* fsb frequency */\n\t\tdata = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tdata = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tdata = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tdata = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tdata = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tdata = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tdata = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tdata |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tdata = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tdata = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tdata = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tdata = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tdata = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tdata = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr, pdata);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tdata = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = get_msr_hyperv_pw(vcpu, msr, pdata);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn get_msr_hyperv(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tdata = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr);\n\t\t\tdata = 0;\n\t\t}\n\t\tbreak;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nint kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\t\tr = boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + ARRAY_SIZE(emulated_msrs);\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t ARRAY_SIZE(emulated_msrs) * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = native_read_tsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    kvm_vcpu_has_lapic(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\t_kvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tvcpu->arch.guest_xstate_size);\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] &=\n\t\t\tvcpu->arch.guest_supported_xcr0 | XSTATE_FPSSE;\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tsizeof(struct i387_fxsave_struct));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXSTATE_FPSSE;\n\t}\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tguest_xsave->region, vcpu->arch.guest_xstate_size);\n\t} else {\n\t\tif (xstate_bv & ~XSTATE_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tguest_xsave->region, sizeof(struct i387_fxsave_struct));\n\t}\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, kvm_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tkvm_set_tsc_khz(vcpu, user_tsc_khz);\n\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}\n\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps, &kvm->arch.vpit->pit_state, sizeof(struct kvm_pit_state));\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0, start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently.  So, to avoid losing data, we keep the following order for\n * each bit:\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Flush TLB's if needed.\n *   4. Copy the snapshot to the userspace.\n *\n * Between 2 and 3, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page will be reported dirty at\n * step 4 using the snapshot taken before and step 3 ensures that successive\n * writes will be logged for the next call.\n */\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tint r;\n\tstruct kvm_memory_slot *memslot;\n\tunsigned long n, i;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool is_dirty = false;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = -EINVAL;\n\tif (log->slot >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, log->slot);\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\n\t\tis_dirty = true;\n\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\toffset = i * BITS_PER_LONG;\n\t\tkvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/* See the comments in kvm_mmu_slot_remove_write_access(). */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * All the TLBs can be flushed out of mmu lock, see the comments in\n\t * kvm_mmu_slot_remove_write_access().\n\t */\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\n\tr = 0;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_master);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_slave);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_eclr);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.  We could work around this\n\t\t * in VMX with the generic MSR save/load machinery, but it\n\t\t * is not really worthwhile since it will really only\n\t\t * happen with nested virtualization.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_read_guest_page(vcpu->kvm, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t  offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_read_guest_page(vcpu->kvm, gpa >> PAGE_SHIFT, val,\n\t\t\t\t  offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}\n\nint kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nint emulator_read_write(struct x86_emulate_ctxt *ctxt, unsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nint emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define CMPXCHG_TYPE(t, ptr, old, new) \\\n\t(cmpxchg((t *)(ptr), *(t *)(old), *(t *)(new)) == *(t *)(old))\n\n#ifdef CONFIG_X86_64\n#  define CMPXCHG64(ptr, old, new) CMPXCHG_TYPE(u64, ptr, old, new)\n#else\n#  define CMPXCHG64(ptr, old, new) \\\n\t(cmpxchg64((u64 *)(ptr), *(u64 *)(old), *(u64 *)(new)) == *(u64 *)(old))\n#endif\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = gfn_to_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tmark_page_dirty(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tkvm_mmu_pte_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\ttrace_kvm_pio(KVM_PIO_IN, port, size, count, vcpu->arch.pio_data);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd(emul_to_vcpu(ctxt));\n}\n\nint emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long *dest)\n{\n\treturn _kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nint emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}\n\nstatic int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\treturn kvm_pmu_check_pmc(emul_to_vcpu(ctxt), pmc);\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_read_pmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}\n\nstatic void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}\n\nstatic void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tctxt->guest_mode = is_guest_mode(vcpu);\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nint kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tpfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_emulate_instruction);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio_out);\n\nstatic void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvmclock_cpu_notifier_block = {\n\t.notifier_call  = kvmclock_cpu_notifier,\n\t.priority = -INT_MAX\n};\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}\n\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, current_vcpu);\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}\n\nstatic int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}\n\nstatic unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.is_in_guest\t\t= kvm_is_in_guest,\n\t.is_user_mode\t\t= kvm_is_user_mode,\n\t.get_guest_ip\t\t= kvm_get_guest_ip,\n};\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_before_handle_nmi);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_after_handle_nmi);\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\n\tkvm_x86_ops = ops;\n\tkvm_init_msr_list();\n\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HV_X64_HV_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tif (longmode) {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t} else {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, ret >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret & 0xffffffff);\n\t}\n\n\treturn 1;\n}\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, 0, &lapic_irq, NULL);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}\n\n/*\n * Check if userspace requested an interrupt window, and that the\n * interrupt window is open.\n *\n * No need to exit to userspace if we already have an interrupt queued.\n */\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n\t\tvcpu->run->request_interrupt_window &&\n\t\tkvm_arch_interrupt_allowed(vcpu));\n}\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t\t!kvm_event_needs_reinjection(vcpu);\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending) {\n\t\tif (kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\t}\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\tu32 tmr[8];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tmemset(eoi_exit_bitmap, 0, 32);\n\tmemset(tmr, 0, 32);\n\n\tkvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n\tkvm_apic_update_tmr(vcpu, tmr);\n}\n\nstatic void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}\n\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_reload_apic_access_page);\n\nvoid kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}\n\n/*\n * Returns 1 to let __vcpu_run() continue the guest execution loop without\n * exiting to the userspace.  Otherwise, the value will be returned to the\n * userspace.\n */\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse if (vcpu->arch.nmi_pending)\n\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tint i;\n\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n\nstatic int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tcond_resched();\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (!tsk_used_math(current) && init_fpu(current))\n\t\treturn -ENOMEM;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = __vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cs_db_l_bits);\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!kvm_vcpu_has_lapic(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct msr_data apic_base_msr;\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_db_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint fx_init(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = fpu_alloc(&vcpu->arch.guest_fpu);\n\tif (err)\n\t\treturn err;\n\n\tfpu_finit(&vcpu->arch.guest_fpu);\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XSTATE_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fx_init);\n\nstatic void fx_free(struct kvm_vcpu *vcpu)\n{\n\tfpu_free(&vcpu->arch.guest_fpu);\n}\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tkvm_put_guest_xcr0(vcpu);\n\n\tif (!vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\tvcpu->guest_fpu_loaded = 0;\n\tfpu_save_init(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\ttrace_kvm_fpu(0);\n}\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\treturn kvm_x86_ops->vcpu_create(kvm, id);\n}\n\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct msr_data msr;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tkvm_pmu_reset(vcpu);\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\n\nint kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = native_read_tsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tbackwards_tsc_observed = true;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void)\n{\n\tkvm_x86_ops->hardware_disable();\n\tdrop_user_return_notifiers();\n}\n\nint kvm_arch_hardware_setup(void)\n{\n\treturn kvm_x86_ops->hardware_setup();\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}\n\nvoid kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}\n\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\n}\n\nstruct static_key kvm_no_apic_vcpu __read_mostly;\n\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tr = fx_init(vcpu);\n\tif (r)\n\t\tgoto fail_free_wbinvd_dirty_mask;\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}\n\nvoid kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tkvm_x86_ops->sched_in(vcpu, cpu);\n}\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\treturn 0;\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tstruct kvm_userspace_memory_region mem;\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = TSS_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\t}\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}\n\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\t/*\n\t * Only private memory slots need to be mapped here since\n\t * KVM_SET_MEMORY_REGION ioctl is no longer supported.\n\t */\n\tif ((memslot->id >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_CREATE)) {\n\t\tunsigned long userspace_addr;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\tuserspace_addr = vm_mmap(NULL, 0, memslot->npages * PAGE_SIZE,\n\t\t\t\t\t PROT_READ | PROT_WRITE,\n\t\t\t\t\t MAP_SHARED | MAP_ANONYMOUS, 0);\n\n\t\tif (IS_ERR((void *)userspace_addr))\n\t\t\treturn PTR_ERR((void *)userspace_addr);\n\n\t\tmemslot->userspace_addr = userspace_addr;\n\t}\n\n\treturn 0;\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tenum kvm_mr_change change)\n{\n\n\tint nr_mmu_pages = 0;\n\n\tif ((mem->slot >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_DELETE)) {\n\t\tint ret;\n\n\t\tret = vm_munmap(old->userspace_addr,\n\t\t\t\told->npages * PAGE_SIZE);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"kvm_vm_ioctl_set_memory_region: \"\n\t\t\t       \"failed to munmap memory\\n\");\n\t}\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t/*\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif ((change != KVM_MR_DELETE) && (mem->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_slot_remove_write_access(kvm, mem->slot);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted)\n\t\t|| !list_empty_careful(&vcpu->async_pf.done)\n\t\t|| kvm_apic_has_events(vcpu)\n\t\t|| vcpu->arch.pv.pv_unhalted\n\t\t|| atomic_read(&vcpu->arch.nmi_queued) ||\n\t\t(kvm_arch_interrupt_allowed(vcpu) &&\n\t\t kvm_cpu_has_interrupt(vcpu));\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\tunsigned long current_rip = kvm_rip_read(vcpu) +\n\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\treturn current_rip == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window);\n"], "fixing_code": ["/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This header defines architecture specific interfaces, x86 version\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#ifndef _ASM_X86_KVM_HOST_H\n#define _ASM_X86_KVM_HOST_H\n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/tracepoint.h>\n#include <linux/cpumask.h>\n#include <linux/irq_work.h>\n\n#include <linux/kvm.h>\n#include <linux/kvm_para.h>\n#include <linux/kvm_types.h>\n#include <linux/perf_event.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/clocksource.h>\n\n#include <asm/pvclock-abi.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/msr-index.h>\n#include <asm/asm.h>\n\n#define KVM_MAX_VCPUS 255\n#define KVM_SOFT_MAX_VCPUS 160\n#define KVM_USER_MEM_SLOTS 125\n/* memory slots that are not exposed to userspace */\n#define KVM_PRIVATE_MEM_SLOTS 3\n#define KVM_MEM_SLOTS_NUM (KVM_USER_MEM_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\n#define KVM_MMIO_SIZE 16\n\n#define KVM_PIO_PAGE_OFFSET 1\n#define KVM_COALESCED_MMIO_PAGE_OFFSET 2\n\n#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS\n\n#define CR0_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR0_PE | X86_CR0_MP | X86_CR0_EM | X86_CR0_TS \\\n\t\t\t  | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM \\\n\t\t\t  | X86_CR0_NW | X86_CR0_CD | X86_CR0_PG))\n\n#define CR3_L_MODE_RESERVED_BITS 0xFFFFFF0000000000ULL\n#define CR4_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\\\n\t\t\t  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \\\n\t\t\t  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \\\n\t\t\t  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \\\n\t\t\t  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE | X86_CR4_SMAP))\n\n#define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)\n\n\n\n#define INVALID_PAGE (~(hpa_t)0)\n#define VALID_PAGE(x) ((x) != INVALID_PAGE)\n\n#define UNMAPPED_GVA (~(gpa_t)0)\n\n/* KVM Hugepage definitions for x86 */\n#define KVM_NR_PAGE_SIZES\t3\n#define KVM_HPAGE_GFN_SHIFT(x)\t(((x) - 1) * 9)\n#define KVM_HPAGE_SHIFT(x)\t(PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))\n#define KVM_HPAGE_SIZE(x)\t(1UL << KVM_HPAGE_SHIFT(x))\n#define KVM_HPAGE_MASK(x)\t(~(KVM_HPAGE_SIZE(x) - 1))\n#define KVM_PAGES_PER_HPAGE(x)\t(KVM_HPAGE_SIZE(x) / PAGE_SIZE)\n\nstatic inline gfn_t gfn_to_index(gfn_t gfn, gfn_t base_gfn, int level)\n{\n\t/* KVM_HPAGE_GFN_SHIFT(PT_PAGE_TABLE_LEVEL) must be 0. */\n\treturn (gfn >> KVM_HPAGE_GFN_SHIFT(level)) -\n\t\t(base_gfn >> KVM_HPAGE_GFN_SHIFT(level));\n}\n\n#define SELECTOR_TI_MASK (1 << 2)\n#define SELECTOR_RPL_MASK 0x03\n\n#define IOPL_SHIFT 12\n\n#define KVM_PERMILLE_MMU_PAGES 20\n#define KVM_MIN_ALLOC_MMU_PAGES 64\n#define KVM_MMU_HASH_SHIFT 10\n#define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)\n#define KVM_MIN_FREE_MMU_PAGES 5\n#define KVM_REFILL_PAGES 25\n#define KVM_MAX_CPUID_ENTRIES 80\n#define KVM_NR_FIXED_MTRR_REGION 88\n#define KVM_NR_VAR_MTRR 8\n\n#define ASYNC_PF_PER_VCPU 64\n\nenum kvm_reg {\n\tVCPU_REGS_RAX = 0,\n\tVCPU_REGS_RCX = 1,\n\tVCPU_REGS_RDX = 2,\n\tVCPU_REGS_RBX = 3,\n\tVCPU_REGS_RSP = 4,\n\tVCPU_REGS_RBP = 5,\n\tVCPU_REGS_RSI = 6,\n\tVCPU_REGS_RDI = 7,\n#ifdef CONFIG_X86_64\n\tVCPU_REGS_R8 = 8,\n\tVCPU_REGS_R9 = 9,\n\tVCPU_REGS_R10 = 10,\n\tVCPU_REGS_R11 = 11,\n\tVCPU_REGS_R12 = 12,\n\tVCPU_REGS_R13 = 13,\n\tVCPU_REGS_R14 = 14,\n\tVCPU_REGS_R15 = 15,\n#endif\n\tVCPU_REGS_RIP,\n\tNR_VCPU_REGS\n};\n\nenum kvm_reg_ex {\n\tVCPU_EXREG_PDPTR = NR_VCPU_REGS,\n\tVCPU_EXREG_CR3,\n\tVCPU_EXREG_RFLAGS,\n\tVCPU_EXREG_SEGMENTS,\n};\n\nenum {\n\tVCPU_SREG_ES,\n\tVCPU_SREG_CS,\n\tVCPU_SREG_SS,\n\tVCPU_SREG_DS,\n\tVCPU_SREG_FS,\n\tVCPU_SREG_GS,\n\tVCPU_SREG_TR,\n\tVCPU_SREG_LDTR,\n};\n\n#include <asm/kvm_emulate.h>\n\n#define KVM_NR_MEM_OBJS 40\n\n#define KVM_NR_DB_REGS\t4\n\n#define DR6_BD\t\t(1 << 13)\n#define DR6_BS\t\t(1 << 14)\n#define DR6_RTM\t\t(1 << 16)\n#define DR6_FIXED_1\t0xfffe0ff0\n#define DR6_INIT\t0xffff0ff0\n#define DR6_VOLATILE\t0x0001e00f\n\n#define DR7_BP_EN_MASK\t0x000000ff\n#define DR7_GE\t\t(1 << 9)\n#define DR7_GD\t\t(1 << 13)\n#define DR7_FIXED_1\t0x00000400\n#define DR7_VOLATILE\t0xffff2bff\n\n/* apic attention bits */\n#define KVM_APIC_CHECK_VAPIC\t0\n/*\n * The following bit is set with PV-EOI, unset on EOI.\n * We detect PV-EOI changes by guest by comparing\n * this bit with PV-EOI in guest memory.\n * See the implementation in apic_update_pv_eoi.\n */\n#define KVM_APIC_PV_EOI_PENDING\t1\n\n/*\n * We don't want allocation failures within the mmu code, so we preallocate\n * enough memory for a single page fault in a cache.\n */\nstruct kvm_mmu_memory_cache {\n\tint nobjs;\n\tvoid *objects[KVM_NR_MEM_OBJS];\n};\n\n/*\n * kvm_mmu_page_role, below, is defined as:\n *\n *   bits 0:3 - total guest paging levels (2-4, or zero for real mode)\n *   bits 4:7 - page table level for this shadow (1-4)\n *   bits 8:9 - page table quadrant for 2-level guests\n *   bit   16 - direct mapping of virtual to physical mapping at gfn\n *              used for real mode and two-dimensional paging\n *   bits 17:19 - common access permissions for all ptes in this shadow page\n */\nunion kvm_mmu_page_role {\n\tunsigned word;\n\tstruct {\n\t\tunsigned level:4;\n\t\tunsigned cr4_pae:1;\n\t\tunsigned quadrant:2;\n\t\tunsigned pad_for_nice_hex_output:6;\n\t\tunsigned direct:1;\n\t\tunsigned access:3;\n\t\tunsigned invalid:1;\n\t\tunsigned nxe:1;\n\t\tunsigned cr0_wp:1;\n\t\tunsigned smep_andnot_wp:1;\n\t};\n};\n\nstruct kvm_mmu_page {\n\tstruct list_head link;\n\tstruct hlist_node hash_link;\n\n\t/*\n\t * The following two entries are used to key the shadow page in the\n\t * hash table.\n\t */\n\tgfn_t gfn;\n\tunion kvm_mmu_page_role role;\n\n\tu64 *spt;\n\t/* hold the gfn of each spte inside spt */\n\tgfn_t *gfns;\n\tbool unsync;\n\tint root_count;          /* Currently serving as active root */\n\tunsigned int unsync_children;\n\tunsigned long parent_ptes;\t/* Reverse mapping for parent_pte */\n\n\t/* The page is obsolete if mmu_valid_gen != kvm->arch.mmu_valid_gen.  */\n\tunsigned long mmu_valid_gen;\n\n\tDECLARE_BITMAP(unsync_child_bitmap, 512);\n\n#ifdef CONFIG_X86_32\n\t/*\n\t * Used out of the mmu-lock to avoid reading spte values while an\n\t * update is in progress; see the comments in __get_spte_lockless().\n\t */\n\tint clear_spte_count;\n#endif\n\n\t/* Number of writes since the last time traversal visited this page.  */\n\tint write_flooding_count;\n};\n\nstruct kvm_pio_request {\n\tunsigned long count;\n\tint in;\n\tint port;\n\tint size;\n};\n\n/*\n * x86 supports 3 paging modes (4-level 64-bit, 3-level 64-bit, and 2-level\n * 32-bit).  The kvm_mmu structure abstracts the details of the current mmu\n * mode.\n */\nstruct kvm_mmu {\n\tvoid (*set_cr3)(struct kvm_vcpu *vcpu, unsigned long root);\n\tunsigned long (*get_cr3)(struct kvm_vcpu *vcpu);\n\tu64 (*get_pdptr)(struct kvm_vcpu *vcpu, int index);\n\tint (*page_fault)(struct kvm_vcpu *vcpu, gva_t gva, u32 err,\n\t\t\t  bool prefault);\n\tvoid (*inject_page_fault)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_exception *fault);\n\tgpa_t (*gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t gva, u32 access,\n\t\t\t    struct x86_exception *exception);\n\tgpa_t (*translate_gpa)(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t       struct x86_exception *exception);\n\tint (*sync_page)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_mmu_page *sp);\n\tvoid (*invlpg)(struct kvm_vcpu *vcpu, gva_t gva);\n\tvoid (*update_pte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t   u64 *spte, const void *pte);\n\thpa_t root_hpa;\n\tint root_level;\n\tint shadow_root_level;\n\tunion kvm_mmu_page_role base_role;\n\tbool direct_map;\n\n\t/*\n\t * Bitmap; bit set = permission fault\n\t * Byte index: page fault error code [4:1]\n\t * Bit index: pte permissions in ACC_* format\n\t */\n\tu8 permissions[16];\n\n\tu64 *pae_root;\n\tu64 *lm_root;\n\tu64 rsvd_bits_mask[2][4];\n\tu64 bad_mt_xwr;\n\n\t/*\n\t * Bitmap: bit set = last pte in walk\n\t * index[0:1]: level (zero-based)\n\t * index[2]: pte.ps\n\t */\n\tu8 last_pte_bitmap;\n\n\tbool nx;\n\n\tu64 pdptrs[4]; /* pae */\n};\n\nenum pmc_type {\n\tKVM_PMC_GP = 0,\n\tKVM_PMC_FIXED,\n};\n\nstruct kvm_pmc {\n\tenum pmc_type type;\n\tu8 idx;\n\tu64 counter;\n\tu64 eventsel;\n\tstruct perf_event *perf_event;\n\tstruct kvm_vcpu *vcpu;\n};\n\nstruct kvm_pmu {\n\tunsigned nr_arch_gp_counters;\n\tunsigned nr_arch_fixed_counters;\n\tunsigned available_event_types;\n\tu64 fixed_ctr_ctrl;\n\tu64 global_ctrl;\n\tu64 global_status;\n\tu64 global_ovf_ctrl;\n\tu64 counter_bitmask[2];\n\tu64 global_ctrl_mask;\n\tu64 reserved_bits;\n\tu8 version;\n\tstruct kvm_pmc gp_counters[INTEL_PMC_MAX_GENERIC];\n\tstruct kvm_pmc fixed_counters[INTEL_PMC_MAX_FIXED];\n\tstruct irq_work irq_work;\n\tu64 reprogram_pmi;\n};\n\nenum {\n\tKVM_DEBUGREG_BP_ENABLED = 1,\n\tKVM_DEBUGREG_WONT_EXIT = 2,\n};\n\nstruct kvm_vcpu_arch {\n\t/*\n\t * rip and regs accesses must go through\n\t * kvm_{register,rip}_{read,write} functions.\n\t */\n\tunsigned long regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n\n\tunsigned long cr0;\n\tunsigned long cr0_guest_owned_bits;\n\tunsigned long cr2;\n\tunsigned long cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr8;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tbool tpr_access_reporting;\n\n\t/*\n\t * Paging state of the vcpu\n\t *\n\t * If the vcpu runs in guest mode with two level paging this still saves\n\t * the paging mode of the l1 guest. This context is always used to\n\t * handle faults.\n\t */\n\tstruct kvm_mmu mmu;\n\n\t/*\n\t * Paging state of an L2 guest (used for nested npt)\n\t *\n\t * This context will save all necessary information to walk page tables\n\t * of the an L2 guest. This context is only initialized for page table\n\t * walking and not for faulting since we never handle l2 page faults on\n\t * the host.\n\t */\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t * Pointer to the mmu context currently used for\n\t * gva_to_gpa translations.\n\t */\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\tstruct fpu guest_fpu;\n\tu64 xcr0;\n\tu64 guest_supported_xcr0;\n\tu32 guest_xstate_size;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool has_error_code;\n\t\tbool reinject;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool pending;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\t/* emulate context */\n\n\tstruct x86_emulate_ctxt emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_hva_cache pv_time;\n\tbool pv_time_enabled;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tu64 accum_steal;\n\t\tstruct gfn_to_hva_cache stime;\n\t\tstruct kvm_steal_time steal;\n\t} st;\n\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\n\tstruct mtrr_state_type mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_vapic;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_val;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\t/*\n\t * Indicate whether the access faults on its page table in guest\n\t * which is set when fix page fault and used to detect unhandeable\n\t * instruction.\n\t */\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n};\n\nstruct kvm_lpage_info {\n\tint write_count;\n};\n\nstruct kvm_arch_memory_slot {\n\tunsigned long *rmap[KVM_NR_PAGE_SIZES];\n\tstruct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];\n};\n\nstruct kvm_apic_map {\n\tstruct rcu_head rcu;\n\tu8 ldr_bits;\n\t/* fields bellow are used to decode ldr values in different modes */\n\tu32 cid_shift, cid_mask, lid_mask;\n\tstruct kvm_lapic *phys_map[256];\n\t/* first index is cluster id second is cpu id in a cluster */\n\tstruct kvm_lapic *logical_map[16][16];\n};\n\nstruct kvm_arch {\n\tunsigned int n_used_mmu_pages;\n\tunsigned int n_requested_mmu_pages;\n\tunsigned int n_max_mmu_pages;\n\tunsigned int indirect_shadow_pages;\n\tunsigned long mmu_valid_gen;\n\tstruct hlist_head mmu_page_hash[KVM_NUM_MMU_PAGES];\n\t/*\n\t * Hash table of struct kvm_mmu_page.\n\t */\n\tstruct list_head active_mmu_pages;\n\tstruct list_head zapped_obsolete_pages;\n\n\tstruct list_head assigned_dev_head;\n\tstruct iommu_domain *iommu_domain;\n\tbool iommu_noncoherent;\n#define __KVM_HAVE_ARCH_NONCOHERENT_DMA\n\tatomic_t noncoherent_dma_count;\n\tstruct kvm_pic *vpic;\n\tstruct kvm_ioapic *vioapic;\n\tstruct kvm_pit *vpit;\n\tint vapics_in_nmi_mode;\n\tstruct mutex apic_map_lock;\n\tstruct kvm_apic_map *apic_map;\n\n\tunsigned int tss_addr;\n\tbool apic_access_page_done;\n\n\tgpa_t wall_clock;\n\n\tbool ept_identity_pagetable_done;\n\tgpa_t ept_identity_map_addr;\n\n\tunsigned long irq_sources_bitmap;\n\ts64 kvmclock_offset;\n\traw_spinlock_t tsc_write_lock;\n\tu64 last_tsc_nsec;\n\tu64 last_tsc_write;\n\tu32 last_tsc_khz;\n\tu64 cur_tsc_nsec;\n\tu64 cur_tsc_write;\n\tu64 cur_tsc_offset;\n\tu64 cur_tsc_generation;\n\tint nr_vcpus_matched_tsc;\n\n\tspinlock_t pvclock_gtod_sync_lock;\n\tbool use_master_clock;\n\tu64 master_kernel_ns;\n\tcycle_t master_cycle_now;\n\tstruct delayed_work kvmclock_update_work;\n\tstruct delayed_work kvmclock_sync_work;\n\n\tstruct kvm_xen_hvm_config xen_hvm_config;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_guest_os_id;\n\tu64 hv_hypercall;\n\tu64 hv_tsc_page;\n\n\t#ifdef CONFIG_KVM_MMU_AUDIT\n\tint audit_point;\n\t#endif\n};\n\nstruct kvm_vm_stat {\n\tu32 mmu_shadow_zapped;\n\tu32 mmu_pte_write;\n\tu32 mmu_pte_updated;\n\tu32 mmu_pde_zapped;\n\tu32 mmu_flooded;\n\tu32 mmu_recycled;\n\tu32 mmu_cache_miss;\n\tu32 mmu_unsync;\n\tu32 remote_tlb_flush;\n\tu32 lpages;\n};\n\nstruct kvm_vcpu_stat {\n\tu32 pf_fixed;\n\tu32 pf_guest;\n\tu32 tlb_flush;\n\tu32 invlpg;\n\n\tu32 exits;\n\tu32 io_exits;\n\tu32 mmio_exits;\n\tu32 signal_exits;\n\tu32 irq_window_exits;\n\tu32 nmi_window_exits;\n\tu32 halt_exits;\n\tu32 halt_wakeup;\n\tu32 request_irq_exits;\n\tu32 irq_exits;\n\tu32 host_state_reload;\n\tu32 efer_reload;\n\tu32 fpu_reload;\n\tu32 insn_emulation;\n\tu32 insn_emulation_fail;\n\tu32 hypercalls;\n\tu32 irq_injections;\n\tu32 nmi_injections;\n};\n\nstruct x86_instruction_info;\n\nstruct msr_data {\n\tbool host_initiated;\n\tu32 index;\n\tu64 data;\n};\n\nstruct kvm_x86_ops {\n\tint (*cpu_has_kvm_support)(void);          /* __init */\n\tint (*disabled_by_bios)(void);             /* __init */\n\tint (*hardware_enable)(void);\n\tvoid (*hardware_disable)(void);\n\tvoid (*check_processor_compatibility)(void *rtn);\n\tint (*hardware_setup)(void);               /* __init */\n\tvoid (*hardware_unsetup)(void);            /* __exit */\n\tbool (*cpu_has_accelerated_tpr)(void);\n\tvoid (*cpuid_update)(struct kvm_vcpu *vcpu);\n\n\t/* Create, but do not attach this VCPU */\n\tstruct kvm_vcpu *(*vcpu_create)(struct kvm *kvm, unsigned id);\n\tvoid (*vcpu_free)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_reset)(struct kvm_vcpu *vcpu);\n\n\tvoid (*prepare_guest_switch)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_load)(struct kvm_vcpu *vcpu, int cpu);\n\tvoid (*vcpu_put)(struct kvm_vcpu *vcpu);\n\n\tvoid (*update_db_bp_intercept)(struct kvm_vcpu *vcpu);\n\tint (*get_msr)(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata);\n\tint (*set_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tu64 (*get_segment_base)(struct kvm_vcpu *vcpu, int seg);\n\tvoid (*get_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tint (*get_cpl)(struct kvm_vcpu *vcpu);\n\tvoid (*set_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tvoid (*get_cs_db_l_bits)(struct kvm_vcpu *vcpu, int *db, int *l);\n\tvoid (*decache_cr0_guest_bits)(struct kvm_vcpu *vcpu);\n\tvoid (*decache_cr3)(struct kvm_vcpu *vcpu);\n\tvoid (*decache_cr4_guest_bits)(struct kvm_vcpu *vcpu);\n\tvoid (*set_cr0)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*set_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\tint (*set_cr4)(struct kvm_vcpu *vcpu, unsigned long cr4);\n\tvoid (*set_efer)(struct kvm_vcpu *vcpu, u64 efer);\n\tvoid (*get_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*get_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tu64 (*get_dr6)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr6)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*sync_dirty_debug_regs)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr7)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);\n\tunsigned long (*get_rflags)(struct kvm_vcpu *vcpu);\n\tvoid (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);\n\tvoid (*fpu_deactivate)(struct kvm_vcpu *vcpu);\n\n\tvoid (*tlb_flush)(struct kvm_vcpu *vcpu);\n\n\tvoid (*run)(struct kvm_vcpu *vcpu);\n\tint (*handle_exit)(struct kvm_vcpu *vcpu);\n\tvoid (*skip_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*set_interrupt_shadow)(struct kvm_vcpu *vcpu, int mask);\n\tu32 (*get_interrupt_shadow)(struct kvm_vcpu *vcpu);\n\tvoid (*patch_hypercall)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned char *hypercall_addr);\n\tvoid (*set_irq)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi)(struct kvm_vcpu *vcpu);\n\tvoid (*queue_exception)(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject);\n\tvoid (*cancel_injection)(struct kvm_vcpu *vcpu);\n\tint (*interrupt_allowed)(struct kvm_vcpu *vcpu);\n\tint (*nmi_allowed)(struct kvm_vcpu *vcpu);\n\tbool (*get_nmi_mask)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi_mask)(struct kvm_vcpu *vcpu, bool masked);\n\tvoid (*enable_nmi_window)(struct kvm_vcpu *vcpu);\n\tvoid (*enable_irq_window)(struct kvm_vcpu *vcpu);\n\tvoid (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);\n\tint (*vm_has_apicv)(struct kvm *kvm);\n\tvoid (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);\n\tvoid (*hwapic_isr_update)(struct kvm *kvm, int isr);\n\tvoid (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);\n\tvoid (*set_virtual_x2apic_mode)(struct kvm_vcpu *vcpu, bool set);\n\tvoid (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu, hpa_t hpa);\n\tvoid (*deliver_posted_interrupt)(struct kvm_vcpu *vcpu, int vector);\n\tvoid (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);\n\tint (*set_tss_addr)(struct kvm *kvm, unsigned int addr);\n\tint (*get_tdp_level)(void);\n\tu64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);\n\tint (*get_lpage_level)(void);\n\tbool (*rdtscp_supported)(void);\n\tbool (*invpcid_supported)(void);\n\tvoid (*adjust_tsc_offset)(struct kvm_vcpu *vcpu, s64 adjustment, bool host);\n\n\tvoid (*set_tdp_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\n\tvoid (*set_supported_cpuid)(u32 func, struct kvm_cpuid_entry2 *entry);\n\n\tbool (*has_wbinvd_exit)(void);\n\n\tvoid (*set_tsc_khz)(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale);\n\tu64 (*read_tsc_offset)(struct kvm_vcpu *vcpu);\n\tvoid (*write_tsc_offset)(struct kvm_vcpu *vcpu, u64 offset);\n\n\tu64 (*compute_tsc_offset)(struct kvm_vcpu *vcpu, u64 target_tsc);\n\tu64 (*read_l1_tsc)(struct kvm_vcpu *vcpu, u64 host_tsc);\n\n\tvoid (*get_exit_info)(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2);\n\n\tint (*check_intercept)(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage);\n\tvoid (*handle_external_intr)(struct kvm_vcpu *vcpu);\n\tbool (*mpx_supported)(void);\n\n\tint (*check_nested_events)(struct kvm_vcpu *vcpu, bool external_intr);\n\n\tvoid (*sched_in)(struct kvm_vcpu *kvm, int cpu);\n};\n\nstruct kvm_arch_async_pf {\n\tu32 token;\n\tgfn_t gfn;\n\tunsigned long cr3;\n\tbool direct_map;\n};\n\nextern struct kvm_x86_ops *kvm_x86_ops;\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset(vcpu, adjustment, false);\n}\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tkvm_x86_ops->adjust_tsc_offset(vcpu, adjustment, true);\n}\n\nint kvm_mmu_module_init(void);\nvoid kvm_mmu_module_exit(void);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu);\nint kvm_mmu_create(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_setup(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm, int slot);\nvoid kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask);\nvoid kvm_mmu_zap_all(struct kvm *kvm);\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm);\nunsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm);\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int kvm_nr_mmu_pages);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes);\nu8 kvm_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nextern bool tdp_enabled;\n\nu64 vcpu_tsc_khz(struct kvm_vcpu *vcpu);\n\n/* control of guest tsc rate supported? */\nextern bool kvm_has_tsc_control;\n/* minimum supported tsc_khz for guests */\nextern u32  kvm_min_guest_tsc_khz;\n/* maximum supported tsc_khz for guests */\nextern u32  kvm_max_guest_tsc_khz;\n\nenum emulation_result {\n\tEMULATE_DONE,         /* no further processing */\n\tEMULATE_USER_EXIT,    /* kvm_run ready for userspace exit */\n\tEMULATE_FAIL,         /* can't emulate this instruction */\n};\n\n#define EMULTYPE_NO_DECODE\t    (1 << 0)\n#define EMULTYPE_TRAP_UD\t    (1 << 1)\n#define EMULTYPE_SKIP\t\t    (1 << 2)\n#define EMULTYPE_RETRY\t\t    (1 << 3)\n#define EMULTYPE_NO_REEXECUTE\t    (1 << 4)\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, unsigned long cr2,\n\t\t\t    int emulation_type, void *insn, int insn_len);\n\nstatic inline int emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\tint emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}\n\nvoid kvm_enable_efer_bits(u64);\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer);\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *data);\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nstruct x86_emulate_ctxt;\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port);\nvoid kvm_emulate_cpuid(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt(struct kvm_vcpu *vcpu);\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu);\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nint kvm_load_segment_descriptor(struct kvm_vcpu *vcpu, u16 selector, int seg);\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3);\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val);\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val);\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l);\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata);\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu);\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nbool kvm_rdpmc(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault);\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t gfn, void *data, int offset, int len,\n\t\t\t    u32 access);\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl);\n\nstatic inline int __kvm_irq_line_state(unsigned long *irq_state,\n\t\t\t\t       int irq_source_id, int level)\n{\n\t/* Logical OR for level trig interrupt */\n\tif (level)\n\t\t__set_bit(irq_source_id, irq_state);\n\telse\n\t\t__clear_bit(irq_source_id, irq_state);\n\n\treturn !!(*irq_state);\n}\n\nint kvm_pic_set_irq(struct kvm_pic *pic, int irq, int irq_source_id, int level);\nvoid kvm_pic_clear_all(struct kvm_pic *pic, int irq_source_id);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu);\n\nint fx_init(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t       const u8 *new, int bytes);\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva);\nvoid __kvm_mmu_free_some_pages(struct kvm_vcpu *vcpu);\nint kvm_mmu_load(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu);\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception);\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t gva, u32 error_code,\n\t\t       void *insn, int insn_len);\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);\nvoid kvm_mmu_new_cr3(struct kvm_vcpu *vcpu);\n\nvoid kvm_enable_tdp(void);\nvoid kvm_disable_tdp(void);\n\nstatic inline gpa_t translate_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn gpa;\n}\n\nstatic inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n{\n\tstruct page *page = pfn_to_page(shadow_page >> PAGE_SHIFT);\n\n\treturn (struct kvm_mmu_page *)page_private(page);\n}\n\nstatic inline u16 kvm_read_ldt(void)\n{\n\tu16 ldt;\n\tasm(\"sldt %0\" : \"=g\"(ldt));\n\treturn ldt;\n}\n\nstatic inline void kvm_load_ldt(u16 sel)\n{\n\tasm(\"lldt %0\" : : \"rm\"(sel));\n}\n\n#ifdef CONFIG_X86_64\nstatic inline unsigned long read_msr(unsigned long msr)\n{\n\tu64 value;\n\n\trdmsrl(msr, value);\n\treturn value;\n}\n#endif\n\nstatic inline u32 get_rdx_init_val(void)\n{\n\treturn 0x600; /* P6 family */\n}\n\nstatic inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n{\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n}\n\nstatic inline u64 get_canonical(u64 la)\n{\n\treturn ((int64_t)la << 16) >> 16;\n}\n\nstatic inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}\n\n#define TSS_IOPB_BASE_OFFSET 0x66\n#define TSS_BASE_SIZE 0x68\n#define TSS_IOPB_SIZE (65536 / 8)\n#define TSS_REDIRECTION_SIZE (256 / 8)\n#define RMODE_TSS_SIZE\t\t\t\t\t\t\t\\\n\t(TSS_BASE_SIZE + TSS_REDIRECTION_SIZE + TSS_IOPB_SIZE + 1)\n\nenum {\n\tTASK_SWITCH_CALL = 0,\n\tTASK_SWITCH_IRET = 1,\n\tTASK_SWITCH_JMP = 2,\n\tTASK_SWITCH_GATE = 3,\n};\n\n#define HF_GIF_MASK\t\t(1 << 0)\n#define HF_HIF_MASK\t\t(1 << 1)\n#define HF_VINTR_MASK\t\t(1 << 2)\n#define HF_NMI_MASK\t\t(1 << 3)\n#define HF_IRET_MASK\t\t(1 << 4)\n#define HF_GUEST_MASK\t\t(1 << 5) /* VCPU is in guest-mode */\n\n/*\n * Hardware virtualization extension instructions may fault if a\n * reboot turns off virtualization while processes are running.\n * Trap the fault and ignore the instruction if that happens.\n */\nasmlinkage void kvm_spurious_fault(void);\n\n#define ____kvm_handle_fault_on_reboot(insn, cleanup_insn)\t\\\n\t\"666: \" insn \"\\n\\t\" \\\n\t\"668: \\n\\t\"                           \\\n\t\".pushsection .fixup, \\\"ax\\\" \\n\" \\\n\t\"667: \\n\\t\" \\\n\tcleanup_insn \"\\n\\t\"\t\t      \\\n\t\"cmpb $0, kvm_rebooting \\n\\t\"\t      \\\n\t\"jne 668b \\n\\t\"      \t\t      \\\n\t__ASM_SIZE(push) \" $666b \\n\\t\"\t      \\\n\t\"call kvm_spurious_fault \\n\\t\"\t      \\\n\t\".popsection \\n\\t\" \\\n\t_ASM_EXTABLE(666b, 667b)\n\n#define __kvm_handle_fault_on_reboot(insn)\t\t\\\n\t____kvm_handle_fault_on_reboot(insn, \"\")\n\n#define KVM_ARCH_WANT_MMU_NOTIFIER\nint kvm_unmap_hva(struct kvm *kvm, unsigned long hva);\nint kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end);\nint kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end);\nint kvm_test_age_hva(struct kvm *kvm, unsigned long hva);\nvoid kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte);\nint cpuid_maxphyaddr(struct kvm_vcpu *vcpu);\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v);\nint kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v);\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu);\nvoid kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address);\n\nvoid kvm_define_shared_msr(unsigned index, u32 msr);\nvoid kvm_set_shared_msr(unsigned index, u64 val, u64 mask);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip);\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work);\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_async_pf *work);\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu);\nextern bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err);\n\nint kvm_is_in_guest(void);\n\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_cpuid_update(struct kvm_vcpu *vcpu);\nbool kvm_pmu_msr(struct kvm_vcpu *vcpu, u32 msr);\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\nint kvm_pmu_check_pmc(struct kvm_vcpu *vcpu, unsigned pmc);\nint kvm_pmu_read_pmc(struct kvm_vcpu *vcpu, unsigned pmc, u64 *data);\nvoid kvm_handle_pmu_event(struct kvm_vcpu *vcpu);\nvoid kvm_deliver_pmi(struct kvm_vcpu *vcpu);\n\n#endif /* _ASM_X86_KVM_HOST_H */\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * AMD SVM support\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Avi Kivity   <avi@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/ftrace_event.h>\n#include <linux/slab.h>\n\n#include <asm/perf_event.h>\n#include <asm/tlbflush.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/kvm_para.h>\n\n#include <asm/virtext.h>\n#include \"trace.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id svm_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_SVM),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, svm_cpu_id);\n\n#define IOPM_ALLOC_ORDER 2\n#define MSRPM_ALLOC_ORDER 1\n\n#define SEG_TYPE_LDT 2\n#define SEG_TYPE_BUSY_TSS16 3\n\n#define SVM_FEATURE_NPT            (1 <<  0)\n#define SVM_FEATURE_LBRV           (1 <<  1)\n#define SVM_FEATURE_SVML           (1 <<  2)\n#define SVM_FEATURE_NRIP           (1 <<  3)\n#define SVM_FEATURE_TSC_RATE       (1 <<  4)\n#define SVM_FEATURE_VMCB_CLEAN     (1 <<  5)\n#define SVM_FEATURE_FLUSH_ASID     (1 <<  6)\n#define SVM_FEATURE_DECODE_ASSIST  (1 <<  7)\n#define SVM_FEATURE_PAUSE_FILTER   (1 << 10)\n\n#define NESTED_EXIT_HOST\t0\t/* Exit handled on host level */\n#define NESTED_EXIT_DONE\t1\t/* Exit caused nested vmexit  */\n#define NESTED_EXIT_CONTINUE\t2\t/* Further checks needed      */\n\n#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))\n\n#define TSC_RATIO_RSVD          0xffffff0000000000ULL\n#define TSC_RATIO_MIN\t\t0x0000000000000001ULL\n#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL\n\nstatic bool erratum_383_found __read_mostly;\n\nstatic const u32 host_save_user_msrs[] = {\n#ifdef CONFIG_X86_64\n\tMSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,\n\tMSR_FS_BASE,\n#endif\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n};\n\n#define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)\n\nstruct kvm_vcpu;\n\nstruct nested_state {\n\tstruct vmcb *hsave;\n\tu64 hsave_msr;\n\tu64 vm_cr_msr;\n\tu64 vmcb;\n\n\t/* These are the merged vectors */\n\tu32 *msrpm;\n\n\t/* gpa pointers to the real vectors */\n\tu64 vmcb_msrpm;\n\tu64 vmcb_iopm;\n\n\t/* A VMEXIT is required but not yet emulated */\n\tbool exit_required;\n\n\t/* cache for intercepts of the guest */\n\tu32 intercept_cr;\n\tu32 intercept_dr;\n\tu32 intercept_exceptions;\n\tu64 intercept;\n\n\t/* Nested Paging related state */\n\tu64 nested_cr3;\n};\n\n#define MSRPM_OFFSETS\t16\nstatic u32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;\n\n/*\n * Set osvw_len to higher value when updated Revision Guides\n * are published and we know what the new status bits are\n */\nstatic uint64_t osvw_len = 4, osvw_status;\n\nstruct vcpu_svm {\n\tstruct kvm_vcpu vcpu;\n\tstruct vmcb *vmcb;\n\tunsigned long vmcb_pa;\n\tstruct svm_cpu_data *svm_data;\n\tuint64_t asid_generation;\n\tuint64_t sysenter_esp;\n\tuint64_t sysenter_eip;\n\n\tu64 next_rip;\n\n\tu64 host_user_msrs[NR_HOST_SAVE_USER_MSRS];\n\tstruct {\n\t\tu16 fs;\n\t\tu16 gs;\n\t\tu16 ldt;\n\t\tu64 gs_base;\n\t} host;\n\n\tu32 *msrpm;\n\n\tulong nmi_iret_rip;\n\n\tstruct nested_state nested;\n\n\tbool nmi_singlestep;\n\n\tunsigned int3_injected;\n\tunsigned long int3_rip;\n\tu32 apf_reason;\n\n\tu64  tsc_ratio;\n};\n\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\n#define MSR_INVALID\t\t\t0xffffffffU\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\n/* enable NPT for AMD64 and X86 with PAE */\n#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)\nstatic bool npt_enabled = true;\n#else\nstatic bool npt_enabled;\n#endif\n\n/* allow nested paging (virtualized MMU) for all guests */\nstatic int npt = true;\nmodule_param(npt, int, S_IRUGO);\n\n/* allow nested virtualization in KVM/SVM */\nstatic int nested = true;\nmodule_param(nested, int, S_IRUGO);\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm);\nstatic int nested_svm_intercept(struct vcpu_svm *svm);\nstatic int nested_svm_vmexit(struct vcpu_svm *svm);\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code);\nstatic u64 __scale_tsc(u64 ratio, u64 tsc);\n\nenum {\n\tVMCB_INTERCEPTS, /* Intercept vectors, TSC offset,\n\t\t\t    pause filter count */\n\tVMCB_PERM_MAP,   /* IOPM Base and MSRPM Base */\n\tVMCB_ASID,\t /* ASID */\n\tVMCB_INTR,\t /* int_ctl, int_vector */\n\tVMCB_NPT,        /* npt_en, nCR3, gPAT */\n\tVMCB_CR,\t /* CR0, CR3, CR4, EFER */\n\tVMCB_DR,         /* DR6, DR7 */\n\tVMCB_DT,         /* GDT, IDT */\n\tVMCB_SEG,        /* CS, DS, SS, ES, CPL */\n\tVMCB_CR2,        /* CR2 only */\n\tVMCB_LBR,        /* DBGCTL, BR_FROM, BR_TO, LAST_EX_FROM, LAST_EX_TO */\n\tVMCB_DIRTY_MAX,\n};\n\n/* TPR and CR2 are always written before VMRUN */\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}\n\nstatic void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr | g->intercept_cr;\n\tc->intercept_dr = h->intercept_dr | g->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions | g->intercept_exceptions;\n\tc->intercept = h->intercept | g->intercept;\n}\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}\n\nstatic unsigned long iopm_base;\n\nstruct kvm_ldttss_desc {\n\tu16 limit0;\n\tu16 base0;\n\tunsigned base1:8, type:5, dpl:2, p:1;\n\tunsigned limit1:4, zero0:3, g:1, base2:8;\n\tu32 base3;\n\tu32 zero1;\n} __attribute__((packed));\n\nstruct svm_cpu_data {\n\tint cpu;\n\n\tu64 asid_generation;\n\tu32 max_asid;\n\tu32 next_asid;\n\tstruct kvm_ldttss_desc *tss_desc;\n\n\tstruct page *save_area;\n};\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstruct svm_init_data {\n\tint cpu;\n\tint r;\n};\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSRS_RANGE_SIZE 2048\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n\nstatic u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}\n\n#define MAX_INST_SIZE 15\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(SVM_STGI));\n}\n\nstatic inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(SVM_INVLPGA) : : \"a\"(addr), \"c\"(asid));\n}\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}\n\nstatic void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\tif (!npt_enabled && !(efer & EFER_LMA))\n\t\tefer &= ~EFER_LME;\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0)\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tif (nr == BP_VECTOR && !static_cpu_has(X86_FEATURE_NRIPS)) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_ptr gdt_descr;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\n\tnative_store_gdt(&gdt_descr);\n\tgdt = (struct desc_struct *)gdt_descr.address;\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tr = -ENOMEM;\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.lbr_ctl = 0;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 max;\n\n\t\tkvm_has_tsc_control = true;\n\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated needed because it will always\n\t\t * be 1 on all machines and a value of 0 is used to disable\n\t\t * tsc-scaling for the vcpu.\n\t\t */\n\t\tmax = min(0x7fffffffULL, __scale_tsc(tsc_khz, TSC_RATIO_MAX));\n\n\t\tkvm_max_guest_tsc_khz = max;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging disabled\\n\");\n\t\tnpt_enabled = false;\n\t}\n\n\tif (npt_enabled) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging enabled\\n\");\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\treturn 0;\n\nerr:\n\t__free_pages(iopm_pages, IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n\treturn r;\n}\n\nstatic __exit void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\tu64 mult, frac, _tsc;\n\n\tmult  = ratio >> 32;\n\tfrac  = ratio & ((1ULL << 32) - 1);\n\n\t_tsc  = tsc;\n\t_tsc *= mult;\n\t_tsc += (tsc >> 32) * frac;\n\t_tsc += ((tsc & ((1ULL << 32) - 1)) * frac) >> 32;\n\n\treturn _tsc;\n}\n\nstatic u64 svm_scale_tsc(struct kvm_vcpu *vcpu, u64 tsc)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 _tsc = tsc;\n\n\tif (svm->tsc_ratio != TSC_RATIO_DEFAULT)\n\t\t_tsc = __scale_tsc(svm->tsc_ratio, tsc);\n\n\treturn _tsc;\n}\n\nstatic void svm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 ratio;\n\tu64 khz;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tsvm->tsc_ratio = TSC_RATIO_DEFAULT;\n\t\treturn;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t} else\n\t\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n\t\treturn;\n\t}\n\n\tkhz = user_tsc_khz;\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = khz << 32;\n\tdo_div(ratio, tsc_khz);\n\n\tif (ratio == 0 || ratio & TSC_RATIO_RSVD) {\n\t\tWARN_ONCE(1, \"Invalid TSC ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t\tuser_tsc_khz);\n\t\treturn;\n\t}\n\tsvm->tsc_ratio             = ratio;\n}\n\nstatic u64 svm_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->vmcb->control.tsc_offset;\n}\n\nstatic void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic void svm_adjust_tsc_offset(struct kvm_vcpu *vcpu, s64 adjustment, bool host)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tWARN_ON(adjustment < 0);\n\tif (host)\n\t\tadjustment = svm_scale_tsc(vcpu, adjustment);\n\n\tsvm->vmcb->control.tsc_offset += adjustment;\n\tif (is_guest_mode(vcpu))\n\t\tsvm->nested.hsave->control.tsc_offset += adjustment;\n\telse\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t     svm->vmcb->control.tsc_offset - adjustment,\n\t\t\t\t     svm->vmcb->control.tsc_offset);\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic u64 svm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = svm_scale_tsc(vcpu, native_read_tsc());\n\n\treturn target_tsc - tsc;\n}\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * This is the guest-visible cr0 value.\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t */\n\tsvm->vcpu.arch.cr0 = 0;\n\t(void)kvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = 0x0007040600070406ULL;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n}\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, eax);\n}\n\nstatic struct kvm_vcpu *svm_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tsvm = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tif (!svm) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsvm->tsc_ratio = TSC_RATIO_DEFAULT;\n\n\terr = kvm_vcpu_init(&svm->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_svm;\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto uninit;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = page_to_pfn(page) << PAGE_SHIFT;\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\tif (kvm_vcpu_is_bsp(&svm->vcpu))\n\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\n\tsvm_init_osvw(&svm->vcpu);\n\n\treturn &svm->vcpu;\n\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nuninit:\n\tkvm_vcpu_uninit(&svm->vcpu);\nfree_svm:\n\tkmem_cache_free(kvm_vcpu_cache, svm);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t__free_page(pfn_to_page(svm->vmcb_pa >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, svm);\n}\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR) &&\n\t    svm->tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t__this_cpu_write(current_tsc_ratio, svm->tsc_ratio);\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, svm->tsc_ratio);\n\t}\n}\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.rflags;\n}\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n       /*\n        * Any change of EFLAGS.VM is accompained by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n}\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n}\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present || (var->type == 0);\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_decache_cr3(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\tif (!svm->vcpu.fpu_active)\n\t\t*hcr0 |= SVM_CR0_SELECTIVE_MASK;\n\telse\n\t\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0 && svm->vcpu.fpu_active) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}\n\nstatic void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}\n\nstatic int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = read_cr4() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}\n\nstatic void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = 1;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}\n\nstatic void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu32 error_code;\n\tint r = 1;\n\n\tswitch (svm->apf_reason) {\n\tdefault:\n\t\terror_code = svm->vmcb->control.exit_info_1;\n\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\t\tif (!npt_enabled && kvm_event_needs_reinjection(&svm->vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(&svm->vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tsvm->vmcb->control.insn_bytes,\n\t\t\tsvm->vmcb->control.insn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tsvm->apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}\n\nstatic int ud_interception(struct vcpu_svm *svm)\n{\n\tint er;\n\n\ter = emulate_instruction(&svm->vcpu, EMULTYPE_TRAP_UD);\n\tif (er != EMULATE_DONE)\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic void svm_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, NM_VECTOR);\n\n\tsvm->vcpu.fpu_active = 1;\n\tupdate_cr0_intercept(svm);\n}\n\nstatic int nm_interception(struct vcpu_svm *svm)\n{\n\tsvm_fpu_activate(&svm->vcpu);\n\treturn 1;\n}\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}\n\nstatic int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}\n\nstatic int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}\n\nstatic int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}\n\nstatic int halt_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 1;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_emulate_halt(&svm->vcpu);\n}\n\nstatic int vmmcall_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_emulate_hypercall(&svm->vcpu);\n\treturn 1;\n}\n\nstatic unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.nested_cr3;\n}\n\nstatic u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr3 = svm->nested.nested_cr3;\n\tu64 pdpte;\n\tint ret;\n\n\tret = kvm_read_guest_page(vcpu->kvm, gpa_to_gfn(cr3), &pdpte,\n\t\t\t\t  offset_in_page(cr3) + index * 8, 8);\n\tif (ret)\n\t\treturn 0;\n\treturn pdpte;\n}\n\nstatic void nested_svm_set_tdp_cr3(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t/*\n\t\t * TODO: track the cause of the nested page fault, and\n\t\t * correctly fill in the high bits of exit_info_1.\n\t\t */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1 = (1ULL << 32);\n\t\tsvm->vmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tsvm->vmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tsvm->vmcb->control.exit_info_1 |= fault->error_code;\n\n\t/*\n\t * The present bit is always zero for page structure faults on real\n\t * hardware.\n\t */\n\tif (svm->vmcb->control.exit_info_1 & (2ULL << 32))\n\t\tsvm->vmcb->control.exit_info_1 &= ~1;\n\n\tnested_svm_vmexit(svm);\n}\n\nstatic void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_init_shadow_mmu(vcpu, &vcpu->arch.mmu);\n\n\tvcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.mmu.shadow_root_level = get_npt_level();\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}\n\nstatic int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t\t      bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tsvm->nested.exit_required = true;\n\n\treturn vmexit;\n}\n\n/* This function returns true if it is save to enable the irq window */\nstatic inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This function returns true if it is save to enable the nmi window */\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}\n\nstatic void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}\n\nstatic void nested_svm_unmap(struct page *page)\n{\n\tkunmap(page);\n\tkvm_release_page_dirty(page);\n}\n\nstatic int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_read_guest(svm->vcpu.kvm, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t/* Offset is in 32 bit units but need in 8 bit units */\n\toffset *= 4;\n\n\tif (kvm_read_guest(svm->vcpu.kvm, svm->nested.vmcb_msrpm + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + NM_VECTOR:\n\t\tnm_interception(svm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}\n\n/*\n * If this function returns true, this #vmexit was already handled\n */\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\t/* async page fault always cause vmexit */\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}\n\nstatic int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}\n\nstatic inline void copy_vmcb_control_area(struct vmcb *dst_vmcb, struct vmcb *from_vmcb)\n{\n\tstruct vmcb_control_area *dst  = &dst_vmcb->control;\n\tstruct vmcb_control_area *from = &from_vmcb->control;\n\n\tdst->intercept_cr         = from->intercept_cr;\n\tdst->intercept_dr         = from->intercept_dr;\n\tdst->intercept_exceptions = from->intercept_exceptions;\n\tdst->intercept            = from->intercept;\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->lbr_ctl              = from->lbr_ctl;\n}\n\nstatic int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tnested_vmcb = nested_svm_map(svm, svm->nested.vmcb, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\tnested_vmcb->control.next_rip          = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, hsave->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, hsave->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tnested_svm_unmap(page);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\treturn 0;\n}\n\nstatic bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_read_guest(svm->vcpu.kvm, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}\n\nstatic bool nested_vmcb_checks(struct vmcb *vmcb)\n{\n\tif ((vmcb->control.intercept & (1ULL << INTERCEPT_VMRUN)) == 0)\n\t\treturn false;\n\n\tif (vmcb->control.asid == 0)\n\t\treturn false;\n\n\tif (vmcb->control.nested_ctl && !npt_enabled)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct page *page;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn false;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_unmap(page);\n\n\t\treturn false;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl) {\n\t\tkvm_mmu_unload(&svm->vcpu);\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RAX, nested_vmcb->save.rax);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RSP, nested_vmcb->save.rsp);\n\tkvm_register_write(&svm->vcpu, VCPU_REGS_RIP, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of the guest */\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tclr_intercept(svm, INTERCEPT_VMMCALL);\n\n\tsvm->vmcb->control.lbr_ctl = nested_vmcb->control.lbr_ctl;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tnested_svm_unmap(page);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\tenable_gif(svm);\n\n\tmark_all_dirty(svm->vmcb);\n\n\treturn true;\n}\n\nstatic void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}\n\nstatic int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}\n\nstatic int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}\n\nstatic int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/* Save rip after vmrun instruction */\n\tkvm_rip_write(&svm->vcpu, kvm_rip_read(&svm->vcpu) + 3);\n\n\tif (!nested_svm_vmrun(svm))\n\t\treturn 1;\n\n\tif (!nested_svm_vmrun_msrpm(svm))\n\t\tgoto failed;\n\n\treturn 1;\n\nfailed:\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\n\treturn 1;\n}\n\nstatic int stgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn 1;\n}\n\nstatic int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\n\treturn 1;\n}\n\nstatic int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, vcpu->arch.regs[VCPU_REGS_RCX],\n\t\t\t  vcpu->arch.regs[VCPU_REGS_RAX]);\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, vcpu->arch.regs[VCPU_REGS_RAX]);\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, svm->vcpu.arch.regs[VCPU_REGS_RAX]);\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_register_read(&svm->vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}\n\nstatic int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR)))\n\t\tskip_emulated_instruction(&svm->vcpu);\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\tif (kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t\thas_error_code, error_code) == EMULATE_FAIL) {\n\t\tsvm->vcpu.run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tsvm->vcpu.run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tsvm->vcpu.run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int cpuid_interception(struct vcpu_svm *svm)\n{\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tkvm_emulate_cpuid(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}\n\nstatic int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn 1;\n}\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn emulate_instruction(&svm->vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_NRIPS))\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}\n\nbool check_selective_cr0_intercepted(struct vcpu_svm *svm, unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}\n\n#define CR_VALID (1ULL << 63)\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\tkvm_complete_insn_gp(&svm->vcpu, err);\n\n\treturn 1;\n}\n\nstatic int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\tint err;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\terr = kvm_get_dr(&svm->vcpu, dr, &val);\n\t\tif (!err)\n\t\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\tskip_emulated_instruction(&svm->vcpu);\n\n\treturn 1;\n}\n\nstatic int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (irqchip_in_kernel(svm->vcpu.kvm))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}\n\nstatic u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(to_svm(vcpu));\n\treturn vmcb->control.tsc_offset +\n\t\tsvm_scale_tsc(vcpu, host_tsc);\n}\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 *data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC: {\n\t\t*data = svm->vmcb->control.tsc_offset +\n\t\t\tsvm_scale_tsc(vcpu, native_read_tsc());\n\n\t\tbreak;\n\t}\n\tcase MSR_STAR:\n\t\t*data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\t*data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\t*data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\t*data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\t*data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\t*data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\t*data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t*data = svm->sysenter_esp;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\t*data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\t*data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\t*data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\t*data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\t*data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\t*data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\t*data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\t*data = 0x01000065;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, ecx, data);\n\t}\n\treturn 0;\n}\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\n\tif (svm_get_msr(&svm->vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, data);\n\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RAX] = data & 0xffffffff;\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RDX] = data >> 32;\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr);\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n\nstatic int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}\n\nstatic int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\t/*\n\t * If the user space waits to inject interrupts, exit as soon as\n\t * possible\n\t */\n\tif (!irqchip_in_kernel(svm->vcpu.kvm) &&\n\t    kvm_run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(&svm->vcpu)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int pause_interception(struct vcpu_svm *svm)\n{\n\tkvm_vcpu_on_spin(&(svm->vcpu));\n\treturn 1;\n}\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\tskip_emulated_instruction(&(svm->vcpu));\n\treturn 1;\n}\n\nstatic int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}\n\nstatic int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}\n\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= emulate_on_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = emulate_on_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= pf_interception,\n};\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"lbr_ctl:\", control->lbr_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}\n\nstatic int handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tpr_err(\"KVM: FAILED VMRUN WITH VMCB:\\n\");\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tkvm_run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tkvm_run->hw.hardware_exit_reason = exit_code;\n\t\treturn 0;\n\t}\n\n\treturn svm_exit_handlers[exit_code](svm);\n}\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}\n\nstatic inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}\n\nstatic void svm_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\treturn;\n}\n\nstatic int svm_vm_has_apicv(struct kvm *kvm)\n{\n\treturn 0;\n}\n\nstatic void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}\n\nstatic void svm_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\treturn;\n}\n\nstatic void svm_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tret = !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn ret && !(svm->vcpu.arch.hflags & HF_VINTR_MASK);\n\n\treturn ret;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept.\n\t */\n\tif (gif_set(svm) && nested_svm_intr(svm)) {\n\t\tsvm_set_vintr(svm);\n\t\tsvm_inject_irq(svm, 0x0);\n\t}\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}\n\nstatic int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}\n\nstatic void svm_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}\n\nstatic void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}\n\nstatic void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\ttrace_kvm_exit(svm->vmcb->control.exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_handle_nmi(&svm->vcpu);\n\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_handle_nmi(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}\n\nstatic void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic void set_tdp_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.nested_cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t/* Also sync guest cr3 here in case we live migrate */\n\tsvm->vmcb->save.cr3 = kvm_read_cr3(vcpu);\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tsvm_flush_tlb(vcpu);\n}\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}\n\nstatic void svm_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = 0;\n}\n\nstatic bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}\n\nstatic void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tswitch (func) {\n\tcase 0x80000001:\n\t\tif (nested)\n\t\t\tentry->ecx |= (1 << 2); /* Set SVM bit */\n\t\tbreak;\n\tcase 0x8000000A:\n\t\tentry->eax = 1; /* SVM revision 1 */\n\t\tentry->ebx = 8; /* Lets support 8 ASIDs in case we add proper\n\t\t\t\t   ASID emulation to nested SVM */\n\t\tentry->ecx = 0; /* Reserved */\n\t\tentry->edx = 0; /* Per default do not support any\n\t\t\t\t   additional features */\n\n\t\t/* Support next_rip if host supports it */\n\t\tif (boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tentry->edx |= SVM_FEATURE_NRIP;\n\n\t\t/* Support NPT for the guest if enabled */\n\t\tif (npt_enabled)\n\t\t\tentry->edx |= SVM_FEATURE_NPT;\n\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_lpage_level(void)\n{\n\treturn PT_PDPE_LEVEL;\n}\n\nstatic bool svm_rdtscp_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_invpcid_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_mpx_supported(void)\n{\n\treturn false;\n}\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}\n\nstatic void svm_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tset_exception_intercept(svm, NM_VECTOR);\n\tupdate_cr0_intercept(svm);\n}\n\n#define PRE_EX(exit)  { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_PRE_EXCEPT, }\n#define POST_EX(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_EXCEPT, }\n#define POST_MEM(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_MEMACCESS, }\n\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n};\n\n#undef PRE_EX\n#undef POST_EX\n#undef POST_MEM\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}\n\nstatic void svm_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tlocal_irq_enable();\n}\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n}\n\nstatic struct kvm_x86_ops svm_x86_ops = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.cpu_has_accelerated_tpr = svm_cpu_has_accelerated_tpr,\n\n\t.vcpu_create = svm_create_vcpu,\n\t.vcpu_free = svm_free_vcpu,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.prepare_guest_switch = svm_prepare_guest_switch,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\n\t.update_db_bp_intercept = update_db_bp_intercept,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = kvm_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = svm_decache_cr0_guest_bits,\n\t.decache_cr3 = svm_decache_cr3,\n\t.decache_cr4_guest_bits = svm_decache_cr4_guest_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.set_cr3 = svm_set_cr3,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.get_dr6 = svm_get_dr6,\n\t.set_dr6 = svm_set_dr6,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\t.fpu_deactivate = svm_fpu_deactivate,\n\n\t.tlb_flush = svm_flush_tlb,\n\n\t.run = svm_vcpu_run,\n\t.handle_exit = handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.set_irq = svm_set_irq,\n\t.set_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,\n\t.vm_has_apicv = svm_vm_has_apicv,\n\t.load_eoi_exitmap = svm_load_eoi_exitmap,\n\t.hwapic_isr_update = svm_hwapic_isr_update,\n\t.sync_pir_to_irr = svm_sync_pir_to_irr,\n\n\t.set_tss_addr = svm_set_tss_addr,\n\t.get_tdp_level = get_npt_level,\n\t.get_mt_mask = svm_get_mt_mask,\n\n\t.get_exit_info = svm_get_exit_info,\n\n\t.get_lpage_level = svm_get_lpage_level,\n\n\t.cpuid_update = svm_cpuid_update,\n\n\t.rdtscp_supported = svm_rdtscp_supported,\n\t.invpcid_supported = svm_invpcid_supported,\n\t.mpx_supported = svm_mpx_supported,\n\n\t.set_supported_cpuid = svm_set_supported_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.set_tsc_khz = svm_set_tsc_khz,\n\t.read_tsc_offset = svm_read_tsc_offset,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.adjust_tsc_offset = svm_adjust_tsc_offset,\n\t.compute_tsc_offset = svm_compute_tsc_offset,\n\t.read_l1_tsc = svm_read_l1_tsc,\n\n\t.set_tdp_cr3 = set_tdp_cr3,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_external_intr = svm_handle_external_intr,\n\n\t.sched_in = svm_sched_in,\n};\n\nstatic int __init svm_init(void)\n{\n\treturn kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}\n\nmodule_init(svm_init)\nmodule_exit(svm_exit)\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"cpuid.h\"\n\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/ftrace_event.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/hrtimer.h>\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n\n#include <asm/io.h>\n#include <asm/desc.h>\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/xcr.h>\n#include <asm/perf_event.h>\n#include <asm/debugreg.h>\n#include <asm/kexec.h>\n\n#include \"trace.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n#define __ex_clear(x, reg) \\\n\t____kvm_handle_fault_on_reboot(x, \"xor \" reg \" , \" reg)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_VMX),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n\nstatic bool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly vmm_exclusive = 1;\nmodule_param(vmm_exclusive, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_apicv = 1;\nmodule_param(enable_apicv, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_shadow_vmcs = 1;\nmodule_param_named(enable_shadow_vmcs, enable_shadow_vmcs, bool, S_IRUGO);\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 0;\nmodule_param(nested, bool, S_IRUGO);\n\n#define KVM_GUEST_CR0_MASK (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST (X86_CR0_WP | X86_CR0_NE)\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT)\n\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE 5\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\n#define KVM_VMX_DEFAULT_PLE_GAP           128\n#define KVM_VMX_DEFAULT_PLE_WINDOW        4096\n#define KVM_VMX_DEFAULT_PLE_WINDOW_GROW   2\n#define KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK 0\n#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    \\\n\t\tINT_MAX / KVM_VMX_DEFAULT_PLE_WINDOW_GROW\n\nstatic int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, int, S_IRUGO);\n\nstatic int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, int, S_IRUGO);\n\n/* Default doubles per-vcpu window every exit. */\nstatic int ple_window_grow = KVM_VMX_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, int, S_IRUGO);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic int ple_window_shrink = KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, int, S_IRUGO);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic int ple_window_actual_max = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, int, S_IRUGO);\n\nextern const ulong vmx_return;\n\n#define NR_AUTOLOAD_MSRS 8\n#define VMCS02_POOL_SIZE 1\n\nstruct vmcs {\n\tu32 revision_id;\n\tu32 abort;\n\tchar data[0];\n};\n\n/*\n * Track a VMCS that may be loaded on a certain CPU. If it is (cpu!=-1), also\n * remember whether it was VMLAUNCHed, and maintain a linked list of all VMCSs\n * loaded on this CPU (so we can clear them if the CPU goes down).\n */\nstruct loaded_vmcs {\n\tstruct vmcs *vmcs;\n\tint cpu;\n\tint launched;\n\tstruct list_head loaded_vmcss_on_cpu_link;\n};\n\nstruct shared_msr_entry {\n\tunsigned index;\n\tu64 data;\n\tu64 mask;\n};\n\n/*\n * struct vmcs12 describes the state that our guest hypervisor (L1) keeps for a\n * single nested guest (L2), hence the name vmcs12. Any VMX implementation has\n * a VMCS structure, and vmcs12 is our emulated VMX's VMCS. This structure is\n * stored in guest memory specified by VMPTRLD, but is opaque to the guest,\n * which must access it using VMREAD/VMWRITE/VMCLEAR instructions.\n * More than one of these structures may exist, if L1 runs multiple L2 guests.\n * nested_vmx_run() will use the data here to build a vmcs02: a VMCS for the\n * underlying hardware which will be used to run L2.\n * This structure is packed to ensure that its layout is identical across\n * machines (necessary for live migration).\n * If there are changes in this struct, VMCS12_REVISION must be changed.\n */\ntypedef u64 natural_width;\nstruct __packed vmcs12 {\n\t/* According to the Intel spec, a VMCS region must start with the\n\t * following two fields. Then follow implementation-specific data.\n\t */\n\tu32 revision_id;\n\tu32 abort;\n\n\tu32 launch_state; /* set to 0 by VMCLEAR, to 1 by VMLAUNCH */\n\tu32 padding[7]; /* room for future expansion */\n\n\tu64 io_bitmap_a;\n\tu64 io_bitmap_b;\n\tu64 msr_bitmap;\n\tu64 vm_exit_msr_store_addr;\n\tu64 vm_exit_msr_load_addr;\n\tu64 vm_entry_msr_load_addr;\n\tu64 tsc_offset;\n\tu64 virtual_apic_page_addr;\n\tu64 apic_access_addr;\n\tu64 ept_pointer;\n\tu64 guest_physical_address;\n\tu64 vmcs_link_pointer;\n\tu64 guest_ia32_debugctl;\n\tu64 guest_ia32_pat;\n\tu64 guest_ia32_efer;\n\tu64 guest_ia32_perf_global_ctrl;\n\tu64 guest_pdptr0;\n\tu64 guest_pdptr1;\n\tu64 guest_pdptr2;\n\tu64 guest_pdptr3;\n\tu64 guest_bndcfgs;\n\tu64 host_ia32_pat;\n\tu64 host_ia32_efer;\n\tu64 host_ia32_perf_global_ctrl;\n\tu64 padding64[8]; /* room for future expansion */\n\t/*\n\t * To allow migration of L1 (complete with its L2 guests) between\n\t * machines of different natural widths (32 or 64 bit), we cannot have\n\t * unsigned long fields with no explict size. We use u64 (aliased\n\t * natural_width) instead. Luckily, x86 is little-endian.\n\t */\n\tnatural_width cr0_guest_host_mask;\n\tnatural_width cr4_guest_host_mask;\n\tnatural_width cr0_read_shadow;\n\tnatural_width cr4_read_shadow;\n\tnatural_width cr3_target_value0;\n\tnatural_width cr3_target_value1;\n\tnatural_width cr3_target_value2;\n\tnatural_width cr3_target_value3;\n\tnatural_width exit_qualification;\n\tnatural_width guest_linear_address;\n\tnatural_width guest_cr0;\n\tnatural_width guest_cr3;\n\tnatural_width guest_cr4;\n\tnatural_width guest_es_base;\n\tnatural_width guest_cs_base;\n\tnatural_width guest_ss_base;\n\tnatural_width guest_ds_base;\n\tnatural_width guest_fs_base;\n\tnatural_width guest_gs_base;\n\tnatural_width guest_ldtr_base;\n\tnatural_width guest_tr_base;\n\tnatural_width guest_gdtr_base;\n\tnatural_width guest_idtr_base;\n\tnatural_width guest_dr7;\n\tnatural_width guest_rsp;\n\tnatural_width guest_rip;\n\tnatural_width guest_rflags;\n\tnatural_width guest_pending_dbg_exceptions;\n\tnatural_width guest_sysenter_esp;\n\tnatural_width guest_sysenter_eip;\n\tnatural_width host_cr0;\n\tnatural_width host_cr3;\n\tnatural_width host_cr4;\n\tnatural_width host_fs_base;\n\tnatural_width host_gs_base;\n\tnatural_width host_tr_base;\n\tnatural_width host_gdtr_base;\n\tnatural_width host_idtr_base;\n\tnatural_width host_ia32_sysenter_esp;\n\tnatural_width host_ia32_sysenter_eip;\n\tnatural_width host_rsp;\n\tnatural_width host_rip;\n\tnatural_width paddingl[8]; /* room for future expansion */\n\tu32 pin_based_vm_exec_control;\n\tu32 cpu_based_vm_exec_control;\n\tu32 exception_bitmap;\n\tu32 page_fault_error_code_mask;\n\tu32 page_fault_error_code_match;\n\tu32 cr3_target_count;\n\tu32 vm_exit_controls;\n\tu32 vm_exit_msr_store_count;\n\tu32 vm_exit_msr_load_count;\n\tu32 vm_entry_controls;\n\tu32 vm_entry_msr_load_count;\n\tu32 vm_entry_intr_info_field;\n\tu32 vm_entry_exception_error_code;\n\tu32 vm_entry_instruction_len;\n\tu32 tpr_threshold;\n\tu32 secondary_vm_exec_control;\n\tu32 vm_instruction_error;\n\tu32 vm_exit_reason;\n\tu32 vm_exit_intr_info;\n\tu32 vm_exit_intr_error_code;\n\tu32 idt_vectoring_info_field;\n\tu32 idt_vectoring_error_code;\n\tu32 vm_exit_instruction_len;\n\tu32 vmx_instruction_info;\n\tu32 guest_es_limit;\n\tu32 guest_cs_limit;\n\tu32 guest_ss_limit;\n\tu32 guest_ds_limit;\n\tu32 guest_fs_limit;\n\tu32 guest_gs_limit;\n\tu32 guest_ldtr_limit;\n\tu32 guest_tr_limit;\n\tu32 guest_gdtr_limit;\n\tu32 guest_idtr_limit;\n\tu32 guest_es_ar_bytes;\n\tu32 guest_cs_ar_bytes;\n\tu32 guest_ss_ar_bytes;\n\tu32 guest_ds_ar_bytes;\n\tu32 guest_fs_ar_bytes;\n\tu32 guest_gs_ar_bytes;\n\tu32 guest_ldtr_ar_bytes;\n\tu32 guest_tr_ar_bytes;\n\tu32 guest_interruptibility_info;\n\tu32 guest_activity_state;\n\tu32 guest_sysenter_cs;\n\tu32 host_ia32_sysenter_cs;\n\tu32 vmx_preemption_timer_value;\n\tu32 padding32[7]; /* room for future expansion */\n\tu16 virtual_processor_id;\n\tu16 guest_es_selector;\n\tu16 guest_cs_selector;\n\tu16 guest_ss_selector;\n\tu16 guest_ds_selector;\n\tu16 guest_fs_selector;\n\tu16 guest_gs_selector;\n\tu16 guest_ldtr_selector;\n\tu16 guest_tr_selector;\n\tu16 host_es_selector;\n\tu16 host_cs_selector;\n\tu16 host_ss_selector;\n\tu16 host_ds_selector;\n\tu16 host_fs_selector;\n\tu16 host_gs_selector;\n\tu16 host_tr_selector;\n};\n\n/*\n * VMCS12_REVISION is an arbitrary id that should be changed if the content or\n * layout of struct vmcs12 is changed. MSR_IA32_VMX_BASIC returns this id, and\n * VMPTRLD verifies that the VMCS region that L1 is loading contains this id.\n */\n#define VMCS12_REVISION 0x11e57ed0\n\n/*\n * VMCS12_SIZE is the number of bytes L1 should allocate for the VMXON region\n * and any VMCS region. Although only sizeof(struct vmcs12) are used by the\n * current implementation, 4K are reserved to avoid future complications.\n */\n#define VMCS12_SIZE 0x1000\n\n/* Used to remember the last vmcs02 used for some recently used vmcs12s */\nstruct vmcs02_list {\n\tstruct list_head list;\n\tgpa_t vmptr;\n\tstruct loaded_vmcs vmcs02;\n};\n\n/*\n * The nested_vmx structure is part of vcpu_vmx, and holds information we need\n * for correct emulation of VMX (i.e., nested VMX) on this vcpu.\n */\nstruct nested_vmx {\n\t/* Has the level1 guest done vmxon? */\n\tbool vmxon;\n\tgpa_t vmxon_ptr;\n\n\t/* The guest-physical address of the current VMCS L1 keeps for L2 */\n\tgpa_t current_vmptr;\n\t/* The host-usable pointer to the above */\n\tstruct page *current_vmcs12_page;\n\tstruct vmcs12 *current_vmcs12;\n\tstruct vmcs *current_shadow_vmcs;\n\t/*\n\t * Indicates if the shadow vmcs must be updated with the\n\t * data hold by vmcs12\n\t */\n\tbool sync_shadow_vmcs;\n\n\t/* vmcs02_list cache of VMCSs recently used to run L2 guests */\n\tstruct list_head vmcs02_pool;\n\tint vmcs02_num;\n\tu64 vmcs01_tsc_offset;\n\t/* L2 must run next, and mustn't decide to exit to L1. */\n\tbool nested_run_pending;\n\t/*\n\t * Guest pages referred to in vmcs02 with host-physical pointers, so\n\t * we must keep them pinned while L2 runs.\n\t */\n\tstruct page *apic_access_page;\n\tstruct page *virtual_apic_page;\n\tu64 msr_ia32_feature_control;\n\n\tstruct hrtimer preemption_timer;\n\tbool preemption_timer_expired;\n\n\t/* to migrate it to L2 if VM_ENTRY_LOAD_DEBUG_CONTROLS is off */\n\tu64 vmcs01_debugctl;\n};\n\n#define POSTED_INTR_ON  0\n/* Posted-Interrupt Descriptor */\nstruct pi_desc {\n\tu32 pir[8];     /* Posted interrupt requested */\n\tu32 control;\t/* bit 0 of control is outstanding notification bit */\n\tu32 rsvd[7];\n} __aligned(64);\n\nstatic bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic bool pi_test_and_clear_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_clear_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}\n\nstruct vcpu_vmx {\n\tstruct kvm_vcpu       vcpu;\n\tunsigned long         host_rsp;\n\tu8                    fail;\n\tbool                  nmi_known_unmasked;\n\tu32                   exit_intr_info;\n\tu32                   idt_vectoring_info;\n\tulong                 rflags;\n\tstruct shared_msr_entry *guest_msrs;\n\tint                   nmsrs;\n\tint                   save_nmsrs;\n\tunsigned long\t      host_idt_base;\n#ifdef CONFIG_X86_64\n\tu64 \t\t      msr_host_kernel_gs_base;\n\tu64 \t\t      msr_guest_kernel_gs_base;\n#endif\n\tu32 vm_entry_controls_shadow;\n\tu32 vm_exit_controls_shadow;\n\t/*\n\t * loaded_vmcs points to the VMCS currently used in this vcpu. For a\n\t * non-nested (L1) guest, it always points to vmcs01. For a nested\n\t * guest (L2), it points to a different VMCS.\n\t */\n\tstruct loaded_vmcs    vmcs01;\n\tstruct loaded_vmcs   *loaded_vmcs;\n\tbool                  __launched; /* temporary, used in vmx_vcpu_run */\n\tstruct msr_autoload {\n\t\tunsigned nr;\n\t\tstruct vmx_msr_entry guest[NR_AUTOLOAD_MSRS];\n\t\tstruct vmx_msr_entry host[NR_AUTOLOAD_MSRS];\n\t} msr_autoload;\n\tstruct {\n\t\tint           loaded;\n\t\tu16           fs_sel, gs_sel, ldt_sel;\n#ifdef CONFIG_X86_64\n\t\tu16           ds_sel, es_sel;\n#endif\n\t\tint           gs_ldt_reload_needed;\n\t\tint           fs_reload_needed;\n\t\tu64           msr_host_bndcfgs;\n\t\tunsigned long vmcs_host_cr4;\t/* May not match real cr4 */\n\t} host_state;\n\tstruct {\n\t\tint vm86_active;\n\t\tulong save_rflags;\n\t\tstruct kvm_segment segs[8];\n\t} rmode;\n\tstruct {\n\t\tu32 bitmask; /* 4 bits per segment (1 bit per field) */\n\t\tstruct kvm_save_segment {\n\t\t\tu16 selector;\n\t\t\tunsigned long base;\n\t\t\tu32 limit;\n\t\t\tu32 ar;\n\t\t} seg[8];\n\t} segment_cache;\n\tint vpid;\n\tbool emulation_required;\n\n\t/* Support for vnmi-less CPUs */\n\tint soft_vnmi_blocked;\n\tktime_t entry_time;\n\ts64 vnmi_blocked_time;\n\tu32 exit_reason;\n\n\tbool rdtscp_enabled;\n\n\t/* Posted interrupt descriptor */\n\tstruct pi_desc pi_desc;\n\n\t/* Support for a guest hypervisor (nested VMX) */\n\tstruct nested_vmx nested;\n\n\t/* Dynamic PLE window. */\n\tint ple_window;\n\tbool ple_window_dirty;\n};\n\nenum segment_cache_field {\n\tSEG_FIELD_SEL = 0,\n\tSEG_FIELD_BASE = 1,\n\tSEG_FIELD_LIMIT = 2,\n\tSEG_FIELD_AR = 3,\n\n\tSEG_FIELD_NR = 4\n};\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}\n\n#define VMCS12_OFFSET(x) offsetof(struct vmcs12, x)\n#define FIELD(number, name)\t[number] = VMCS12_OFFSET(name)\n#define FIELD64(number, name)\t[number] = VMCS12_OFFSET(name), \\\n\t\t\t\t[number##_HIGH] = VMCS12_OFFSET(name)+4\n\n\nstatic unsigned long shadow_read_only_fields[] = {\n\t/*\n\t * We do NOT shadow fields that are modified when L0\n\t * traps and emulates any vmx instruction (e.g. VMPTRLD,\n\t * VMXON...) executed by L1.\n\t * For example, VM_INSTRUCTION_ERROR is read\n\t * by L1 if a vmx instruction fails (part of the error path).\n\t * Note the code assumes this logic. If for some reason\n\t * we start shadowing these fields then we need to\n\t * force a shadow sync when L0 emulates vmx instructions\n\t * (e.g. force a sync if VM_INSTRUCTION_ERROR is modified\n\t * by nested_vmx_failValid)\n\t */\n\tVM_EXIT_REASON,\n\tVM_EXIT_INTR_INFO,\n\tVM_EXIT_INSTRUCTION_LEN,\n\tIDT_VECTORING_INFO_FIELD,\n\tIDT_VECTORING_ERROR_CODE,\n\tVM_EXIT_INTR_ERROR_CODE,\n\tEXIT_QUALIFICATION,\n\tGUEST_LINEAR_ADDRESS,\n\tGUEST_PHYSICAL_ADDRESS\n};\nstatic int max_shadow_read_only_fields =\n\tARRAY_SIZE(shadow_read_only_fields);\n\nstatic unsigned long shadow_read_write_fields[] = {\n\tTPR_THRESHOLD,\n\tGUEST_RIP,\n\tGUEST_RSP,\n\tGUEST_CR0,\n\tGUEST_CR3,\n\tGUEST_CR4,\n\tGUEST_INTERRUPTIBILITY_INFO,\n\tGUEST_RFLAGS,\n\tGUEST_CS_SELECTOR,\n\tGUEST_CS_AR_BYTES,\n\tGUEST_CS_LIMIT,\n\tGUEST_CS_BASE,\n\tGUEST_ES_BASE,\n\tGUEST_BNDCFGS,\n\tCR0_GUEST_HOST_MASK,\n\tCR0_READ_SHADOW,\n\tCR4_READ_SHADOW,\n\tTSC_OFFSET,\n\tEXCEPTION_BITMAP,\n\tCPU_BASED_VM_EXEC_CONTROL,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tVM_ENTRY_INTR_INFO_FIELD,\n\tVM_ENTRY_INSTRUCTION_LEN,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tHOST_FS_BASE,\n\tHOST_GS_BASE,\n\tHOST_FS_SELECTOR,\n\tHOST_GS_SELECTOR\n};\nstatic int max_shadow_read_write_fields =\n\tARRAY_SIZE(shadow_read_write_fields);\n\nstatic const unsigned short vmcs_field_to_offset_table[] = {\n\tFIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id),\n\tFIELD(GUEST_ES_SELECTOR, guest_es_selector),\n\tFIELD(GUEST_CS_SELECTOR, guest_cs_selector),\n\tFIELD(GUEST_SS_SELECTOR, guest_ss_selector),\n\tFIELD(GUEST_DS_SELECTOR, guest_ds_selector),\n\tFIELD(GUEST_FS_SELECTOR, guest_fs_selector),\n\tFIELD(GUEST_GS_SELECTOR, guest_gs_selector),\n\tFIELD(GUEST_LDTR_SELECTOR, guest_ldtr_selector),\n\tFIELD(GUEST_TR_SELECTOR, guest_tr_selector),\n\tFIELD(HOST_ES_SELECTOR, host_es_selector),\n\tFIELD(HOST_CS_SELECTOR, host_cs_selector),\n\tFIELD(HOST_SS_SELECTOR, host_ss_selector),\n\tFIELD(HOST_DS_SELECTOR, host_ds_selector),\n\tFIELD(HOST_FS_SELECTOR, host_fs_selector),\n\tFIELD(HOST_GS_SELECTOR, host_gs_selector),\n\tFIELD(HOST_TR_SELECTOR, host_tr_selector),\n\tFIELD64(IO_BITMAP_A, io_bitmap_a),\n\tFIELD64(IO_BITMAP_B, io_bitmap_b),\n\tFIELD64(MSR_BITMAP, msr_bitmap),\n\tFIELD64(VM_EXIT_MSR_STORE_ADDR, vm_exit_msr_store_addr),\n\tFIELD64(VM_EXIT_MSR_LOAD_ADDR, vm_exit_msr_load_addr),\n\tFIELD64(VM_ENTRY_MSR_LOAD_ADDR, vm_entry_msr_load_addr),\n\tFIELD64(TSC_OFFSET, tsc_offset),\n\tFIELD64(VIRTUAL_APIC_PAGE_ADDR, virtual_apic_page_addr),\n\tFIELD64(APIC_ACCESS_ADDR, apic_access_addr),\n\tFIELD64(EPT_POINTER, ept_pointer),\n\tFIELD64(GUEST_PHYSICAL_ADDRESS, guest_physical_address),\n\tFIELD64(VMCS_LINK_POINTER, vmcs_link_pointer),\n\tFIELD64(GUEST_IA32_DEBUGCTL, guest_ia32_debugctl),\n\tFIELD64(GUEST_IA32_PAT, guest_ia32_pat),\n\tFIELD64(GUEST_IA32_EFER, guest_ia32_efer),\n\tFIELD64(GUEST_IA32_PERF_GLOBAL_CTRL, guest_ia32_perf_global_ctrl),\n\tFIELD64(GUEST_PDPTR0, guest_pdptr0),\n\tFIELD64(GUEST_PDPTR1, guest_pdptr1),\n\tFIELD64(GUEST_PDPTR2, guest_pdptr2),\n\tFIELD64(GUEST_PDPTR3, guest_pdptr3),\n\tFIELD64(GUEST_BNDCFGS, guest_bndcfgs),\n\tFIELD64(HOST_IA32_PAT, host_ia32_pat),\n\tFIELD64(HOST_IA32_EFER, host_ia32_efer),\n\tFIELD64(HOST_IA32_PERF_GLOBAL_CTRL, host_ia32_perf_global_ctrl),\n\tFIELD(PIN_BASED_VM_EXEC_CONTROL, pin_based_vm_exec_control),\n\tFIELD(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control),\n\tFIELD(EXCEPTION_BITMAP, exception_bitmap),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MASK, page_fault_error_code_mask),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MATCH, page_fault_error_code_match),\n\tFIELD(CR3_TARGET_COUNT, cr3_target_count),\n\tFIELD(VM_EXIT_CONTROLS, vm_exit_controls),\n\tFIELD(VM_EXIT_MSR_STORE_COUNT, vm_exit_msr_store_count),\n\tFIELD(VM_EXIT_MSR_LOAD_COUNT, vm_exit_msr_load_count),\n\tFIELD(VM_ENTRY_CONTROLS, vm_entry_controls),\n\tFIELD(VM_ENTRY_MSR_LOAD_COUNT, vm_entry_msr_load_count),\n\tFIELD(VM_ENTRY_INTR_INFO_FIELD, vm_entry_intr_info_field),\n\tFIELD(VM_ENTRY_EXCEPTION_ERROR_CODE, vm_entry_exception_error_code),\n\tFIELD(VM_ENTRY_INSTRUCTION_LEN, vm_entry_instruction_len),\n\tFIELD(TPR_THRESHOLD, tpr_threshold),\n\tFIELD(SECONDARY_VM_EXEC_CONTROL, secondary_vm_exec_control),\n\tFIELD(VM_INSTRUCTION_ERROR, vm_instruction_error),\n\tFIELD(VM_EXIT_REASON, vm_exit_reason),\n\tFIELD(VM_EXIT_INTR_INFO, vm_exit_intr_info),\n\tFIELD(VM_EXIT_INTR_ERROR_CODE, vm_exit_intr_error_code),\n\tFIELD(IDT_VECTORING_INFO_FIELD, idt_vectoring_info_field),\n\tFIELD(IDT_VECTORING_ERROR_CODE, idt_vectoring_error_code),\n\tFIELD(VM_EXIT_INSTRUCTION_LEN, vm_exit_instruction_len),\n\tFIELD(VMX_INSTRUCTION_INFO, vmx_instruction_info),\n\tFIELD(GUEST_ES_LIMIT, guest_es_limit),\n\tFIELD(GUEST_CS_LIMIT, guest_cs_limit),\n\tFIELD(GUEST_SS_LIMIT, guest_ss_limit),\n\tFIELD(GUEST_DS_LIMIT, guest_ds_limit),\n\tFIELD(GUEST_FS_LIMIT, guest_fs_limit),\n\tFIELD(GUEST_GS_LIMIT, guest_gs_limit),\n\tFIELD(GUEST_LDTR_LIMIT, guest_ldtr_limit),\n\tFIELD(GUEST_TR_LIMIT, guest_tr_limit),\n\tFIELD(GUEST_GDTR_LIMIT, guest_gdtr_limit),\n\tFIELD(GUEST_IDTR_LIMIT, guest_idtr_limit),\n\tFIELD(GUEST_ES_AR_BYTES, guest_es_ar_bytes),\n\tFIELD(GUEST_CS_AR_BYTES, guest_cs_ar_bytes),\n\tFIELD(GUEST_SS_AR_BYTES, guest_ss_ar_bytes),\n\tFIELD(GUEST_DS_AR_BYTES, guest_ds_ar_bytes),\n\tFIELD(GUEST_FS_AR_BYTES, guest_fs_ar_bytes),\n\tFIELD(GUEST_GS_AR_BYTES, guest_gs_ar_bytes),\n\tFIELD(GUEST_LDTR_AR_BYTES, guest_ldtr_ar_bytes),\n\tFIELD(GUEST_TR_AR_BYTES, guest_tr_ar_bytes),\n\tFIELD(GUEST_INTERRUPTIBILITY_INFO, guest_interruptibility_info),\n\tFIELD(GUEST_ACTIVITY_STATE, guest_activity_state),\n\tFIELD(GUEST_SYSENTER_CS, guest_sysenter_cs),\n\tFIELD(HOST_IA32_SYSENTER_CS, host_ia32_sysenter_cs),\n\tFIELD(VMX_PREEMPTION_TIMER_VALUE, vmx_preemption_timer_value),\n\tFIELD(CR0_GUEST_HOST_MASK, cr0_guest_host_mask),\n\tFIELD(CR4_GUEST_HOST_MASK, cr4_guest_host_mask),\n\tFIELD(CR0_READ_SHADOW, cr0_read_shadow),\n\tFIELD(CR4_READ_SHADOW, cr4_read_shadow),\n\tFIELD(CR3_TARGET_VALUE0, cr3_target_value0),\n\tFIELD(CR3_TARGET_VALUE1, cr3_target_value1),\n\tFIELD(CR3_TARGET_VALUE2, cr3_target_value2),\n\tFIELD(CR3_TARGET_VALUE3, cr3_target_value3),\n\tFIELD(EXIT_QUALIFICATION, exit_qualification),\n\tFIELD(GUEST_LINEAR_ADDRESS, guest_linear_address),\n\tFIELD(GUEST_CR0, guest_cr0),\n\tFIELD(GUEST_CR3, guest_cr3),\n\tFIELD(GUEST_CR4, guest_cr4),\n\tFIELD(GUEST_ES_BASE, guest_es_base),\n\tFIELD(GUEST_CS_BASE, guest_cs_base),\n\tFIELD(GUEST_SS_BASE, guest_ss_base),\n\tFIELD(GUEST_DS_BASE, guest_ds_base),\n\tFIELD(GUEST_FS_BASE, guest_fs_base),\n\tFIELD(GUEST_GS_BASE, guest_gs_base),\n\tFIELD(GUEST_LDTR_BASE, guest_ldtr_base),\n\tFIELD(GUEST_TR_BASE, guest_tr_base),\n\tFIELD(GUEST_GDTR_BASE, guest_gdtr_base),\n\tFIELD(GUEST_IDTR_BASE, guest_idtr_base),\n\tFIELD(GUEST_DR7, guest_dr7),\n\tFIELD(GUEST_RSP, guest_rsp),\n\tFIELD(GUEST_RIP, guest_rip),\n\tFIELD(GUEST_RFLAGS, guest_rflags),\n\tFIELD(GUEST_PENDING_DBG_EXCEPTIONS, guest_pending_dbg_exceptions),\n\tFIELD(GUEST_SYSENTER_ESP, guest_sysenter_esp),\n\tFIELD(GUEST_SYSENTER_EIP, guest_sysenter_eip),\n\tFIELD(HOST_CR0, host_cr0),\n\tFIELD(HOST_CR3, host_cr3),\n\tFIELD(HOST_CR4, host_cr4),\n\tFIELD(HOST_FS_BASE, host_fs_base),\n\tFIELD(HOST_GS_BASE, host_gs_base),\n\tFIELD(HOST_TR_BASE, host_tr_base),\n\tFIELD(HOST_GDTR_BASE, host_gdtr_base),\n\tFIELD(HOST_IDTR_BASE, host_idtr_base),\n\tFIELD(HOST_IA32_SYSENTER_ESP, host_ia32_sysenter_esp),\n\tFIELD(HOST_IA32_SYSENTER_EIP, host_ia32_sysenter_eip),\n\tFIELD(HOST_RSP, host_rsp),\n\tFIELD(HOST_RIP, host_rip),\n};\nstatic const int max_vmcs_field = ARRAY_SIZE(vmcs_field_to_offset_table);\n\nstatic inline short vmcs_field_to_offset(unsigned long field)\n{\n\tif (field >= max_vmcs_field || vmcs_field_to_offset_table[field] == 0)\n\t\treturn -1;\n\treturn vmcs_field_to_offset_table[field];\n}\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.current_vmcs12;\n}\n\nstatic struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)\n{\n\tstruct page *page = gfn_to_page(vcpu->kvm, addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}\n\nstatic void nested_release_page_clean(struct page *page)\n{\n\tkvm_release_page_clean(page);\n}\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic u64 construct_eptp(unsigned long root_hpa);\nstatic void kvm_cpu_vmxon(u64 addr);\nstatic void kvm_cpu_vmxoff(void);\nstatic bool vmx_mpx_supported(void);\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr);\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic void vmx_sync_pir_to_irr_dummy(struct kvm_vcpu *vcpu);\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx);\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx);\nstatic int alloc_identity_pagetable(struct kvm *kvm);\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nstatic DEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\nstatic DEFINE_PER_CPU(struct desc_ptr, host_gdt);\n\nstatic unsigned long *vmx_io_bitmap_a;\nstatic unsigned long *vmx_io_bitmap_b;\nstatic unsigned long *vmx_msr_bitmap_legacy;\nstatic unsigned long *vmx_msr_bitmap_longmode;\nstatic unsigned long *vmx_msr_bitmap_legacy_x2apic;\nstatic unsigned long *vmx_msr_bitmap_longmode_x2apic;\nstatic unsigned long *vmx_vmread_bitmap;\nstatic unsigned long *vmx_vmwrite_bitmap;\n\nstatic bool cpu_has_load_ia32_efer;\nstatic bool cpu_has_load_perf_global_ctrl;\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic struct vmx_capability {\n\tu32 ept;\n\tu32 vpid;\n} vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u64 host_efer;\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\n\n/*\n * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it\n * away by decrementing the array size.\n */\nstatic const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | PF_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_no_device(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | NM_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | UD_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_external_interrupt(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_EXT_INTR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}\n\nstatic inline bool vm_need_tpr_shadow(struct kvm *kvm)\n{\n\treturn (cpu_has_vmx_tpr_shadow()) && (irqchip_in_kernel(kvm));\n}\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_apic_accesses(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}\n\nstatic inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_virtual_intr_delivery(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY;\n}\n\nstatic inline bool cpu_has_vmx_posted_intr(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}\n\nstatic inline bool cpu_has_vmx_eptp_uncacheable(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_UC_BIT;\n}\n\nstatic inline bool cpu_has_vmx_eptp_writeback(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_EPT;\n}\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}\n\nstatic inline bool vm_need_virtualize_apic_accesses(struct kvm *kvm)\n{\n\treturn flexpriority_enabled && irqchip_in_kernel(kvm);\n}\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_shadow_vmcs(void)\n{\n\tu64 vmx_msr;\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t/* check if the cpu supports writing r/o exit information fields */\n\tif (!(vmx_msr & MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS))\n\t\treturn false;\n\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}\n\nstatic inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}\n\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification);\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification);\n\nstatic int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n\nstatic inline void __invept(int ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tasm volatile (__ex(ASM_VMX_INVEPT)\n\t\t\t/* CF==1 or ZF==1 --> rc = -1 */\n\t\t\t\"; ja 1f ; ud2 ; 1:\\n\"\n\t\t\t: : \"a\" (&operand), \"c\" (ext) : \"cc\", \"memory\");\n}\n\nstatic struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}\n\nstatic void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMCLEAR_RAX) \"; setna %0\"\n\t\t      : \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t      : \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmclear fail: %p/%llx\\n\",\n\t\t       vmcs, phys_addr);\n}\n\nstatic inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)\n{\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nstatic void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMPTRLD_RAX) \"; setna %0\"\n\t\t\t: \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t\t: \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmptrld %p/%llx failed\\n\",\n\t\t       vmcs, phys_addr);\n}\n\n#ifdef CONFIG_KEXEC\n/*\n * This bitmap is used to indicate whether the vmclear\n * operation is enabled on all cpus. All disabled by\n * default.\n */\nstatic cpumask_t crash_vmclear_enabled_bitmap = CPU_MASK_NONE;\n\nstatic inline void crash_enable_local_vmclear(int cpu)\n{\n\tcpumask_set_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline void crash_disable_local_vmclear(int cpu)\n{\n\tcpumask_clear_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline int crash_local_vmclear_enabled(int cpu)\n{\n\treturn cpumask_test_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tif (!crash_local_vmclear_enabled(cpu))\n\t\treturn;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#else\nstatic inline void crash_enable_local_vmclear(int cpu) { }\nstatic inline void crash_disable_local_vmclear(int cpu) { }\n#endif /* CONFIG_KEXEC */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\tcrash_disable_local_vmclear(cpu);\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * we should ensure updating loaded_vmcs->loaded_vmcss_on_cpu_link\n\t * is before setting loaded_vmcs->vcpu to -1 which is done in\n\t * loaded_vmcs_init. Otherwise, other cpu can see vcpu = -1 fist\n\t * then adds the vmcs into percpu list before it is deleted.\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs_init(loaded_vmcs);\n\tcrash_enable_local_vmclear(cpu);\n}\n\nstatic void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic inline void vpid_sync_vcpu_single(struct vcpu_vmx *vmx)\n{\n\tif (vmx->vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vmx->vpid, 0);\n}\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}\n\nstatic inline void vpid_sync_context(struct vcpu_vmx *vmx)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vmx);\n\telse\n\t\tvpid_sync_vcpu_global();\n}\n\nstatic inline void ept_sync_global(void)\n{\n\tif (cpu_has_vmx_invept_global())\n\t\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (enable_ept) {\n\t\tif (cpu_has_vmx_invept_context())\n\t\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\t\telse\n\t\t\tept_sync_global();\n\t}\n}\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, \"%0\")\n\t\t      : \"=a\"(value) : \"d\"(field) : \"cc\");\n\treturn value;\n}\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\treturn vmcs_readl(field);\n}\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\treturn vmcs_readl(field);\n}\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n#ifdef CONFIG_X86_64\n\treturn vmcs_readl(field);\n#else\n\treturn vmcs_readl(field) | ((u64)vmcs_readl(field+1) << 32);\n#endif\n}\n\nstatic noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tprintk(KERN_ERR \"vmwrite error: reg %lx value %lx (err %d)\\n\",\n\t       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n\tdump_stack();\n}\n\nstatic void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMWRITE_RAX_RDX) \"; setna %0\"\n\t\t       : \"=q\"(error) : \"a\"(value), \"d\"(field) : \"cc\");\n\tif (unlikely(error))\n\t\tvmwrite_error(field, value);\n}\n\nstatic void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_writel(field, value);\n}\n\nstatic void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_writel(field, value);\n}\n\nstatic void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\tasm volatile (\"\");\n\tvmcs_writel(field+1, value >> 32);\n#endif\n}\n\nstatic void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) & ~mask);\n}\n\nstatic void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) | mask);\n}\n\nstatic inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}\n\nstatic inline void vm_entry_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_entry_controls_shadow != val)\n\t\tvm_entry_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_entry_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_entry_controls_shadow;\n}\n\n\nstatic inline void vm_entry_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) | val);\n}\n\nstatic inline void vm_entry_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) & ~val);\n}\n\nstatic inline void vm_exit_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_EXIT_CONTROLS, val);\n\tvmx->vm_exit_controls_shadow = val;\n}\n\nstatic inline void vm_exit_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_exit_controls_shadow != val)\n\t\tvm_exit_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}\n\n\nstatic inline void vm_exit_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) | val);\n}\n\nstatic inline void vm_exit_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) & ~val);\n}\n\nstatic void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!(vmx->vcpu.arch.regs_avail & (1 << VCPU_EXREG_SEGMENTS))) {\n\t\tvmx->vcpu.arch.regs_avail |= (1 << VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nstatic void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); /* bypass_guest_pf = 0 */\n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == m->nr)\n\t\treturn;\n\t--m->nr;\n\tm->guest[i] = m->guest[m->nr];\n\tm->host[i] = m->host[m->nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == NR_AUTOLOAD_MSRS) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t} else if (i == m->nr) {\n\t\t++m->nr;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n\t}\n\n\tm->guest[i].index = msr;\n\tm->guest[i].value = guest_val;\n\tm->host[i].index = msr;\n\tm->host[i].value = host_val;\n}\n\nstatic void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer;\n\tu64 ignore_bits;\n\n\tguest_efer = vmx->vcpu.arch.efer;\n\n\t/*\n\t * NX is emulated; LMA and LME handled by hardware; SCE meaningless\n\t * outside long mode\n\t */\n\tignore_bits = EFER_NX | EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\tguest_efer &= ~ignore_bits;\n\tguest_efer |= host_efer & ignore_bits;\n\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t/* On ept, can't emulate nx, and must switch nx atomically */\n\tif (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX)) {\n\t\tguest_efer = vmx->vcpu.arch.efer;\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tadd_atomic_switch_msr(vmx, MSR_EFER, guest_efer, host_efer);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *d;\n\tunsigned long table_base;\n\tunsigned long v;\n\n\tif (!(selector & ~3))\n\t\treturn 0;\n\n\ttable_base = gdt->address;\n\n\tif (selector & 4) {           /* from ldt */\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~3))\n\t\t\treturn 0;\n\n\t\ttable_base = segment_base(ldt_selector);\n\t}\n\td = (struct desc_struct *)(table_base + (selector & ~7));\n\tv = get_desc_base(d);\n#ifdef CONFIG_X86_64\n       if (d->s == 0 && (d->type == 2 || d->type == 9 || d->type == 11))\n               v |= ((unsigned long)((struct ldttss_desc64 *)d)->base3) << 32;\n#endif\n\treturn v;\n}\n\nstatic inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n\nstatic void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (boot_cpu_has(X86_FEATURE_MPX))\n\t\trdmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n\nstatic void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu))\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(vmx->host_state.gs_sel);\n#else\n\t\tloadsegment(gs, vmx->host_state.gs_sel);\n#endif\n\t}\n\tif (vmx->host_state.fs_reload_needed)\n\t\tloadsegment(fs, vmx->host_state.fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(vmx->host_state.ds_sel | vmx->host_state.es_sel)) {\n\t\tloadsegment(ds, vmx->host_state.ds_sel);\n\t\tloadsegment(es, vmx->host_state.es_sel);\n\t}\n#endif\n\treload_tss();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tif (vmx->host_state.msr_host_bndcfgs)\n\t\twrmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\t/*\n\t * If the FPU is not active (through the host task or\n\t * the guest vcpu), then restore the cr0.TS bit.\n\t */\n\tif (!user_has_fpu() && !vmx->vcpu.guest_fpu_loaded)\n\t\tstts();\n\tload_gdt(this_cpu_ptr(&host_gdt));\n}\n\nstatic void vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\t__vmx_load_host_state(vmx);\n\tpreempt_enable();\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(phys_addr);\n\telse if (vmx->loaded_vmcs->cpu != cpu)\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t}\n\n\tif (vmx->loaded_vmcs->cpu != cpu) {\n\t\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tlocal_irq_disable();\n\t\tcrash_disable_local_vmclear(cpu);\n\n\t\t/*\n\t\t * Read loaded_vmcs->cpu should be before fetching\n\t\t * loaded_vmcs->loaded_vmcss_on_cpu_link.\n\t\t * See the comments in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tcrash_enable_local_vmclear(cpu);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE, kvm_read_tr_base()); /* 22.2.4 */\n\t\tvmcs_writel(HOST_GDTR_BASE, gdt->address);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\t__vmx_load_host_state(to_vmx(vcpu));\n\tif (!vmm_exclusive) {\n\t\t__loaded_vmcs_clear(to_vmx(vcpu)->loaded_vmcs);\n\t\tvcpu->cpu = -1;\n\t\tkvm_cpu_vmxoff();\n\t}\n}\n\nstatic void vmx_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tulong cr0;\n\n\tif (vcpu->fpu_active)\n\t\treturn;\n\tvcpu->fpu_active = 1;\n\tcr0 = vmcs_readl(GUEST_CR0);\n\tcr0 &= ~(X86_CR0_TS | X86_CR0_MP);\n\tcr0 |= kvm_read_cr0_bits(vcpu, X86_CR0_TS | X86_CR0_MP);\n\tvmcs_writel(GUEST_CR0, cr0);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.cr0_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\n\n/*\n * Return the cr0 value that a nested guest would read. This is a combination\n * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by\n * its hypervisor (cr0_read_shadow).\n */\nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n\nstatic void vmx_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\t/* Note that there is no vcpu->fpu_active = 0 here. The caller must\n\t * set this *before* calling this function.\n\t */\n\tvmx_decache_cr0_guest_bits(vcpu);\n\tvmcs_set_bits(GUEST_CR0, X86_CR0_TS | X86_CR0_MP);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = 0;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1's specified read shadow might not contain the TS bit,\n\t\t * so now that we turned on shadowing of this bit, we need to\n\t\t * set this bit of the shadow. Like in nested_vmx_run we need\n\t\t * nested_read_cr0(vmcs12), but vmcs12->guest_cr0 is not yet\n\t\t * up-to-date here because we just decached cr0.TS (and we'll\n\t\t * only update vmcs12->guest_cr0 on nested exit).\n\t\t */\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tvmcs12->guest_cr0 = (vmcs12->guest_cr0 & ~X86_CR0_TS) |\n\t\t\t(vcpu->arch.cr0 & X86_CR0_TS);\n\t\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\t} else\n\t\tvmcs_writel(CR0_READ_SHADOW, vcpu->arch.cr0);\n}\n\nstatic unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags, save_rflags;\n\n\tif (!test_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = to_vmx(vcpu)->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tto_vmx(vcpu)->rflags = rflags;\n\t}\n\treturn to_vmx(vcpu)->rflags;\n}\n\nstatic void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\tto_vmx(vcpu)->rflags = rflags;\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tto_vmx(vcpu)->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n}\n\nstatic u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nstatic void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}\n\n/*\n * KVM wants to inject page-faults which it got to the guest. This function\n * checks whether in a nested guest, we need to inject them to L1 or L2.\n */\nstatic int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (!(vmcs12->exception_bitmap & (1u << nr)))\n\t\treturn 0;\n\n\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}\n\nstatic bool vmx_invpcid_supported(void)\n{\n\treturn cpu_has_vmx_invpcid() && enable_ept;\n}\n\n/*\n * Swap MSR entry in host/guest MSR entry array.\n */\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}\n\nstatic void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (irqchip_in_kernel(vcpu->kvm) && apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n\n/*\n * Set up the vmcs to automatically save and restore system\n * msrs.  Don't touch the 64-bit msrs if the guest is in legacy\n * mode, as fiddling with msrs is very expensive.\n */\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && vmx->rdtscp_enabled)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\t/*\n\t\t * MSR_STAR is only needed on long mode guests, and only\n\t\t * if efer.sce is enabled.\n\t\t */\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}\n\n/*\n * reads and returns guest's timestamp counter \"register\"\n * guest_tsc = host_tsc + tsc_offset    -- 21.3\n */\nstatic u64 guest_read_tsc(void)\n{\n\tu64 host_tsc, tsc_offset;\n\n\trdtscll(host_tsc);\n\ttsc_offset = vmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}\n\n/*\n * Like guest_read_tsc, but always returns L1's notion of the timestamp\n * counter, even if a nested guest (L2) is currently running.\n */\nstatic u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}\n\n/*\n * Engage any workarounds for mis-matched TSC rates.  Currently limited to\n * software catchup for faster rates on slower CPUs.\n */\nstatic void vmx_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tif (!scale)\n\t\treturn;\n\n\tif (user_tsc_khz > tsc_khz) {\n\t\tvcpu->arch.tsc_catchup = 1;\n\t\tvcpu->arch.tsc_always_catchup = 1;\n\t} else\n\t\tWARN(1, \"user requested TSC rate below hardware speed\\n\");\n}\n\nstatic u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}\n\n/*\n * writes 'offset' into guest's timestamp counter offset register\n */\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t\t * to the spec, this should set L1's TSC; The offset that L1\n\t\t * set for L2 remains unchanged, and still needs to be added\n\t\t * to the newly set TSC to get L2's TSC.\n\t\t */\n\t\tstruct vmcs12 *vmcs12;\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset = offset;\n\t\t/* recalculate vmcs02.TSC_OFFSET: */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tvmcs_write64(TSC_OFFSET, offset +\n\t\t\t(nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETING) ?\n\t\t\t vmcs12->tsc_offset : 0));\n\t} else {\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   vmcs_read64(TSC_OFFSET), offset);\n\t\tvmcs_write64(TSC_OFFSET, offset);\n\t}\n}\n\nstatic void vmx_adjust_tsc_offset(struct kvm_vcpu *vcpu, s64 adjustment, bool host)\n{\n\tu64 offset = vmcs_read64(TSC_OFFSET);\n\n\tvmcs_write64(TSC_OFFSET, offset + adjustment);\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Even when running L2, the adjustment needs to apply to L1 */\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset += adjustment;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id, offset,\n\t\t\t\t\t   offset + adjustment);\n}\n\nstatic u64 vmx_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\treturn target_tsc - native_read_tsc();\n}\n\nstatic bool guest_cpuid_has_vmx(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & (1 << (X86_FEATURE_VMX & 31)));\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nstatic inline bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has_vmx(vcpu);\n}\n\n/*\n * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be\n * returned for the various VMX controls MSRs when nested VMX is enabled.\n * The same values should also be used to verify that vmcs12 control fields are\n * valid during nested entry from L1 to L2.\n * Each of these control msrs has a low and high 32-bit half: A low bit is on\n * if the corresponding bit in the (32-bit) control field *must* be on, and a\n * bit in the high half is on if the corresponding bit in the control field\n * may be on. See also vmx_control_verify().\n * TODO: allow these variables to be modified (downgraded) by module options\n * or other means.\n */\nstatic u32 nested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high;\nstatic u32 nested_vmx_true_procbased_ctls_low;\nstatic u32 nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high;\nstatic u32 nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high;\nstatic u32 nested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high;\nstatic u32 nested_vmx_true_exit_ctls_low;\nstatic u32 nested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high;\nstatic u32 nested_vmx_true_entry_ctls_low;\nstatic u32 nested_vmx_misc_low, nested_vmx_misc_high;\nstatic u32 nested_vmx_ept_caps;\nstatic __init void nested_vmx_setup_ctls_msrs(void)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high);\n\tnested_vmx_pinbased_ctls_low |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_pinbased_ctls_high &= PIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING | PIN_BASED_VIRTUAL_NMIS;\n\tnested_vmx_pinbased_ctls_high |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/* exit controls */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tnested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high);\n\tnested_vmx_exit_ctls_low = VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\n\tnested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tnested_vmx_exit_ctls_high |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER | VM_EXIT_ACK_INTR_ON_EXIT;\n\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* We support free control of debug control saving. */\n\tnested_vmx_true_exit_ctls_low = nested_vmx_exit_ctls_low &\n\t\t~VM_EXIT_SAVE_DEBUG_CONTROLS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tnested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high);\n\tnested_vmx_entry_ctls_low = VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tnested_vmx_entry_ctls_high |= (VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\t\t\t       VM_ENTRY_LOAD_IA32_EFER);\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* We support free control of debug control loading. */\n\tnested_vmx_true_entry_ctls_low = nested_vmx_entry_ctls_low &\n\t\t~VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tnested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high);\n\tnested_vmx_procbased_ctls_low = CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_EXITING |\n\t\tCPU_BASED_RDPMC_EXITING | CPU_BASED_RDTSC_EXITING |\n\t\tCPU_BASED_PAUSE_EXITING | CPU_BASED_TPR_SHADOW |\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tnested_vmx_procbased_ctls_high |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tCPU_BASED_USE_MSR_BITMAPS;\n\n\t/* We support free control of CR3 access interception. */\n\tnested_vmx_true_procbased_ctls_low = nested_vmx_procbased_ctls_low &\n\t\t~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tnested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);\n\tnested_vmx_secondary_ctls_low = 0;\n\tnested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tnested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;\n\t\tnested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tnested_vmx_ept_caps &= vmx_capability.ept;\n\t\t/*\n\t\t * For nested guests, we don't do anything specific\n\t\t * for single context invalidation. Hence, only advertise\n\t\t * support for global context invalidation.\n\t\t */\n\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;\n\t} else\n\t\tnested_vmx_ept_caps = 0;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);\n\tnested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tnested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tnested_vmx_misc_high = 0;\n}\n\nstatic inline bool vmx_control_verify(u32 control, u32 low, u32 high)\n{\n\t/*\n\t * Bits 0 in high must be 0, and bits 1 in low must be 1.\n\t */\n\treturn ((control & high) | low) == control;\n}\n\nstatic inline u64 vmx_control_msr(u32 low, u32 high)\n{\n\treturn low | ((u64)high << 32);\n}\n\n/* Returns 0 on success, non-0 otherwise. */\nstatic int vmx_get_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t/*\n\t\t * This MSR reports some information about VMX support. We\n\t\t * should return information about the VMX we emulate for the\n\t\t * guest, and the VMCS structure we give it - not about the\n\t\t * VMX support of the underlying hardware.\n\t\t */\n\t\t*pdata = VMCS12_REVISION | VMX_BASIC_TRUE_CTLS |\n\t\t\t   ((u64)VMCS12_SIZE << VMX_BASIC_VMCS_SIZE_SHIFT) |\n\t\t\t   (VMX_BASIC_MEM_TYPE_WB << VMX_BASIC_MEM_TYPE_SHIFT);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_pinbased_ctls_low,\n\t\t\t\t\tnested_vmx_pinbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_procbased_ctls_low,\n\t\t\t\t\tnested_vmx_procbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_procbased_ctls_low,\n\t\t\t\t\tnested_vmx_procbased_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_exit_ctls_low,\n\t\t\t\t\tnested_vmx_exit_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_exit_ctls_low,\n\t\t\t\t\tnested_vmx_exit_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_true_entry_ctls_low,\n\t\t\t\t\tnested_vmx_entry_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(nested_vmx_entry_ctls_low,\n\t\t\t\t\tnested_vmx_entry_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(nested_vmx_misc_low,\n\t\t\t\t\t nested_vmx_misc_high);\n\t\tbreak;\n\t/*\n\t * These MSRs specify bits which the guest must keep fixed (on or off)\n\t * while L1 is in VMXON mode (in L1's root mode, or running an L2).\n\t * We picked the standard core2 setting.\n\t */\n#define VMXON_CR0_ALWAYSON\t(X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)\n#define VMXON_CR4_ALWAYSON\tX86_CR4_VMXE\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = VMXON_CR0_ALWAYSON;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = -1ULL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = VMXON_CR4_ALWAYSON;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = -1ULL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = 0x2e; /* highest index: VMX_PREEMPTION_TIMER_VALUE */\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(nested_vmx_secondary_ctls_low,\n\t\t\t\t\tnested_vmx_secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t/* Currently, no nested vpid support */\n\t\t*pdata = nested_vmx_ept_caps;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tu64 data;\n\tstruct shared_msr_entry *msr;\n\n\tif (!pdata) {\n\t\tprintk(KERN_ERR \"BUG: get_msr called with NULL pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tdata = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tdata = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(to_vmx(vcpu));\n\t\tdata = to_vmx(vcpu)->msr_guest_kernel_gs_base;\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_index, pdata);\n\tcase MSR_IA32_TSC:\n\t\tdata = guest_read_tsc();\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tdata = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tdata = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tdata = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!vmx_mpx_supported())\n\t\t\treturn 1;\n\t\tdata = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tdata = to_vmx(vcpu)->nested.msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(vcpu, msr_index, pdata);\n\tcase MSR_TSC_AUX:\n\t\tif (!to_vmx(vcpu)->rdtscp_enabled)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(to_vmx(vcpu), msr_index);\n\t\tif (msr) {\n\t\t\tdata = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_index, pdata);\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(vmx);\n\t\tvmx->msr_guest_kernel_gs_base = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!vmx_mpx_supported())\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\t\treturn 1;\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!nested_vmx_allowed(vcpu) ||\n\t\t    (to_vmx(vcpu)->nested.msr_ia32_feature_control &\n\t\t     FEATURE_CONTROL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->nested.msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn 1; /* they are read-only */\n\tcase MSR_TSC_AUX:\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\t\t\tpreempt_disable();\n\t\t\t\tkvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t\t   msr->mask);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\tu64 msr;\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, msr);\n\tif (msr & FEATURE_CONTROL_LOCKED) {\n\t\t/* launched w/ TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& tboot_enabled())\n\t\t\treturn 1;\n\t\t/* launched w/o TXT and VMX only enabled w/ TXT */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& !tboot_enabled()) {\n\t\t\tprintk(KERN_WARNING \"kvm: disable TXT in the BIOS or \"\n\t\t\t\t\"activate TXT before enabling KVM\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* launched w/o TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& !tboot_enabled())\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void kvm_cpu_vmxon(u64 addr)\n{\n\tasm volatile (ASM_VMX_VMXON_RAX\n\t\t\t: : \"a\"(&addr), \"m\"(addr)\n\t\t\t: \"memory\", \"cc\");\n}\n\nstatic int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\n\t/*\n\t * Now we can enable the vmclear operation in kdump\n\t * since the loaded_vmcss_on_cpu list on this cpu\n\t * has been initialized.\n\t *\n\t * Though the cpu is not in VMX operation now, there\n\t * is no problem to enable the vmclear operation\n\t * for the loaded_vmcss_on_cpu list is empty!\n\t */\n\tcrash_enable_local_vmclear(cpu);\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); /* FIXME: not cpu hotplug safe */\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\n\n/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()\n * tricks.\n */\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(ASM_VMX_VMXOFF) : : : \"cc\");\n}\n\nstatic void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\twrite_cr4(read_cr4() & ~X86_CR4_VMXE);\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init bool allow_1_setting(u32 msr, u32 ctl)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\treturn vmx_msr_high & ctl;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_USE_IO_BITMAPS |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t\trdmsr(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t      vmx_capability.ept, vmx_capability.vpid);\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_SAVE_IA32_PAT | VM_EXIT_LOAD_IA32_PAT |\n\t\tVM_EXIT_ACK_INTR_ON_EXIT | VM_EXIT_CLEAR_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) ||\n\t\t!(_vmexit_control & VM_EXIT_ACK_INTR_ON_EXIT))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->order = get_order(vmcs_config.size);\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n\tcpu_has_load_ia32_efer =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_EFER)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_EFER);\n\n\tcpu_has_load_perf_global_ctrl =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\n\t/*\n\t * Some cpus support VM_ENTRY_(LOAD|SAVE)_IA32_PERF_GLOBAL_CTRL\n\t * but due to arrata below it can't be used. Workaround is to use\n\t * msr load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t *\n\t * VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]\n\t *\n\t * AAK155             (model 26)\n\t * AAP115             (model 30)\n\t * AAT100             (model 37)\n\t * BC86,AAY89,BD102   (model 44)\n\t * BA97               (model 46)\n\t *\n\t */\n\tif (cpu_has_load_perf_global_ctrl && boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26:\n\t\tcase 30:\n\t\tcase 37:\n\t\tcase 44:\n\t\tcase 46:\n\t\t\tcpu_has_load_perf_global_ctrl = false;\n\t\t\tprintk_once(KERN_WARNING\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct vmcs *alloc_vmcs_cpu(int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = alloc_pages_exact_node(node, GFP_KERNEL, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\tvmcs->revision_id = vmcs_config.revision_id; /* vmcs revision id */\n\treturn vmcs;\n}\n\nstatic struct vmcs *alloc_vmcs(void)\n{\n\treturn alloc_vmcs_cpu(raw_smp_processor_id());\n}\n\nstatic void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nstatic void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\n\t/* No checks for read only fields yet */\n\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!vmx_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\n\t/* shadowed fields guest access without vmexit */\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(cpu);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic __init int hardware_setup(void)\n{\n\tif (setup_vmcs_config(&vmcs_config) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority()) {\n\t\tflexpriority_enabled = 0;\n\n\t\t/*\n\t\t * set_apic_access_page_addr() is used to reload apic access\n\t\t * page upon invalidation.  No need to do anything if the\n\t\t * processor does not have the APIC_ACCESS_ADDR VMCS field.\n\t\t */\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\t}\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (enable_apicv)\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\telse {\n\t\tkvm_x86_ops->hwapic_irr_update = NULL;\n\t\tkvm_x86_ops->deliver_posted_interrupt = NULL;\n\t\tkvm_x86_ops->sync_pir_to_irr = vmx_sync_pir_to_irr_dummy;\n\t}\n\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs();\n\n\treturn alloc_kvm_area();\n}\n\nstatic __exit void hardware_unsetup(void)\n{\n\tfree_kvm_area();\n}\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SELECTOR_RPL_MASK;\n\t\tsave->dpl = save->selector & SELECTOR_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_write32(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!vcpu->kvm->arch.tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, vcpu->kvm->arch.tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\t/*\n\t * Force kernel_gs_base reloading before EFER changes, as control\n\t * of this msr depends on is_long_mode().\n\t */\n\tvmx_load_host_state(to_vmx(vcpu));\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & AR_TYPE_MASK) != AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~AR_TYPE_MASK)\n\t\t\t     | AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic void vmx_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tvpid_sync_context(to_vmx(vcpu));\n\tif (enable_ept) {\n\t\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\t\treturn;\n\t\tept_sync_context(construct_eptp(vcpu->arch.mmu.root_hpa));\n\t}\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}\n\nstatic void vmx_decache_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (enable_ept && is_paging(vcpu))\n\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n}\n\nstatic void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_dirty))\n\t\treturn;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tvmx_decache_cr3(vcpu);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) |\n\t\t\t     (CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t      CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) &\n\t\t\t     ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t       CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}\n\nstatic void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_GUEST_CR0_MASK);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tif (!vcpu->fpu_active)\n\t\thw_cr0 |= X86_CR0_TS | X86_CR0_MP;\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic u64 construct_eptp(unsigned long root_hpa)\n{\n\tu64 eptp;\n\n\t/* TODO write the value reading from MSR */\n\teptp = VMX_EPT_DEFAULT_MT |\n\t\tVMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT;\n\tif (enable_ept_ad_bits)\n\t\teptp |= VMX_EPT_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}\n\nstatic void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (is_paging(vcpu) || is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = vcpu->kvm->arch.ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long hw_cr4 = cr4 | (to_vmx(vcpu)->rmode.vm86_active ?\n\t\t    KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t}\n\tif (to_vmx(vcpu)->nested.vmxon &&\n\t    ((cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\tif (enable_ept) {\n\t\tif (!is_paging(vcpu)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t/*\n\t\t\t * SMEP/SMAP is disabled if CPU is in non-paging mode\n\t\t\t * in hardware. However KVM always uses paging mode to\n\t\t\t * emulate guest non-paging mode with TDP.\n\t\t\t * To emulate this behavior, SMEP/SMAP needs to be\n\t\t\t * manually disabled when guest switches to non-paging\n\t\t\t * mode.\n\t\t\t */\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP);\n\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t}\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}\n\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nstatic int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SELECTOR_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (AR_TYPE_CODE_MASK|AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SELECTOR_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SELECTOR_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (AR_TYPE_CODE_MASK|AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SELECTOR_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SELECTOR_RPL_MASK) ==\n\t\t (ss.selector & SELECTOR_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = kvm->arch.tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tint i, idx, r = 0;\n\tpfn_t identity_map_pfn;\n\tu32 tmp;\n\n\tif (!enable_ept)\n\t\treturn 0;\n\n\t/* Protect kvm->arch.ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm->arch.ept_identity_pagetable_done))\n\t\tgoto out2;\n\n\tidentity_map_pfn = kvm->arch.ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = alloc_identity_pagetable(kvm);\n\tif (r < 0)\n\t\tgoto out2;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm->arch.ept_identity_pagetable_done = true;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\nout2:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tkvm_userspace_mem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\tkvm_userspace_mem.flags = 0;\n\tkvm_userspace_mem.guest_phys_addr = APIC_DEFAULT_PHYS_BASE;\n\tkvm_userspace_mem.memory_size = PAGE_SIZE;\n\tr = __kvm_set_memory_region(kvm, &kvm_userspace_mem);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic int alloc_identity_pagetable(struct kvm *kvm)\n{\n\t/* Called with kvm->slots_lock held. */\n\n\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\tint r = 0;\n\n\tBUG_ON(kvm->arch.ept_identity_pagetable_done);\n\n\tkvm_userspace_mem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\tkvm_userspace_mem.flags = 0;\n\tkvm_userspace_mem.guest_phys_addr =\n\t\tkvm->arch.ept_identity_map_addr;\n\tkvm_userspace_mem.memory_size = PAGE_SIZE;\n\tr = __kvm_set_memory_region(kvm, &kvm_userspace_mem);\n\n\treturn r;\n}\n\nstatic void allocate_vpid(struct vcpu_vmx *vmx)\n{\n\tint vpid;\n\n\tvmx->vpid = 0;\n\tif (!enable_vpid)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS) {\n\t\tvmx->vpid = vpid;\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\t}\n\tspin_unlock(&vmx_vpid_lock);\n}\n\nstatic void free_vpid(struct vcpu_vmx *vmx)\n{\n\tif (!enable_vpid)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\tif (vmx->vpid != 0)\n\t\t__clear_bit(vmx->vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\n#define MSR_TYPE_R\t1\n#define MSR_TYPE_W\t2\nstatic void __vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\nstatic void __vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\nstatic void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)\n{\n\tif (!longmode_only)\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n}\n\nstatic void vmx_enable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}\n\nstatic void vmx_disable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}\n\nstatic void vmx_disable_intercept_msr_write_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_W);\n}\n\nstatic int vmx_vm_has_apicv(struct kvm *kvm)\n{\n\treturn enable_apicv && irqchip_in_kernel(kvm);\n}\n\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn;\n\n\tr = pi_test_and_set_on(&vmx->pi_desc);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n#ifdef CONFIG_SMP\n\tif (!r && (vcpu->mode == IN_GUEST_MODE))\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu),\n\t\t\t\tPOSTED_INTR_VECTOR);\n\telse\n#endif\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!pi_test_and_clear_on(&vmx->pi_desc))\n\t\treturn;\n\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}\n\nstatic void vmx_sync_pir_to_irr_dummy(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nstatic void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}\n\nstatic void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!vmx_vm_has_apicv(vmx->vcpu.kvm))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\treturn pin_based_exec_ctrl;\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!vm_need_tpr_shadow(vmx->vcpu.kvm)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\treturn exec_control;\n}\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\tif (!vm_need_virtualize_apic_accesses(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t\t/* Enable INVPCID for non-ept guests may cause performance regression. */\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (!ple_gap)\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!vmx_vm_has_apicv(vmx->vcpu.kvm))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\treturn exec_control;\n}\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n\n/*\n * Sets up the vmcs for emulated real mode.\n */\nstatic int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (vmx_vm_has_apicv(vmx->vcpu.kvm)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write64(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tu32 msr_low, msr_high;\n\t\tu64 host_pat;\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\t/* Write the default value follow host pat */\n\t\tvmcs_write64(GUEST_IA32_PAT, host_pat);\n\t\t/* Keep arch.pat sync with GUEST_IA32_PAT */\n\t\tvmx->vcpu.arch.pat = host_pat;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\treturn 0;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx->soft_vnmi_blocked = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tkvm_set_cr8(&vmx->vcpu, 0);\n\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE;\n\tif (kvm_vcpu_is_bsp(&vmx->vcpu))\n\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(&vmx->vcpu, &apic_base_msr);\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_write32(GUEST_CS_BASE, 0xffff0000);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\n\tvmcs_writel(GUEST_RFLAGS, 0x02);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_write32(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\n\t/* Special registers */\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow()) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (vm_need_tpr_shadow(vmx->vcpu.kvm))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vmx->vcpu.arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_vcpu_reload_apic_access_page(vcpu);\n\n\tif (vmx_vm_has_apicv(vcpu->kvm))\n\t\tmemset(&vmx->pi_desc, 0, sizeof(struct pi_desc));\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tvmx->vcpu.arch.cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx_set_cr0(&vmx->vcpu, kvm_read_cr0(vcpu)); /* enter rmode */\n\tvmx_set_cr4(&vmx->vcpu, 0);\n\tvmx_set_efer(&vmx->vcpu, 0);\n\tvmx_fpu_activate(&vmx->vcpu);\n\tupdate_exception_bitmap(&vmx->vcpu);\n\n\tvpid_sync_context(vmx);\n}\n\n/*\n * In nested virtualization, check if L1 asked to exit on external interrupts.\n * For most existing hypervisors, this will always return true.\n */\nstatic bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}\n\n/*\n * In nested virtualization, check if L1 has set\n * VM_EXIT_ACK_INTR_ON_EXIT\n */\nstatic bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->vm_exit_controls &\n\t\tVM_EXIT_ACK_INTR_ON_EXIT;\n}\n\nstatic bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn;\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->soft_vnmi_blocked = 1;\n\t\tvmx->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->nmi_known_unmasked = false;\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n\nstatic bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tif (!cpu_has_virtual_nmis())\n\t\treturn to_vmx(vcpu)->soft_vnmi_blocked;\n\tif (to_vmx(vcpu)->nmi_known_unmasked)\n\t\treturn false;\n\treturn vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\t& GUEST_INTR_STATE_NMI;\n}\n\nstatic void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\tif (vmx->soft_vnmi_blocked != masked) {\n\t\t\tvmx->soft_vnmi_blocked = masked;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\tstruct kvm_userspace_memory_region tss_mem = {\n\t\t.slot = TSS_PRIVATE_MEMSLOT,\n\t\t.guest_phys_addr = addr,\n\t\t.memory_size = PAGE_SIZE * 3,\n\t\t.flags = 0,\n\t};\n\n\tret = kvm_set_memory_region(kvm, &tss_mem);\n\tif (ret)\n\t\treturn ret;\n\tkvm->arch.tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\tbreak;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (emulate_instruction(vcpu, 0) == EMULATE_DONE) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_emulate_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\n/*\n * Trigger machine check on the host. We assume all the MSRs are already set up\n * by the CPU and that we still run on the same CPU as the MCE occurred on.\n * We pass a fake environment to the machine check handler because we want\n * the guest to be always treated like user space, no matter what context\n * it used internally.\n */\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* already handled by vcpu_run */\n\treturn 1;\n}\n\nstatic int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\tin = (exit_qualification & 8) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tskip_emulated_instruction(vcpu);\n\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\nstatic bool nested_cr0_valid(struct vmcs12 *vmcs12, unsigned long val)\n{\n\tunsigned long always_on = VMXON_CR0_ALWAYSON;\n\n\tif (nested_vmx_secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\talways_on &= ~(X86_CR0_PE | X86_CR0_PG);\n\treturn (val & always_on) == always_on;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_cr0_valid(vmcs12, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    ((val & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON))\n\t\t\treturn 1;\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\n/* called to set cr0 as approriate for clts instruction exit. */\nstatic void handle_clts(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We get here when L2 did CLTS, and L1 didn't shadow CR0.TS\n\t\t * but we did (!fpu_active). We need to keep GUEST_CR0.TS on,\n\t\t * just pretend it's off (also in arch.cr0 for fpu_activate).\n\t\t */\n\t\tvmcs_writel(CR0_READ_SHADOW,\n\t\t\tvmcs_readl(CR0_READ_SHADOW) & ~X86_CR0_TS);\n\t\tvcpu->arch.cr0 &= ~X86_CR0_TS;\n\t} else\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\treturn 1;\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tkvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (irqchip_in_kernel(vcpu->kvm))\n\t\t\t\t\treturn 1;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn 1;\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\thandle_clts(vcpu);\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\tskip_emulated_instruction(vcpu);\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, reg;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr = vmcs_readl(GUEST_DR7);\n\tif (dr & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr;\n\t\t\tvcpu->run->debug.arch.pc =\n\t\t\t\tvmcs_readl(GUEST_CS_BASE) +\n\t\t\t\tvmcs_readl(GUEST_RIP);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tvmcs_writel(GUEST_DR7, vcpu->arch.dr7);\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\tu32 cpu_based_vm_exec_control;\n\n\t\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\t\tcpu_based_vm_exec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}\n\nstatic void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_MOV_DR_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_cpuid(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_cpuid(vcpu);\n\treturn 1;\n}\n\nstatic int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, data);\n\n\t/* FIXME: handling of bits 32:63 of rax, rdx */\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (kvm_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending irq */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\n\t/*\n\t * If the user space waits to inject interrupts, exit as soon as\n\t * possible\n\t */\n\tif (!irqchip_in_kernel(vcpu->kvm) &&\n\t    vcpu->run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_halt(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\treturn kvm_emulate_halt(vcpu);\n}\n\nstatic int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_hypercall(vcpu);\n\treturn 1;\n}\n\nstatic int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\tkvm_complete_insn_gp(vcpu, err);\n\n\treturn 1;\n}\n\nstatic int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_wbinvd(vcpu);\n\treturn 1;\n}\n\nstatic int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tskip_emulated_instruction(vcpu);\n\n\tif (kvm_task_switch(vcpu, tss_selector,\n\t\t\t    type == INTR_TYPE_SOFT_INTR ? idt_index : -1, reason,\n\t\t\t    has_error_code, error_code) == EMULATE_FAIL) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\t/* clear all local breakpoint enable flags */\n\tvmcs_writel(GUEST_DR7, vmcs_readl(GUEST_DR7) & ~0x55);\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\n\treturn 1;\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu32 error_code;\n\tint gla_validity;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tgla_validity = (exit_qualification >> 7) & 0x3;\n\tif (gla_validity != 0x3 && gla_validity != 0x1 && gla_validity != 0) {\n\t\tprintk(KERN_ERR \"EPT: Handling EPT violation failed!\\n\");\n\t\tprintk(KERN_ERR \"EPT: GPA: 0x%lx, GVA: 0x%lx\\n\",\n\t\t\t(long unsigned int)vmcs_read64(GUEST_PHYSICAL_ADDRESS),\n\t\t\tvmcs_readl(GUEST_LINEAR_ADDRESS));\n\t\tprintk(KERN_ERR \"EPT: Exit qualification is 0x%lx\\n\",\n\t\t\t(long unsigned int)exit_qualification);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_VIOLATION;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* It is a write fault? */\n\terror_code = exit_qualification & (1U << 1);\n\t/* It is a fetch fault? */\n\terror_code |= (exit_qualification & (1U << 2)) << 2;\n\t/* ept page table is present? */\n\terror_code |= (exit_qualification >> 3) & 0x1;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic u64 ept_rsvd_mask(u64 spte, int level)\n{\n\tint i;\n\tu64 mask = 0;\n\n\tfor (i = 51; i > boot_cpu_data.x86_phys_bits; i--)\n\t\tmask |= (1ULL << i);\n\n\tif (level == 4)\n\t\t/* bits 7:3 reserved */\n\t\tmask |= 0xf8;\n\telse if (spte & (1ULL << 7))\n\t\t/*\n\t\t * 1GB/2MB page, bits 29:12 or 20:12 reserved respectively,\n\t\t * level == 1 if the hypervisor is using the ignored bit 7.\n\t\t */\n\t\tmask |= (PAGE_SIZE << ((level - 1) * 9)) - PAGE_SIZE;\n\telse if (level > 1)\n\t\t/* bits 6:3 reserved */\n\t\tmask |= 0x78;\n\n\treturn mask;\n}\n\nstatic void ept_misconfig_inspect_spte(struct kvm_vcpu *vcpu, u64 spte,\n\t\t\t\t       int level)\n{\n\tprintk(KERN_ERR \"%s: spte 0x%llx level %d\\n\", __func__, spte, level);\n\n\t/* 010b (write-only) */\n\tWARN_ON((spte & 0x7) == 0x2);\n\n\t/* 110b (write/execute) */\n\tWARN_ON((spte & 0x7) == 0x6);\n\n\t/* 100b (execute-only) and value not supported by logical processor */\n\tif (!cpu_has_vmx_ept_execute_only())\n\t\tWARN_ON((spte & 0x7) == 0x4);\n\n\t/* not 000b */\n\tif ((spte & 0x7)) {\n\t\tu64 rsvd_bits = spte & ept_rsvd_mask(spte, level);\n\n\t\tif (rsvd_bits != 0) {\n\t\t\tprintk(KERN_ERR \"%s: rsvd_bits = 0x%llx\\n\",\n\t\t\t\t\t __func__, rsvd_bits);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/* bits 5:3 are _not_ reserved for large page or leaf page */\n\t\tif ((rsvd_bits & 0x38) == 0) {\n\t\t\tu64 ept_mem_type = (spte & 0x38) >> 3;\n\n\t\t\tif (ept_mem_type == 2 || ept_mem_type == 3 ||\n\t\t\t    ept_mem_type == 7) {\n\t\t\t\tprintk(KERN_ERR \"%s: ept_mem_type=0x%llx\\n\",\n\t\t\t\t\t\t__func__, ept_mem_type);\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tu64 sptes[4];\n\tint nr_sptes, i, ret;\n\tgpa_t gpa;\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!kvm_io_bus_write(vcpu->kvm, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tret = handle_mmio_page_fault_common(vcpu, gpa, true);\n\tif (likely(ret == RET_MMIO_PF_EMULATE))\n\t\treturn x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==\n\t\t\t\t\t      EMULATE_DONE;\n\n\tif (unlikely(ret == RET_MMIO_PF_INVALID))\n\t\treturn kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);\n\n\tif (unlikely(ret == RET_MMIO_PF_RETRY))\n\t\treturn 1;\n\n\t/* It is the real ept misconfig */\n\tprintk(KERN_ERR \"EPT: Misconfiguration.\\n\");\n\tprintk(KERN_ERR \"EPT: GPA: 0x%llx\\n\", gpa);\n\n\tnr_sptes = kvm_mmu_get_spte_hierarchy(vcpu, gpa, sptes);\n\n\tfor (i = PT64_ROOT_LEVEL; i > PT64_ROOT_LEVEL - nr_sptes; --i)\n\t\tept_misconfig_inspect_spte(vcpu, sptes[i-1], i);\n\n\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_MISCONFIG;\n\n\treturn 0;\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending NMI */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tenum emulation_result err = EMULATE_DONE;\n\tint ret = 1;\n\tu32 cpu_exec_ctrl;\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tcpu_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tintr_window_requested = cpu_exec_ctrl & CPU_BASED_VIRTUAL_INTR_PENDING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (test_bit(KVM_REQ_EVENT, &vcpu->requests))\n\t\t\treturn 1;\n\n\t\terr = emulate_instruction(vcpu, EMULTYPE_NO_REEXECUTE);\n\n\t\tif (err == EMULATE_USER_EXIT) {\n\t\t\t++vcpu->stat.mmio_exits;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (err != EMULATE_DONE) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\tret = kvm_emulate_halt(vcpu);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __grow_ple_window(int val)\n{\n\tif (ple_window_grow < 1)\n\t\treturn ple_window;\n\n\tval = min(val, ple_window_actual_max);\n\n\tif (ple_window_grow < ple_window)\n\t\tval *= ple_window_grow;\n\telse\n\t\tval += ple_window_grow;\n\n\treturn val;\n}\n\nstatic int __shrink_ple_window(int val, int modifier, int minimum)\n{\n\tif (modifier < 1)\n\t\treturn ple_window;\n\n\tif (modifier < ple_window)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, minimum);\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old,\n\t                                      ple_window_shrink, ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\n/*\n * ple_window_actual_max is computed to be one grow_ple_window() below\n * ple_window_max. (See __grow_ple_window for the reason.)\n * This prevents overflows, because ple_window_max is int.\n * ple_window_max effectively rounded down to a multiple of ple_window_grow in\n * this process.\n * ple_window_max is also prevented from setting vmx->ple_window < ple_window.\n */\nstatic void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\n\tskip_emulated_instruction(vcpu);\n\tkvm_vcpu_on_spin(vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\nstatic int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\n/*\n * To run an L2 guest, we need a vmcs02 based on the L1-specified vmcs12.\n * We could reuse a single VMCS for all the L2 guests, but we also want the\n * option to allocate a separate vmcs02 for each separate loaded vmcs12 - this\n * allows keeping them loaded on the processor, and in the future will allow\n * optimizations where prepare_vmcs02 doesn't need to set all the fields on\n * every entry if they never change.\n * So we keep, in vmx->nested.vmcs02_pool, a cache of size VMCS02_POOL_SIZE\n * (>=0) with a vmcs02 for each recently loaded vmcs12s, most recent first.\n *\n * The following functions allocate and free a vmcs02 in this pool.\n */\n\n/* Get a VMCS from the pool to use as vmcs02 for the current vmcs12. */\nstatic struct loaded_vmcs *nested_get_current_vmcs02(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmx->nested.current_vmptr) {\n\t\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\t\treturn &item->vmcs02;\n\t\t}\n\n\tif (vmx->nested.vmcs02_num >= max(VMCS02_POOL_SIZE, 1)) {\n\t\t/* Recycle the least recently used VMCS. */\n\t\titem = list_entry(vmx->nested.vmcs02_pool.prev,\n\t\t\tstruct vmcs02_list, list);\n\t\titem->vmptr = vmx->nested.current_vmptr;\n\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\treturn &item->vmcs02;\n\t}\n\n\t/* Create a new VMCS */\n\titem = kmalloc(sizeof(struct vmcs02_list), GFP_KERNEL);\n\tif (!item)\n\t\treturn NULL;\n\titem->vmcs02.vmcs = alloc_vmcs();\n\tif (!item->vmcs02.vmcs) {\n\t\tkfree(item);\n\t\treturn NULL;\n\t}\n\tloaded_vmcs_init(&item->vmcs02);\n\titem->vmptr = vmx->nested.current_vmptr;\n\tlist_add(&(item->list), &(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num++;\n\treturn &item->vmcs02;\n}\n\n/* Free and remove from pool a vmcs02 saved for a vmcs12 (if there is one) */\nstatic void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmptr) {\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t\tvmx->nested.vmcs02_num--;\n\t\t\treturn;\n\t\t}\n}\n\n/*\n * Free all VMCSs saved for this vcpu, except the one pointed by\n * vmx->loaded_vmcs. We must be running L1, so vmx->loaded_vmcs\n * must be &vmx->vmcs01.\n */\nstatic void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\n\tWARN_ON(vmx->loaded_vmcs != &vmx->vmcs01);\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\t/*\n\t\t * Something will leak if the above WARN triggers.  Better than\n\t\t * a use-after-free.\n\t\t */\n\t\tif (vmx->loaded_vmcs == &item->vmcs02)\n\t\t\tcontinue;\n\n\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t\tvmx->nested.vmcs02_num--;\n\t}\n}\n\n/*\n * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),\n * set the success or error code of an emulated VMX instruction, as specified\n * by Vol 2B, VMX Instruction Reference, \"Conventions\".\n */\nstatic void nested_vmx_succeed(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));\n}\n\nstatic void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}\n\nstatic void nested_vmx_failValid(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu32 vm_instruction_error)\n{\n\tif (to_vmx(vcpu)->nested.current_vmptr == -1ull) {\n\t\t/*\n\t\t * failValid writes the error number to the current VMCS, which\n\t\t * can't be done there isn't a current VMCS.\n\t\t */\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn;\n\t}\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_ZF);\n\tget_vmcs12(vcpu)->vm_instruction_error = vm_instruction_error;\n\t/*\n\t * We don't need to force a shadow sync because\n\t * VM_INSTRUCTION_ERROR is not shadowed\n\t */\n}\n\nstatic enum hrtimer_restart vmx_preemption_timer_fn(struct hrtimer *timer)\n{\n\tstruct vcpu_vmx *vmx =\n\t\tcontainer_of(timer, struct vcpu_vmx, nested.preemption_timer);\n\n\tvmx->nested.preemption_timer_expired = true;\n\tkvm_make_request(KVM_REQ_EVENT, &vmx->vcpu);\n\tkvm_vcpu_kick(&vmx->vcpu);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * Decode the memory-address operand of a vmx instruction, as recorded on an\n * exit caused by such an instruction (run by a guest hypervisor).\n * On success, returns 0. When the operand is invalid, returns 1 and throws\n * #UD or #GP.\n */\nstatic int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; /* holds the displacement */\n\n\tif (addr_size == 1) /* 32 bit */\n\t\t*ret &= 0xffffffff;\n\n\t/*\n\t * TODO: throw #GP (and return 1) in various cases that the VM*\n\t * instructions require it - e.g., offset beyond segment limit,\n\t * unusable or unreadable/unwritable segment, non-canonical 64-bit\n\t * address, and so on. Currently these are not checked.\n\t */\n\treturn 0;\n}\n\n/*\n * This function performs the various checks including\n * - if it's 4KB aligned\n * - No bits beyond the physical address width are set\n * - Returns 0 on success or else 1\n * (Intel SDM Section 30.3)\n */\nstatic int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,\n\t\t\t\t  gpa_t *vmpointer)\n{\n\tgva_t gva;\n\tgpa_t vmptr;\n\tstruct x86_exception e;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmcs_read32(VMX_INSTRUCTION_INFO), &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vmptr,\n\t\t\t\tsizeof(vmptr), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_VMON:\n\t\t/*\n\t\t * SDM 3: 24.11.5\n\t\t * The first 4 bytes of VMXON region contain the supported\n\t\t * VMCS revision identifier\n\t\t *\n\t\t * Note - IA32_VMX_BASIC[48] will never be 1\n\t\t * for the nested case;\n\t\t * which replaces physical address width with 32\n\t\t *\n\t\t */\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL ||\n\t\t    *(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tkunmap(page);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tkunmap(page);\n\t\tvmx->nested.vmxon_ptr = vmptr;\n\t\tbreak;\n\tcase EXIT_REASON_VMCLEAR:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_INVALID_ADDRESS);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase EXIT_REASON_VMPTRLD:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_INVALID_ADDRESS);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 1; /* shouldn't happen */\n\t}\n\n\tif (vmpointer)\n\t\t*vmpointer = vmptr;\n\treturn 0;\n}\n\n/*\n * Emulate the VMXON instruction.\n * Currently, we just remember that VMX is active, and do not save or even\n * inspect the argument to VMXON (the so-called \"VMXON pointer\") because we\n * do not currently need to store anything in that guest-allocated memory\n * region. Consequently, VMCLEAR and VMPTRLD also do not verify that the their\n * argument is different from the VMXON pointer (which the spec says they do).\n */\nstatic int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs *shadow_vmcs;\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\t/* The Intel VMX Instruction Reference lists a bunch of bits that\n\t * are prerequisite to running VMXON, most notably cr4.VMXE must be\n\t * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).\n\t * Otherwise, we should fail with #UD. We test these now:\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE) ||\n\t    !kvm_read_cr0_bits(vcpu, X86_CR0_PE) ||\n\t    (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif (is_long_mode(vcpu) && !cs.l) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMON, NULL))\n\t\treturn 1;\n\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif ((vmx->nested.msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (enable_shadow_vmcs) {\n\t\tshadow_vmcs = alloc_vmcs();\n\t\tif (!shadow_vmcs)\n\t\t\treturn -ENOMEM;\n\t\t/* mark vmcs as shadow */\n\t\tshadow_vmcs->revision_id |= (1u << 31);\n\t\t/* init shadow vmcs */\n\t\tvmcs_clear(shadow_vmcs);\n\t\tvmx->nested.current_shadow_vmcs = shadow_vmcs;\n\t}\n\n\tINIT_LIST_HEAD(&(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num = 0;\n\n\thrtimer_init(&vmx->nested.preemption_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tvmx->nested.preemption_timer.function = vmx_preemption_timer_fn;\n\n\tvmx->nested.vmxon = true;\n\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\n/*\n * Intel's VMX Instruction Reference specifies a common set of prerequisites\n * for running VMX instructions (except VMXON, whose prerequisites are\n * slightly different). It also specifies what exception to inject otherwise.\n */\nstatic int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif ((vmx_get_rflags(vcpu) & X86_EFLAGS_VM) ||\n\t    (is_long_mode(vcpu) && !cs.l)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline void nested_release_vmcs12(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control;\n\tif (vmx->nested.current_vmptr == -1ull)\n\t\treturn;\n\n\t/* current_vmptr and current_vmcs12 are always set/reset together */\n\tif (WARN_ON(vmx->nested.current_vmcs12 == NULL))\n\t\treturn;\n\n\tif (enable_shadow_vmcs) {\n\t\t/* copy to memory all shadowed fields in case\n\t\t   they were modified */\n\t\tcopy_shadow_to_vmcs12(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\t}\n\tkunmap(vmx->nested.current_vmcs12_page);\n\tnested_release_page(vmx->nested.current_vmcs12_page);\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n}\n\n/*\n * Free whatever needs to be freed from vmx->nested when L1 goes down, or\n * just stops using VMX.\n */\nstatic void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}\n\n/* Emulate the VMXOFF instruction */\nstatic int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMCLEAR instruction */\nstatic int handle_vmclear(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tstruct vmcs12 *vmcs12;\n\tstruct page *page;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMCLEAR, &vmptr))\n\t\treturn 1;\n\n\tif (vmptr == vmx->nested.current_vmptr)\n\t\tnested_release_vmcs12(vmx);\n\n\tpage = nested_get_page(vcpu, vmptr);\n\tif (page == NULL) {\n\t\t/*\n\t\t * For accurate processor emulation, VMCLEAR beyond available\n\t\t * physical memory should do nothing at all. However, it is\n\t\t * possible that a nested vmx bug, not a guest hypervisor bug,\n\t\t * resulted in this case, so let's shut down before doing any\n\t\t * more damage:\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn 1;\n\t}\n\tvmcs12 = kmap(page);\n\tvmcs12->launch_state = 0;\n\tkunmap(page);\n\tnested_release_page(page);\n\n\tnested_free_vmcs02(vmx, vmptr);\n\n\tskip_emulated_instruction(vcpu);\n\tnested_vmx_succeed(vcpu);\n\treturn 1;\n}\n\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch);\n\n/* Emulate the VMLAUNCH instruction */\nstatic int handle_vmlaunch(struct kvm_vcpu *vcpu)\n{\n\treturn nested_vmx_run(vcpu, true);\n}\n\n/* Emulate the VMRESUME instruction */\nstatic int handle_vmresume(struct kvm_vcpu *vcpu)\n{\n\n\treturn nested_vmx_run(vcpu, false);\n}\n\nenum vmcs_field_type {\n\tVMCS_FIELD_TYPE_U16 = 0,\n\tVMCS_FIELD_TYPE_U64 = 1,\n\tVMCS_FIELD_TYPE_U32 = 2,\n\tVMCS_FIELD_TYPE_NATURAL_WIDTH = 3\n};\n\nstatic inline int vmcs_field_type(unsigned long field)\n{\n\tif (0x1 & field)\t/* the *_HIGH fields are all 32 bit */\n\t\treturn VMCS_FIELD_TYPE_U32;\n\treturn (field >> 13) & 0x3 ;\n}\n\nstatic inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}\n\n/*\n * Read a vmcs12 field. Since these can have varying lengths and we return\n * one type, we chose the biggest type (u64) and zero-extend the return value\n * to that size. Note that the caller, handle_vmread, might need to use only\n * some of the bits we return here (e.g., on 32-bit guests, only 32 bits of\n * 64-bit fields are to be returned).\n */\nstatic inline bool vmcs12_read_any(struct kvm_vcpu *vcpu,\n\t\t\t\t\tunsigned long field, u64 *ret)\n{\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p;\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\tp = ((char *)(get_vmcs12(vcpu))) + offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*ret = *((natural_width *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*ret = *((u16 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*ret = *((u32 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*ret = *((u64 *)p);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0; /* can never happen. */\n\t}\n}\n\n\nstatic inline bool vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t    unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn false;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn true;\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn true;\n\tdefault:\n\t\treturn false; /* can never happen. */\n\t}\n\n}\n\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)\n{\n\tint i;\n\tunsigned long field;\n\tu64 field_value;\n\tstruct vmcs *shadow_vmcs = vmx->nested.current_shadow_vmcs;\n\tconst unsigned long *fields = shadow_read_write_fields;\n\tconst int num_fields = max_shadow_read_write_fields;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tfield = fields[i];\n\t\tswitch (vmcs_field_type(field)) {\n\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\tfield_value = vmcs_read16(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\tfield_value = vmcs_read32(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\tfield_value = vmcs_read64(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\tfield_value = vmcs_readl(field);\n\t\t\tbreak;\n\t\t}\n\t\tvmcs12_write_any(&vmx->vcpu, field, field_value);\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long *fields[] = {\n\t\tshadow_read_write_fields,\n\t\tshadow_read_only_fields\n\t};\n\tconst int max_fields[] = {\n\t\tmax_shadow_read_write_fields,\n\t\tmax_shadow_read_only_fields\n\t};\n\tint i, q;\n\tunsigned long field;\n\tu64 field_value = 0;\n\tstruct vmcs *shadow_vmcs = vmx->nested.current_shadow_vmcs;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (q = 0; q < ARRAY_SIZE(fields); q++) {\n\t\tfor (i = 0; i < max_fields[q]; i++) {\n\t\t\tfield = fields[q][i];\n\t\t\tvmcs12_read_any(&vmx->vcpu, field, &field_value);\n\n\t\t\tswitch (vmcs_field_type(field)) {\n\t\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\t\tvmcs_write16(field, (u16)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\t\tvmcs_write32(field, (u32)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\t\tvmcs_write64(field, (u64)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\t\tvmcs_writel(field, (long)field_value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\n/*\n * VMX instructions which assume a current vmcs12 (i.e., that VMPTRLD was\n * used before) all generate the same failure when it is missing.\n */\nstatic int nested_vmx_check_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (vmx->nested.current_vmptr == -1ull) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\t/* Decode instruction info and find the field to read */\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\t/* Read the field, zero-extended to a u64 field_value */\n\tif (!vmcs12_read_any(vcpu, field, &field_value)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\t/*\n\t * Now copy part of this value to register or memory, as requested.\n\t * Note that the number of bits actually copied is 32 or 64 depending\n\t * on the guest's mode (32 or 64 bit), not on the given field's length.\n\t */\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, &gva))\n\t\t\treturn 1;\n\t\t/* _system ok, as nested_vmx_check_permission verified cpl=0 */\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n\nstatic int handle_vmwrite(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tgva_t gva;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\t/* The value to write might be 32 or 64 bits, depending on L1's long\n\t * mode, and eventually we need to write that into a field of several\n\t * possible lengths. The code below first zero-extends the value to 64\n\t * bit (field_value), and then copies only the approriate number of\n\t * bits into the vmcs12 field.\n\t */\n\tu64 field_value = 0;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\tif (vmx_instruction_info & (1u << 10))\n\t\tfield_value = kvm_register_readl(vcpu,\n\t\t\t(((vmx_instruction_info) >> 3) & 0xf));\n\telse {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, &gva))\n\t\t\treturn 1;\n\t\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t   &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {\n\t\t\tkvm_inject_page_fault(vcpu, &e);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs_field_readonly(field)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (!vmcs12_write_any(vcpu, field, field_value)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\tskip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMPTRLD instruction */\nstatic int handle_vmptrld(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tu32 exec_control;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMPTRLD, &vmptr))\n\t\treturn 1;\n\n\tif (vmx->nested.current_vmptr != vmptr) {\n\t\tstruct vmcs12 *new_vmcs12;\n\t\tstruct page *page;\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\t\tnew_vmcs12 = kmap(page);\n\t\tif (new_vmcs12->revision_id != VMCS12_REVISION) {\n\t\t\tkunmap(page);\n\t\t\tnested_release_page_clean(page);\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);\n\t\t\tskip_emulated_instruction(vcpu);\n\t\t\treturn 1;\n\t\t}\n\n\t\tnested_release_vmcs12(vmx);\n\t\tvmx->nested.current_vmptr = vmptr;\n\t\tvmx->nested.current_vmcs12 = new_vmcs12;\n\t\tvmx->nested.current_vmcs12_page = page;\n\t\tif (enable_shadow_vmcs) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control |= SECONDARY_EXEC_SHADOW_VMCS;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t\t\tvmcs_write64(VMCS_LINK_POINTER,\n\t\t\t\t     __pa(vmx->nested.current_shadow_vmcs));\n\t\t\tvmx->nested.sync_shadow_vmcs = true;\n\t\t}\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the VMPTRST instruction */\nstatic int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, &vmcs_gva))\n\t\treturn 1;\n\t/* ok to use *_system, as nested_vmx_check_permission verified cpl=0 */\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/* Emulate the INVEPT instruction */\nstatic int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\t/* Trap single context invalidation invept calls */\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n\t[EXIT_REASON_VMREAD]                  = handle_vmread,\n\t[EXIT_REASON_VMRESUME]                = handle_vmresume,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n\t[EXIT_REASON_VMOFF]                   = handle_vmoff,\n\t[EXIT_REASON_VMON]                    = handle_vmon,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_invept,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tgpa_t bitmap, last_bitmap;\n\tunsigned int port;\n\tint size;\n\tu8 b;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn 1;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_read_guest(vcpu->kvm, bitmap, &b, 1))\n\t\t\t\treturn 1;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn 1;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an MSR access access,\n * rather than handle it ourselves in L0. I.e., check whether L1 expressed\n * disinterest in the current event (read or write a specific MSR) by using an\n * MSR bitmap. This may be the case even when L0 doesn't use MSR bitmaps.\n */\nstatic bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12, u32 exit_reason)\n{\n\tu32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tgpa_t bitmap;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 1;\n\n\t/*\n\t * The MSR_BITMAP page is divided into four 1024-byte bitmaps,\n\t * for the four combinations of read/write and low/high MSR numbers.\n\t * First we need to figure out which of the four to use:\n\t */\n\tbitmap = vmcs12->msr_bitmap;\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\tbitmap += 2048;\n\tif (msr_index >= 0xc0000000) {\n\t\tmsr_index -= 0xc0000000;\n\t\tbitmap += 1024;\n\t}\n\n\t/* Then read the msr_index'th bit from this bitmap: */\n\tif (msr_index < 1024*8) {\n\t\tunsigned char b;\n\t\tif (kvm_read_guest(vcpu->kvm, bitmap + msr_index/8, &b, 1))\n\t\t\treturn 1;\n\t\treturn 1 & (b >> (msr_index & 7));\n\t} else\n\t\treturn 1; /* let L1 handle the wrong parameter */\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle a CR access exit,\n * rather than handle it ourselves in L0. I.e., check if L1 wanted to\n * intercept (via guest_host_mask etc.) the current event.\n */\nstatic bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint cr = exit_qualification & 15;\n\tint reg = (exit_qualification >> 8) & 15;\n\tunsigned long val = kvm_register_readl(vcpu, reg);\n\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (vmcs12->cr0_guest_host_mask &\n\t\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((vmcs12->cr3_target_count >= 1 &&\n\t\t\t\t\tvmcs12->cr3_target_value0 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 2 &&\n\t\t\t\t\tvmcs12->cr3_target_value1 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 3 &&\n\t\t\t\t\tvmcs12->cr3_target_value2 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 4 &&\n\t\t\t\t\tvmcs12->cr3_target_value3 == val))\n\t\t\t\treturn 0;\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR3_LOAD_EXITING))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (vmcs12->cr4_guest_host_mask &\n\t\t\t    (vmcs12->cr4_read_shadow ^ val))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tif ((vmcs12->cr0_guest_host_mask & X86_CR0_TS) &&\n\t\t    (vmcs12->cr0_read_shadow & X86_CR0_TS))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 1: /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR3_STORE_EXITING)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR8_STORE_EXITING)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\t/*\n\t\t * lmsw can change bits 1..3 of cr0, and only set bit 0 of\n\t\t * cr0. Other attempted changes are ignored, with no exit.\n\t\t */\n\t\tif (vmcs12->cr0_guest_host_mask & 0xe &\n\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\treturn 1;\n\t\tif ((vmcs12->cr0_guest_host_mask & 0x1) &&\n\t\t    !(vmcs12->cr0_read_shadow & 0x1) &&\n\t\t    (val & 0x1))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an exit, or 0 if we\n * should handle it ourselves in L0 (and then continue L2). Only call this\n * when in is_guest_mode (L2).\n */\nstatic bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn 0;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn 0;\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n\tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = exit_reason;\n\t}\n\treturn 0;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\tif (irr == -1 || tpr < irr) {\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(TPR_THRESHOLD, irr);\n}\n\nstatic void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\tu32 sec_exec_control;\n\n\t/*\n\t * There is not point to enable virtualize x2apic without enable\n\t * apicv\n\t */\n\tif (!cpu_has_vmx_virtualize_x2apic_mode() ||\n\t\t\t\t!vmx_vm_has_apicv(vcpu->kvm))\n\t\treturn;\n\n\tif (!vm_need_tpr_shadow(vcpu->kvm))\n\t\treturn;\n\n\tsec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tif (set) {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t} else {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t}\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);\n\n\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Currently we do not handle the nested case where L2 has an\n\t * APIC access page of its own; that page is still pinned.\n\t * Hence, we skip the case where the VCPU is in guest mode _and_\n\t * L1 prepared an APIC access page for L2.\n\t *\n\t * For the case where L1 and L2 share the same APIC access page\n\t * (flexpriority=Y but SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES clear\n\t * in the vmcs12), this function will only update either the vmcs01\n\t * or the vmcs02.  If the former, the vmcs02 will be updated by\n\t * prepare_vmcs02.  If the latter, the vmcs01 will be updated in\n\t * the next L2->L1 exit.\n\t */\n\tif (!is_guest_mode(vcpu) ||\n\t    !nested_cpu_has2(vmx->nested.current_vmcs12,\n\t\t\t     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (!vmx_vm_has_apicv(kvm))\n\t\treturn;\n\n\tif (isr == -1)\n\t\tisr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\tif (max_irr == -1)\n\t\treturn;\n\n\t/*\n\t * If a vmexit is needed, vmx_check_nested_events handles it.\n\t */\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn;\n\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmx_set_rvi(max_irr);\n\t\treturn;\n\t}\n\n\t/*\n\t * Fall back to pre-APICv interrupt injection since L2\n\t * is run without virtual interrupt delivery.\n\t */\n\tif (!kvm_event_needs_reinjection(vcpu) &&\n\t    vmx_interrupt_allowed(vcpu)) {\n\t\tkvm_queue_interrupt(vcpu, max_irr, false);\n\t\tvmx_inject_irq(vcpu);\n\t}\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!vmx_vm_has_apicv(vcpu->kvm))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n\nstatic void vmx_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * If external interrupt exists, IF bit is set in rflags/eflags on the\n\t * interrupt stack frame, and interrupt will be enabled on a return\n\t * from interrupt handler.\n\t */\n\tif ((exit_intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) {\n\t\tunsigned int vector;\n\t\tunsigned long entry;\n\t\tgate_desc *desc;\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n#ifdef CONFIG_X86_64\n\t\tunsigned long tmp;\n#endif\n\n\t\tvector =  exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\tdesc = (gate_desc *)vmx->host_idt_base + vector;\n\t\tentry = gate_offset(*desc);\n\t\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\t\"push $%c[ss]\\n\\t\"\n\t\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\t\"pushf\\n\\t\"\n\t\t\t\"orl $0x200, (%%\" _ASM_SP \")\\n\\t\"\n\t\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\t\t\"call *%[entry]\\n\\t\"\n\t\t\t:\n#ifdef CONFIG_X86_64\n\t\t\t[sp]\"=&r\"(tmp)\n#endif\n\t\t\t:\n\t\t\t[entry]\"r\"(entry),\n\t\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t\t[cs]\"i\"(__KERNEL_CS)\n\t\t\t);\n\t} else\n\t\tlocal_irq_enable();\n}\n\nstatic bool vmx_mpx_supported(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (cpu_has_virtual_nmis()) {\n\t\tif (vmx->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->soft_vnmi_blocked))\n\t\tvmx->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(), vmx->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}\n\nstatic void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\ttrace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n\nstatic void vmx_load_vmcs01(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\n\tif (vmx->loaded_vmcs == &vmx->vmcs01)\n\t\treturn;\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n}\n\nstatic void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tfree_vpid(vmx);\n\tleave_guest_mode(vcpu);\n\tvmx_load_vmcs01(vcpu);\n\tfree_nested(vmx);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n\tkfree(vmx->guest_msrs);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n}\n\nstatic struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tint err;\n\tstruct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tint cpu;\n\n\tif (!vmx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tallocate_vpid(vmx);\n\n\terr = kvm_vcpu_init(&vmx->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_vcpu;\n\n\tvmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) * sizeof(vmx->guest_msrs[0])\n\t\t     > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tif (!vmx->guest_msrs) {\n\t\tgoto uninit_vcpu;\n\t}\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx->loaded_vmcs->vmcs = alloc_vmcs();\n\tif (!vmx->loaded_vmcs->vmcs)\n\t\tgoto free_msrs;\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(__pa(per_cpu(vmxarea, raw_smp_processor_id())));\n\tloaded_vmcs_init(vmx->loaded_vmcs);\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxoff();\n\n\tcpu = get_cpu();\n\tvmx_vcpu_load(&vmx->vcpu, cpu);\n\tvmx->vcpu.cpu = cpu;\n\terr = vmx_vcpu_setup(vmx);\n\tvmx_vcpu_put(&vmx->vcpu);\n\tput_cpu();\n\tif (err)\n\t\tgoto free_vmcs;\n\tif (vm_need_virtualize_apic_accesses(kvm)) {\n\t\terr = alloc_apic_access_page(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept) {\n\t\tif (!kvm->arch.ept_identity_map_addr)\n\t\t\tkvm->arch.ept_identity_map_addr =\n\t\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t\terr = init_rmode_identity_map(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n\n\treturn &vmx->vcpu;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_msrs:\n\tkfree(vmx->guest_msrs);\nuninit_vcpu:\n\tkvm_vcpu_uninit(&vmx->vcpu);\nfree_vcpu:\n\tfree_vpid(vmx);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n\treturn ERR_PTR(err);\n}\n\nstatic void __init vmx_check_processor_compat(void *rtn)\n{\n\tstruct vmcs_config vmcs_conf;\n\n\t*(int *)rtn = 0;\n\tif (setup_vmcs_config(&vmcs_conf) < 0)\n\t\t*(int *)rtn = -EIO;\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\t*(int *)rtn = -EIO;\n\t}\n}\n\nstatic int get_ept_level(void)\n{\n\treturn VMX_EPT_DEFAULT_GAW + 1;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu64 ret;\n\n\t/* For VT-d and EPT combination\n\t * 1. MMIO: always map as UC\n\t * 2. EPT with VT-d:\n\t *   a. VT-d without snooping control feature: can't guarantee the\n\t *\tresult, try to trust guest.\n\t *   b. VT-d with snooping control feature: snooping control feature of\n\t *\tVT-d engine can guarantee the cache correctness. Just set it\n\t *\tto WB to keep consistent with host. So the same as item 3.\n\t * 3. EPT without VT-d: always map as WB and set IPAT=1 to keep\n\t *    consistent with host MTRR\n\t */\n\tif (is_mmio)\n\t\tret = MTRR_TYPE_UNCACHABLE << VMX_EPT_MT_EPTE_SHIFT;\n\telse if (kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\tret = kvm_get_guest_memory_type(vcpu, gfn) <<\n\t\t      VMX_EPT_MT_EPTE_SHIFT;\n\telse\n\t\tret = (MTRR_TYPE_WRBACK << VMX_EPT_MT_EPTE_SHIFT)\n\t\t\t| VMX_EPT_IPAT_BIT;\n\n\treturn ret;\n}\n\nstatic int vmx_get_lpage_level(void)\n{\n\tif (enable_ept && !cpu_has_vmx_ept_1g_page())\n\t\treturn PT_DIRECTORY_LEVEL;\n\telse\n\t\t/* For shadow and EPT supported 1GB page */\n\t\treturn PT_PDPE_LEVEL;\n}\n\nstatic void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmx->rdtscp_enabled = false;\n\tif (vmx_rdtscp_supported()) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\tif (exec_control & SECONDARY_EXEC_RDTSCP) {\n\t\t\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\t\tif (best && (best->edx & bit(X86_FEATURE_RDTSCP)))\n\t\t\t\tvmx->rdtscp_enabled = true;\n\t\t\telse {\n\t\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\t\texec_control);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Exposing INVPCID only when PCID is exposed */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    best && (best->ebx & bit(X86_FEATURE_INVPCID)) &&\n\t    guest_cpuid_has_pcid(vcpu)) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control |= SECONDARY_EXEC_ENABLE_INVPCID;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t     exec_control);\n\t} else {\n\t\tif (cpu_has_secondary_exec_ctrls()) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t     exec_control);\n\t\t}\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n}\n\nstatic void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}\n\nstatic void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason;\n\n\tif (fault->error_code & PFERR_RSVD_MASK)\n\t\texit_reason = EXIT_REASON_EPT_MISCONFIG;\n\telse\n\t\texit_reason = EXIT_REASON_EPT_VIOLATION;\n\tnested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);\n\tvmcs12->guest_physical_address = fault->address;\n}\n\n/* Callbacks for nested_ept_init_mmu_context: */\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}\n\nstatic void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_init_shadow_ept_mmu(vcpu, &vcpu->arch.mmu,\n\t\t\tnested_vmx_ept_caps & VMX_EPT_EXECUTE_ONLY_BIT);\n\n\tvcpu->arch.mmu.set_cr3           = vmx_set_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;\n\tvcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;\n\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic void vmx_inject_page_fault_nested(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON(!is_guest_mode(vcpu));\n\n\t/* TODO: also check PFEC_MATCH/MASK, not just EB.PF. */\n\tif (vmcs12->exception_bitmap & (1u << PF_VECTOR))\n\t\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\telse\n\t\tkvm_inject_page_fault(vcpu, fault);\n}\n\nstatic bool nested_get_vmcs12_pages(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {\n\t\t/* TODO: Also verify bits beyond physical address width are 0 */\n\t\tif (!PAGE_ALIGNED(vmcs12->apic_access_addr))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Translate L1 physical address to host physical\n\t\t * address for vmcs02. Keep the page pinned, so this\n\t\t * physical address remains valid. We keep a reference\n\t\t * to it so we can release it later.\n\t\t */\n\t\tif (vmx->nested.apic_access_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page =\n\t\t\tnested_get_page(vcpu, vmcs12->apic_access_addr);\n\t}\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\t/* TODO: Also verify bits beyond physical address width are 0 */\n\t\tif (!PAGE_ALIGNED(vmcs12->virtual_apic_page_addr))\n\t\t\treturn false;\n\n\t\tif (vmx->nested.virtual_apic_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page =\n\t\t\tnested_get_page(vcpu, vmcs12->virtual_apic_page_addr);\n\n\t\t/*\n\t\t * Failing the vm entry is _not_ what the processor does\n\t\t * but it's basically the only possibility we have.\n\t\t * We could still enter the guest if CR8 load exits are\n\t\t * enabled, CR8 store exits are enabled, and virtualize APIC\n\t\t * access is disabled; in this case the processor would never\n\t\t * use the TPR shadow and we could simply clear the bit from\n\t\t * the execution control.  But such a configuration is useless,\n\t\t * so let's keep the code simple.\n\t\t */\n\t\tif (!vmx->nested.virtual_apic_page)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void vmx_start_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tu64 preemption_timeout = get_vmcs12(vcpu)->vmx_preemption_timer_value;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vcpu->arch.virtual_tsc_khz == 0)\n\t\treturn;\n\n\t/* Make sure short timeouts reliably trigger an immediate vmexit.\n\t * hrtimer_start does not guarantee this. */\n\tif (preemption_timeout <= 1) {\n\t\tvmx_preemption_timer_fn(&vmx->nested.preemption_timer);\n\t\treturn;\n\t}\n\n\tpreemption_timeout <<= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n\tpreemption_timeout *= 1000000;\n\tdo_div(preemption_timeout, vcpu->arch.virtual_tsc_khz);\n\thrtimer_start(&vmx->nested.preemption_timer,\n\t\t      ns_to_ktime(preemption_timeout), HRTIMER_MODE_REL);\n}\n\n/*\n * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested\n * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function \"merges\" it\n * with L0's requirements for its guest (a.k.a. vmcs01), so we can run the L2\n * guest in a way that will both be appropriate to L1's requests, and our\n * needs. In addition to modifying the active vmcs (which is vmcs02), this\n * function also has additional necessary side-effects, like setting various\n * vcpu->arch fields.\n */\nstatic void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\texec_control &= ~(PIN_BASED_VMX_PREEMPTION_TIMER |\n                          PIN_BASED_POSTED_INTR);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (vm_need_virtualize_apic_accesses(vmx->vcpu.kvm)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\t/*\n\t * Merging of IO and MSR bitmaps not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvmx->nested.vmcs01_tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\t/* shadow page tables on either EPT or shadow page tables */\n\tkvm_set_cr3(vcpu, vmcs12->guest_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n}\n\n/*\n * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1\n * for running an L2 nested guest.\n */\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\tstruct loaded_vmcs *vmcs02;\n\tbool ia32e;\n\n\tif (!nested_vmx_check_permission(vcpu) ||\n\t    !nested_vmx_check_vmcs12(vcpu))\n\t\treturn 1;\n\n\tskip_emulated_instruction(vcpu);\n\tvmcs12 = get_vmcs12(vcpu);\n\n\tif (enable_shadow_vmcs)\n\t\tcopy_shadow_to_vmcs12(vmx);\n\n\t/*\n\t * The nested entry process starts with enforcing various prerequisites\n\t * on vmcs12 as required by the Intel SDM, and act appropriately when\n\t * they fail: As the SDM explains, some conditions should cause the\n\t * instruction to fail, while others will cause the instruction to seem\n\t * to succeed, but return an EXIT_REASON_INVALID_STATE.\n\t * To speed up the normal (success) code path, we should avoid checking\n\t * for misconfigurations which will anyway be caught by the processor\n\t * when using the merged vmcs02.\n\t */\n\tif (vmcs12->launch_state == launch) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tlaunch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS\n\t\t\t       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);\n\t\treturn 1;\n\t}\n\n\tif (vmcs12->guest_activity_state != GUEST_ACTIVITY_ACTIVE &&\n\t    vmcs12->guest_activity_state != GUEST_ACTIVITY_HLT) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif ((vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_MSR_BITMAPS) &&\n\t\t\t!PAGE_ALIGNED(vmcs12->msr_bitmap)) {\n\t\t/*TODO: Also verify bits beyond physical address width are 0*/\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!nested_get_vmcs12_pages(vcpu, vmcs12)) {\n\t\t/*TODO: Also verify bits beyond physical address width are 0*/\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (vmcs12->vm_entry_msr_load_count > 0 ||\n\t    vmcs12->vm_exit_msr_load_count > 0 ||\n\t    vmcs12->vm_exit_msr_store_count > 0) {\n\t\tpr_warn_ratelimited(\"%s: VMCS MSR_{LOAD,STORE} unsupported\\n\",\n\t\t\t\t    __func__);\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,\n\t\t\t\tnested_vmx_true_procbased_ctls_low,\n\t\t\t\tnested_vmx_procbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->secondary_vm_exec_control,\n\t      nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->pin_based_vm_exec_control,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_exit_controls,\n\t\t\t\tnested_vmx_true_exit_ctls_low,\n\t\t\t\tnested_vmx_exit_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_entry_controls,\n\t\t\t\tnested_vmx_true_entry_ctls_low,\n\t\t\t\tnested_vmx_entry_ctls_high))\n\t{\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (((vmcs12->host_cr0 & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON) ||\n\t    ((vmcs12->host_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_ENTRY_INVALID_HOST_STATE_FIELD);\n\t\treturn 1;\n\t}\n\n\tif (!nested_cr0_valid(vmcs12, vmcs12->guest_cr0) ||\n\t    ((vmcs12->guest_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\treturn 1;\n\t}\n\tif (vmcs12->vmcs_link_pointer != -1ull) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_VMCS_LINK_PTR);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-entry control is 1, the following checks\n\t * are performed on the field for the IA32_EFER MSR:\n\t * - Bits reserved in the IA32_EFER MSR must be 0.\n\t * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of\n\t *   the IA-32e mode guest VM-exit control. It must also be identical\n\t *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to\n\t *   CR0.PG) is 1.\n\t */\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-exit control is 1, bits reserved in the\n\t * IA32_EFER MSR must be 0 in the field for that register. In addition,\n\t * the values of the LMA and LME bits in the field must each be that of\n\t * the host address-space size VM-exit control.\n\t */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME)) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We're finally done with prerequisite checking, and can start with\n\t * the nested entry.\n\t */\n\n\tvmcs02 = nested_get_current_vmcs02(vmx);\n\tif (!vmcs02)\n\t\treturn -ENOMEM;\n\n\tenter_guest_mode(vcpu);\n\n\tvmx->nested.vmcs01_tsc_offset = vmcs_read64(TSC_OFFSET);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = vmcs02;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs12->launch_state = 1;\n\n\tprepare_vmcs02(vcpu, vmcs12);\n\n\tif (vmcs12->guest_activity_state == GUEST_ACTIVITY_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\n\tvmx->nested.nested_run_pending = 1;\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn 1;\n}\n\n/*\n * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date\n * because L2 may have changed some cr0 bits directly (CRO_GUEST_HOST_MASK).\n * This function returns the new value we should put in vmcs12.guest_cr0.\n * It's not enough to just return the vmcs02 GUEST_CR0. Rather,\n *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now\n *     available in vmcs02 GUEST_CR0. (Note: It's enough to check that L0\n *     didn't trap the bit, because if L1 did, so would L0).\n *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have\n *     been modified by L2, and L1 knows it. So just leave the old value of\n *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0\n *     isn't relevant, because if L0 traps this bit it can set it to anything.\n *  3. Bits that L1 didn't trap, but L0 did. L1 believes the guest could have\n *     changed these bits, and therefore they need to be updated, but L0\n *     didn't necessarily allow them to be changed in GUEST_CR0 - and rather\n *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.\n */\nstatic inline unsigned long\nvmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |\n\t\t\tvcpu->arch.cr0_guest_owned_bits));\n}\n\nstatic inline unsigned long\nvmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |\n\t\t\tvcpu->arch.cr4_guest_owned_bits));\n}\n\nstatic void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tu32 idt_vectoring;\n\tunsigned int nr;\n\n\tif (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) {\n\t\tnr = vcpu->arch.exception.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (kvm_exception_is_soft(nr)) {\n\t\t\tvmcs12->vm_exit_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_EXCEPTION;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_HARD_EXCEPTION;\n\n\t\tif (vcpu->arch.exception.has_error_code) {\n\t\t\tidt_vectoring |= VECTORING_INFO_DELIVER_CODE_MASK;\n\t\t\tvmcs12->idt_vectoring_error_code =\n\t\t\t\tvcpu->arch.exception.error_code;\n\t\t}\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t} else if (vcpu->arch.nmi_injected) {\n\t\tvmcs12->idt_vectoring_info_field =\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR;\n\t} else if (vcpu->arch.interrupt.pending) {\n\t\tnr = vcpu->arch.interrupt.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (vcpu->arch.interrupt.soft) {\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_INTR;\n\t\t\tvmcs12->vm_entry_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_EXT_INTR;\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t}\n}\n\nstatic int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending ||\n\t\t    vcpu->arch.interrupt.pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\t/*\n\t\t * The NMI-triggered VM exit counts as injection:\n\t\t * clear this one and block further NMIs.\n\t\t */\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)\n{\n\tktime_t remaining =\n\t\thrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);\n\tu64 value;\n\n\tif (ktime_to_ns(remaining) <= 0)\n\t\treturn 0;\n\n\tvalue = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;\n\tdo_div(value, 1000000);\n\treturn value >> VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n}\n\n/*\n * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits\n * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),\n * and this function updates it to reflect the changes to the guest state while\n * L2 was running (and perhaps made some exits which were handled directly by L0\n * without going back to L1), and to reflect the exit reason.\n * Note that we do not have to copy here all VMCS fields, just those that\n * could have changed by the L2 guest or the exit - i.e., the guest-state and\n * exit-information fields only. Other fields are modified by L1 with VMWRITE,\n * which already writes to vmcs12 directly.\n */\nstatic void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t   u32 exit_reason, u32 exit_intr_info,\n\t\t\t   unsigned long exit_qualification)\n{\n\t/* update guest state fields: */\n\tvmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);\n\tvmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);\n\n\tvmcs12->guest_rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tvmcs12->guest_rip = kvm_register_read(vcpu, VCPU_REGS_RIP);\n\tvmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);\n\n\tvmcs12->guest_es_selector = vmcs_read16(GUEST_ES_SELECTOR);\n\tvmcs12->guest_cs_selector = vmcs_read16(GUEST_CS_SELECTOR);\n\tvmcs12->guest_ss_selector = vmcs_read16(GUEST_SS_SELECTOR);\n\tvmcs12->guest_ds_selector = vmcs_read16(GUEST_DS_SELECTOR);\n\tvmcs12->guest_fs_selector = vmcs_read16(GUEST_FS_SELECTOR);\n\tvmcs12->guest_gs_selector = vmcs_read16(GUEST_GS_SELECTOR);\n\tvmcs12->guest_ldtr_selector = vmcs_read16(GUEST_LDTR_SELECTOR);\n\tvmcs12->guest_tr_selector = vmcs_read16(GUEST_TR_SELECTOR);\n\tvmcs12->guest_es_limit = vmcs_read32(GUEST_ES_LIMIT);\n\tvmcs12->guest_cs_limit = vmcs_read32(GUEST_CS_LIMIT);\n\tvmcs12->guest_ss_limit = vmcs_read32(GUEST_SS_LIMIT);\n\tvmcs12->guest_ds_limit = vmcs_read32(GUEST_DS_LIMIT);\n\tvmcs12->guest_fs_limit = vmcs_read32(GUEST_FS_LIMIT);\n\tvmcs12->guest_gs_limit = vmcs_read32(GUEST_GS_LIMIT);\n\tvmcs12->guest_ldtr_limit = vmcs_read32(GUEST_LDTR_LIMIT);\n\tvmcs12->guest_tr_limit = vmcs_read32(GUEST_TR_LIMIT);\n\tvmcs12->guest_gdtr_limit = vmcs_read32(GUEST_GDTR_LIMIT);\n\tvmcs12->guest_idtr_limit = vmcs_read32(GUEST_IDTR_LIMIT);\n\tvmcs12->guest_es_ar_bytes = vmcs_read32(GUEST_ES_AR_BYTES);\n\tvmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);\n\tvmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);\n\tvmcs12->guest_ds_ar_bytes = vmcs_read32(GUEST_DS_AR_BYTES);\n\tvmcs12->guest_fs_ar_bytes = vmcs_read32(GUEST_FS_AR_BYTES);\n\tvmcs12->guest_gs_ar_bytes = vmcs_read32(GUEST_GS_AR_BYTES);\n\tvmcs12->guest_ldtr_ar_bytes = vmcs_read32(GUEST_LDTR_AR_BYTES);\n\tvmcs12->guest_tr_ar_bytes = vmcs_read32(GUEST_TR_AR_BYTES);\n\tvmcs12->guest_es_base = vmcs_readl(GUEST_ES_BASE);\n\tvmcs12->guest_cs_base = vmcs_readl(GUEST_CS_BASE);\n\tvmcs12->guest_ss_base = vmcs_readl(GUEST_SS_BASE);\n\tvmcs12->guest_ds_base = vmcs_readl(GUEST_DS_BASE);\n\tvmcs12->guest_fs_base = vmcs_readl(GUEST_FS_BASE);\n\tvmcs12->guest_gs_base = vmcs_readl(GUEST_GS_BASE);\n\tvmcs12->guest_ldtr_base = vmcs_readl(GUEST_LDTR_BASE);\n\tvmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);\n\tvmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);\n\tvmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);\n\n\tvmcs12->guest_interruptibility_info =\n\t\tvmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tvmcs12->guest_pending_dbg_exceptions =\n\t\tvmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;\n\telse\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_ACTIVE;\n\n\tif (nested_cpu_has_preemption_timer(vmcs12)) {\n\t\tif (vmcs12->vm_exit_controls &\n\t\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER)\n\t\t\tvmcs12->vmx_preemption_timer_value =\n\t\t\t\tvmx_get_preemption_timer_value(vcpu);\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\t}\n\n\t/*\n\t * In some cases (usually, nested EPT), L2 is allowed to change its\n\t * own CR3 without exiting. If it has changed it, we must keep it.\n\t * Of course, if L0 is using shadow page tables, GUEST_CR3 was defined\n\t * by L0, not L1 or L2, so we mustn't unconditionally copy it to vmcs12.\n\t *\n\t * Additionally, restore L2's PDPTR to vmcs12.\n\t */\n\tif (enable_ept) {\n\t\tvmcs12->guest_cr3 = vmcs_read64(GUEST_CR3);\n\t\tvmcs12->guest_pdptr0 = vmcs_read64(GUEST_PDPTR0);\n\t\tvmcs12->guest_pdptr1 = vmcs_read64(GUEST_PDPTR1);\n\t\tvmcs12->guest_pdptr2 = vmcs_read64(GUEST_PDPTR2);\n\t\tvmcs12->guest_pdptr3 = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tvmcs12->vm_entry_controls =\n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_IA32E_MODE) |\n\t\t(vm_entry_controls_get(to_vmx(vcpu)) & VM_ENTRY_IA32E_MODE);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_DEBUG_CONTROLS) {\n\t\tkvm_get_dr(vcpu, 7, (unsigned long *)&vmcs12->guest_dr7);\n\t\tvmcs12->guest_ia32_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t}\n\n\t/* TODO: These cannot have changed unless we have MSR bitmaps and\n\t * the relevant bit asks not to trap the change */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\tvmcs12->guest_ia32_pat = vmcs_read64(GUEST_IA32_PAT);\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)\n\t\tvmcs12->guest_ia32_efer = vcpu->arch.efer;\n\tvmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);\n\tvmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);\n\tvmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);\n\tif (vmx_mpx_supported())\n\t\tvmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\n\t/* update exit information fields: */\n\n\tvmcs12->vm_exit_reason = exit_reason;\n\tvmcs12->exit_qualification = exit_qualification;\n\n\tvmcs12->vm_exit_intr_info = exit_intr_info;\n\tif ((vmcs12->vm_exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK))\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\tvmcs12->idt_vectoring_info_field = 0;\n\tvmcs12->vm_exit_instruction_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tvmcs12->vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\n\tif (!(vmcs12->vm_exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY)) {\n\t\t/* vm_entry_intr_info_field is cleared on exit. Emulate this\n\t\t * instead of reading the real value. */\n\t\tvmcs12->vm_entry_intr_info_field &= ~INTR_INFO_VALID_MASK;\n\n\t\t/*\n\t\t * Transfer the event that L0 or L1 may wanted to inject into\n\t\t * L2 to IDT_VECTORING_INFO_FIELD.\n\t\t */\n\t\tvmcs12_save_pending_event(vcpu, vmcs12);\n\t}\n\n\t/*\n\t * Drop what we picked up for L2 via vmx_complete_interrupts. It is\n\t * preserved above and would only end up incorrectly in L1.\n\t */\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n}\n\n/*\n * A part of what we need to when the nested L2 guest exits and we want to\n * run its L1 parent, is to reset L1's guest state to the host state specified\n * in vmcs12.\n * This function is to be called not only on normal nested exit, but also on\n * a nested entry failure, as explained in Intel's spec, 3B.23.7 (\"VM-Entry\n * Failures During or After Loading Guest State\").\n * This function should be called when the active VMCS is L1's (vmcs01).\n */\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tstruct kvm_segment seg;\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->host_ia32_efer;\n\telse if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->host_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->host_rip);\n\tvmx_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\t/*\n\t * Note that calling vmx_set_cr0 is important, even if cr0 hasn't\n\t * actually changed, because it depends on the current state of\n\t * fpu_active (which may have changed).\n\t * Note that vmx_set_cr0 refers to efer set above.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->host_cr0);\n\t/*\n\t * If we did fpu_activate()/fpu_deactivate() during L2's run, we need\n\t * to apply the same changes to L1's vmcs. We just set cr0 correctly,\n\t * but we also need to update cr0_guest_host_mask and exception_bitmap.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = (vcpu->fpu_active ? X86_CR0_TS : 0);\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/*\n\t * Note that CR4_GUEST_HOST_MASK is already set in the original vmcs01\n\t * (KVM doesn't change it)- no reason to call set_cr4_guest_host_mask();\n\t */\n\tvcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);\n\tkvm_set_cr4(vcpu, vmcs12->host_cr4);\n\n\tnested_ept_uninit_mmu_context(vcpu);\n\n\tkvm_set_cr3(vcpu, vmcs12->host_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = kvm_inject_page_fault;\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->host_idtr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->host_gdtr_base);\n\n\t/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_CLEAR_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->host_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->host_ia32_pat;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tvmcs_write64(GUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\tvmcs12->host_ia32_perf_global_ctrl);\n\n\t/* Set L1 segment info according to Intel SDM\n\t    27.5.2 Loading Host Segment and Descriptor-Table Registers */\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.selector = vmcs12->host_cs_selector,\n\t\t.type = 11,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.g = 1\n\t};\n\tif (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tseg.l = 1;\n\telse\n\t\tseg.db = 1;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_CS);\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.type = 3,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.db = 1,\n\t\t.g = 1\n\t};\n\tseg.selector = vmcs12->host_ds_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_DS);\n\tseg.selector = vmcs12->host_es_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_ES);\n\tseg.selector = vmcs12->host_ss_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_SS);\n\tseg.selector = vmcs12->host_fs_selector;\n\tseg.base = vmcs12->host_fs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_FS);\n\tseg.selector = vmcs12->host_gs_selector;\n\tseg.base = vmcs12->host_gs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_GS);\n\tseg = (struct kvm_segment) {\n\t\t.base = vmcs12->host_tr_base,\n\t\t.limit = 0x67,\n\t\t.selector = vmcs12->host_tr_selector,\n\t\t.type = 11,\n\t\t.present = 1\n\t};\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_TR);\n\n\tkvm_set_dr(vcpu, 7, 0x400);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n}\n\n/*\n * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1\n * and modify vmcs12 to make it see what it would expect to see there if\n * L2 was its real guest. Must only be called when in L2 (is_guest_mode())\n */\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t       exit_qualification);\n\n\tvmx_load_vmcs01(vcpu);\n\n\tif ((exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t    && nested_exit_intr_ack_set(vcpu)) {\n\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\tWARN_ON(irq < 0);\n\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t}\n\n\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t       KVM_ISA_VMX);\n\n\tvm_entry_controls_init(vmx, vmcs_read32(VM_ENTRY_CONTROLS));\n\tvm_exit_controls_init(vmx, vmcs_read32(VM_EXIT_CONTROLS));\n\tvmx_segment_cache_clear(vmx);\n\n\t/* if no vmcs02 cache requested, remove the one we used */\n\tif (VMCS02_POOL_SIZE == 0)\n\t\tnested_free_vmcs02(vmx, vmx->nested.current_vmptr);\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t/* Update TSC_OFFSET if TSC was changed while L2 ran */\n\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\t/* This is needed for same reason as it was needed in prepare_vmcs02 */\n\tvmx->host_rsp = 0;\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_vcpu_reload_apic_access_page(vcpu);\n\n\t/*\n\t * Exiting from L2 to L1, we're now back to L1 which thinks it just\n\t * finished a VMLAUNCH or VMRESUME instruction, so we need to set the\n\t * success or failure flag accordingly.\n\t */\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->fail = 0;\n\t\tnested_vmx_failValid(vcpu, vmcs_read32(VM_INSTRUCTION_ERROR));\n\t} else\n\t\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tvmx->nested.sync_shadow_vmcs = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\n/*\n * Forcibly leave nested mode in order to be able to reset the VCPU later on.\n */\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\tfree_nested(to_vmx(vcpu));\n}\n\n/*\n * L1's failure to enter L2 is a subset of a normal exit, as explained in\n * 23.7 \"VM-entry failures during or after loading guest state\" (this also\n * lists the acceptable exit-reason and exit-qualification parameters).\n * It should only be called before L2 actually succeeded to run, and when\n * vmcs01 is current (it doesn't leave_guest_mode() or switch vmcss).\n */\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (ple_gap)\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.hardware_setup = hardware_setup,\n\t.hardware_unsetup = hardware_unsetup,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_enable = hardware_enable,\n\t.hardware_disable = hardware_disable,\n\t.cpu_has_accelerated_tpr = report_flexpriority,\n\n\t.vcpu_create = vmx_create_vcpu,\n\t.vcpu_free = vmx_free_vcpu,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_guest_switch = vmx_save_host_state,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_db_bp_intercept = update_exception_bitmap,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = vmx_decache_cr0_guest_bits,\n\t.decache_cr3 = vmx_decache_cr3,\n\t.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.set_cr3 = vmx_set_cr3,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.get_dr6 = vmx_get_dr6,\n\t.set_dr6 = vmx_set_dr6,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\t.fpu_deactivate = vmx_fpu_deactivate,\n\n\t.tlb_flush = vmx_flush_tlb,\n\n\t.run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.set_irq = vmx_inject_irq,\n\t.set_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = vmx_set_virtual_x2apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.vm_has_apicv = vmx_vm_has_apicv,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_posted_interrupt = vmx_deliver_posted_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.get_tdp_level = get_ept_level,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.get_lpage_level = vmx_get_lpage_level,\n\n\t.cpuid_update = vmx_cpuid_update,\n\n\t.rdtscp_supported = vmx_rdtscp_supported,\n\t.invpcid_supported = vmx_invpcid_supported,\n\n\t.set_supported_cpuid = vmx_set_supported_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.set_tsc_khz = vmx_set_tsc_khz,\n\t.read_tsc_offset = vmx_read_tsc_offset,\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\t.adjust_tsc_offset = vmx_adjust_tsc_offset,\n\t.compute_tsc_offset = vmx_compute_tsc_offset,\n\t.read_l1_tsc = vmx_read_l1_tsc,\n\n\t.set_tdp_cr3 = vmx_set_cr3,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_external_intr = vmx_handle_external_intr,\n\t.mpx_supported = vmx_mpx_supported,\n\n\t.check_nested_events = vmx_check_nested_events,\n\n\t.sched_in = vmx_sched_in,\n};\n\nstatic int __init vmx_init(void)\n{\n\tint r, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tvmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_a)\n\t\treturn -ENOMEM;\n\n\tr = -ENOMEM;\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_b)\n\t\tgoto out;\n\n\tvmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy)\n\t\tgoto out1;\n\n\tvmx_msr_bitmap_legacy_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy_x2apic)\n\t\tgoto out2;\n\n\tvmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode)\n\t\tgoto out3;\n\n\tvmx_msr_bitmap_longmode_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode_x2apic)\n\t\tgoto out4;\n\tvmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmread_bitmap)\n\t\tgoto out5;\n\n\tvmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmwrite_bitmap)\n\t\tgoto out6;\n\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tr = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\tgoto out7;\n\n#ifdef CONFIG_KEXEC\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tif (enable_apicv) {\n\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n\n\t\t/* According SDM, in x2apic mode, the whole id reg is used.\n\t\t * But in KVM, it only use the highest eight bits. Need to\n\t\t * intercept it */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n\t\t/* TMCCT */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n\t\t/* TPR */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n\t\t/* EOI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n\t\t/* SELF-IPI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n\t}\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\treturn 0;\n\nout7:\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\nout6:\n\tfree_page((unsigned long)vmx_vmread_bitmap);\nout5:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\nout4:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\nout3:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\nout2:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\nout1:\n\tfree_page((unsigned long)vmx_io_bitmap_b);\nout:\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\treturn r;\n}\n\nstatic void __exit vmx_exit(void)\n{\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\n\tfree_page((unsigned long)vmx_io_bitmap_b);\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\n\tfree_page((unsigned long)vmx_vmread_bitmap);\n\n#ifdef CONFIG_KEXEC\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n}\n\nmodule_init(vmx_init)\nmodule_exit(vmx_exit)\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <trace/events/kvm.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/fpu-internal.h> /* Ugh! */\n#include <asm/xcr.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n\n#define emul_to_vcpu(ctxt) \\\n\tcontainer_of(ctxt, struct kvm_vcpu, arch.emulate_ctxt)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\n#define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM\n#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\n\nstruct kvm_x86_ops *kvm_x86_ops;\nEXPORT_SYMBOL_GPL(kvm_x86_ops);\n\nstatic bool ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nunsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nbool kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\nstatic bool backwards_tsc_observed = false;\n\n#define KVM_NR_SHARED_MSRS 16\n\nstruct kvm_shared_msrs_global {\n\tint nr;\n\tu32 msrs[KVM_NR_SHARED_MSRS];\n};\n\nstruct kvm_shared_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_shared_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_NR_SHARED_MSRS];\n};\n\nstatic struct kvm_shared_msrs_global __read_mostly shared_msrs_global;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstruct kvm_stats_debugfs_item debugfs_entries[] = {\n\t{ \"pf_fixed\", VCPU_STAT(pf_fixed) },\n\t{ \"pf_guest\", VCPU_STAT(pf_guest) },\n\t{ \"tlb_flush\", VCPU_STAT(tlb_flush) },\n\t{ \"invlpg\", VCPU_STAT(invlpg) },\n\t{ \"exits\", VCPU_STAT(exits) },\n\t{ \"io_exits\", VCPU_STAT(io_exits) },\n\t{ \"mmio_exits\", VCPU_STAT(mmio_exits) },\n\t{ \"signal_exits\", VCPU_STAT(signal_exits) },\n\t{ \"irq_window\", VCPU_STAT(irq_window_exits) },\n\t{ \"nmi_window\", VCPU_STAT(nmi_window_exits) },\n\t{ \"halt_exits\", VCPU_STAT(halt_exits) },\n\t{ \"halt_wakeup\", VCPU_STAT(halt_wakeup) },\n\t{ \"hypercalls\", VCPU_STAT(hypercalls) },\n\t{ \"request_irq\", VCPU_STAT(request_irq_exits) },\n\t{ \"irq_exits\", VCPU_STAT(irq_exits) },\n\t{ \"host_state_reload\", VCPU_STAT(host_state_reload) },\n\t{ \"efer_reload\", VCPU_STAT(efer_reload) },\n\t{ \"fpu_reload\", VCPU_STAT(fpu_reload) },\n\t{ \"insn_emulation\", VCPU_STAT(insn_emulation) },\n\t{ \"insn_emulation_fail\", VCPU_STAT(insn_emulation_fail) },\n\t{ \"irq_injections\", VCPU_STAT(irq_injections) },\n\t{ \"nmi_injections\", VCPU_STAT(nmi_injections) },\n\t{ \"mmu_shadow_zapped\", VM_STAT(mmu_shadow_zapped) },\n\t{ \"mmu_pte_write\", VM_STAT(mmu_pte_write) },\n\t{ \"mmu_pte_updated\", VM_STAT(mmu_pte_updated) },\n\t{ \"mmu_pde_zapped\", VM_STAT(mmu_pde_zapped) },\n\t{ \"mmu_flooded\", VM_STAT(mmu_flooded) },\n\t{ \"mmu_recycled\", VM_STAT(mmu_recycled) },\n\t{ \"mmu_cache_miss\", VM_STAT(mmu_cache_miss) },\n\t{ \"mmu_unsync\", VM_STAT(mmu_unsync) },\n\t{ \"remote_tlb_flush\", VM_STAT(remote_tlb_flush) },\n\t{ \"largepages\", VM_STAT(lpages) },\n\t{ NULL }\n};\n\nu64 __read_mostly host_xcr0;\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\t/* we need ensured the shared_msr_global have been updated */\n\tsmp_wmb();\n}\nEXPORT_SYMBOL_GPL(kvm_define_shared_msr);\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}\n\nvoid kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn;\n\tsmsr->values[slot].curr = value;\n\twrmsrl(shared_msrs_global.msrs[slot], value);\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_set_shared_msr);\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_state = vcpu->arch.apic_base &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 new_state = msr_info->data &\n\t\t(MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |\n\t\t0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);\n\n\tif (!msr_info->host_initiated &&\n\t    ((msr_info->data & reserved_bits) != 0 ||\n\t     new_state == X2APIC_ENABLE ||\n\t     (new_state == MSR_IA32_APICBASE_ENABLE &&\n\t      old_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE)) ||\n\t     (new_state == (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE) &&\n\t      old_state == 0)))\n\t\treturn 1;\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\nasmlinkage __visible void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\n#define EXCPT_FAULT\t\t0\n#define EXCPT_TRAP\t\t1\n#define EXCPT_ABORT\t\t2\n#define EXCPT_INTERRUPT\t\t3\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\nstatic bool kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n\n\treturn fault->nested_page_fault;\n}\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\n/*\n * This function will be used to read from the physical memory of the currently\n * running guest. The difference to kvm_read_guest_page is that this function\n * can read from guest physical or from the guest's guest physical memory.\n */\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tstruct x86_exception exception;\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access, &exception);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_read_guest_page(vcpu->kvm, real_gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page_mmu);\n\nint kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}\n\n/*\n * Load the pae pdptrs.  Return true is they are all valid.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] & vcpu->arch.mmu.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP |\n\t\t\t\t    X86_CR0_CD | X86_CR0_NW;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}\n\nint __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XSTATE_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XSTATE_BNDREGS)) != (!(xcr0 & XSTATE_BNDCSR)))\n\t\treturn 1;\n\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XSTATE_EXTEND_MASK)\n\t\tkvm_update_cpuid(vcpu);\n\treturn 0;\n}\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_xcr);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smap(vcpu) && (cr4 & X86_CR4_SMAP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_SMAP)\n\t\tupdate_permission_bitmask(vcpu, vcpu->arch.walk_mmu, false);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tint res;\n\n\tres = __kvm_set_dr(vcpu, dr, val);\n\tif (res > 0)\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\telse if (res < 0)\n\t\tkvm_inject_gp(vcpu, 0);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nstatic int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tif (_kvm_get_dr(vcpu, dr, val)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_read_pmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kvm_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * This list is modified at module load time to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in the beginning of the list.\n */\n\n#define KVM_SAVE_MSRS_BEGIN\t12\nstatic u32 msrs_to_save[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS\n};\n\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs[] = {\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n};\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t/*\n\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n\t\t * non-canonical address is written on Intel but not on\n\t\t * AMD (which ignores the top 32-bits, because it does\n\t\t * not implement 64-bit SYSENTER).\n\t\t *\n\t\t * 64-bit code should hence be able to write a non-canonical\n\t\t * value on AMD.  Making the address canonical ensures that\n\t\t * vmentry does not fail on Intel after writing a non-canonical\n\t\t * value, and that something deterministic happens if the guest\n\t\t * invokes 64-bit SYSENTER.\n\t\t */\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr);\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct { /* extract of a clocksource struct */\n\t\tint vclock_mode;\n\t\tcycle_t\tcycle_last;\n\t\tcycle_t\tmask;\n\t\tu32\tmult;\n\t\tu32\tshift;\n\t} clock;\n\n\tu64\t\tboot_ns;\n\tu64\t\tnsec_base;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr.base_mono, tk->offs_boot));\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr.mask;\n\tvdata->clock.mult\t\t= tk->tkr.mult;\n\tvdata->clock.shift\t\t= tk->tkr.shift;\n\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr.xtime_nsec;\n\n\twrite_seqcount_end(&vdata->seq);\n}\n#endif\n\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tuint32_t quotient, remainder;\n\n\t/* Don't try to replace with do_div(), this one calculates\n\t * \"(dividend << 32) / divisor\" */\n\t__asm__ ( \"divl %4\"\n\t\t  : \"=a\" (quotient), \"=d\" (remainder)\n\t\t  : \"0\" (0), \"1\" (dividend), \"r\" (divisor) );\n\treturn quotient;\n}\n\nstatic void kvm_get_time_scale(uint32_t scaled_khz, uint32_t base_khz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_khz * 1000LL;\n\tscaled64 = scaled_khz * 1000LL;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_khz %u => %u, shift %d, mul %u\\n\",\n\t\t __func__, base_khz, scaled_khz, shift, *pmultiplier);\n}\n\nstatic inline u64 get_kernel_ns(void)\n{\n\treturn ktime_get_boot_ns();\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nunsigned long max_tsc_khz;\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 this_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (this_tsc_khz == 0)\n\t\treturn;\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(this_tsc_khz, NSEC_PER_SEC / 1000,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = this_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (this_tsc_khz < thresh_lo || this_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", this_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\tkvm_x86_ops->set_tsc_khz(vcpu, this_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\nvoid kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tbool do_request = false;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\tif (vcpus_matched && gtod->clock.vclock_mode == VCLOCK_TSC)\n\t\tif (!ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (!vcpus_matched && ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (do_request)\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\nstatic void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}\n\nvoid kvm_write_tsc(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\ts64 usdiff;\n\tbool matched;\n\tbool already_matched;\n\tu64 data = msr->data;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\tns = get_kernel_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tint faulted = 0;\n\n\t\t/* n.b - signed multiplication and division required */\n\t\tusdiff = data - kvm->arch.last_tsc_write;\n#ifdef CONFIG_X86_64\n\t\tusdiff = (usdiff * 1000) / vcpu->arch.virtual_tsc_khz;\n#else\n\t\t/* do_div() only does unsigned */\n\t\tasm(\"1: idivl %[divisor]\\n\"\n\t\t    \"2: xor %%edx, %%edx\\n\"\n\t\t    \"   movl $0, %[faulted]\\n\"\n\t\t    \"3:\\n\"\n\t\t    \".section .fixup,\\\"ax\\\"\\n\"\n\t\t    \"4: movl $1, %[faulted]\\n\"\n\t\t    \"   jmp  3b\\n\"\n\t\t    \".previous\\n\"\n\n\t\t_ASM_EXTABLE(1b, 4b)\n\n\t\t: \"=A\"(usdiff), [faulted] \"=r\" (faulted)\n\t\t: \"A\"(usdiff * 1000), [divisor] \"rm\"(vcpu->arch.virtual_tsc_khz));\n\n#endif\n\t\tdo_div(elapsed, 1000);\n\t\tusdiff -= elapsed;\n\t\tif (usdiff < 0)\n\t\t\tusdiff = -usdiff;\n\n\t\t/* idivl overflow => difference is larger than USEC_PER_SEC */\n\t\tif (faulted)\n\t\t\tusdiff = USEC_PER_SEC;\n\t} else\n\t\tusdiff = USEC_PER_SEC; /* disable TSC match window below */\n\n\t/*\n\t * Special case: TSC write with a small delta (1 second) of virtual\n\t * cycle time against real time is interpreted as an attempt to\n\t * synchronize the CPU.\n         *\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (usdiff < USEC_PER_SEC &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t\tpr_debug(\"kvm: matched tsc offset for %llu\\n\", data);\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\t\t\tpr_debug(\"kvm: adjusted tsc offset by %llu\\n\", delta);\n\t\t}\n\t\tmatched = true;\n\t\talready_matched = (vcpu->arch.this_tsc_generation == kvm->arch.cur_tsc_generation);\n\t} else {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = data;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tmatched = false;\n\t\tpr_debug(\"kvm: new tsc generation %llu, clock %llu\\n\",\n\t\t\t kvm->arch.cur_tsc_generation, data);\n\t}\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = data;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\n\tvcpu->arch.last_guest_tsc = data;\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tif (guest_cpuid_has_tsc_adjust(vcpu) && !msr->host_initiated)\n\t\tupdate_ia32_tsc_adjust_msr(vcpu, offset);\n\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tspin_lock(&kvm->arch.pvclock_gtod_sync_lock);\n\tif (!matched) {\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\t} else if (!already_matched) {\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\t}\n\n\tkvm_track_tsc_matching(vcpu);\n\tspin_unlock(&kvm->arch.pvclock_gtod_sync_lock);\n}\n\nEXPORT_SYMBOL_GPL(kvm_write_tsc);\n\n#ifdef CONFIG_X86_64\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret;\n\tu64 last;\n\n\t/*\n\t * Empirically, a fence (of type that depends on the CPU)\n\t * before rdtsc is enough to ensure that rdtsc is ordered\n\t * with respect to loads.  The various CPU manuals are unclear\n\t * as to whether rdtsc can be reordered with later loads,\n\t * but no one has ever seen it happen.\n\t */\n\trdtsc_barrier();\n\tret = (cycle_t)vget_cycles();\n\n\tlast = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a funciton of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}\n\nstatic int do_monotonic_boot(s64 *t, cycle_t *cycle_now)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tns = gtod->nsec_base;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t\tns += gtod->boot_ns;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}\n\n/* returns true if host is using tsc clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\treturn do_monotonic_boot(kernel_ns, cycle_now) == VCLOCK_TSC;\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !backwards_tsc_observed;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, this_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\tthis_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(this_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = native_read_tsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_x86_ops->read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\tif (unlikely(vcpu->hw_tsc_khz != this_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC / 1000, this_tsc_khz,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = this_tsc_khz;\n\t}\n\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/*\n\t * The interface expects us to write an even number signaling that the\n\t * update is finished. Since the guest won't see the intermediate\n\t * state, we just increase by 2 at the end.\n\t */\n\tvcpu->hv_clock.version += 2;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * We need to rate-limit these requests though, as they can\n * considerably slow guests that have a large number of vcpus.\n * The time for a remote vcpu to update its kvmclock is bound\n * by the delay we use to rate-limit the updates.\n */\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvmclock_update_fn(struct work_struct *work)\n{\n\tint i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}\n\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_mtrr_valid);\n\nstatic int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!kvm_mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType) {\n\t\tvcpu->arch.mtrr_state.def_type = data;\n\t\tvcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;\n\t} else if (msr == MSR_MTRRfix64K_00000)\n\t\tp[0] = data;\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\tp[1 + msr - MSR_MTRRfix16K_80000] = data;\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\tp[3 + msr - MSR_MTRRfix4K_C0000] = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pt = data;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_write_guest(kvm, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}\n\nstatic bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int set_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tkvm->arch.hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tkvm->arch.hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\tkvm->arch.hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\tkvm->arch.hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC: {\n\t\tu64 gfn;\n\t\tHV_REFERENCE_TSC_PAGE tsc_ref;\n\t\tmemset(&tsc_ref, 0, sizeof(tsc_ref));\n\t\tkvm->arch.hv_tsc_page = data;\n\t\tif (!(data & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\t\tbreak;\n\t\tgfn = data >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t\tif (kvm_write_guest(kvm, gfn << HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT,\n\t\t\t&tsc_ref, sizeof(tsc_ref)))\n\t\t\treturn 1;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int set_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\tvcpu->arch.hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(vcpu->kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\tvcpu->arch.hv_vapic = data;\n\t\tmark_page_dirty(vcpu->kvm, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, gfn_to_gpa(gfn) | KVM_MSR_ENABLED))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}\n\nstatic void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tvcpu->arch.st.steal.steal += vcpu->arch.st.accum_steal;\n\tvcpu->arch.st.steal.version += 2;\n\tvcpu->arch.st.accum_steal = 0;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tdata &= ~(u64)0x40000;  /* ignore Mc status write enable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr_index, pdata);\n}\n\nstatic int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.def_type +\n\t\t\t (vcpu->arch.mtrr_state.enabled << 10);\n\telse if (msr == MSR_MTRRfix64K_00000)\n\t\t*pdata = p[0];\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\t*pdata = p[1 + msr - MSR_MTRRfix16K_80000];\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\t*pdata = p[3 + msr - MSR_MTRRfix4K_C0000];\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pdata = *pt;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = kvm->arch.hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = kvm->arch.hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT: {\n\t\tdata =\n\t\t     div_u64(get_kernel_ns() + kvm->arch.kvmclock_offset, 100);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = kvm->arch.hv_tsc_page;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm) {\n\t\t\tif (v == vcpu) {\n\t\t\t\tdata = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = vcpu->arch.hv_vapic;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tdata = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\t\tdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn get_msr_mtrr(vcpu, msr, pdata);\n\tcase 0xcd: /* fsb frequency */\n\t\tdata = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tdata = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tdata = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tdata = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tdata = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tdata = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tdata = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tdata |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tdata = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tdata = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tdata = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tdata = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tdata = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tdata = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr, pdata);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tdata = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = get_msr_hyperv_pw(vcpu, msr, pdata);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn get_msr_hyperv(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tdata = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr);\n\t\t\tdata = 0;\n\t\t}\n\t\tbreak;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nint kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\t\tr = boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + ARRAY_SIZE(emulated_msrs);\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t ARRAY_SIZE(emulated_msrs) * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = native_read_tsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    kvm_vcpu_has_lapic(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\t_kvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tvcpu->arch.guest_xstate_size);\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] &=\n\t\t\tvcpu->arch.guest_supported_xcr0 | XSTATE_FPSSE;\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tsizeof(struct i387_fxsave_struct));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXSTATE_FPSSE;\n\t}\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~kvm_supported_xcr0())\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tguest_xsave->region, vcpu->arch.guest_xstate_size);\n\t} else {\n\t\tif (xstate_bv & ~XSTATE_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tguest_xsave->region, sizeof(struct i387_fxsave_struct));\n\t}\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, kvm_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tkvm_set_tsc_khz(vcpu, user_tsc_khz);\n\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}\n\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps, &kvm->arch.vpit->pit_state, sizeof(struct kvm_pit_state));\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0, start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently.  So, to avoid losing data, we keep the following order for\n * each bit:\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Flush TLB's if needed.\n *   4. Copy the snapshot to the userspace.\n *\n * Between 2 and 3, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page will be reported dirty at\n * step 4 using the snapshot taken before and step 3 ensures that successive\n * writes will be logged for the next call.\n */\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tint r;\n\tstruct kvm_memory_slot *memslot;\n\tunsigned long n, i;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool is_dirty = false;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = -EINVAL;\n\tif (log->slot >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, log->slot);\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\n\t\tis_dirty = true;\n\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\toffset = i * BITS_PER_LONG;\n\t\tkvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/* See the comments in kvm_mmu_slot_remove_write_access(). */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * All the TLBs can be flushed out of mmu lock, see the comments in\n\t * kvm_mmu_slot_remove_write_access().\n\t */\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\n\tr = 0;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_master);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_slave);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_eclr);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.  We could work around this\n\t\t * in VMX with the generic MSR save/load machinery, but it\n\t\t * is not really worthwhile since it will really only\n\t\t * happen with nested virtualization.\n\t\t */\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_read_guest_page(vcpu->kvm, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t  offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_read_guest_page(vcpu->kvm, gpa >> PAGE_SHIFT, val,\n\t\t\t\t  offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}\n\nint kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t vcpu->arch.access, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nint emulator_read_write(struct x86_emulate_ctxt *ctxt, unsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nint emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define CMPXCHG_TYPE(t, ptr, old, new) \\\n\t(cmpxchg((t *)(ptr), *(t *)(old), *(t *)(new)) == *(t *)(old))\n\n#ifdef CONFIG_X86_64\n#  define CMPXCHG64(ptr, old, new) CMPXCHG_TYPE(u64, ptr, old, new)\n#else\n#  define CMPXCHG64(ptr, old, new) \\\n\t(cmpxchg64((u64 *)(ptr), *(u64 *)(old), *(u64 *)(new)) == *(u64 *)(old))\n#endif\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = gfn_to_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tmark_page_dirty(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tkvm_mmu_pte_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\ttrace_kvm_pio(KVM_PIO_IN, port, size, count, vcpu->arch.pio_data);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd(emul_to_vcpu(ctxt));\n}\n\nint emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long *dest)\n{\n\treturn _kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nint emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}\n\nstatic int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\treturn kvm_pmu_check_pmc(emul_to_vcpu(ctxt), pmc);\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_read_pmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}\n\nstatic void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}\n\nstatic void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_propagate_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tctxt->guest_mode = is_guest_mode(vcpu);\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nint kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tpfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |\n\t\t\t\t\t\t  DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_emulate_instruction);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio_out);\n\nstatic void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvmclock_cpu_notifier_block = {\n\t.notifier_call  = kvmclock_cpu_notifier,\n\t.priority = -INT_MAX\n};\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\n\tcpu_notifier_register_begin();\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\n\t__register_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tcpu_notifier_register_done();\n\n}\n\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, current_vcpu);\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}\n\nstatic int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}\n\nstatic unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.is_in_guest\t\t= kvm_is_in_guest,\n\t.is_user_mode\t\t= kvm_is_user_mode,\n\t.get_guest_ip\t\t= kvm_get_guest_ip,\n};\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_before_handle_nmi);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_after_handle_nmi);\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\n\tkvm_x86_ops = ops;\n\tkvm_init_msr_list();\n\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tlongmode = is_64_bit_mode(vcpu);\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HV_X64_HV_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tif (longmode) {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t} else {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, ret >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret & 0xffffffff);\n\t}\n\n\treturn 1;\n}\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, 0, &lapic_irq, NULL);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}\n\n/*\n * Check if userspace requested an interrupt window, and that the\n * interrupt window is open.\n *\n * No need to exit to userspace if we already have an interrupt queued.\n */\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n\t\tvcpu->run->request_interrupt_window &&\n\t\tkvm_arch_interrupt_allowed(vcpu));\n}\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t\t!kvm_event_needs_reinjection(vcpu);\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)\n{\n\tint r;\n\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending) {\n\t\tif (kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\t}\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\t/*\n\t\t * Because interrupts can be injected asynchronously, we are\n\t\t * calling check_nested_events again here to avoid a race condition.\n\t\t * See https://lkml.org/lkml/2014/7/2/60 for discussion about this\n\t\t * proposal and current concerns.  Perhaps we should be setting\n\t\t * KVM_REQ_EVENT only on certain events and not unconditionally?\n\t\t */\n\t\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {\n\t\t\tr = kvm_x86_ops->check_nested_events(vcpu, req_int_win);\n\t\t\tif (r != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\tu32 tmr[8];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tmemset(eoi_exit_bitmap, 0, 32);\n\tmemset(tmr, 0, 32);\n\n\tkvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n\tkvm_apic_update_tmr(vcpu, tmr);\n}\n\nstatic void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tkvm_x86_ops->tlb_flush(vcpu);\n}\n\nvoid kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page = NULL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\treturn;\n\n\tif (!kvm_x86_ops->set_apic_access_page_addr)\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tkvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_reload_apic_access_page);\n\nvoid kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}\n\n/*\n * Returns 1 to let __vcpu_run() continue the guest execution loop without\n * exiting to the userspace.  Otherwise, the value will be returned to the\n * userspace.\n */\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse if (vcpu->arch.nmi_pending)\n\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tint i;\n\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n\nstatic int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tcond_resched();\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (!tsk_used_math(current) && init_fpu(current))\n\t\treturn -ENOMEM;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = __vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cs_db_l_bits);\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!kvm_vcpu_has_lapic(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct msr_data apic_base_msr;\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_db_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint fx_init(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = fpu_alloc(&vcpu->arch.guest_fpu);\n\tif (err)\n\t\treturn err;\n\n\tfpu_finit(&vcpu->arch.guest_fpu);\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XSTATE_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fx_init);\n\nstatic void fx_free(struct kvm_vcpu *vcpu)\n{\n\tfpu_free(&vcpu->arch.guest_fpu);\n}\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tkvm_put_guest_xcr0(vcpu);\n\n\tif (!vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\tvcpu->guest_fpu_loaded = 0;\n\tfpu_save_init(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\ttrace_kvm_fpu(0);\n}\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\treturn kvm_x86_ops->vcpu_create(kvm, id);\n}\n\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct msr_data msr;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tkvm_pmu_reset(vcpu);\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\n\nint kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = native_read_tsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tbackwards_tsc_observed = true;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void)\n{\n\tkvm_x86_ops->hardware_disable();\n\tdrop_user_return_notifiers();\n}\n\nint kvm_arch_hardware_setup(void)\n{\n\treturn kvm_x86_ops->hardware_setup();\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}\n\nvoid kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}\n\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\n}\n\nstruct static_key kvm_no_apic_vcpu __read_mostly;\n\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tr = fx_init(vcpu);\n\tif (r)\n\t\tgoto fail_free_wbinvd_dirty_mask;\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}\n\nvoid kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tkvm_x86_ops->sched_in(vcpu, cpu);\n}\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\treturn 0;\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tstruct kvm_userspace_memory_region mem;\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = TSS_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\t}\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}\n\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\t/*\n\t * Only private memory slots need to be mapped here since\n\t * KVM_SET_MEMORY_REGION ioctl is no longer supported.\n\t */\n\tif ((memslot->id >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_CREATE)) {\n\t\tunsigned long userspace_addr;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\tuserspace_addr = vm_mmap(NULL, 0, memslot->npages * PAGE_SIZE,\n\t\t\t\t\t PROT_READ | PROT_WRITE,\n\t\t\t\t\t MAP_SHARED | MAP_ANONYMOUS, 0);\n\n\t\tif (IS_ERR((void *)userspace_addr))\n\t\t\treturn PTR_ERR((void *)userspace_addr);\n\n\t\tmemslot->userspace_addr = userspace_addr;\n\t}\n\n\treturn 0;\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tenum kvm_mr_change change)\n{\n\n\tint nr_mmu_pages = 0;\n\n\tif ((mem->slot >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_DELETE)) {\n\t\tint ret;\n\n\t\tret = vm_munmap(old->userspace_addr,\n\t\t\t\told->npages * PAGE_SIZE);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"kvm_vm_ioctl_set_memory_region: \"\n\t\t\t       \"failed to munmap memory\\n\");\n\t}\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t/*\n\t * Write protect all pages for dirty logging.\n\t *\n\t * All the sptes including the large sptes which point to this\n\t * slot are set to readonly. We can not create any new large\n\t * spte on this slot until the end of the logging.\n\t *\n\t * See the comments in fast_page_fault().\n\t */\n\tif ((change != KVM_MR_DELETE) && (mem->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_slot_remove_write_access(kvm, mem->slot);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted)\n\t\t|| !list_empty_careful(&vcpu->async_pf.done)\n\t\t|| kvm_apic_has_events(vcpu)\n\t\t|| vcpu->arch.pv.pv_unhalted\n\t\t|| atomic_read(&vcpu->arch.nmi_queued) ||\n\t\t(kvm_arch_interrupt_allowed(vcpu) &&\n\t\t kvm_cpu_has_interrupt(vcpu));\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\tunsigned long current_rip = kvm_rip_read(vcpu) +\n\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\treturn current_rip == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n}\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window);\n"], "filenames": ["arch/x86/include/asm/kvm_host.h", "arch/x86/kvm/svm.c", "arch/x86/kvm/vmx.c", "arch/x86/kvm/x86.c"], "buggy_code_start_loc": [991, 3254, 5294, 990], "buggy_code_end_loc": [991, 3255, 5295, 999], "fixing_code_start_loc": [992, 3254, 5294, 989], "fixing_code_end_loc": [1006, 3255, 5295, 1025], "type": "NVD-CWE-noinfo", "message": "The WRMSR processing functionality in the KVM subsystem in the Linux kernel through 3.17.2 does not properly handle the writing of a non-canonical address to a model-specific register, which allows guest OS users to cause a denial of service (host OS crash) by leveraging guest OS privileges, related to the wrmsr_interception function in arch/x86/kvm/svm.c and the handle_wrmsr function in arch/x86/kvm/vmx.c.", "other": {"cve": {"id": "CVE-2014-3610", "sourceIdentifier": "secalert@redhat.com", "published": "2014-11-10T11:55:06.330", "lastModified": "2023-02-13T00:41:04.027", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The WRMSR processing functionality in the KVM subsystem in the Linux kernel through 3.17.2 does not properly handle the writing of a non-canonical address to a model-specific register, which allows guest OS users to cause a denial of service (host OS crash) by leveraging guest OS privileges, related to the wrmsr_interception function in arch/x86/kvm/svm.c and the handle_wrmsr function in arch/x86/kvm/vmx.c."}, {"lang": "es", "value": "La funcionalidad de procesamiento WRMSR en el subsistema KVM en el kernel de Linux hasta 3.17.2 no maneja debidamente la escritura de direcciones no can\u00f3nicas en un registro especifico a modelos, lo que permite a usuarios del sistema operativo invitado causar una denegaci\u00f3n de servicio (ca\u00edda del sistema operativo anfitri\u00f3n) mediante el aprovechamiento de los privilegios del sistema operativo invitado, relacionado con la funci\u00f3n wrmsr_interception en arch/x86/kvm/svm.c y la funci\u00f3n handle_wrmsr en arch/x86/kvm/vmx.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.17.2", "matchCriteriaId": "0FA12E64-02D2-4452-A4C8-7B636EC1BCBD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:evergreen:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "CCE4D64E-8C4B-4F21-A9B0-90637C85C1D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "C202F75B-221A-40BB-8A0D-451335B39937"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=854e8bb1aa06c578c2c9145fa6bfe3680ef63b23", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0869.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3060", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/10/24/9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/70742", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2394-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2417-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2418-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2491-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1144883", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23"}}