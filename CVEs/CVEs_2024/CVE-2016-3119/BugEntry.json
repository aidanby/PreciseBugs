{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c */\n/*\n * Copyright (C) 2016 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in\n *   the documentation and/or other materials provided with the\n *   distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_principal.h\"\n#include \"princ_xdr.h\"\n#include \"ldap_tkt_policy.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n#include <kadm5/admin.h>\n#include <time.h>\n\nextern char* principal_attributes[];\nextern char* max_pwd_life_attr[];\n\nstatic char *\ngetstringtime(krb5_timestamp);\n\nkrb5_error_code\nberval2tl_data(struct berval *in, krb5_tl_data **out)\n{\n    *out = (krb5_tl_data *) malloc (sizeof (krb5_tl_data));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->tl_data_length = in->bv_len - 2;\n    (*out)->tl_data_contents =  (krb5_octet *) malloc\n        ((*out)->tl_data_length * sizeof (krb5_octet));\n    if ((*out)->tl_data_contents == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    UNSTORE16_INT (in->bv_val, (*out)->tl_data_type);\n    memcpy ((*out)->tl_data_contents, in->bv_val + 2, (*out)->tl_data_length);\n\n    return 0;\n}\n\n/*\n * look up a principal in the directory.\n */\n\nkrb5_error_code\nkrb5_ldap_get_principal(krb5_context context, krb5_const_principal searchfor,\n                        unsigned int flags, krb5_db_entry **entry_ptr)\n{\n    char                        *user=NULL, *filter=NULL, *filtuser=NULL;\n    unsigned int                tree=0, ntrees=1, princlen=0;\n    krb5_error_code             tempst=0, st=0;\n    char                        **values=NULL, **subtree=NULL, *cname=NULL;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_principal              cprinc=NULL;\n    krb5_boolean                found=FALSE;\n    krb5_db_entry               *entry = NULL;\n\n    *entry_ptr = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    if (searchfor == NULL)\n        return EINVAL;\n\n    dal_handle = context->dal_handle;\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;\n\n    CHECK_LDAP_HANDLE(ldap_context);\n\n    if (!is_principal_in_realm(ldap_context, searchfor)) {\n        st = KRB5_KDB_NOENTRY;\n        k5_setmsg(context, st, _(\"Principal does not belong to realm\"));\n        goto cleanup;\n    }\n\n    if ((st=krb5_unparse_name(context, searchfor, &user)) != 0)\n        goto cleanup;\n\n    if ((st=krb5_ldap_unparse_principal_name(user)) != 0)\n        goto cleanup;\n\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    princlen = strlen(FILTER) + strlen(filtuser) + 2 + 1;  /* 2 for closing brackets */\n    if ((filter = malloc(princlen)) == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    snprintf(filter, princlen, FILTER\"%s))\", filtuser);\n\n    if ((st = krb5_get_subtree_info(ldap_context, &subtree, &ntrees)) != 0)\n        goto cleanup;\n\n    GET_HANDLE();\n    for (tree=0; tree < ntrees && !found; ++tree) {\n\n        LDAP_SEARCH(subtree[tree], ldap_context->lrparams->search_scope, filter, principal_attributes);\n        for (ent=ldap_first_entry(ld, result); ent != NULL && !found; ent=ldap_next_entry(ld, ent)) {\n\n            /* get the associated directory user information */\n            if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                int i;\n\n                /* a wild-card in a principal name can return a list of kerberos principals.\n                 * Make sure that the correct principal is returned.\n                 * NOTE: a principalname k* in ldap server will return all the principals starting with a k\n                 */\n                for (i=0; values[i] != NULL; ++i) {\n                    if (strcmp(values[i], user) == 0) {\n                        found = TRUE;\n                        break;\n                    }\n                }\n                ldap_value_free(values);\n\n                if (!found) /* no matching principal found */\n                    continue;\n            }\n\n            if ((values=ldap_get_values(ld, ent, \"krbcanonicalname\")) != NULL) {\n                if (values[0] && strcmp(values[0], user) != 0) {\n                    /* We matched an alias, not the canonical name. */\n                    if (flags & KRB5_KDB_FLAG_ALIAS_OK) {\n                        st = krb5_ldap_parse_principal_name(values[0], &cname);\n                        if (st != 0)\n                            goto cleanup;\n                        st = krb5_parse_name(context, cname, &cprinc);\n                        if (st != 0)\n                            goto cleanup;\n                    } else /* No canonicalization, so don't return aliases. */\n                        found = FALSE;\n                }\n                ldap_value_free(values);\n                if (!found)\n                    continue;\n            }\n\n            entry = k5alloc(sizeof(*entry), &st);\n            if (entry == NULL)\n                goto cleanup;\n            if ((st = populate_krb5_db_entry(context, ldap_context, ld, ent,\n                                             cprinc ? cprinc : searchfor,\n                                             entry)) != 0)\n                goto cleanup;\n        }\n        ldap_msgfree(result);\n        result = NULL;\n    } /* for (tree=0 ... */\n\n    if (found) {\n        *entry_ptr = entry;\n        entry = NULL;\n    } else\n        st = KRB5_KDB_NOENTRY;\n\ncleanup:\n    ldap_msgfree(result);\n    krb5_ldap_free_principal(context, entry);\n\n    if (filter)\n        free (filter);\n\n    if (subtree) {\n        for (; ntrees; --ntrees)\n            if (subtree[ntrees-1])\n                free (subtree[ntrees-1]);\n        free (subtree);\n    }\n\n    if (ldap_server_handle)\n        krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    if (cname)\n        free(cname);\n\n    if (cprinc)\n        krb5_free_principal(context, cprinc);\n\n    return st;\n}\n\ntypedef enum{ ADD_PRINCIPAL, MODIFY_PRINCIPAL } OPERATION;\n/*\n * ptype is creating confusions. Additionally the logic\n * surronding ptype is redundunt and can be achevied\n * with the help of dn and containerdn members.\n * so dropping the ptype member\n */\n\ntypedef struct _xargs_t {\n    char           *dn;\n    char           *linkdn;\n    krb5_boolean   dn_from_kbd;\n    char           *containerdn;\n    char           *tktpolicydn;\n}xargs_t;\n\nstatic void\nfree_xargs(xargs_t xargs)\n{\n    if (xargs.dn)\n        free (xargs.dn);\n    if (xargs.linkdn)\n        free(xargs.linkdn);\n    if (xargs.containerdn)\n        free (xargs.containerdn);\n    if (xargs.tktpolicydn)\n        free (xargs.tktpolicydn);\n}\n\nstatic krb5_error_code\nprocess_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], \"=\", &arg_val);\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &xargs->tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n\nkrb5int_access accessor;\n\nstatic krb5_error_code\nasn1_encode_sequence_of_keys(krb5_key_data *key_data, krb5_int16 n_key_data,\n                             krb5_int32 mkvno, krb5_data **code)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data val;\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    val.key_data = key_data;\n    val.n_key_data = n_key_data;\n    val.mkvno = mkvno;\n    val.kvno = key_data[0].key_data_kvno;\n\n    return accessor.asn1_ldap_encode_sequence_of_keys(&val, code);\n}\n\nstatic krb5_error_code\nasn1_decode_sequence_of_keys(krb5_data *in, ldap_seqof_key_data *out)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data *p;\n    int i;\n\n    memset(out, 0, sizeof(*out));\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    err = accessor.asn1_ldap_decode_sequence_of_keys(in, &p);\n    if (err)\n        return err;\n\n    /* Set kvno and key_data_ver in each key_data element. */\n    for (i = 0; i < p->n_key_data; i++) {\n        p->key_data[i].key_data_kvno = p->kvno;\n        /* The decoder sets key_data_ver to 1 if no salt is present, but leaves\n         * it at 0 if salt is present. */\n        if (p->key_data[i].key_data_ver == 0)\n            p->key_data[i].key_data_ver = 2;\n    }\n\n    *out = *p;\n    free(p);\n    return 0;\n}\n\n/*\n * Free a NULL-terminated struct berval *array[] and all its contents.\n * Does not set array to NULL after freeing it.\n */\nstatic void\nfree_berdata(struct berval **array)\n{\n    int i;\n\n    if (array != NULL) {\n        for (i = 0; array[i] != NULL; i++) {\n            if (array[i]->bv_val != NULL)\n                free(array[i]->bv_val);\n            free(array[i]);\n        }\n        free(array);\n    }\n}\n\n/*\n * Encode krb5_key_data into a berval struct for insertion into LDAP.\n */\nstatic krb5_error_code\nencode_keys(krb5_key_data *key_data_in, int n_key_data, krb5_kvno mkvno,\n            struct berval **bval_out)\n{\n    krb5_error_code err = 0;\n    int i;\n    krb5_key_data *key_data = NULL;\n    struct berval *bval = NULL;\n    krb5_data *code;\n\n    *bval_out = NULL;\n    if (n_key_data <= 0) {\n        err = EINVAL;\n        goto cleanup;\n    }\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    bval = k5alloc(sizeof(struct berval), &err);\n    if (bval == NULL)\n        goto cleanup;\n\n    err = asn1_encode_sequence_of_keys(key_data, n_key_data, mkvno, &code);\n    if (err)\n        goto cleanup;\n\n    /* Steal the data pointer from code for bval and discard code. */\n    bval->bv_len = code->length;\n    bval->bv_val = code->data;\n    free(code);\n\n    *bval_out = bval;\n    bval = NULL;\n\ncleanup:\n    free(key_data);\n    free(bval);\n    return err;\n}\n\n/* Decoding ASN.1 encoded key */\nstatic struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data, int n_key_data,\n                         krb5_kvno mkvno)\n{\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 0;\n    int i, j, last;\n    krb5_error_code err = 0;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Find the number of key versions */\n    if (n_key_data > 0) {\n        for (i = 0, num_versions = 1; i < n_key_data - 1; i++) {\n            if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n                num_versions++;\n        }\n    }\n\n    ret = calloc(num_versions + 1, sizeof(struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    ret[num_versions] = NULL;\n\n    /* n_key_data may be 0 if a principal is created without a key. */\n    if (n_key_data == 0)\n        goto cleanup;\n\n    currkvno = key_data[0].key_data_kvno;\n    for (i = 0, last = 0, j = 0; i < n_key_data; i++) {\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            err = encode_keys(key_data + last, (krb5_int16)i - last + 1, mkvno,\n                              &ret[j]);\n            if (err)\n                goto cleanup;\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\n/*\n * Encode a principal's key history for insertion into ldap.\n */\nstatic struct berval **\nkrb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n\n    ret[princ_ent->old_key_len] = NULL;\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\ntl_data2berval (krb5_tl_data *in, struct berval **out)\n{\n    *out = (struct berval *) malloc (sizeof (struct berval));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->bv_len = in->tl_data_length + 2;\n    (*out)->bv_val =  (char *) malloc ((*out)->bv_len);\n    if ((*out)->bv_val == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    STORE16_INT((*out)->bv_val, in->tl_data_type);\n    memcpy ((*out)->bv_val + 2, in->tl_data_contents, in->tl_data_length);\n\n    return 0;\n}\n\n/* Parse the \"require_auth\" string for auth indicators, adding them to the\n * krbPrincipalAuthInd attribute. */\nstatic krb5_error_code\nupdate_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\n\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}\n\nkrb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nkrb5_error_code\nkrb5_read_tkt_policy(krb5_context context, krb5_ldap_context *ldap_context,\n                     krb5_db_entry *entries, char *policy)\n{\n    krb5_error_code             st=0;\n    int                         mask=0, omask=0;\n    int                         tkt_mask=(KDB_MAX_LIFE_ATTR | KDB_MAX_RLIFE_ATTR | KDB_TKT_FLAGS_ATTR);\n    krb5_ldap_policy_params     *tktpoldnparam=NULL;\n\n    if ((st=krb5_get_attributes_mask(context, entries, &mask)) != 0)\n        goto cleanup;\n\n    if ((mask & tkt_mask) == tkt_mask)\n        goto cleanup;\n\n    if (policy != NULL) {\n        st = krb5_ldap_read_policy(context, policy, &tktpoldnparam, &omask);\n        if (st && st != KRB5_KDB_NOENTRY) {\n            k5_prependmsg(context, st, _(\"Error reading ticket policy\"));\n            goto cleanup;\n        }\n\n        st = 0; /* reset the return status */\n    }\n\n    if ((mask & KDB_MAX_LIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_LIFE_ATTR) ==  KDB_MAX_LIFE_ATTR)\n            entries->max_life = tktpoldnparam->maxtktlife;\n        else if (ldap_context->lrparams->max_life)\n            entries->max_life = ldap_context->lrparams->max_life;\n    }\n\n    if ((mask & KDB_MAX_RLIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_RLIFE_ATTR) == KDB_MAX_RLIFE_ATTR)\n            entries->max_renewable_life = tktpoldnparam->maxrenewlife;\n        else if (ldap_context->lrparams->max_renewable_life)\n            entries->max_renewable_life = ldap_context->lrparams->max_renewable_life;\n    }\n\n    if ((mask & KDB_TKT_FLAGS_ATTR) == 0) {\n        if ((omask & KDB_TKT_FLAGS_ATTR) == KDB_TKT_FLAGS_ATTR)\n            entries->attributes = tktpoldnparam->tktflags;\n        else if (ldap_context->lrparams->tktflags)\n            entries->attributes |= ldap_context->lrparams->tktflags;\n    }\n    krb5_ldap_free_policy(context, tktpoldnparam);\n\ncleanup:\n    return st;\n}\n\nstatic void\nfree_ldap_seqof_key_data(ldap_seqof_key_data *keysets, krb5_int16 n_keysets)\n{\n    int i;\n\n    if (keysets == NULL)\n        return;\n\n    for (i = 0; i < n_keysets; i++)\n        k5_free_key_data(keysets[i].n_key_data, keysets[i].key_data);\n    free(keysets);\n}\n\n/*\n * Decode keys from ldap search results.\n *\n * Arguments:\n *  - bvalues\n *      The ldap search results containing the key data.\n *  - mkvno\n *      The master kvno that the keys were encrypted with.\n *  - keysets_out\n *      The decoded keys in a ldap_seqof_key_data struct.  Must be freed using\n *      free_ldap_seqof_key_data.\n *  - n_keysets_out\n *      The number of entries in keys_out.\n *  - total_keys_out\n *      An optional argument that if given will be set to the total number of\n *      keys found throughout all the entries: sum(keys_out.n_key_data)\n *      May be NULL.\n */\nstatic krb5_error_code\ndecode_keys(struct berval **bvalues, ldap_seqof_key_data **keysets_out,\n            krb5_int16 *n_keysets_out, krb5_int16 *total_keys_out)\n{\n    krb5_error_code err = 0;\n    krb5_int16 n_keys, i, ki, total_keys;\n    ldap_seqof_key_data *keysets = NULL;\n\n    *keysets_out = NULL;\n    *n_keysets_out = 0;\n    if (total_keys_out)\n        *total_keys_out = 0;\n\n    /* Precount the number of keys. */\n    for (n_keys = 0, i = 0; bvalues[i] != NULL; i++) {\n        if (bvalues[i]->bv_len > 0)\n            n_keys++;\n    }\n\n    keysets = k5calloc(n_keys, sizeof(ldap_seqof_key_data), &err);\n    if (keysets == NULL)\n        goto cleanup;\n    memset(keysets, 0, n_keys * sizeof(ldap_seqof_key_data));\n\n    for (i = 0, ki = 0, total_keys = 0; bvalues[i] != NULL; i++) {\n        krb5_data in;\n\n        if (bvalues[i]->bv_len == 0)\n            continue;\n        in.length = bvalues[i]->bv_len;\n        in.data = bvalues[i]->bv_val;\n\n        err = asn1_decode_sequence_of_keys(&in, &keysets[ki]);\n        if (err)\n            goto cleanup;\n\n        if (total_keys_out)\n            total_keys += keysets[ki].n_key_data;\n        ki++;\n    }\n\n    if (total_keys_out)\n        *total_keys_out = total_keys;\n\n    *n_keysets_out = n_keys;\n    *keysets_out = keysets;\n    keysets = NULL;\n    n_keys = 0;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keys);\n    return err;\n}\n\nkrb5_error_code\nkrb5_decode_krbsecretkey(krb5_context context, krb5_db_entry *entries,\n                         struct berval **bvalues, krb5_kvno *mkvno)\n{\n    krb5_key_data *key_data = NULL, *tmp;\n    krb5_error_code err = 0;\n    ldap_seqof_key_data *keysets = NULL;\n    krb5_int16 i, n_keysets = 0, total_keys = 0;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, &total_keys);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal key data\"));\n        goto cleanup;\n    }\n\n    key_data = k5calloc(total_keys, sizeof(krb5_key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memset(key_data, 0, total_keys * sizeof(krb5_key_data));\n\n    if (n_keysets > 0)\n        *mkvno = keysets[0].mkvno;\n\n    /* Transfer key data values from keysets to a flat list in entries. */\n    tmp = key_data;\n    for (i = 0; i < n_keysets; i++) {\n        memcpy(tmp, keysets[i].key_data,\n               sizeof(krb5_key_data) * keysets[i].n_key_data);\n        tmp += keysets[i].n_key_data;\n        keysets[i].n_key_data = 0;\n    }\n    entries->n_key_data = total_keys;\n    entries->key_data = key_data;\n    key_data = NULL;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    k5_free_key_data(total_keys, key_data);\n    return err;\n}\n\nstatic int\ncompare_osa_pw_hist_ent(const void *left_in, const void *right_in)\n{\n    int kvno_left, kvno_right;\n    osa_pw_hist_ent *left = (osa_pw_hist_ent *)left_in;\n    osa_pw_hist_ent *right = (osa_pw_hist_ent *)right_in;\n\n    kvno_left = left->n_key_data ? left->key_data[0].key_data_kvno : 0;\n    kvno_right = right->n_key_data ? right->key_data[0].key_data_kvno : 0;\n    return kvno_left - kvno_right;\n}\n\n/*\n * Decode the key history entries from an LDAP search.\n *\n * NOTE: the caller must free princ_ent->old_keys even on error.\n */\nkrb5_error_code\nkrb5_decode_histkey(krb5_context context, struct berval **bvalues,\n                    osa_princ_ent_rec *princ_ent)\n{\n    krb5_error_code err = 0;\n    krb5_int16 i, n_keysets = 0;\n    ldap_seqof_key_data *keysets = NULL;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, NULL);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal pw history\"));\n        goto cleanup;\n    }\n\n    princ_ent->old_keys = k5calloc(n_keysets, sizeof(osa_pw_hist_ent), &err);\n    if (princ_ent->old_keys == NULL)\n        goto cleanup;\n    princ_ent->old_key_len = n_keysets;\n\n    if (n_keysets > 0)\n        princ_ent->admin_history_kvno = keysets[0].mkvno;\n\n    /* Transfer key data pointers from keysets to princ_ent. */\n    for (i = 0; i < n_keysets; i++) {\n        princ_ent->old_keys[i].n_key_data = keysets[i].n_key_data;\n        princ_ent->old_keys[i].key_data = keysets[i].key_data;\n        keysets[i].n_key_data = 0;\n        keysets[i].key_data = NULL;\n    }\n\n    /* Sort the principal entries by kvno in ascending order. */\n    qsort(princ_ent->old_keys, princ_ent->old_key_len, sizeof(osa_pw_hist_ent),\n          &compare_osa_pw_hist_ent);\n\n    princ_ent->aux_attributes |= KADM5_KEY_HIST;\n\n    /* Set the next key to the end of the list.  The queue will be lengthened\n     * if it isn't full yet; the first entry will be replaced if it is full. */\n    princ_ent->old_key_next = princ_ent->old_key_len;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    return err;\n}\n\nstatic char *\ngetstringtime(krb5_timestamp epochtime)\n{\n    struct tm           tme;\n    char                *strtime=NULL;\n    time_t              posixtime = epochtime;\n\n    strtime = calloc (50, 1);\n    if (strtime == NULL)\n        return NULL;\n\n    if (gmtime_r(&posixtime, &tme) == NULL)\n        return NULL;\n\n    strftime(strtime, 50, \"%Y%m%d%H%M%SZ\", &tme);\n    return strtime;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c */\n/*\n * Copyright (C) 2016 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in\n *   the documentation and/or other materials provided with the\n *   distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_principal.h\"\n#include \"princ_xdr.h\"\n#include \"ldap_tkt_policy.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n#include <kadm5/admin.h>\n#include <time.h>\n\nextern char* principal_attributes[];\nextern char* max_pwd_life_attr[];\n\nstatic char *\ngetstringtime(krb5_timestamp);\n\nkrb5_error_code\nberval2tl_data(struct berval *in, krb5_tl_data **out)\n{\n    *out = (krb5_tl_data *) malloc (sizeof (krb5_tl_data));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->tl_data_length = in->bv_len - 2;\n    (*out)->tl_data_contents =  (krb5_octet *) malloc\n        ((*out)->tl_data_length * sizeof (krb5_octet));\n    if ((*out)->tl_data_contents == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    UNSTORE16_INT (in->bv_val, (*out)->tl_data_type);\n    memcpy ((*out)->tl_data_contents, in->bv_val + 2, (*out)->tl_data_length);\n\n    return 0;\n}\n\n/*\n * look up a principal in the directory.\n */\n\nkrb5_error_code\nkrb5_ldap_get_principal(krb5_context context, krb5_const_principal searchfor,\n                        unsigned int flags, krb5_db_entry **entry_ptr)\n{\n    char                        *user=NULL, *filter=NULL, *filtuser=NULL;\n    unsigned int                tree=0, ntrees=1, princlen=0;\n    krb5_error_code             tempst=0, st=0;\n    char                        **values=NULL, **subtree=NULL, *cname=NULL;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_principal              cprinc=NULL;\n    krb5_boolean                found=FALSE;\n    krb5_db_entry               *entry = NULL;\n\n    *entry_ptr = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    if (searchfor == NULL)\n        return EINVAL;\n\n    dal_handle = context->dal_handle;\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;\n\n    CHECK_LDAP_HANDLE(ldap_context);\n\n    if (!is_principal_in_realm(ldap_context, searchfor)) {\n        st = KRB5_KDB_NOENTRY;\n        k5_setmsg(context, st, _(\"Principal does not belong to realm\"));\n        goto cleanup;\n    }\n\n    if ((st=krb5_unparse_name(context, searchfor, &user)) != 0)\n        goto cleanup;\n\n    if ((st=krb5_ldap_unparse_principal_name(user)) != 0)\n        goto cleanup;\n\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    princlen = strlen(FILTER) + strlen(filtuser) + 2 + 1;  /* 2 for closing brackets */\n    if ((filter = malloc(princlen)) == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    snprintf(filter, princlen, FILTER\"%s))\", filtuser);\n\n    if ((st = krb5_get_subtree_info(ldap_context, &subtree, &ntrees)) != 0)\n        goto cleanup;\n\n    GET_HANDLE();\n    for (tree=0; tree < ntrees && !found; ++tree) {\n\n        LDAP_SEARCH(subtree[tree], ldap_context->lrparams->search_scope, filter, principal_attributes);\n        for (ent=ldap_first_entry(ld, result); ent != NULL && !found; ent=ldap_next_entry(ld, ent)) {\n\n            /* get the associated directory user information */\n            if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                int i;\n\n                /* a wild-card in a principal name can return a list of kerberos principals.\n                 * Make sure that the correct principal is returned.\n                 * NOTE: a principalname k* in ldap server will return all the principals starting with a k\n                 */\n                for (i=0; values[i] != NULL; ++i) {\n                    if (strcmp(values[i], user) == 0) {\n                        found = TRUE;\n                        break;\n                    }\n                }\n                ldap_value_free(values);\n\n                if (!found) /* no matching principal found */\n                    continue;\n            }\n\n            if ((values=ldap_get_values(ld, ent, \"krbcanonicalname\")) != NULL) {\n                if (values[0] && strcmp(values[0], user) != 0) {\n                    /* We matched an alias, not the canonical name. */\n                    if (flags & KRB5_KDB_FLAG_ALIAS_OK) {\n                        st = krb5_ldap_parse_principal_name(values[0], &cname);\n                        if (st != 0)\n                            goto cleanup;\n                        st = krb5_parse_name(context, cname, &cprinc);\n                        if (st != 0)\n                            goto cleanup;\n                    } else /* No canonicalization, so don't return aliases. */\n                        found = FALSE;\n                }\n                ldap_value_free(values);\n                if (!found)\n                    continue;\n            }\n\n            entry = k5alloc(sizeof(*entry), &st);\n            if (entry == NULL)\n                goto cleanup;\n            if ((st = populate_krb5_db_entry(context, ldap_context, ld, ent,\n                                             cprinc ? cprinc : searchfor,\n                                             entry)) != 0)\n                goto cleanup;\n        }\n        ldap_msgfree(result);\n        result = NULL;\n    } /* for (tree=0 ... */\n\n    if (found) {\n        *entry_ptr = entry;\n        entry = NULL;\n    } else\n        st = KRB5_KDB_NOENTRY;\n\ncleanup:\n    ldap_msgfree(result);\n    krb5_ldap_free_principal(context, entry);\n\n    if (filter)\n        free (filter);\n\n    if (subtree) {\n        for (; ntrees; --ntrees)\n            if (subtree[ntrees-1])\n                free (subtree[ntrees-1]);\n        free (subtree);\n    }\n\n    if (ldap_server_handle)\n        krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    if (cname)\n        free(cname);\n\n    if (cprinc)\n        krb5_free_principal(context, cprinc);\n\n    return st;\n}\n\ntypedef enum{ ADD_PRINCIPAL, MODIFY_PRINCIPAL } OPERATION;\n/*\n * ptype is creating confusions. Additionally the logic\n * surronding ptype is redundunt and can be achevied\n * with the help of dn and containerdn members.\n * so dropping the ptype member\n */\n\ntypedef struct _xargs_t {\n    char           *dn;\n    char           *linkdn;\n    krb5_boolean   dn_from_kbd;\n    char           *containerdn;\n    char           *tktpolicydn;\n}xargs_t;\n\nstatic void\nfree_xargs(xargs_t xargs)\n{\n    if (xargs.dn)\n        free (xargs.dn);\n    if (xargs.linkdn)\n        free(xargs.linkdn);\n    if (xargs.containerdn)\n        free (xargs.containerdn);\n    if (xargs.tktpolicydn)\n        free (xargs.tktpolicydn);\n}\n\nstatic krb5_error_code\nprocess_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], \"=\", &arg_val);\n            arg = (arg != NULL) ? arg : \"\";\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &xargs->tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n\nkrb5int_access accessor;\n\nstatic krb5_error_code\nasn1_encode_sequence_of_keys(krb5_key_data *key_data, krb5_int16 n_key_data,\n                             krb5_int32 mkvno, krb5_data **code)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data val;\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    val.key_data = key_data;\n    val.n_key_data = n_key_data;\n    val.mkvno = mkvno;\n    val.kvno = key_data[0].key_data_kvno;\n\n    return accessor.asn1_ldap_encode_sequence_of_keys(&val, code);\n}\n\nstatic krb5_error_code\nasn1_decode_sequence_of_keys(krb5_data *in, ldap_seqof_key_data *out)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data *p;\n    int i;\n\n    memset(out, 0, sizeof(*out));\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    err = accessor.asn1_ldap_decode_sequence_of_keys(in, &p);\n    if (err)\n        return err;\n\n    /* Set kvno and key_data_ver in each key_data element. */\n    for (i = 0; i < p->n_key_data; i++) {\n        p->key_data[i].key_data_kvno = p->kvno;\n        /* The decoder sets key_data_ver to 1 if no salt is present, but leaves\n         * it at 0 if salt is present. */\n        if (p->key_data[i].key_data_ver == 0)\n            p->key_data[i].key_data_ver = 2;\n    }\n\n    *out = *p;\n    free(p);\n    return 0;\n}\n\n/*\n * Free a NULL-terminated struct berval *array[] and all its contents.\n * Does not set array to NULL after freeing it.\n */\nstatic void\nfree_berdata(struct berval **array)\n{\n    int i;\n\n    if (array != NULL) {\n        for (i = 0; array[i] != NULL; i++) {\n            if (array[i]->bv_val != NULL)\n                free(array[i]->bv_val);\n            free(array[i]);\n        }\n        free(array);\n    }\n}\n\n/*\n * Encode krb5_key_data into a berval struct for insertion into LDAP.\n */\nstatic krb5_error_code\nencode_keys(krb5_key_data *key_data_in, int n_key_data, krb5_kvno mkvno,\n            struct berval **bval_out)\n{\n    krb5_error_code err = 0;\n    int i;\n    krb5_key_data *key_data = NULL;\n    struct berval *bval = NULL;\n    krb5_data *code;\n\n    *bval_out = NULL;\n    if (n_key_data <= 0) {\n        err = EINVAL;\n        goto cleanup;\n    }\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    bval = k5alloc(sizeof(struct berval), &err);\n    if (bval == NULL)\n        goto cleanup;\n\n    err = asn1_encode_sequence_of_keys(key_data, n_key_data, mkvno, &code);\n    if (err)\n        goto cleanup;\n\n    /* Steal the data pointer from code for bval and discard code. */\n    bval->bv_len = code->length;\n    bval->bv_val = code->data;\n    free(code);\n\n    *bval_out = bval;\n    bval = NULL;\n\ncleanup:\n    free(key_data);\n    free(bval);\n    return err;\n}\n\n/* Decoding ASN.1 encoded key */\nstatic struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data, int n_key_data,\n                         krb5_kvno mkvno)\n{\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 0;\n    int i, j, last;\n    krb5_error_code err = 0;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Find the number of key versions */\n    if (n_key_data > 0) {\n        for (i = 0, num_versions = 1; i < n_key_data - 1; i++) {\n            if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n                num_versions++;\n        }\n    }\n\n    ret = calloc(num_versions + 1, sizeof(struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    ret[num_versions] = NULL;\n\n    /* n_key_data may be 0 if a principal is created without a key. */\n    if (n_key_data == 0)\n        goto cleanup;\n\n    currkvno = key_data[0].key_data_kvno;\n    for (i = 0, last = 0, j = 0; i < n_key_data; i++) {\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            err = encode_keys(key_data + last, (krb5_int16)i - last + 1, mkvno,\n                              &ret[j]);\n            if (err)\n                goto cleanup;\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\n/*\n * Encode a principal's key history for insertion into ldap.\n */\nstatic struct berval **\nkrb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n\n    ret[princ_ent->old_key_len] = NULL;\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\ntl_data2berval (krb5_tl_data *in, struct berval **out)\n{\n    *out = (struct berval *) malloc (sizeof (struct berval));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->bv_len = in->tl_data_length + 2;\n    (*out)->bv_val =  (char *) malloc ((*out)->bv_len);\n    if ((*out)->bv_val == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    STORE16_INT((*out)->bv_val, in->tl_data_type);\n    memcpy ((*out)->bv_val + 2, in->tl_data_contents, in->tl_data_length);\n\n    return 0;\n}\n\n/* Parse the \"require_auth\" string for auth indicators, adding them to the\n * krbPrincipalAuthInd attribute. */\nstatic krb5_error_code\nupdate_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\n\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}\n\nkrb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nkrb5_error_code\nkrb5_read_tkt_policy(krb5_context context, krb5_ldap_context *ldap_context,\n                     krb5_db_entry *entries, char *policy)\n{\n    krb5_error_code             st=0;\n    int                         mask=0, omask=0;\n    int                         tkt_mask=(KDB_MAX_LIFE_ATTR | KDB_MAX_RLIFE_ATTR | KDB_TKT_FLAGS_ATTR);\n    krb5_ldap_policy_params     *tktpoldnparam=NULL;\n\n    if ((st=krb5_get_attributes_mask(context, entries, &mask)) != 0)\n        goto cleanup;\n\n    if ((mask & tkt_mask) == tkt_mask)\n        goto cleanup;\n\n    if (policy != NULL) {\n        st = krb5_ldap_read_policy(context, policy, &tktpoldnparam, &omask);\n        if (st && st != KRB5_KDB_NOENTRY) {\n            k5_prependmsg(context, st, _(\"Error reading ticket policy\"));\n            goto cleanup;\n        }\n\n        st = 0; /* reset the return status */\n    }\n\n    if ((mask & KDB_MAX_LIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_LIFE_ATTR) ==  KDB_MAX_LIFE_ATTR)\n            entries->max_life = tktpoldnparam->maxtktlife;\n        else if (ldap_context->lrparams->max_life)\n            entries->max_life = ldap_context->lrparams->max_life;\n    }\n\n    if ((mask & KDB_MAX_RLIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_RLIFE_ATTR) == KDB_MAX_RLIFE_ATTR)\n            entries->max_renewable_life = tktpoldnparam->maxrenewlife;\n        else if (ldap_context->lrparams->max_renewable_life)\n            entries->max_renewable_life = ldap_context->lrparams->max_renewable_life;\n    }\n\n    if ((mask & KDB_TKT_FLAGS_ATTR) == 0) {\n        if ((omask & KDB_TKT_FLAGS_ATTR) == KDB_TKT_FLAGS_ATTR)\n            entries->attributes = tktpoldnparam->tktflags;\n        else if (ldap_context->lrparams->tktflags)\n            entries->attributes |= ldap_context->lrparams->tktflags;\n    }\n    krb5_ldap_free_policy(context, tktpoldnparam);\n\ncleanup:\n    return st;\n}\n\nstatic void\nfree_ldap_seqof_key_data(ldap_seqof_key_data *keysets, krb5_int16 n_keysets)\n{\n    int i;\n\n    if (keysets == NULL)\n        return;\n\n    for (i = 0; i < n_keysets; i++)\n        k5_free_key_data(keysets[i].n_key_data, keysets[i].key_data);\n    free(keysets);\n}\n\n/*\n * Decode keys from ldap search results.\n *\n * Arguments:\n *  - bvalues\n *      The ldap search results containing the key data.\n *  - mkvno\n *      The master kvno that the keys were encrypted with.\n *  - keysets_out\n *      The decoded keys in a ldap_seqof_key_data struct.  Must be freed using\n *      free_ldap_seqof_key_data.\n *  - n_keysets_out\n *      The number of entries in keys_out.\n *  - total_keys_out\n *      An optional argument that if given will be set to the total number of\n *      keys found throughout all the entries: sum(keys_out.n_key_data)\n *      May be NULL.\n */\nstatic krb5_error_code\ndecode_keys(struct berval **bvalues, ldap_seqof_key_data **keysets_out,\n            krb5_int16 *n_keysets_out, krb5_int16 *total_keys_out)\n{\n    krb5_error_code err = 0;\n    krb5_int16 n_keys, i, ki, total_keys;\n    ldap_seqof_key_data *keysets = NULL;\n\n    *keysets_out = NULL;\n    *n_keysets_out = 0;\n    if (total_keys_out)\n        *total_keys_out = 0;\n\n    /* Precount the number of keys. */\n    for (n_keys = 0, i = 0; bvalues[i] != NULL; i++) {\n        if (bvalues[i]->bv_len > 0)\n            n_keys++;\n    }\n\n    keysets = k5calloc(n_keys, sizeof(ldap_seqof_key_data), &err);\n    if (keysets == NULL)\n        goto cleanup;\n    memset(keysets, 0, n_keys * sizeof(ldap_seqof_key_data));\n\n    for (i = 0, ki = 0, total_keys = 0; bvalues[i] != NULL; i++) {\n        krb5_data in;\n\n        if (bvalues[i]->bv_len == 0)\n            continue;\n        in.length = bvalues[i]->bv_len;\n        in.data = bvalues[i]->bv_val;\n\n        err = asn1_decode_sequence_of_keys(&in, &keysets[ki]);\n        if (err)\n            goto cleanup;\n\n        if (total_keys_out)\n            total_keys += keysets[ki].n_key_data;\n        ki++;\n    }\n\n    if (total_keys_out)\n        *total_keys_out = total_keys;\n\n    *n_keysets_out = n_keys;\n    *keysets_out = keysets;\n    keysets = NULL;\n    n_keys = 0;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keys);\n    return err;\n}\n\nkrb5_error_code\nkrb5_decode_krbsecretkey(krb5_context context, krb5_db_entry *entries,\n                         struct berval **bvalues, krb5_kvno *mkvno)\n{\n    krb5_key_data *key_data = NULL, *tmp;\n    krb5_error_code err = 0;\n    ldap_seqof_key_data *keysets = NULL;\n    krb5_int16 i, n_keysets = 0, total_keys = 0;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, &total_keys);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal key data\"));\n        goto cleanup;\n    }\n\n    key_data = k5calloc(total_keys, sizeof(krb5_key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memset(key_data, 0, total_keys * sizeof(krb5_key_data));\n\n    if (n_keysets > 0)\n        *mkvno = keysets[0].mkvno;\n\n    /* Transfer key data values from keysets to a flat list in entries. */\n    tmp = key_data;\n    for (i = 0; i < n_keysets; i++) {\n        memcpy(tmp, keysets[i].key_data,\n               sizeof(krb5_key_data) * keysets[i].n_key_data);\n        tmp += keysets[i].n_key_data;\n        keysets[i].n_key_data = 0;\n    }\n    entries->n_key_data = total_keys;\n    entries->key_data = key_data;\n    key_data = NULL;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    k5_free_key_data(total_keys, key_data);\n    return err;\n}\n\nstatic int\ncompare_osa_pw_hist_ent(const void *left_in, const void *right_in)\n{\n    int kvno_left, kvno_right;\n    osa_pw_hist_ent *left = (osa_pw_hist_ent *)left_in;\n    osa_pw_hist_ent *right = (osa_pw_hist_ent *)right_in;\n\n    kvno_left = left->n_key_data ? left->key_data[0].key_data_kvno : 0;\n    kvno_right = right->n_key_data ? right->key_data[0].key_data_kvno : 0;\n    return kvno_left - kvno_right;\n}\n\n/*\n * Decode the key history entries from an LDAP search.\n *\n * NOTE: the caller must free princ_ent->old_keys even on error.\n */\nkrb5_error_code\nkrb5_decode_histkey(krb5_context context, struct berval **bvalues,\n                    osa_princ_ent_rec *princ_ent)\n{\n    krb5_error_code err = 0;\n    krb5_int16 i, n_keysets = 0;\n    ldap_seqof_key_data *keysets = NULL;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, NULL);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal pw history\"));\n        goto cleanup;\n    }\n\n    princ_ent->old_keys = k5calloc(n_keysets, sizeof(osa_pw_hist_ent), &err);\n    if (princ_ent->old_keys == NULL)\n        goto cleanup;\n    princ_ent->old_key_len = n_keysets;\n\n    if (n_keysets > 0)\n        princ_ent->admin_history_kvno = keysets[0].mkvno;\n\n    /* Transfer key data pointers from keysets to princ_ent. */\n    for (i = 0; i < n_keysets; i++) {\n        princ_ent->old_keys[i].n_key_data = keysets[i].n_key_data;\n        princ_ent->old_keys[i].key_data = keysets[i].key_data;\n        keysets[i].n_key_data = 0;\n        keysets[i].key_data = NULL;\n    }\n\n    /* Sort the principal entries by kvno in ascending order. */\n    qsort(princ_ent->old_keys, princ_ent->old_key_len, sizeof(osa_pw_hist_ent),\n          &compare_osa_pw_hist_ent);\n\n    princ_ent->aux_attributes |= KADM5_KEY_HIST;\n\n    /* Set the next key to the end of the list.  The queue will be lengthened\n     * if it isn't full yet; the first entry will be replaced if it is full. */\n    princ_ent->old_key_next = princ_ent->old_key_len;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    return err;\n}\n\nstatic char *\ngetstringtime(krb5_timestamp epochtime)\n{\n    struct tm           tme;\n    char                *strtime=NULL;\n    time_t              posixtime = epochtime;\n\n    strtime = calloc (50, 1);\n    if (strtime == NULL)\n        return NULL;\n\n    if (gmtime_r(&posixtime, &tme) == NULL)\n        return NULL;\n\n    strftime(strtime, 50, \"%Y%m%d%H%M%SZ\", &tme);\n    return strtime;\n}\n"], "filenames": ["src/plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c"], "buggy_code_start_loc": [298], "buggy_code_end_loc": [298], "fixing_code_start_loc": [299], "fixing_code_end_loc": [300], "type": "NVD-CWE-Other", "message": "The process_db_args function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) through 1.13.4 and 1.14.x through 1.14.1 mishandles the DB argument, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request to modify a principal.", "other": {"cve": {"id": "CVE-2016-3119", "sourceIdentifier": "cve@mitre.org", "published": "2016-03-26T01:59:05.997", "lastModified": "2020-01-21T15:47:45.433", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/476.html\">CWE-476: NULL Pointer Dereference</a>", "descriptions": [{"lang": "en", "value": "The process_db_args function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) through 1.13.4 and 1.14.x through 1.14.1 mishandles the DB argument, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request to modify a principal."}, {"lang": "es", "value": "La funci\u00f3n process_db_args en plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c en el m\u00f3dulo LDAP KDB en kadmind en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) hasta la versi\u00f3n 1.13.4 y 1.14.x hasta la versi\u00f3n 1.14.1 no maneja adecuadamente el argumento DB, lo que permite a usuarios remotros autenticados provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda de demonio) a trav\u00e9s de una petici\u00f3n manipulada para modificar una principal."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "08FA60A9-10E1-4ACD-819C-17801FAD7671"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "E8973E93-0BBE-4BD3-9983-F6480FFEA228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "7A37987D-22F9-47AC-A07A-380F7E509BFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "E47F0770-67D7-42EE-A1AD-9D5B5E83BF2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BE8C0C82-749E-4837-88F8-FB56A753B094"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2:beta1:*:*:*:*:*:*", "matchCriteriaId": "4EA5E4B3-AD02-4E87-822B-8A6C91DA65FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2:beta2:*:*:*:*:*:*", "matchCriteriaId": "1A0B70C1-476D-4FAF-BA96-CB3EB32B7BC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "8AD672FA-918D-48CB-BC03-4E412AF0DCCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "D0B363A4-BB7A-48A2-AE6B-BD2DDD46E7CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "74EF42A5-EC47-4475-81D6-FD1E9C2B8A3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "30F2CBEF-6FA1-4E07-8163-6AFEDC93FCE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "D133CB0D-8A54-4DAA-9FE8-0B367544DE65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "7B2C23BD-1995-4F09-B444-87DDDE21817E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "EEF118BE-6351-4768-A3F0-DFE0065273D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "2574FC48-C80A-427A-AD12-42676D125D62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "7F01A83F-3BD1-4DED-979A-B4B6B23039FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3:alpha1:*:*:*:*:*:*", "matchCriteriaId": "6B1422F8-CC87-46EA-8649-A12D6E47335D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "ACEB5A36-8F72-417A-AC92-149612EC7BCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B8704B5-F37B-4C61-A924-3774A29BFEB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "F953CEBA-BAC0-48DF-A3D0-1FABCC9963E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "ED81A044-8A7B-4EEF-A4B3-EA49D76FAAED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "30AA5727-BD83-45CF-B308-BA5F8A577B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "0E088E64-6FBD-4148-8F78-506364B7BB1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "52F0EECF-7787-442B-9888-D22F7D36C3DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "EF344AED-BE00-4A9B-A9DE-C6FB0BEE4617"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "567406CA-58D8-453E-B36E-6D1D2EFC8EB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "7830E03F-A813-4E35-893E-BF27395CEFB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "7764411E-C056-4696-822E-235F2620FAC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4DD315AE-868B-4061-BF01-CDBF59B02499"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "B639DD5F-71C7-4D9B-BA5C-51CAF64140B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "2B904DCE-D59F-45C7-A814-DE42CF02792D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "9957FE9E-1E89-4C27-852C-44F866A1834E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2C382DAA-68D2-4DD9-BE29-8EEB0BAF1A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "73BB258E-51CF-4D12-836B-BCEA587A3F5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "F81DE01C-BA3B-40B4-BD85-17692F0AF8A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "DFB1190E-BE7A-4C6B-862D-D5747C64E980"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "4B09C090-B842-43C7-B8A6-DBF63D80FEC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "36823B2B-5C72-4FF3-9301-FB263EB8CE09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "59AFA33E-FEBC-45F5-9EC6-8AA363163FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "04D83332-B2FD-4E86-A76C-C3F1CD3B3A31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "758A0011-20ED-414A-9DF3-50A161DF8BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "7768AED0-AE4C-4D4E-8D5D-5B618AB82966"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "534104C5-966E-4740-A354-4F6C210FF25B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "78AF5659-C0E3-49C4-9CA7-FC3917C8AC49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "86738633-C081-4440-9F75-A775D6DF2228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BCFFEE-EA7A-4F26-97AA-31128A179745"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "91A2D7F5-EBDE-4000-AC78-8DD6472E685A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8E92BFA5-723E-4843-A8D8-BC1D32F34569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "34C27198-9B55-42FB-AA21-D8B4EB60D926"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "FC504264-A9E9-4433-B7AA-6D5015A93FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "77FA352F-520C-4C05-AD52-FC8586DB16B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "9FFB18F7-CB08-4AE4-9DEC-55D047819A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "637E858A-7C16-490C-99A8-F46440E5F504"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "22840B84-2EA4-4E96-A8D8-154AAEADB806"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "65BCD38A-33AD-4FD7-AF5B-8470B24C4139"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "E11F9209-799A-428B-9513-DBD0F19C7BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "1DA40FAA-B858-4282-8438-247E99FBB002"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "65795542-D886-46C4-8ECB-4630078DF66A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "D0A4C436-C3D7-469E-8895-8EEC9569EE86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "79A9FAE9-7219-4D6A-9E94-FFE20223537D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA68BC90-FCFC-4C9B-8574-9029DB2358E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "9D0A28CB-173D-4676-B083-E3718213B840"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "AA3D2861-7EB7-4984-AC92-989B427BDB58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13:*:*:*:*:*:*:*", "matchCriteriaId": "169D00BD-344F-453C-BE7C-9DF0740080BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "765B3248-A524-4A79-858C-E787C1C1599E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.2:*:*:*:*:*:*:*", "matchCriteriaId": "BF1BB0AB-2C22-49F9-9D2A-074D2F711BA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.3:*:*:*:*:*:*:*", "matchCriteriaId": "C8EC001E-9507-410D-836F-93002789D574"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.4:*:*:*:*:*:*:*", "matchCriteriaId": "CC0939BF-9ACB-41A7-9B48-0FBF1176C8CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:alpha1:*:*:*:*:*:*", "matchCriteriaId": "EC81822F-DC8C-4889-AD53-33216B66A109"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta1:*:*:*:*:*:*", "matchCriteriaId": "C1B23EE0-35EB-46FC-8620-AC0059498D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta2:*:*:*:*:*:*", "matchCriteriaId": "70831CB8-695D-45E8-A829-2E888823E8A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "94DADC6D-0449-40C1-85C6-109CFB8EDFAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "E650B5A3-99CA-491B-A1FB-259EF548D92E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-04/msg00007.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-04/msg00055.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2591.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/85392", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1035399", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/08c642c09c38a9c6454ab43a9b53b2a89b9eef99", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00040.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/08c642c09c38a9c6454ab43a9b53b2a89b9eef99"}}