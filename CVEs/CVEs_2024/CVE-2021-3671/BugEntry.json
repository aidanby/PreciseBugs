{"buggy_code": ["/*\n * Copyright (c) 1997-2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"kdc_locl.h\"\n\n/*\n * return the realm of a krbtgt-ticket or NULL\n */\n\nstatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}\n\n/*\n * The KDC might add a signed path to the ticket authorization data\n * field. This is to avoid server impersonating clients and the\n * request constrained delegation.\n *\n * This is done by storing a KRB5_AUTHDATA_IF_RELEVANT with a single\n * entry of type KRB5SignedPath.\n */\n\nstatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n\nkrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_const_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = rk_UNCONST(client);\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\nstatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}\n\nstatic krb5_boolean\nis_anon_tgs_request_p(const KDC_REQ_BODY *b,\n\t\t      const EncTicketPart *tgt)\n{\n    KDCOptions f = b->kdc_options;\n\n    /*\n     * Versions of Heimdal from 1.0 to 7.6, inclusive, send both the\n     * request-anonymous and cname-in-addl-tkt flags for constrained\n     * delegation requests. A true anonymous TGS request will only\n     * have the request-anonymous flag set. (A corollary of this is\n     * that it is not possible to support anonymous constrained\n     * delegation requests, although they would be of limited utility.)\n     */\n    return tgt->flags.anonymous ||\n\t(f.request_anonymous && !f.cname_in_addl_tkt && !b->additional_tickets);\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_tgs_flags(astgs_request_t r, KDC_REQ_BODY *b,\n\t\tkrb5_const_principal tgt_name,\n\t\tconst EncTicketPart *tgt, EncTicketPart *et)\n{\n    krb5_context context = r->context;\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif (!tgt->flags.invalid || tgt->starttime == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    } else if (tgt->flags.invalid) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif (!tgt->flags.forwardable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif (!tgt->flags.forwardable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif (!tgt->flags.proxiable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif (!tgt->flags.proxiable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif (!tgt->flags.may_postdate) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif (!tgt->flags.may_postdate) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    } else if (b->from && *b->from > kdc_time + context->max_skew) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif (!tgt->flags.renewable || tgt->renew_till == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif (!tgt->flags.renewable || tgt->renew_till == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n    /*\n     * RFC 8062 section 3 defines an anonymous ticket as one containing\n     * the anonymous principal and the anonymous ticket flag.\n     */\n    if (tgt->flags.anonymous &&\n\t!_kdc_is_anonymous(context, tgt_name)) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Anonymous ticket flag set without \"\n\t\t\t \"anonymous principal\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * RFC 8062 section 4.2 states that if the TGT is anonymous, the\n     * anonymous KDC option SHOULD be set, but it is not required.\n     * Treat an anonymous TGT as if the anonymous flag was set.\n     */\n    if (is_anon_tgs_request_p(b, tgt))\n\tet->flags.anonymous = 1;\n\n    return 0;\n}\n\n/*\n * Determine if constrained delegation is allowed from this client to this server\n */\n\nstatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 4,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 4,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}\n\n/*\n * Determine if s4u2self is allowed from this client to this server\n *\n * For example, regardless of the principal being impersonated, if the\n * 'client' and 'server' are the same, then it's safe.\n */\n\nstatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 4, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 4, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case domain_X500_Compress:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 4,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 4,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    /*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     */\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 4,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 4,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = domain_X500_Compress;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}\n\n\nstatic krb5_error_code\ntgs_make_reply(astgs_request_t r,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n               const char *tgt_realm,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    const char **e_text = &r->e_text;\n    krb5_data *reply = r->reply;\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(r, b, tgt_name, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t tgt_realm);\n    if(ret)\n\tgoto out;\n\n    ret = copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    ret = copy_Realm(&tgt_name->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n\n    /*\n     * RFC 8062 states \"if the ticket in the TGS request is an anonymous\n     * one, the client and client realm are copied from that ticket\". So\n     * whilst the TGT flag check below is superfluous, it is included in\n     * order to follow the specification to its letter.\n     */\n    if (et.flags.anonymous && !tgt->flags.anonymous)\n\t_kdc_make_anonymous_principalname(&rep.cname);\n    else\n\tret = copy_PrincipalName(&tgt_name->name, &rep.cname);\n    if (ret)\n\tgoto out;\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    /* See MS-KILE 3.3.5.1 */\n    if (!server->entry.flags.forwardable)\n\tet.flags.forwardable = 0;\n    if (!server->entry.flags.proxiable)\n\tet.flags.proxiable = 0;\n\n    /*\n     * For anonymous tickets, we should filter out positive authorization data\n     * that could reveal the client's identity, and return a policy error for\n     * restrictive authorization data. Policy for unknown authorization types\n     * is implementation dependent.\n     */\n    if (rspac->length && !et.flags.anonymous) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = rep.crealm;\n    et.cname = rep.cname;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(r, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *realm = get_krbtgt_realm(&ek.sname);\n\n\tif (realm == NULL || strcmp(realm, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\n    r->reply_key.keytype = replykey->keytype;\n    _log_astgs_req(r, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n\nstatic krb5_error_code\ntgs_check_authenticator(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t                krb5_auth_context ac,\n\t\t\tKDC_REQ_BODY *b,\n\t\t\tconst char **e_text,\n\t\t\tkrb5_keyblock *key)\n{\n    krb5_authenticator auth;\n    size_t len = 0;\n    unsigned char *buf;\n    size_t buf_size;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    krb5_auth_con_getauthenticator(context, ac, &auth);\n    if(auth->cksum == NULL){\n\tkdc_log(context, config, 4, \"No authenticator in request\");\n\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n    /*\n     * according to RFC1510 it doesn't need to be keyed,\n     * but according to the latest draft it needs to.\n     */\n    if (\n#if 0\n!krb5_checksum_is_keyed(context, auth->cksum->cksumtype)\n\t||\n#endif\n !krb5_checksum_is_collision_proof(context, auth->cksum->cksumtype)) {\n\tkdc_log(context, config, 4, \"Bad checksum type in authenticator: %d\",\n\t\tauth->cksum->cksumtype);\n\tret =  KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n\n    /* XXX should not re-encode this */\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to encode KDC-REQ-BODY: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 4, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\tret = KRB5KRB_ERR_GENERIC;\n\tgoto out;\n    }\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    ret = krb5_verify_checksum(context,\n\t\t\t       crypto,\n\t\t\t       KRB5_KU_TGS_REQ_AUTH_CKSUM,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       auth->cksum);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4,\n\t\t\"Failed to verify authenticator checksum: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\nout:\n    free_Authenticator(auth);\n    free(auth);\n    return ret;\n}\n\nstatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 4, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 5, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}\n\nstatic krb5_error_code\ntgs_parse_request(astgs_request_t r,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags = 0;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 4, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkdc_log(context, config, 4,\n\t\t\"Ticket-granting ticket %s not found in database: %s\", p, msg);\n\tkrb5_free_principal(context, princ);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n\tkdc_log(context, config, 4,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags |= KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n\n    if (r->config->warn_ticket_addresses)\n        verify_ap_req_flags |= KRB5_VERIFY_AP_REQ_IGNORE_ADDRS;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ticket && *ticket && (*ticket)->ticket.caddr)\n        _kdc_audit_addaddrs((kdc_request_t)r, (*ticket)->ticket.caddr, \"tixaddrs\");\n    if (r->config->warn_ticket_addresses && ret == KRB5KRB_AP_ERR_BADADDR &&\n        *ticket != NULL) {\n        _kdc_audit_addkv((kdc_request_t)r, 0, \"wrongaddr\", \"yes\");\n        ret = 0;\n    }\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 4, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 4, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 4, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 4,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 4, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}\n\nstatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ntgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_tgs_rep(astgs_request_t r)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    krb5_data *data = r->reply;\n    const char *from = r->from;\n    struct sockaddr *from_addr = r->addr;\n    int datagram_reply = r->datagram_reply;\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(r, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 5, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(r,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 5, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(r,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1997-2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"kdc_locl.h\"\n\n/*\n * return the realm of a krbtgt-ticket or NULL\n */\n\nstatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}\n\n/*\n * The KDC might add a signed path to the ticket authorization data\n * field. This is to avoid server impersonating clients and the\n * request constrained delegation.\n *\n * This is done by storing a KRB5_AUTHDATA_IF_RELEVANT with a single\n * entry of type KRB5SignedPath.\n */\n\nstatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n\nkrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_const_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = rk_UNCONST(client);\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\nstatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}\n\nstatic krb5_boolean\nis_anon_tgs_request_p(const KDC_REQ_BODY *b,\n\t\t      const EncTicketPart *tgt)\n{\n    KDCOptions f = b->kdc_options;\n\n    /*\n     * Versions of Heimdal from 1.0 to 7.6, inclusive, send both the\n     * request-anonymous and cname-in-addl-tkt flags for constrained\n     * delegation requests. A true anonymous TGS request will only\n     * have the request-anonymous flag set. (A corollary of this is\n     * that it is not possible to support anonymous constrained\n     * delegation requests, although they would be of limited utility.)\n     */\n    return tgt->flags.anonymous ||\n\t(f.request_anonymous && !f.cname_in_addl_tkt && !b->additional_tickets);\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_tgs_flags(astgs_request_t r, KDC_REQ_BODY *b,\n\t\tkrb5_const_principal tgt_name,\n\t\tconst EncTicketPart *tgt, EncTicketPart *et)\n{\n    krb5_context context = r->context;\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif (!tgt->flags.invalid || tgt->starttime == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    } else if (tgt->flags.invalid) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif (!tgt->flags.forwardable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif (!tgt->flags.forwardable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif (!tgt->flags.proxiable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif (!tgt->flags.proxiable) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif (!tgt->flags.may_postdate) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif (!tgt->flags.may_postdate) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    } else if (b->from && *b->from > kdc_time + context->max_skew) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif (!tgt->flags.renewable || tgt->renew_till == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif (!tgt->flags.renewable || tgt->renew_till == NULL) {\n\t    _kdc_audit_addreason((kdc_request_t)r,\n                                 \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n    /*\n     * RFC 8062 section 3 defines an anonymous ticket as one containing\n     * the anonymous principal and the anonymous ticket flag.\n     */\n    if (tgt->flags.anonymous &&\n\t!_kdc_is_anonymous(context, tgt_name)) {\n\t_kdc_audit_addreason((kdc_request_t)r,\n                             \"Anonymous ticket flag set without \"\n\t\t\t \"anonymous principal\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * RFC 8062 section 4.2 states that if the TGT is anonymous, the\n     * anonymous KDC option SHOULD be set, but it is not required.\n     * Treat an anonymous TGT as if the anonymous flag was set.\n     */\n    if (is_anon_tgs_request_p(b, tgt))\n\tet->flags.anonymous = 1;\n\n    return 0;\n}\n\n/*\n * Determine if constrained delegation is allowed from this client to this server\n */\n\nstatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 4,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 4,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}\n\n/*\n * Determine if s4u2self is allowed from this client to this server\n *\n * For example, regardless of the principal being impersonated, if the\n * 'client' and 'server' are the same, then it's safe.\n */\n\nstatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 4, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 4, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case domain_X500_Compress:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 4,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 4,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    /*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     */\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 4,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 4,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = domain_X500_Compress;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}\n\n\nstatic krb5_error_code\ntgs_make_reply(astgs_request_t r,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n               const char *tgt_realm,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    const char **e_text = &r->e_text;\n    krb5_data *reply = r->reply;\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(r, b, tgt_name, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t tgt_realm);\n    if(ret)\n\tgoto out;\n\n    ret = copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    ret = copy_Realm(&tgt_name->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n\n    /*\n     * RFC 8062 states \"if the ticket in the TGS request is an anonymous\n     * one, the client and client realm are copied from that ticket\". So\n     * whilst the TGT flag check below is superfluous, it is included in\n     * order to follow the specification to its letter.\n     */\n    if (et.flags.anonymous && !tgt->flags.anonymous)\n\t_kdc_make_anonymous_principalname(&rep.cname);\n    else\n\tret = copy_PrincipalName(&tgt_name->name, &rep.cname);\n    if (ret)\n\tgoto out;\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    /* See MS-KILE 3.3.5.1 */\n    if (!server->entry.flags.forwardable)\n\tet.flags.forwardable = 0;\n    if (!server->entry.flags.proxiable)\n\tet.flags.proxiable = 0;\n\n    /*\n     * For anonymous tickets, we should filter out positive authorization data\n     * that could reveal the client's identity, and return a policy error for\n     * restrictive authorization data. Policy for unknown authorization types\n     * is implementation dependent.\n     */\n    if (rspac->length && !et.flags.anonymous) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = rep.crealm;\n    et.cname = rep.cname;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(r, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *realm = get_krbtgt_realm(&ek.sname);\n\n\tif (realm == NULL || strcmp(realm, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\n    r->reply_key.keytype = replykey->keytype;\n    _log_astgs_req(r, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n\nstatic krb5_error_code\ntgs_check_authenticator(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t                krb5_auth_context ac,\n\t\t\tKDC_REQ_BODY *b,\n\t\t\tconst char **e_text,\n\t\t\tkrb5_keyblock *key)\n{\n    krb5_authenticator auth;\n    size_t len = 0;\n    unsigned char *buf;\n    size_t buf_size;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    krb5_auth_con_getauthenticator(context, ac, &auth);\n    if(auth->cksum == NULL){\n\tkdc_log(context, config, 4, \"No authenticator in request\");\n\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n    /*\n     * according to RFC1510 it doesn't need to be keyed,\n     * but according to the latest draft it needs to.\n     */\n    if (\n#if 0\n!krb5_checksum_is_keyed(context, auth->cksum->cksumtype)\n\t||\n#endif\n !krb5_checksum_is_collision_proof(context, auth->cksum->cksumtype)) {\n\tkdc_log(context, config, 4, \"Bad checksum type in authenticator: %d\",\n\t\tauth->cksum->cksumtype);\n\tret =  KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n\n    /* XXX should not re-encode this */\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to encode KDC-REQ-BODY: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 4, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\tret = KRB5KRB_ERR_GENERIC;\n\tgoto out;\n    }\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    ret = krb5_verify_checksum(context,\n\t\t\t       crypto,\n\t\t\t       KRB5_KU_TGS_REQ_AUTH_CKSUM,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       auth->cksum);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4,\n\t\t\"Failed to verify authenticator checksum: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\nout:\n    free_Authenticator(auth);\n    free(auth);\n    return ret;\n}\n\nstatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 4, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 5, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}\n\nstatic krb5_error_code\ntgs_parse_request(astgs_request_t r,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags = 0;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 4, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkdc_log(context, config, 4,\n\t\t\"Ticket-granting ticket %s not found in database: %s\", p, msg);\n\tkrb5_free_principal(context, princ);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n\tkdc_log(context, config, 4,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags |= KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n\n    if (r->config->warn_ticket_addresses)\n        verify_ap_req_flags |= KRB5_VERIFY_AP_REQ_IGNORE_ADDRS;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ticket && *ticket && (*ticket)->ticket.caddr)\n        _kdc_audit_addaddrs((kdc_request_t)r, (*ticket)->ticket.caddr, \"tixaddrs\");\n    if (r->config->warn_ticket_addresses && ret == KRB5KRB_AP_ERR_BADADDR &&\n        *ticket != NULL) {\n        _kdc_audit_addkv((kdc_request_t)r, 0, \"wrongaddr\", \"yes\");\n        ret = 0;\n    }\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 4, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 4, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 4, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 4,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 4, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}\n\nstatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ntgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    } else if (s == NULL) {\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t_kdc_set_e_text(r, \"No server in request\");\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_tgs_rep(astgs_request_t r)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    krb5_data *data = r->reply;\n    const char *from = r->from;\n    struct sockaddr *from_addr = r->addr;\n    int datagram_reply = r->datagram_reply;\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(r, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 5, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(r,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 5, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(r,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}\n"], "filenames": ["kdc/krb5tgs.c"], "buggy_code_start_loc": [1701], "buggy_code_end_loc": [1701], "fixing_code_start_loc": [1702], "fixing_code_end_loc": [1706], "type": "CWE-476", "message": "A null pointer de-reference was found in the way samba kerberos server handled missing sname in TGS-REQ (Ticket Granting Server - Request). An authenticated user could use this flaw to crash the samba server.", "other": {"cve": {"id": "CVE-2021-3671", "sourceIdentifier": "secalert@redhat.com", "published": "2021-10-12T18:15:08.357", "lastModified": "2023-02-24T17:39:38.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A null pointer de-reference was found in the way samba kerberos server handled missing sname in TGS-REQ (Ticket Granting Server - Request). An authenticated user could use this flaw to crash the samba server."}, {"lang": "es", "value": "Se ha encontrado una desreferencia de puntero null en la forma en que el servidor kerberos de Samba manejaba el sname faltante en TGS-REQ (Ticket Granting Server - Request). Un usuario autenticado podr\u00eda usar este fallo para bloquear el servidor samba"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13.12", "matchCriteriaId": "AE0BDAA5-2AEC-40FD-A355-571DB1F7E49B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14.0", "versionEndExcluding": "4.14.8", "matchCriteriaId": "A4749057-1B17-4E8E-A26E-0C2E2A6EA0BA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_netapp_hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "4455CF3A-CC91-4BE4-A7AB-929AC82E34F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2013080,", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking"]}, {"url": "https://bugzilla.samba.org/show_bug.cgi?id=14770,", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking"]}, {"url": "https://github.com/heimdal/heimdal/commit/04171147948d0a3636bc6374181926f0fb2ec83a", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00034.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221215-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230216-0008/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5287", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/heimdal/heimdal/commit/04171147948d0a3636bc6374181926f0fb2ec83a"}}