{"buggy_code": ["/*\n * Copyright 2001-2004 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.axis.client;\n\nimport org.apache.axis.EngineConfiguration;\nimport org.apache.axis.configuration.EngineConfigurationFactoryFinder;\nimport org.apache.axis.utils.ClassUtils;\nimport org.apache.axis.utils.Messages;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.Name;\nimport javax.naming.NamingException;\nimport javax.naming.RefAddr;\nimport javax.naming.Reference;\nimport javax.naming.spi.ObjectFactory;\nimport javax.xml.namespace.QName;\nimport javax.xml.rpc.ServiceException;\nimport java.lang.reflect.Constructor;\nimport java.net.URL;\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * Helper class for obtaining Services from JNDI.\n *\n * !!! WORK IN PROGRESS\n * \n * @author Glen Daniels (gdaniels@apache.org)\n */ \n\npublic class ServiceFactory extends javax.xml.rpc.ServiceFactory\n        implements ObjectFactory\n{\n    // Constants for RefAddrs in the Reference.\n    public static final String SERVICE_CLASSNAME  = \"service classname\";\n    public static final String WSDL_LOCATION      = \"WSDL location\";\n    public static final String MAINTAIN_SESSION   = \"maintain session\";\n    public static final String SERVICE_NAMESPACE  = \"service namespace\";\n    public static final String SERVICE_LOCAL_PART = \"service local part\";\n    public static final String SERVICE_IMPLEMENTATION_NAME_PROPERTY = \"serviceImplementationName\";\n\n    private static final String SERVICE_IMPLEMENTATION_SUFFIX = \"Locator\";\n\n    private static EngineConfiguration _defaultEngineConfig = null;\n\n    private static ThreadLocal threadDefaultConfig = new ThreadLocal();\n\n    public static void setThreadDefaultConfig(EngineConfiguration config)\n    {\n        threadDefaultConfig.set(config);\n    }\n    \n    private static EngineConfiguration getDefaultEngineConfig() {\n        if (_defaultEngineConfig == null) {\n            _defaultEngineConfig =\n                EngineConfigurationFactoryFinder.newFactory().getClientEngineConfig();\n        }\n        return _defaultEngineConfig;\n    }\n\n    /**\n     * Obtain an AxisClient reference, using JNDI if possible, otherwise\n     * creating one using the standard Axis configuration pattern.  If we\n     * end up creating one and do have JNDI access, bind it to the passed\n     * name so we find it next time.\n     *\n     * @param environment\n     * @return a service\n     */\n    public static Service getService(Map environment)\n    {\n        Service service = null;\n        InitialContext context = null;\n\n        EngineConfiguration configProvider =\n            (EngineConfiguration)environment.get(EngineConfiguration.PROPERTY_NAME);\n\n        if (configProvider == null)\n            configProvider = (EngineConfiguration)threadDefaultConfig.get();\n\n        if (configProvider == null)\n            configProvider = getDefaultEngineConfig();\n\n        // First check to see if JNDI works\n        // !!! Might we need to set up context parameters here?\n        try {\n            context = new InitialContext();\n        } catch (NamingException e) {\n        }\n        \n        if (context != null) {\n            String name = (String)environment.get(\"jndiName\");\n            if (name == null) {\n                name = \"axisServiceName\";\n            }\n\n            // We've got JNDI, so try to find an AxisClient at the\n            // specified name.\n            try {\n                service = (Service)context.lookup(name);\n            } catch (NamingException e) {\n                service = new Service(configProvider);\n                try {\n                    context.bind(name, service);\n                } catch (NamingException e1) {\n                    // !!! Couldn't do it, what should we do here?\n                }\n            }\n        } else {\n            service = new Service(configProvider);\n        }\n\n        return service;\n    }\n\n    public Object getObjectInstance(Object refObject, Name name,\n            Context nameCtx, Hashtable environment) throws Exception\n    {\n        Object instance = null;\n        if (refObject instanceof Reference) {\n            Reference ref = (Reference) refObject;\n\n            RefAddr addr = ref.get(SERVICE_CLASSNAME);\n            Object obj = null;\n            // If an explicit service classname is provided, then this is a\n            // generated Service class.  Just use its default constructor.\n            if (addr != null && (obj = addr.getContent()) instanceof String) {\n                instance = ClassUtils.forName((String) obj).newInstance();\n            }\n            // else this is an instance of the Service class, so grab the\n            // reference data...\n            else {\n                // Get the WSDL location...\n                addr = ref.get(WSDL_LOCATION);\n                if (addr != null && (obj = addr.getContent()) instanceof String) {\n                    URL wsdlLocation = new URL((String) obj);\n\n                    // Build the service qname...\n                    addr = ref.get(SERVICE_NAMESPACE);\n                    if (addr != null\n                        && (obj = addr.getContent()) instanceof String) {\n                        String namespace = (String) obj;\n                        addr = ref.get(SERVICE_LOCAL_PART);\n                        if (addr != null\n                            && (obj = addr.getContent()) instanceof String) {\n                            String localPart = (String) obj;\n                            QName serviceName = new QName(namespace, localPart);\n\n                            // Construct an instance of the service\n                            Class[] formalArgs = new Class[]\n                                    {URL.class, QName.class};\n                            Object[] actualArgs = new Object[]\n                                    {wsdlLocation, serviceName};\n                            Constructor ctor =\n                                    Service.class.getDeclaredConstructor(\n                                    formalArgs);\n                            instance = ctor.newInstance(actualArgs);\n                        }\n                    }\n                }\n            }\n            // If maintainSession should be set to true, there will be an\n            // addr for it.\n            addr = ref.get(MAINTAIN_SESSION);\n            if (addr != null && instance instanceof Service) {\n                ((Service) instance).setMaintainSession(true);\n            }\n        }\n        return instance;\n    } // getObjectInstance\n\n    /**\n     *  Create a Service instance.\n     *  @param   wsdlDocumentLocation URL for the WSDL document location\n                              for the service\n     *  @param   serviceName  QName for the service.\n     *  @return  Service.\n     *  @throws  ServiceException If any error in creation of the specified service\n     */\n    public javax.xml.rpc.Service createService(URL wsdlDocumentLocation,\n            QName serviceName) throws ServiceException {\n        return new Service(wsdlDocumentLocation, serviceName);\n    } // createService\n\n    /**\n     * Create a Service instance.  Since the WSDL file is not provided\n     * here, the Service object returned is quite simpleminded.\n     * Likewise, the Call object that service.createCall will return\n     * will also be simpleminded.  The caller must explicitly fill in\n     * all the info on the Call object (ie., endpoint address, etc.).\n     *\n     *  @param   serviceName QName for the service\n     *  @return  Service.\n     *  @throws  ServiceException If any error in creation of the specified service\n     */\n    public javax.xml.rpc.Service createService(QName serviceName)\n            throws ServiceException {\n        return new Service(serviceName);\n    } // createService\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service interface, if available. \n     *\n     *  @param   serviceInterface Service interface \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(Class serviceInterface) throws ServiceException {\n        if (serviceInterface == null) {\n            throw new IllegalArgumentException(\n                    Messages.getMessage(\"serviceFactoryIllegalServiceInterface\"));\n        }\n        if (!(javax.xml.rpc.Service.class).isAssignableFrom(serviceInterface))\n        {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceInterfaceRequirement\", serviceInterface.getName()));\n        } else {\n            String serviceImplementationName = serviceInterface.getName() + SERVICE_IMPLEMENTATION_SUFFIX;\n            Service service = createService(serviceImplementationName);\n            return service;\n        }\n    }\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service interface, if available. \n     * An implementation may use the provided wsdlDocumentLocation and properties \n     * to help locate the generated implementation class. \n     * If no such class is present, a ServiceException will be thrown.\n     *\n     *  @param   wsdlDocumentLocation URL for the WSDL document location for the service or null \n     *  @param   serviceInterface Service interface \n     *  @param   properties A set of implementation-specific properties \n     *      to help locate the generated service implementation class \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(URL wsdlDocumentLocation, \n            Class serviceInterface, Properties properties) throws ServiceException {\n        if (serviceInterface == null) {\n            throw new IllegalArgumentException(\n                    Messages.getMessage(\"serviceFactoryIllegalServiceInterface\"));\n        }\n        if (!(javax.xml.rpc.Service.class).isAssignableFrom(serviceInterface))\n        {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceInterfaceRequirement\", serviceInterface.getName()));\n        } else {\n            String serviceImplementationName = serviceInterface.getName() + SERVICE_IMPLEMENTATION_SUFFIX;\n            Service service = createService(serviceImplementationName);\n            return service;\n        }\n    }\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service, if available. \n     * The service is uniquely identified by the wsdlDocumentLocation and serviceName arguments. \n     * An implementation may use the provided properties to help locate the generated implementation class. \n     * If no such class is present, a ServiceException will be thrown. \n     *\n     *  @param   wsdlDocumentLocation URL for the WSDL document location for the service or null \n     *  @param   serviceName Qualified name for the service \n     *  @param   properties A set of implementation-specific properties \n     *      to help locate the generated service implementation class \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(URL wsdlDocumentLocation, \n            QName serviceName, Properties properties) throws ServiceException {\n        String serviceImplementationName = properties.getProperty(SERVICE_IMPLEMENTATION_NAME_PROPERTY);\n        javax.xml.rpc.Service service = createService(serviceImplementationName);\n        if (service.getServiceName().equals(serviceName)) {\n            return service;\n        } else {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceImplementationNotFound\", serviceImplementationName));\n        }\n    }\n\n    private Service createService(String serviceImplementationName) throws ServiceException {\n        if(serviceImplementationName == null) {\n            throw new IllegalArgumentException(Messages.getMessage(\"serviceFactoryInvalidServiceName\"));\n        }\n        try {\n            Class serviceImplementationClass;\n            serviceImplementationClass = Thread.currentThread().getContextClassLoader().loadClass(serviceImplementationName);\n            if (!(org.apache.axis.client.Service.class).isAssignableFrom(serviceImplementationClass)) {\n                throw new ServiceException(\n                        Messages.getMessage(\"serviceFactoryServiceImplementationRequirement\", serviceImplementationName));\n            }\n            Service service = (Service) serviceImplementationClass.newInstance();\n            if (service.getServiceName() != null) {\n                return service;\n            } else {\n                throw new ServiceException(Messages.getMessage(\"serviceFactoryInvalidServiceName\"));\n            }\n        } catch (ServiceException e) {\n            throw e;\n        } catch (Exception e){\n            throw new ServiceException(e);\n        }\n        \n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2001-2004 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.axis.client;\n\nimport org.apache.axis.EngineConfiguration;\nimport org.apache.axis.configuration.EngineConfigurationFactoryFinder;\nimport org.apache.axis.utils.ClassUtils;\nimport org.apache.axis.utils.Messages;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.Name;\nimport javax.naming.NamingException;\nimport javax.naming.RefAddr;\nimport javax.naming.Reference;\nimport javax.naming.spi.ObjectFactory;\nimport javax.xml.namespace.QName;\nimport javax.xml.rpc.ServiceException;\nimport java.lang.reflect.Constructor;\nimport java.net.URL;\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * Helper class for obtaining Services from JNDI.\n *\n * !!! WORK IN PROGRESS\n * \n * @author Glen Daniels (gdaniels@apache.org)\n */ \n\npublic class ServiceFactory extends javax.xml.rpc.ServiceFactory\n        implements ObjectFactory\n{\n    // Constants for RefAddrs in the Reference.\n    public static final String SERVICE_CLASSNAME  = \"service classname\";\n    public static final String WSDL_LOCATION      = \"WSDL location\";\n    public static final String MAINTAIN_SESSION   = \"maintain session\";\n    public static final String SERVICE_NAMESPACE  = \"service namespace\";\n    public static final String SERVICE_LOCAL_PART = \"service local part\";\n    public static final String SERVICE_IMPLEMENTATION_NAME_PROPERTY = \"serviceImplementationName\";\n\n    private static final String SERVICE_IMPLEMENTATION_SUFFIX = \"Locator\";\n\n    private static EngineConfiguration _defaultEngineConfig = null;\n\n    private static ThreadLocal threadDefaultConfig = new ThreadLocal();\n\n    public static void setThreadDefaultConfig(EngineConfiguration config)\n    {\n        threadDefaultConfig.set(config);\n    }\n    \n    private static EngineConfiguration getDefaultEngineConfig() {\n        if (_defaultEngineConfig == null) {\n            _defaultEngineConfig =\n                EngineConfigurationFactoryFinder.newFactory().getClientEngineConfig();\n        }\n        return _defaultEngineConfig;\n    }\n\n    /**\n     * Obtain an AxisClient reference, using JNDI if possible, otherwise\n     * creating one using the standard Axis configuration pattern.  If we\n     * end up creating one and do have JNDI access, bind it to the passed\n     * name so we find it next time.\n     *\n     * @param environment\n     * @return a service\n     */\n    public static Service getService(Map environment)\n    {\n        Service service = null;\n        InitialContext context = null;\n\n        EngineConfiguration configProvider =\n            (EngineConfiguration)environment.get(EngineConfiguration.PROPERTY_NAME);\n\n        if (configProvider == null)\n            configProvider = (EngineConfiguration)threadDefaultConfig.get();\n\n        if (configProvider == null)\n            configProvider = getDefaultEngineConfig();\n\n        // First check to see if JNDI works\n        // !!! Might we need to set up context parameters here?\n        try {\n            context = new InitialContext();\n        } catch (NamingException e) {\n        }\n        \n        if (context != null) {\n            String name = (String)environment.get(\"jndiName\");\n\n\t    if(name!=null && (name.toUpperCase().indexOf(\"LDAP\")!=-1 || name.toUpperCase().indexOf(\"RMI\")!=-1 || name.toUpperCase().indexOf(\"JMS\")!=-1 || name.toUpperCase().indexOf(\"JMX\")!=-1) || name.toUpperCase().indexOf(\"JRMP\")!=-1 || name.toUpperCase().indexOf(\"JAVA\")!=-1 || name.toUpperCase().indexOf(\"DNS\")!=-1)  {\n\t        return null;\n            }\n            if (name == null) {\n                name = \"axisServiceName\";\n            }\n\n            // We've got JNDI, so try to find an AxisClient at the\n            // specified name.\n            try {\n                service = (Service)context.lookup(name);\n            } catch (NamingException e) {\n                service = new Service(configProvider);\n                try {\n                    context.bind(name, service);\n                } catch (NamingException e1) {\n                    // !!! Couldn't do it, what should we do here?\n\t            return null;\n                }\n            }\n        } else {\n            service = new Service(configProvider);\n        }\n\n        return service;\n    }\n\n    public Object getObjectInstance(Object refObject, Name name,\n            Context nameCtx, Hashtable environment) throws Exception\n    {\n        Object instance = null;\n        if (refObject instanceof Reference) {\n            Reference ref = (Reference) refObject;\n\n            RefAddr addr = ref.get(SERVICE_CLASSNAME);\n            Object obj = null;\n            // If an explicit service classname is provided, then this is a\n            // generated Service class.  Just use its default constructor.\n            if (addr != null && (obj = addr.getContent()) instanceof String) {\n                instance = ClassUtils.forName((String) obj).newInstance();\n            }\n            // else this is an instance of the Service class, so grab the\n            // reference data...\n            else {\n                // Get the WSDL location...\n                addr = ref.get(WSDL_LOCATION);\n                if (addr != null && (obj = addr.getContent()) instanceof String) {\n                    URL wsdlLocation = new URL((String) obj);\n\n                    // Build the service qname...\n                    addr = ref.get(SERVICE_NAMESPACE);\n                    if (addr != null\n                        && (obj = addr.getContent()) instanceof String) {\n                        String namespace = (String) obj;\n                        addr = ref.get(SERVICE_LOCAL_PART);\n                        if (addr != null\n                            && (obj = addr.getContent()) instanceof String) {\n                            String localPart = (String) obj;\n                            QName serviceName = new QName(namespace, localPart);\n\n                            // Construct an instance of the service\n                            Class[] formalArgs = new Class[]\n                                    {URL.class, QName.class};\n                            Object[] actualArgs = new Object[]\n                                    {wsdlLocation, serviceName};\n                            Constructor ctor =\n                                    Service.class.getDeclaredConstructor(\n                                    formalArgs);\n                            instance = ctor.newInstance(actualArgs);\n                        }\n                    }\n                }\n            }\n            // If maintainSession should be set to true, there will be an\n            // addr for it.\n            addr = ref.get(MAINTAIN_SESSION);\n            if (addr != null && instance instanceof Service) {\n                ((Service) instance).setMaintainSession(true);\n            }\n        }\n        return instance;\n    } // getObjectInstance\n\n    /**\n     *  Create a Service instance.\n     *  @param   wsdlDocumentLocation URL for the WSDL document location\n                              for the service\n     *  @param   serviceName  QName for the service.\n     *  @return  Service.\n     *  @throws  ServiceException If any error in creation of the specified service\n     */\n    public javax.xml.rpc.Service createService(URL wsdlDocumentLocation,\n            QName serviceName) throws ServiceException {\n        return new Service(wsdlDocumentLocation, serviceName);\n    } // createService\n\n    /**\n     * Create a Service instance.  Since the WSDL file is not provided\n     * here, the Service object returned is quite simpleminded.\n     * Likewise, the Call object that service.createCall will return\n     * will also be simpleminded.  The caller must explicitly fill in\n     * all the info on the Call object (ie., endpoint address, etc.).\n     *\n     *  @param   serviceName QName for the service\n     *  @return  Service.\n     *  @throws  ServiceException If any error in creation of the specified service\n     */\n    public javax.xml.rpc.Service createService(QName serviceName)\n            throws ServiceException {\n        return new Service(serviceName);\n    } // createService\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service interface, if available. \n     *\n     *  @param   serviceInterface Service interface \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(Class serviceInterface) throws ServiceException {\n        if (serviceInterface == null) {\n            throw new IllegalArgumentException(\n                    Messages.getMessage(\"serviceFactoryIllegalServiceInterface\"));\n        }\n        if (!(javax.xml.rpc.Service.class).isAssignableFrom(serviceInterface))\n        {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceInterfaceRequirement\", serviceInterface.getName()));\n        } else {\n            String serviceImplementationName = serviceInterface.getName() + SERVICE_IMPLEMENTATION_SUFFIX;\n            Service service = createService(serviceImplementationName);\n            return service;\n        }\n    }\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service interface, if available. \n     * An implementation may use the provided wsdlDocumentLocation and properties \n     * to help locate the generated implementation class. \n     * If no such class is present, a ServiceException will be thrown.\n     *\n     *  @param   wsdlDocumentLocation URL for the WSDL document location for the service or null \n     *  @param   serviceInterface Service interface \n     *  @param   properties A set of implementation-specific properties \n     *      to help locate the generated service implementation class \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(URL wsdlDocumentLocation, \n            Class serviceInterface, Properties properties) throws ServiceException {\n        if (serviceInterface == null) {\n            throw new IllegalArgumentException(\n                    Messages.getMessage(\"serviceFactoryIllegalServiceInterface\"));\n        }\n        if (!(javax.xml.rpc.Service.class).isAssignableFrom(serviceInterface))\n        {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceInterfaceRequirement\", serviceInterface.getName()));\n        } else {\n            String serviceImplementationName = serviceInterface.getName() + SERVICE_IMPLEMENTATION_SUFFIX;\n            Service service = createService(serviceImplementationName);\n            return service;\n        }\n    }\n\n    /**\n     * Create an instance of the generated service implementation class \n     * for a given service, if available. \n     * The service is uniquely identified by the wsdlDocumentLocation and serviceName arguments. \n     * An implementation may use the provided properties to help locate the generated implementation class. \n     * If no such class is present, a ServiceException will be thrown. \n     *\n     *  @param   wsdlDocumentLocation URL for the WSDL document location for the service or null \n     *  @param   serviceName Qualified name for the service \n     *  @param   properties A set of implementation-specific properties \n     *      to help locate the generated service implementation class \n     *  @return  Service.\n     *  @throws  ServiceException If there is any error while creating the specified service, \n     *      including the case where a generated service implementation class cannot be located\n     */\n    public javax.xml.rpc.Service loadService(URL wsdlDocumentLocation, \n            QName serviceName, Properties properties) throws ServiceException {\n        String serviceImplementationName = properties.getProperty(SERVICE_IMPLEMENTATION_NAME_PROPERTY);\n        javax.xml.rpc.Service service = createService(serviceImplementationName);\n        if (service.getServiceName().equals(serviceName)) {\n            return service;\n        } else {\n            throw new ServiceException(\n                    Messages.getMessage(\"serviceFactoryServiceImplementationNotFound\", serviceImplementationName));\n        }\n    }\n\n    private Service createService(String serviceImplementationName) throws ServiceException {\n        if(serviceImplementationName == null) {\n            throw new IllegalArgumentException(Messages.getMessage(\"serviceFactoryInvalidServiceName\"));\n        }\n        try {\n            Class serviceImplementationClass;\n            serviceImplementationClass = Thread.currentThread().getContextClassLoader().loadClass(serviceImplementationName);\n            if (!(org.apache.axis.client.Service.class).isAssignableFrom(serviceImplementationClass)) {\n                throw new ServiceException(\n                        Messages.getMessage(\"serviceFactoryServiceImplementationRequirement\", serviceImplementationName));\n            }\n            Service service = (Service) serviceImplementationClass.newInstance();\n            if (service.getServiceName() != null) {\n                return service;\n            } else {\n                throw new ServiceException(Messages.getMessage(\"serviceFactoryInvalidServiceName\"));\n            }\n        } catch (ServiceException e) {\n            throw e;\n        } catch (Exception e){\n            throw new ServiceException(e);\n        }\n        \n    }\n}\n"], "filenames": ["axis-rt-core/src/main/java/org/apache/axis/client/ServiceFactory.java"], "buggy_code_start_loc": [108], "buggy_code_end_loc": [122], "fixing_code_start_loc": [109], "fixing_code_end_loc": [128], "type": "CWE-20", "message": "** UNSUPPORTED WHEN ASSIGNED ** When integrating Apache Axis 1.x in an application, it may not have been obvious that looking up a service through \"ServiceFactory.getService\" allows potentially dangerous lookup mechanisms such as LDAP. When passing untrusted input to this API method, this could expose the application to DoS, SSRF and even attacks leading to RCE.\n\nAs Axis 1 has been EOL we recommend you migrate to a different SOAP engine, such as Apache Axis 2/Java. As a workaround, you may review your code to verify no untrusted or unsanitized input is passed to \"ServiceFactory.getService\", or by applying the patch from  https://github.com/apache/axis-axis1-java/commit/7e66753427466590d6def0125e448d2791723210 . The Apache Axis project does not expect to create an Axis 1.x release fixing this problem, though contributors that would like to work towards this are welcome.\n\n", "other": {"cve": {"id": "CVE-2023-40743", "sourceIdentifier": "security@apache.org", "published": "2023-09-05T15:15:42.687", "lastModified": "2023-11-07T04:20:21.547", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** UNSUPPORTED WHEN ASSIGNED ** When integrating Apache Axis 1.x in an application, it may not have been obvious that looking up a service through \"ServiceFactory.getService\" allows potentially dangerous lookup mechanisms such as LDAP. When passing untrusted input to this API method, this could expose the application to DoS, SSRF and even attacks leading to RCE.\n\nAs Axis 1 has been EOL we recommend you migrate to a different SOAP engine, such as Apache Axis 2/Java. As a workaround, you may review your code to verify no untrusted or unsanitized input is passed to \"ServiceFactory.getService\", or by applying the patch from  https://github.com/apache/axis-axis1-java/commit/7e66753427466590d6def0125e448d2791723210 . The Apache Axis project does not expect to create an Axis 1.x release fixing this problem, though contributors that would like to work towards this are welcome.\n\n"}, {"lang": "es", "value": "** NO SOPORTADO CUANDO  EST\u00c9 ASIGNADO ** ** NO SOPORTADO CUANDO  EST\u00c9 ASIGNADO ** Al integrar Apache Axis 1.x en una aplicaci\u00f3n, puede que no haya sido obvio que buscar un servicio a trav\u00e9s de \"ServiceFactory.getService\" permita mecanismos de b\u00fasqueda potencialmente peligrosos como LDAP . Al pasar entradas que no son de confianza a este m\u00e9todo API, esto podr\u00eda exponer la aplicaci\u00f3n a DoS, SSRF e incluso ataques que conduzcan a RCE. Como Axis 1 ha estado en EOL, le recomendamos migrar a un motor SOAP diferente, como Apache Axis 2/Java. Como workaround, puede revisar su c\u00f3digo para verificar que no se pase ninguna entrada que no sea de confianza o no sanitizada a \"ServiceFactory.getService\", o aplicando el parche desde https://github.com/apache/axis-axis1-java/commit/7e66753427466590d6def0125e448d2791723210. El proyecto Apache Axis no espera crear una versi\u00f3n Axis 1.x que solucione este problema, aunque los contribuyentes que deseen trabajar para lograrlo son bienvenidos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@apache.org", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:axis:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-08-01", "matchCriteriaId": "28772E39-4100-404C-8274-8A4FF7DDF588"}]}]}], "references": [{"url": "https://github.com/apache/axis-axis1-java/commit/7e66753427466590d6def0125e448d2791723210", "source": "security@apache.org", "tags": ["Patch"]}, {"url": "https://lists.apache.org/thread/gs0qgk2mgss7zfhzdd6ftfjvm4kp7v82", "source": "security@apache.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00025.html", "source": "security@apache.org"}]}, "github_commit_url": "https://github.com/apache/axis-axis1-java/commit/7e66753427466590d6def0125e448d2791723210"}}