{"buggy_code": ["/*\n * Copyright \u00a9 2010 Codethink Limited\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: Ryan Lortie <desrt@desrt.ca>\n */\n\n#include \"gvdb-builder.h\"\n#include \"gvdb-format.h\"\n\n#include <glib.h>\n#include <fcntl.h>\n#if !defined(G_OS_WIN32) || !defined(_MSC_VER)\n#include <unistd.h>\n#endif\n#include <string.h>\n\n\nstruct _GvdbItem\n{\n  gchar *key;\n  guint32 hash_value;\n  guint32_le assigned_index;\n  GvdbItem *parent;\n  GvdbItem *sibling;\n  GvdbItem *next;\n\n  /* one of:\n   * this:\n   */\n  GVariant *value;\n\n  /* this: */\n  GHashTable *table;\n\n  /* or this: */\n  GvdbItem *child;\n};\n\nstatic void\ngvdb_item_free (gpointer data)\n{\n  GvdbItem *item = data;\n\n  g_free (item->key);\n\n  if (item->value)\n    g_variant_unref (item->value);\n\n  if (item->table)\n    g_hash_table_unref (item->table);\n\n  g_slice_free (GvdbItem, item);\n}\n\nGHashTable *\ngvdb_hash_table_new (GHashTable  *parent,\n                     const gchar *name_in_parent)\n{\n  GHashTable *table;\n\n  table = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                 g_free, gvdb_item_free);\n\n  if (parent)\n    {\n      GvdbItem *item;\n\n      item = gvdb_hash_table_insert (parent, name_in_parent);\n      gvdb_item_set_hash_table (item, table);\n    }\n\n  return table;\n}\n\nstatic guint32\ndjb_hash (const gchar *key)\n{\n  guint32 hash_value = 5381;\n\n  while (*key)\n    hash_value = hash_value * 33 + *(signed char *)key++;\n\n  return hash_value;\n}\n\nGvdbItem *\ngvdb_hash_table_insert (GHashTable  *table,\n                        const gchar *key)\n{\n  GvdbItem *item;\n\n  item = g_slice_new0 (GvdbItem);\n  item->key = g_strdup (key);\n  item->hash_value = djb_hash (key);\n\n  g_hash_table_insert (table, g_strdup (key), item);\n\n  return item;\n}\n\nvoid\ngvdb_hash_table_insert_string (GHashTable  *table,\n                               const gchar *key,\n                               const gchar *value)\n{\n  GvdbItem *item;\n\n  item = gvdb_hash_table_insert (table, key);\n  gvdb_item_set_value (item, g_variant_new_string (value));\n}\n\nvoid\ngvdb_item_set_value (GvdbItem *item,\n                     GVariant *value)\n{\n  g_return_if_fail (!item->value && !item->table && !item->child);\n\n  item->value = g_variant_ref_sink (value);\n}\n\nvoid\ngvdb_item_set_hash_table (GvdbItem   *item,\n                          GHashTable *table)\n{\n  g_return_if_fail (!item->value && !item->table && !item->child);\n\n  item->table = g_hash_table_ref (table);\n}\n\nvoid\ngvdb_item_set_parent (GvdbItem *item,\n                      GvdbItem *parent)\n{\n  GvdbItem **node;\n\n  g_return_if_fail (g_str_has_prefix (item->key, parent->key));\n  g_return_if_fail (!parent->value && !parent->table);\n  g_return_if_fail (!item->parent && !item->sibling);\n\n  for (node = &parent->child; *node; node = &(*node)->sibling)\n    if (strcmp ((*node)->key, item->key) > 0)\n      break;\n\n  item->parent = parent;\n  item->sibling = *node;\n  *node = item;\n}\n\ntypedef struct\n{\n  GvdbItem **buckets;\n  gint n_buckets;\n} HashTable;\n\nstatic HashTable *\nhash_table_new (gint n_buckets)\n{\n  HashTable *table;\n\n  table = g_slice_new (HashTable);\n  table->buckets = g_new0 (GvdbItem *, n_buckets);\n  table->n_buckets = n_buckets;\n\n  return table;\n}\n\nstatic void\nhash_table_free (HashTable *table)\n{\n  g_free (table->buckets);\n\n  g_slice_free (HashTable, table);\n}\n\nstatic void\nhash_table_insert (gpointer key,\n                   gpointer value,\n                   gpointer data)\n{\n  guint32 hash_value, bucket;\n  HashTable *table = data;\n  GvdbItem *item = value;\n\n  hash_value = djb_hash (key);\n  bucket = hash_value % table->n_buckets;\n  item->next = table->buckets[bucket];\n  table->buckets[bucket] = item;\n}\n\nstatic guint32_le\nitem_to_index (GvdbItem *item)\n{\n  if (item != NULL)\n    return item->assigned_index;\n\n  return guint32_to_le (-1u);\n}\n\ntypedef struct\n{\n  GQueue *chunks;\n  guint64 offset;\n  gboolean byteswap;\n} FileBuilder;\n\ntypedef struct\n{\n  gsize offset;\n  gsize size;\n  gpointer data;\n} FileChunk;\n\nstatic gpointer\nfile_builder_allocate (FileBuilder         *fb,\n                       guint                alignment,\n                       gsize                size,\n                       struct gvdb_pointer *pointer)\n{\n  FileChunk *chunk;\n\n  if (size == 0)\n    return NULL;\n\n  fb->offset += (-fb->offset) & (alignment - 1);\n  chunk = g_slice_new (FileChunk);\n  chunk->offset = fb->offset;\n  chunk->size = size;\n  chunk->data = g_malloc (size);\n\n  pointer->start = guint32_to_le (fb->offset);\n  fb->offset += size;\n  pointer->end = guint32_to_le (fb->offset);\n\n  g_queue_push_tail (fb->chunks, chunk);\n\n  return chunk->data;\n}\n\nstatic void\nfile_builder_add_value (FileBuilder         *fb,\n                        GVariant            *value,\n                        struct gvdb_pointer *pointer)\n{\n  GVariant *variant, *normal;\n  gpointer data;\n  gsize size;\n\n  if (fb->byteswap)\n    {\n      value = g_variant_byteswap (value);\n      variant = g_variant_new_variant (value);\n      g_variant_unref (value);\n    }\n  else\n    variant = g_variant_new_variant (value);\n\n  normal = g_variant_get_normal_form (variant);\n  g_variant_unref (variant);\n\n  size = g_variant_get_size (normal);\n  data = file_builder_allocate (fb, 8, size, pointer);\n  g_variant_store (normal, data);\n  g_variant_unref (normal);\n}\n\nstatic void\nfile_builder_add_string (FileBuilder *fb,\n                         const gchar *string,\n                         guint32_le  *start,\n                         guint16_le  *size)\n{\n  FileChunk *chunk;\n  gsize length;\n\n  length = strlen (string);\n\n  chunk = g_slice_new (FileChunk);\n  chunk->offset = fb->offset;\n  chunk->size = length;\n  chunk->data = g_malloc (length);\n  if (length != 0)\n    memcpy (chunk->data, string, length);\n\n  *start = guint32_to_le (fb->offset);\n  *size = guint16_to_le (length);\n  fb->offset += length;\n\n  g_queue_push_tail (fb->chunks, chunk);\n}\n\nstatic void\nfile_builder_allocate_for_hash (FileBuilder            *fb,\n                                gsize                   n_buckets,\n                                gsize                   n_items,\n                                guint                   bloom_shift,\n                                gsize                   n_bloom_words,\n                                guint32_le            **bloom_filter,\n                                guint32_le            **hash_buckets,\n                                struct gvdb_hash_item **hash_items,\n                                struct gvdb_pointer    *pointer)\n{\n  guint32_le bloom_hdr, table_hdr;\n  guchar *data;\n  gsize size;\n\n  g_assert (n_bloom_words < (1u << 27));\n\n  bloom_hdr = guint32_to_le (bloom_shift << 27 | n_bloom_words);\n  table_hdr = guint32_to_le (n_buckets);\n\n  size = sizeof bloom_hdr + sizeof table_hdr +\n         n_bloom_words * sizeof (guint32_le) +\n         n_buckets     * sizeof (guint32_le) +\n         n_items       * sizeof (struct gvdb_hash_item);\n\n  data = file_builder_allocate (fb, 4, size, pointer);\n\n#define chunk(s) (size -= (s), data += (s), data - (s))\n  memcpy (chunk (sizeof bloom_hdr), &bloom_hdr, sizeof bloom_hdr);\n  memcpy (chunk (sizeof table_hdr), &table_hdr, sizeof table_hdr);\n  *bloom_filter = (guint32_le *) chunk (n_bloom_words * sizeof (guint32_le));\n  *hash_buckets = (guint32_le *) chunk (n_buckets * sizeof (guint32_le));\n  *hash_items = (struct gvdb_hash_item *) chunk (n_items *\n                  sizeof (struct gvdb_hash_item));\n  g_assert (size == 0);\n#undef chunk\n\n  memset (*bloom_filter, 0, n_bloom_words * sizeof (guint32_le));\n\n  /* NOTE - the code to actually fill in the bloom filter here is missing.\n   * Patches welcome!\n   *\n   * http://en.wikipedia.org/wiki/Bloom_filter\n   * http://0pointer.de/blog/projects/bloom.html\n   */\n}\n\nstatic void\nfile_builder_add_hash (FileBuilder         *fb,\n                       GHashTable          *table,\n                       struct gvdb_pointer *pointer)\n{\n  guint32_le *buckets, *bloom_filter;\n  struct gvdb_hash_item *items;\n  HashTable *mytable;\n  GvdbItem *item;\n  guint32 index;\n  gint bucket;\n\n  mytable = hash_table_new (g_hash_table_size (table));\n  g_hash_table_foreach (table, hash_table_insert, mytable);\n  index = 0;\n\n  for (bucket = 0; bucket < mytable->n_buckets; bucket++)\n    for (item = mytable->buckets[bucket]; item; item = item->next)\n      item->assigned_index = guint32_to_le (index++);\n\n  file_builder_allocate_for_hash (fb, mytable->n_buckets, index, 5, 0,\n                                  &bloom_filter, &buckets, &items, pointer);\n\n  index = 0;\n  for (bucket = 0; bucket < mytable->n_buckets; bucket++)\n    {\n      buckets[bucket] = guint32_to_le (index);\n\n      for (item = mytable->buckets[bucket]; item; item = item->next)\n        {\n          struct gvdb_hash_item *entry = items++;\n          const gchar *basename;\n\n          g_assert (index == guint32_from_le (item->assigned_index));\n          entry->hash_value = guint32_to_le (item->hash_value);\n          entry->parent = item_to_index (item->parent);\n          entry->unused = 0;\n\n          if (item->parent != NULL)\n            basename = item->key + strlen (item->parent->key);\n          else\n            basename = item->key;\n\n          file_builder_add_string (fb, basename,\n                                   &entry->key_start,\n                                   &entry->key_size);\n\n          if (item->value != NULL)\n            {\n              g_assert (item->child == NULL && item->table == NULL);\n\n              file_builder_add_value (fb, item->value, &entry->value.pointer);\n              entry->type = 'v';\n            }\n\n          if (item->child != NULL)\n            {\n              guint32 children = 0, i = 0;\n              guint32_le *offsets;\n              GvdbItem *child;\n\n              g_assert (item->table == NULL);\n\n              for (child = item->child; child; child = child->sibling)\n                children++;\n\n              offsets = file_builder_allocate (fb, 4, 4 * children,\n                                               &entry->value.pointer);\n              entry->type = 'L';\n\n              for (child = item->child; child; child = child->sibling)\n                offsets[i++] = child->assigned_index;\n\n              g_assert (children == i);\n            }\n\n          if (item->table != NULL)\n            {\n              entry->type = 'H';\n              file_builder_add_hash (fb, item->table, &entry->value.pointer);\n            }\n\n          index++;\n        }\n    }\n\n  hash_table_free (mytable);\n}\n\nstatic FileBuilder *\nfile_builder_new (gboolean byteswap)\n{\n  FileBuilder *builder;\n\n  builder = g_slice_new (FileBuilder);\n  builder->chunks = g_queue_new ();\n  builder->offset = sizeof (struct gvdb_header);\n  builder->byteswap = byteswap;\n\n  return builder;\n}\n\nstatic void\nfile_builder_free (FileBuilder *fb)\n{\n  g_queue_free (fb->chunks);\n  g_slice_free (FileBuilder, fb);\n}\n\nstatic GString *\nfile_builder_serialise (FileBuilder          *fb,\n                        struct gvdb_pointer   root)\n{\n  struct gvdb_header header = { { 0, }, };\n  GString *result;\n\n  if (fb->byteswap)\n    {\n      header.signature[0] = GVDB_SWAPPED_SIGNATURE0;\n      header.signature[1] = GVDB_SWAPPED_SIGNATURE1;\n    }\n  else\n    {\n      header.signature[0] = GVDB_SIGNATURE0;\n      header.signature[1] = GVDB_SIGNATURE1;\n    }\n\n  result = g_string_new (NULL);\n\n  header.root = root;\n  g_string_append_len (result, (gpointer) &header, sizeof header);\n\n  while (!g_queue_is_empty (fb->chunks))\n    {\n      FileChunk *chunk = g_queue_pop_head (fb->chunks);\n\n      if (result->len != chunk->offset)\n        {\n          gchar zero[8] = { 0, };\n\n          g_assert (chunk->offset > result->len);\n          g_assert (chunk->offset - result->len < 8);\n\n          g_string_append_len (result, zero, chunk->offset - result->len);\n          g_assert (result->len == chunk->offset);\n        }\n\n      g_string_append_len (result, chunk->data, chunk->size);\n      g_free (chunk->data);\n\n      g_slice_free (FileChunk, chunk);\n    }\n\n  return result;\n}\n\ngboolean\ngvdb_table_write_contents (GHashTable   *table,\n                           const gchar  *filename,\n                           gboolean      byteswap,\n                           GError      **error)\n{\n  struct gvdb_pointer root;\n  gboolean status;\n  FileBuilder *fb;\n  GString *str;\n\n  g_return_val_if_fail (table != NULL, FALSE);\n  g_return_val_if_fail (filename != NULL, FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  file_builder_free (fb);\n\n  status = g_file_set_contents (filename, str->str, str->len, error);\n  g_string_free (str, TRUE);\n\n  return status;\n}\n\ntypedef struct {\n  GBytes *contents;  /* (owned) */\n  GFile  *file;      /* (owned) */\n} WriteContentsData;\n\nstatic WriteContentsData *\nwrite_contents_data_new (GBytes *contents,\n                         GFile  *file)\n{\n  WriteContentsData *data;\n\n  data = g_slice_new (WriteContentsData);\n  data->contents = g_bytes_ref (contents);\n  data->file = g_object_ref (file);\n\n  return data;\n}\n\nstatic void\nwrite_contents_data_free (WriteContentsData *data)\n{\n  g_bytes_unref (data->contents);\n  g_object_unref (data->file);\n  g_slice_free (WriteContentsData, data);\n}\n\nstatic void\nreplace_contents_cb (GObject      *source_object,\n                     GAsyncResult *result,\n                     gpointer      user_data)\n{\n  GTask *task = user_data;\n  WriteContentsData *data = g_task_get_task_data (task);\n  GError *error = NULL;\n\n  g_return_if_fail (g_task_get_source_tag (task) == gvdb_table_write_contents_async);\n\n  if (!g_file_replace_contents_finish (data->file, result, NULL, &error))\n    g_task_return_error (task, g_steal_pointer (&error));\n  else\n    g_task_return_boolean (task, TRUE);\n\n  g_object_unref (task);\n}\n\nvoid\ngvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}\n\ngboolean\ngvdb_table_write_contents_finish (GHashTable    *table,\n                                  GAsyncResult  *result,\n                                  GError       **error)\n{\n  g_return_val_if_fail (table != NULL, FALSE);\n  g_return_val_if_fail (g_task_is_valid (result, NULL), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (result), error);\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2010 Codethink Limited\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: Ryan Lortie <desrt@desrt.ca>\n */\n\n#include \"gvdb-builder.h\"\n#include \"gvdb-format.h\"\n\n#include <glib.h>\n#include <fcntl.h>\n#if !defined(G_OS_WIN32) || !defined(_MSC_VER)\n#include <unistd.h>\n#endif\n#include <string.h>\n\n\nstruct _GvdbItem\n{\n  gchar *key;\n  guint32 hash_value;\n  guint32_le assigned_index;\n  GvdbItem *parent;\n  GvdbItem *sibling;\n  GvdbItem *next;\n\n  /* one of:\n   * this:\n   */\n  GVariant *value;\n\n  /* this: */\n  GHashTable *table;\n\n  /* or this: */\n  GvdbItem *child;\n};\n\nstatic void\ngvdb_item_free (gpointer data)\n{\n  GvdbItem *item = data;\n\n  g_free (item->key);\n\n  if (item->value)\n    g_variant_unref (item->value);\n\n  if (item->table)\n    g_hash_table_unref (item->table);\n\n  g_slice_free (GvdbItem, item);\n}\n\nGHashTable *\ngvdb_hash_table_new (GHashTable  *parent,\n                     const gchar *name_in_parent)\n{\n  GHashTable *table;\n\n  table = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                 g_free, gvdb_item_free);\n\n  if (parent)\n    {\n      GvdbItem *item;\n\n      item = gvdb_hash_table_insert (parent, name_in_parent);\n      gvdb_item_set_hash_table (item, table);\n    }\n\n  return table;\n}\n\nstatic guint32\ndjb_hash (const gchar *key)\n{\n  guint32 hash_value = 5381;\n\n  while (*key)\n    hash_value = hash_value * 33 + *(signed char *)key++;\n\n  return hash_value;\n}\n\nGvdbItem *\ngvdb_hash_table_insert (GHashTable  *table,\n                        const gchar *key)\n{\n  GvdbItem *item;\n\n  item = g_slice_new0 (GvdbItem);\n  item->key = g_strdup (key);\n  item->hash_value = djb_hash (key);\n\n  g_hash_table_insert (table, g_strdup (key), item);\n\n  return item;\n}\n\nvoid\ngvdb_hash_table_insert_string (GHashTable  *table,\n                               const gchar *key,\n                               const gchar *value)\n{\n  GvdbItem *item;\n\n  item = gvdb_hash_table_insert (table, key);\n  gvdb_item_set_value (item, g_variant_new_string (value));\n}\n\nvoid\ngvdb_item_set_value (GvdbItem *item,\n                     GVariant *value)\n{\n  g_return_if_fail (!item->value && !item->table && !item->child);\n\n  item->value = g_variant_ref_sink (value);\n}\n\nvoid\ngvdb_item_set_hash_table (GvdbItem   *item,\n                          GHashTable *table)\n{\n  g_return_if_fail (!item->value && !item->table && !item->child);\n\n  item->table = g_hash_table_ref (table);\n}\n\nvoid\ngvdb_item_set_parent (GvdbItem *item,\n                      GvdbItem *parent)\n{\n  GvdbItem **node;\n\n  g_return_if_fail (g_str_has_prefix (item->key, parent->key));\n  g_return_if_fail (!parent->value && !parent->table);\n  g_return_if_fail (!item->parent && !item->sibling);\n\n  for (node = &parent->child; *node; node = &(*node)->sibling)\n    if (strcmp ((*node)->key, item->key) > 0)\n      break;\n\n  item->parent = parent;\n  item->sibling = *node;\n  *node = item;\n}\n\ntypedef struct\n{\n  GvdbItem **buckets;\n  gint n_buckets;\n} HashTable;\n\nstatic HashTable *\nhash_table_new (gint n_buckets)\n{\n  HashTable *table;\n\n  table = g_slice_new (HashTable);\n  table->buckets = g_new0 (GvdbItem *, n_buckets);\n  table->n_buckets = n_buckets;\n\n  return table;\n}\n\nstatic void\nhash_table_free (HashTable *table)\n{\n  g_free (table->buckets);\n\n  g_slice_free (HashTable, table);\n}\n\nstatic void\nhash_table_insert (gpointer key,\n                   gpointer value,\n                   gpointer data)\n{\n  guint32 hash_value, bucket;\n  HashTable *table = data;\n  GvdbItem *item = value;\n\n  hash_value = djb_hash (key);\n  bucket = hash_value % table->n_buckets;\n  item->next = table->buckets[bucket];\n  table->buckets[bucket] = item;\n}\n\nstatic guint32_le\nitem_to_index (GvdbItem *item)\n{\n  if (item != NULL)\n    return item->assigned_index;\n\n  return guint32_to_le (-1u);\n}\n\ntypedef struct\n{\n  GQueue *chunks;\n  guint64 offset;\n  gboolean byteswap;\n} FileBuilder;\n\ntypedef struct\n{\n  gsize offset;\n  gsize size;\n  gpointer data;\n} FileChunk;\n\nstatic gpointer\nfile_builder_allocate (FileBuilder         *fb,\n                       guint                alignment,\n                       gsize                size,\n                       struct gvdb_pointer *pointer)\n{\n  FileChunk *chunk;\n\n  if (size == 0)\n    return NULL;\n\n  fb->offset += (-fb->offset) & (alignment - 1);\n  chunk = g_slice_new (FileChunk);\n  chunk->offset = fb->offset;\n  chunk->size = size;\n  chunk->data = g_malloc (size);\n\n  pointer->start = guint32_to_le (fb->offset);\n  fb->offset += size;\n  pointer->end = guint32_to_le (fb->offset);\n\n  g_queue_push_tail (fb->chunks, chunk);\n\n  return chunk->data;\n}\n\nstatic void\nfile_builder_add_value (FileBuilder         *fb,\n                        GVariant            *value,\n                        struct gvdb_pointer *pointer)\n{\n  GVariant *variant, *normal;\n  gpointer data;\n  gsize size;\n\n  if (fb->byteswap)\n    {\n      value = g_variant_byteswap (value);\n      variant = g_variant_new_variant (value);\n      g_variant_unref (value);\n    }\n  else\n    variant = g_variant_new_variant (value);\n\n  normal = g_variant_get_normal_form (variant);\n  g_variant_unref (variant);\n\n  size = g_variant_get_size (normal);\n  data = file_builder_allocate (fb, 8, size, pointer);\n  g_variant_store (normal, data);\n  g_variant_unref (normal);\n}\n\nstatic void\nfile_builder_add_string (FileBuilder *fb,\n                         const gchar *string,\n                         guint32_le  *start,\n                         guint16_le  *size)\n{\n  FileChunk *chunk;\n  gsize length;\n\n  length = strlen (string);\n\n  chunk = g_slice_new (FileChunk);\n  chunk->offset = fb->offset;\n  chunk->size = length;\n  chunk->data = g_malloc (length);\n  if (length != 0)\n    memcpy (chunk->data, string, length);\n\n  *start = guint32_to_le (fb->offset);\n  *size = guint16_to_le (length);\n  fb->offset += length;\n\n  g_queue_push_tail (fb->chunks, chunk);\n}\n\nstatic void\nfile_builder_allocate_for_hash (FileBuilder            *fb,\n                                gsize                   n_buckets,\n                                gsize                   n_items,\n                                guint                   bloom_shift,\n                                gsize                   n_bloom_words,\n                                guint32_le            **bloom_filter,\n                                guint32_le            **hash_buckets,\n                                struct gvdb_hash_item **hash_items,\n                                struct gvdb_pointer    *pointer)\n{\n  guint32_le bloom_hdr, table_hdr;\n  guchar *data;\n  gsize size;\n\n  g_assert (n_bloom_words < (1u << 27));\n\n  bloom_hdr = guint32_to_le (bloom_shift << 27 | n_bloom_words);\n  table_hdr = guint32_to_le (n_buckets);\n\n  size = sizeof bloom_hdr + sizeof table_hdr +\n         n_bloom_words * sizeof (guint32_le) +\n         n_buckets     * sizeof (guint32_le) +\n         n_items       * sizeof (struct gvdb_hash_item);\n\n  data = file_builder_allocate (fb, 4, size, pointer);\n\n#define chunk(s) (size -= (s), data += (s), data - (s))\n  memcpy (chunk (sizeof bloom_hdr), &bloom_hdr, sizeof bloom_hdr);\n  memcpy (chunk (sizeof table_hdr), &table_hdr, sizeof table_hdr);\n  *bloom_filter = (guint32_le *) chunk (n_bloom_words * sizeof (guint32_le));\n  *hash_buckets = (guint32_le *) chunk (n_buckets * sizeof (guint32_le));\n  *hash_items = (struct gvdb_hash_item *) chunk (n_items *\n                  sizeof (struct gvdb_hash_item));\n  g_assert (size == 0);\n#undef chunk\n\n  memset (*bloom_filter, 0, n_bloom_words * sizeof (guint32_le));\n\n  /* NOTE - the code to actually fill in the bloom filter here is missing.\n   * Patches welcome!\n   *\n   * http://en.wikipedia.org/wiki/Bloom_filter\n   * http://0pointer.de/blog/projects/bloom.html\n   */\n}\n\nstatic void\nfile_builder_add_hash (FileBuilder         *fb,\n                       GHashTable          *table,\n                       struct gvdb_pointer *pointer)\n{\n  guint32_le *buckets, *bloom_filter;\n  struct gvdb_hash_item *items;\n  HashTable *mytable;\n  GvdbItem *item;\n  guint32 index;\n  gint bucket;\n\n  mytable = hash_table_new (g_hash_table_size (table));\n  g_hash_table_foreach (table, hash_table_insert, mytable);\n  index = 0;\n\n  for (bucket = 0; bucket < mytable->n_buckets; bucket++)\n    for (item = mytable->buckets[bucket]; item; item = item->next)\n      item->assigned_index = guint32_to_le (index++);\n\n  file_builder_allocate_for_hash (fb, mytable->n_buckets, index, 5, 0,\n                                  &bloom_filter, &buckets, &items, pointer);\n\n  index = 0;\n  for (bucket = 0; bucket < mytable->n_buckets; bucket++)\n    {\n      buckets[bucket] = guint32_to_le (index);\n\n      for (item = mytable->buckets[bucket]; item; item = item->next)\n        {\n          struct gvdb_hash_item *entry = items++;\n          const gchar *basename;\n\n          g_assert (index == guint32_from_le (item->assigned_index));\n          entry->hash_value = guint32_to_le (item->hash_value);\n          entry->parent = item_to_index (item->parent);\n          entry->unused = 0;\n\n          if (item->parent != NULL)\n            basename = item->key + strlen (item->parent->key);\n          else\n            basename = item->key;\n\n          file_builder_add_string (fb, basename,\n                                   &entry->key_start,\n                                   &entry->key_size);\n\n          if (item->value != NULL)\n            {\n              g_assert (item->child == NULL && item->table == NULL);\n\n              file_builder_add_value (fb, item->value, &entry->value.pointer);\n              entry->type = 'v';\n            }\n\n          if (item->child != NULL)\n            {\n              guint32 children = 0, i = 0;\n              guint32_le *offsets;\n              GvdbItem *child;\n\n              g_assert (item->table == NULL);\n\n              for (child = item->child; child; child = child->sibling)\n                children++;\n\n              offsets = file_builder_allocate (fb, 4, 4 * children,\n                                               &entry->value.pointer);\n              entry->type = 'L';\n\n              for (child = item->child; child; child = child->sibling)\n                offsets[i++] = child->assigned_index;\n\n              g_assert (children == i);\n            }\n\n          if (item->table != NULL)\n            {\n              entry->type = 'H';\n              file_builder_add_hash (fb, item->table, &entry->value.pointer);\n            }\n\n          index++;\n        }\n    }\n\n  hash_table_free (mytable);\n}\n\nstatic FileBuilder *\nfile_builder_new (gboolean byteswap)\n{\n  FileBuilder *builder;\n\n  builder = g_slice_new (FileBuilder);\n  builder->chunks = g_queue_new ();\n  builder->offset = sizeof (struct gvdb_header);\n  builder->byteswap = byteswap;\n\n  return builder;\n}\n\nstatic void\nfile_builder_free (FileBuilder *fb)\n{\n  g_queue_free (fb->chunks);\n  g_slice_free (FileBuilder, fb);\n}\n\nstatic GString *\nfile_builder_serialise (FileBuilder          *fb,\n                        struct gvdb_pointer   root)\n{\n  struct gvdb_header header = { { 0, }, };\n  GString *result;\n\n  if (fb->byteswap)\n    {\n      header.signature[0] = GVDB_SWAPPED_SIGNATURE0;\n      header.signature[1] = GVDB_SWAPPED_SIGNATURE1;\n    }\n  else\n    {\n      header.signature[0] = GVDB_SIGNATURE0;\n      header.signature[1] = GVDB_SIGNATURE1;\n    }\n\n  result = g_string_new (NULL);\n\n  header.root = root;\n  g_string_append_len (result, (gpointer) &header, sizeof header);\n\n  while (!g_queue_is_empty (fb->chunks))\n    {\n      FileChunk *chunk = g_queue_pop_head (fb->chunks);\n\n      if (result->len != chunk->offset)\n        {\n          gchar zero[8] = { 0, };\n\n          g_assert (chunk->offset > result->len);\n          g_assert (chunk->offset - result->len < 8);\n\n          g_string_append_len (result, zero, chunk->offset - result->len);\n          g_assert (result->len == chunk->offset);\n        }\n\n      g_string_append_len (result, chunk->data, chunk->size);\n      g_free (chunk->data);\n\n      g_slice_free (FileChunk, chunk);\n    }\n\n  return result;\n}\n\ngboolean\ngvdb_table_write_contents (GHashTable   *table,\n                           const gchar  *filename,\n                           gboolean      byteswap,\n                           GError      **error)\n{\n  struct gvdb_pointer root;\n  gboolean status;\n  FileBuilder *fb;\n  GString *str;\n\n  g_return_val_if_fail (table != NULL, FALSE);\n  g_return_val_if_fail (filename != NULL, FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  file_builder_free (fb);\n\n  status = g_file_set_contents (filename, str->str, str->len, error);\n  g_string_free (str, TRUE);\n\n  return status;\n}\n\ntypedef struct {\n  GBytes *contents;  /* (owned) */\n  GFile  *file;      /* (owned) */\n} WriteContentsData;\n\nstatic WriteContentsData *\nwrite_contents_data_new (GBytes *contents,\n                         GFile  *file)\n{\n  WriteContentsData *data;\n\n  data = g_slice_new (WriteContentsData);\n  data->contents = g_bytes_ref (contents);\n  data->file = g_object_ref (file);\n\n  return data;\n}\n\nstatic void\nwrite_contents_data_free (WriteContentsData *data)\n{\n  g_bytes_unref (data->contents);\n  g_object_unref (data->file);\n  g_slice_free (WriteContentsData, data);\n}\n\nstatic void\nreplace_contents_cb (GObject      *source_object,\n                     GAsyncResult *result,\n                     gpointer      user_data)\n{\n  GTask *task = user_data;\n  WriteContentsData *data = g_task_get_task_data (task);\n  GError *error = NULL;\n\n  g_return_if_fail (g_task_get_source_tag (task) == gvdb_table_write_contents_async);\n\n  if (!g_file_replace_contents_finish (data->file, result, NULL, &error))\n    g_task_return_error (task, g_steal_pointer (&error));\n  else\n    g_task_return_boolean (task, TRUE);\n\n  g_object_unref (task);\n}\n\nvoid\ngvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n\n  g_file_replace_contents_async (file,\n                                 g_bytes_get_data (bytes, NULL),\n                                 g_bytes_get_size (bytes),\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}\n\ngboolean\ngvdb_table_write_contents_finish (GHashTable    *table,\n                                  GAsyncResult  *result,\n                                  GError       **error)\n{\n  g_return_val_if_fail (table != NULL, FALSE);\n  g_return_val_if_fail (g_task_is_valid (result, NULL), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (result), error);\n}\n"], "filenames": ["gvdb-builder.c"], "buggy_code_start_loc": [611], "buggy_code_end_loc": [612], "fixing_code_start_loc": [611], "fixing_code_end_loc": [614], "type": "CWE-416", "message": "A vulnerability was found in GNOME gvdb. It has been classified as critical. This affects the function gvdb_table_write_contents_async of the file gvdb-builder.c. The manipulation leads to use after free. It is possible to initiate the attack remotely. The name of the patch is d83587b2a364eb9a9a53be7e6a708074e252de14. It is recommended to apply a patch to fix this issue. The identifier VDB-216789 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2019-25085", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-26T07:15:09.713", "lastModified": "2023-01-05T03:19:37.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in GNOME gvdb. It has been classified as critical. This affects the function gvdb_table_write_contents_async of the file gvdb-builder.c. The manipulation leads to use after free. It is possible to initiate the attack remotely. The name of the patch is d83587b2a364eb9a9a53be7e6a708074e252de14. It is recommended to apply a patch to fix this issue. The identifier VDB-216789 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gvariant_database:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-06-27", "matchCriteriaId": "E600BC3A-7C5A-4C67-B8DE-0964836F1EA4"}]}]}], "references": [{"url": "https://github.com/GNOME/gvdb/commit/d83587b2a364eb9a9a53be7e6a708074e252de14", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216789", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216789", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GNOME/gvdb/commit/d83587b2a364eb9a9a53be7e6a708074e252de14"}}