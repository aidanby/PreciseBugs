{"buggy_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.commonwl.view.cwl;\n\nimport static org.apache.commons.io.FileUtils.readFileToString;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.jena.iri.IRI;\nimport org.apache.jena.iri.IRIFactory;\nimport org.apache.jena.ontology.OntModelSpec;\nimport org.apache.jena.query.QuerySolution;\nimport org.apache.jena.query.ResultSet;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.riot.RiotException;\nimport org.commonwl.view.docker.DockerService;\nimport org.commonwl.view.git.GitDetails;\nimport org.commonwl.view.graphviz.ModelDotWriter;\nimport org.commonwl.view.graphviz.RDFDotWriter;\nimport org.commonwl.view.workflow.Workflow;\nimport org.commonwl.view.workflow.WorkflowNotFoundException;\nimport org.commonwl.view.workflow.WorkflowOverview;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.yaml.snakeyaml.Yaml;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.TextNode;\n\n/**\n * Provides CWL parsing for workflows to gather an overview\n * for display and visualisation\n */\n@Service\npublic class CWLService {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n    private final IRIFactory iriFactory = IRIFactory.iriImplementation();\n\n    // Autowired properties/services\n    private final RDFService rdfService;\n    private final CWLTool cwlTool;\n    private final int singleFileSizeLimit;\n\n    // CWL specific strings\n    private final String DOC_GRAPH = \"$graph\";\n    private final String CLASS = \"class\";\n    private final String WORKFLOW = \"Workflow\";\n    private final String COMMANDLINETOOL = \"CommandLineTool\";\n    private final String EXPRESSIONTOOL = \"ExpressionTool\";\n    private final String STEPS = \"steps\";\n    private final String INPUTS = \"inputs\";\n    private final String IN = \"in\";\n    private final String OUTPUTS = \"outputs\";\n    private final String OUT = \"out\";\n    private final String ID = \"id\";\n    private final String TYPE = \"type\";\n    private final String LABEL = \"label\";\n    private final String DEFAULT = \"default\";\n    private final String OUTPUT_SOURCE = \"outputSource\";\n    private final String SOURCE = \"source\";\n    private final String DOC = \"doc\";\n    private final String DESCRIPTION = \"description\";\n    private final String ARRAY = \"array\";\n    private final String ARRAY_ITEMS = \"items\";\n    private final String LOCATION = \"location\";\n    private final String RUN = \"run\";\n\n    /**\n     * Constructor for the Common Workflow Language service\n     * @param rdfService A service for handling RDF queries\n     * @param cwlTool Handles cwltool integration\n     * @param singleFileSizeLimit The file size limit for single files\n     */\n    @Autowired\n    public CWLService(RDFService rdfService,\n                      CWLTool cwlTool,\n                      @Value(\"${singleFileSizeLimit}\") int singleFileSizeLimit) {\n        this.rdfService = rdfService;\n        this.cwlTool = cwlTool;\n        this.singleFileSizeLimit = singleFileSizeLimit;\n    }\n\n    /**\n     * Gets whether a file is packed using schema salad\n     * @param workflowFile The file to be parsed\n     * @return Whether the file is packed\n     */\n    public boolean isPacked(File workflowFile) throws IOException {\n        if (workflowFile.length() > singleFileSizeLimit) {\n            return false;\n        }\n        String fileContent = readFileToString(workflowFile);\n        return fileContent.contains(\"$graph\");\n    }\n\n    /**\n     * Gets a list of workflows from a packed CWL file\n     * @param packedFile The packed CWL file\n     * @return The list of workflow overviews\n     */\n    public List<WorkflowOverview> getWorkflowOverviewsFromPacked(File packedFile) throws IOException {\n        if (packedFile.length() <= singleFileSizeLimit) {\n            List<WorkflowOverview> overviews = new ArrayList<>();\n\n            JsonNode packedJson = yamlPathToJson(packedFile.toPath());\n\n            if (packedJson.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : packedJson.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        WorkflowOverview overview = new WorkflowOverview(jsonNode.get(ID).asText(),\n                                extractLabel(jsonNode), extractDoc(jsonNode));\n                        overviews.add(overview);\n                    }\n                }\n            } else {\n                throw new IOException(\"The file given was not recognised as a packed CWL file\");\n            }\n\n            return overviews;\n\n        } else {\n            throw new IOException(\"File '\" + packedFile.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(packedFile.length()) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n    }\n\n    /**\n     * Gets the Workflow object from internal parsing. \n     * Note, the length of the stream is not checked.\n     *  \n     * @param workflowStream The workflow stream to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed. <code>null</code> means the workflow is not expected to be packed, while \"\" means the first workflow found is used, packed or non-packed.\n     * @param defaultLabel Label to give workflow if not set\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(InputStream workflowStream, String packedWorkflowId, String defaultLabel) throws IOException {\n        // Parse file as yaml\n        JsonNode cwlFile = yamlStreamToJson(workflowStream);\n\n        // Check packed workflow occurs\n        boolean found = false;\n        if (packedWorkflowId != null) {\n            if (cwlFile.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        String currentId = jsonNode.get(ID).asText();\n                        if (currentId.startsWith(\"#\")) {\n                            currentId = currentId.substring(1);\n                        }\n                        if (packedWorkflowId.isEmpty() || currentId.equals(packedWorkflowId)) {\n                            cwlFile = jsonNode;\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!found && ! packedWorkflowId.isEmpty()) throw new WorkflowNotFoundException();\n        }\n        if (! found && extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n        \t// Check the current json node is a workflow\n        \tfound = true;\n        }\n        if (! found) {\n            throw new WorkflowNotFoundException();\n        }\n\n        // Use filename for label if there is no defined one\n        String label = extractLabel(cwlFile);\n        if (label == null) {\n            label = defaultLabel;\n        }\n\n        // Construct the rest of the workflow model\n        Workflow workflowModel = new Workflow(label, extractDoc(cwlFile), getInputs(cwlFile),\n                getOutputs(cwlFile), getSteps(cwlFile));\n\n        workflowModel.setCwltoolVersion(cwlTool.getVersion());\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        ModelDotWriter dotWriter = new ModelDotWriter(graphWriter);\n        try {\n            dotWriter.writeGraph(workflowModel);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n        return workflowModel;\n\n\n    }\n\n    \n    /**\n     * Gets the Workflow object from internal parsing.\n     * The size of the workflow file must be below the configured \n     * singleFileSizeLimit in the constructor/spring config.\n     * \n     * @param workflowFile The workflow file to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(Path workflowFile, String packedWorkflowId) throws IOException {\n\n        // Check file size limit before parsing\n        long fileSizeBytes = Files.size(workflowFile);\n        if (fileSizeBytes <= singleFileSizeLimit) {\n        \ttry (InputStream in = Files.newInputStream(workflowFile)) {\n        \t\treturn parseWorkflowNative(in, packedWorkflowId, \n        \t\t\t\tworkflowFile.getName(workflowFile.getNameCount()-1).toString());\n        \t}\n        } else {\n            throw new IOException(\"File '\" + workflowFile.getFileName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Create a workflow model using cwltool rdf output\n     * @param basicModel The basic workflow object created thus far\n     * @param workflowFile The workflow file to run cwltool on\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowWithCwltool(Workflow basicModel,\n                                             Path workflowFile,\n                                             Path workTree) throws CWLValidationException {\n        GitDetails gitDetails = basicModel.getRetrievedFrom();\n        String latestCommit = basicModel.getLastCommit();\n        String packedWorkflowID = gitDetails.getPackedId();\n\n        // Get paths to workflow\n        String url = basicModel.getIdentifier();\n        String workflowFileURI = workflowFile.toAbsolutePath().toUri().toString();\n        URI workTreeUri = workTree.toAbsolutePath().toUri();\n\t\tString localPath = workflowFileURI;\n        String gitPath = gitDetails.getPath();\n        if (packedWorkflowID != null) {\n            if (packedWorkflowID.charAt(0) != '#') {\n                localPath += \"#\";\n                gitPath += \"#\";\n            }\n            localPath += packedWorkflowID;\n            gitPath += packedWorkflowID;\n        }\n\n        // Get RDF representation from cwltool\n        if (!rdfService.graphExists(url)) {\n            String rdf = cwlTool.getRDF(localPath);\n            // Replace /tmp/123123 with permalink base \n            // NOTE: We do not just replace workflowFileURI, all referenced files will also get rewritten\n\t\t\trdf = rdf.replace(workTreeUri.toString(),\n                    \"https://w3id.org/cwl/view/git/\" + latestCommit + \"/\");\n            // Workaround for common-workflow-language/cwltool#427\n            rdf = rdf.replace(\"<rdfs:>\", \"<http://www.w3.org/2000/01/rdf-schema#>\");\n\n            // Create a workflow model from RDF representation\n            Model model = ModelFactory.createDefaultModel();\n            model.read(new ByteArrayInputStream(rdf.getBytes()), null, \"TURTLE\");\n\n            // Store the model\n            rdfService.storeModel(url, model);\n        }\n\n        // Base workflow details\n        String label = FilenameUtils.getName(url);\n        String doc = null;\n        ResultSet labelAndDoc = rdfService.getLabelAndDoc(url);\n        if (labelAndDoc.hasNext()) {\n            QuerySolution labelAndDocSoln = labelAndDoc.nextSolution();\n            if (labelAndDocSoln.contains(\"label\")) {\n                label = labelAndDocSoln.get(\"label\").toString();\n            }\n            if (labelAndDocSoln.contains(\"doc\")) {\n                doc = labelAndDocSoln.get(\"doc\").toString();\n            }\n        }\n\n        // Inputs\n        Map<String, CWLElement> wfInputs = new HashMap<>();\n        ResultSet inputs = rdfService.getInputs(url);\n        while (inputs.hasNext()) {\n            QuerySolution input = inputs.nextSolution();\n            String inputName = rdfService.stepNameFromURI(gitPath, input.get(\"name\").toString());\n\n            CWLElement wfInput = new CWLElement();\n            if (input.contains(\"type\")) {\n                String type;\n                if (input.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(input.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(input.get(\"type\").toString());\n                }\n                if (input.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfInput.setType(type);\n            }\n            if (input.contains(\"format\")) {\n                String format = input.get(\"format\").toString();\n                setFormat(wfInput, format);\n            }\n            if (input.contains(\"label\")) {\n                wfInput.setLabel(input.get(\"label\").toString());\n            }\n            if (input.contains(\"doc\")) {\n                wfInput.setDoc(input.get(\"doc\").toString());\n            }\n            wfInputs.put(rdfService.labelFromName(inputName), wfInput);\n        }\n\n        // Outputs\n        Map<String, CWLElement> wfOutputs = new HashMap<>();\n        ResultSet outputs = rdfService.getOutputs(url);\n        while (outputs.hasNext()) {\n            QuerySolution output = outputs.nextSolution();\n            CWLElement wfOutput = new CWLElement();\n\n            String outputName = rdfService.stepNameFromURI(gitPath, output.get(\"name\").toString());\n            if (output.contains(\"type\")) {\n                String type;\n                if (output.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(output.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(output.get(\"type\").toString());\n                }\n                if (output.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfOutput.setType(type);\n            }\n\n            if (output.contains(\"src\")) {\n                wfOutput.addSourceID(rdfService.stepNameFromURI(gitPath,\n                        output.get(\"src\").toString()));\n            }\n            if (output.contains(\"format\")) {\n                String format = output.get(\"format\").toString();\n                setFormat(wfOutput, format);\n            }\n            if (output.contains(\"label\")) {\n                wfOutput.setLabel(output.get(\"label\").toString());\n            }\n            if (output.contains(\"doc\")) {\n                wfOutput.setDoc(output.get(\"doc\").toString());\n            }\n            wfOutputs.put(rdfService.labelFromName(outputName), wfOutput);\n        }\n\n\n        // Steps\n        Map<String, CWLStep> wfSteps = new HashMap<>();\n        ResultSet steps = rdfService.getSteps(url);\n        while (steps.hasNext()) {\n            QuerySolution step = steps.nextSolution();\n            String uri = rdfService.stepNameFromURI(gitPath, step.get(\"step\").toString());\n            if (wfSteps.containsKey(uri)) {\n                // Already got step details, add extra source ID\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                }\n            } else {\n                // Add new step\n                CWLStep wfStep = new CWLStep();\n\n                IRI workflowPath = iriFactory.construct(url).resolve(\"./\");\n                IRI runPath = iriFactory.construct(step.get(\"run\").asResource().getURI());\n                wfStep.setRun(workflowPath.relativize(runPath).toString());\n                wfStep.setRunType(rdfService.strToRuntype(step.get(\"runtype\").toString()));\n\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                }\n                if (step.contains(\"label\")) {\n                    wfStep.setLabel(step.get(\"label\").toString());\n                }\n                if (step.contains(\"doc\")) {\n                    wfStep.setDoc(step.get(\"doc\").toString());\n                }\n                wfSteps.put(rdfService.labelFromName(uri), wfStep);\n            }\n        }\n        // Try to determine license\n        ResultSet licenseResult = rdfService.getLicense(url);\n        String licenseLink = null;\n        if (licenseResult.hasNext()) {\n        \tlicenseLink = licenseResult.next().get(\"license\").toString();\n        } else {\n        \t// Check for \"LICENSE\"-like files in root of git repo\n        \tfor (String licenseCandidate : new String[]{\"LICENSE\", \"LICENSE.txt\", \"LICENSE.md\"}) {\n        \t\t// FIXME: This might wrongly match lower-case \"license.txt\" in case-insensitive file systems\n        \t\t// but the URL would not work\n        \t\tif (Files.isRegularFile(workTree.resolve(licenseCandidate))) {\n        \t\t\t// Link to it by raw URL\n        \t\t\tlicenseLink = basicModel.getRetrievedFrom().getRawUrl(null, licenseCandidate);\n        \t\t}\n\t\t\t}\n        }\n\n        // Docker link\n        ResultSet dockerResult = rdfService.getDockerLink(url);\n        String dockerLink = null;\n        if (dockerResult.hasNext()) {\n            QuerySolution docker = dockerResult.nextSolution();\n            if (docker.contains(\"pull\")) {\n                dockerLink = DockerService.getDockerHubURL(docker.get(\"pull\").toString());\n            } else {\n                dockerLink = \"true\";\n            }\n        }\n\n        // Create workflow model\n        Workflow workflowModel = new Workflow(label, doc,\n                wfInputs, wfOutputs, wfSteps, \n                dockerLink, licenseLink);\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        RDFDotWriter RDFDotWriter = new RDFDotWriter(graphWriter, rdfService, gitPath);\n        try {\n            RDFDotWriter.writeGraph(url);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n\n        return workflowModel;\n\n    }\n\n    /**\n     * Get an overview of a workflow\n     * @param file A file, potentially a workflow\n     * @return A constructed WorkflowOverview of the workflow\n     * @throws IOException Any API errors which may have occurred\n     */\n    public WorkflowOverview getWorkflowOverview(File file) throws IOException {\n\n        // Get the content of this file from Github\n        long fileSizeBytes = file.length();\n\n        // Check file size limit before parsing\n        if (fileSizeBytes <= singleFileSizeLimit) {\n\n            // Parse file as yaml\n            JsonNode cwlFile = yamlPathToJson(file.toPath());\n\n            // If the CWL file is packed there can be multiple workflows in a file\n            int packedCount = 0;\n            if (cwlFile.has(DOC_GRAPH)) {\n                // Packed CWL, find the first subelement which is a workflow and take it\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        cwlFile = jsonNode;\n                        packedCount++;\n                    }\n                }\n                if (packedCount > 1) {\n                    return new WorkflowOverview(\"/\" + file.getName(), \"Packed file\",\n                            \"contains \" + packedCount + \" workflows\");\n                }\n            }\n\n            // Can only make an overview if this is a workflow\n            if (extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n                // Use filename for label if there is no defined one\n                String label = extractLabel(cwlFile);\n                if (label == null) {\n                    label = file.getName();\n                }\n\n                // Return the constructed overview\n                return new WorkflowOverview(\"/\" + file.getName(), label, extractDoc(cwlFile));\n            } else {\n                // Return null if not a workflow file\n                return null;\n            }\n        } else {\n            throw new IOException(\"File '\" + file.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Set the format for an input or output, handling ontologies\n     * @param inputOutput The input or output CWL Element\n     * @param format The format URI\n     */\n    private void setFormat(CWLElement inputOutput, String format) {\n        inputOutput.setFormat(format);\n        try {\n            if (!rdfService.ontPropertyExists(format)) {\n                Model ontModel = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);\n                ontModel.read(format, null, \"RDF/XML\");\n                rdfService.addToOntologies(ontModel);\n            }\n            String formatLabel = rdfService.getOntLabel(format);\n            inputOutput.setType(inputOutput.getType() + \" [\" + formatLabel + \"]\");\n        } catch (RiotException ex) {\n            inputOutput.setType(inputOutput.getType() + \" [format]\");\n        }\n    }\n\n    /**\n     * Convert RDF URI for a type to a name\n     * @param uri The URI for the type\n     * @return The human readable name for that type\n     */\n    private String typeURIToString(String uri) {\n        switch (uri) {\n            case \"http://www.w3.org/2001/XMLSchema#string\":\n                return \"String\";\n            case \"https://w3id.org/cwl/cwl#File\":\n                return \"File\";\n            case \"http://www.w3.org/2001/XMLSchema#boolean\":\n                return \"Boolean\";\n            case \"http://www.w3.org/2001/XMLSchema#int\":\n                return \"Integer\";\n            case \"http://www.w3.org/2001/XMLSchema#double\":\n                return \"Double\";\n            case \"http://www.w3.org/2001/XMLSchema#float\":\n                return \"Float\";\n            case \"http://www.w3.org/2001/XMLSchema#long\":\n                return \"Long\";\n            case \"https://w3id.org/cwl/cwl#Directory\":\n                return \"Directory\";\n            default:\n                return uri;\n        }\n    }\n\n    /**\n     * Converts a yaml String to JsonNode\n     * @param path A Path to a file containing the yaml content\n     * @return A JsonNode with the content of the document\n     * @throws IOException \n     */\n    private JsonNode yamlPathToJson(Path path) throws IOException {\n        Yaml reader = new Yaml();\n        ObjectMapper mapper = new ObjectMapper();\n        Path p;\n        \n        try (InputStream in = Files.newInputStream(path)) {\n        \treturn mapper.valueToTree(reader.load(in));\n        }\n    }\n\n    \n    /**\n     * Converts a yaml String to JsonNode\n     * @param yamlStream An InputStream containing the yaml content\n     * @return A JsonNode with the content of the document\n     */\n    private JsonNode yamlStreamToJson(InputStream yamlStream) {\n        Yaml reader = new Yaml();\n        ObjectMapper mapper = new ObjectMapper();\n\t\treturn mapper.valueToTree(reader.load(yamlStream));\n    }\n\n    /**\n     * Extract the label from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the label of the node\n     */\n    private String extractLabel(JsonNode node) {\n        if (node != null && node.has(LABEL)) {\n            return node.get(LABEL).asText();\n        }\n        return null;\n    }\n\n    /**\n     * Extract the class parameter from a node representing a document\n     * @param rootNode The root node of a cwl document\n     * @return Which process this document represents\n     */\n    private CWLProcess extractProcess(JsonNode rootNode) {\n        if (rootNode != null) {\n            if (rootNode.has(CLASS)) {\n                switch(rootNode.get(CLASS).asText()) {\n                    case WORKFLOW:\n                        return CWLProcess.WORKFLOW;\n                    case COMMANDLINETOOL:\n                        return CWLProcess.COMMANDLINETOOL;\n                    case EXPRESSIONTOOL:\n                        return CWLProcess.EXPRESSIONTOOL;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the steps for a particular document\n     * @param cwlDoc The document to get steps for\n     * @return A map of step IDs and details related to them\n     */\n    private Map<String, CWLStep> getSteps(JsonNode cwlDoc) {\n        if (cwlDoc != null && cwlDoc.has(STEPS)) {\n            Map<String, CWLStep> returnMap = new HashMap<>();\n\n            JsonNode steps = cwlDoc.get(STEPS);\n            if (steps.getClass() == ArrayNode.class) {\n                // Explicit ID and other fields within each input list\n                for (JsonNode step : steps) {\n                    CWLStep stepObject = new CWLStep(extractLabel(step), extractDoc(step),\n                            extractRun(step), getInputs(step));\n                    returnMap.put(extractID(step), stepObject);\n                }\n            } else if (steps.getClass() == ObjectNode.class) {\n                // ID is the key of each object\n                Iterator<Map.Entry<String, JsonNode>> iterator = steps.fields();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, JsonNode> stepNode = iterator.next();\n                    JsonNode stepJson = stepNode.getValue();\n                    CWLStep stepObject = new CWLStep(extractLabel(stepJson), extractDoc(stepJson),\n                            extractRun(stepJson), getInputs(stepJson));\n                    returnMap.put(stepNode.getKey(), stepObject);\n                }\n            }\n\n            return returnMap;\n        }\n        return null;\n    }\n\n    /**\n     * Get a the inputs for a particular document\n     * @param cwlDoc The document to get inputs for\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            if (cwlDoc.has(INPUTS)) {\n                // For all version workflow inputs/outputs and draft steps\n                return getInputsOutputs(cwlDoc.get(INPUTS));\n            } else if (cwlDoc.has(IN)) {\n                // For V1.0 steps\n                return getStepInputsOutputs(cwlDoc.get(IN));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the outputs for a particular document\n     * @param cwlDoc The document to get outputs for\n     * @return A map of output IDs and details related to them\n     */\n    private Map<String, CWLElement> getOutputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            // For all version workflow inputs/outputs and draft steps\n            if (cwlDoc.has(OUTPUTS)) {\n                return getInputsOutputs(cwlDoc.get(OUTPUTS));\n            }\n            // Outputs are not gathered for v1 steps\n        }\n        return null;\n    }\n\n    /**\n     * Get inputs or outputs from an in or out node\n     * @param inOut The in or out node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getStepInputsOutputs(JsonNode inOut) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inOut.getClass() == ArrayNode.class) {\n            // array<WorkflowStepInput>\n            for (JsonNode inOutNode : inOut) {\n                if (inOutNode.getClass() == ObjectNode.class) {\n                    CWLElement inputOutput = new CWLElement();\n                    List<String> sources = extractSource(inOutNode);\n                    if (sources.size() > 0) {\n                        for (String source : sources) {\n                            inputOutput.addSourceID(stepIDFromSource(source));\n                        }\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(inOutNode));\n                    }\n                    returnMap.put(extractID(inOutNode), inputOutput);\n                }\n            }\n        } else if (inOut.getClass() == ObjectNode.class) {\n            // map<WorkflowStepInput.id, WorkflowStepInput.source>\n            Iterator<Map.Entry<String, JsonNode>> iterator = inOut.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inOutNode = iterator.next();\n                CWLElement inputOutput = new CWLElement();\n                if (inOutNode.getValue().getClass() == ObjectNode.class) {\n                    JsonNode properties = inOutNode.getValue();\n                    if (properties.has(SOURCE)) {\n                        inputOutput.addSourceID(stepIDFromSource(properties.get(SOURCE).asText()));\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(properties));\n                    }\n                } else if (inOutNode.getValue().getClass() == ArrayNode.class) {\n                    for (JsonNode key : inOutNode.getValue()) {\n                        inputOutput.addSourceID(stepIDFromSource(key.asText()));\n                    }\n                } else {\n                    inputOutput.addSourceID(stepIDFromSource(inOutNode.getValue().asText()));\n                }\n                returnMap.put(inOutNode.getKey(), inputOutput);\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Get inputs or outputs from an inputs or outputs node\n     * @param inputsOutputs The inputs or outputs node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputsOutputs(JsonNode inputsOutputs) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inputsOutputs.getClass() == ArrayNode.class) {\n            // Explicit ID and other fields within each list\n            for (JsonNode inputOutput : inputsOutputs) {\n                String id = inputOutput.get(ID).asText();\n                if (id.charAt(0) == '#') {\n                    id = id.substring(1);\n                }\n                returnMap.put(id, getDetails(inputOutput));\n            }\n        } else if (inputsOutputs.getClass() == ObjectNode.class) {\n            // ID is the key of each object\n            Iterator<Map.Entry<String, JsonNode>> iterator = inputsOutputs.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inputOutputNode = iterator.next();\n                returnMap.put(inputOutputNode.getKey(), getDetails(inputOutputNode.getValue()));\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Gets the details of an input or output\n     * @param inputOutput The node of the particular input or output\n     * @return An CWLElement object with the label, doc and type extracted\n     */\n    private CWLElement getDetails(JsonNode inputOutput) {\n        if (inputOutput != null) {\n            CWLElement details = new CWLElement();\n\n            // Shorthand notation \"id: type\" - no label/doc/other params\n            if (inputOutput.getClass() == TextNode.class) {\n                details.setType(inputOutput.asText());\n            } else {\n                details.setLabel(extractLabel(inputOutput));\n                details.setDoc(extractDoc(inputOutput));\n                extractSource(inputOutput).forEach(details::addSourceID);\n                details.setDefaultVal(extractDefault(inputOutput));\n\n                // Type is only for inputs\n                if (inputOutput.has(TYPE)) {\n                    details.setType(extractTypes(inputOutput.get(TYPE)));\n                }\n            }\n\n            return details;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the id from a node\n     * @param node The node to have the id extracted from\n     * @return The string for the id of the node\n     */\n    private String extractID(JsonNode node) {\n        if (node != null && node.has(ID)) {\n            String id = node.get(ID).asText();\n            if (id.startsWith(\"#\")) {\n                return id.substring(1);\n            }\n            return id;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the default value from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the default value of the node\n     */\n    private String extractDefault(JsonNode node) {\n        if (node != null && node.has(DEFAULT)) {\n            if (node.get(DEFAULT).has(LOCATION)) {\n                return node.get(DEFAULT).get(LOCATION).asText();\n            } else {\n                return \"\\\\\\\"\" + node.get(DEFAULT).asText() + \"\\\\\\\"\";\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the source or outputSource from a node\n     * @param node The node to have the sources extracted from\n     * @return A list of strings for the sources\n     */\n    private List<String> extractSource(JsonNode node) {\n        if (node != null) {\n            List<String> sources = new ArrayList<String>();\n            JsonNode sourceNode = null;\n\n            // outputSource and source treated the same\n            if (node.has(OUTPUT_SOURCE)) {\n                sourceNode = node.get(OUTPUT_SOURCE);\n            } else if (node.has(SOURCE)) {\n                sourceNode = node.get(SOURCE);\n            }\n\n            if (sourceNode != null) {\n                // Single source\n                if (sourceNode.getClass() == TextNode.class) {\n                    sources.add(stepIDFromSource(sourceNode.asText()));\n                }\n                // Can be an array of multiple sources\n                if (sourceNode.getClass() == ArrayNode.class) {\n                    for (JsonNode source : sourceNode) {\n                        sources.add(stepIDFromSource(source.asText()));\n                    }\n                }\n            }\n\n            return sources;\n        }\n        return null;\n    }\n\n    /**\n     * Gets just the step ID from source of format 'stepID</ or .>outputID'\n     * @param source The source\n     * @return The step ID\n     */\n    private String stepIDFromSource(String source) {\n        if (source != null && source.length() > 0) {\n            // Strip leading # if it exists\n            if (source.charAt(0) == '#') {\n                source = source.substring(1);\n            }\n\n            // Draft 3/V1 notation is 'stepID/outputID'\n            int slashSplit = source.indexOf(\"/\");\n            if (slashSplit != -1) {\n                source = source.substring(0, slashSplit);\n            } else {\n                // Draft 2 notation was 'stepID.outputID'\n                int dotSplit = source.indexOf(\".\");\n                if (dotSplit != -1) {\n                    source = source.substring(0, dotSplit);\n                }\n            }\n        }\n        return source;\n    }\n\n    /**\n     * Extract the doc or description from a node\n     * @param node The node to have the doc/description extracted from\n     * @return The string for the doc/description of the node\n     */\n    private String extractDoc(JsonNode node) {\n        if (node != null) {\n            if (node.has(DOC)) {\n                return node.get(DOC).asText();\n            } else if (node.has(DESCRIPTION)) {\n                // This is to support older standards of cwl which use description instead of doc\n                return node.get(DESCRIPTION).asText();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the types from a node representing inputs or outputs\n     * @param typeNode The root node representing an input or output\n     * @return A string with the types listed\n     */\n    private String extractTypes(JsonNode typeNode) {\n        if (typeNode != null) {\n            if (typeNode.getClass() == TextNode.class) {\n                // Single type\n                return typeNode.asText();\n            } else if (typeNode.getClass() == ArrayNode.class) {\n                // Multiple types, build a string to represent them\n                StringBuilder typeDetails = new StringBuilder();\n                boolean optional = false;\n                for (JsonNode type : typeNode) {\n                    if (type.getClass() == TextNode.class) {\n                        // This is a simple type\n                        if (type.asText().equals(\"null\")) {\n                            // null as a type means this field is optional\n                            optional = true;\n                        } else {\n                            // Add a simple type to the string\n                            typeDetails.append(type.asText());\n                            typeDetails.append(\", \");\n                        }\n                    } else if (typeNode.getClass() == ArrayNode.class) {\n                        // This is a verbose type with sub-fields broken down into type: and other params\n                        if (type.get(TYPE).asText().equals(ARRAY)) {\n                            typeDetails.append(type.get(ARRAY_ITEMS).asText());\n                            typeDetails.append(\"[], \");\n                        } else {\n                            typeDetails.append(type.get(TYPE).asText());\n                        }\n                    }\n                }\n\n                // Trim off excessive separators\n                if (typeDetails.length() > 1) {\n                    typeDetails.setLength(typeDetails.length() - 2);\n                }\n\n                // Add optional if null was included in the multiple types\n                if (optional) typeDetails.append(\"?\");\n\n                // Set the type to the constructed string\n                return typeDetails.toString();\n\n            } else if (typeNode.getClass() == ObjectNode.class) {\n                // Type: array and items:\n                if (typeNode.has(ARRAY_ITEMS)) {\n                    return typeNode.get(ARRAY_ITEMS).asText() + \"[]\";\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the run parameter from a node representing a step\n     * @param stepNode The root node of a step\n     * @return A string with the run parameter if it exists\n     */\n    private String extractRun(JsonNode stepNode) {\n        if (stepNode != null) {\n            if (stepNode.has(RUN)) {\n                return stepNode.get(RUN).asText();\n            }\n        }\n        return null;\n    }\n\n}\n"], "fixing_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.commonwl.view.cwl;\n\nimport static org.apache.commons.io.FileUtils.readFileToString;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.jena.iri.IRI;\nimport org.apache.jena.iri.IRIFactory;\nimport org.apache.jena.ontology.OntModelSpec;\nimport org.apache.jena.query.QuerySolution;\nimport org.apache.jena.query.ResultSet;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.riot.RiotException;\nimport org.commonwl.view.docker.DockerService;\nimport org.commonwl.view.git.GitDetails;\nimport org.commonwl.view.graphviz.ModelDotWriter;\nimport org.commonwl.view.graphviz.RDFDotWriter;\nimport org.commonwl.view.workflow.Workflow;\nimport org.commonwl.view.workflow.WorkflowNotFoundException;\nimport org.commonwl.view.workflow.WorkflowOverview;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.yaml.snakeyaml.Yaml;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.TextNode;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\n/**\n * Provides CWL parsing for workflows to gather an overview\n * for display and visualisation\n */\n@Service\npublic class CWLService {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n    private final IRIFactory iriFactory = IRIFactory.iriImplementation();\n\n    // Autowired properties/services\n    private final RDFService rdfService;\n    private final CWLTool cwlTool;\n    private final int singleFileSizeLimit;\n\n    // CWL specific strings\n    private final String DOC_GRAPH = \"$graph\";\n    private final String CLASS = \"class\";\n    private final String WORKFLOW = \"Workflow\";\n    private final String COMMANDLINETOOL = \"CommandLineTool\";\n    private final String EXPRESSIONTOOL = \"ExpressionTool\";\n    private final String STEPS = \"steps\";\n    private final String INPUTS = \"inputs\";\n    private final String IN = \"in\";\n    private final String OUTPUTS = \"outputs\";\n    private final String OUT = \"out\";\n    private final String ID = \"id\";\n    private final String TYPE = \"type\";\n    private final String LABEL = \"label\";\n    private final String DEFAULT = \"default\";\n    private final String OUTPUT_SOURCE = \"outputSource\";\n    private final String SOURCE = \"source\";\n    private final String DOC = \"doc\";\n    private final String DESCRIPTION = \"description\";\n    private final String ARRAY = \"array\";\n    private final String ARRAY_ITEMS = \"items\";\n    private final String LOCATION = \"location\";\n    private final String RUN = \"run\";\n\n    /**\n     * Constructor for the Common Workflow Language service\n     * @param rdfService A service for handling RDF queries\n     * @param cwlTool Handles cwltool integration\n     * @param singleFileSizeLimit The file size limit for single files\n     */\n    @Autowired\n    public CWLService(RDFService rdfService,\n                      CWLTool cwlTool,\n                      @Value(\"${singleFileSizeLimit}\") int singleFileSizeLimit) {\n        this.rdfService = rdfService;\n        this.cwlTool = cwlTool;\n        this.singleFileSizeLimit = singleFileSizeLimit;\n    }\n\n    /**\n     * Gets whether a file is packed using schema salad\n     * @param workflowFile The file to be parsed\n     * @return Whether the file is packed\n     */\n    public boolean isPacked(File workflowFile) throws IOException {\n        if (workflowFile.length() > singleFileSizeLimit) {\n            return false;\n        }\n        String fileContent = readFileToString(workflowFile);\n        return fileContent.contains(\"$graph\");\n    }\n\n    /**\n     * Gets a list of workflows from a packed CWL file\n     * @param packedFile The packed CWL file\n     * @return The list of workflow overviews\n     */\n    public List<WorkflowOverview> getWorkflowOverviewsFromPacked(File packedFile) throws IOException {\n        if (packedFile.length() <= singleFileSizeLimit) {\n            List<WorkflowOverview> overviews = new ArrayList<>();\n\n            JsonNode packedJson = yamlPathToJson(packedFile.toPath());\n\n            if (packedJson.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : packedJson.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        WorkflowOverview overview = new WorkflowOverview(jsonNode.get(ID).asText(),\n                                extractLabel(jsonNode), extractDoc(jsonNode));\n                        overviews.add(overview);\n                    }\n                }\n            } else {\n                throw new IOException(\"The file given was not recognised as a packed CWL file\");\n            }\n\n            return overviews;\n\n        } else {\n            throw new IOException(\"File '\" + packedFile.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(packedFile.length()) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n    }\n\n    /**\n     * Gets the Workflow object from internal parsing. \n     * Note, the length of the stream is not checked.\n     *  \n     * @param workflowStream The workflow stream to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed. <code>null</code> means the workflow is not expected to be packed, while \"\" means the first workflow found is used, packed or non-packed.\n     * @param defaultLabel Label to give workflow if not set\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(InputStream workflowStream, String packedWorkflowId, String defaultLabel) throws IOException {\n        // Parse file as yaml\n        JsonNode cwlFile = yamlStreamToJson(workflowStream);\n\n        // Check packed workflow occurs\n        boolean found = false;\n        if (packedWorkflowId != null) {\n            if (cwlFile.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        String currentId = jsonNode.get(ID).asText();\n                        if (currentId.startsWith(\"#\")) {\n                            currentId = currentId.substring(1);\n                        }\n                        if (packedWorkflowId.isEmpty() || currentId.equals(packedWorkflowId)) {\n                            cwlFile = jsonNode;\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!found && ! packedWorkflowId.isEmpty()) throw new WorkflowNotFoundException();\n        }\n        if (! found && extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n        \t// Check the current json node is a workflow\n        \tfound = true;\n        }\n        if (! found) {\n            throw new WorkflowNotFoundException();\n        }\n\n        // Use filename for label if there is no defined one\n        String label = extractLabel(cwlFile);\n        if (label == null) {\n            label = defaultLabel;\n        }\n\n        // Construct the rest of the workflow model\n        Workflow workflowModel = new Workflow(label, extractDoc(cwlFile), getInputs(cwlFile),\n                getOutputs(cwlFile), getSteps(cwlFile));\n\n        workflowModel.setCwltoolVersion(cwlTool.getVersion());\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        ModelDotWriter dotWriter = new ModelDotWriter(graphWriter);\n        try {\n            dotWriter.writeGraph(workflowModel);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n        return workflowModel;\n\n\n    }\n\n    \n    /**\n     * Gets the Workflow object from internal parsing.\n     * The size of the workflow file must be below the configured \n     * singleFileSizeLimit in the constructor/spring config.\n     * \n     * @param workflowFile The workflow file to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(Path workflowFile, String packedWorkflowId) throws IOException {\n\n        // Check file size limit before parsing\n        long fileSizeBytes = Files.size(workflowFile);\n        if (fileSizeBytes <= singleFileSizeLimit) {\n        \ttry (InputStream in = Files.newInputStream(workflowFile)) {\n        \t\treturn parseWorkflowNative(in, packedWorkflowId, \n        \t\t\t\tworkflowFile.getName(workflowFile.getNameCount()-1).toString());\n        \t}\n        } else {\n            throw new IOException(\"File '\" + workflowFile.getFileName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Create a workflow model using cwltool rdf output\n     * @param basicModel The basic workflow object created thus far\n     * @param workflowFile The workflow file to run cwltool on\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowWithCwltool(Workflow basicModel,\n                                             Path workflowFile,\n                                             Path workTree) throws CWLValidationException {\n        GitDetails gitDetails = basicModel.getRetrievedFrom();\n        String latestCommit = basicModel.getLastCommit();\n        String packedWorkflowID = gitDetails.getPackedId();\n\n        // Get paths to workflow\n        String url = basicModel.getIdentifier();\n        String workflowFileURI = workflowFile.toAbsolutePath().toUri().toString();\n        URI workTreeUri = workTree.toAbsolutePath().toUri();\n\t\tString localPath = workflowFileURI;\n        String gitPath = gitDetails.getPath();\n        if (packedWorkflowID != null) {\n            if (packedWorkflowID.charAt(0) != '#') {\n                localPath += \"#\";\n                gitPath += \"#\";\n            }\n            localPath += packedWorkflowID;\n            gitPath += packedWorkflowID;\n        }\n\n        // Get RDF representation from cwltool\n        if (!rdfService.graphExists(url)) {\n            String rdf = cwlTool.getRDF(localPath);\n            // Replace /tmp/123123 with permalink base \n            // NOTE: We do not just replace workflowFileURI, all referenced files will also get rewritten\n\t\t\trdf = rdf.replace(workTreeUri.toString(),\n                    \"https://w3id.org/cwl/view/git/\" + latestCommit + \"/\");\n            // Workaround for common-workflow-language/cwltool#427\n            rdf = rdf.replace(\"<rdfs:>\", \"<http://www.w3.org/2000/01/rdf-schema#>\");\n\n            // Create a workflow model from RDF representation\n            Model model = ModelFactory.createDefaultModel();\n            model.read(new ByteArrayInputStream(rdf.getBytes()), null, \"TURTLE\");\n\n            // Store the model\n            rdfService.storeModel(url, model);\n        }\n\n        // Base workflow details\n        String label = FilenameUtils.getName(url);\n        String doc = null;\n        ResultSet labelAndDoc = rdfService.getLabelAndDoc(url);\n        if (labelAndDoc.hasNext()) {\n            QuerySolution labelAndDocSoln = labelAndDoc.nextSolution();\n            if (labelAndDocSoln.contains(\"label\")) {\n                label = labelAndDocSoln.get(\"label\").toString();\n            }\n            if (labelAndDocSoln.contains(\"doc\")) {\n                doc = labelAndDocSoln.get(\"doc\").toString();\n            }\n        }\n\n        // Inputs\n        Map<String, CWLElement> wfInputs = new HashMap<>();\n        ResultSet inputs = rdfService.getInputs(url);\n        while (inputs.hasNext()) {\n            QuerySolution input = inputs.nextSolution();\n            String inputName = rdfService.stepNameFromURI(gitPath, input.get(\"name\").toString());\n\n            CWLElement wfInput = new CWLElement();\n            if (input.contains(\"type\")) {\n                String type;\n                if (input.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(input.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(input.get(\"type\").toString());\n                }\n                if (input.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfInput.setType(type);\n            }\n            if (input.contains(\"format\")) {\n                String format = input.get(\"format\").toString();\n                setFormat(wfInput, format);\n            }\n            if (input.contains(\"label\")) {\n                wfInput.setLabel(input.get(\"label\").toString());\n            }\n            if (input.contains(\"doc\")) {\n                wfInput.setDoc(input.get(\"doc\").toString());\n            }\n            wfInputs.put(rdfService.labelFromName(inputName), wfInput);\n        }\n\n        // Outputs\n        Map<String, CWLElement> wfOutputs = new HashMap<>();\n        ResultSet outputs = rdfService.getOutputs(url);\n        while (outputs.hasNext()) {\n            QuerySolution output = outputs.nextSolution();\n            CWLElement wfOutput = new CWLElement();\n\n            String outputName = rdfService.stepNameFromURI(gitPath, output.get(\"name\").toString());\n            if (output.contains(\"type\")) {\n                String type;\n                if (output.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(output.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(output.get(\"type\").toString());\n                }\n                if (output.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfOutput.setType(type);\n            }\n\n            if (output.contains(\"src\")) {\n                wfOutput.addSourceID(rdfService.stepNameFromURI(gitPath,\n                        output.get(\"src\").toString()));\n            }\n            if (output.contains(\"format\")) {\n                String format = output.get(\"format\").toString();\n                setFormat(wfOutput, format);\n            }\n            if (output.contains(\"label\")) {\n                wfOutput.setLabel(output.get(\"label\").toString());\n            }\n            if (output.contains(\"doc\")) {\n                wfOutput.setDoc(output.get(\"doc\").toString());\n            }\n            wfOutputs.put(rdfService.labelFromName(outputName), wfOutput);\n        }\n\n\n        // Steps\n        Map<String, CWLStep> wfSteps = new HashMap<>();\n        ResultSet steps = rdfService.getSteps(url);\n        while (steps.hasNext()) {\n            QuerySolution step = steps.nextSolution();\n            String uri = rdfService.stepNameFromURI(gitPath, step.get(\"step\").toString());\n            if (wfSteps.containsKey(uri)) {\n                // Already got step details, add extra source ID\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                }\n            } else {\n                // Add new step\n                CWLStep wfStep = new CWLStep();\n\n                IRI workflowPath = iriFactory.construct(url).resolve(\"./\");\n                IRI runPath = iriFactory.construct(step.get(\"run\").asResource().getURI());\n                wfStep.setRun(workflowPath.relativize(runPath).toString());\n                wfStep.setRunType(rdfService.strToRuntype(step.get(\"runtype\").toString()));\n\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                }\n                if (step.contains(\"label\")) {\n                    wfStep.setLabel(step.get(\"label\").toString());\n                }\n                if (step.contains(\"doc\")) {\n                    wfStep.setDoc(step.get(\"doc\").toString());\n                }\n                wfSteps.put(rdfService.labelFromName(uri), wfStep);\n            }\n        }\n        // Try to determine license\n        ResultSet licenseResult = rdfService.getLicense(url);\n        String licenseLink = null;\n        if (licenseResult.hasNext()) {\n        \tlicenseLink = licenseResult.next().get(\"license\").toString();\n        } else {\n        \t// Check for \"LICENSE\"-like files in root of git repo\n        \tfor (String licenseCandidate : new String[]{\"LICENSE\", \"LICENSE.txt\", \"LICENSE.md\"}) {\n        \t\t// FIXME: This might wrongly match lower-case \"license.txt\" in case-insensitive file systems\n        \t\t// but the URL would not work\n        \t\tif (Files.isRegularFile(workTree.resolve(licenseCandidate))) {\n        \t\t\t// Link to it by raw URL\n        \t\t\tlicenseLink = basicModel.getRetrievedFrom().getRawUrl(null, licenseCandidate);\n        \t\t}\n\t\t\t}\n        }\n\n        // Docker link\n        ResultSet dockerResult = rdfService.getDockerLink(url);\n        String dockerLink = null;\n        if (dockerResult.hasNext()) {\n            QuerySolution docker = dockerResult.nextSolution();\n            if (docker.contains(\"pull\")) {\n                dockerLink = DockerService.getDockerHubURL(docker.get(\"pull\").toString());\n            } else {\n                dockerLink = \"true\";\n            }\n        }\n\n        // Create workflow model\n        Workflow workflowModel = new Workflow(label, doc,\n                wfInputs, wfOutputs, wfSteps, \n                dockerLink, licenseLink);\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        RDFDotWriter RDFDotWriter = new RDFDotWriter(graphWriter, rdfService, gitPath);\n        try {\n            RDFDotWriter.writeGraph(url);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n\n        return workflowModel;\n\n    }\n\n    /**\n     * Get an overview of a workflow\n     * @param file A file, potentially a workflow\n     * @return A constructed WorkflowOverview of the workflow\n     * @throws IOException Any API errors which may have occurred\n     */\n    public WorkflowOverview getWorkflowOverview(File file) throws IOException {\n\n        // Get the content of this file from Github\n        long fileSizeBytes = file.length();\n\n        // Check file size limit before parsing\n        if (fileSizeBytes <= singleFileSizeLimit) {\n\n            // Parse file as yaml\n            JsonNode cwlFile = yamlPathToJson(file.toPath());\n\n            // If the CWL file is packed there can be multiple workflows in a file\n            int packedCount = 0;\n            if (cwlFile.has(DOC_GRAPH)) {\n                // Packed CWL, find the first subelement which is a workflow and take it\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        cwlFile = jsonNode;\n                        packedCount++;\n                    }\n                }\n                if (packedCount > 1) {\n                    return new WorkflowOverview(\"/\" + file.getName(), \"Packed file\",\n                            \"contains \" + packedCount + \" workflows\");\n                }\n            }\n\n            // Can only make an overview if this is a workflow\n            if (extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n                // Use filename for label if there is no defined one\n                String label = extractLabel(cwlFile);\n                if (label == null) {\n                    label = file.getName();\n                }\n\n                // Return the constructed overview\n                return new WorkflowOverview(\"/\" + file.getName(), label, extractDoc(cwlFile));\n            } else {\n                // Return null if not a workflow file\n                return null;\n            }\n        } else {\n            throw new IOException(\"File '\" + file.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Set the format for an input or output, handling ontologies\n     * @param inputOutput The input or output CWL Element\n     * @param format The format URI\n     */\n    private void setFormat(CWLElement inputOutput, String format) {\n        inputOutput.setFormat(format);\n        try {\n            if (!rdfService.ontPropertyExists(format)) {\n                Model ontModel = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);\n                ontModel.read(format, null, \"RDF/XML\");\n                rdfService.addToOntologies(ontModel);\n            }\n            String formatLabel = rdfService.getOntLabel(format);\n            inputOutput.setType(inputOutput.getType() + \" [\" + formatLabel + \"]\");\n        } catch (RiotException ex) {\n            inputOutput.setType(inputOutput.getType() + \" [format]\");\n        }\n    }\n\n    /**\n     * Convert RDF URI for a type to a name\n     * @param uri The URI for the type\n     * @return The human readable name for that type\n     */\n    private String typeURIToString(String uri) {\n        switch (uri) {\n            case \"http://www.w3.org/2001/XMLSchema#string\":\n                return \"String\";\n            case \"https://w3id.org/cwl/cwl#File\":\n                return \"File\";\n            case \"http://www.w3.org/2001/XMLSchema#boolean\":\n                return \"Boolean\";\n            case \"http://www.w3.org/2001/XMLSchema#int\":\n                return \"Integer\";\n            case \"http://www.w3.org/2001/XMLSchema#double\":\n                return \"Double\";\n            case \"http://www.w3.org/2001/XMLSchema#float\":\n                return \"Float\";\n            case \"http://www.w3.org/2001/XMLSchema#long\":\n                return \"Long\";\n            case \"https://w3id.org/cwl/cwl#Directory\":\n                return \"Directory\";\n            default:\n                return uri;\n        }\n    }\n\n    /**\n     * Converts a yaml String to JsonNode\n     * @param path A Path to a file containing the yaml content\n     * @return A JsonNode with the content of the document\n     * @throws IOException \n     */\n    private JsonNode yamlPathToJson(Path path) throws IOException {\n        Yaml reader = new Yaml(new SafeConstructor());\n        ObjectMapper mapper = new ObjectMapper();\n        try (InputStream in = Files.newInputStream(path)) {\n        \treturn mapper.valueToTree(reader.load(in));\n        }\n    }\n\n    \n    /**\n     * Converts a yaml String to JsonNode\n     * @param yamlStream An InputStream containing the yaml content\n     * @return A JsonNode with the content of the document\n     */\n    private JsonNode yamlStreamToJson(InputStream yamlStream) {\n        Yaml reader = new Yaml(new SafeConstructor());\n        ObjectMapper mapper = new ObjectMapper();\n\t\treturn mapper.valueToTree(reader.load(yamlStream));\n    }\n\n    /**\n     * Extract the label from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the label of the node\n     */\n    private String extractLabel(JsonNode node) {\n        if (node != null && node.has(LABEL)) {\n            return node.get(LABEL).asText();\n        }\n        return null;\n    }\n\n    /**\n     * Extract the class parameter from a node representing a document\n     * @param rootNode The root node of a cwl document\n     * @return Which process this document represents\n     */\n    private CWLProcess extractProcess(JsonNode rootNode) {\n        if (rootNode != null) {\n            if (rootNode.has(CLASS)) {\n                switch(rootNode.get(CLASS).asText()) {\n                    case WORKFLOW:\n                        return CWLProcess.WORKFLOW;\n                    case COMMANDLINETOOL:\n                        return CWLProcess.COMMANDLINETOOL;\n                    case EXPRESSIONTOOL:\n                        return CWLProcess.EXPRESSIONTOOL;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the steps for a particular document\n     * @param cwlDoc The document to get steps for\n     * @return A map of step IDs and details related to them\n     */\n    private Map<String, CWLStep> getSteps(JsonNode cwlDoc) {\n        if (cwlDoc != null && cwlDoc.has(STEPS)) {\n            Map<String, CWLStep> returnMap = new HashMap<>();\n\n            JsonNode steps = cwlDoc.get(STEPS);\n            if (steps.getClass() == ArrayNode.class) {\n                // Explicit ID and other fields within each input list\n                for (JsonNode step : steps) {\n                    CWLStep stepObject = new CWLStep(extractLabel(step), extractDoc(step),\n                            extractRun(step), getInputs(step));\n                    returnMap.put(extractID(step), stepObject);\n                }\n            } else if (steps.getClass() == ObjectNode.class) {\n                // ID is the key of each object\n                Iterator<Map.Entry<String, JsonNode>> iterator = steps.fields();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, JsonNode> stepNode = iterator.next();\n                    JsonNode stepJson = stepNode.getValue();\n                    CWLStep stepObject = new CWLStep(extractLabel(stepJson), extractDoc(stepJson),\n                            extractRun(stepJson), getInputs(stepJson));\n                    returnMap.put(stepNode.getKey(), stepObject);\n                }\n            }\n\n            return returnMap;\n        }\n        return null;\n    }\n\n    /**\n     * Get a the inputs for a particular document\n     * @param cwlDoc The document to get inputs for\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            if (cwlDoc.has(INPUTS)) {\n                // For all version workflow inputs/outputs and draft steps\n                return getInputsOutputs(cwlDoc.get(INPUTS));\n            } else if (cwlDoc.has(IN)) {\n                // For V1.0 steps\n                return getStepInputsOutputs(cwlDoc.get(IN));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the outputs for a particular document\n     * @param cwlDoc The document to get outputs for\n     * @return A map of output IDs and details related to them\n     */\n    private Map<String, CWLElement> getOutputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            // For all version workflow inputs/outputs and draft steps\n            if (cwlDoc.has(OUTPUTS)) {\n                return getInputsOutputs(cwlDoc.get(OUTPUTS));\n            }\n            // Outputs are not gathered for v1 steps\n        }\n        return null;\n    }\n\n    /**\n     * Get inputs or outputs from an in or out node\n     * @param inOut The in or out node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getStepInputsOutputs(JsonNode inOut) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inOut.getClass() == ArrayNode.class) {\n            // array<WorkflowStepInput>\n            for (JsonNode inOutNode : inOut) {\n                if (inOutNode.getClass() == ObjectNode.class) {\n                    CWLElement inputOutput = new CWLElement();\n                    List<String> sources = extractSource(inOutNode);\n                    if (sources.size() > 0) {\n                        for (String source : sources) {\n                            inputOutput.addSourceID(stepIDFromSource(source));\n                        }\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(inOutNode));\n                    }\n                    returnMap.put(extractID(inOutNode), inputOutput);\n                }\n            }\n        } else if (inOut.getClass() == ObjectNode.class) {\n            // map<WorkflowStepInput.id, WorkflowStepInput.source>\n            Iterator<Map.Entry<String, JsonNode>> iterator = inOut.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inOutNode = iterator.next();\n                CWLElement inputOutput = new CWLElement();\n                if (inOutNode.getValue().getClass() == ObjectNode.class) {\n                    JsonNode properties = inOutNode.getValue();\n                    if (properties.has(SOURCE)) {\n                        inputOutput.addSourceID(stepIDFromSource(properties.get(SOURCE).asText()));\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(properties));\n                    }\n                } else if (inOutNode.getValue().getClass() == ArrayNode.class) {\n                    for (JsonNode key : inOutNode.getValue()) {\n                        inputOutput.addSourceID(stepIDFromSource(key.asText()));\n                    }\n                } else {\n                    inputOutput.addSourceID(stepIDFromSource(inOutNode.getValue().asText()));\n                }\n                returnMap.put(inOutNode.getKey(), inputOutput);\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Get inputs or outputs from an inputs or outputs node\n     * @param inputsOutputs The inputs or outputs node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputsOutputs(JsonNode inputsOutputs) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inputsOutputs.getClass() == ArrayNode.class) {\n            // Explicit ID and other fields within each list\n            for (JsonNode inputOutput : inputsOutputs) {\n                String id = inputOutput.get(ID).asText();\n                if (id.charAt(0) == '#') {\n                    id = id.substring(1);\n                }\n                returnMap.put(id, getDetails(inputOutput));\n            }\n        } else if (inputsOutputs.getClass() == ObjectNode.class) {\n            // ID is the key of each object\n            Iterator<Map.Entry<String, JsonNode>> iterator = inputsOutputs.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inputOutputNode = iterator.next();\n                returnMap.put(inputOutputNode.getKey(), getDetails(inputOutputNode.getValue()));\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Gets the details of an input or output\n     * @param inputOutput The node of the particular input or output\n     * @return An CWLElement object with the label, doc and type extracted\n     */\n    private CWLElement getDetails(JsonNode inputOutput) {\n        if (inputOutput != null) {\n            CWLElement details = new CWLElement();\n\n            // Shorthand notation \"id: type\" - no label/doc/other params\n            if (inputOutput.getClass() == TextNode.class) {\n                details.setType(inputOutput.asText());\n            } else {\n                details.setLabel(extractLabel(inputOutput));\n                details.setDoc(extractDoc(inputOutput));\n                extractSource(inputOutput).forEach(details::addSourceID);\n                details.setDefaultVal(extractDefault(inputOutput));\n\n                // Type is only for inputs\n                if (inputOutput.has(TYPE)) {\n                    details.setType(extractTypes(inputOutput.get(TYPE)));\n                }\n            }\n\n            return details;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the id from a node\n     * @param node The node to have the id extracted from\n     * @return The string for the id of the node\n     */\n    private String extractID(JsonNode node) {\n        if (node != null && node.has(ID)) {\n            String id = node.get(ID).asText();\n            if (id.startsWith(\"#\")) {\n                return id.substring(1);\n            }\n            return id;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the default value from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the default value of the node\n     */\n    private String extractDefault(JsonNode node) {\n        if (node != null && node.has(DEFAULT)) {\n            if (node.get(DEFAULT).has(LOCATION)) {\n                return node.get(DEFAULT).get(LOCATION).asText();\n            } else {\n                return \"\\\\\\\"\" + node.get(DEFAULT).asText() + \"\\\\\\\"\";\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the source or outputSource from a node\n     * @param node The node to have the sources extracted from\n     * @return A list of strings for the sources\n     */\n    private List<String> extractSource(JsonNode node) {\n        if (node != null) {\n            List<String> sources = new ArrayList<String>();\n            JsonNode sourceNode = null;\n\n            // outputSource and source treated the same\n            if (node.has(OUTPUT_SOURCE)) {\n                sourceNode = node.get(OUTPUT_SOURCE);\n            } else if (node.has(SOURCE)) {\n                sourceNode = node.get(SOURCE);\n            }\n\n            if (sourceNode != null) {\n                // Single source\n                if (sourceNode.getClass() == TextNode.class) {\n                    sources.add(stepIDFromSource(sourceNode.asText()));\n                }\n                // Can be an array of multiple sources\n                if (sourceNode.getClass() == ArrayNode.class) {\n                    for (JsonNode source : sourceNode) {\n                        sources.add(stepIDFromSource(source.asText()));\n                    }\n                }\n            }\n\n            return sources;\n        }\n        return null;\n    }\n\n    /**\n     * Gets just the step ID from source of format 'stepID</ or .>outputID'\n     * @param source The source\n     * @return The step ID\n     */\n    private String stepIDFromSource(String source) {\n        if (source != null && source.length() > 0) {\n            // Strip leading # if it exists\n            if (source.charAt(0) == '#') {\n                source = source.substring(1);\n            }\n\n            // Draft 3/V1 notation is 'stepID/outputID'\n            int slashSplit = source.indexOf(\"/\");\n            if (slashSplit != -1) {\n                source = source.substring(0, slashSplit);\n            } else {\n                // Draft 2 notation was 'stepID.outputID'\n                int dotSplit = source.indexOf(\".\");\n                if (dotSplit != -1) {\n                    source = source.substring(0, dotSplit);\n                }\n            }\n        }\n        return source;\n    }\n\n    /**\n     * Extract the doc or description from a node\n     * @param node The node to have the doc/description extracted from\n     * @return The string for the doc/description of the node\n     */\n    private String extractDoc(JsonNode node) {\n        if (node != null) {\n            if (node.has(DOC)) {\n                return node.get(DOC).asText();\n            } else if (node.has(DESCRIPTION)) {\n                // This is to support older standards of cwl which use description instead of doc\n                return node.get(DESCRIPTION).asText();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the types from a node representing inputs or outputs\n     * @param typeNode The root node representing an input or output\n     * @return A string with the types listed\n     */\n    private String extractTypes(JsonNode typeNode) {\n        if (typeNode != null) {\n            if (typeNode.getClass() == TextNode.class) {\n                // Single type\n                return typeNode.asText();\n            } else if (typeNode.getClass() == ArrayNode.class) {\n                // Multiple types, build a string to represent them\n                StringBuilder typeDetails = new StringBuilder();\n                boolean optional = false;\n                for (JsonNode type : typeNode) {\n                    if (type.getClass() == TextNode.class) {\n                        // This is a simple type\n                        if (type.asText().equals(\"null\")) {\n                            // null as a type means this field is optional\n                            optional = true;\n                        } else {\n                            // Add a simple type to the string\n                            typeDetails.append(type.asText());\n                            typeDetails.append(\", \");\n                        }\n                    } else if (typeNode.getClass() == ArrayNode.class) {\n                        // This is a verbose type with sub-fields broken down into type: and other params\n                        if (type.get(TYPE).asText().equals(ARRAY)) {\n                            typeDetails.append(type.get(ARRAY_ITEMS).asText());\n                            typeDetails.append(\"[], \");\n                        } else {\n                            typeDetails.append(type.get(TYPE).asText());\n                        }\n                    }\n                }\n\n                // Trim off excessive separators\n                if (typeDetails.length() > 1) {\n                    typeDetails.setLength(typeDetails.length() - 2);\n                }\n\n                // Add optional if null was included in the multiple types\n                if (optional) typeDetails.append(\"?\");\n\n                // Set the type to the constructed string\n                return typeDetails.toString();\n\n            } else if (typeNode.getClass() == ObjectNode.class) {\n                // Type: array and items:\n                if (typeNode.has(ARRAY_ITEMS)) {\n                    return typeNode.get(ARRAY_ITEMS).asText() + \"[]\";\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the run parameter from a node representing a step\n     * @param stepNode The root node of a step\n     * @return A string with the run parameter if it exists\n     */\n    private String extractRun(JsonNode stepNode) {\n        if (stepNode != null) {\n            if (stepNode.has(RUN)) {\n                return stepNode.get(RUN).asText();\n            }\n        }\n        return null;\n    }\n\n}\n"], "filenames": ["src/main/java/org/commonwl/view/cwl/CWLService.java"], "buggy_code_start_loc": [66], "buggy_code_end_loc": [622], "fixing_code_start_loc": [67], "fixing_code_end_loc": [621], "type": "CWE-502", "message": "cwlviewer is a web application to view and share Common Workflow Language workflows. Versions prior to 1.3.1 contain a Deserialization of Untrusted Data vulnerability. Commit number f6066f09edb70033a2ce80200e9fa9e70a5c29de (dated 2021-09-30) contains a patch. There are no available workarounds aside from installing the patch. The SnakeYaml constructor, by default, allows any data to be parsed. To fix the issue the object needs to be created with a `SafeConstructor` object, as seen in the patch.", "other": {"cve": {"id": "CVE-2021-41110", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-01T13:15:07.607", "lastModified": "2021-10-08T16:21:25.903", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cwlviewer is a web application to view and share Common Workflow Language workflows. Versions prior to 1.3.1 contain a Deserialization of Untrusted Data vulnerability. Commit number f6066f09edb70033a2ce80200e9fa9e70a5c29de (dated 2021-09-30) contains a patch. There are no available workarounds aside from installing the patch. The SnakeYaml constructor, by default, allows any data to be parsed. To fix the issue the object needs to be created with a `SafeConstructor` object, as seen in the patch."}, {"lang": "es", "value": "cwlviewer es una aplicaci\u00f3n web para visualizar y compartir workflows de Common Workflow Language. Las versiones anteriores a 1.3.1 contienen una vulnerabilidad de Deserializaci\u00f3n de Datos no Confiables. N\u00famero de Commit f6066f09edb70033a2ce80200e9fa9e70a5c29de (con fecha 30-09-2021) contiene un parche. No hay soluciones disponibles aparte de instalar el parche. El constructor SnakeYaml, por defecto, permite analizar cualquier dato. Para solucionar el problema, el objeto debe ser creado con un objeto \"SafeConstructor\", como es visualizado en el parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:commonwl:cwlviewer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "EC61CB3A-696A-4EB3-8B0D-8CAFF4E2C0A2"}]}]}], "references": [{"url": "https://github.com/common-workflow-language/cwlviewer/commit/f6066f09edb70033a2ce80200e9fa9e70a5c29de", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/common-workflow-language/cwlviewer/security/advisories/GHSA-7g7j-f5g3-fqp7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.fatalerrors.org/a/analysis-of-the-snakeyaml-deserialization-in-java-security.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/common-workflow-language/cwlviewer/commit/f6066f09edb70033a2ce80200e9fa9e70a5c29de"}}