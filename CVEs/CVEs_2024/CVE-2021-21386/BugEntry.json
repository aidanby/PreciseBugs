{"buggy_code": ["#!/usr/bin/env python3\nfrom apkleaks.colors import clr\nfrom contextlib import closing\nfrom distutils.spawn import find_executable\nfrom pyaxmlparser import APK\nfrom urllib.request import urlopen\nfrom zipfile import ZipFile\nimport io\nimport json\nimport logging.config\nimport mimetypes\nimport numpy\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\n\nclass APKLeaks:\n\tdef __init__(self, args):\n\t\tself.file = args.file\n\t\tself.prefix = \"apkleaks-\"\n\t\tself.tempdir = tempfile.mkdtemp(prefix=self.prefix)\n\t\tself.main_dir = os.path.dirname(os.path.realpath(__file__))\n\t\tself.output = tempfile.mkstemp(suffix=\".txt\", prefix=self.prefix)[1] if args.output is None else args.output\n\t\tself.pattern = self.main_dir + \"/../config/regexes.json\" if args.pattern is None else args.pattern\n\t\tself.jadx = find_executable(\"jadx\") if find_executable(\"jadx\") is not None else self.main_dir + \"/../jadx/bin/jadx%s\" % (\".bat\" if os.name == \"nt\" else \"\")\n\t\tlogging.config.dictConfig({\"version\": 1, \"disable_existing_loggers\": True})\n\n\tdef apk_info(self):\n\t\treturn APK(self.file)\n\n\tdef dependencies(self):\n\t\texter = \"https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip\"\n\t\twith closing(urlopen(exter)) as jadx:\n\t\t\twith ZipFile(io.BytesIO(jadx.read())) as zfile:\n\t\t\t\tzfile.extractall(self.main_dir + \"/../jadx\")\n\t\tos.chmod(self.jadx, 33268)\n\n\tdef write(self, message, color):\n\t\tsys.stdout.write(\"%s%s%s\" % (color, message, clr.ENDC))\n\n\tdef writeln(self, message, color):\n\t\tself.write(message + \"\\n\", color)\n\n\tdef integrity(self):\n\t\tif os.path.exists(self.jadx) is False:\n\t\t\tself.writeln(\"Can't find jadx binary.\", clr.WARNING)\n\t\t\tvalid = {\"yes\": True, \"y\": True, \"ye\": True, \"no\": False, \"n\": False}\n\t\t\twhile True:\n\t\t\t\tself.write(\"Do you want to download jadx? (Y/n) \", clr.OKBLUE)\n\t\t\t\tchoice = input().lower()\n\t\t\t\tif choice == \"\":\n\t\t\t\t\tchoice = valid[\"y\"]\n\t\t\t\t\tbreak\n\t\t\t\telif choice in valid:\n\t\t\t\t\tchoice = valid[choice]\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tself.writeln(\"\\nPlease respond with 'yes' or 'no' (or 'y' or 'n').\", clr.WARNING)\n\t\t\tif choice:\n\t\t\t\tself.writeln(\"** Downloading jadx...\\n\", clr.OKBLUE)\n\t\t\t\tself.dependencies()\n\t\t\telse:\n\t\t\t\tsys.exit(self.writeln(\"Aborted.\", clr.FAIL))\n\n\t\tif os.path.isfile(self.file) is True:\n\t\t\ttry:\n\t\t\t\tself.apk = self.apk_info()\n\t\t\texcept Exception as e:\n\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))\n\t\t\telse:\n\t\t\t\treturn self.apk\n\t\telse:\n\t\t\tsys.exit(self.writeln(\"It's not a valid file!\", clr.WARNING))\n\n\tdef decompile(self):\n\t\tself.writeln(\"** Decompiling APK...\", clr.OKBLUE)\n\t\twith ZipFile(self.file) as zipped:\n\t\t\ttry:\n\t\t\t\tdex = self.tempdir + \"/\" + self.apk.package + \".dex\"\n\t\t\t\twith open(dex, \"wb\") as classes:\n\t\t\t\t\tclasses.write(zipped.read(\"classes.dex\"))\n\t\t\texcept Exception as e:\n\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))\n\t\tdec = \"%s %s -d %s --deobf\" % (self.jadx, dex, self.tempdir)\n\t\tos.system(dec)\n\t\treturn self.tempdir\n\n\tdef unique(self, list): \n\t\tx = numpy.array(list) \n\t\treturn (numpy.unique(x))\n\n\tdef finder(self, pattern, path):\n\t\tmatcher = re.compile(pattern)\n\t\tfound = []\n\t\tfor path, _, files in os.walk(path):\n\t\t\tfor fn in files:\n\t\t\t\tfilepath = os.path.join(path, fn)\n\t\t\t\tif mimetypes.guess_type(filepath)[0] is None:\n\t\t\t\t\tcontinue\n\t\t\t\twith open(filepath) as handle:\n\t\t\t\t\tfor lineno, line in enumerate(handle):\n\t\t\t\t\t\tmo = matcher.search(line)\n\t\t\t\t\t\tif mo:\n\t\t\t\t\t\t\tfound.append(mo.group())\n\t\treturn self.unique(found)\n\n\tdef extract(self, name, matches):\n\t\toutput = open(self.output, \"a+\")\n\t\tif matches:\n\t\t\tstdout = (\"[%s]\" % (name))\n\t\t\tself.writeln(\"\\n\" + stdout, clr.OKGREEN)\n\t\t\toutput.write(stdout + \"\\n\")\n\t\t\tfor secret in matches:\n\t\t\t\tif name == \"LinkFinder\" and re.match(r\"^.(L[a-z]|application|audio|fonts|image|layout|multipart|plain|text|video).*\\/.+\", secret) is not None:\n\t\t\t\t\tcontinue\n\t\t\t\tstdout = (\"- %s\" % (secret))\n\t\t\t\tprint(stdout)\n\t\t\t\toutput.write(stdout + \"\\n\")\n\t\t\toutput.write(\"\\n\")\n\t\toutput.close()\n\n\tdef scanning(self):\n\t\tself.writeln(\"\\n** Scanning against '%s'\" % (self.apk.package), clr.OKBLUE)\n\t\twith open(self.pattern) as regexes:\n\t\t\tregex = json.load(regexes)\n\t\t\tfor name, pattern in regex.items():\n\t\t\t\tif isinstance(pattern, list):\n\t\t\t\t\tfor pattern in pattern:\n\t\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))\n\t\t\t\t\t\tthread.start()\n\t\t\t\telse:\n\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))\n\t\t\t\t\tthread.start()\n\n\tdef __del__(self):\n\t\tprint(\"%s\\n** Results saved into '%s%s%s%s'%s\" % (clr.OKBLUE, clr.ENDC, clr.OKGREEN, self.output, clr.OKBLUE, clr.ENDC))\n\t\ttry:\n\t\t\tshutil.rmtree(self.tempdir)\n\t\texcept Exception:\n\t\t\treturn\n"], "fixing_code": ["#!/usr/bin/env python3\nfrom apkleaks.colors import clr\nfrom contextlib import closing\nfrom distutils.spawn import find_executable\nfrom pipes import quote\nfrom pyaxmlparser import APK\nfrom urllib.request import urlopen\nfrom zipfile import ZipFile\nimport io\nimport json\nimport logging.config\nimport mimetypes\nimport numpy\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\n\nclass APKLeaks:\n\tdef __init__(self, args):\n\t\tself.file = args.file\n\t\tself.prefix = \"apkleaks-\"\n\t\tself.tempdir = tempfile.mkdtemp(prefix=self.prefix)\n\t\tself.main_dir = os.path.dirname(os.path.realpath(__file__))\n\t\tself.output = tempfile.mkstemp(suffix=\".txt\", prefix=self.prefix)[1] if args.output is None else args.output\n\t\tself.pattern = self.main_dir + \"/../config/regexes.json\" if args.pattern is None else args.pattern\n\t\tself.jadx = find_executable(\"jadx\") if find_executable(\"jadx\") is not None else self.main_dir + \"/../jadx/bin/jadx%s\" % (\".bat\" if os.name == \"nt\" else \"\")\n\t\tlogging.config.dictConfig({\"version\": 1, \"disable_existing_loggers\": True})\n\n\tdef apk_info(self):\n\t\treturn APK(self.file)\n\n\tdef dependencies(self):\n\t\texter = \"https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip\"\n\t\twith closing(urlopen(exter)) as jadx:\n\t\t\twith ZipFile(io.BytesIO(jadx.read())) as zfile:\n\t\t\t\tzfile.extractall(self.main_dir + \"/../jadx\")\n\t\tos.chmod(self.jadx, 33268)\n\n\tdef write(self, message, color):\n\t\tsys.stdout.write(\"%s%s%s\" % (color, message, clr.ENDC))\n\n\tdef writeln(self, message, color):\n\t\tself.write(message + \"\\n\", color)\n\n\tdef integrity(self):\n\t\tif os.path.exists(self.jadx) is False:\n\t\t\tself.writeln(\"Can't find jadx binary.\", clr.WARNING)\n\t\t\tvalid = {\"yes\": True, \"y\": True, \"ye\": True, \"no\": False, \"n\": False}\n\t\t\twhile True:\n\t\t\t\tself.write(\"Do you want to download jadx? (Y/n) \", clr.OKBLUE)\n\t\t\t\tchoice = input().lower()\n\t\t\t\tif choice == \"\":\n\t\t\t\t\tchoice = valid[\"y\"]\n\t\t\t\t\tbreak\n\t\t\t\telif choice in valid:\n\t\t\t\t\tchoice = valid[choice]\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tself.writeln(\"\\nPlease respond with 'yes' or 'no' (or 'y' or 'n').\", clr.WARNING)\n\t\t\tif choice:\n\t\t\t\tself.writeln(\"** Downloading jadx...\\n\", clr.OKBLUE)\n\t\t\t\tself.dependencies()\n\t\t\telse:\n\t\t\t\tsys.exit(self.writeln(\"Aborted.\", clr.FAIL))\n\n\t\tif os.path.isfile(self.file) is True:\n\t\t\ttry:\n\t\t\t\tself.apk = self.apk_info()\n\t\t\texcept Exception as e:\n\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))\n\t\t\telse:\n\t\t\t\treturn self.apk\n\t\telse:\n\t\t\tsys.exit(self.writeln(\"It's not a valid file!\", clr.WARNING))\n\n\tdef decompile(self):\n\t\tself.writeln(\"** Decompiling APK...\", clr.OKBLUE)\n\t\twith ZipFile(self.file) as zipped:\n\t\t\ttry:\n\t\t\t\tdex = self.tempdir + \"/\" + self.apk.package + \".dex\"\n\t\t\t\twith open(dex, \"wb\") as classes:\n\t\t\t\t\tclasses.write(zipped.read(\"classes.dex\"))\n\t\t\texcept Exception as e:\n\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))\n\t\targs = [self.jadx, dex, \"-d\", self.tempdir, \"--deobf\"]\n\t\tcomm = \"%s\" % (\" \".join(quote(arg) for arg in args))\n\t\tos.system(comm)\n\t\treturn self.tempdir\n\n\tdef unique(self, list): \n\t\tx = numpy.array(list) \n\t\treturn (numpy.unique(x))\n\n\tdef finder(self, pattern, path):\n\t\tmatcher = re.compile(pattern)\n\t\tfound = []\n\t\tfor path, _, files in os.walk(path):\n\t\t\tfor fn in files:\n\t\t\t\tfilepath = os.path.join(path, fn)\n\t\t\t\tif mimetypes.guess_type(filepath)[0] is None:\n\t\t\t\t\tcontinue\n\t\t\t\twith open(filepath) as handle:\n\t\t\t\t\tfor lineno, line in enumerate(handle):\n\t\t\t\t\t\tmo = matcher.search(line)\n\t\t\t\t\t\tif mo:\n\t\t\t\t\t\t\tfound.append(mo.group())\n\t\treturn self.unique(found)\n\n\tdef extract(self, name, matches):\n\t\toutput = open(self.output, \"a+\")\n\t\tif matches:\n\t\t\tstdout = (\"[%s]\" % (name))\n\t\t\tself.writeln(\"\\n\" + stdout, clr.OKGREEN)\n\t\t\toutput.write(stdout + \"\\n\")\n\t\t\tfor secret in matches:\n\t\t\t\tif name == \"LinkFinder\" and re.match(r\"^.(L[a-z]|application|audio|fonts|image|layout|multipart|plain|text|video).*\\/.+\", secret) is not None:\n\t\t\t\t\tcontinue\n\t\t\t\tstdout = (\"- %s\" % (secret))\n\t\t\t\tprint(stdout)\n\t\t\t\toutput.write(stdout + \"\\n\")\n\t\t\toutput.write(\"\\n\")\n\t\toutput.close()\n\n\tdef scanning(self):\n\t\tself.writeln(\"\\n** Scanning against '%s'\" % (self.apk.package), clr.OKBLUE)\n\t\twith open(self.pattern) as regexes:\n\t\t\tregex = json.load(regexes)\n\t\t\tfor name, pattern in regex.items():\n\t\t\t\tif isinstance(pattern, list):\n\t\t\t\t\tfor pattern in pattern:\n\t\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))\n\t\t\t\t\t\tthread.start()\n\t\t\t\telse:\n\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))\n\t\t\t\t\tthread.start()\n\n\tdef __del__(self):\n\t\tprint(\"%s\\n** Results saved into '%s%s%s%s'%s\" % (clr.OKBLUE, clr.ENDC, clr.OKGREEN, self.output, clr.OKBLUE, clr.ENDC))\n\t\ttry:\n\t\t\tshutil.rmtree(self.tempdir)\n\t\texcept Exception:\n\t\t\treturn\n"], "filenames": ["apkleaks/apkleaks.py"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [89], "fixing_code_start_loc": [5], "fixing_code_end_loc": [91], "type": "CWE-78", "message": "APKLeaks is an open-source project for scanning APK file for URIs, endpoints & secrets. APKLeaks prior to v2.0.3 allows remote attackers to execute arbitrary OS commands via package name inside application manifest. An attacker could include arguments that allow unintended commands or code to be executed, allow sensitive data to be read or modified or could cause other unintended behavior through malicious package name. The problem is fixed in version v2.0.6-dev and above.", "other": {"cve": {"id": "CVE-2021-21386", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-24T21:15:15.177", "lastModified": "2021-03-27T01:48:44.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "APKLeaks is an open-source project for scanning APK file for URIs, endpoints & secrets. APKLeaks prior to v2.0.3 allows remote attackers to execute arbitrary OS commands via package name inside application manifest. An attacker could include arguments that allow unintended commands or code to be executed, allow sensitive data to be read or modified or could cause other unintended behavior through malicious package name. The problem is fixed in version v2.0.6-dev and above."}, {"lang": "es", "value": "APKLeaks es un proyecto de c\u00f3digo abierto para escanear archivos APK en busca de unos URI, endpoints y secretos.&#xa0;APKLeaks anterior a versi\u00f3n v2.0.3, permite a atacantes remotos ejecutar comandos arbitrarios del sistema operativo por medio del nombre del paquete dentro del manifiesto de la aplicaci\u00f3n.&#xa0;Un atacante podr\u00eda incluir argumentos que permitan ejecutar comandos o c\u00f3digos no deseados, permitir que sean le\u00eddos o modificados datos confidenciales o que puedan causar otros comportamientos no deseados mediante el nombre del paquete malicioso.&#xa0;El problema es corregido en versi\u00f3n v2.0.6-dev y superior"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}, {"lang": "en", "value": "CWE-88"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apkleaks_project:apkleaks:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.3", "matchCriteriaId": "AE92E1BE-181B-4541-96D1-24A70FE08833"}]}]}], "references": [{"url": "https://github.com/dwisiswant0/apkleaks/commit/a966e781499ff6fd4eea66876d7532301b13a382", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dwisiswant0/apkleaks/security/advisories/GHSA-8434-v7xw-8m9x", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dwisiswant0/apkleaks/commit/a966e781499ff6fd4eea66876d7532301b13a382"}}