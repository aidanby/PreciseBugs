{"buggy_code": ["\"\"\"Base Tornado handlers for the Jupyter server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nfrom __future__ import annotations\n\nimport functools\nimport inspect\nimport ipaddress\nimport json\nimport mimetypes\nimport os\nimport re\nimport traceback\nimport types\nimport warnings\nfrom http.client import responses\nfrom logging import Logger\nfrom typing import TYPE_CHECKING, Any, Awaitable, Sequence, cast\nfrom urllib.parse import urlparse\n\nimport prometheus_client\nfrom jinja2 import TemplateNotFound\nfrom jupyter_core.paths import is_hidden\nfrom jupyter_events import EventLogger\nfrom tornado import web\nfrom tornado.log import app_log\nfrom traitlets.config import Application\n\nimport jupyter_server\nfrom jupyter_server import CallContext\nfrom jupyter_server._sysinfo import get_sys_info\nfrom jupyter_server._tz import utcnow\nfrom jupyter_server.auth.decorator import authorized\nfrom jupyter_server.i18n import combine_translations\nfrom jupyter_server.services.security import csp_report_uri\nfrom jupyter_server.utils import (\n    ensure_async,\n    filefind,\n    url_escape,\n    url_is_absolute,\n    url_path_join,\n    urldecode_unix_socket_path,\n)\n\nif TYPE_CHECKING:\n    from jupyter_client.kernelspec import KernelSpecManager\n    from jupyter_server_terminals.terminalmanager import TerminalManager\n    from tornado.concurrent import Future\n\n    from jupyter_server.auth.authorizer import Authorizer\n    from jupyter_server.auth.identity import IdentityProvider, User\n    from jupyter_server.serverapp import ServerApp\n    from jupyter_server.services.config.manager import ConfigManager\n    from jupyter_server.services.contents.manager import ContentsManager\n    from jupyter_server.services.kernels.kernelmanager import AsyncMappingKernelManager\n    from jupyter_server.services.sessions.sessionmanager import SessionManager\n\n# -----------------------------------------------------------------------------\n# Top-level handlers\n# -----------------------------------------------------------------------------\n\n_sys_info_cache = None\n\n\ndef json_sys_info():\n    \"\"\"Get sys info as json.\"\"\"\n    global _sys_info_cache  # noqa: PLW0603\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\n\ndef log() -> Logger:\n    \"\"\"Get the application log.\"\"\"\n    if Application.initialized():\n        return cast(Logger, Application.instance().log)\n    else:\n        return app_log\n\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def base_url(self) -> str:\n        return cast(str, self.settings.get(\"base_url\", \"/\"))\n\n    @property\n    def content_security_policy(self) -> str:\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if \"Content-Security-Policy\" in self.settings.get(\"headers\", {}):\n            # user-specified, don't override\n            return cast(str, self.settings[\"headers\"][\"Content-Security-Policy\"])\n\n        return \"; \".join(\n            [\n                \"frame-ancestors 'self'\",\n                # Make sure the report-uri is relative to the base_url\n                \"report-uri \"\n                + self.settings.get(\"csp_report_uri\", url_path_join(self.base_url, csp_report_uri)),\n            ]\n        )\n\n    def set_default_headers(self) -> None:\n        \"\"\"Set the default headers.\"\"\"\n        headers = {}\n        headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        headers.update(self.settings.get(\"headers\", {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.exception(  # type:ignore[attr-defined]\n                    \"Could not set default headers: %s\", e\n                )\n\n    @property\n    def cookie_name(self) -> str:\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.identity_provider.get_cookie_name(self)\n\n    def force_clear_cookie(self, name: str, path: str = \"/\", domain: str | None = None) -> None:\n        \"\"\"Force a cookie clear.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.identity_provider._force_clear_cookie(self, name, path=path, domain=domain)\n\n    def clear_login_cookie(self) -> None:\n        \"\"\"Clear a login cookie.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.identity_provider.clear_login_cookie(self)\n\n    def get_current_user(self) -> str:\n        \"\"\"Get the current user.\"\"\"\n        clsname = self.__class__.__name__\n        msg = (\n            f\"Calling `{clsname}.get_current_user()` directly is deprecated in jupyter-server 2.0.\"\n            \" Use `self.current_user` instead (works in all versions).\"\n        )\n        if hasattr(self, \"_jupyter_current_user\"):\n            # backward-compat: return _jupyter_current_user\n            warnings.warn(\n                msg,\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return cast(str, self._jupyter_current_user)\n        # haven't called get_user in prepare, raise\n        raise RuntimeError(msg)\n\n    def skip_check_origin(self) -> bool:\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == \"OPTIONS\":\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        return not self.identity_provider.should_check_origin(self)\n\n    @property\n    def token_authenticated(self) -> bool:\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        return self.identity_provider.is_token_authenticated(self)\n\n    @property\n    def logged_in(self) -> bool:\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.current_user\n        return bool(user and user != \"anonymous\")\n\n    @property\n    def login_handler(self) -> Any:\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.identity_provider.login_handler_class\n\n    @property\n    def token(self) -> str | None:\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.identity_provider.token\n\n    @property\n    def login_available(self) -> bool:\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        return cast(bool, self.identity_provider.login_available)\n\n    @property\n    def authorizer(self) -> Authorizer:\n        if \"authorizer\" not in self.settings:\n            warnings.warn(\n                \"The Tornado web application does not have an 'authorizer' defined \"\n                \"in its settings. In future releases of jupyter_server, this will \"\n                \"be a required key for all subclasses of `JupyterHandler`. For an \"\n                \"example, see the jupyter_server source code for how to \"\n                \"add an authorizer to the tornado settings: \"\n                \"https://github.com/jupyter-server/jupyter_server/blob/\"\n                \"653740cbad7ce0c8a8752ce83e4d3c2c754b13cb/jupyter_server/serverapp.py\"\n                \"#L234-L256\",\n                stacklevel=2,\n            )\n            from jupyter_server.auth import AllowAllAuthorizer\n\n            self.settings[\"authorizer\"] = AllowAllAuthorizer(\n                config=self.settings.get(\"config\", None),\n                identity_provider=self.identity_provider,\n            )\n\n        return cast(\"Authorizer\", self.settings.get(\"authorizer\"))\n\n    @property\n    def identity_provider(self) -> IdentityProvider:\n        if \"identity_provider\" not in self.settings:\n            warnings.warn(\n                \"The Tornado web application does not have an 'identity_provider' defined \"\n                \"in its settings. In future releases of jupyter_server, this will \"\n                \"be a required key for all subclasses of `JupyterHandler`. For an \"\n                \"example, see the jupyter_server source code for how to \"\n                \"add an identity provider to the tornado settings: \"\n                \"https://github.com/jupyter-server/jupyter_server/blob/v2.0.0/\"\n                \"jupyter_server/serverapp.py#L242\",\n                stacklevel=2,\n            )\n            from jupyter_server.auth import IdentityProvider\n\n            # no identity provider set, load default\n            self.settings[\"identity_provider\"] = IdentityProvider(\n                config=self.settings.get(\"config\", None)\n            )\n        return cast(\"IdentityProvider\", self.settings[\"identity_provider\"])\n\n\nclass JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self) -> dict[str, Any] | None:\n        return cast(\"dict[str, Any] | None\", self.settings.get(\"config\", None))\n\n    @property\n    def log(self) -> Logger:\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self) -> dict[str, Any]:\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return cast(\"dict[str, Any]\", self.settings.get(\"jinja_template_vars\", {}))\n\n    @property\n    def serverapp(self) -> ServerApp | None:\n        return cast(\"ServerApp | None\", self.settings[\"serverapp\"])\n\n    # ---------------------------------------------------------------\n    # URLs\n    # ---------------------------------------------------------------\n\n    @property\n    def version_hash(self) -> str:\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return cast(str, self.settings.get(\"version_hash\", \"\"))\n\n    @property\n    def mathjax_url(self) -> str:\n        url = cast(str, self.settings.get(\"mathjax_url\", \"\"))\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self) -> str:\n        return cast(str, self.settings.get(\"mathjax_config\", \"TeX-AMS-MML_HTMLorMML-full,Safe\"))\n\n    @property\n    def default_url(self) -> str:\n        return cast(str, self.settings.get(\"default_url\", \"\"))\n\n    @property\n    def ws_url(self) -> str:\n        return cast(str, self.settings.get(\"websocket_url\", \"\"))\n\n    @property\n    def contents_js_source(self) -> str:\n        self.log.debug(\n            \"Using contents: %s\",\n            self.settings.get(\"contents_js_source\", \"services/contents\"),\n        )\n        return cast(str, self.settings.get(\"contents_js_source\", \"services/contents\"))\n\n    # ---------------------------------------------------------------\n    # Manager objects\n    # ---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self) -> AsyncMappingKernelManager:\n        return cast(\"AsyncMappingKernelManager\", self.settings[\"kernel_manager\"])\n\n    @property\n    def contents_manager(self) -> ContentsManager:\n        return cast(\"ContentsManager\", self.settings[\"contents_manager\"])\n\n    @property\n    def session_manager(self) -> SessionManager:\n        return cast(\"SessionManager\", self.settings[\"session_manager\"])\n\n    @property\n    def terminal_manager(self) -> TerminalManager:\n        return cast(\"TerminalManager\", self.settings[\"terminal_manager\"])\n\n    @property\n    def kernel_spec_manager(self) -> KernelSpecManager:\n        return cast(\"KernelSpecManager\", self.settings[\"kernel_spec_manager\"])\n\n    @property\n    def config_manager(self) -> ConfigManager:\n        return cast(\"ConfigManager\", self.settings[\"config_manager\"])\n\n    @property\n    def event_logger(self) -> EventLogger:\n        return cast(\"EventLogger\", self.settings[\"event_logger\"])\n\n    # ---------------------------------------------------------------\n    # CORS\n    # ---------------------------------------------------------------\n\n    @property\n    def allow_origin(self) -> str:\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return cast(str, self.settings.get(\"allow_origin\", \"\"))\n\n    @property\n    def allow_origin_pat(self) -> str | None:\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return cast(\"str | None\", self.settings.get(\"allow_origin_pat\", None))\n\n    @property\n    def allow_credentials(self) -> bool:\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return cast(bool, self.settings.get(\"allow_credentials\", False))\n\n    def set_default_headers(self) -> None:\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super().set_default_headers()\n\n    def set_cors_headers(self) -> None:\n        \"\"\"Add CORS headers, if defined\n\n        Now that current_user is async (jupyter-server 2.0),\n        must be called at the end of prepare(), instead of in set_default_headers.\n        \"\"\"\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and re.match(self.allow_origin_pat, origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif self.token_authenticated and \"Access-Control-Allow-Origin\" not in self.settings.get(\n            \"headers\", {}\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header(\"Access-Control-Allow-Origin\", self.request.headers.get(\"Origin\", \"\"))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", \"true\")\n\n    def set_attachment_header(self, filename: str) -> None:\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header(\n            \"Content-Disposition\",\n            f\"attachment; filename*=utf-8''{escaped_filename}\",\n        )\n\n    def get_origin(self) -> str | None:\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado: str = \"\") -> bool:\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == \"*\" or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = bool(self.allow_origin == origin)\n        elif self.allow_origin_pat:\n            allow = bool(re.match(self.allow_origin_pat, origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\n                \"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path,\n                origin,\n                host,\n            )\n        return allow\n\n    def check_referer(self) -> bool:\n        \"\"\"Check Referer for cross-site requests.\n        Disables requests to certain endpoints with\n        external or missing Referer.\n        If set, allow_origin settings are applied to the Referer\n        to whitelist specific cross-origin sites.\n        Used on GET for api endpoints and /files/\n        to block cross-site inclusion (XSSI).\n        \"\"\"\n        if self.allow_origin == \"*\" or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        referer = self.request.headers.get(\"Referer\")\n\n        if not host:\n            self.log.warning(\"Blocking request with no host\")\n            return False\n        if not referer:\n            self.log.warning(\"Blocking request with no referer\")\n            return False\n\n        referer_url = urlparse(referer)\n        referer_host = referer_url.netloc\n        if referer_host == host:\n            return True\n\n        # apply cross-origin checks to Referer:\n        origin = f\"{referer_url.scheme}://{referer_url.netloc}\"\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(re.match(self.allow_origin_pat, origin))\n        else:\n            # No CORS settings, deny the request\n            allow = False\n\n        if not allow:\n            self.log.warning(\n                \"Blocking Cross Origin request for %s.  Referer: %s, Host: %s\",\n                self.request.path,\n                origin,\n                host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self) -> None:\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if not hasattr(self, \"_jupyter_current_user\"):\n            # Called too early, will be checked later\n            return None\n        if self.token_authenticated or self.settings.get(\"disable_check_xsrf\", False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return None\n        try:\n            return super().check_xsrf_cookie()\n        except web.HTTPError as e:\n            if self.request.method in {\"GET\", \"HEAD\"}:\n                # Consider Referer a sufficient cross-origin check for GET requests\n                if not self.check_referer():\n                    referer = self.request.headers.get(\"Referer\")\n                    if referer:\n                        msg = f\"Blocking Cross Origin request from {referer}.\"\n                    else:\n                        msg = \"Blocking request from unknown origin\"\n                    raise web.HTTPError(403, msg) from e\n            else:\n                raise\n\n    def check_host(self) -> bool:\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get(\"allow_remote_access\", False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        match = re.match(r\"^(.*?)(:\\d+)?$\", self.request.host)\n        assert match is not None\n        host = match.group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith(\"[\") and host.endswith(\"]\"):\n            host = host[1:-1]\n\n        # UNIX socket handling\n        check_host = urldecode_unix_socket_path(host)\n        if check_host.startswith(\"/\") and os.path.exists(check_host):\n            allow = True\n        else:\n            try:\n                addr = ipaddress.ip_address(host)\n            except ValueError:\n                # Not an IP address: check against hostnames\n                allow = host in self.settings.get(\"local_hostnames\", [\"localhost\"])\n            else:\n                allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\n                    \"Blocking request with non-local 'Host' %s (%s). \"\n                    \"If the server should be accessible at that name, \"\n                    \"set ServerApp.allow_remote_access to disable the check.\"\n                ),\n                host,\n                self.request.host,\n            )\n        return allow\n\n    async def prepare(self) -> Awaitable[None] | None:  # type:ignore[override]\n        \"\"\"Prepare a response.\"\"\"\n        # Set the current Jupyter Handler context variable.\n        CallContext.set(CallContext.JUPYTER_HANDLER, self)\n\n        if not self.check_host():\n            self.current_user = self._jupyter_current_user = None\n            raise web.HTTPError(403)\n\n        from jupyter_server.auth import IdentityProvider\n\n        mod_obj = inspect.getmodule(self.get_current_user)\n        assert mod_obj is not None\n        user: User | None = None\n\n        if type(self.identity_provider) is IdentityProvider and mod_obj.__name__ != __name__:\n            # check for overridden get_current_user + default IdentityProvider\n            # deprecated way to override auth (e.g. JupyterHub < 3.0)\n            # allow deprecated, overridden get_current_user\n            warnings.warn(\n                \"Overriding JupyterHandler.get_current_user is deprecated in jupyter-server 2.0.\"\n                \" Use an IdentityProvider class.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            user = User(self.get_current_user())\n        else:\n            _user = self.identity_provider.get_user(self)\n            if isinstance(_user, Awaitable):\n                # IdentityProvider.get_user _may_ be async\n                _user = await _user\n            user = _user\n\n        # self.current_user for tornado's @web.authenticated\n        # self._jupyter_current_user for backward-compat in deprecated get_current_user calls\n        # and our own private checks for whether .current_user has been set\n        self.current_user = self._jupyter_current_user = user\n        # complete initial steps which require auth to resolve first:\n        self.set_cors_headers()\n        if self.request.method not in {\"GET\", \"HEAD\", \"OPTIONS\"}:\n            self.check_xsrf_cookie()\n        return super().prepare()\n\n    # ---------------------------------------------------------------\n    # template rendering\n    # ---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings[\"jinja2_env\"].get_template(name)\n\n    def render_template(self, name, **ns):\n        \"\"\"Render a template by name.\"\"\"\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self) -> dict[str, Any]:\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=getattr(self.identity_provider, \"allow_password_change\", False),\n            auth_enabled=self.identity_provider.auth_enabled,\n            login_available=self.identity_provider.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode(\"utf8\"),\n            nbjs_translations=json.dumps(\n                combine_translations(self.request.headers.get(\"Accept-Language\", \"\"))\n            ),\n            **self.jinja_template_vars,\n        )\n\n    def get_json_body(self) -> dict[str, Any] | None:\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(\"utf-8\")\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, \"Invalid JSON in body of request\") from e\n        return cast(\"dict[str, Any]\", model)\n\n    def write_error(self, status_code: int, **kwargs: Any) -> None:\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get(\"exc_info\")\n        message = \"\"\n        status_message = responses.get(status_code, \"Unknown HTTP Error\")\n\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, \"reason\", \"\")\n            if reason:\n                status_message = reason\n        else:\n            exception = \"(unknown)\"\n\n        # build template namespace\n        ns = {\n            \"status_code\": status_code,\n            \"status_message\": status_message,\n            \"message\": message,\n            \"exception\": exception,\n        }\n\n        self.set_header(\"Content-Type\", \"text/html\")\n        # render the template\n        try:\n            html = self.render_template(\"%s.html\" % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template(\"error.html\", **ns)\n\n        self.write(html)\n\n\nclass APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    async def prepare(self) -> None:\n        \"\"\"Prepare an API response.\"\"\"\n        await super().prepare()\n        if not self.check_origin():\n            raise web.HTTPError(404)\n\n    def write_error(self, status_code: int, **kwargs: Any) -> None:\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header(\"Content-Type\", \"application/json\")\n        message = responses.get(status_code, \"Unknown HTTP Error\")\n        reply: dict[str, Any] = {\n            \"message\": message,\n        }\n        exc_info = kwargs.get(\"exc_info\")\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply[\"message\"] = e.log_message or message\n                reply[\"reason\"] = e.reason\n            else:\n                reply[\"message\"] = \"Unhandled error\"\n                reply[\"reason\"] = None\n                reply[\"traceback\"] = \"\".join(traceback.format_exception(*exc_info))\n        self.log.warning(\"wrote error: %r\", reply[\"message\"], exc_info=True)\n        self.finish(json.dumps(reply))\n\n    def get_login_url(self) -> str:\n        \"\"\"Get the login url.\"\"\"\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super().get_login_url()\n\n    @property\n    def content_security_policy(self) -> str:\n        csp = \"; \".join(\n            [\n                super().content_security_policy,\n                \"default-src 'none'\",\n            ]\n        )\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self) -> None:\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, \"_jupyter_current_user\", None)\n            and self.get_argument(\"no_track_activity\", None) is None\n        ):\n            self.settings[\"api_last_activity\"] = utcnow()\n\n    def finish(self, *args: Any, **kwargs: Any) -> Future[Any]:\n        \"\"\"Finish an API response.\"\"\"\n        self.update_api_activity()\n        # Allow caller to indicate content-type...\n        set_content_type = kwargs.pop(\"set_content_type\", \"application/json\")\n        self.set_header(\"Content-Type\", set_content_type)\n        return super().finish(*args, **kwargs)\n\n    def options(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Get the options.\"\"\"\n        if \"Access-Control-Allow-Headers\" in self.settings.get(\"headers\", {}):\n            self.set_header(\n                \"Access-Control-Allow-Headers\",\n                self.settings[\"headers\"][\"Access-Control-Allow-Headers\"],\n            )\n        else:\n            self.set_header(\n                \"Access-Control-Allow-Headers\",\n                \"accept, content-type, authorization, x-xsrftoken\",\n            )\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, PATCH, DELETE, OPTIONS\")\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get(\"Access-Control-Request-Headers\", \"\").split(\n            \",\"\n        )\n        if (\n            requested_headers\n            and any(h.strip().lower() == \"authorization\" for h in requested_headers)\n            and (\n                # FIXME: it would be even better to check specifically for token-auth,\n                # but there is currently no API for this.\n                self.login_available\n            )\n            and (\n                self.allow_origin\n                or self.allow_origin_pat\n                or \"Access-Control-Allow-Origin\" in self.settings.get(\"headers\", {})\n            )\n        ):\n            self.set_header(\"Access-Control-Allow-Origin\", self.request.headers.get(\"Origin\", \"\"))\n\n\nclass Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n\n    async def prepare(self) -> None:\n        \"\"\"Prepare a 404 response.\"\"\"\n        await super().prepare()\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    auth_resource = \"contents\"\n\n    @property\n    def content_security_policy(self) -> str:\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super().content_security_policy + \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    @authorized\n    def head(self, path: str) -> Awaitable[None]:  # type:ignore[override]\n        \"\"\"Get the head response for a path.\"\"\"\n        self.check_xsrf_cookie()\n        return super().head(path)\n\n    @web.authenticated\n    @authorized\n    def get(  # type:ignore[override]\n        self, path: str, **kwargs: Any\n    ) -> Awaitable[None]:\n        \"\"\"Get a file by path.\"\"\"\n        self.check_xsrf_cookie()\n        if os.path.splitext(path)[1] == \".ipynb\" or self.get_argument(\"download\", None):\n            name = path.rsplit(\"/\", 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path, **kwargs)\n\n    def get_content_type(self) -> str:\n        \"\"\"Get the content type.\"\"\"\n        assert self.absolute_path is not None\n        path = self.absolute_path.strip(\"/\")\n        if \"/\" in path:\n            _, name = path.rsplit(\"/\", 1)\n        else:\n            name = path\n        if name.endswith(\".ipynb\"):\n            return \"application/x-ipynb+json\"\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == \"text/plain\":\n                return \"text/plain; charset=UTF-8\"\n            else:\n                return super().get_content_type()\n\n    def set_headers(self) -> None:\n        \"\"\"Set the headers.\"\"\"\n        super().set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self) -> str | None:\n        \"\"\"Compute the etag.\"\"\"\n        return None\n\n    def validate_absolute_path(self, root: str, absolute_path: str) -> str:\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super().validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        assert abs_path is not None\n        if not self.contents_manager.allow_hidden and is_hidden(abs_path, abs_root):\n            self.log.info(\n                \"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\"\n            )\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method: Any) -> Any:  # pragma: no cover\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn(\n        \"@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n\n    return wrapper\n\n\n# -----------------------------------------------------------------------------\n# File handler\n# -----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\n\nclass FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\n\n    The setting \"static_immutable_cache\" can be set up to serve some static\n    file as immutable (e.g. file name containing a hash). The setting is a\n    list of base URL, every static file URL starting with one of those will\n    be immutable.\n    \"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths: dict[str, str] = {}\n    root: tuple[str]  # type:ignore[assignment]\n\n    def set_headers(self) -> None:\n        \"\"\"Set the headers.\"\"\"\n        super().set_headers()\n\n        immutable_paths = self.settings.get(\"static_immutable_cache\", [])\n\n        # allow immutable cache for files\n        if any(self.request.path.startswith(path) for path in immutable_paths):\n            self.set_header(\"Cache-Control\", \"public, max-age=31536000, immutable\")\n\n        # disable browser caching, rely on 304 replies for savings\n        elif \"v\" not in self.request.arguments or any(\n            self.request.path.startswith(path) for path in self.no_cache_paths\n        ):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(\n        self,\n        path: str | list[str],\n        default_filename: str | None = None,\n        no_cache_paths: list[str] | None = None,\n    ) -> None:\n        \"\"\"Initialize the file find handler.\"\"\"\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, str):\n            path = [path]\n\n        self.root = tuple(os.path.abspath(os.path.expanduser(p)) + os.sep for p in path)  # type:ignore[assignment]\n        self.default_filename = default_filename\n\n    def compute_etag(self) -> str | None:\n        \"\"\"Compute the etag.\"\"\"\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots: Sequence[str], path: str) -> str:\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except OSError:\n                # IOError means not found\n                return \"\"\n\n            cls._static_paths[path] = abspath\n\n            log().debug(f\"Path {path} served from {abspath}\")\n            return abspath\n\n    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if not absolute_path:\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super().validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n    \"\"\"An API handler for the server version.\"\"\"\n\n    _track_activity = False\n\n    def get(self) -> None:\n        \"\"\"Get the server version info.\"\"\"\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self) -> None:\n        \"\"\"Handle trailing slashes in a get.\"\"\"\n        assert self.request.uri is not None\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get\n\n\nclass MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Get the main template.\"\"\"\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get\n\n\nclass FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    async def redirect_to_files(self: Any, path: str) -> None:\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if await ensure_async(cm.dir_exists(path)):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, \"tree\", url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split(\"/\")\n\n            if not await ensure_async(cm.file_exists(path=path)) and \"files\" in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove(\"files\")\n                path = \"/\".join(parts)\n\n            if not await ensure_async(cm.file_exists(path=path)):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, \"files\", url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    async def get(self, path: str = \"\") -> None:\n        return await self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n\n    def initialize(self, url: str, permanent: bool = True) -> None:\n        \"\"\"Initialize a redirect handler.\"\"\"\n        self._url = url\n        self._permanent = permanent\n\n    def get(self) -> None:\n        \"\"\"Get a redirect.\"\"\"\n        sep = \"&\" if \"?\" in self._url else \"?\"\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n\nclass PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this server\n    \"\"\"\n\n    def get(self) -> None:\n        \"\"\"Get prometheus metrics.\"\"\"\n        if self.settings[\"authenticate_prometheus\"] and not self.logged_in:\n            raise web.HTTPError(403)\n\n        self.set_header(\"Content-Type\", prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))\n\n\n# -----------------------------------------------------------------------------\n# URL pattern fragments for reuse\n# -----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n# -----------------------------------------------------------------------------\n# URL to handler mappings\n# -----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r\"/(robots\\.txt|favicon\\.ico)\", web.StaticFileHandler),\n    (r\"/metrics\", PrometheusMetricsHandler),\n]\n", "\"\"\"Tornado handlers for kernels.\n\nPreliminary documentation at https://github.com/ipython/ipython/wiki/IPEP-16%3A-Notebook-multi-directory-dashboard-and-URL-mapping#kernels-api\n\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport json\nfrom traceback import format_tb\n\ntry:\n    from jupyter_client.jsonutil import json_default\nexcept ImportError:\n    from jupyter_client.jsonutil import date_default as json_default\n\nfrom jupyter_core.utils import ensure_async\nfrom tornado import web\n\nfrom jupyter_server.auth.decorator import authorized\nfrom jupyter_server.utils import url_escape, url_path_join\n\nfrom ...base.handlers import APIHandler\nfrom .websocket import KernelWebsocketHandler\n\nAUTH_RESOURCE = \"kernels\"\n\n\nclass KernelsAPIHandler(APIHandler):\n    \"\"\"A kernels API handler.\"\"\"\n\n    auth_resource = AUTH_RESOURCE\n\n\nclass MainKernelHandler(KernelsAPIHandler):\n    \"\"\"The root kernel handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def get(self):\n        \"\"\"Get the list of running kernels.\"\"\"\n        km = self.kernel_manager\n        kernels = await ensure_async(km.list_kernels())\n        self.finish(json.dumps(kernels, default=json_default))\n\n    @web.authenticated\n    @authorized\n    async def post(self):\n        \"\"\"Start a kernel.\"\"\"\n        km = self.kernel_manager\n        model = self.get_json_body()\n        if model is None:\n            model = {\"name\": km.default_kernel_name}\n        else:\n            model.setdefault(\"name\", km.default_kernel_name)\n\n        kernel_id = await ensure_async(\n            km.start_kernel(  # type:ignore[has-type]\n                kernel_name=model[\"name\"], path=model.get(\"path\")\n            )\n        )\n        model = await ensure_async(km.kernel_model(kernel_id))\n        location = url_path_join(self.base_url, \"api\", \"kernels\", url_escape(kernel_id))\n        self.set_header(\"Location\", location)\n        self.set_status(201)\n        self.finish(json.dumps(model, default=json_default))\n\n\nclass KernelHandler(KernelsAPIHandler):\n    \"\"\"A kernel API handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def get(self, kernel_id):\n        \"\"\"Get a kernel model.\"\"\"\n        km = self.kernel_manager\n        model = await ensure_async(km.kernel_model(kernel_id))\n        self.finish(json.dumps(model, default=json_default))\n\n    @web.authenticated\n    @authorized\n    async def delete(self, kernel_id):\n        \"\"\"Remove a kernel.\"\"\"\n        km = self.kernel_manager\n        await ensure_async(km.shutdown_kernel(kernel_id))\n        self.set_status(204)\n        self.finish()\n\n\nclass KernelActionHandler(KernelsAPIHandler):\n    \"\"\"A kernel action API handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def post(self, kernel_id, action):\n        \"\"\"Interrupt or restart a kernel.\"\"\"\n        km = self.kernel_manager\n        if action == \"interrupt\":\n            await ensure_async(km.interrupt_kernel(kernel_id))  # type:ignore[func-returns-value]\n            self.set_status(204)\n        if action == \"restart\":\n            try:\n                await km.restart_kernel(kernel_id)\n            except Exception as e:\n                message = \"Exception restarting kernel\"\n                self.log.error(message, exc_info=True)\n                traceback = format_tb(e.__traceback__)\n                self.write(json.dumps({\"message\": message, \"traceback\": traceback}))\n                self.set_status(500)\n            else:\n                model = await ensure_async(km.kernel_model(kernel_id))\n                self.write(json.dumps(model, default=json_default))\n        self.finish()\n\n\n# -----------------------------------------------------------------------------\n# URL to handler mappings\n# -----------------------------------------------------------------------------\n_kernel_id_regex = r\"(?P<kernel_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n_kernel_action_regex = r\"(?P<action>restart|interrupt)\"\n\ndefault_handlers = [\n    (r\"/api/kernels\", MainKernelHandler),\n    (r\"/api/kernels/%s\" % _kernel_id_regex, KernelHandler),\n    (\n        rf\"/api/kernels/{_kernel_id_regex}/{_kernel_action_regex}\",\n        KernelActionHandler,\n    ),\n    (r\"/api/kernels/%s/channels\" % _kernel_id_regex, KernelWebsocketHandler),\n]\n"], "fixing_code": ["\"\"\"Base Tornado handlers for the Jupyter server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nfrom __future__ import annotations\n\nimport functools\nimport inspect\nimport ipaddress\nimport json\nimport mimetypes\nimport os\nimport re\nimport types\nimport warnings\nfrom http.client import responses\nfrom logging import Logger\nfrom typing import TYPE_CHECKING, Any, Awaitable, Sequence, cast\nfrom urllib.parse import urlparse\n\nimport prometheus_client\nfrom jinja2 import TemplateNotFound\nfrom jupyter_core.paths import is_hidden\nfrom jupyter_events import EventLogger\nfrom tornado import web\nfrom tornado.log import app_log\nfrom traitlets.config import Application\n\nimport jupyter_server\nfrom jupyter_server import CallContext\nfrom jupyter_server._sysinfo import get_sys_info\nfrom jupyter_server._tz import utcnow\nfrom jupyter_server.auth.decorator import authorized\nfrom jupyter_server.i18n import combine_translations\nfrom jupyter_server.services.security import csp_report_uri\nfrom jupyter_server.utils import (\n    ensure_async,\n    filefind,\n    url_escape,\n    url_is_absolute,\n    url_path_join,\n    urldecode_unix_socket_path,\n)\n\nif TYPE_CHECKING:\n    from jupyter_client.kernelspec import KernelSpecManager\n    from jupyter_server_terminals.terminalmanager import TerminalManager\n    from tornado.concurrent import Future\n\n    from jupyter_server.auth.authorizer import Authorizer\n    from jupyter_server.auth.identity import IdentityProvider, User\n    from jupyter_server.serverapp import ServerApp\n    from jupyter_server.services.config.manager import ConfigManager\n    from jupyter_server.services.contents.manager import ContentsManager\n    from jupyter_server.services.kernels.kernelmanager import AsyncMappingKernelManager\n    from jupyter_server.services.sessions.sessionmanager import SessionManager\n\n# -----------------------------------------------------------------------------\n# Top-level handlers\n# -----------------------------------------------------------------------------\n\n_sys_info_cache = None\n\n\ndef json_sys_info():\n    \"\"\"Get sys info as json.\"\"\"\n    global _sys_info_cache  # noqa: PLW0603\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\n\ndef log() -> Logger:\n    \"\"\"Get the application log.\"\"\"\n    if Application.initialized():\n        return cast(Logger, Application.instance().log)\n    else:\n        return app_log\n\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def base_url(self) -> str:\n        return cast(str, self.settings.get(\"base_url\", \"/\"))\n\n    @property\n    def content_security_policy(self) -> str:\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if \"Content-Security-Policy\" in self.settings.get(\"headers\", {}):\n            # user-specified, don't override\n            return cast(str, self.settings[\"headers\"][\"Content-Security-Policy\"])\n\n        return \"; \".join(\n            [\n                \"frame-ancestors 'self'\",\n                # Make sure the report-uri is relative to the base_url\n                \"report-uri \"\n                + self.settings.get(\"csp_report_uri\", url_path_join(self.base_url, csp_report_uri)),\n            ]\n        )\n\n    def set_default_headers(self) -> None:\n        \"\"\"Set the default headers.\"\"\"\n        headers = {}\n        headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        headers.update(self.settings.get(\"headers\", {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.exception(  # type:ignore[attr-defined]\n                    \"Could not set default headers: %s\", e\n                )\n\n    @property\n    def cookie_name(self) -> str:\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.identity_provider.get_cookie_name(self)\n\n    def force_clear_cookie(self, name: str, path: str = \"/\", domain: str | None = None) -> None:\n        \"\"\"Force a cookie clear.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.identity_provider._force_clear_cookie(self, name, path=path, domain=domain)\n\n    def clear_login_cookie(self) -> None:\n        \"\"\"Clear a login cookie.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.identity_provider.clear_login_cookie(self)\n\n    def get_current_user(self) -> str:\n        \"\"\"Get the current user.\"\"\"\n        clsname = self.__class__.__name__\n        msg = (\n            f\"Calling `{clsname}.get_current_user()` directly is deprecated in jupyter-server 2.0.\"\n            \" Use `self.current_user` instead (works in all versions).\"\n        )\n        if hasattr(self, \"_jupyter_current_user\"):\n            # backward-compat: return _jupyter_current_user\n            warnings.warn(\n                msg,\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return cast(str, self._jupyter_current_user)\n        # haven't called get_user in prepare, raise\n        raise RuntimeError(msg)\n\n    def skip_check_origin(self) -> bool:\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == \"OPTIONS\":\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        return not self.identity_provider.should_check_origin(self)\n\n    @property\n    def token_authenticated(self) -> bool:\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        return self.identity_provider.is_token_authenticated(self)\n\n    @property\n    def logged_in(self) -> bool:\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.current_user\n        return bool(user and user != \"anonymous\")\n\n    @property\n    def login_handler(self) -> Any:\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        warnings.warn(\n            \"\"\"JupyterHandler.login_handler is deprecated in 2.0,\n            use JupyterHandler.identity_provider.\n            \"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.identity_provider.login_handler_class\n\n    @property\n    def token(self) -> str | None:\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.identity_provider.token\n\n    @property\n    def login_available(self) -> bool:\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        return cast(bool, self.identity_provider.login_available)\n\n    @property\n    def authorizer(self) -> Authorizer:\n        if \"authorizer\" not in self.settings:\n            warnings.warn(\n                \"The Tornado web application does not have an 'authorizer' defined \"\n                \"in its settings. In future releases of jupyter_server, this will \"\n                \"be a required key for all subclasses of `JupyterHandler`. For an \"\n                \"example, see the jupyter_server source code for how to \"\n                \"add an authorizer to the tornado settings: \"\n                \"https://github.com/jupyter-server/jupyter_server/blob/\"\n                \"653740cbad7ce0c8a8752ce83e4d3c2c754b13cb/jupyter_server/serverapp.py\"\n                \"#L234-L256\",\n                stacklevel=2,\n            )\n            from jupyter_server.auth import AllowAllAuthorizer\n\n            self.settings[\"authorizer\"] = AllowAllAuthorizer(\n                config=self.settings.get(\"config\", None),\n                identity_provider=self.identity_provider,\n            )\n\n        return cast(\"Authorizer\", self.settings.get(\"authorizer\"))\n\n    @property\n    def identity_provider(self) -> IdentityProvider:\n        if \"identity_provider\" not in self.settings:\n            warnings.warn(\n                \"The Tornado web application does not have an 'identity_provider' defined \"\n                \"in its settings. In future releases of jupyter_server, this will \"\n                \"be a required key for all subclasses of `JupyterHandler`. For an \"\n                \"example, see the jupyter_server source code for how to \"\n                \"add an identity provider to the tornado settings: \"\n                \"https://github.com/jupyter-server/jupyter_server/blob/v2.0.0/\"\n                \"jupyter_server/serverapp.py#L242\",\n                stacklevel=2,\n            )\n            from jupyter_server.auth import IdentityProvider\n\n            # no identity provider set, load default\n            self.settings[\"identity_provider\"] = IdentityProvider(\n                config=self.settings.get(\"config\", None)\n            )\n        return cast(\"IdentityProvider\", self.settings[\"identity_provider\"])\n\n\nclass JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self) -> dict[str, Any] | None:\n        return cast(\"dict[str, Any] | None\", self.settings.get(\"config\", None))\n\n    @property\n    def log(self) -> Logger:\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self) -> dict[str, Any]:\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return cast(\"dict[str, Any]\", self.settings.get(\"jinja_template_vars\", {}))\n\n    @property\n    def serverapp(self) -> ServerApp | None:\n        return cast(\"ServerApp | None\", self.settings[\"serverapp\"])\n\n    # ---------------------------------------------------------------\n    # URLs\n    # ---------------------------------------------------------------\n\n    @property\n    def version_hash(self) -> str:\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return cast(str, self.settings.get(\"version_hash\", \"\"))\n\n    @property\n    def mathjax_url(self) -> str:\n        url = cast(str, self.settings.get(\"mathjax_url\", \"\"))\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self) -> str:\n        return cast(str, self.settings.get(\"mathjax_config\", \"TeX-AMS-MML_HTMLorMML-full,Safe\"))\n\n    @property\n    def default_url(self) -> str:\n        return cast(str, self.settings.get(\"default_url\", \"\"))\n\n    @property\n    def ws_url(self) -> str:\n        return cast(str, self.settings.get(\"websocket_url\", \"\"))\n\n    @property\n    def contents_js_source(self) -> str:\n        self.log.debug(\n            \"Using contents: %s\",\n            self.settings.get(\"contents_js_source\", \"services/contents\"),\n        )\n        return cast(str, self.settings.get(\"contents_js_source\", \"services/contents\"))\n\n    # ---------------------------------------------------------------\n    # Manager objects\n    # ---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self) -> AsyncMappingKernelManager:\n        return cast(\"AsyncMappingKernelManager\", self.settings[\"kernel_manager\"])\n\n    @property\n    def contents_manager(self) -> ContentsManager:\n        return cast(\"ContentsManager\", self.settings[\"contents_manager\"])\n\n    @property\n    def session_manager(self) -> SessionManager:\n        return cast(\"SessionManager\", self.settings[\"session_manager\"])\n\n    @property\n    def terminal_manager(self) -> TerminalManager:\n        return cast(\"TerminalManager\", self.settings[\"terminal_manager\"])\n\n    @property\n    def kernel_spec_manager(self) -> KernelSpecManager:\n        return cast(\"KernelSpecManager\", self.settings[\"kernel_spec_manager\"])\n\n    @property\n    def config_manager(self) -> ConfigManager:\n        return cast(\"ConfigManager\", self.settings[\"config_manager\"])\n\n    @property\n    def event_logger(self) -> EventLogger:\n        return cast(\"EventLogger\", self.settings[\"event_logger\"])\n\n    # ---------------------------------------------------------------\n    # CORS\n    # ---------------------------------------------------------------\n\n    @property\n    def allow_origin(self) -> str:\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return cast(str, self.settings.get(\"allow_origin\", \"\"))\n\n    @property\n    def allow_origin_pat(self) -> str | None:\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return cast(\"str | None\", self.settings.get(\"allow_origin_pat\", None))\n\n    @property\n    def allow_credentials(self) -> bool:\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return cast(bool, self.settings.get(\"allow_credentials\", False))\n\n    def set_default_headers(self) -> None:\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super().set_default_headers()\n\n    def set_cors_headers(self) -> None:\n        \"\"\"Add CORS headers, if defined\n\n        Now that current_user is async (jupyter-server 2.0),\n        must be called at the end of prepare(), instead of in set_default_headers.\n        \"\"\"\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and re.match(self.allow_origin_pat, origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif self.token_authenticated and \"Access-Control-Allow-Origin\" not in self.settings.get(\n            \"headers\", {}\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header(\"Access-Control-Allow-Origin\", self.request.headers.get(\"Origin\", \"\"))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", \"true\")\n\n    def set_attachment_header(self, filename: str) -> None:\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header(\n            \"Content-Disposition\",\n            f\"attachment; filename*=utf-8''{escaped_filename}\",\n        )\n\n    def get_origin(self) -> str | None:\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado: str = \"\") -> bool:\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == \"*\" or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = bool(self.allow_origin == origin)\n        elif self.allow_origin_pat:\n            allow = bool(re.match(self.allow_origin_pat, origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\n                \"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path,\n                origin,\n                host,\n            )\n        return allow\n\n    def check_referer(self) -> bool:\n        \"\"\"Check Referer for cross-site requests.\n        Disables requests to certain endpoints with\n        external or missing Referer.\n        If set, allow_origin settings are applied to the Referer\n        to whitelist specific cross-origin sites.\n        Used on GET for api endpoints and /files/\n        to block cross-site inclusion (XSSI).\n        \"\"\"\n        if self.allow_origin == \"*\" or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        referer = self.request.headers.get(\"Referer\")\n\n        if not host:\n            self.log.warning(\"Blocking request with no host\")\n            return False\n        if not referer:\n            self.log.warning(\"Blocking request with no referer\")\n            return False\n\n        referer_url = urlparse(referer)\n        referer_host = referer_url.netloc\n        if referer_host == host:\n            return True\n\n        # apply cross-origin checks to Referer:\n        origin = f\"{referer_url.scheme}://{referer_url.netloc}\"\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(re.match(self.allow_origin_pat, origin))\n        else:\n            # No CORS settings, deny the request\n            allow = False\n\n        if not allow:\n            self.log.warning(\n                \"Blocking Cross Origin request for %s.  Referer: %s, Host: %s\",\n                self.request.path,\n                origin,\n                host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self) -> None:\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if not hasattr(self, \"_jupyter_current_user\"):\n            # Called too early, will be checked later\n            return None\n        if self.token_authenticated or self.settings.get(\"disable_check_xsrf\", False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return None\n        try:\n            return super().check_xsrf_cookie()\n        except web.HTTPError as e:\n            if self.request.method in {\"GET\", \"HEAD\"}:\n                # Consider Referer a sufficient cross-origin check for GET requests\n                if not self.check_referer():\n                    referer = self.request.headers.get(\"Referer\")\n                    if referer:\n                        msg = f\"Blocking Cross Origin request from {referer}.\"\n                    else:\n                        msg = \"Blocking request from unknown origin\"\n                    raise web.HTTPError(403, msg) from e\n            else:\n                raise\n\n    def check_host(self) -> bool:\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get(\"allow_remote_access\", False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        match = re.match(r\"^(.*?)(:\\d+)?$\", self.request.host)\n        assert match is not None\n        host = match.group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith(\"[\") and host.endswith(\"]\"):\n            host = host[1:-1]\n\n        # UNIX socket handling\n        check_host = urldecode_unix_socket_path(host)\n        if check_host.startswith(\"/\") and os.path.exists(check_host):\n            allow = True\n        else:\n            try:\n                addr = ipaddress.ip_address(host)\n            except ValueError:\n                # Not an IP address: check against hostnames\n                allow = host in self.settings.get(\"local_hostnames\", [\"localhost\"])\n            else:\n                allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\n                    \"Blocking request with non-local 'Host' %s (%s). \"\n                    \"If the server should be accessible at that name, \"\n                    \"set ServerApp.allow_remote_access to disable the check.\"\n                ),\n                host,\n                self.request.host,\n            )\n        return allow\n\n    async def prepare(self) -> Awaitable[None] | None:  # type:ignore[override]\n        \"\"\"Prepare a response.\"\"\"\n        # Set the current Jupyter Handler context variable.\n        CallContext.set(CallContext.JUPYTER_HANDLER, self)\n\n        if not self.check_host():\n            self.current_user = self._jupyter_current_user = None\n            raise web.HTTPError(403)\n\n        from jupyter_server.auth import IdentityProvider\n\n        mod_obj = inspect.getmodule(self.get_current_user)\n        assert mod_obj is not None\n        user: User | None = None\n\n        if type(self.identity_provider) is IdentityProvider and mod_obj.__name__ != __name__:\n            # check for overridden get_current_user + default IdentityProvider\n            # deprecated way to override auth (e.g. JupyterHub < 3.0)\n            # allow deprecated, overridden get_current_user\n            warnings.warn(\n                \"Overriding JupyterHandler.get_current_user is deprecated in jupyter-server 2.0.\"\n                \" Use an IdentityProvider class.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            user = User(self.get_current_user())\n        else:\n            _user = self.identity_provider.get_user(self)\n            if isinstance(_user, Awaitable):\n                # IdentityProvider.get_user _may_ be async\n                _user = await _user\n            user = _user\n\n        # self.current_user for tornado's @web.authenticated\n        # self._jupyter_current_user for backward-compat in deprecated get_current_user calls\n        # and our own private checks for whether .current_user has been set\n        self.current_user = self._jupyter_current_user = user\n        # complete initial steps which require auth to resolve first:\n        self.set_cors_headers()\n        if self.request.method not in {\"GET\", \"HEAD\", \"OPTIONS\"}:\n            self.check_xsrf_cookie()\n        return super().prepare()\n\n    # ---------------------------------------------------------------\n    # template rendering\n    # ---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings[\"jinja2_env\"].get_template(name)\n\n    def render_template(self, name, **ns):\n        \"\"\"Render a template by name.\"\"\"\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self) -> dict[str, Any]:\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=getattr(self.identity_provider, \"allow_password_change\", False),\n            auth_enabled=self.identity_provider.auth_enabled,\n            login_available=self.identity_provider.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode(\"utf8\"),\n            nbjs_translations=json.dumps(\n                combine_translations(self.request.headers.get(\"Accept-Language\", \"\"))\n            ),\n            **self.jinja_template_vars,\n        )\n\n    def get_json_body(self) -> dict[str, Any] | None:\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(\"utf-8\")\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, \"Invalid JSON in body of request\") from e\n        return cast(\"dict[str, Any]\", model)\n\n    def write_error(self, status_code: int, **kwargs: Any) -> None:\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get(\"exc_info\")\n        message = \"\"\n        status_message = responses.get(status_code, \"Unknown HTTP Error\")\n\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, \"reason\", \"\")\n            if reason:\n                status_message = reason\n        else:\n            exception = \"(unknown)\"\n\n        # build template namespace\n        ns = {\n            \"status_code\": status_code,\n            \"status_message\": status_message,\n            \"message\": message,\n            \"exception\": exception,\n        }\n\n        self.set_header(\"Content-Type\", \"text/html\")\n        # render the template\n        try:\n            html = self.render_template(\"%s.html\" % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template(\"error.html\", **ns)\n\n        self.write(html)\n\n\nclass APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    async def prepare(self) -> None:\n        \"\"\"Prepare an API response.\"\"\"\n        await super().prepare()\n        if not self.check_origin():\n            raise web.HTTPError(404)\n\n    def write_error(self, status_code: int, **kwargs: Any) -> None:\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header(\"Content-Type\", \"application/json\")\n        message = responses.get(status_code, \"Unknown HTTP Error\")\n        reply: dict[str, Any] = {\n            \"message\": message,\n        }\n        exc_info = kwargs.get(\"exc_info\")\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply[\"message\"] = e.log_message or message\n                reply[\"reason\"] = e.reason\n            else:\n                reply[\"message\"] = \"Unhandled error\"\n                reply[\"reason\"] = None\n                # backward-compatibility: traceback field is present,\n                # but always empty\n                reply[\"traceback\"] = \"\"\n        self.log.warning(\"wrote error: %r\", reply[\"message\"], exc_info=True)\n        self.finish(json.dumps(reply))\n\n    def get_login_url(self) -> str:\n        \"\"\"Get the login url.\"\"\"\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super().get_login_url()\n\n    @property\n    def content_security_policy(self) -> str:\n        csp = \"; \".join(\n            [\n                super().content_security_policy,\n                \"default-src 'none'\",\n            ]\n        )\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self) -> None:\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, \"_jupyter_current_user\", None)\n            and self.get_argument(\"no_track_activity\", None) is None\n        ):\n            self.settings[\"api_last_activity\"] = utcnow()\n\n    def finish(self, *args: Any, **kwargs: Any) -> Future[Any]:\n        \"\"\"Finish an API response.\"\"\"\n        self.update_api_activity()\n        # Allow caller to indicate content-type...\n        set_content_type = kwargs.pop(\"set_content_type\", \"application/json\")\n        self.set_header(\"Content-Type\", set_content_type)\n        return super().finish(*args, **kwargs)\n\n    def options(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Get the options.\"\"\"\n        if \"Access-Control-Allow-Headers\" in self.settings.get(\"headers\", {}):\n            self.set_header(\n                \"Access-Control-Allow-Headers\",\n                self.settings[\"headers\"][\"Access-Control-Allow-Headers\"],\n            )\n        else:\n            self.set_header(\n                \"Access-Control-Allow-Headers\",\n                \"accept, content-type, authorization, x-xsrftoken\",\n            )\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, PATCH, DELETE, OPTIONS\")\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get(\"Access-Control-Request-Headers\", \"\").split(\n            \",\"\n        )\n        if (\n            requested_headers\n            and any(h.strip().lower() == \"authorization\" for h in requested_headers)\n            and (\n                # FIXME: it would be even better to check specifically for token-auth,\n                # but there is currently no API for this.\n                self.login_available\n            )\n            and (\n                self.allow_origin\n                or self.allow_origin_pat\n                or \"Access-Control-Allow-Origin\" in self.settings.get(\"headers\", {})\n            )\n        ):\n            self.set_header(\"Access-Control-Allow-Origin\", self.request.headers.get(\"Origin\", \"\"))\n\n\nclass Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n\n    async def prepare(self) -> None:\n        \"\"\"Prepare a 404 response.\"\"\"\n        await super().prepare()\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    auth_resource = \"contents\"\n\n    @property\n    def content_security_policy(self) -> str:\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super().content_security_policy + \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    @authorized\n    def head(self, path: str) -> Awaitable[None]:  # type:ignore[override]\n        \"\"\"Get the head response for a path.\"\"\"\n        self.check_xsrf_cookie()\n        return super().head(path)\n\n    @web.authenticated\n    @authorized\n    def get(  # type:ignore[override]\n        self, path: str, **kwargs: Any\n    ) -> Awaitable[None]:\n        \"\"\"Get a file by path.\"\"\"\n        self.check_xsrf_cookie()\n        if os.path.splitext(path)[1] == \".ipynb\" or self.get_argument(\"download\", None):\n            name = path.rsplit(\"/\", 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path, **kwargs)\n\n    def get_content_type(self) -> str:\n        \"\"\"Get the content type.\"\"\"\n        assert self.absolute_path is not None\n        path = self.absolute_path.strip(\"/\")\n        if \"/\" in path:\n            _, name = path.rsplit(\"/\", 1)\n        else:\n            name = path\n        if name.endswith(\".ipynb\"):\n            return \"application/x-ipynb+json\"\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == \"text/plain\":\n                return \"text/plain; charset=UTF-8\"\n            else:\n                return super().get_content_type()\n\n    def set_headers(self) -> None:\n        \"\"\"Set the headers.\"\"\"\n        super().set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self) -> str | None:\n        \"\"\"Compute the etag.\"\"\"\n        return None\n\n    def validate_absolute_path(self, root: str, absolute_path: str) -> str:\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super().validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        assert abs_path is not None\n        if not self.contents_manager.allow_hidden and is_hidden(abs_path, abs_root):\n            self.log.info(\n                \"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\"\n            )\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method: Any) -> Any:  # pragma: no cover\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn(\n        \"@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n\n    return wrapper\n\n\n# -----------------------------------------------------------------------------\n# File handler\n# -----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\n\nclass FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\n\n    The setting \"static_immutable_cache\" can be set up to serve some static\n    file as immutable (e.g. file name containing a hash). The setting is a\n    list of base URL, every static file URL starting with one of those will\n    be immutable.\n    \"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths: dict[str, str] = {}\n    root: tuple[str]  # type:ignore[assignment]\n\n    def set_headers(self) -> None:\n        \"\"\"Set the headers.\"\"\"\n        super().set_headers()\n\n        immutable_paths = self.settings.get(\"static_immutable_cache\", [])\n\n        # allow immutable cache for files\n        if any(self.request.path.startswith(path) for path in immutable_paths):\n            self.set_header(\"Cache-Control\", \"public, max-age=31536000, immutable\")\n\n        # disable browser caching, rely on 304 replies for savings\n        elif \"v\" not in self.request.arguments or any(\n            self.request.path.startswith(path) for path in self.no_cache_paths\n        ):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(\n        self,\n        path: str | list[str],\n        default_filename: str | None = None,\n        no_cache_paths: list[str] | None = None,\n    ) -> None:\n        \"\"\"Initialize the file find handler.\"\"\"\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, str):\n            path = [path]\n\n        self.root = tuple(os.path.abspath(os.path.expanduser(p)) + os.sep for p in path)  # type:ignore[assignment]\n        self.default_filename = default_filename\n\n    def compute_etag(self) -> str | None:\n        \"\"\"Compute the etag.\"\"\"\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots: Sequence[str], path: str) -> str:\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except OSError:\n                # IOError means not found\n                return \"\"\n\n            cls._static_paths[path] = abspath\n\n            log().debug(f\"Path {path} served from {abspath}\")\n            return abspath\n\n    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if not absolute_path:\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super().validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n    \"\"\"An API handler for the server version.\"\"\"\n\n    _track_activity = False\n\n    def get(self) -> None:\n        \"\"\"Get the server version info.\"\"\"\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self) -> None:\n        \"\"\"Handle trailing slashes in a get.\"\"\"\n        assert self.request.uri is not None\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get\n\n\nclass MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Get the main template.\"\"\"\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get\n\n\nclass FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    async def redirect_to_files(self: Any, path: str) -> None:\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if await ensure_async(cm.dir_exists(path)):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, \"tree\", url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split(\"/\")\n\n            if not await ensure_async(cm.file_exists(path=path)) and \"files\" in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove(\"files\")\n                path = \"/\".join(parts)\n\n            if not await ensure_async(cm.file_exists(path=path)):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, \"files\", url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    async def get(self, path: str = \"\") -> None:\n        return await self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n\n    def initialize(self, url: str, permanent: bool = True) -> None:\n        \"\"\"Initialize a redirect handler.\"\"\"\n        self._url = url\n        self._permanent = permanent\n\n    def get(self) -> None:\n        \"\"\"Get a redirect.\"\"\"\n        sep = \"&\" if \"?\" in self._url else \"?\"\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n\nclass PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this server\n    \"\"\"\n\n    def get(self) -> None:\n        \"\"\"Get prometheus metrics.\"\"\"\n        if self.settings[\"authenticate_prometheus\"] and not self.logged_in:\n            raise web.HTTPError(403)\n\n        self.set_header(\"Content-Type\", prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))\n\n\n# -----------------------------------------------------------------------------\n# URL pattern fragments for reuse\n# -----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n# -----------------------------------------------------------------------------\n# URL to handler mappings\n# -----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r\"/(robots\\.txt|favicon\\.ico)\", web.StaticFileHandler),\n    (r\"/metrics\", PrometheusMetricsHandler),\n]\n", "\"\"\"Tornado handlers for kernels.\n\nPreliminary documentation at https://github.com/ipython/ipython/wiki/IPEP-16%3A-Notebook-multi-directory-dashboard-and-URL-mapping#kernels-api\n\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport json\n\ntry:\n    from jupyter_client.jsonutil import json_default\nexcept ImportError:\n    from jupyter_client.jsonutil import date_default as json_default\n\nfrom jupyter_core.utils import ensure_async\nfrom tornado import web\n\nfrom jupyter_server.auth.decorator import authorized\nfrom jupyter_server.utils import url_escape, url_path_join\n\nfrom ...base.handlers import APIHandler\nfrom .websocket import KernelWebsocketHandler\n\nAUTH_RESOURCE = \"kernels\"\n\n\nclass KernelsAPIHandler(APIHandler):\n    \"\"\"A kernels API handler.\"\"\"\n\n    auth_resource = AUTH_RESOURCE\n\n\nclass MainKernelHandler(KernelsAPIHandler):\n    \"\"\"The root kernel handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def get(self):\n        \"\"\"Get the list of running kernels.\"\"\"\n        km = self.kernel_manager\n        kernels = await ensure_async(km.list_kernels())\n        self.finish(json.dumps(kernels, default=json_default))\n\n    @web.authenticated\n    @authorized\n    async def post(self):\n        \"\"\"Start a kernel.\"\"\"\n        km = self.kernel_manager\n        model = self.get_json_body()\n        if model is None:\n            model = {\"name\": km.default_kernel_name}\n        else:\n            model.setdefault(\"name\", km.default_kernel_name)\n\n        kernel_id = await ensure_async(\n            km.start_kernel(  # type:ignore[has-type]\n                kernel_name=model[\"name\"], path=model.get(\"path\")\n            )\n        )\n        model = await ensure_async(km.kernel_model(kernel_id))\n        location = url_path_join(self.base_url, \"api\", \"kernels\", url_escape(kernel_id))\n        self.set_header(\"Location\", location)\n        self.set_status(201)\n        self.finish(json.dumps(model, default=json_default))\n\n\nclass KernelHandler(KernelsAPIHandler):\n    \"\"\"A kernel API handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def get(self, kernel_id):\n        \"\"\"Get a kernel model.\"\"\"\n        km = self.kernel_manager\n        model = await ensure_async(km.kernel_model(kernel_id))\n        self.finish(json.dumps(model, default=json_default))\n\n    @web.authenticated\n    @authorized\n    async def delete(self, kernel_id):\n        \"\"\"Remove a kernel.\"\"\"\n        km = self.kernel_manager\n        await ensure_async(km.shutdown_kernel(kernel_id))\n        self.set_status(204)\n        self.finish()\n\n\nclass KernelActionHandler(KernelsAPIHandler):\n    \"\"\"A kernel action API handler.\"\"\"\n\n    @web.authenticated\n    @authorized\n    async def post(self, kernel_id, action):\n        \"\"\"Interrupt or restart a kernel.\"\"\"\n        km = self.kernel_manager\n        if action == \"interrupt\":\n            await ensure_async(km.interrupt_kernel(kernel_id))  # type:ignore[func-returns-value]\n            self.set_status(204)\n        if action == \"restart\":\n            try:\n                await km.restart_kernel(kernel_id)\n            except Exception as e:\n                message = \"Exception restarting kernel\"\n                self.log.error(message, exc_info=True)\n                self.write(json.dumps({\"message\": message, \"traceback\": \"\"}))\n                self.set_status(500)\n            else:\n                model = await ensure_async(km.kernel_model(kernel_id))\n                self.write(json.dumps(model, default=json_default))\n        self.finish()\n\n\n# -----------------------------------------------------------------------------\n# URL to handler mappings\n# -----------------------------------------------------------------------------\n_kernel_id_regex = r\"(?P<kernel_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n_kernel_action_regex = r\"(?P<action>restart|interrupt)\"\n\ndefault_handlers = [\n    (r\"/api/kernels\", MainKernelHandler),\n    (r\"/api/kernels/%s\" % _kernel_id_regex, KernelHandler),\n    (\n        rf\"/api/kernels/{_kernel_id_regex}/{_kernel_action_regex}\",\n        KernelActionHandler,\n    ),\n    (r\"/api/kernels/%s/channels\" % _kernel_id_regex, KernelWebsocketHandler),\n]\n"], "filenames": ["jupyter_server/base/handlers.py", "jupyter_server/services/kernels/handlers.py"], "buggy_code_start_loc": [13, 8], "buggy_code_end_loc": [752, 107], "fixing_code_start_loc": [12, 7], "fixing_code_end_loc": [753, 105], "type": "CWE-209", "message": "The Jupyter Server provides the backend (i.e. the core services, APIs, and REST endpoints) for Jupyter web applications like Jupyter notebook, JupyterLab, and Voila. Unhandled errors in API requests coming from an authenticated user include traceback information, which can include path information. There is no known mechanism by which to trigger these errors without authentication, so the paths revealed are not considered particularly sensitive, given that the requesting user has arbitrary execution permissions already in the same environment. A fix has been introduced in commit `0056c3aa52` which no longer includes traceback information in JSON error responses. For compatibility, the traceback field is present, but always empty. This commit has been included in version 2.11.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-49080", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-04T21:15:34.273", "lastModified": "2023-12-14T03:15:36.243", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Jupyter Server provides the backend (i.e. the core services, APIs, and REST endpoints) for Jupyter web applications like Jupyter notebook, JupyterLab, and Voila. Unhandled errors in API requests coming from an authenticated user include traceback information, which can include path information. There is no known mechanism by which to trigger these errors without authentication, so the paths revealed are not considered particularly sensitive, given that the requesting user has arbitrary execution permissions already in the same environment. A fix has been introduced in commit `0056c3aa52` which no longer includes traceback information in JSON error responses. For compatibility, the traceback field is present, but always empty. This commit has been included in version 2.11.2. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Jupyter Server proporciona el backend (es decir, los servicios principales, API y endpoints REST) para aplicaciones web de Jupyter como Jupyter notebook, JupyterLab y Voila. Los errores no controlados en solicitudes de API provenientes de un usuario autenticado incluyen informaci\u00f3n de rastreo, que puede incluir informaci\u00f3n de ruta. No existe ning\u00fan mecanismo conocido para desencadenar estos errores sin autenticaci\u00f3n, por lo que las rutas reveladas no se consideran particularmente sensibles, dado que el usuario solicitante ya tiene permisos de ejecuci\u00f3n arbitrarios en el mismo entorno. Se introdujo una soluci\u00f3n en el commit `0056c3aa52` que ya no incluye informaci\u00f3n de rastreo en las respuestas de error JSON. Por compatibilidad, el campo de rastreo est\u00e1 presente, pero siempre vac\u00edo. Esta confirmaci\u00f3n se ha incluido en la versi\u00f3n 2.11.2. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyter_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.2", "matchCriteriaId": "8863886A-CB5A-42DC-B629-16579E41FDF5"}]}]}], "references": [{"url": "https://github.com/jupyter-server/jupyter_server/commit/0056c3aa52cbb28b263a7a609ae5f17618b36652", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jupyter-server/jupyter_server/security/advisories/GHSA-h56g-gq9v-vc8r", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/62LO7PPIAMLIDEKUOORXLHKLGA6QPL77/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FG2JWZI5KPUYMDPS53AIFTZJWZD3IT6I/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/jupyter-server/jupyter_server/commit/0056c3aa52cbb28b263a7a609ae5f17618b36652"}}