{"buggy_code": ["#######################################################################\n#  File Segmenter Script\n#######################################################################\n#  This script divides a file into individual chunks that have been marked\n#  in some specified tier.  Each vowel is saved as an individual Praat\n#  sound file with the name of the original file plus the interval\n#  label.  25 milliseconds is added to either side of the chunk to ensure\n#  that any analysis (with a 25ms window) made at the beginning of the chunk\n#  will not crash.\n#\n#  Input:   Sound files with associated TextGrids\n#           - TextGrids should have labels for relevant intervals (i.e.,\n#             intervals to be chunked).\n#  Output:  Individual sound files named according to the original file and\n#           the interval label.\n#  Process: The script asks for a directory in which to look for files, a tier\n#           by which to segment, and an input sound file type.  It then looks\n#           for soundfiles of the specified type with associated TextGrids in\n#           the specified folder.  For each soundfile, it locates marked\n#           intervals in the specifed tier one-by-one.  Each labeled interval \n#           (plus 25 ms before and after it) is saved as a new .wav file and\n#           a new text grid.  After all intervals in all files in the specified\n#           directory have been segmented, a finish message appears.\n\n# This script is not by Will Styler, but is distributed by him because it's super useful.\n#######################################################################\n\nform Chopping long sound files\n   comment Specify which tier in the TextGrid you want to segment by:\n        integer tier_number 2\n   comment Sound file extension:\n        optionmenu file_type: 2\n        option .aiff\n        option .wav\n   comment Filename base (soundfile name if left blank)\n   \t\tword namebase\nendform\ndirectory$ = chooseDirectory$ (\"Choose the directory containing sound files and textgrids\")\ndirectory$ = \"'directory$'\" + \"/\" \nout_dir$ = directory$\n\nclearinfo\nCreate Strings as file list... list 'directory$'*'file_type$'\nnumber_of_files = Get number of strings\n\n# Starting from here, add everything that should be repeated for each sound file\nfor j from 1 to number_of_files\n        select Strings list\n        filename$ = Get string... 'j'\n        Read from file... 'directory$''filename$'\n        soundname$ = selected$ (\"Sound\")\n        \n        gridfile$ = \"'directory$''soundname$'.TextGrid\"\n        if fileReadable (gridfile$)\n                Read from file... 'gridfile$'\n                select TextGrid 'soundname$'\n                number_of_intervals = Get number of intervals... 'tier_number'\n                \n                # Go through all intervals in the file\n                for k from 1 to number_of_intervals\n\t   \t\t \t\tselect TextGrid 'soundname$'\n\t    \t\t\tseg_label$ = Get label of interval... 'tier_number' 'k'\n\t\t\t    \tif seg_label$ <> \"\"\n\t\t\t            seg_start = Get starting point... 'tier_number' 'k'\n\t\t\t            seg_end = Get end point... 'tier_number' 'k'\n\t\t\t            start = seg_start - 0.025\n\t\t\t            end = seg_end + 0.025\n\t\t\t            select Sound 'soundname$'\n\t\t\t            Extract part: start, end, \"rectangular\", 1, \"no\"\n\t\t\t\t\t\tif namebase$ <> \"\"\n\t\t\t            \tout_filename$ = \"'out_dir$''namebase$'_'seg_label$'\"\n\t\t\t\t\t\telse\n\t\t\t            \tout_filename$ = \"'out_dir$''soundname$'_'seg_label$'\"\n\t\t\t\t\t\tendif\n\t\t\t\t\t\t# initialize anti-collision counter.\n\t\t\t            aff = 1\n\t\t\t\t\t\tname$ = \"'out_filename$'_'aff'\"\n\t\t\t            while fileReadable (\"'name$'.wav\")\n\t\t\t\t\t\t\t#out_filename$ = \"'out_dir$''soundname$'-'seg_label$'-'k'\"\n\t\t\t\t\t\t\taff = aff + 1\n\t\t\t\t\t\t\tname$ = \"'out_filename$'_'aff'\"\n\t\t\t            endwhile\n\t\t\t            Write to WAV file... 'name$'.wav\n\t\t\t            select TextGrid 'soundname$'\n\t\t\t            Extract part... 'start' 'end' no\n\t\t\t            #Rename... 'out_filename$'\n\t\t\t            Write to text file... 'name$'.TextGrid\n\t\t\t\t    endif\n                endfor\n                select all\n                minus Strings list\n                Remove\n        endif\nendfor\nselect all\nRemove\nprint All files have been segmented.\n\n", "# Nasal Earbud Extraction Script\n# This script is designed to extract information pulled from Nasal Earbud Measument (as described in Stewart and Kohlberger 2017)\n\n\n\n# References\n\n## Stewart, J., & Kohlberger, M. (2017). Earbuds: A Method for Analyzing Nasality in the Field.\n\nform De-modulate and Process Airflow Signals\n\tcomment Which channel contains nasal earbud signal?\n\t\tinteger naschannel 2\n\tcomment Which channel contains acoustic data?\n\t\tinteger orchannel 1\n\tcomment Which tier contains nasal segment marking?\n\t\tinteger nastier 2\nendform\n\ntpnum = 25\nshownasalance = 1\n\ndirectory$ = chooseDirectory$ (\"Choose the directory containing flow files and grids\")\ndirectory$ = \"'directory$'\" + \"/\" \nfile_type$ = \".wav\"\ncreateDirectory: directory$ + \"_graphs\"\nCreate Strings as file list... list 'directory$'*'file_type$'\nnumber_files = Get number of strings\n\n\t\t\n# Open a file for the results\nresultfile$ = \"'directory$'\"+\"_flowlog.txt\"\n\nheader_row$ = \"filename\" + tab$ + \"point\" + tab$ + \"vwlpct\" + tab$ + \"nas_power\" + tab$ + \"acoustic_power\" + tab$ + \"percnasalance\" + tab$ + \"measurement_time\"\npheader_row$ = \"'header_row$'\" + newline$\n#fileappend \"'resultfile$'\" 'pheader_row$'\n\nfor ifile to number_files\n\tselect Strings list\n\tsound$ = Get string... ifile\n\tRead from file... 'directory$''sound$'\n\tsoundname$ = selected$ (\"Sound\", 1)\n\tgridfile$ = \"'directory$''soundname$'.TextGrid\"\n\tif fileReadable (gridfile$)\n\t\t# Open the Textgrid\n\t\tRead from file... 'gridfile$'\n\t\t\n\t\t###\n\t\t# Get Grid Information\n\t\t###\n\t\t\n\t\tselect TextGrid 'soundname$'\n\t\tintstart = Get starting point... 1 2\n\t\tintend = Get end point... 1 2\n\t\tintdur = intend - intstart\n\t\tintmid = intstart + (intdur / 2)\n\t\tdisplayoff = 0.1 * intdur\n\t\tdisplaystart = intstart - displayoff\n\t\tdisplayend = intend + displayoff\n\t\t\n\t\t\n\t\t# Make a copy of the sound\n\t\tselectObject: \"Sound 'soundname$'\"\n\t\tCopy: \"'soundname$'_rekt\"\n\n\t\t# Rectify the signal, the first step in AM demodulation\n\t\tFormula: \"abs(self)\"\n\n\t\t# Low pass the Rectified version, completing the AM Demodulation\n\t\tFilter (pass Hann band): 0, 40, 20\n\t\tRename: \"'soundname$'_flow\"\n\n\t\t# Now extract the individual flow channels and delete the original\n\n\t\tselect Sound 'soundname$'_flow\n\t\tExtract all channels\n\t\tselect Sound 'soundname$'_flow\n\t\tRemove\n\n\t\tif naschannel = 1\n\t\t\tselect Sound 'soundname$'_flow_ch1\n\t\t\tRename: \"nasal_flow\"\n\t\t\tselect Sound 'soundname$'_flow_ch2\n\t\t\tRename: \"oral_flow\"\n\t\telse\n\t\t\tselect Sound 'soundname$'_flow_ch1\n\t\t\tRename: \"oral_flow\"\n\t\t\tselect Sound 'soundname$'_flow_ch2\n\t\t\tRename: \"nasal_flow\"\n\t\tendif\n\n\t\t# Process the oral flow to get standard deviations\n\t\tselect Sound oral_flow\n\t\tomax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\tosd = Get standard deviation: 1, 0,0\n\t\thalfosd = osd*0.01\n\t\t\n\t\t# Process the nasal flow to get standard deviations\n\t\tselect Sound nasal_flow\n\t\tnmax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\tnsd = Get standard deviation: 1, 0,0\n\t\thalfnsd = nsd*0.01\n\n\t\t####\n\t\t# Get %Nasalance\n\t\t####\n\n\t\tselect Sound nasal_flow\n\t\tdur = Get total duration\n\n\t\t# Basically take nasalflow / (oralflow+nasalflow), and don't calculate if nasality is stupidly small\n\n\t\tCreate Sound from formula: \"'soundname$'_nasalance\", 1, 0, 'dur', 44100, \"if (Sound_nasal_flow [col]) < 'halfnsd' then 0 else if (Sound_oral_flow [col]) < 'halfosd' then 0 else (Sound_nasal_flow [col])/((Sound_nasal_flow [col]) + (Sound_oral_flow [col])) endif endif\"\n\n\t\t# Percentages don't go higher than 1...\n\t\tFormula: \"if self > 1 then 1 else self endif\"\n\t\t\n\t\t###\n\t\t# Draw Pretty Pictures\n\t\t###\n\n\t\tLine width: 1\n\n\t\t# First paint the spectrogram for the flow chart\n\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\tErase all\n\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\n\t\tselect Sound 'soundname$'\n\t\tnoprogress To Spectrogram: 0.005, 5000, 0.005, 20, \"Hamming (raised sine-squared)\"\n\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\tselect TextGrid 'soundname$'\n\t\tBlack\n\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\tselect Spectrogram 'soundname$'\n\n\t\t# Make a second spectrogram for the scaled flows\n\t\tSelect outer viewport: 0, 9.5, 3, 6\n\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\tLine width: 1\n\t\tselect TextGrid 'soundname$'\n\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\tselect Spectrogram 'soundname$'\n\t\tif shownasalance\n\t\t\t# Make a third spectrogram for the %nasalance\n\t\t\tSelect outer viewport: 0, 9.5, 6, 9\n\t\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\t\tLine width: 1\n\t\t\tselect TextGrid 'soundname$'\n\t\t\tBlack\n\t\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\t\tselect Spectrogram 'soundname$'\n\t\tendif\n\t\t\n\t\tselect Spectrogram 'soundname$'\n\t\tRemove\n\n\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\n\t\t\n\t\tLine width: 2\n\n\t\tRed\n\n\t\t\tselect Sound oral_flow\n\t\t\tomax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\t\tomin = Get minimum: displaystart,displayend, \"Sinc70\"\n\t\n\t\t\tselect Sound nasal_flow\n\t\t\tnmax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\t\tnmin = Get minimum: displaystart,displayend, \"Sinc70\"\n\t\n\t\t\tif omax > nmax\n\t\t\t\tomax = omax + (0.1*omax)\n\t\t\telse\n\t\t\t\tomax = nmax + (0.1*nmax)\n\t\t\tendif\n\t\t\tif omin < nmin\n\t\t\t\tomin = omin + (0.5*omin)\n\t\t\telse\n\t\t\t\tomin = nmin + (0.5*nmin)\n\t\t\tendif\n\t\n\t\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\tDraw inner box\n\t\t\tomin = omin \n\t\t\tselect Sound oral_flow\n\t\t\tDraw: displaystart,displayend, 'omin', 'omax', \"no\", \"Curve\"\n\t\t\tLine width: 2\n\t\t\tLime\n\t\t\tselect Sound nasal_flow\n\t\t\tDraw: displaystart,displayend, 'omin', 'omax', \"no\", \"Curve\"\n\t\t\tOne mark right: 0, \"no\", \"yes\", \"yes\", \"Zero\"\n\t\t\tText top: \"no\", \"Nasal (Green) vs. Acoustic (Red) signal\"\n\t\t\n\t\tLine width: 2\n\t\n\t\t\tselect Sound 'soundname$'_nasalance\n\t\tSelect outer viewport: 0, 9.5, 3, 6\n\t\t\tCyan\n\t\t\tDraw: displaystart,displayend, 0, 1, \"yes\", \"Curve\"\n\t\t\tOne mark left: 0.5, \"no\", \"yes\", \"yes\", \"50%\"\n\t\t\tText top: \"no\", \"Percent Nasalance over time (where both oral and nasal > 0)\"\n\t\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\tLine width: 1\n\t\tBlue\n\t\tselect Sound 'soundname$'\n\t\tSelect outer viewport: 0, 9.5, 6, 9\n\t\tText top: \"no\", \"Waveforms (Acoustic on Top, Nasal bud on Bottom)\"\n\t\tDraw: displaystart,displayend, 0, 0, \"yes\", \"Curve\"\n\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\t# Now save the file\n\t\tSave as 300-dpi PNG file: \"'directory$'_graphs/'soundname$'.png\"\n\t\t\n\t\t# Clean up a bit\n\t\tselectObject: \"Sound nasal_flow\"\n\t\tplusObject: \"Sound oral_flow\"\n\t\tCombine to stereo\n\t\tRename: \"'soundname$'_flow_pascal\"\n\t\tselectObject: \"Sound nasal_flow\"\n\t\tplusObject: \"Sound oral_flow\"\n\t\tRemove\n\t\t\n\t\t###\n\t\t# Extract the data to a file\n\t\t###\n\n\t\t\n\t\t# Calculate how large each jump is based on duration of vowel\n\t\tsize = intdur / (tpnum-1)\n\t\t\n\t\tfor point from 1 to tpnum\n\t\t\tif point = 1\n\t\t\t\ttimepoint = 'intstart'\n\t\t\telsif point = tpnum\n\t\t\t\ttimepoint = 'intend'\n\t\t\telse\n\t\t\t\ttimepoint = intstart + (size * (point-1))\n\t\t\tendif\n\t\t\tselectObject: \"Sound 'soundname$'_flow_pascal\"\n\t\t\tnaspasc = Get value at time: 1, 'timepoint', \"Nearest\"\n\t\t\torpasc = Get value at time: 2, 'timepoint', \"Nearest\"\n\t\t\t\n\t\t\tselectObject: \"Sound 'soundname$'_nasalance\"\n\t\t\tpercnas = Get value at time: 1, 'timepoint', \"Nearest\"\n\t\t\tvwlpct = ((timepoint-intstart)/intdur)*100\n\t\t\t\n\t\t\tresult_row$ = \"'soundname$'\" + tab$ + \"'point'\" + tab$ + \"'vwlpct:2'\" + tab$ + \"'naspasc:10'\" + tab$ + \"'orpasc:10'\" + tab$ + \"'percnas:5'\" + tab$ + \"'timepoint:4'\" + newline$\n\t\t\t#fileappend \"'resultfile$'\" 'result_row$'\n\t\t\t\n\t\tendfor\n\telse\n\t\tselectObject: \"Sound 'soundname$'\"\n\t\tRemove\n\tendif\nendfor\nselect Strings list\nRemove\n\n# Version History\n# 1.0 - First release"], "fixing_code": ["#######################################################################\n#  File Segmenter Script\n#######################################################################\n#  This script divides a file into individual chunks that have been marked\n#  in some specified tier.  Each vowel is saved as an individual Praat\n#  sound file with the name of the original file plus the interval\n#  label.  25 milliseconds is added to either side of the chunk to ensure\n#  that any analysis (with a 25ms window) made at the beginning of the chunk\n#  will not crash.\n#\n#  Input:   Sound files with associated TextGrids\n#           - TextGrids should have labels for relevant intervals (i.e.,\n#             intervals to be chunked).\n#  Output:  Individual sound files named according to the original file and\n#           the interval label.\n#  Process: The script asks for a directory in which to look for files, a tier\n#           by which to segment, and an input sound file type.  It then looks\n#           for soundfiles of the specified type with associated TextGrids in\n#           the specified folder.  For each soundfile, it locates marked\n#           intervals in the specifed tier one-by-one.  Each labeled interval \n#           (plus 25 ms before and after it) is saved as a new .wav file and\n#           a new text grid.  After all intervals in all files in the specified\n#           directory have been segmented, a finish message appears.\n\n# This script is not by Will Styler, but is distributed by him because it's super useful.\n#######################################################################\n\nform Chopping long sound files\n   comment Specify which tier in the TextGrid you want to segment by:\n        integer tier_number 3\n   comment Sound file extension:\n        optionmenu file_type: 2\n        option .aiff\n        option .wav\n   comment Filename base (soundfile name if left blank)\n   \t\tword namebase\nendform\ndirectory$ = chooseDirectory$ (\"Choose the directory containing sound files and textgrids\")\ndirectory$ = \"'directory$'\" + \"/\" \nout_dir$ = directory$\n\nclearinfo\nCreate Strings as file list... list 'directory$'*'file_type$'\nnumber_of_files = Get number of strings\n\n# Starting from here, add everything that should be repeated for each sound file\nfor j from 1 to number_of_files\n        select Strings list\n        filename$ = Get string... 'j'\n        Read from file... 'directory$''filename$'\n        soundname$ = selected$ (\"Sound\")\n        \n        gridfile$ = \"'directory$''soundname$'.TextGrid\"\n        if fileReadable (gridfile$)\n                Read from file... 'gridfile$'\n                select TextGrid 'soundname$'\n                number_of_intervals = Get number of intervals... 'tier_number'\n                \n                # Go through all intervals in the file\n                for k from 1 to number_of_intervals\n\t   \t\t \t\tselect TextGrid 'soundname$'\n\t    \t\t\tseg_label$ = Get label of interval... 'tier_number' 'k'\n\t\t\t    \tif seg_label$ <> \"\"\n\t\t\t            seg_start = Get starting point... 'tier_number' 'k'\n\t\t\t            seg_end = Get end point... 'tier_number' 'k'\n\t\t\t            start = seg_start - 0.025\n\t\t\t            end = seg_end + 0.025\n\t\t\t            select Sound 'soundname$'\n\t\t\t            Extract part: start, end, \"rectangular\", 1, \"no\"\n\t\t\t\t\t\tif namebase$ <> \"\"\n\t\t\t            \twritename$ = \"'namebase$'_'seg_label$'\"\n\t\t\t\t\t\telse\n\t\t\t            \twritename$ = \"'soundname$'_'seg_label$'\"\n\t\t\t\t\t\tendif\n\t\t\t\t\t\t# Although you should use ASCII when making textgrids, this bit removes some instacrashes\n\t\t\t\t\t\twritename$ = replace$ (writename$, \" \", \"_\", 0)\n\t\t\t\t\t\twritename$ = replace$ (writename$, \"/\", \"_\", 0)\n\t\t\t\t\t\tout_filename$ = \"'out_dir$''writename$'\"\n\t\t\t\t\t\t# initialize anti-collision counter.\n\t\t\t        aff = 1\n\t\t\t\t\t\tname$ = \"'out_filename$'_'aff'\"\n\n\t\t\t\t\t\t#writeInfo: name$\n\t\t\t        while fileReadable (\"'name$'.wav\")\n\t\t\t\t\t\t\taff = aff + 1\n\t\t\t\t\t\t\tname$ = \"'out_filename$'_'aff'\"\n\t\t\t        endwhile\n\t\t\t            Write to WAV file... 'name$'.wav\n\t\t\t            select TextGrid 'soundname$'\n\t\t\t            Extract part... 'start' 'end' no\n\t\t\t            #Rename... 'out_filename$'\n\t\t\t            Write to text file... 'name$'.TextGrid\n\t\t\t\t    endif\n                endfor\n                select all\n                minus Strings list\n                Remove\n        endif\nendfor\nselect all\nRemove\nprint All files have been segmented.\n\n", "# Nasal Earbud Extraction Script\n# This script is designed to extract information pulled from Nasal Earbud Measument (as described in Stewart and Kohlberger 2017)\n\n\n\n# References\n\n## Stewart, J., & Kohlberger, M. (2017). Earbuds: A Method for Analyzing Nasality in the Field.\n\nform De-modulate and Process Airflow Signals\n\tcomment Which channel contains nasal earbud signal?\n\t\tinteger naschannel 2\n\tcomment Which channel contains acoustic data?\n\t\tinteger orchannel 1\n\tcomment Which tier contains nasal segment marking?\n\t\tinteger nastier 2\nendform\n\ntpnum = 25\nshownasalance = 1\n\ndirectory$ = chooseDirectory$ (\"Choose the directory containing flow files and grids\")\ndirectory$ = \"'directory$'\" + \"/\" \nfile_type$ = \".wav\"\ncreateDirectory: directory$ + \"_graphs\"\nCreate Strings as file list... list 'directory$'*'file_type$'\nnumber_files = Get number of strings\n\n\t\t\n# Open a file for the results\nresultfile$ = \"'directory$'\"+\"_flowlog.txt\"\n\nheader_row$ = \"filename\" + tab$ + \"point\" + tab$ + \"vwlpct\" + tab$ + \"nas_power\" + tab$ + \"acoustic_power\" + tab$ + \"percnasalance\" + tab$ + \"measurement_time\"\npheader_row$ = \"'header_row$'\" + newline$\n#fileappend \"'resultfile$'\" 'pheader_row$'\n\nfor ifile to number_files\n\tselect Strings list\n\tsound$ = Get string... ifile\n\tRead from file... 'directory$''sound$'\n\tsoundname$ = selected$ (\"Sound\", 1)\n\tgridfile$ = \"'directory$''soundname$'.TextGrid\"\n\tif fileReadable (gridfile$)\n\t\t# Open the Textgrid\n\t\tRead from file... 'gridfile$'\n\t\t\n\t\t###\n\t\t# Get Grid Information\n\t\t###\n\t\t\n\t\tselect TextGrid 'soundname$'\n\t\tintstart = Get starting point... 1 2\n\t\tintend = Get end point... 1 2\n\t\tintdur = intend - intstart\n\t\tintmid = intstart + (intdur / 2)\n\t\tdisplayoff = 0.1 * intdur\n\t\tdisplaystart = intstart - displayoff\n\t\tdisplayend = intend + displayoff\n\t\t\n\t\t\n\t\t# Make a copy of the sound\n\t\tselectObject: \"Sound 'soundname$'\"\n\t\tCopy: \"'soundname$'_rekt\"\n\n\t\t# Rectify the signal, the first step in AM demodulation\n\t\tFormula: \"abs(self)\"\n\n\t\t# Low pass the Rectified version, completing the AM Demodulation\n\t\tFilter (pass Hann band): 0, 40, 20\n\t\tRename: \"'soundname$'_flow\"\n\n\t\t# Now extract the individual flow channels and delete the original\n\n\t\tselect Sound 'soundname$'_flow\n\t\tExtract all channels\n\t\tselect Sound 'soundname$'_flow\n\t\tRemove\n\n\t\tif naschannel = 1\n\t\t\tselect Sound 'soundname$'_flow_ch1\n\t\t\tRename: \"nasal_flow\"\n\t\t\tselect Sound 'soundname$'_flow_ch2\n\t\t\tRename: \"oral_flow\"\n\t\telse\n\t\t\tselect Sound 'soundname$'_flow_ch1\n\t\t\tRename: \"oral_flow\"\n\t\t\tselect Sound 'soundname$'_flow_ch2\n\t\t\tRename: \"nasal_flow\"\n\t\tendif\n\n\t\t# Process the oral flow to get standard deviations\n\t\tselect Sound oral_flow\n\t\tomax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\tosd = Get standard deviation: 1, 0,0\n\t\thalfosd = osd*0.01\n\t\t\n\t\t# Process the nasal flow to get standard deviations\n\t\tselect Sound nasal_flow\n\t\tnmax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\tnsd = Get standard deviation: 1, 0,0\n\t\thalfnsd = nsd*0.01\n\n\t\t####\n\t\t# Get %Nasalance\n\t\t####\n\n\t\tselect Sound nasal_flow\n\t\tdur = Get total duration\n\n\t\t# Basically take nasalflow / (oralflow+nasalflow), and don't calculate if nasality is stupidly small\n\n\t\tCreate Sound from formula: \"'soundname$'_nasalance\", 1, 0, 'dur', 44100, \"if (Sound_nasal_flow [col]) < 'halfnsd' then 0 else if (Sound_oral_flow [col]) < 'halfosd' then 0 else (Sound_nasal_flow [col])/((Sound_nasal_flow [col]) + (Sound_oral_flow [col])) endif endif\"\n\n\t\t# Percentages don't go higher than 1...\n\t\tFormula: \"if self > 1 then 1 else self endif\"\n\t\t\n\t\t###\n\t\t# Draw Pretty Pictures\n\t\t###\n\n\t\tLine width: 1\n\n\t\t# First paint the spectrogram for the flow chart\n\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\tErase all\n\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\n\t\tselect Sound 'soundname$'\n\t\tnoprogress To Spectrogram: 0.005, 5000, 0.005, 20, \"Hamming (raised sine-squared)\"\n\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\tselect TextGrid 'soundname$'\n\t\tBlack\n\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\tselect Spectrogram 'soundname$'\n\n\t\t# Make a second spectrogram for the scaled flows\n\t\tSelect outer viewport: 0, 9.5, 3, 6\n\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\tLine width: 1\n\t\tselect TextGrid 'soundname$'\n\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\tselect Spectrogram 'soundname$'\n\t\tif shownasalance\n\t\t\t# Make a third spectrogram for the %nasalance\n\t\t\tSelect outer viewport: 0, 9.5, 6, 9\n\t\t\tPaint: displaystart,displayend, 0, 0, 100, \"yes\", 50, 6, 0, \"no\"\n\t\t\tLine width: 1\n\t\t\tselect TextGrid 'soundname$'\n\t\t\tBlack\n\t\t\tDraw: displaystart, displayend, \"yes\", \"yes\", \"yes\"\n\t\t\tselect Spectrogram 'soundname$'\n\t\tendif\n\t\t\n\t\tselect Spectrogram 'soundname$'\n\t\tRemove\n\n\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\n\t\t\n\t\tLine width: 2\n\n\t\tRed\n\n\t\t\tselect Sound oral_flow\n\t\t\tomax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\t\tomin = Get minimum: displaystart,displayend, \"Sinc70\"\n\t\n\t\t\tselect Sound nasal_flow\n\t\t\tnmax = Get maximum: displaystart,displayend, \"Sinc70\"\n\t\t\tnmin = Get minimum: displaystart,displayend, \"Sinc70\"\n\t\n\t\t\tif omax > nmax\n\t\t\t\tomax = omax + (0.1*omax)\n\t\t\telse\n\t\t\t\tomax = nmax + (0.1*nmax)\n\t\t\tendif\n\t\t\tif omin < nmin\n\t\t\t\tomin = omin + (0.5*omin)\n\t\t\telse\n\t\t\t\tomin = nmin + (0.5*nmin)\n\t\t\tendif\n\t\n\t\t\tSelect outer viewport: 0, 9.5, 0, 3\n\t\t\tDraw inner box\n\t\t\tomin = omin \n\t\t\tselect Sound oral_flow\n\t\t\tDraw: displaystart,displayend, 'omin', 'omax', \"no\", \"Curve\"\n\t\t\tLine width: 2\n\t\t\tLime\n\t\t\tselect Sound nasal_flow\n\t\t\tDraw: displaystart,displayend, 'omin', 'omax', \"no\", \"Curve\"\n\t\t\tOne mark right: 0, \"no\", \"yes\", \"yes\", \"Zero\"\n\t\t\tText top: \"no\", \"Nasal (Green) vs. Acoustic (Red) signal\"\n\t\t\n\t\tLine width: 2\n\t\n\t\t\tselect Sound 'soundname$'_nasalance\n\t\tSelect outer viewport: 0, 9.5, 3, 6\n\t\t\tCyan\n\t\t\tDraw: displaystart,displayend, 0, 1, \"yes\", \"Curve\"\n\t\t\tOne mark left: 0.5, \"no\", \"yes\", \"yes\", \"50%\"\n\t\t\tText top: \"no\", \"Percent Nasalance over time (where both oral and nasal > 0)\"\n\t\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\tLine width: 1\n\t\tBlue\n\t\tselect Sound 'soundname$'\n\t\tSelect outer viewport: 0, 9.5, 6, 9\n\t\tText top: \"no\", \"Waveforms (Acoustic on Top, Nasal bud on Bottom)\"\n\t\tDraw: displaystart,displayend, 0, 0, \"yes\", \"Curve\"\n\t\tSelect outer viewport: 0, 9.5, 0, 9\n\t\t# Now save the file\n\t\tSave as 300-dpi PNG file: \"'directory$'_graphs/'soundname$'.png\"\n\t\t\n\t\t# Clean up a bit\n\t\tselectObject: \"Sound nasal_flow\"\n\t\tplusObject: \"Sound oral_flow\"\n\t\tCombine to stereo\n\t\tRename: \"'soundname$'_flow_pascal\"\n\t\tselectObject: \"Sound nasal_flow\"\n\t\tplusObject: \"Sound oral_flow\"\n\t\tRemove\n\t\t\n\t\t###\n\t\t# Extract the data to a file\n\t\t###\n\n\t\t\n\t\t# Calculate how large each jump is based on duration of vowel\n\t\tsize = intdur / (tpnum-1)\n\t\t\n\t\tfor point from 1 to tpnum\n\t\t\tif point = 1\n\t\t\t\ttimepoint = 'intstart'\n\t\t\telsif point = tpnum\n\t\t\t\ttimepoint = 'intend'\n\t\t\telse\n\t\t\t\ttimepoint = intstart + (size * (point-1))\n\t\t\tendif\n\t\t\tselectObject: \"Sound 'soundname$'_flow_pascal\"\n\t\t\tnaspasc = Get value at time: 1, 'timepoint', \"Nearest\"\n\t\t\torpasc = Get value at time: 2, 'timepoint', \"Nearest\"\n\t\t\t\n\t\t\tselectObject: \"Sound 'soundname$'_nasalance\"\n\t\t\tpercnas = Get value at time: 1, 'timepoint', \"Nearest\"\n\t\t\tvwlpct = ((timepoint-intstart)/intdur)*100\n\t\t\t\n\t\t\tresult_row$ = \"'soundname$'\" + tab$ + \"'point'\" + tab$ + \"'vwlpct:2'\" + tab$ + \"'naspasc:10'\" + tab$ + \"'orpasc:10'\" + tab$ + \"'percnas:5'\" + tab$ + \"'timepoint:4'\" + newline$\n\t\t\tfileappend \"'resultfile$'\" 'result_row$'\n\t\t\t\n\t\tendfor\n\telse\n\t\tselectObject: \"Sound 'soundname$'\"\n\t\tRemove\n\tendif\nendfor\nselect Strings list\nRemove\n\n# Version History\n# 1.0 - First release"], "filenames": ["file_segmenter.praat", "nasal_earbud_extract.praat"], "buggy_code_start_loc": [30, 248], "buggy_code_end_loc": [83, 249], "fixing_code_start_loc": [30, 248], "fixing_code_end_loc": [88, 249], "type": "CWE-404", "message": "A vulnerability was found in styler_praat_scripts. It has been classified as problematic. Affected is an unknown function of the file file_segmenter.praat of the component Slash Handler. The manipulation leads to denial of service. It is possible to launch the attack remotely. The name of the patch is 0cad44aa4a3eb0ecdba071c10eaff16023d8b35f. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216780.", "other": {"cve": {"id": "CVE-2021-4280", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-25T20:15:25.687", "lastModified": "2023-01-04T21:16:54.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in styler_praat_scripts. It has been classified as problematic. Affected is an unknown function of the file file_segmenter.praat of the component Slash Handler. The manipulation leads to denial of service. It is possible to launch the attack remotely. The name of the patch is 0cad44aa4a3eb0ecdba071c10eaff16023d8b35f. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216780."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:styler_praat_scripts_project:styler_praat_scripts:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-11-24", "matchCriteriaId": "C484B28D-560F-451F-9762-C7258E2EAE22"}]}]}], "references": [{"url": "https://github.com/stylerw/styler_praat_scripts/commit/0cad44aa4a3eb0ecdba071c10eaff16023d8b35f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216780", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216780", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stylerw/styler_praat_scripts/commit/0cad44aa4a3eb0ecdba071c10eaff16023d8b35f"}}