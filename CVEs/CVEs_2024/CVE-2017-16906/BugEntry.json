{"buggy_code": ["<?php\n/**\n * Kronolith_Event defines a generic API for events.\n *\n * Copyright 1999-2017 Horde LLC (http://www.horde.org/)\n *\n * See the enclosed file COPYING for license information (GPL). If you\n * did not receive this file, see http://www.horde.org/licenses/gpl.\n *\n * @author  Chuck Hagenbuch <chuck@horde.org>\n * @author  Jan Schneider <jan@horde.org>\n * @package Kronolith\n */\nabstract class Kronolith_Event\n{\n    /**\n     * Flag that is set to true if this event has data from either a storage\n     * backend or a form or other import method.\n     *\n     * @var boolean\n     */\n    public $initialized = false;\n\n    /**\n     * Flag that is set to true if this event exists in a storage driver.\n     *\n     * @var boolean\n     */\n    public $stored = false;\n\n    /**\n     * The driver unique identifier for this event.\n     *\n     * @var string\n     */\n    protected $_id = null;\n\n    /**\n     * The UID for this event.\n     *\n     * @var string\n     */\n    public $uid = null;\n\n    /**\n     * The iCalendar SEQUENCE for this event.\n     *\n     * @var integer\n     */\n    public $sequence = null;\n\n    /**\n     * The user id of the creator of the event.\n     *\n     * @var string\n     */\n    protected $_creator = null;\n\n    /**\n     * The title of this event.\n     *\n     * For displaying in the interface use getTitle() instead.\n     *\n     * @var string\n     */\n    public $title = '';\n\n    /**\n     * The location this event occurs at.\n     *\n     * @var string\n     */\n    public $location = '';\n\n    /**\n     * The timezone of this event.\n     *\n     * @var string\n     */\n    public $timezone;\n\n    /**\n     * The status of this event.\n     *\n     * @var integer\n     */\n    public $status = Kronolith::STATUS_CONFIRMED;\n\n    /**\n     * URL to an icon of this event.\n     *\n     * @var string\n     */\n    public $icon = '';\n\n    /**\n     * The description for this event.\n     *\n     * @var string\n     */\n    public $description = '';\n\n    /**\n     * URL of this event.\n     *\n     * @var string\n     */\n    public $url = '';\n\n    /**\n     * Whether the event is private.\n     *\n     * @var boolean\n     */\n    public $private = false;\n\n    /**\n     * Event tags from the storage backend (e.g. Kolab)\n     *\n     * @var array\n     */\n    protected $_internaltags;\n\n    /**\n     * This tag's events.\n     *\n     * @var array|string\n     */\n    protected $_tags = null;\n\n    /**\n     * Geolocation\n     *\n     * @var array\n     */\n    protected $_geoLocation;\n\n    /**\n     * Whether this is the event on the first day of a multi-day event.\n     *\n     * @var boolen\n     */\n    public $first = true;\n\n    /**\n     * Whether this is the event on the last day of a multi-day event.\n     *\n     * @var boolen\n     */\n    public $last = true;\n\n    /**\n     * All the attendees of this event.\n     *\n     * This is an associative array where the keys are the email addresses\n     * of the attendees, and the values are also associative arrays with\n     * keys 'attendance' and 'response' pointing to the attendees' attendance\n     * and response values, respectively.\n     *\n     * @var array\n     */\n    public $attendees = array();\n\n    /**\n     * All resources of this event.\n     *\n     * This is an associative array where keys are resource uids, values are\n     * associative arrays with keys attendance and response.\n     *\n     * @var array\n     */\n    protected $_resources = array();\n\n    /**\n     * The start time of the event.\n     *\n     * @var Horde_Date\n     */\n    public $start;\n\n    /**\n     * The end time of the event.\n     *\n     * @var Horde_Date\n     */\n    public $end;\n\n    /**\n     * The original start time of the event.\n     *\n     * This may differ from $start on multi-day events where $start is the\n     * start time on the current day. For recurring events this is the start\n     * time of the current recurrence.\n     *\n     * @var Horde_Date\n     */\n    protected $_originalStart;\n\n    /**\n     * The original end time of the event.\n     *\n     * @see $_originalStart for details.\n     *\n     * @var Horde_Date\n     */\n    protected $_originalEnd;\n\n    /**\n     * The duration of this event in minutes\n     *\n     * @var integer\n     */\n    public $durMin = 0;\n\n    /**\n     * Whether this is an all-day event.\n     *\n     * @var boolean\n     */\n    public $allday = false;\n\n    /**\n     * The creation time.\n     *\n     * @see loadHistory()\n     * @var Horde_Date\n     */\n    public $created;\n\n    /**\n     * The creator string.\n     *\n     * @see loadHistory()\n     * @var string\n     */\n    public $createdby;\n\n    /**\n     * The last modification time.\n     *\n     * @see loadHistory()\n     * @var Horde_Date\n     */\n    public $modified;\n\n    /**\n     * The last-modifier string.\n     *\n     * @see loadHistory()\n     * @var string\n     */\n    public $modifiedby;\n\n    /**\n     * Number of minutes before the event starts to trigger an alarm.\n     *\n     * @var integer\n     */\n    public $alarm = 0;\n\n    /**\n     * Snooze minutes for this event's alarm.\n     *\n     * @see Horde_Alarm::snooze()\n     *\n     * @var integer\n     */\n    protected $_snooze;\n\n    /**\n     * The particular alarm methods overridden for this event.\n     *\n     * @var array\n     */\n    public $methods;\n\n    /**\n     * The identifier of the calender this event exists on.\n     *\n     * @var string\n     */\n    public $calendar;\n\n    /**\n     * The type of the calender this event exists on.\n     *\n     * @var string\n     */\n    public $calendarType;\n\n    /**\n     * The HTML background color to be used for this event.\n     *\n     * @var string\n     */\n    protected $_backgroundColor = '#dddddd';\n\n    /**\n     * The HTML foreground color to be used for this event.\n     *\n     * @var string\n     */\n    protected $_foregroundColor = '#000000';\n\n    /**\n     * The VarRenderer class to use for printing select elements.\n     *\n     * @var Horde_Core_Ui_VarRenderer\n     */\n    private $_varRenderer;\n\n    /**\n     * The Horde_Date_Recurrence class for this event.\n     *\n     * @var Horde_Date_Recurrence\n     */\n    public $recurrence;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_overlap;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_indent;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_span;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_rowspan;\n\n    /**\n     * The baseid. For events that represent exceptions this is the UID of the\n     * original, recurring event.\n     *\n     * @var string\n     */\n    public $baseid;\n\n    /**\n     * For exceptions, the date of the original recurring event that this is an\n     * exception for.\n     *\n     * @var Horde_Date\n     */\n    public $exceptionoriginaldate;\n\n    /**\n     * The cached event duration, split up in time units.\n     *\n     * @see getDuration()\n     * @var stdClass\n     */\n    protected $_duration;\n\n    /**\n     * Constructor.\n     *\n     * @param Kronolith_Driver $driver  The backend driver that this event is\n     *                                  stored in.\n     * @param mixed $eventObject        Backend specific event object\n     *                                  that this will represent.\n     */\n    public function __construct(Kronolith_Driver $driver, $eventObject = null)\n    {\n        $this->calendar = $driver->calendar;\n        list($this->_backgroundColor, $this->_foregroundColor) = $driver->colors();\n\n        if (!is_null($eventObject)) {\n            $this->fromDriver($eventObject);\n        }\n    }\n\n    /**\n     * Retrieves history information for this event from the history backend.\n     */\n    public function loadHistory()\n    {\n        try {\n            $log = $GLOBALS['injector']->getInstance('Horde_History')\n                ->getHistory('kronolith:' . $this->calendar . ':' . $this->uid);\n            $userId = $GLOBALS['registry']->getAuth();\n            foreach ($log as $entry) {\n                switch ($entry['action']) {\n                case 'add':\n                    $this->created = new Horde_Date($entry['ts']);\n                    if ($userId != $entry['who']) {\n                        $this->createdby = sprintf(_(\"by %s\"), Kronolith::getUserName($entry['who']));\n                    } else {\n                        $this->createdby = _(\"by me\");\n                    }\n                    break;\n\n                case 'modify':\n                    if ($this->modified &&\n                        $this->modified->timestamp() >= $entry['ts']) {\n                        break;\n                    }\n                    $this->modified = new Horde_Date($entry['ts']);\n                    if ($userId != $entry['who']) {\n                        $this->modifiedby = sprintf(_(\"by %s\"), Kronolith::getUserName($entry['who']));\n                    } else {\n                        $this->modifiedby = _(\"by me\");\n                    }\n                    break;\n                }\n            }\n        } catch (Horde_Exception $e) {\n        }\n    }\n\n    /**\n     * Setter.\n     *\n     * Sets the 'id' and 'creator' properties.\n     *\n     * @param string $name  Property name.\n     * @param mixed $value  Property value.\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n        case 'id':\n            if (substr($value, 0, 10) == 'kronolith:') {\n                $value = substr($value, 10);\n            }\n            // Fall through.\n        case 'creator':\n        case 'geoLocation':\n        case 'indent':\n        case 'originalStart':\n        case 'originalEnd':\n        case 'overlap':\n        case 'rowspan':\n        case 'span':\n        case 'tags':\n            $this->{'_' . $name} = $value;\n            return;\n        }\n        $trace = debug_backtrace();\n        trigger_error('Undefined property via __set(): ' . $name\n                      . ' in ' . $trace[0]['file']\n                      . ' on line ' . $trace[0]['line'],\n                      E_USER_NOTICE);\n    }\n\n    /**\n     * Getter.\n     *\n     * Returns the 'id' and 'creator' properties.\n     *\n     * @param string $name  Property name.\n     *\n     * @return mixed  Property value.\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n        case 'id':\n        case 'indent':\n        case 'overlap':\n        case 'rowspan':\n        case 'span':\n            return $this->{'_' . $name};\n        case 'creator':\n            if (empty($this->_creator)) {\n                $this->_creator = $GLOBALS['registry']->getAuth();\n            }\n            return $this->_creator;\n            break;\n        case 'originalStart':\n            if (empty($this->_originalStart)) {\n                $this->_originalStart = $this->start;\n            }\n            return $this->_originalStart;\n            break;\n        case 'originalEnd':\n            if (empty($this->_originalEnd)) {\n                $this->_originalEnd = $this->start;\n            }\n            return $this->_originalEnd;\n            break;\n        case 'tags':\n            if (!isset($this->_tags)) {\n                $this->synchronizeTags(Kronolith::getTagger()->getTags($this->uid, Kronolith_Tagger::TYPE_EVENT));\n            }\n            return $this->_tags;\n        case 'geoLocation':\n            if (!isset($this->_geoLocation)) {\n                try {\n                    $this->_geoLocation = $GLOBALS['injector']->getInstance('Kronolith_Geo')->getLocation($this->id);\n                } catch (Kronolith_Exception $e) {}\n            }\n            return $this->_geoLocation;\n        }\n\n        $trace = debug_backtrace();\n        trigger_error('Undefined property via __set(): ' . $name\n                      . ' in ' . $trace[0]['file']\n                      . ' on line ' . $trace[0]['line'],\n                      E_USER_NOTICE);\n        return null;\n    }\n\n    /**\n     * Returns a reference to a driver that's valid for this event.\n     *\n     * @return Kronolith_Driver  A driver that this event can use to save\n     *                           itself, etc.\n     */\n    public function getDriver()\n    {\n        return Kronolith::getDriver(str_replace('Kronolith_Event_', '', get_class($this)), $this->calendar);\n    }\n\n    /**\n     * Returns the share this event belongs to.\n     *\n     * @return Horde_Share  This event's share.\n     * @throws Kronolith_Exception\n     */\n    public function getShare()\n    {\n        if ($GLOBALS['calendar_manager']->getEntry(Kronolith::ALL_CALENDARS, $this->calendar) !== false) {\n            return $GLOBALS['calendar_manager']->getEntry(Kronolith::ALL_CALENDARS, $this->calendar)->share();\n        }\n        throw new LogicException('Share not found');\n    }\n\n    /**\n     * Encapsulates permissions checking.\n     *\n     * @param integer $permission  The permission to check for.\n     * @param string $user         The user to check permissions for.\n     *\n     * @return boolean\n     */\n    public function hasPermission($permission, $user = null)\n    {\n        if ($user === null) {\n            $user = $GLOBALS['registry']->getAuth();\n        }\n        try {\n            $share = $this->getShare();\n        } catch (Exception $e) {\n            return false;\n        }\n        return $share->hasPermission($user, $permission, $this->creator);\n    }\n\n    /**\n     * Saves changes to this event.\n     *\n     * @return integer  The event id.\n     * @throws Kronolith_Exception\n     */\n    public function save()\n    {\n        if (!$this->initialized) {\n            throw new LogicException('Event not yet initialized');\n        }\n\n        /* Check for acceptance/denial of this event's resources. */\n        $accepted_resources = array();\n        $locks = $GLOBALS['injector']->getInstance('Horde_Lock');\n        $lock = array();\n        // Don't waste time with resource acceptance if the status is cancelled,\n        // the event will be removed from the resource calendar anyway.\n        if ($this->status != Kronolith::STATUS_CANCELLED) {\n            foreach (array_keys($this->getResources()) as $id) {\n                /* Get the resource and protect against infinite recursion in\n                 * case someone is silly enough to add a resource to it's own\n                 * event.*/\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                $rcal = $resource->get('calendar');\n                if ($rcal == $this->calendar) {\n                    continue;\n                }\n                Kronolith::getDriver('Resource')->open($rcal);\n\n                /* Lock the resource and get the response */\n                if ($resource->get('response_type') == Kronolith_Resource::RESPONSETYPE_AUTO) {\n                    $principle = 'calendar/' . $rcal;\n                    $lock[$resource->getId()] = $locks->setLock($GLOBALS['registry']->getAuth(), 'kronolith', $principle, 5, Horde_Lock::TYPE_EXCLUSIVE);\n                    $haveLock = true;\n                } else {\n                    $haveLock = false;\n                }\n                if ($haveLock && !$lock[$resource->getId()]) {\n                    // Already locked\n                    // For now, just fail. Not sure how else to capture the\n                    // locked resources and notify the user.\n                    throw new Kronolith_Exception(sprintf(_(\"The resource \\\"%s\\\" was locked. Please try again.\"), $resource->get('name')));\n                } else {\n                    $response = $resource->getResponse($this);\n                }\n\n                /* Remember accepted resources so we can add the event to their\n                 * calendars. Otherwise, clear the lock. */\n                if ($response == Kronolith::RESPONSE_ACCEPTED) {\n                    $accepted_resources[] = $resource;\n                } elseif ($haveLock) {\n                    $locks->clearLock($lock[$resource->getId()]);\n                }\n\n                if ($response == Kronolith::RESPONSE_DECLINED && $this->uid) {\n                    $r_driver = Kronolith::getDriver('Resource');\n                    $r_event = $r_driver->getByUID($this->uid, array($resource->get('calendar')));\n                    $r_driver->deleteEvent($r_event, true, true);\n                }\n\n                /* Add the resource to the event */\n                $this->addResource($resource, $response);\n            }\n        } else {\n            // If event is cancelled, and actually exists, we need to mark it\n            // as cancelled in resource calendar.\n            foreach (array_keys($this->getResources()) as $id) {\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                $rcal = $resource->get('calendar');\n                if ($rcal == $this->calendar) {\n                    continue;\n                }\n                try {\n                    Kronolith::getDriver('Resource')->open($rcal);\n                    $resource->addEvent($this);\n                } catch (Exception $e) {\n                }\n            }\n        }\n\n        /* Save */\n        $result = $this->getDriver()->saveEvent($this);\n\n        /* Now that the event is definitely commited to storage, we can add\n         * the event to each resource that has accepted. Not very efficient,\n         * but this also solves the problem of not having a GUID for the event\n         * until after it's saved. If we add the event to the resources\n         * calendar before it is saved, they will have different GUIDs, and\n         * hence no longer refer to the same event. */\n        foreach ($accepted_resources as $resource) {\n            $resource->addEvent($this);\n            if ($resource->get('response_type') == Kronolith_Resource::RESPONSETYPE_AUTO) {\n                $locks->clearLock($lock[$resource->getId()]);\n            }\n        }\n\n        $hordeAlarm = $GLOBALS['injector']->getInstance('Horde_Alarm');\n        if ($alarm = $this->toAlarm(new Horde_Date($_SERVER['REQUEST_TIME']))) {\n            $hordeAlarm->set($alarm);\n            if ($this->_snooze) {\n                $hordeAlarm->snooze($this->uid, $GLOBALS['registry']->getAuth(), $this->_snooze);\n            }\n        } else {\n            $hordeAlarm->delete($this->uid);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Imports a backend specific event object.\n     *\n     * @param mixed $eventObject  Backend specific event object that this\n     *                            object will represent.\n     */\n    public function fromDriver($event)\n    {\n    }\n\n    /**\n     * Exports this event in iCalendar format.\n     *\n     * @param Horde_Icalendar $calendar  A Horde_Icalendar object that acts as\n     *                                   a container.\n     *\n     * @return array  An array of Horde_Icalendar_Vevent objects for this event.\n     */\n    public function toiCalendar($calendar)\n    {\n        $vEvent = Horde_Icalendar::newComponent('vevent', $calendar);\n        $v1 = $calendar->getAttribute('VERSION') == '1.0';\n        $vEvents = array();\n\n        // For certain recur types, we must output in the event's timezone\n        // so that the BYDAY values do not get out of sync with the UTC\n        // date-time. See Bug: 11339\n        if ($this->recurs()) {\n            switch ($this->recurrence->getRecurType()) {\n            case Horde_Date_Recurrence::RECUR_WEEKLY:\n            case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n                if (!$this->timezone) {\n                    $this->timezone = date_default_timezone_get();\n                }\n            }\n        }\n\n        if ($this->isAllDay()) {\n            $vEvent->setAttribute('DTSTART', $this->start, array('VALUE' => 'DATE'));\n            $vEvent->setAttribute('DTEND', $this->end, array('VALUE' => 'DATE'));\n            $vEvent->setAttribute('X-FUNAMBOL-ALLDAY', 1);\n        } else {\n            $this->setTimezone(true);\n            $params = array();\n            if ($this->timezone) {\n                try {\n                    if (!$this->baseid) {\n                        $tz = $GLOBALS['injector']->getInstance('Horde_Timezone');\n                        $vEvents[] = $tz->getZone($this->timezone)->toVtimezone();\n                    }\n                    $params['TZID'] = $this->timezone;\n                } catch (Horde_Exception $e) {\n                    Horde::log('Unable to locate the tz database.', 'WARN');\n                }\n            }\n\n            $vEvent->setAttribute('DTSTART', clone $this->start, $params);\n            $vEvent->setAttribute('DTEND', clone $this->end, $params);\n        }\n\n        $vEvent->setAttribute('DTSTAMP', $_SERVER['REQUEST_TIME']);\n        $vEvent->setAttribute('UID', $this->uid);\n\n        /* Get the event's create and last modify date. */\n        $created = $modified = null;\n        try {\n            $history = $GLOBALS['injector']->getInstance('Horde_History');\n            $created = $history->getActionTimestamp(\n                'kronolith:' . $this->calendar . ':' . $this->uid, 'add');\n            $modified = $history->getActionTimestamp(\n                'kronolith:' . $this->calendar . ':' . $this->uid, 'modify');\n            /* The history driver returns 0 for not found. If 0 or null does\n             * not matter, strip this. */\n            if ($created == 0) {\n                $created = null;\n            }\n            if ($modified == 0) {\n                $modified = null;\n            }\n        } catch (Exception $e) {\n        }\n        if (!empty($created)) {\n            $vEvent->setAttribute($v1 ? 'DCREATED' : 'CREATED', $created);\n            if (empty($modified)) {\n                $modified = $created;\n            }\n        }\n        if (!empty($modified)) {\n            $vEvent->setAttribute('LAST-MODIFIED', $modified);\n        }\n\n        $vEvent->setAttribute('SUMMARY', $this->getTitle());\n\n        // Organizer\n        if (count($this->attendees)) {\n            $name = Kronolith::getUserName($this->creator);\n            $email = Kronolith::getUserEmail($this->creator);\n            $params = array();\n            if ($v1) {\n                $tmp = new Horde_Mail_Rfc822_Address($email);\n                if (!empty($name)) {\n                    $tmp->personal = $name;\n                }\n                $email = strval($tmp);\n            } else {\n                if (!empty($name)) {\n                    $params['CN'] = $name;\n                }\n                if (!empty($email)) {\n                    $email = 'mailto:' . $email;\n                }\n            }\n            $vEvent->setAttribute('ORGANIZER', $email, $params);\n        }\n        if (!$this->isPrivate()) {\n            if (!empty($this->description)) {\n                $vEvent->setAttribute('DESCRIPTION', $this->description);\n            }\n\n            // Tags\n            if ($this->tags) {\n                $vEvent->setAttribute('CATEGORIES', '', array(), true, array_values($this->tags));\n            }\n\n            // Location\n            if (!empty($this->location)) {\n                $vEvent->setAttribute('LOCATION', $this->location);\n            }\n            if ($this->geoLocation) {\n                $vEvent->setAttribute('GEO', array('latitude' => $this->geoLocation['lat'], 'longitude' => $this->geoLocation['lon']));\n            }\n\n            // URL\n            if (!empty($this->url)) {\n                $vEvent->setAttribute('URL', $this->url);\n            }\n        }\n        $vEvent->setAttribute('CLASS', $this->private ? 'PRIVATE' : 'PUBLIC');\n\n        // Status.\n        switch ($this->status) {\n        case Kronolith::STATUS_FREE:\n            // This is not an official iCalendar value, but we need it for\n            // synchronization.\n            $vEvent->setAttribute('STATUS', 'FREE');\n            $vEvent->setAttribute('TRANSP', $v1 ? 1 : 'TRANSPARENT');\n            break;\n        case Kronolith::STATUS_TENTATIVE:\n            $vEvent->setAttribute('STATUS', 'TENTATIVE');\n            $vEvent->setAttribute('TRANSP', $v1 ? 0 : 'OPAQUE');\n            break;\n        case Kronolith::STATUS_CONFIRMED:\n            $vEvent->setAttribute('STATUS', 'CONFIRMED');\n            $vEvent->setAttribute('TRANSP', $v1 ? 0 : 'OPAQUE');\n            break;\n        case Kronolith::STATUS_CANCELLED:\n            if ($v1) {\n                $vEvent->setAttribute('STATUS', 'DECLINED');\n                $vEvent->setAttribute('TRANSP', 1);\n            } else {\n                $vEvent->setAttribute('STATUS', 'CANCELLED');\n                $vEvent->setAttribute('TRANSP', 'TRANSPARENT');\n            }\n            break;\n        }\n\n        // Attendees.\n        foreach ($this->attendees as $email => $status) {\n            $params = array();\n            switch ($status['attendance']) {\n            case Kronolith::PART_REQUIRED:\n                if ($v1) {\n                    $params['EXPECT'] = 'REQUIRE';\n                } else {\n                    $params['ROLE'] = 'REQ-PARTICIPANT';\n                }\n                break;\n\n            case Kronolith::PART_OPTIONAL:\n                if ($v1) {\n                    $params['EXPECT'] = 'REQUEST';\n                } else {\n                    $params['ROLE'] = 'OPT-PARTICIPANT';\n                }\n                break;\n\n            case Kronolith::PART_NONE:\n                if ($v1) {\n                    $params['EXPECT'] = 'FYI';\n                } else {\n                    $params['ROLE'] = 'NON-PARTICIPANT';\n                }\n                break;\n            }\n\n            switch ($status['response']) {\n            case Kronolith::RESPONSE_NONE:\n                if ($v1) {\n                    $params['STATUS'] = 'NEEDS ACTION';\n                    $params['RSVP'] = 'YES';\n                } else {\n                    $params['PARTSTAT'] = 'NEEDS-ACTION';\n                    $params['RSVP'] = 'TRUE';\n                }\n                break;\n\n            case Kronolith::RESPONSE_ACCEPTED:\n                if ($v1) {\n                    $params['STATUS'] = 'ACCEPTED';\n                } else {\n                    $params['PARTSTAT'] = 'ACCEPTED';\n                }\n                break;\n\n            case Kronolith::RESPONSE_DECLINED:\n                if ($v1) {\n                    $params['STATUS'] = 'DECLINED';\n                } else {\n                    $params['PARTSTAT'] = 'DECLINED';\n                }\n                break;\n\n            case Kronolith::RESPONSE_TENTATIVE:\n                if ($v1) {\n                    $params['STATUS'] = 'TENTATIVE';\n                } else {\n                    $params['PARTSTAT'] = 'TENTATIVE';\n                }\n                break;\n            }\n\n            if (strpos($email, '@') === false) {\n                $email = '';\n            }\n            if ($v1) {\n                if (empty($email)) {\n                    if (!empty($status['name'])) {\n                        $email = $status['name'];\n                    }\n                } else {\n                    $tmp = new Horde_Mail_Rfc822_Address($email);\n                    if (!empty($status['name'])) {\n                        $tmp->personal = $status['name'];\n                    }\n                    $email = strval($tmp);\n                }\n            } else {\n                if (!empty($status['name'])) {\n                    $params['CN'] = $status['name'];\n                }\n                if (!empty($email)) {\n                    $email = 'mailto:' . $email;\n                }\n            }\n\n            $vEvent->setAttribute('ATTENDEE', $email, $params);\n        }\n\n        // Alarms.\n        if (!empty($this->alarm)) {\n            if ($v1) {\n                $alarm = new Horde_Date($this->start);\n                $alarm->min -= $this->alarm;\n                $vEvent->setAttribute('AALARM', $alarm);\n            } else {\n                $vAlarm = Horde_Icalendar::newComponent('valarm', $vEvent);\n                $vAlarm->setAttribute('ACTION', 'DISPLAY');\n                $vAlarm->setAttribute('DESCRIPTION', $this->getTitle());\n                $vAlarm->setAttribute(\n                    'TRIGGER;VALUE=DURATION',\n                    ($this->alarm > 0 ? '-' : '') . 'PT' . abs($this->alarm) . 'M'\n                );\n                $vEvent->addComponent($vAlarm);\n            }\n            $hordeAlarm = $GLOBALS['injector']->getInstance('Horde_Alarm');\n            if ($hordeAlarm->exists($this->uid, $GLOBALS['registry']->getAuth()) &&\n                $hordeAlarm->isSnoozed($this->uid, $GLOBALS['registry']->getAuth())) {\n                $vEvent->setAttribute('X-MOZ-LASTACK', new Horde_Date($_SERVER['REQUEST_TIME']));\n                $alarm = $hordeAlarm->get($this->uid, $GLOBALS['registry']->getAuth());\n                if (!empty($alarm['snooze'])) {\n                    $alarm['snooze']->setTimezone(date_default_timezone_get());\n                    $vEvent->setAttribute('X-MOZ-SNOOZE-TIME', $alarm['snooze']);\n                }\n            }\n        }\n\n        // Recurrence.\n        if ($this->recurs()) {\n            if ($v1) {\n                $rrule = $this->recurrence->toRRule10($calendar);\n            } else {\n                $rrule = $this->recurrence->toRRule20($calendar);\n            }\n            if (!empty($rrule)) {\n                $vEvent->setAttribute('RRULE', $rrule);\n            }\n\n            // Exceptions. An exception with no replacement event is represented\n            // by EXDATE, and those with replacement events are represented by\n            // a new vEvent element. We get all known replacement events first,\n            // then remove the exceptionoriginaldate from the list of the event\n            // exceptions. Any exceptions left should represent exceptions with\n            // no replacement.\n            $exceptions = $this->recurrence->getExceptions();\n            $search = new stdClass();\n            $search->baseid = $this->uid;\n            $results = $this->getDriver()->search($search);\n            foreach ($results as $days) {\n                foreach ($days as $exceptionEvent) {\n                    // Need to change the UID so it links to the original\n                    // recurring event, but only if not using $v1. If using $v1,\n                    // we add the date to EXDATE and do NOT change the UID.\n                    if (!$v1) {\n                        $exceptionEvent->uid = $this->uid;\n                    }\n                    $vEventException = $exceptionEvent->toiCalendar($calendar);\n\n                    // This should never happen, but protect against it anyway.\n                    if (count($vEventException) > 2 ||\n                        (count($vEventException) > 1 &&\n                         !($vEventException[0] instanceof Horde_Icalendar_Vtimezone) &&\n                         !($vEventException[1] instanceof Horde_Icalendar_Vtimezone))) {\n                        throw new Kronolith_Exception(_(\"Unable to parse event.\"));\n                    }\n                    $vEventException = array_pop($vEventException);\n                    // If $v1, need to add to EXDATE\n                    if (!$this->isAllDay()) {\n                        $exceptionEvent->setTimezone(true);\n                    }\n                    if (!$v1) {\n                        $vEventException->setAttribute('RECURRENCE-ID', $exceptionEvent->exceptionoriginaldate);\n                    } else {\n                        $vEvent->setAttribute('EXDATE', array($exceptionEvent->exceptionoriginaldate), array('VALUE' => 'DATE'));\n                    }\n                    $originaldate = $exceptionEvent->exceptionoriginaldate->format('Ymd');\n                    $key = array_search($originaldate, $exceptions);\n                    if ($key !== false) {\n                        unset($exceptions[$key]);\n                    }\n                    $vEvents[] = $vEventException;\n                }\n            }\n\n            /* The remaining exceptions represent deleted recurrences */\n            foreach ($exceptions as $exception) {\n                if (!empty($exception)) {\n                    // Use multiple EXDATE attributes instead of EXDATE\n                    // attributes with multiple values to make Apple iCal\n                    // happy.\n                    list($year, $month, $mday) = sscanf($exception, '%04d%02d%02d');\n                    if ($this->isAllDay()) {\n                        $vEvent->setAttribute('EXDATE', array(new Horde_Date($year, $month, $mday)), array('VALUE' => 'DATE'));\n                    } else {\n                        // Another Apple iCal/Calendar fix. EXDATE is only\n                        // recognized if the full datetime is present and matches\n                        // the time part given in DTSTART.\n                        $params = array();\n                        if ($this->timezone) {\n                            $params['TZID'] = $this->timezone;\n                        }\n                        $exdate = clone $this->start;\n                        $exdate->year = $year;\n                        $exdate->month = $month;\n                        $exdate->mday = $mday;\n                        $vEvent->setAttribute('EXDATE', array($exdate), $params);\n                    }\n                }\n            }\n        }\n        array_unshift($vEvents, $vEvent);\n\n        $this->setTimezone(false);\n\n        return $vEvents;\n    }\n\n    /**\n     * Updates the properties of this event from a Horde_Icalendar_Vevent\n     * object.\n     *\n     * @param Horde_Icalendar_Vevent $vEvent  The iCalendar data to update\n     *                                        from.\n     * @param boolean $parseAttendees         Parse attendees too?\n     *                                        @since Kronolith 4.2\n     */\n    public function fromiCalendar($vEvent, $parseAttendees = false)\n    {\n        // Unique ID.\n        try {\n            $uid = $vEvent->getAttribute('UID');\n            if (!empty($uid)) {\n                $this->uid = $uid;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Sequence.\n        try {\n            $seq = $vEvent->getAttribute('SEQUENCE');\n            if (is_int($seq)) {\n                $this->sequence = $seq;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Title, tags and description.\n        try {\n            $title = $this->_ensureUtf8($vEvent->getAttribute('SUMMARY'));\n            if (!is_array($title)) {\n                $this->title = $title;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Tags\n        try {\n            $this->_tags = $vEvent->getAttributeValues('CATEGORIES');\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Description\n        try {\n            $desc = $this->_ensureUtf8($vEvent->getAttribute('DESCRIPTION'));\n            if (!is_array($desc)) {\n                $this->description = $desc;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Remote Url\n        try {\n            $url = $vEvent->getAttribute('URL');\n            if (!is_array($url)) {\n                $this->url = $url;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Location\n        try {\n            $location = $this->_ensureUtf8($vEvent->getAttribute('LOCATION'));\n            if (!is_array($location)) {\n                $this->location = $location;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        try {\n            $geolocation = $vEvent->getAttribute('GEO');\n            $this->geoLocation = array(\n                'lat' => $geolocation['latitude'],\n                'lon' => $geolocation['longitude']\n            );\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Class\n        try {\n            $class = $vEvent->getAttribute('CLASS');\n            if (!is_array($class)) {\n                $class = Horde_String::upper($class);\n                $this->private = $class == 'PRIVATE' || $class == 'CONFIDENTIAL';\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Status.\n        try {\n            $status = $vEvent->getAttribute('STATUS');\n            if (!is_array($status)) {\n                $status = Horde_String::upper($status);\n                if ($status == 'DECLINED') {\n                    $status = 'CANCELLED';\n                }\n                if (defined('Kronolith::STATUS_' . $status)) {\n                    $this->status = constant('Kronolith::STATUS_' . $status);\n                }\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Reset allday flag in case this has changed. Will be recalculated\n        // next time isAllDay() is called.\n        $this->allday = false;\n\n        // Start and end date.\n        $tzid = null;\n        try {\n            $start = $vEvent->getAttribute('DTSTART');\n            $startParams = $vEvent->getAttribute('DTSTART', true);\n            // We don't support different timezones for different attributes,\n            // so use the DTSTART timezone for the complete event.\n            if (isset($startParams[0]['TZID'])) {\n                // Horde_Date supports timezone aliases, so try that first.\n                $tz = $startParams[0]['TZID'];\n                try {\n                    // Check if the timezone name is supported by PHP natively.\n                    new DateTimeZone($tz);\n                    $this->timezone = $tzid = $tz;\n                } catch (Exception $e) {\n                }\n            }\n            if (!is_array($start)) {\n                // Date-Time field\n                $this->start = new Horde_Date($start, $tzid);\n            } else {\n                // Date field\n                $this->start = new Horde_Date(\n                    array('year'  => (int)$start['year'],\n                          'month' => (int)$start['month'],\n                          'mday'  => (int)$start['mday']),\n                    $tzid\n                );\n            }\n        } catch (Horde_Icalendar_Exception $e) {\n            throw new Kronolith_Exception($e);\n        } catch (Horde_Date_Exception $e) {\n            throw new Kronolith_Exception($e);\n        }\n\n        try {\n            $end = $vEvent->getAttribute('DTEND');\n            if (!is_array($end)) {\n                // Date-Time field\n                $this->end = new Horde_Date($end, $tzid);\n                // All day events are transferred by many device as\n                // DSTART: YYYYMMDDT000000 DTEND: YYYYMMDDT2359(59|00)\n                // Convert accordingly\n                if (is_object($this->start) && $this->start->hour == 0 &&\n                    $this->start->min == 0 && $this->start->sec == 0 &&\n                    $this->end->hour == 23 && $this->end->min == 59) {\n                    $this->end = new Horde_Date(\n                        array('year'  => (int)$this->end->year,\n                              'month' => (int)$this->end->month,\n                              'mday'  => (int)$this->end->mday + 1),\n                        $tzid);\n                }\n            } else {\n                // Date field\n                $this->end = new Horde_Date(\n                    array('year'  => (int)$end['year'],\n                          'month' => (int)$end['month'],\n                          'mday'  => (int)$end['mday']),\n                    $tzid);\n            }\n        } catch (Horde_Icalendar_Exception $e) {\n            $end = null;\n        }\n\n        if (is_null($end)) {\n            try {\n                $duration = $vEvent->getAttribute('DURATION');\n                if (!is_array($duration)) {\n                    $this->end = new Horde_Date($this->start);\n                    $this->end->sec += $duration;\n                    $end = 1;\n                }\n            } catch (Horde_Icalendar_Exception $e) {}\n\n            if (is_null($end)) {\n                // End date equal to start date as per RFC 2445.\n                $this->end = new Horde_Date($this->start);\n                if (is_array($start)) {\n                    // Date field\n                    $this->end->mday++;\n                }\n            }\n        }\n\n        // vCalendar 1.0 alarms\n        try {\n            $alarm = $vEvent->getAttribute('AALARM');\n            if (!is_array($alarm) && intval($alarm)) {\n                $this->alarm = intval(($this->start->timestamp() - $alarm) / 60);\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // vCalendar 2.0 alarms\n        foreach ($vEvent->getComponents() as $alarm) {\n            if (!($alarm instanceof Horde_Icalendar_Valarm)) {\n                continue;\n            }\n            try {\n                if ($alarm->getAttribute('ACTION') == 'NONE') {\n                    continue;\n                }\n            } catch (Horde_Icalendar_Exception $e) {\n            }\n            try {\n                // @todo consider implementing different ACTION types.\n                // $action = $alarm->getAttribute('ACTION');\n                $trigger = $alarm->getAttribute('TRIGGER');\n                $triggerParams = $alarm->getAttribute('TRIGGER', true);\n            } catch (Horde_Icalendar_Exception $e) {\n                continue;\n            }\n            if (!is_array($triggerParams)) {\n                $triggerParams = array($triggerParams);\n            }\n            $haveTrigger = false;\n            foreach ($triggerParams as $tp) {\n                if (isset($tp['VALUE']) &&\n                    $tp['VALUE'] == 'DATE-TIME') {\n                    if (isset($tp['RELATED']) &&\n                        $tp['RELATED'] == 'END') {\n                        $this->alarm = intval(($this->end->timestamp() - $trigger) / 60);\n                    } else {\n                        $this->alarm = intval(($this->start->timestamp() - $trigger) / 60);\n                    }\n                    $haveTrigger = true;\n                    break;\n                } elseif (isset($tp['RELATED']) && $tp['RELATED'] == 'END') {\n                    $this->alarm = -intval($trigger / 60);\n                    $this->alarm -= $this->durMin;\n                    $haveTrigger = true;\n                    break;\n                }\n            }\n            if (!$haveTrigger) {\n                $this->alarm = -intval($trigger / 60);\n            }\n            break;\n        }\n\n        // Alarm snoozing/dismissal\n        if ($this->alarm) {\n            try {\n                // If X-MOZ-LASTACK is set, this event is either dismissed or\n                // snoozed.\n                $vEvent->getAttribute('X-MOZ-LASTACK');\n                try {\n                    // If X-MOZ-SNOOZE-TIME is set, this event is snoozed.\n                    $snooze = $vEvent->getAttribute('X-MOZ-SNOOZE-TIME');\n                    $this->_snooze = intval(($snooze - time()) / 60);\n                } catch (Horde_Icalendar_Exception $e) {\n                    // If X-MOZ-SNOOZE-TIME is not set, this event is dismissed.\n                    $this->_snooze = -1;\n                }\n            } catch (Horde_Icalendar_Exception $e) {\n            }\n        }\n\n        // Attendance.\n        // Importing attendance may result in confusion: editing an imported\n        // copy of an event can cause invitation updates to be sent from\n        // people other than the original organizer. So we don't import by\n        // default. However to allow updates by synchronization, this behavior\n        // can be overriden.\n        // X-ATTENDEE is there for historical reasons. @todo remove in\n        // Kronolith 5.\n        $attendee = null;\n        if ($parseAttendees) {\n            try {\n                $attendee = $vEvent->getAttribute('ATTENDEE');\n                $params = $vEvent->getAttribute('ATTENDEE', true);\n            } catch (Horde_Icalendar_Exception $e) {\n                try {\n                    $attendee = $vEvent->getAttribute('X-ATTENDEE');\n                    $params = $vEvent->getAttribute('X-ATTENDEE', true);\n                } catch (Horde_Icalendar_Exception $e) {\n                }\n            }\n        }\n        if ($attendee) {\n            if (!is_array($attendee)) {\n                $attendee = array($attendee);\n            }\n            if (!is_array($params)) {\n                $params = array($params);\n            }\n            // Clear the attendees since we might be editing/replacing the event\n            $this->attendees = array();\n            for ($i = 0; $i < count($attendee); ++$i) {\n                $attendee[$i] = str_replace(array('MAILTO:', 'mailto:'), '',\n                                            $attendee[$i]);\n                $tmp = new Horde_Mail_Rfc822_Address($attendee[$i]);\n                $email = $tmp->bare_address;\n                // Default according to rfc2445:\n                $attendance = Kronolith::PART_REQUIRED;\n                // vCalendar 2.0 style:\n                if (!empty($params[$i]['ROLE'])) {\n                    switch($params[$i]['ROLE']) {\n                    case 'OPT-PARTICIPANT':\n                        $attendance = Kronolith::PART_OPTIONAL;\n                        break;\n\n                    case 'NON-PARTICIPANT':\n                        $attendance = Kronolith::PART_NONE;\n                        break;\n                    }\n                }\n                // vCalendar 1.0 style;\n                if (!empty($params[$i]['EXPECT'])) {\n                    switch($params[$i]['EXPECT']) {\n                    case 'REQUEST':\n                        $attendance = Kronolith::PART_OPTIONAL;\n                        break;\n\n                    case 'FYI':\n                        $attendance = Kronolith::PART_NONE;\n                        break;\n                    }\n                }\n                $response = Kronolith::RESPONSE_NONE;\n                if (empty($params[$i]['PARTSTAT']) &&\n                    !empty($params[$i]['STATUS'])) {\n                    $params[$i]['PARTSTAT']  = $params[$i]['STATUS'];\n                }\n\n                if (!empty($params[$i]['PARTSTAT'])) {\n                    switch($params[$i]['PARTSTAT']) {\n                    case 'ACCEPTED':\n                        $response = Kronolith::RESPONSE_ACCEPTED;\n                        break;\n\n                    case 'DECLINED':\n                        $response = Kronolith::RESPONSE_DECLINED;\n                        break;\n\n                    case 'TENTATIVE':\n                        $response = Kronolith::RESPONSE_TENTATIVE;\n                        break;\n                    }\n                }\n                $name = isset($params[$i]['CN'])\n                    ? $this->_ensureUtf8($params[$i]['CN'])\n                    : null;\n\n                $this->addAttendee($email, $attendance, $response, $name);\n            }\n        }\n\n        $this->_handlevEventRecurrence($vEvent);\n\n        $this->initialized = true;\n    }\n\n    /**\n     * Handle parsing recurrence related fields.\n     *\n     * @param Horde_Icalendar $vEvent\n     * @throws Kronolith_Exception\n     */\n    protected function _handlevEventRecurrence($vEvent)\n    {\n        // Recurrence.\n        try {\n            $rrule = $vEvent->getAttribute('RRULE');\n            if (!is_array($rrule)) {\n                $this->recurrence = new Horde_Date_Recurrence($this->start);\n                if (strpos($rrule, '=') !== false) {\n                    $this->recurrence->fromRRule20($rrule);\n                } else {\n                    $this->recurrence->fromRRule10($rrule);\n                }\n\n                // Exceptions. EXDATE represents deleted events, just add the\n                // exception, no new event is needed.\n                $exdates = $vEvent->getAttributeValues('EXDATE');\n                if (is_array($exdates)) {\n                    foreach ($exdates as $exdate) {\n                        if (is_array($exdate)) {\n                            $this->recurrence->addException(\n                                (int)$exdate['year'],\n                                (int)$exdate['month'],\n                                (int)$exdate['mday']);\n                        }\n                    }\n                }\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // RECURRENCE-ID indicates that this event represents an exception\n        try {\n            $recurrenceid = $vEvent->getAttribute('RECURRENCE-ID');\n            $originaldt = new Horde_Date($recurrenceid);\n            $this->exceptionoriginaldate = $originaldt;\n            $this->baseid = $this->uid;\n            $this->uid = null;\n            try {\n                $originalEvent = $this->getDriver()->getByUID($this->baseid);\n                if ($originalEvent->recurrence) {\n                    $originalEvent->recurrence->addException(\n                        $originaldt->format('Y'),\n                        $originaldt->format('m'),\n                        $originaldt->format('d')\n                    );\n                    $originalEvent->save();\n                }\n            } catch (Horde_Exception_NotFound $e) {\n                throw new Kronolith_Exception(_(\"Unable to locate original event series.\"));\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n    }\n\n    /**\n     * Imports the values for this event from a MS ActiveSync Message.\n     *\n     * @see Horde_ActiveSync_Message_Appointment\n     */\n    public function fromASAppointment(Horde_ActiveSync_Message_Appointment $message)\n    {\n        /* New event? */\n        if ($this->id === null) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n        if (!$message->isGhosted('subject') &&\n            strlen($title = $message->getSubject())) {\n            $this->title = $title;\n        }\n        if ($message->getProtocolVersion() == Horde_ActiveSync::VERSION_TWOFIVE &&\n            !$message->isGhosted('body') &&\n            strlen($description = $message->getBody())) {\n            $this->description = $description;\n        } elseif ($message->getProtocolVersion() > Horde_ActiveSync::VERSION_TWOFIVE && !$message->isGhosted('airsyncbasebody')) {\n            if ($message->airsyncbasebody->type == Horde_ActiveSync::BODYPREF_TYPE_HTML) {\n                $this->description = Horde_Text_Filter::filter($message->airsyncbasebody->data, 'Html2text');\n            } else {\n                $this->description = $message->airsyncbasebody->data;\n            }\n        }\n\n        if (!$message->isGhosted('location') &&\n            strlen($location = $message->getLocation())) {\n            $this->location = $location;\n        }\n\n        /* Date/times */\n        $tz = !$message->isGhosted('timezone')\n            ? $message->getTimezone()\n            : $this->timezone;\n        $dates = $message->getDatetime();\n        $this->start = !$message->isGhosted('starttime')\n            ? clone($dates['start'])\n            : $this->start;\n        $this->start->setTimezone($tz);\n\n        $this->end = !$message->isGhosted('endtime')\n            ? clone($dates['end'])\n            : $this->end;\n        $this->end->setTimezone($tz);\n\n        if (!$message->isGhosted('alldayevent')) {\n            $this->allday = $dates['allday'];\n        }\n        if ($tz != date_default_timezone_get()) {\n            $this->timezone = $tz;\n        }\n\n        /* Sensitivity */\n        if (!$message->isGhosted('sensitivity')) {\n            $this->private = ($message->getSensitivity() == Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE || $message->getSensitivity() == Horde_ActiveSync_Message_Appointment::SENSITIVITY_CONFIDENTIAL) ? true :  false;\n        }\n\n        /* Busy Status */\n        if (!$message->isGhosted('meetingstatus')) {\n            if ($message->getMeetingStatus() == Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED) {\n                $status = Kronolith::STATUS_CANCELLED;\n            } else {\n                $status = $message->getBusyStatus();\n                switch ($status) {\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_BUSY:\n                    $status = Kronolith::STATUS_CONFIRMED;\n                    break;\n\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE:\n                    $status = Kronolith::STATUS_FREE;\n                    break;\n\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_TENTATIVE:\n                    $status = Kronolith::STATUS_TENTATIVE;\n                    break;\n                // @TODO: not sure how \"Out\" should show in kronolith...\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_OUT:\n                    $status = Kronolith::STATUS_CONFIRMED;\n                default:\n                    // EAS Specifies default should be free.\n                    $status = Kronolith::STATUS_FREE;\n                }\n            }\n            $this->status = $status;\n        }\n\n        /* Alarm */\n        if (!$message->isGhosted('reminder') && ($alarm = $message->getReminder())) {\n            $this->alarm = $alarm;\n        }\n\n        /* Recurrence */\n        if (!$message->isGhosted('recurrence') && ($rrule = $message->getRecurrence())) {\n            /* Exceptions */\n            $kronolith_driver = $this->getDriver();\n            /* Since AS keeps exceptions as part of the original event, we need\n             * to delete all existing exceptions and re-create them. The only\n             * drawback to this is that the UIDs will change. */\n            $this->recurrence = $rrule;\n            if (!empty($this->uid)) {\n                $search = new StdClass();\n                $search->baseid = $this->uid;\n                $results = $kronolith_driver->search($search);\n                foreach ($results as $days) {\n                    foreach ($days as $exception) {\n                        $kronolith_driver->deleteEvent($exception->id);\n                    }\n                }\n            }\n\n            $erules = $message->getExceptions();\n            foreach ($erules as $rule){\n                /* Readd the exception event, but only if not deleted */\n                if (!$rule->deleted) {\n                    $event = $kronolith_driver->getEvent();\n                    $times = $rule->getDatetime();\n                    $original = $rule->getExceptionStartTime();\n                    $original->setTimezone($tz);\n                    $this->recurrence->addException($original->format('Y'), $original->format('m'), $original->format('d'));\n                    $event->start = $times['start'];\n                    $event->end = $times['end'];\n                    $event->start->setTimezone($tz);\n                    $event->end->setTimezone($tz);\n                    $event->allday = $times['allday'];\n                    $event->title = $rule->getSubject();\n                    $event->title = empty($event->title) ? $this->title : $event->title;\n                    $event->description = $rule->getBody();\n                    $event->description = empty($event->description) ? $this->description : $event->description;\n                    $event->baseid = $this->uid;\n                    $event->exceptionoriginaldate = $original;\n                    $event->initialized = true;\n                    if ($tz != date_default_timezone_get()) {\n                        $event->timezone = $tz;\n                    }\n                    $event->save();\n                } else {\n                    /* For exceptions that are deletions, just add the exception */\n                    $exceptiondt = $rule->getExceptionStartTime();\n                    $exceptiondt->setTimezone($tz);\n                    $this->recurrence->addException($exceptiondt->format('Y'), $exceptiondt->format('m'), $exceptiondt->format('d'));\n               }\n            }\n        }\n\n        /* Attendees */\n        if (!$message->isGhosted('attendees')) {\n            $attendees = $message->getAttendees();\n            foreach ($attendees as $attendee) {\n                switch ($attendee->status) {\n                case Horde_ActiveSync_Message_Attendee::STATUS_ACCEPT:\n                    $response_code = Kronolith::RESPONSE_ACCEPTED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::STATUS_DECLINE:\n                    $response_code = Kronolith::RESPONSE_DECLINED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::STATUS_TENTATIVE:\n                    $response_code = Kronolith::RESPONSE_TENTATIVE;\n                    break;\n                default:\n                    $response_code = Kronolith::RESPONSE_NONE;\n                }\n                switch ($attendee->type) {\n                case Horde_ActiveSync_Message_Attendee::TYPE_REQUIRED:\n                    $part_type = Kronolith::PART_REQUIRED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::TYPE_OPTIONAL:\n                    $part_type = Kronolith::PART_OPTIONAL;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::TYPE_RESOURCE:\n                    $part_type = Kronolith::PART_REQUIRED;\n                }\n\n                $this->addAttendee($attendee->email,\n                                   $part_type,\n                                   $response_code,\n                                   $attendee->name);\n            }\n        }\n\n        /* Categories (Tags) */\n        if (!$message->isGhosted('categories')) {\n            $this->_tags = $message->getCategories();\n        }\n\n        // 14.1\n        if ($message->getProtocolVersion() >= Horde_ActiveSync::VERSION_FOURTEENONE &&\n            !$message->isGhosted('onlinemeetingexternallink')) {\n            $this->url = $message->onlinemeetingexternallink;\n        }\n\n        /* Flag that we are initialized */\n        $this->initialized = true;\n    }\n\n    /**\n     * Export this event as a MS ActiveSync Message\n     *\n     * @param array $options  Options:\n     *   - protocolversion: (float)  The EAS version to support\n     *                      DEFAULT: 2.5\n     *   - bodyprefs: (array)  A BODYPREFERENCE array.\n     *                DEFAULT: none (No body prefs enforced).\n     *   - truncation: (integer)  Truncate event body to this length\n     *                 DEFAULT: none (No truncation).\n     *\n     * @return Horde_ActiveSync_Message_Appointment\n     */\n    public function toASAppointment(array $options = array())\n    {\n        global $prefs, $registry;\n\n        $message = new Horde_ActiveSync_Message_Appointment(\n            array(\n                'logger' => $GLOBALS['injector']->getInstance('Horde_Log_Logger'),\n                'protocolversion' => $options['protocolversion']\n            )\n        );\n\n        if (!$this->isPrivate()) {\n            // Handle body/truncation\n            if (!empty($options['bodyprefs'])) {\n                if (Horde_String::length($this->description) > 0) {\n                    $bp = $options['bodyprefs'];\n                    $note = new Horde_ActiveSync_Message_AirSyncBaseBody();\n                    // No HTML supported. Always use plaintext.\n                    $note->type = Horde_ActiveSync::BODYPREF_TYPE_PLAIN;\n                    if (isset($bp[Horde_ActiveSync::BODYPREF_TYPE_PLAIN]['truncationsize'])) {\n                        $truncation = $bp[Horde_ActiveSync::BODYPREF_TYPE_PLAIN]['truncationsize'];\n                    } elseif (isset($bp[Horde_ActiveSync::BODYPREF_TYPE_HTML])) {\n                        $truncation = $bp[Horde_ActiveSync::BODYPREF_TYPE_HTML]['truncationsize'];\n                        $this->description = Horde_Text_Filter::filter($this->description, 'Text2html', array('parselevel' => Horde_Text_Filter_Text2html::MICRO));\n                    } else {\n                        $truncation = false;\n                    }\n                    if ($truncation && Horde_String::length($this->description) > $truncation) {\n                        $note->data = Horde_String::substr($this->description, 0, $truncation);\n                        $note->truncated = 1;\n                    } else {\n                        $note->data = $this->description;\n                    }\n                    $note->estimateddatasize = Horde_String::length($this->description);\n                    $message->airsyncbasebody = $note;\n                }\n            } else {\n                $message->setBody($this->description);\n            }\n            $message->setLocation($this->location);\n        }\n\n        $message->setSubject($this->getTitle());\n        $message->setDatetime(array(\n            'start' => $this->start,\n            'end' => $this->end,\n            'allday' => $this->isAllDay())\n        );\n        $message->setTimezone($this->start);\n\n        // Organizer\n        if (count($this->attendees)) {\n            if ($this->creator == $registry->getAuth()) {\n                $as_ident = $prefs->getValue('activesync_identity') == 'horde'\n                    ? $prefs->getValue('default_identity')\n                    : $prefs->getValue('activesync_identity');\n\n                $name = $GLOBALS['injector']\n                    ->getInstance('Horde_Core_Factory_Identity')\n                    ->create($this->creator)->getValue('fullname', $as_ident);\n                $email = $GLOBALS['injector']\n                    ->getInstance('Horde_Core_Factory_Identity')\n                    ->create($this->creator)->getValue('from_addr', $as_ident);\n            } else {\n                $name = Kronolith::getUserName($this->creator);\n                $email = Kronolith::getUserEmail($this->creator);\n            }\n            $message->setOrganizer(array(\n                'name' => $name,\n                'email' => $email)\n            );\n        }\n\n        // Privacy\n        $message->setSensitivity($this->private ?\n            Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE :\n            Horde_ActiveSync_Message_Appointment::SENSITIVITY_NORMAL);\n\n        // Busy Status\n        switch ($this->status) {\n        case Kronolith::STATUS_CANCELLED:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE;\n            break;\n        case Kronolith::STATUS_CONFIRMED:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_BUSY;\n            break;\n        case Kronolith::STATUS_TENTATIVE:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_TENTATIVE;\n        case Kronolith::STATUS_FREE:\n        case Kronolith::STATUS_NONE:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE;\n        }\n        $message->setBusyStatus($status);\n\n        // DTStamp\n        $message->setDTStamp($_SERVER['REQUEST_TIME']);\n\n        // Recurrence\n        if ($this->recurs()) {\n            $message->setRecurrence($this->recurrence, $GLOBALS['prefs']->getValue('week_start_monday'));\n\n            /* Exceptions are tricky. Exceptions, even those that represent\n             * deleted instances of a recurring event, must be added. To do this\n             * we query the storage for all the events that represent exceptions\n             * (those with the baseid == $this->uid) and then remove the\n             * exceptionoriginaldate from the list of exceptions we know about.\n             * Any dates left in this list when we are done, must represent\n             * deleted instances of this recurring event.*/\n            if (!empty($this->recurrence) && $exceptions = $this->recurrence->getExceptions()) {\n                $results = $this->boundExceptions();\n                foreach ($results as $exception) {\n                    $e = new Horde_ActiveSync_Message_Exception(array(\n                        'protocolversion' => $options['protocolversion']));\n                    $e->setDateTime(array(\n                        'start' => $exception->start,\n                        'end' => $exception->end,\n                        'allday' => $exception->isAllDay()));\n\n                    // The start time of the *original* recurring event\n                    $e->setExceptionStartTime($exception->exceptionoriginaldate);\n                    $originaldate = $exception->exceptionoriginaldate->format('Ymd');\n                    $key = array_search($originaldate, $exceptions);\n                    if ($key !== false) {\n                        unset($exceptions[$key]);\n                    }\n\n                    // Remaining properties that could be different\n                    $e->setSubject($exception->getTitle());\n                    if (!$exception->isPrivate()) {\n                        $e->setLocation($exception->location);\n                        $e->setBody($exception->description);\n                    }\n\n                    $e->setSensitivity($exception->private ?\n                        Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE :\n                        Horde_ActiveSync_Message_Appointment::SENSITIVITY_NORMAL);\n                    $e->setReminder($exception->alarm);\n                    $e->setDTStamp($_SERVER['REQUEST_TIME']);\n\n                    if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWELVEONE) {\n                        switch ($exception->status) {\n                        case Kronolith::STATUS_TENTATIVE;\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_TENTATIVE;\n                            break;\n                        case Kronolith::STATUS_NONE:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NORESPONSE;\n                            break;\n                        case Kronolith::STATUS_CONFIRMED:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_ACCEPTED;\n                            break;\n                        default:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NONE;\n                        }\n                    }\n\n                    // Tags/Categories\n                    if (!$exception->isPrivate()) {\n                        foreach ($exception->tags as $tag) {\n                            $e->addCategory($tag);\n                        }\n                    }\n\n                    $message->addexception($e);\n                }\n\n                // Any dates left in $exceptions must be deleted exceptions\n                foreach ($exceptions as $deleted) {\n                    $e = new Horde_ActiveSync_Message_Exception(array(\n                        'protocolversion' => $options['protocolversion']));\n                    // Kronolith stores the date only, but some AS clients need\n                    // the datetime.\n                    list($year, $month, $mday) = sscanf($deleted, '%04d%02d%02d');\n                    $st = clone $this->start;\n                    $st->year = $year;\n                    $st->month = $month;\n                    $st->mday = $mday;\n                    $e->setExceptionStartTime($st);\n                    $e->deleted = true;\n                    $message->addException($e);\n                }\n            }\n        }\n\n        // Attendees\n        if (!$this->isPrivate() && count($this->attendees)) {\n            $message->setMeetingStatus(\n                $this->status == Kronolith::STATUS_CANCELLED\n                    ? Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED\n                    : Horde_ActiveSync_Message_Appointment::MEETING_IS_MEETING\n            );\n            foreach ($this->attendees as $email => $properties) {\n                $attendee = new Horde_ActiveSync_Message_Attendee(array(\n                    'protocolversion' => $options['protocolversion']));\n                $adr_obj = new Horde_Mail_Rfc822_Address($email);\n                $attendee->name = $adr_obj->label;\n                $attendee->email = $adr_obj->bare_address;\n\n                // AS only has required or optional, and only EAS Version > 2.5\n                if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWOFIVE) {\n                    $attendee->type = ($properties['attendance'] !== Kronolith::PART_REQUIRED\n                        ? Horde_ActiveSync_Message_Attendee::TYPE_OPTIONAL\n                        : Horde_ActiveSync_Message_Attendee::TYPE_REQUIRED);\n\n                    switch ($properties['response']) {\n                    case Kronolith::RESPONSE_NONE:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_NORESPONSE;\n                        break;\n                    case Kronolith::RESPONSE_ACCEPTED:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_ACCEPT;\n                        break;\n                    case Kronolith::RESPONSE_DECLINED:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_DECLINE;\n                        break;\n                    case Kronolith::RESPONSE_TENTATIVE:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_TENTATIVE;\n                        break;\n                    default:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_UNKNOWN;\n                    }\n                }\n\n                $message->addAttendee($attendee);\n            }\n        } elseif ($this->status == Kronolith::STATUS_CANCELLED) {\n            $message->setMeetingStatus(Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED);\n        } else {\n            $message->setMeetingStatus(Horde_ActiveSync_Message_Appointment::MEETING_NOT_MEETING);\n        }\n\n        // Resources\n        if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWOFIVE) {\n            $r = $this->getResources();\n            foreach ($r as $id => $data) {\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                // EAS *REQUIRES* an email field for Resources. If it is missing\n                // a number of clients will fail, losing push.\n                if ($resource->get('email')) {\n                    $attendee = new Horde_ActiveSync_Message_Attendee(array(\n                        'protocolversion' => $options['protocolversion']));\n                    $attendee->email = $resource->get('email');\n                    $attendee->type = Horde_ActiveSync_Message_Attendee::TYPE_RESOURCE;\n                    $attendee->name = $data['name'];\n                    $attendee->status = $data['response'];\n                    $message->addAttendee($attendee);\n                }\n           }\n        }\n\n        // Reminder\n        if ($this->alarm) {\n            $message->setReminder($this->alarm);\n        }\n\n        // Categories (tags)\n        if (!$this->isPrivate()) {\n            foreach ($this->tags as $tag) {\n                $message->addCategory($tag);\n            }\n        }\n\n        // EAS 14\n        if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWELVEONE) {\n            // We don't track the actual responses we sent to other's invitations.\n            // Set this based on the status flag.\n            switch ($this->status) {\n            case Kronolith::STATUS_TENTATIVE;\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_TENTATIVE;\n                break;\n            case Kronolith::STATUS_NONE:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NORESPONSE;\n                break;\n            case Kronolith::STATUS_CONFIRMED:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_ACCEPTED;\n                break;\n            default:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NONE;\n            }\n        }\n\n        // 14.1\n        if ($options['protocolversion'] >= Horde_ActiveSync::VERSION_FOURTEENONE) {\n            $message->onlinemeetingexternallink = $this->url;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Imports the values for this event from an array of values.\n     *\n     * @param array $hash  Array containing all the values.\n     *\n     * @throws Kronolith_Exception\n     */\n    public function fromHash($hash)\n    {\n        // See if it's a new event.\n        if ($this->id === null) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n\n        if (!empty($hash['title'])) {\n            $this->title = $hash['title'];\n        } else {\n            throw new Kronolith_Exception(_(\"Events must have a title.\"));\n        }\n\n        $this->start = null;\n        if (!empty($hash['start_date'])) {\n            $date = array_map('intval', explode('-', $hash['start_date']));\n            if (empty($hash['start_time'])) {\n                $time = array(0, 0, 0);\n            } else {\n                $time = array_map('intval', explode(':', $hash['start_time']));\n                if (count($time) == 2) {\n                    $time[2] = 0;\n                }\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                if ($date[0] < 100) {\n                    $date[0] += (date('Y') / 100 | 0) * 100;\n                }\n                $this->start = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n            }\n        }\n        if (!isset($this->start)) {\n            throw new Kronolith_Exception(_(\"Events must have a start date.\"));\n        }\n\n        if (empty($hash['duration'])) {\n            if (empty($hash['end_date'])) {\n                $hash['end_date'] = $hash['start_date'];\n            }\n            if (empty($hash['end_time'])) {\n                $hash['end_time'] = $hash['start_time'];\n            }\n        } else {\n            $weeks = str_replace('W', '', $hash['duration'][1]);\n            $days = str_replace('D', '', $hash['duration'][2]);\n            $hours = str_replace('H', '', $hash['duration'][4]);\n            $minutes = isset($hash['duration'][5]) ? str_replace('M', '', $hash['duration'][5]) : 0;\n            $seconds = isset($hash['duration'][6]) ? str_replace('S', '', $hash['duration'][6]) : 0;\n            $hash['duration'] = ($weeks * 60 * 60 * 24 * 7) + ($days * 60 * 60 * 24) + ($hours * 60 * 60) + ($minutes * 60) + $seconds;\n            $this->end = new Horde_Date($this->start);\n            $this->end->sec += $hash['duration'];\n        }\n        if (!empty($hash['end_date'])) {\n            $date = array_map('intval', explode('-', $hash['end_date']));\n            if (empty($hash['end_time'])) {\n                $time = array(0, 0, 0);\n            } else {\n                $time = array_map('intval', explode(':', $hash['end_time']));\n                if (count($time) == 2) {\n                    $time[2] = 0;\n                }\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                if ($date[0] < 100) {\n                    $date[0] += (date('Y') / 100 | 0) * 100;\n                }\n                $this->end = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n            }\n        }\n\n        if (!empty($hash['alarm'])) {\n            $this->alarm = (int)$hash['alarm'];\n        } elseif (!empty($hash['alarm_date']) &&\n                  !empty($hash['alarm_time'])) {\n            $date = array_map('intval', explode('-', $hash['alarm_date']));\n            $time = array_map('intval', explode(':', $hash['alarm_time']));\n            if (count($time) == 2) {\n                $time[2] = 0;\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                $alarm = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n                $this->alarm = ($this->start->timestamp() - $alarm->timestamp()) / 60;\n            }\n        }\n\n        $this->allday = !empty($hash['allday']);\n\n        if (!empty($hash['description'])) {\n            $this->description = $hash['description'];\n        }\n\n        if (!empty($hash['location'])) {\n            $this->location = $hash['location'];\n        }\n\n        // Import once we support organizers.\n        /*\n        if (!empty($hash['organizer'])) {\n            $this->organizer = $hash['organizer'];\n        }\n        */\n\n        if (!empty($hash['private'])) {\n            $this->private = true;\n        }\n\n        if (!empty($hash['recur_type'])) {\n            $this->recurrence = new Horde_Date_Recurrence($this->start);\n            $this->recurrence->setRecurType($hash['recur_type']);\n            if (!empty($hash['recur_count'])) {\n                $this->recurrence->setRecurCount($hash['recur_count']);\n            } elseif (!empty($hash['recur_end_date'])) {\n                $date = array_map('intval', explode('-', $hash['recur_end_date']));\n                if (count($date) == 3 && !empty($date[1]) && !empty($date[2])) {\n                    $this->recurrence->setRecurEnd(\n                        new Horde_Date(array(\n                            'year'  => $date[0],\n                            'month' => $date[1],\n                            'mday'  => $date[2]\n                        ))\n                    );\n                }\n            }\n            if (!empty($hash['recur_interval'])) {\n                $this->recurrence->setRecurInterval($hash['recur_interval']);\n            }\n            if (!empty($hash['recur_data'])) {\n                $this->recurrence->setRecurOnDay($hash['recur_data']);\n            }\n            if (!empty($hash['recur_exceptions'])) {\n                foreach ($hash['recur_exceptions'] as $exception) {\n                    $parts = explode('-', $exception);\n                    if (count($parts) == 3) {\n                        $this->recurrence->addException($parts[0], $parts[1], $parts[2]);\n                    }\n                }\n            }\n        }\n\n        if (isset($hash['sequence'])) {\n            $this->sequence = $hash['sequence'];\n        }\n\n        if (!empty($hash['tags'])) {\n            $this->tags = $hash['tags'];\n        }\n\n        if (!empty($hash['timezone'])) {\n            $this->timezone = $hash['timezone'];\n        }\n\n        if (!empty($hash['uid'])) {\n            $this->uid = $hash['uid'];\n        }\n\n        $this->initialized = true;\n    }\n\n    /**\n     * Returns an alarm hash of this event suitable for Horde_Alarm.\n     *\n     * @param Horde_Date $time  Time of alarm.\n     * @param string $user      The user to return alarms for.\n     * @param Prefs $prefs      A Prefs instance.\n     *\n     * @return array  Alarm hash or null.\n     */\n    public function toAlarm($time, $user = null, $prefs = null)\n    {\n        if (!$this->alarm || $this->status == Kronolith::STATUS_CANCELLED) {\n            return;\n        }\n\n        if ($this->recurs()) {\n            $eventDate = $this->recurrence->nextRecurrence($time);\n            if (!$eventDate || ($eventDate && $this->recurrence->hasException($eventDate->year, $eventDate->month, $eventDate->mday))) {\n                return;\n            }\n            $start = clone $eventDate;\n            $diff = Date_Calc::dateDiff(\n                $this->start->mday,\n                $this->start->month,\n                $this->start->year,\n                $this->end->mday,\n                $this->end->month,\n                $this->end->year\n            );\n            if ($diff == -1) {\n                $diff = 0;\n            }\n            $end = new Horde_Date(array(\n                'year' => $start->year,\n                'month' => $start->month,\n                'mday' => $start->mday + $diff,\n                'hour' => $this->end->hour,\n                'min' => $this->end->min,\n                'sec' => $this->end->sec)\n            );\n        } else {\n            $start = clone $this->start;\n            $end = clone $this->end;\n        }\n\n        $serverName = $_SERVER['SERVER_NAME'];\n        $serverConf = $GLOBALS['conf']['server']['name'];\n        if (!empty($GLOBALS['conf']['reminder']['server_name'])) {\n            $_SERVER['SERVER_NAME'] = $GLOBALS['conf']['server']['name'] = $GLOBALS['conf']['reminder']['server_name'];\n        }\n\n        if (empty($user)) {\n            $user = $GLOBALS['registry']->getAuth();\n        }\n        if (empty($prefs)) {\n            $prefs = $GLOBALS['prefs'];\n        }\n\n        $methods = !empty($this->methods) ? $this->methods : @unserialize($prefs->getValue('event_alarms'));\n        if (isset($methods['notify'])) {\n            $methods['notify']['show'] = array(\n                '__app' => $GLOBALS['registry']->getApp(),\n                'event' => $this->id,\n                'calendar' => $this->calendar);\n            $methods['notify']['ajax'] = 'event:' . $this->calendarType . '|' . $this->calendar . ':' . $this->id . ':' . $start->dateString();\n            if (!empty($methods['notify']['sound'])) {\n                if ($methods['notify']['sound'] == 'on') {\n                    // Handle boolean sound preferences.\n                    $methods['notify']['sound'] = (string)Horde_Themes::sound('theetone.wav');\n                } else {\n                    // Else we know we have a sound name that can be\n                    // served from Horde.\n                    $methods['notify']['sound'] = (string)Horde_Themes::sound($methods['notify']['sound']);\n                }\n            }\n            if ($this->isAllDay()) {\n                if ($start->compareDate($end) == 0) {\n                    $methods['notify']['subtitle'] = sprintf(_(\"On %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')) . '</strong>');\n                } else {\n                    $methods['notify']['subtitle'] = sprintf(_(\"From %s to %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')) . '</strong>', '<strong>' . $end->strftime($prefs->getValue('date_format')) . '</strong>');\n                }\n            } else {\n                $methods['notify']['subtitle'] = sprintf(_(\"From %s at %s to %s at %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')), $start->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia') . '</strong>', '<strong>' . $end->strftime($prefs->getValue('date_format')), $this->end->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia') . '</strong>');\n            }\n        }\n        if (isset($methods['mail'])) {\n            $image = Kronolith::getImagePart('big_alarm.png');\n\n            $view = new Horde_View(array('templatePath' => KRONOLITH_TEMPLATES . '/alarm', 'encoding' => 'UTF-8'));\n            new Horde_View_Helper_Text($view);\n            $view->event = $this;\n            $view->imageId = $image->getContentId();\n            $view->user = $user;\n            $view->dateFormat = $prefs->getValue('date_format');\n            $view->timeFormat = $prefs->getValue('twentyFour') ? 'H:i' : 'h:ia';\n            $view->start = $start;\n            if (!$prefs->isLocked('event_reminder')) {\n                $view->prefsUrl = Horde::url($GLOBALS['registry']->getServiceLink('prefs', 'kronolith'), true)->remove(session_name());\n            }\n            if ($this->attendees) {\n                $view->attendees = Kronolith::getAttendeeEmailList($this->attendees)->addresses;\n            }\n\n            $methods['mail']['mimepart'] = Kronolith::buildMimeMessage($view, 'mail', $image);\n        }\n        if (isset($methods['desktop'])) {\n            if ($this->isAllDay()) {\n                if ($this->start->compareDate($this->end) == 0) {\n                    $methods['desktop']['subtitle'] = sprintf(_(\"On %s\"), $start->strftime($prefs->getValue('date_format')));\n                } else {\n                    $methods['desktop']['subtitle'] = sprintf(_(\"From %s to %s\"), $start->strftime($prefs->getValue('date_format')), $end->strftime($prefs->getValue('date_format')));\n                }\n            } else {\n                $methods['desktop']['subtitle'] = sprintf(_(\"From %s at %s to %s at %s\"), $start->strftime($prefs->getValue('date_format')), $start->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia'), $end->strftime($prefs->getValue('date_format')), $this->end->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia'));\n            }\n            $methods['desktop']['url'] = strval($this->getViewUrl(array(), true, false));\n        }\n\n        $alarmStart = clone $start;\n        $alarmStart->min -= $this->alarm;\n        $alarm = array(\n            'id' => $this->uid,\n            'user' => $user,\n            'start' => $alarmStart,\n            'end' => $end,\n            'methods' => array_keys($methods),\n            'params' => $methods,\n            'title' => $this->getTitle($user),\n            'text' => $this->description,\n            'instanceid' => $this->recurs() ? $eventDate->dateString() : null);\n\n        $_SERVER['SERVER_NAME'] = $serverName;\n        $GLOBALS['conf']['server']['name'] = $serverConf;\n\n        return $alarm;\n    }\n\n    /**\n     * Returns a simple object suitable for json transport representing this\n     * event.\n     *\n     * Possible properties are:\n     * - t: title\n     * - d: description\n     * - c: calendar id\n     * - s: start date\n     * - e: end date\n     * - fi: first day of a multi-day event\n     * - la: last day of a multi-day event\n     * - x: status (Kronolith::STATUS_* constant)\n     * - al: all-day?\n     * - bg: background color\n     * - fg: foreground color\n     * - pe: edit permissions?\n     * - pd: delete permissions?\n     * - vl: variable, i.e. editable length?\n     * - a: alarm text or minutes\n     * - r: recurrence type (Horde_Date_Recurrence::RECUR_* constant)\n     * - bid: The baseid for an event representing an exception\n     * - eod: The original date that an exception is replacing\n     * - ic: icon\n     * - ln: link\n     * - aj: ajax link\n     * - id: event id\n     * - ty: calendar type (driver)\n     * - l: location\n     * - u: url\n     * - sd: formatted start date\n     * - st: formatted start time\n     * - ed: formatted end date\n     * - et: formatted end time\n     * - at: attendees\n     * - rs:  resources\n     * - tg: tag list,\n     * - mt: meeting (Boolean true if event has attendees, false otherwise).\n     *\n     * @param boolean $allDay      If not null, overrides whether the event is\n     *                             an all-day event.\n     * @param boolean $full        Whether to return all event details.\n     * @param string $time_format  The date() format to use for time formatting.\n     *\n     * @return stdClass  A simple object.\n     */\n    public function toJson($allDay = null, $full = false, $time_format = 'H:i')\n    {\n        $json = new stdClass;\n        $json->uid = $this->uid;\n        $json->t = $this->getTitle();\n        $json->c = $this->calendar;\n        $json->s = $this->start->toJson();\n        $json->e = $this->end->toJson();\n        $json->fi = $this->first;\n        $json->la = $this->last;\n        $json->x = (int)$this->status;\n        $json->al = is_null($allDay) ? $this->isAllDay() : $allDay;\n        $json->pe = $this->hasPermission(Horde_Perms::EDIT);\n        $json->pd = $this->hasPermission(Horde_Perms::DELETE);\n        $json->l = $this->getLocation();\n        $json->mt = !empty($this->attendees);\n        $json->sort = sprintf(\n            '%010s%06s',\n            $this->originalStart->timestamp(),\n            240000 - $this->end->format('His')\n        );\n\n        if ($this->icon) {\n            $json->ic = $this->icon;\n        }\n        if ($this->alarm) {\n            if ($this->alarm % 10080 == 0) {\n                $alarm_value = $this->alarm / 10080;\n                $json->a = sprintf(ngettext(\"%d week\", \"%d weeks\", $alarm_value), $alarm_value);\n            } elseif ($this->alarm % 1440 == 0) {\n                $alarm_value = $this->alarm / 1440;\n                $json->a = sprintf(ngettext(\"%d day\", \"%d days\", $alarm_value), $alarm_value);\n            } elseif ($this->alarm % 60 == 0) {\n                $alarm_value = $this->alarm / 60;\n                $json->a = sprintf(ngettext(\"%d hour\", \"%d hours\", $alarm_value), $alarm_value);\n            } else {\n                $alarm_value = $this->alarm;\n                $json->a = sprintf(ngettext(\"%d minute\", \"%d minutes\", $alarm_value), $alarm_value);\n            }\n        }\n        if ($this->recurs()) {\n            $json->r = $this->recurrence->getRecurType();\n        } elseif ($this->baseid) {\n            $json->bid = $this->baseid;\n            if ($this->exceptionoriginaldate) {\n                $json->eod = sprintf(_(\"%s at %s\"), $this->exceptionoriginaldate->strftime($GLOBALS['prefs']->getValue('date_format')), $this->exceptionoriginaldate->strftime(($GLOBALS['prefs']->getValue('twentyFour') ? '%H:%M' : '%I:%M %p')));\n            }\n        }\n        if ($this->_resources) {\n            $json->rs = $this->_resources;\n        }\n        if ($full) {\n            $json->id = $this->id;\n            $json->ty = $this->calendarType;\n            $json->sd = $this->start->strftime('%x');\n            $json->st = $this->start->format($time_format);\n            $json->ed = $this->end->strftime('%x');\n            $json->et = $this->end->format($time_format);\n            $json->tz = $this->timezone;\n            $json->a = $this->alarm;\n            $json->pv = $this->private;\n            if ($this->recurs()) {\n                $json->r = $this->recurrence->toJson();\n            }\n            if (!$this->isPrivate()) {\n                $json->d = $this->description;\n                $json->u = $this->url;\n                $json->uhl = $GLOBALS['injector']->getInstance('Horde_Core_Factory_TextFilter')->filter($this->url, 'linkurls');\n                $json->tg = array_values($this->tags);\n                $json->gl = $this->geoLocation;\n                if ($this->attendees) {\n                    $attendees = array();\n                    foreach ($this->attendees as $email => $info) {\n                        $tmp = new Horde_Mail_Rfc822_Address($email);\n                        if (!empty($info['name'])) {\n                            $tmp->personal = $info['name'];\n                        }\n\n                        $attendees[] = array(\n                            'a' => intval($info['attendance']),\n                            'e' => $tmp->bare_address,\n                            'r' => intval($info['response']),\n                            'l' => strval($tmp)\n                        );\n                        $json->at = $attendees;\n                    }\n                }\n            }\n            if ($this->methods) {\n                $json->m = $this->methods;\n            }\n        }\n\n        return $json;\n    }\n\n    /**\n     * Checks if the current event is already present in the calendar.\n     *\n     * Does the check based on the uid.\n     *\n     * @return boolean  True if event exists, false otherwise.\n     */\n    public function exists()\n    {\n        if (!isset($this->uid) || !isset($this->calendar)) {\n            return false;\n        }\n        try {\n            $eventID = $this->getDriver()->exists($this->uid, $this->calendar);\n            if (!$eventID) {\n                return false;\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        $this->id = $eventID;\n        return true;\n    }\n\n    /**\n     * Converts this event between the event's and the local timezone.\n     *\n     * @param boolean $to_orginal  If true converts to the event's timezone.\n     */\n    public function setTimezone($to_original)\n    {\n        if (!$this->timezone || !$this->getDriver()->supportsTimezones()) {\n            return;\n        }\n        $timezone = $to_original ? $this->timezone : date_default_timezone_get();\n        $this->start->setTimezone($timezone);\n        $this->end->setTimezone($timezone);\n        if ($this->recurs() && $this->recurrence->hasRecurEnd()) {\n            /* @todo Check if have to go through all recurrence\n               exceptions too. */\n            $this->recurrence->start->setTimezone($timezone);\n            $this->recurrence->recurEnd->setTimezone($timezone);\n        }\n    }\n\n    public function getDuration()\n    {\n        if (isset($this->_duration)) {\n            return $this->_duration;\n        }\n\n        if ($this->start && $this->end) {\n            $dur_day_match = Date_Calc::dateDiff($this->start->mday,\n                                                 $this->start->month,\n                                                 $this->start->year,\n                                                 $this->end->mday,\n                                                 $this->end->month,\n                                                 $this->end->year);\n            $dur_hour_match = $this->end->hour - $this->start->hour;\n            $dur_min_match = $this->end->min - $this->start->min;\n            while ($dur_min_match < 0) {\n                $dur_min_match += 60;\n                --$dur_hour_match;\n            }\n            while ($dur_hour_match < 0) {\n                $dur_hour_match += 24;\n                --$dur_day_match;\n            }\n        } else {\n            $dur_day_match = 0;\n            $dur_hour_match = 1;\n            $dur_min_match = 0;\n        }\n\n        $this->_duration = new stdClass;\n        $this->_duration->day = $dur_day_match;\n        $this->_duration->hour = $dur_hour_match;\n        $this->_duration->min = $dur_min_match;\n        $this->_duration->wholeDay = $this->isAllDay();\n\n        return $this->_duration;\n    }\n\n    /**\n     * Returns whether this event is a recurring event.\n     *\n     * @return boolean  True if this is a recurring event.\n     */\n    public function recurs()\n    {\n        return isset($this->recurrence) &&\n            !$this->recurrence->hasRecurType(Horde_Date_Recurrence::RECUR_NONE) &&\n            empty($this->baseid);\n    }\n\n    /**\n     * Returns a description of this event's recurring type.\n     *\n     * @return string  Human readable recurring type.\n     */\n    public function getRecurName()\n    {\n        if (empty($this->baseid)) {\n            return $this->recurs()\n                ? $this->recurrence->getRecurName()\n                : _(\"No recurrence\");\n        } else {\n            return _(\"Exception\");\n        }\n    }\n\n    /**\n     * Returns a correcty formatted exception date for recurring events and a\n     * link to delete this exception.\n     *\n     * @param string $date  Exception in the format Ymd.\n     *\n     * @return string  The formatted date and delete link.\n     */\n    public function exceptionLink($date)\n    {\n        if (!preg_match('/(\\d{4})(\\d{2})(\\d{2})/', $date, $match)) {\n            return '';\n        }\n        $horde_date = new Horde_Date(array('year' => $match[1],\n                                           'month' => $match[2],\n                                           'mday' => $match[3]));\n        $formatted = $horde_date->strftime($GLOBALS['prefs']->getValue('date_format'));\n        return $formatted\n            . Horde::url('edit.php')\n            ->add(array('calendar' => $this->calendarType . '_' .$this->calendar,\n                        'eventID' => $this->id,\n                        'del_exception' => $date,\n                        'url' => Horde_Util::getFormData('url')))\n            ->link(array('title' => sprintf(_(\"Delete exception on %s\"), $formatted)))\n            . Horde::img('delete-small.png', _(\"Delete\"))\n            . '</a>';\n    }\n\n    /**\n     * Returns a list of exception dates for recurring events including links\n     * to delete them.\n     *\n     * @return string  List of exception dates and delete links.\n     */\n    public function exceptionsList()\n    {\n        $exceptions = $this->recurrence->getExceptions();\n        asort($exceptions);\n        return implode(', ', array_map(array($this, 'exceptionLink'), $exceptions));\n    }\n\n    /**\n     * Returns a list of events that represent exceptions to this event's\n     * recurrence series, if any. If this event does not recur, an empty array\n     * is returned.\n     *\n     * @param boolean $flat  If true (the default), returns a flat array\n     *                       containing Kronolith_Event objects. If false,\n     *                       results are in the format of listEvents calls. @see\n     *                       Kronolith::listEvents().\n     *\n     * @return array  An array of Kronolith_Event objects whose baseid property\n     *                is equal to this event's uid. I.e., it is a bound\n     *                exception.\n     *\n     * @since 4.2.2\n     */\n    public function boundExceptions($flat = true)\n    {\n        if (!$this->recurrence || !$this->uid) {\n            return array();\n        }\n        $return = array();\n        $search = new stdClass();\n        $search->baseid = $this->uid;\n        $results = $this->getDriver()->search($search);\n\n        if (!$flat) {\n            return $results;\n        }\n\n        foreach ($results as $days) {\n            foreach ($days as $exception) {\n                $return[] = $exception;\n            }\n        }\n\n        return $return;\n    }\n\n    /**\n     * Returns whether the event should be considered private.\n     *\n     * @param string $user  The current user. If omitted, uses the current user.\n     *\n     * @return boolean  Whether to consider the event as private.\n     */\n    public function isPrivate($user = null)\n    {\n        global $registry;\n\n        if ($user === null) {\n            $user = $registry->getAuth();\n        }\n\n        // Never private if private is not true or if the current user is the\n        // event creator.\n        if ((!$this->private || $this->creator == $user) &&\n            $this->hasPermission(Horde_Perms::READ, $user)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the title of this event, considering private flags.\n     *\n     * @param string $user  The current user.\n     *\n     * @return string  The title of this event.\n     */\n    public function getTitle($user = null)\n    {\n        if (!$this->initialized) {\n            return '';\n        }\n\n        return $this->isPrivate($user)\n            ? _(\"busy\")\n            : (strlen($this->title) ? $this->title : _(\"[Unnamed event]\"));\n    }\n\n    /**\n     * Returns the location of this event, considering private flags.\n     *\n     * @param string $user  The current user.\n     *\n     * @return string  The location of this event.\n     */\n    public function getLocation($user = null)\n    {\n        return $this->isPrivate($user) ? '' : $this->location;\n    }\n\n    /**\n     * Checks to see whether the specified attendee is associated with the\n     * current event.\n     *\n     * @param string $email  The email address of the attendee.\n     *\n     * @return boolean  True if the specified attendee is present for this\n     *                  event.\n     */\n    public function hasAttendee($email)\n    {\n        return isset($this->attendees[Horde_String::lower($email)]);\n    }\n\n    /**\n     * Adds a new attendee to the current event.\n     *\n     * This will overwrite an existing attendee if one exists with the same\n     * email address.\n     *\n     * @param string $email        The email address of the attendee.\n     * @param integer $attendance  The attendance code of the attendee.\n     * @param integer $response    The response code of the attendee.\n     * @param string $name         The name of the attendee.\n     */\n    public function addAttendee($email, $attendance, $response, $name = null)\n    {\n        if ($attendance == Kronolith::PART_IGNORE) {\n            if (isset($this->attendees[$email])) {\n                $attendance = $this->attendees[$email]['attendance'];\n            } else {\n                $attendance = Kronolith::PART_REQUIRED;\n            }\n        }\n        if (empty($name) && isset($this->attendees[$email]) &&\n            !empty($this->attendees[$email]['name'])) {\n            $name = $this->attendees[$email]['name'];\n        }\n\n        $this->attendees[$email] = array(\n            'attendance' => $attendance,\n            'response' => $response,\n            'name' => $name\n        );\n    }\n\n    /**\n     * Adds a single resource to this event.\n     *\n     * No validation or acceptence/denial is done here...it should be done\n     * when saving the event.\n     *\n     * @param Kronolith_Resource $resource  The resource to add.\n     */\n    public function addResource($resource, $response)\n    {\n        $this->_resources[$resource->getId()] = array(\n            'attendance' => Kronolith::PART_REQUIRED,\n            'response' => $response,\n            'name' => $resource->get('name'),\n            'calendar' => $resource->get('calendar')\n        );\n    }\n\n    /**\n     * Removes a resource from this event.\n     *\n     * @param Kronolith_Resource $resource  The resource to remove.\n     */\n    public function removeResource($resource)\n    {\n        if (isset($this->_resources[$resource->getId()])) {\n            unset($this->_resources[$resource->getId()]);\n        }\n    }\n\n    /**\n     * Returns all resources.\n     *\n     * @return array  A copy of the resources array.\n     */\n    public function getResources()\n    {\n        return $this->_resources;\n    }\n\n    /**\n     * Set the entire resource array. Only used when copying an Event.\n     *\n     * @param array  $resources  The resource array.\n     * @since 4.2.6\n     */\n    public function setResources(array $resources)\n    {\n        $this->_resources = $resources;\n    }\n\n    public function isAllDay()\n    {\n        return $this->allday ||\n            ($this->start->hour == 0 && $this->start->min == 0 && $this->start->sec == 0 &&\n             (($this->end->hour == 23 && $this->end->min == 59) ||\n              ($this->end->hour == 0 && $this->end->min == 0 && $this->end->sec == 0 &&\n               ($this->end->mday > $this->start->mday ||\n                $this->end->month > $this->start->month ||\n                $this->end->year > $this->start->year))));\n    }\n\n    /**\n     * Syncronizes tags from the tagging backend with the task storage backend,\n     * if necessary.\n     *\n     * @param array $tags  Tags from the tagging backend.\n     */\n    public function synchronizeTags($tags)\n    {\n        if (isset($this->_internaltags)) {\n            $lower_internaltags = array_map('Horde_String::lower', $this->_internaltags);\n            $lower_tags = array_map('Horde_String::lower', $tags);\n            usort($lower_tags, 'strcoll');\n\n            if (array_diff($lower_internaltags, $lower_tags)) {\n                Kronolith::getTagger()->replaceTags(\n                    $this->uid,\n                    $this->_internaltags,\n                    $this->_creator,\n                    Kronolith_Tagger::TYPE_EVENT\n                );\n            }\n            $this->_tags = $this->_internaltags;\n        } else {\n            $this->_tags = $tags;\n        }\n    }\n\n    /**\n     * Reads form/post data and updates this event's properties.\n     *\n     * @param  Kronolith_Event|null $existing  If this is an exception event\n     *                                         this is taken as the base event.\n     *                                         @since 4.2.6\n     *\n     */\n    public function readForm(Kronolith_Event $existing = null)\n    {\n        global $prefs, $session;\n\n        // Event owner.\n        $targetcalendar = Horde_Util::getFormData('targetcalendar');\n        if (strpos($targetcalendar, '\\\\')) {\n            list(, $this->creator) = explode('\\\\', $targetcalendar, 2);\n        } elseif (!isset($this->_id)) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n\n        // Basic fields.\n        $this->title = Horde_Util::getFormData('title', $this->title);\n        $this->description = Horde_Util::getFormData('description', $this->description);\n        $this->location = Horde_Util::getFormData('location', $this->location);\n        $this->timezone = Horde_Util::getFormData('timezone', $this->timezone);\n        $this->private = (bool)Horde_Util::getFormData('private');\n\n        // URL.\n        $url = Horde_Util::getFormData('eventurl', $this->url);\n        if (strlen($url)) {\n            // Analyze and re-construct.\n            $url = @parse_url($url);\n            if ($url) {\n                if (function_exists('http_build_url')) {\n                    if (empty($url['path'])) {\n                        $url['path'] = '/';\n                    }\n                    $url = http_build_url($url);\n                } else {\n                    $new_url = '';\n                    if (isset($url['scheme'])) {\n                        $new_url .= $url['scheme'] . '://';\n                    }\n                    if (isset($url['user'])) {\n                        $new_url .= $url['user'];\n                        if (isset($url['pass'])) {\n                            $new_url .= ':' . $url['pass'];\n                        }\n                        $new_url .= '@';\n                    }\n                    if (isset($url['host'])) {\n                        // Convert IDN hosts to ASCII.\n                        if (function_exists('idn_to_ascii')) {\n                            $url['host'] = @idn_to_ascii($url['host']);\n                        } elseif (Horde_Mime::is8bit($url['host'])) {\n                            //throw new Kronolith_Exception(_(\"Invalid character in URL.\"));\n                            $url['host'] = '';\n                        }\n                        $new_url .= $url['host'];\n                    }\n                    if (isset($url['path'])) {\n                        $new_url .= $url['path'];\n                    }\n                    if (isset($url['query'])) {\n                        $new_url .= '?' . $url['query'];\n                    }\n                    if (isset($url['fragment'])) {\n                        $new_url .= '#' . $url['fragment'];\n                    }\n                    $url = $new_url;\n                }\n            }\n        }\n        $this->url = $url;\n\n        // Status.\n        $this->status = Horde_Util::getFormData('status', $this->status);\n\n        // Attendees.\n        $attendees = $session->get('kronolith', 'attendees', Horde_Session::TYPE_ARRAY);\n        if (!is_null($newattendees = Horde_Util::getFormData('attendees'))) {\n            $newattendees = Kronolith::parseAttendees(trim($newattendees));\n            foreach ($newattendees as $email => $attendee) {\n                if (!isset($attendees[$email])) {\n                    $attendees[$email] = $attendee;\n                }\n            }\n            foreach (array_keys($attendees) as $email) {\n                if (!isset($newattendees[$email])) {\n                    unset($attendees[$email]);\n                }\n            }\n        }\n        $this->attendees = $attendees;\n\n        // Event start.\n        $allDay = Horde_Util::getFormData('whole_day');\n        if ($start_date = Horde_Util::getFormData('start_date')) {\n            // From ajax interface.\n            $this->start = Kronolith::parseDate($start_date . ' ' . Horde_Util::getFormData('start_time'), true, $this->timezone);\n            if ($allDay) {\n                $this->start->hour = $this->start->min = $this->start->sec = 0;\n            }\n        } elseif ($start = Horde_Util::getFormData('start')) {\n            // From traditional interface.\n            $start_year = $start['year'];\n            $start_month = $start['month'];\n            $start_day = $start['day'];\n            $start_hour = Horde_Util::getFormData('start_hour');\n            $start_min = Horde_Util::getFormData('start_min');\n            $am_pm = Horde_Util::getFormData('am_pm');\n\n            if (!$prefs->getValue('twentyFour')) {\n                if ($am_pm == 'PM') {\n                    if ($start_hour != 12) {\n                        $start_hour += 12;\n                    }\n                } elseif ($start_hour == 12) {\n                    $start_hour = 0;\n                }\n            }\n\n            if (Horde_Util::getFormData('end_or_dur') == 1) {\n                if ($allDay) {\n                    $start_hour = 0;\n                    $start_min = 0;\n                    $dur_day = 0;\n                    $dur_hour = 24;\n                    $dur_min = 0;\n                } else {\n                    $dur_day = (int)Horde_Util::getFormData('dur_day');\n                    $dur_hour = (int)Horde_Util::getFormData('dur_hour');\n                    $dur_min = (int)Horde_Util::getFormData('dur_min');\n                }\n            }\n\n            $this->start = new Horde_Date(array('hour' => $start_hour,\n                                                'min' => $start_min,\n                                                'month' => $start_month,\n                                                'mday' => $start_day,\n                                                'year' => $start_year),\n                                          $this->timezone);\n        }\n\n        // Event end.\n        if ($end_date = Horde_Util::getFormData('end_date')) {\n            // From ajax interface.\n            $this->end = Kronolith::parseDate($end_date . ' ' . Horde_Util::getFormData('end_time'), true, $this->timezone);\n            if ($allDay) {\n                $this->end->hour = $this->end->min = $this->end->sec = 0;\n                $this->end->mday++;\n            }\n        } elseif (Horde_Util::getFormData('end_or_dur') == 1) {\n            // Event duration from traditional interface.\n            $this->end = new Horde_Date(array('hour' => $start_hour + $dur_hour,\n                                              'min' => $start_min + $dur_min,\n                                              'month' => $start_month,\n                                              'mday' => $start_day + $dur_day,\n                                              'year' => $start_year));\n        } elseif ($end = Horde_Util::getFormData('end')) {\n            // From traditional interface.\n            $end_year = $end['year'];\n            $end_month = $end['month'];\n            $end_day = $end['day'];\n            $end_hour = Horde_Util::getFormData('end_hour');\n            $end_min = Horde_Util::getFormData('end_min');\n            $end_am_pm = Horde_Util::getFormData('end_am_pm');\n\n            if (!$prefs->getValue('twentyFour')) {\n                if ($end_am_pm == 'PM') {\n                    if ($end_hour != 12) {\n                        $end_hour += 12;\n                    }\n                } elseif ($end_hour == 12) {\n                    $end_hour = 0;\n                }\n            }\n\n            $this->end = new Horde_Date(array('hour' => $end_hour,\n                                              'min' => $end_min,\n                                              'month' => $end_month,\n                                              'mday' => $end_day,\n                                              'year' => $end_year),\n                                        $this->timezone);\n            if ($this->end->compareDateTime($this->start) < 0) {\n                $this->end = new Horde_Date($this->start);\n            }\n        }\n\n        $this->allday = false;\n\n        // Alarm.\n        if (!is_null($alarm = Horde_Util::getFormData('alarm'))) {\n            if ($alarm) {\n                $value = Horde_Util::getFormData('alarm_value');\n                $unit = Horde_Util::getFormData('alarm_unit');\n                if ($value == 0) {\n                    $value = $unit = 1;\n                }\n                $this->alarm = $value * $unit;\n                // Notification.\n                if (Horde_Util::getFormData('alarm_change_method')) {\n                    $types = Horde_Util::getFormData('event_alarms');\n                    $methods = array();\n                    if (!empty($types)) {\n                        foreach ($types as $type) {\n                            $methods[$type] = array();\n                            switch ($type){\n                            case 'notify':\n                                $methods[$type]['sound'] = Horde_Util::getFormData('event_alarms_sound');\n                                break;\n                            case 'mail':\n                                $methods[$type]['email'] = Horde_Util::getFormData('event_alarms_email');\n                                break;\n                            case 'popup':\n                                break;\n                            }\n                        }\n                    }\n                    $this->methods = $methods;\n                } else {\n                    $this->methods = array();\n                }\n            } else {\n                $this->alarm = 0;\n                $this->methods = array();\n            }\n        }\n\n        // Recurrence.\n        $this->recurrence = $this->readRecurrenceForm(\n            $this->start, $this->timezone, $this->recurrence);\n\n        // Convert to local timezone.\n        $this->setTimezone(false);\n\n        $this->_handleResources($existing);\n\n        // Tags.\n        $this->tags = Horde_Util::getFormData('tags', $this->tags);\n\n        // Geolocation\n        if (Horde_Util::getFormData('lat') && Horde_Util::getFormData('lon')) {\n            $this->geoLocation = array('lat' => Horde_Util::getFormData('lat'),\n                                       'lon' => Horde_Util::getFormData('lon'),\n                                       'zoom' => Horde_Util::getFormData('zoom'));\n        }\n\n        $this->initialized = true;\n    }\n\n    static public function readRecurrenceForm($start, $timezone,\n                                              $recurrence = null)\n    {\n        $recur = Horde_Util::getFormData('recur');\n        if (!strlen($recur)) {\n            return $recurrence;\n        }\n        if (!isset($recurrence)) {\n            $recurrence = new Horde_Date_Recurrence($start);\n        } else {\n            $recurrence->setRecurStart($start);\n        }\n        if (Horde_Util::getFormData('recur_end_type') == 'date') {\n            $end_date = Horde_Util::getFormData('recur_end_date', false);\n            if ($end_date !== false) {\n                // From ajax interface.\n                if (empty($end_date)) {\n                    throw new Kronolith_Exception(\"Missing required end date of recurrence.\");\n                }\n                $date_ob = Kronolith::parseDate($end_date, false);\n                $recur_enddate = array(\n                    'year'  => $date_ob->year,\n                    'month' => $date_ob->month,\n                    'day'  => $date_ob->mday);\n            } else {\n                // From traditional interface.\n                $recur_enddate = Horde_Util::getFormData('recur_end');\n            }\n            if ($recurrence->hasRecurEnd()) {\n                $recurEnd = $recurrence->recurEnd;\n                $recurEnd->month = $recur_enddate['month'];\n                $recurEnd->mday = $recur_enddate['day'];\n                $recurEnd->year = $recur_enddate['year'];\n            } else {\n                $recurEnd = new Horde_Date(\n                    array('hour' => 23,\n                          'min' => 59,\n                          'sec' => 59,\n                          'month' => $recur_enddate['month'],\n                          'mday' => $recur_enddate['day'],\n                          'year' => $recur_enddate['year']),\n                    $timezone);\n            }\n            $recurrence->setRecurEnd($recurEnd);\n        } elseif (Horde_Util::getFormData('recur_end_type') == 'count') {\n            $recurrence->setRecurCount(Horde_Util::getFormData('recur_count'));\n        } elseif (Horde_Util::getFormData('recur_end_type') == 'none') {\n            $recurrence->setRecurCount(0);\n            $recurrence->setRecurEnd(null);\n        }\n\n        $recurrence->setRecurType($recur);\n        switch ($recur) {\n        case Horde_Date_Recurrence::RECUR_DAILY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_daily_interval', 1));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_WEEKLY:\n            $weekly = Horde_Util::getFormData('weekly');\n            $weekdays = 0;\n            if (is_array($weekly)) {\n                foreach ($weekly as $day) {\n                    $weekdays |= $day;\n                }\n            }\n\n            if ($weekdays == 0) {\n                // Sunday starts at 0.\n                switch ($start->dayOfWeek()) {\n                case 0: $weekdays |= Horde_Date::MASK_SUNDAY; break;\n                case 1: $weekdays |= Horde_Date::MASK_MONDAY; break;\n                case 2: $weekdays |= Horde_Date::MASK_TUESDAY; break;\n                case 3: $weekdays |= Horde_Date::MASK_WEDNESDAY; break;\n                case 4: $weekdays |= Horde_Date::MASK_THURSDAY; break;\n                case 5: $weekdays |= Horde_Date::MASK_FRIDAY; break;\n                case 6: $weekdays |= Horde_Date::MASK_SATURDAY; break;\n                }\n            }\n\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_weekly_interval', 1));\n            $recurrence->setRecurOnDay($weekdays);\n            break;\n\n        case Horde_Date_Recurrence::RECUR_MONTHLY_DATE:\n            switch (Horde_Util::getFormData('recur_monthly_scheme')) {\n            case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n                $recurrence->setRecurType(Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY);\n            case Horde_Date_Recurrence::RECUR_MONTHLY_DATE:\n                $recurrence->setRecurInterval(\n                    Horde_Util::getFormData('recur_monthly')\n                        ? 1\n                        : Horde_Util::getFormData('recur_monthly_interval', 1)\n                );\n                break;\n            default:\n                $recurrence->setRecurInterval(Horde_Util::getFormData('recur_day_of_month_interval', 1));\n                break;\n            }\n            break;\n\n        case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_week_of_month_interval', 1));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_DATE:\n            switch (Horde_Util::getFormData('recur_yearly_scheme')) {\n            case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            case Horde_Date_Recurrence::RECUR_YEARLY_DAY:\n                $recurrence->setRecurType(Horde_Util::getFormData('recur_yearly_scheme'));\n            case Horde_Date_Recurrence::RECUR_YEARLY_DATE:\n                $recurrence->setRecurInterval(\n                    Horde_Util::getFormData('recur_yearly')\n                        ? 1\n                        : Horde_Util::getFormData('recur_yearly_interval', 1)\n                );\n                break;\n            default:\n                $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_interval', 1));\n                break;\n            }\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_DAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_day_interval', $yearly_interval));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_weekday_interval', $yearly_interval));\n            break;\n        }\n\n        foreach (array('exceptions', 'completions') as $what) {\n            if ($data = Horde_Util::getFormData($what)) {\n                if (!is_array($data)) {\n                    $data = explode(',', $data);\n                }\n                foreach ($data as $date) {\n                    list($year, $month, $mday) = sscanf($date, '%04d%02d%02d');\n                    if ($what == 'exceptions') {\n                        $recurrence->addException($year, $month, $mday);\n                    } else {\n                        $recurrence->addCompletion($year, $month, $mday);\n                    }\n                }\n            }\n        }\n\n        return $recurrence;\n    }\n\n    /**\n     * Handles updating/saving this event's resources. Unless this event recurs,\n     * this will delete this event from any resource calendars that are no\n     * longer needed (as when a resource is removed from an existing event). If\n     * this event is an exception, i.e., contains a baseid, AND $existing is\n     * provided, the resources from the original event are used for purposes\n     * of determining any resources that need to be removed.\n     *\n     *\n     * @param  Kronolith_Event|null $existing  An existing base event.\n     * @since 4.2.6\n     */\n    protected function _handleResources(Kronolith_Event $existing = null)\n    {\n        global $session;\n\n        if (Horde_Util::getFormData('isajax', false)) {\n            $resources = array();\n        } else {\n            $resources = $session->get('kronolith', 'resources', Horde_Session::TYPE_ARRAY);\n        }\n\n        $existingResources = $this->_resources;\n        $newresources = Horde_Util::getFormData('resources');\n        if (!empty($newresources)) {\n            foreach (explode(',', $newresources) as $id) {\n                try {\n                    $resource = Kronolith::getDriver('Resource')->getResource($id);\n                } catch (Kronolith_Exception $e) {\n                    $GLOBALS['notification']->push($e->getMessage(), 'horde.error');\n                    continue;\n                }\n                if (!($resource instanceof Kronolith_Resource_Group) ||\n                    $resource->isFree($this)) {\n                    $resources[$resource->getId()] = array(\n                        'attendance' => Kronolith::PART_REQUIRED,\n                        'response'   => Kronolith::RESPONSE_NONE,\n                        'name'       => $resource->get('name')\n                    );\n                } else {\n                    $GLOBALS['notification']->push(_(\"No resources from this group were available\"), 'horde.error');\n                }\n            }\n        }\n        $this->_resources = $resources;\n\n\n        // Have the base event, and this is an exception so we must\n        // match the recurrence in the resource's copy of the base event.\n        if (!empty($existing) && $existing->recurs() && !$this->recurs()) {\n            foreach ($existing->getResources() as $rid => $data) {\n                $resource = Kronolith::getDriver('Resource')->getResource($key);\n                $r_event = Kronolith::getDriver('Resource')->getByUID($existing->uid, $resource->calendar);\n                $r_event->recurrence = $event->recurrence;\n                $r_event->save();\n            }\n        }\n\n        // If we don't recur, check for removal of any resources so we can\n        // update those resources' calendars.\n        if (!$this->recurs()) {\n            $merged = $existingResources + $this->_resources;\n            $delete = array_diff(array_keys($existingResources), array_keys($this->_resources));\n            foreach ($delete as $key) {\n                // Resource might be declined, in which case it won't have the event\n                // on it's calendar.\n                if ($merged[$key]['response'] != Kronolith::RESPONSE_DECLINED) {\n                    try {\n                        Kronolith::getDriver('Resource')\n                            ->getResource($key)\n                            ->removeEvent($this);\n                    } catch (Kronolith_Exception $e) {\n                        $GLOBALS['notification']->push('foo', 'horde.error');\n                    }\n                }\n            }\n        }\n    }\n\n    public function html($property)\n    {\n        global $prefs;\n\n        $options = array();\n        $attributes = '';\n        $sel = false;\n        $label = '';\n\n        switch ($property) {\n        case 'start[year]':\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"Start Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $this->start->year .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'start[month]':\n            $sel = $this->start->month;\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"Start Month\");\n            break;\n\n        case 'start[day]':\n            $sel = $this->start->mday;\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Start Day\");\n            break;\n\n        case 'start_hour':\n            $sel = $this->start->format($prefs->getValue('twentyFour') ? 'G' : 'g');\n            $hour_min = $prefs->getValue('twentyFour') ? 0 : 1;\n            $hour_max = $prefs->getValue('twentyFour') ? 24 : 13;\n            for ($i = $hour_min; $i < $hour_max; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Start Hour\");\n            break;\n\n        case 'start_min':\n            $sel = sprintf('%02d', $this->start->min);\n            for ($i = 0; $i < 12; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"Start Minute\");\n            break;\n\n        case 'end[year]':\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"End Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $this->end->year .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'end[month]':\n            $sel = $this->end ? $this->end->month : $this->start->month;\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"End Month\");\n            break;\n\n        case 'end[day]':\n            $sel = $this->end ? $this->end->mday : $this->start->mday;\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"End Day\");\n            break;\n\n        case 'end_hour':\n            $sel = $this->end\n                ? $this->end->format($prefs->getValue('twentyFour') ? 'G' : 'g')\n                : $this->start->format($prefs->getValue('twentyFour') ? 'G' : 'g') + 1;\n            $hour_min = $prefs->getValue('twentyFour') ? 0 : 1;\n            $hour_max = $prefs->getValue('twentyFour') ? 24 : 13;\n            for ($i = $hour_min; $i < $hour_max; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"End Hour\");\n            break;\n\n        case 'end_min':\n            $sel = $this->end ? $this->end->min : $this->start->min;\n            $sel = sprintf('%02d', $sel);\n            for ($i = 0; $i < 12; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"End Minute\");\n            break;\n\n        case 'dur_day':\n            $dur = $this->getDuration();\n            return  '<label for=\"' . $property . '\" class=\"hidden\">' . _(\"Duration Day\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $dur->day .\n                '\" type=\"text\"' .\n                ' id=\"' . $property . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'dur_hour':\n            $dur = $this->getDuration();\n            $sel = $dur->hour;\n            for ($i = 0; $i < 24; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Duration Hour\");\n            break;\n\n        case 'dur_min':\n            $dur = $this->getDuration();\n            $sel = $dur->min;\n            for ($i = 0; $i < 13; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"Duration Minute\");\n            break;\n\n        case 'recur_end[year]':\n            if ($this->end) {\n                $end = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                        ? $this->recurrence->recurEnd->year\n                        : $this->end->year;\n            } else {\n                $end = $this->start->year;\n            }\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"Recurrence End Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $end .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'recur_end[month]':\n            if ($this->end) {\n                $sel = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                    ? $this->recurrence->recurEnd->month\n                    : $this->end->month;\n            } else {\n                $sel = $this->start->month;\n            }\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"Recurrence End Month\");\n            break;\n\n        case 'recur_end[day]':\n            if ($this->end) {\n                $sel = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                    ? $this->recurrence->recurEnd->mday\n                    : $this->end->mday;\n            } else {\n                $sel = $this->start->mday;\n            }\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Recurrence End Day\");\n            break;\n        }\n\n        if (!$this->_varRenderer) {\n            $this->_varRenderer = Horde_Core_Ui_VarRenderer::factory('Html');\n        }\n\n        return '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . $label . '</label>' .\n            '<select name=\"' . $property . '\"' . $attributes . ' id=\"' . $this->_formIDEncode($property) . '\">' .\n            $this->_varRenderer->selectOptions($options, $sel) .\n            '</select>';\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getViewUrl($params = array(), $full = false, $encoded = true)\n    {\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->setRaw(!$encoded)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getEditUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'EditEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getDeleteUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'DeleteEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getExportUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'ExportEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    public function getLink($datetime = null, $icons = true, $from_url = null,\n                            $full = false, $encoded = true)\n    {\n        global $prefs;\n\n        if (is_null($datetime)) {\n            $datetime = $this->start;\n        }\n        if (is_null($from_url)) {\n            $from_url = Horde::selfUrl(true, false, true);\n        }\n\n        $event_title = $this->getTitle();\n        $view_url = $this->getViewUrl(array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'), 'url' => $from_url), $full, $encoded);\n        $read_permission = $this->hasPermission(Horde_Perms::READ);\n\n        $link = '<span' . $this->getCSSColors() . '>';\n        if ($read_permission && $view_url) {\n            $link .= Horde::linkTooltip($view_url,\n                                       $event_title,\n                                       $this->getStatusClass(),\n                                       '',\n                                       '',\n                                       $this->getTooltip(),\n                                       '',\n                                       array('style' => $this->getCSSColors(false)));\n        }\n        $link .= htmlspecialchars($event_title);\n        if ($read_permission && $view_url) {\n            $link .= '</a>';\n        }\n\n        if ($icons && $prefs->getValue('show_icons')) {\n            $icon_color = $this->_foregroundColor == '#000' ? '000' : 'fff';\n            $status = '';\n            if ($this->alarm) {\n                if ($this->alarm % 10080 == 0) {\n                    $alarm_value = $this->alarm / 10080;\n                    $title = sprintf(ngettext(\"Alarm %d week before\", \"Alarm %d weeks before\", $alarm_value), $alarm_value);\n                } elseif ($this->alarm % 1440 == 0) {\n                    $alarm_value = $this->alarm / 1440;\n                    $title = sprintf(ngettext(\"Alarm %d day before\", \"Alarm %d days before\", $alarm_value), $alarm_value);\n                } elseif ($this->alarm % 60 == 0) {\n                    $alarm_value = $this->alarm / 60;\n                    $title = sprintf(ngettext(\"Alarm %d hour before\", \"Alarm %d hours before\", $alarm_value), $alarm_value);\n                } else {\n                    $alarm_value = $this->alarm;\n                    $title = sprintf(ngettext(\"Alarm %d minute before\", \"Alarm %d minutes before\", $alarm_value), $alarm_value);\n                }\n                $status .= Horde::fullSrcImg('alarm-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconAlarm')));\n            }\n\n            if ($this->recurs()) {\n                $title = Kronolith::recurToString($this->recurrence->getRecurType());\n                $status .= Horde::fullSrcImg('recur-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconRecur')));\n            } elseif ($this->baseid) {\n                $title = _(\"Exception\");\n                $status .= Horde::fullSrcImg('exception-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconRecur')));\n            }\n\n            if ($this->private) {\n                $title = _(\"Private event\");\n                $status .= Horde::fullSrcImg('private-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconPrivate')));\n            }\n\n            if (!empty($this->attendees)) {\n                $status .= Horde::fullSrcImg('attendees-' . $icon_color . '.png', array('attr' => array('alt' => _(\"Meeting\"), 'title' => _(\"Meeting\"), 'class' => 'iconPeople')));\n            }\n\n            $space = ' ';\n            if (!empty($this->icon)) {\n                $link = $status . ' <img class=\"kronolithEventIcon\" src=\"' . $this->icon . '\" /> ' . $link;\n            } elseif (!empty($status)) {\n                $link .= ' ' . $status;\n                $space = '';\n            }\n\n            if ((!$this->private ||\n                 $this->creator == $GLOBALS['registry']->getAuth()) &&\n                Kronolith::getDefaultCalendar(Horde_Perms::EDIT)) {\n                $url = $this->getEditUrl(\n                    array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'),\n                          'url' => $from_url),\n                    $full);\n                if ($url) {\n                    $link .= $space\n                        . $url->link(array('title' => sprintf(_(\"Edit %s\"), $event_title),\n                                           'class' => 'iconEdit'))\n                        . Horde::fullSrcImg('edit-' . $icon_color . '.png',\n                                            array('attr' => array('alt' => _(\"Edit\"))))\n                        . '</a>';\n                    $space = '';\n                }\n            }\n            if ($this->hasPermission(Horde_Perms::DELETE)) {\n                $url = $this->getDeleteUrl(\n                    array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'),\n                          'url' => $from_url),\n                    $full);\n                if ($url) {\n                    $link .= $space\n                        . $url->link(array('title' => sprintf(_(\"Delete %s\"), $event_title),\n                                           'class' => 'iconDelete'))\n                        . Horde::fullSrcImg('delete-' . $icon_color . '.png',\n                                            array('attr' => array('alt' => _(\"Delete\"))))\n                        . '</a>';\n                }\n            }\n        }\n\n        return $link . '</span>';\n    }\n\n    /**\n     * Returns the CSS color definition for this event.\n     *\n     * @param boolean $with_attribute  Whether to wrap the colors inside a\n     *                                 \"style\" attribute.\n     *\n     * @return string  A CSS string with color definitions.\n     */\n    public function getCSSColors($with_attribute = true)\n    {\n        $css = 'background-color:' . $this->_backgroundColor . ';color:' . $this->_foregroundColor;\n        if ($with_attribute) {\n            $css = ' style=\"' . $css . '\"';\n        }\n        return $css;\n    }\n\n    /**\n     * @return string  A tooltip for quick descriptions of this event.\n     */\n    public function getTooltip()\n    {\n        $tooltip = $this->getTimeRange()\n            . \"\\n\" . sprintf(_(\"Owner: %s\"), ($this->creator == $GLOBALS['registry']->getAuth() ?\n                                              _(\"Me\") : Kronolith::getUserName($this->creator)));\n\n        if (!$this->isPrivate()) {\n            if ($this->location) {\n                $tooltip .= \"\\n\" . _(\"Location\") . ': ' . $this->location;\n            }\n\n            if ($this->description) {\n                $tooltip .= \"\\n\\n\" . Horde_String::wrap($this->description);\n            }\n        }\n\n        return $tooltip;\n    }\n\n    /**\n     * @return string  The time range of the event (\"All Day\", \"1:00pm-3:00pm\",\n     *                 \"08:00-22:00\").\n     */\n    public function getTimeRange()\n    {\n        if ($this->isAllDay()) {\n            return _(\"All day\");\n        } elseif (($cmp = $this->start->compareDate($this->end)) > 0) {\n            $df = $GLOBALS['prefs']->getValue('date_format');\n            if ($cmp > 0) {\n                return $this->end->strftime($df) . '-'\n                    . $this->start->strftime($df);\n            } else {\n                return $this->start->strftime($df) . '-'\n                    . $this->end->strftime($df);\n            }\n        } else {\n            $twentyFour = $GLOBALS['prefs']->getValue('twentyFour');\n            return $this->start->format($twentyFour ? 'G:i' : 'g:ia')\n                . '-'\n                . $this->end->format($twentyFour ? 'G:i' : 'g:ia');\n        }\n    }\n\n    /**\n     * @return string  The CSS class for the event based on its status.\n     */\n    public function getStatusClass()\n    {\n        switch ($this->status) {\n        case Kronolith::STATUS_CANCELLED:\n            return 'kronolith-event-cancelled';\n\n        case Kronolith::STATUS_TENTATIVE:\n        case Kronolith::STATUS_FREE:\n            return 'kronolith-event-tentative';\n        }\n    }\n\n    protected function _formIDEncode($id)\n    {\n        return str_replace(array('[', ']'),\n                           array('_', ''),\n                           $id);\n    }\n\n    /**\n     * Ensure the given string is valid UTF-8.\n     *\n     * @param string $text  The string to ensure contains no invalid UTF-8 sequences.\n     *\n     * @return string|boolean  The valid UTF-8 string, possibly with illegal sequences removed.\n     */\n    protected function _ensureUtf8($text)\n    {\n        if (Horde_String::validUtf8($text)) {\n            return $text;\n        }\n\n        return preg_replace('/[^\\x09\\x0A\\x0D\\x20-\\x7E]/', '', $text);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Kronolith_Event defines a generic API for events.\n *\n * Copyright 1999-2017 Horde LLC (http://www.horde.org/)\n *\n * See the enclosed file COPYING for license information (GPL). If you\n * did not receive this file, see http://www.horde.org/licenses/gpl.\n *\n * @author  Chuck Hagenbuch <chuck@horde.org>\n * @author  Jan Schneider <jan@horde.org>\n * @package Kronolith\n */\nabstract class Kronolith_Event\n{\n    /**\n     * Flag that is set to true if this event has data from either a storage\n     * backend or a form or other import method.\n     *\n     * @var boolean\n     */\n    public $initialized = false;\n\n    /**\n     * Flag that is set to true if this event exists in a storage driver.\n     *\n     * @var boolean\n     */\n    public $stored = false;\n\n    /**\n     * The driver unique identifier for this event.\n     *\n     * @var string\n     */\n    protected $_id = null;\n\n    /**\n     * The UID for this event.\n     *\n     * @var string\n     */\n    public $uid = null;\n\n    /**\n     * The iCalendar SEQUENCE for this event.\n     *\n     * @var integer\n     */\n    public $sequence = null;\n\n    /**\n     * The user id of the creator of the event.\n     *\n     * @var string\n     */\n    protected $_creator = null;\n\n    /**\n     * The title of this event.\n     *\n     * For displaying in the interface use getTitle() instead.\n     *\n     * @var string\n     */\n    public $title = '';\n\n    /**\n     * The location this event occurs at.\n     *\n     * @var string\n     */\n    public $location = '';\n\n    /**\n     * The timezone of this event.\n     *\n     * @var string\n     */\n    public $timezone;\n\n    /**\n     * The status of this event.\n     *\n     * @var integer\n     */\n    public $status = Kronolith::STATUS_CONFIRMED;\n\n    /**\n     * URL to an icon of this event.\n     *\n     * @var string\n     */\n    public $icon = '';\n\n    /**\n     * The description for this event.\n     *\n     * @var string\n     */\n    public $description = '';\n\n    /**\n     * URL of this event.\n     *\n     * @var string\n     */\n    public $url = '';\n\n    /**\n     * Whether the event is private.\n     *\n     * @var boolean\n     */\n    public $private = false;\n\n    /**\n     * Event tags from the storage backend (e.g. Kolab)\n     *\n     * @var array\n     */\n    protected $_internaltags;\n\n    /**\n     * This tag's events.\n     *\n     * @var array|string\n     */\n    protected $_tags = null;\n\n    /**\n     * Geolocation\n     *\n     * @var array\n     */\n    protected $_geoLocation;\n\n    /**\n     * Whether this is the event on the first day of a multi-day event.\n     *\n     * @var boolen\n     */\n    public $first = true;\n\n    /**\n     * Whether this is the event on the last day of a multi-day event.\n     *\n     * @var boolen\n     */\n    public $last = true;\n\n    /**\n     * All the attendees of this event.\n     *\n     * This is an associative array where the keys are the email addresses\n     * of the attendees, and the values are also associative arrays with\n     * keys 'attendance' and 'response' pointing to the attendees' attendance\n     * and response values, respectively.\n     *\n     * @var array\n     */\n    public $attendees = array();\n\n    /**\n     * All resources of this event.\n     *\n     * This is an associative array where keys are resource uids, values are\n     * associative arrays with keys attendance and response.\n     *\n     * @var array\n     */\n    protected $_resources = array();\n\n    /**\n     * The start time of the event.\n     *\n     * @var Horde_Date\n     */\n    public $start;\n\n    /**\n     * The end time of the event.\n     *\n     * @var Horde_Date\n     */\n    public $end;\n\n    /**\n     * The original start time of the event.\n     *\n     * This may differ from $start on multi-day events where $start is the\n     * start time on the current day. For recurring events this is the start\n     * time of the current recurrence.\n     *\n     * @var Horde_Date\n     */\n    protected $_originalStart;\n\n    /**\n     * The original end time of the event.\n     *\n     * @see $_originalStart for details.\n     *\n     * @var Horde_Date\n     */\n    protected $_originalEnd;\n\n    /**\n     * The duration of this event in minutes\n     *\n     * @var integer\n     */\n    public $durMin = 0;\n\n    /**\n     * Whether this is an all-day event.\n     *\n     * @var boolean\n     */\n    public $allday = false;\n\n    /**\n     * The creation time.\n     *\n     * @see loadHistory()\n     * @var Horde_Date\n     */\n    public $created;\n\n    /**\n     * The creator string.\n     *\n     * @see loadHistory()\n     * @var string\n     */\n    public $createdby;\n\n    /**\n     * The last modification time.\n     *\n     * @see loadHistory()\n     * @var Horde_Date\n     */\n    public $modified;\n\n    /**\n     * The last-modifier string.\n     *\n     * @see loadHistory()\n     * @var string\n     */\n    public $modifiedby;\n\n    /**\n     * Number of minutes before the event starts to trigger an alarm.\n     *\n     * @var integer\n     */\n    public $alarm = 0;\n\n    /**\n     * Snooze minutes for this event's alarm.\n     *\n     * @see Horde_Alarm::snooze()\n     *\n     * @var integer\n     */\n    protected $_snooze;\n\n    /**\n     * The particular alarm methods overridden for this event.\n     *\n     * @var array\n     */\n    public $methods;\n\n    /**\n     * The identifier of the calender this event exists on.\n     *\n     * @var string\n     */\n    public $calendar;\n\n    /**\n     * The type of the calender this event exists on.\n     *\n     * @var string\n     */\n    public $calendarType;\n\n    /**\n     * The HTML background color to be used for this event.\n     *\n     * @var string\n     */\n    protected $_backgroundColor = '#dddddd';\n\n    /**\n     * The HTML foreground color to be used for this event.\n     *\n     * @var string\n     */\n    protected $_foregroundColor = '#000000';\n\n    /**\n     * The VarRenderer class to use for printing select elements.\n     *\n     * @var Horde_Core_Ui_VarRenderer\n     */\n    private $_varRenderer;\n\n    /**\n     * The Horde_Date_Recurrence class for this event.\n     *\n     * @var Horde_Date_Recurrence\n     */\n    public $recurrence;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_overlap;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_indent;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_span;\n\n    /**\n     * Used in view renderers.\n     *\n     * @var integer\n     */\n    protected $_rowspan;\n\n    /**\n     * The baseid. For events that represent exceptions this is the UID of the\n     * original, recurring event.\n     *\n     * @var string\n     */\n    public $baseid;\n\n    /**\n     * For exceptions, the date of the original recurring event that this is an\n     * exception for.\n     *\n     * @var Horde_Date\n     */\n    public $exceptionoriginaldate;\n\n    /**\n     * The cached event duration, split up in time units.\n     *\n     * @see getDuration()\n     * @var stdClass\n     */\n    protected $_duration;\n\n    /**\n     * Constructor.\n     *\n     * @param Kronolith_Driver $driver  The backend driver that this event is\n     *                                  stored in.\n     * @param mixed $eventObject        Backend specific event object\n     *                                  that this will represent.\n     */\n    public function __construct(Kronolith_Driver $driver, $eventObject = null)\n    {\n        $this->calendar = $driver->calendar;\n        list($this->_backgroundColor, $this->_foregroundColor) = $driver->colors();\n\n        if (!is_null($eventObject)) {\n            $this->fromDriver($eventObject);\n        }\n    }\n\n    /**\n     * Retrieves history information for this event from the history backend.\n     */\n    public function loadHistory()\n    {\n        try {\n            $log = $GLOBALS['injector']->getInstance('Horde_History')\n                ->getHistory('kronolith:' . $this->calendar . ':' . $this->uid);\n            $userId = $GLOBALS['registry']->getAuth();\n            foreach ($log as $entry) {\n                switch ($entry['action']) {\n                case 'add':\n                    $this->created = new Horde_Date($entry['ts']);\n                    if ($userId != $entry['who']) {\n                        $this->createdby = sprintf(_(\"by %s\"), Kronolith::getUserName($entry['who']));\n                    } else {\n                        $this->createdby = _(\"by me\");\n                    }\n                    break;\n\n                case 'modify':\n                    if ($this->modified &&\n                        $this->modified->timestamp() >= $entry['ts']) {\n                        break;\n                    }\n                    $this->modified = new Horde_Date($entry['ts']);\n                    if ($userId != $entry['who']) {\n                        $this->modifiedby = sprintf(_(\"by %s\"), Kronolith::getUserName($entry['who']));\n                    } else {\n                        $this->modifiedby = _(\"by me\");\n                    }\n                    break;\n                }\n            }\n        } catch (Horde_Exception $e) {\n        }\n    }\n\n    /**\n     * Setter.\n     *\n     * Sets the 'id' and 'creator' properties.\n     *\n     * @param string $name  Property name.\n     * @param mixed $value  Property value.\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n        case 'id':\n            if (substr($value, 0, 10) == 'kronolith:') {\n                $value = substr($value, 10);\n            }\n            // Fall through.\n        case 'creator':\n        case 'geoLocation':\n        case 'indent':\n        case 'originalStart':\n        case 'originalEnd':\n        case 'overlap':\n        case 'rowspan':\n        case 'span':\n        case 'tags':\n            $this->{'_' . $name} = $value;\n            return;\n        }\n        $trace = debug_backtrace();\n        trigger_error('Undefined property via __set(): ' . $name\n                      . ' in ' . $trace[0]['file']\n                      . ' on line ' . $trace[0]['line'],\n                      E_USER_NOTICE);\n    }\n\n    /**\n     * Getter.\n     *\n     * Returns the 'id' and 'creator' properties.\n     *\n     * @param string $name  Property name.\n     *\n     * @return mixed  Property value.\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n        case 'id':\n        case 'indent':\n        case 'overlap':\n        case 'rowspan':\n        case 'span':\n            return $this->{'_' . $name};\n        case 'creator':\n            if (empty($this->_creator)) {\n                $this->_creator = $GLOBALS['registry']->getAuth();\n            }\n            return $this->_creator;\n            break;\n        case 'originalStart':\n            if (empty($this->_originalStart)) {\n                $this->_originalStart = $this->start;\n            }\n            return $this->_originalStart;\n            break;\n        case 'originalEnd':\n            if (empty($this->_originalEnd)) {\n                $this->_originalEnd = $this->start;\n            }\n            return $this->_originalEnd;\n            break;\n        case 'tags':\n            if (!isset($this->_tags)) {\n                $this->synchronizeTags(Kronolith::getTagger()->getTags($this->uid, Kronolith_Tagger::TYPE_EVENT));\n            }\n            return $this->_tags;\n        case 'geoLocation':\n            if (!isset($this->_geoLocation)) {\n                try {\n                    $this->_geoLocation = $GLOBALS['injector']->getInstance('Kronolith_Geo')->getLocation($this->id);\n                } catch (Kronolith_Exception $e) {}\n            }\n            return $this->_geoLocation;\n        }\n\n        $trace = debug_backtrace();\n        trigger_error('Undefined property via __set(): ' . $name\n                      . ' in ' . $trace[0]['file']\n                      . ' on line ' . $trace[0]['line'],\n                      E_USER_NOTICE);\n        return null;\n    }\n\n    /**\n     * Returns a reference to a driver that's valid for this event.\n     *\n     * @return Kronolith_Driver  A driver that this event can use to save\n     *                           itself, etc.\n     */\n    public function getDriver()\n    {\n        return Kronolith::getDriver(str_replace('Kronolith_Event_', '', get_class($this)), $this->calendar);\n    }\n\n    /**\n     * Returns the share this event belongs to.\n     *\n     * @return Horde_Share  This event's share.\n     * @throws Kronolith_Exception\n     */\n    public function getShare()\n    {\n        if ($GLOBALS['calendar_manager']->getEntry(Kronolith::ALL_CALENDARS, $this->calendar) !== false) {\n            return $GLOBALS['calendar_manager']->getEntry(Kronolith::ALL_CALENDARS, $this->calendar)->share();\n        }\n        throw new LogicException('Share not found');\n    }\n\n    /**\n     * Encapsulates permissions checking.\n     *\n     * @param integer $permission  The permission to check for.\n     * @param string $user         The user to check permissions for.\n     *\n     * @return boolean\n     */\n    public function hasPermission($permission, $user = null)\n    {\n        if ($user === null) {\n            $user = $GLOBALS['registry']->getAuth();\n        }\n        try {\n            $share = $this->getShare();\n        } catch (Exception $e) {\n            return false;\n        }\n        return $share->hasPermission($user, $permission, $this->creator);\n    }\n\n    /**\n     * Saves changes to this event.\n     *\n     * @return integer  The event id.\n     * @throws Kronolith_Exception\n     */\n    public function save()\n    {\n        if (!$this->initialized) {\n            throw new LogicException('Event not yet initialized');\n        }\n\n        /* Check for acceptance/denial of this event's resources. */\n        $accepted_resources = array();\n        $locks = $GLOBALS['injector']->getInstance('Horde_Lock');\n        $lock = array();\n        // Don't waste time with resource acceptance if the status is cancelled,\n        // the event will be removed from the resource calendar anyway.\n        if ($this->status != Kronolith::STATUS_CANCELLED) {\n            foreach (array_keys($this->getResources()) as $id) {\n                /* Get the resource and protect against infinite recursion in\n                 * case someone is silly enough to add a resource to it's own\n                 * event.*/\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                $rcal = $resource->get('calendar');\n                if ($rcal == $this->calendar) {\n                    continue;\n                }\n                Kronolith::getDriver('Resource')->open($rcal);\n\n                /* Lock the resource and get the response */\n                if ($resource->get('response_type') == Kronolith_Resource::RESPONSETYPE_AUTO) {\n                    $principle = 'calendar/' . $rcal;\n                    $lock[$resource->getId()] = $locks->setLock($GLOBALS['registry']->getAuth(), 'kronolith', $principle, 5, Horde_Lock::TYPE_EXCLUSIVE);\n                    $haveLock = true;\n                } else {\n                    $haveLock = false;\n                }\n                if ($haveLock && !$lock[$resource->getId()]) {\n                    // Already locked\n                    // For now, just fail. Not sure how else to capture the\n                    // locked resources and notify the user.\n                    throw new Kronolith_Exception(sprintf(_(\"The resource \\\"%s\\\" was locked. Please try again.\"), $resource->get('name')));\n                } else {\n                    $response = $resource->getResponse($this);\n                }\n\n                /* Remember accepted resources so we can add the event to their\n                 * calendars. Otherwise, clear the lock. */\n                if ($response == Kronolith::RESPONSE_ACCEPTED) {\n                    $accepted_resources[] = $resource;\n                } elseif ($haveLock) {\n                    $locks->clearLock($lock[$resource->getId()]);\n                }\n\n                if ($response == Kronolith::RESPONSE_DECLINED && $this->uid) {\n                    $r_driver = Kronolith::getDriver('Resource');\n                    $r_event = $r_driver->getByUID($this->uid, array($resource->get('calendar')));\n                    $r_driver->deleteEvent($r_event, true, true);\n                }\n\n                /* Add the resource to the event */\n                $this->addResource($resource, $response);\n            }\n        } else {\n            // If event is cancelled, and actually exists, we need to mark it\n            // as cancelled in resource calendar.\n            foreach (array_keys($this->getResources()) as $id) {\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                $rcal = $resource->get('calendar');\n                if ($rcal == $this->calendar) {\n                    continue;\n                }\n                try {\n                    Kronolith::getDriver('Resource')->open($rcal);\n                    $resource->addEvent($this);\n                } catch (Exception $e) {\n                }\n            }\n        }\n\n        /* Save */\n        $result = $this->getDriver()->saveEvent($this);\n\n        /* Now that the event is definitely commited to storage, we can add\n         * the event to each resource that has accepted. Not very efficient,\n         * but this also solves the problem of not having a GUID for the event\n         * until after it's saved. If we add the event to the resources\n         * calendar before it is saved, they will have different GUIDs, and\n         * hence no longer refer to the same event. */\n        foreach ($accepted_resources as $resource) {\n            $resource->addEvent($this);\n            if ($resource->get('response_type') == Kronolith_Resource::RESPONSETYPE_AUTO) {\n                $locks->clearLock($lock[$resource->getId()]);\n            }\n        }\n\n        $hordeAlarm = $GLOBALS['injector']->getInstance('Horde_Alarm');\n        if ($alarm = $this->toAlarm(new Horde_Date($_SERVER['REQUEST_TIME']))) {\n            $hordeAlarm->set($alarm);\n            if ($this->_snooze) {\n                $hordeAlarm->snooze($this->uid, $GLOBALS['registry']->getAuth(), $this->_snooze);\n            }\n        } else {\n            $hordeAlarm->delete($this->uid);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Imports a backend specific event object.\n     *\n     * @param mixed $eventObject  Backend specific event object that this\n     *                            object will represent.\n     */\n    public function fromDriver($event)\n    {\n    }\n\n    /**\n     * Exports this event in iCalendar format.\n     *\n     * @param Horde_Icalendar $calendar  A Horde_Icalendar object that acts as\n     *                                   a container.\n     *\n     * @return array  An array of Horde_Icalendar_Vevent objects for this event.\n     */\n    public function toiCalendar($calendar)\n    {\n        $vEvent = Horde_Icalendar::newComponent('vevent', $calendar);\n        $v1 = $calendar->getAttribute('VERSION') == '1.0';\n        $vEvents = array();\n\n        // For certain recur types, we must output in the event's timezone\n        // so that the BYDAY values do not get out of sync with the UTC\n        // date-time. See Bug: 11339\n        if ($this->recurs()) {\n            switch ($this->recurrence->getRecurType()) {\n            case Horde_Date_Recurrence::RECUR_WEEKLY:\n            case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n                if (!$this->timezone) {\n                    $this->timezone = date_default_timezone_get();\n                }\n            }\n        }\n\n        if ($this->isAllDay()) {\n            $vEvent->setAttribute('DTSTART', $this->start, array('VALUE' => 'DATE'));\n            $vEvent->setAttribute('DTEND', $this->end, array('VALUE' => 'DATE'));\n            $vEvent->setAttribute('X-FUNAMBOL-ALLDAY', 1);\n        } else {\n            $this->setTimezone(true);\n            $params = array();\n            if ($this->timezone) {\n                try {\n                    if (!$this->baseid) {\n                        $tz = $GLOBALS['injector']->getInstance('Horde_Timezone');\n                        $vEvents[] = $tz->getZone($this->timezone)->toVtimezone();\n                    }\n                    $params['TZID'] = $this->timezone;\n                } catch (Horde_Exception $e) {\n                    Horde::log('Unable to locate the tz database.', 'WARN');\n                }\n            }\n\n            $vEvent->setAttribute('DTSTART', clone $this->start, $params);\n            $vEvent->setAttribute('DTEND', clone $this->end, $params);\n        }\n\n        $vEvent->setAttribute('DTSTAMP', $_SERVER['REQUEST_TIME']);\n        $vEvent->setAttribute('UID', $this->uid);\n\n        /* Get the event's create and last modify date. */\n        $created = $modified = null;\n        try {\n            $history = $GLOBALS['injector']->getInstance('Horde_History');\n            $created = $history->getActionTimestamp(\n                'kronolith:' . $this->calendar . ':' . $this->uid, 'add');\n            $modified = $history->getActionTimestamp(\n                'kronolith:' . $this->calendar . ':' . $this->uid, 'modify');\n            /* The history driver returns 0 for not found. If 0 or null does\n             * not matter, strip this. */\n            if ($created == 0) {\n                $created = null;\n            }\n            if ($modified == 0) {\n                $modified = null;\n            }\n        } catch (Exception $e) {\n        }\n        if (!empty($created)) {\n            $vEvent->setAttribute($v1 ? 'DCREATED' : 'CREATED', $created);\n            if (empty($modified)) {\n                $modified = $created;\n            }\n        }\n        if (!empty($modified)) {\n            $vEvent->setAttribute('LAST-MODIFIED', $modified);\n        }\n\n        $vEvent->setAttribute('SUMMARY', $this->getTitle());\n\n        // Organizer\n        if (count($this->attendees)) {\n            $name = Kronolith::getUserName($this->creator);\n            $email = Kronolith::getUserEmail($this->creator);\n            $params = array();\n            if ($v1) {\n                $tmp = new Horde_Mail_Rfc822_Address($email);\n                if (!empty($name)) {\n                    $tmp->personal = $name;\n                }\n                $email = strval($tmp);\n            } else {\n                if (!empty($name)) {\n                    $params['CN'] = $name;\n                }\n                if (!empty($email)) {\n                    $email = 'mailto:' . $email;\n                }\n            }\n            $vEvent->setAttribute('ORGANIZER', $email, $params);\n        }\n        if (!$this->isPrivate()) {\n            if (!empty($this->description)) {\n                $vEvent->setAttribute('DESCRIPTION', $this->description);\n            }\n\n            // Tags\n            if ($this->tags) {\n                $vEvent->setAttribute('CATEGORIES', '', array(), true, array_values($this->tags));\n            }\n\n            // Location\n            if (!empty($this->location)) {\n                $vEvent->setAttribute('LOCATION', $this->location);\n            }\n            if ($this->geoLocation) {\n                $vEvent->setAttribute('GEO', array('latitude' => $this->geoLocation['lat'], 'longitude' => $this->geoLocation['lon']));\n            }\n\n            // URL\n            if (!empty($this->url)) {\n                $vEvent->setAttribute('URL', $this->url);\n            }\n        }\n        $vEvent->setAttribute('CLASS', $this->private ? 'PRIVATE' : 'PUBLIC');\n\n        // Status.\n        switch ($this->status) {\n        case Kronolith::STATUS_FREE:\n            // This is not an official iCalendar value, but we need it for\n            // synchronization.\n            $vEvent->setAttribute('STATUS', 'FREE');\n            $vEvent->setAttribute('TRANSP', $v1 ? 1 : 'TRANSPARENT');\n            break;\n        case Kronolith::STATUS_TENTATIVE:\n            $vEvent->setAttribute('STATUS', 'TENTATIVE');\n            $vEvent->setAttribute('TRANSP', $v1 ? 0 : 'OPAQUE');\n            break;\n        case Kronolith::STATUS_CONFIRMED:\n            $vEvent->setAttribute('STATUS', 'CONFIRMED');\n            $vEvent->setAttribute('TRANSP', $v1 ? 0 : 'OPAQUE');\n            break;\n        case Kronolith::STATUS_CANCELLED:\n            if ($v1) {\n                $vEvent->setAttribute('STATUS', 'DECLINED');\n                $vEvent->setAttribute('TRANSP', 1);\n            } else {\n                $vEvent->setAttribute('STATUS', 'CANCELLED');\n                $vEvent->setAttribute('TRANSP', 'TRANSPARENT');\n            }\n            break;\n        }\n\n        // Attendees.\n        foreach ($this->attendees as $email => $status) {\n            $params = array();\n            switch ($status['attendance']) {\n            case Kronolith::PART_REQUIRED:\n                if ($v1) {\n                    $params['EXPECT'] = 'REQUIRE';\n                } else {\n                    $params['ROLE'] = 'REQ-PARTICIPANT';\n                }\n                break;\n\n            case Kronolith::PART_OPTIONAL:\n                if ($v1) {\n                    $params['EXPECT'] = 'REQUEST';\n                } else {\n                    $params['ROLE'] = 'OPT-PARTICIPANT';\n                }\n                break;\n\n            case Kronolith::PART_NONE:\n                if ($v1) {\n                    $params['EXPECT'] = 'FYI';\n                } else {\n                    $params['ROLE'] = 'NON-PARTICIPANT';\n                }\n                break;\n            }\n\n            switch ($status['response']) {\n            case Kronolith::RESPONSE_NONE:\n                if ($v1) {\n                    $params['STATUS'] = 'NEEDS ACTION';\n                    $params['RSVP'] = 'YES';\n                } else {\n                    $params['PARTSTAT'] = 'NEEDS-ACTION';\n                    $params['RSVP'] = 'TRUE';\n                }\n                break;\n\n            case Kronolith::RESPONSE_ACCEPTED:\n                if ($v1) {\n                    $params['STATUS'] = 'ACCEPTED';\n                } else {\n                    $params['PARTSTAT'] = 'ACCEPTED';\n                }\n                break;\n\n            case Kronolith::RESPONSE_DECLINED:\n                if ($v1) {\n                    $params['STATUS'] = 'DECLINED';\n                } else {\n                    $params['PARTSTAT'] = 'DECLINED';\n                }\n                break;\n\n            case Kronolith::RESPONSE_TENTATIVE:\n                if ($v1) {\n                    $params['STATUS'] = 'TENTATIVE';\n                } else {\n                    $params['PARTSTAT'] = 'TENTATIVE';\n                }\n                break;\n            }\n\n            if (strpos($email, '@') === false) {\n                $email = '';\n            }\n            if ($v1) {\n                if (empty($email)) {\n                    if (!empty($status['name'])) {\n                        $email = $status['name'];\n                    }\n                } else {\n                    $tmp = new Horde_Mail_Rfc822_Address($email);\n                    if (!empty($status['name'])) {\n                        $tmp->personal = $status['name'];\n                    }\n                    $email = strval($tmp);\n                }\n            } else {\n                if (!empty($status['name'])) {\n                    $params['CN'] = $status['name'];\n                }\n                if (!empty($email)) {\n                    $email = 'mailto:' . $email;\n                }\n            }\n\n            $vEvent->setAttribute('ATTENDEE', $email, $params);\n        }\n\n        // Alarms.\n        if (!empty($this->alarm)) {\n            if ($v1) {\n                $alarm = new Horde_Date($this->start);\n                $alarm->min -= $this->alarm;\n                $vEvent->setAttribute('AALARM', $alarm);\n            } else {\n                $vAlarm = Horde_Icalendar::newComponent('valarm', $vEvent);\n                $vAlarm->setAttribute('ACTION', 'DISPLAY');\n                $vAlarm->setAttribute('DESCRIPTION', $this->getTitle());\n                $vAlarm->setAttribute(\n                    'TRIGGER;VALUE=DURATION',\n                    ($this->alarm > 0 ? '-' : '') . 'PT' . abs($this->alarm) . 'M'\n                );\n                $vEvent->addComponent($vAlarm);\n            }\n            $hordeAlarm = $GLOBALS['injector']->getInstance('Horde_Alarm');\n            if ($hordeAlarm->exists($this->uid, $GLOBALS['registry']->getAuth()) &&\n                $hordeAlarm->isSnoozed($this->uid, $GLOBALS['registry']->getAuth())) {\n                $vEvent->setAttribute('X-MOZ-LASTACK', new Horde_Date($_SERVER['REQUEST_TIME']));\n                $alarm = $hordeAlarm->get($this->uid, $GLOBALS['registry']->getAuth());\n                if (!empty($alarm['snooze'])) {\n                    $alarm['snooze']->setTimezone(date_default_timezone_get());\n                    $vEvent->setAttribute('X-MOZ-SNOOZE-TIME', $alarm['snooze']);\n                }\n            }\n        }\n\n        // Recurrence.\n        if ($this->recurs()) {\n            if ($v1) {\n                $rrule = $this->recurrence->toRRule10($calendar);\n            } else {\n                $rrule = $this->recurrence->toRRule20($calendar);\n            }\n            if (!empty($rrule)) {\n                $vEvent->setAttribute('RRULE', $rrule);\n            }\n\n            // Exceptions. An exception with no replacement event is represented\n            // by EXDATE, and those with replacement events are represented by\n            // a new vEvent element. We get all known replacement events first,\n            // then remove the exceptionoriginaldate from the list of the event\n            // exceptions. Any exceptions left should represent exceptions with\n            // no replacement.\n            $exceptions = $this->recurrence->getExceptions();\n            $search = new stdClass();\n            $search->baseid = $this->uid;\n            $results = $this->getDriver()->search($search);\n            foreach ($results as $days) {\n                foreach ($days as $exceptionEvent) {\n                    // Need to change the UID so it links to the original\n                    // recurring event, but only if not using $v1. If using $v1,\n                    // we add the date to EXDATE and do NOT change the UID.\n                    if (!$v1) {\n                        $exceptionEvent->uid = $this->uid;\n                    }\n                    $vEventException = $exceptionEvent->toiCalendar($calendar);\n\n                    // This should never happen, but protect against it anyway.\n                    if (count($vEventException) > 2 ||\n                        (count($vEventException) > 1 &&\n                         !($vEventException[0] instanceof Horde_Icalendar_Vtimezone) &&\n                         !($vEventException[1] instanceof Horde_Icalendar_Vtimezone))) {\n                        throw new Kronolith_Exception(_(\"Unable to parse event.\"));\n                    }\n                    $vEventException = array_pop($vEventException);\n                    // If $v1, need to add to EXDATE\n                    if (!$this->isAllDay()) {\n                        $exceptionEvent->setTimezone(true);\n                    }\n                    if (!$v1) {\n                        $vEventException->setAttribute('RECURRENCE-ID', $exceptionEvent->exceptionoriginaldate);\n                    } else {\n                        $vEvent->setAttribute('EXDATE', array($exceptionEvent->exceptionoriginaldate), array('VALUE' => 'DATE'));\n                    }\n                    $originaldate = $exceptionEvent->exceptionoriginaldate->format('Ymd');\n                    $key = array_search($originaldate, $exceptions);\n                    if ($key !== false) {\n                        unset($exceptions[$key]);\n                    }\n                    $vEvents[] = $vEventException;\n                }\n            }\n\n            /* The remaining exceptions represent deleted recurrences */\n            foreach ($exceptions as $exception) {\n                if (!empty($exception)) {\n                    // Use multiple EXDATE attributes instead of EXDATE\n                    // attributes with multiple values to make Apple iCal\n                    // happy.\n                    list($year, $month, $mday) = sscanf($exception, '%04d%02d%02d');\n                    if ($this->isAllDay()) {\n                        $vEvent->setAttribute('EXDATE', array(new Horde_Date($year, $month, $mday)), array('VALUE' => 'DATE'));\n                    } else {\n                        // Another Apple iCal/Calendar fix. EXDATE is only\n                        // recognized if the full datetime is present and matches\n                        // the time part given in DTSTART.\n                        $params = array();\n                        if ($this->timezone) {\n                            $params['TZID'] = $this->timezone;\n                        }\n                        $exdate = clone $this->start;\n                        $exdate->year = $year;\n                        $exdate->month = $month;\n                        $exdate->mday = $mday;\n                        $vEvent->setAttribute('EXDATE', array($exdate), $params);\n                    }\n                }\n            }\n        }\n        array_unshift($vEvents, $vEvent);\n\n        $this->setTimezone(false);\n\n        return $vEvents;\n    }\n\n    /**\n     * Updates the properties of this event from a Horde_Icalendar_Vevent\n     * object.\n     *\n     * @param Horde_Icalendar_Vevent $vEvent  The iCalendar data to update\n     *                                        from.\n     * @param boolean $parseAttendees         Parse attendees too?\n     *                                        @since Kronolith 4.2\n     */\n    public function fromiCalendar($vEvent, $parseAttendees = false)\n    {\n        // Unique ID.\n        try {\n            $uid = $vEvent->getAttribute('UID');\n            if (!empty($uid)) {\n                $this->uid = $uid;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Sequence.\n        try {\n            $seq = $vEvent->getAttribute('SEQUENCE');\n            if (is_int($seq)) {\n                $this->sequence = $seq;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Title, tags and description.\n        try {\n            $title = $this->_ensureUtf8($vEvent->getAttribute('SUMMARY'));\n            if (!is_array($title)) {\n                $this->title = $title;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Tags\n        try {\n            $this->_tags = $vEvent->getAttributeValues('CATEGORIES');\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Description\n        try {\n            $desc = $this->_ensureUtf8($vEvent->getAttribute('DESCRIPTION'));\n            if (!is_array($desc)) {\n                $this->description = $desc;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Remote Url\n        try {\n            $url = $vEvent->getAttribute('URL');\n            if (!is_array($url)) {\n                $this->url = $url;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Location\n        try {\n            $location = $this->_ensureUtf8($vEvent->getAttribute('LOCATION'));\n            if (!is_array($location)) {\n                $this->location = $location;\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        try {\n            $geolocation = $vEvent->getAttribute('GEO');\n            $this->geoLocation = array(\n                'lat' => $geolocation['latitude'],\n                'lon' => $geolocation['longitude']\n            );\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Class\n        try {\n            $class = $vEvent->getAttribute('CLASS');\n            if (!is_array($class)) {\n                $class = Horde_String::upper($class);\n                $this->private = $class == 'PRIVATE' || $class == 'CONFIDENTIAL';\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Status.\n        try {\n            $status = $vEvent->getAttribute('STATUS');\n            if (!is_array($status)) {\n                $status = Horde_String::upper($status);\n                if ($status == 'DECLINED') {\n                    $status = 'CANCELLED';\n                }\n                if (defined('Kronolith::STATUS_' . $status)) {\n                    $this->status = constant('Kronolith::STATUS_' . $status);\n                }\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // Reset allday flag in case this has changed. Will be recalculated\n        // next time isAllDay() is called.\n        $this->allday = false;\n\n        // Start and end date.\n        $tzid = null;\n        try {\n            $start = $vEvent->getAttribute('DTSTART');\n            $startParams = $vEvent->getAttribute('DTSTART', true);\n            // We don't support different timezones for different attributes,\n            // so use the DTSTART timezone for the complete event.\n            if (isset($startParams[0]['TZID'])) {\n                // Horde_Date supports timezone aliases, so try that first.\n                $tz = $startParams[0]['TZID'];\n                try {\n                    // Check if the timezone name is supported by PHP natively.\n                    new DateTimeZone($tz);\n                    $this->timezone = $tzid = $tz;\n                } catch (Exception $e) {\n                }\n            }\n            if (!is_array($start)) {\n                // Date-Time field\n                $this->start = new Horde_Date($start, $tzid);\n            } else {\n                // Date field\n                $this->start = new Horde_Date(\n                    array('year'  => (int)$start['year'],\n                          'month' => (int)$start['month'],\n                          'mday'  => (int)$start['mday']),\n                    $tzid\n                );\n            }\n        } catch (Horde_Icalendar_Exception $e) {\n            throw new Kronolith_Exception($e);\n        } catch (Horde_Date_Exception $e) {\n            throw new Kronolith_Exception($e);\n        }\n\n        try {\n            $end = $vEvent->getAttribute('DTEND');\n            if (!is_array($end)) {\n                // Date-Time field\n                $this->end = new Horde_Date($end, $tzid);\n                // All day events are transferred by many device as\n                // DSTART: YYYYMMDDT000000 DTEND: YYYYMMDDT2359(59|00)\n                // Convert accordingly\n                if (is_object($this->start) && $this->start->hour == 0 &&\n                    $this->start->min == 0 && $this->start->sec == 0 &&\n                    $this->end->hour == 23 && $this->end->min == 59) {\n                    $this->end = new Horde_Date(\n                        array('year'  => (int)$this->end->year,\n                              'month' => (int)$this->end->month,\n                              'mday'  => (int)$this->end->mday + 1),\n                        $tzid);\n                }\n            } else {\n                // Date field\n                $this->end = new Horde_Date(\n                    array('year'  => (int)$end['year'],\n                          'month' => (int)$end['month'],\n                          'mday'  => (int)$end['mday']),\n                    $tzid);\n            }\n        } catch (Horde_Icalendar_Exception $e) {\n            $end = null;\n        }\n\n        if (is_null($end)) {\n            try {\n                $duration = $vEvent->getAttribute('DURATION');\n                if (!is_array($duration)) {\n                    $this->end = new Horde_Date($this->start);\n                    $this->end->sec += $duration;\n                    $end = 1;\n                }\n            } catch (Horde_Icalendar_Exception $e) {}\n\n            if (is_null($end)) {\n                // End date equal to start date as per RFC 2445.\n                $this->end = new Horde_Date($this->start);\n                if (is_array($start)) {\n                    // Date field\n                    $this->end->mday++;\n                }\n            }\n        }\n\n        // vCalendar 1.0 alarms\n        try {\n            $alarm = $vEvent->getAttribute('AALARM');\n            if (!is_array($alarm) && intval($alarm)) {\n                $this->alarm = intval(($this->start->timestamp() - $alarm) / 60);\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // vCalendar 2.0 alarms\n        foreach ($vEvent->getComponents() as $alarm) {\n            if (!($alarm instanceof Horde_Icalendar_Valarm)) {\n                continue;\n            }\n            try {\n                if ($alarm->getAttribute('ACTION') == 'NONE') {\n                    continue;\n                }\n            } catch (Horde_Icalendar_Exception $e) {\n            }\n            try {\n                // @todo consider implementing different ACTION types.\n                // $action = $alarm->getAttribute('ACTION');\n                $trigger = $alarm->getAttribute('TRIGGER');\n                $triggerParams = $alarm->getAttribute('TRIGGER', true);\n            } catch (Horde_Icalendar_Exception $e) {\n                continue;\n            }\n            if (!is_array($triggerParams)) {\n                $triggerParams = array($triggerParams);\n            }\n            $haveTrigger = false;\n            foreach ($triggerParams as $tp) {\n                if (isset($tp['VALUE']) &&\n                    $tp['VALUE'] == 'DATE-TIME') {\n                    if (isset($tp['RELATED']) &&\n                        $tp['RELATED'] == 'END') {\n                        $this->alarm = intval(($this->end->timestamp() - $trigger) / 60);\n                    } else {\n                        $this->alarm = intval(($this->start->timestamp() - $trigger) / 60);\n                    }\n                    $haveTrigger = true;\n                    break;\n                } elseif (isset($tp['RELATED']) && $tp['RELATED'] == 'END') {\n                    $this->alarm = -intval($trigger / 60);\n                    $this->alarm -= $this->durMin;\n                    $haveTrigger = true;\n                    break;\n                }\n            }\n            if (!$haveTrigger) {\n                $this->alarm = -intval($trigger / 60);\n            }\n            break;\n        }\n\n        // Alarm snoozing/dismissal\n        if ($this->alarm) {\n            try {\n                // If X-MOZ-LASTACK is set, this event is either dismissed or\n                // snoozed.\n                $vEvent->getAttribute('X-MOZ-LASTACK');\n                try {\n                    // If X-MOZ-SNOOZE-TIME is set, this event is snoozed.\n                    $snooze = $vEvent->getAttribute('X-MOZ-SNOOZE-TIME');\n                    $this->_snooze = intval(($snooze - time()) / 60);\n                } catch (Horde_Icalendar_Exception $e) {\n                    // If X-MOZ-SNOOZE-TIME is not set, this event is dismissed.\n                    $this->_snooze = -1;\n                }\n            } catch (Horde_Icalendar_Exception $e) {\n            }\n        }\n\n        // Attendance.\n        // Importing attendance may result in confusion: editing an imported\n        // copy of an event can cause invitation updates to be sent from\n        // people other than the original organizer. So we don't import by\n        // default. However to allow updates by synchronization, this behavior\n        // can be overriden.\n        // X-ATTENDEE is there for historical reasons. @todo remove in\n        // Kronolith 5.\n        $attendee = null;\n        if ($parseAttendees) {\n            try {\n                $attendee = $vEvent->getAttribute('ATTENDEE');\n                $params = $vEvent->getAttribute('ATTENDEE', true);\n            } catch (Horde_Icalendar_Exception $e) {\n                try {\n                    $attendee = $vEvent->getAttribute('X-ATTENDEE');\n                    $params = $vEvent->getAttribute('X-ATTENDEE', true);\n                } catch (Horde_Icalendar_Exception $e) {\n                }\n            }\n        }\n        if ($attendee) {\n            if (!is_array($attendee)) {\n                $attendee = array($attendee);\n            }\n            if (!is_array($params)) {\n                $params = array($params);\n            }\n            // Clear the attendees since we might be editing/replacing the event\n            $this->attendees = array();\n            for ($i = 0; $i < count($attendee); ++$i) {\n                $attendee[$i] = str_replace(array('MAILTO:', 'mailto:'), '',\n                                            $attendee[$i]);\n                $tmp = new Horde_Mail_Rfc822_Address($attendee[$i]);\n                $email = $tmp->bare_address;\n                // Default according to rfc2445:\n                $attendance = Kronolith::PART_REQUIRED;\n                // vCalendar 2.0 style:\n                if (!empty($params[$i]['ROLE'])) {\n                    switch($params[$i]['ROLE']) {\n                    case 'OPT-PARTICIPANT':\n                        $attendance = Kronolith::PART_OPTIONAL;\n                        break;\n\n                    case 'NON-PARTICIPANT':\n                        $attendance = Kronolith::PART_NONE;\n                        break;\n                    }\n                }\n                // vCalendar 1.0 style;\n                if (!empty($params[$i]['EXPECT'])) {\n                    switch($params[$i]['EXPECT']) {\n                    case 'REQUEST':\n                        $attendance = Kronolith::PART_OPTIONAL;\n                        break;\n\n                    case 'FYI':\n                        $attendance = Kronolith::PART_NONE;\n                        break;\n                    }\n                }\n                $response = Kronolith::RESPONSE_NONE;\n                if (empty($params[$i]['PARTSTAT']) &&\n                    !empty($params[$i]['STATUS'])) {\n                    $params[$i]['PARTSTAT']  = $params[$i]['STATUS'];\n                }\n\n                if (!empty($params[$i]['PARTSTAT'])) {\n                    switch($params[$i]['PARTSTAT']) {\n                    case 'ACCEPTED':\n                        $response = Kronolith::RESPONSE_ACCEPTED;\n                        break;\n\n                    case 'DECLINED':\n                        $response = Kronolith::RESPONSE_DECLINED;\n                        break;\n\n                    case 'TENTATIVE':\n                        $response = Kronolith::RESPONSE_TENTATIVE;\n                        break;\n                    }\n                }\n                $name = isset($params[$i]['CN'])\n                    ? $this->_ensureUtf8($params[$i]['CN'])\n                    : null;\n\n                $this->addAttendee($email, $attendance, $response, $name);\n            }\n        }\n\n        $this->_handlevEventRecurrence($vEvent);\n\n        $this->initialized = true;\n    }\n\n    /**\n     * Handle parsing recurrence related fields.\n     *\n     * @param Horde_Icalendar $vEvent\n     * @throws Kronolith_Exception\n     */\n    protected function _handlevEventRecurrence($vEvent)\n    {\n        // Recurrence.\n        try {\n            $rrule = $vEvent->getAttribute('RRULE');\n            if (!is_array($rrule)) {\n                $this->recurrence = new Horde_Date_Recurrence($this->start);\n                if (strpos($rrule, '=') !== false) {\n                    $this->recurrence->fromRRule20($rrule);\n                } else {\n                    $this->recurrence->fromRRule10($rrule);\n                }\n\n                // Exceptions. EXDATE represents deleted events, just add the\n                // exception, no new event is needed.\n                $exdates = $vEvent->getAttributeValues('EXDATE');\n                if (is_array($exdates)) {\n                    foreach ($exdates as $exdate) {\n                        if (is_array($exdate)) {\n                            $this->recurrence->addException(\n                                (int)$exdate['year'],\n                                (int)$exdate['month'],\n                                (int)$exdate['mday']);\n                        }\n                    }\n                }\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n\n        // RECURRENCE-ID indicates that this event represents an exception\n        try {\n            $recurrenceid = $vEvent->getAttribute('RECURRENCE-ID');\n            $originaldt = new Horde_Date($recurrenceid);\n            $this->exceptionoriginaldate = $originaldt;\n            $this->baseid = $this->uid;\n            $this->uid = null;\n            try {\n                $originalEvent = $this->getDriver()->getByUID($this->baseid);\n                if ($originalEvent->recurrence) {\n                    $originalEvent->recurrence->addException(\n                        $originaldt->format('Y'),\n                        $originaldt->format('m'),\n                        $originaldt->format('d')\n                    );\n                    $originalEvent->save();\n                }\n            } catch (Horde_Exception_NotFound $e) {\n                throw new Kronolith_Exception(_(\"Unable to locate original event series.\"));\n            }\n        } catch (Horde_Icalendar_Exception $e) {}\n    }\n\n    /**\n     * Imports the values for this event from a MS ActiveSync Message.\n     *\n     * @see Horde_ActiveSync_Message_Appointment\n     */\n    public function fromASAppointment(Horde_ActiveSync_Message_Appointment $message)\n    {\n        /* New event? */\n        if ($this->id === null) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n        if (!$message->isGhosted('subject') &&\n            strlen($title = $message->getSubject())) {\n            $this->title = $title;\n        }\n        if ($message->getProtocolVersion() == Horde_ActiveSync::VERSION_TWOFIVE &&\n            !$message->isGhosted('body') &&\n            strlen($description = $message->getBody())) {\n            $this->description = $description;\n        } elseif ($message->getProtocolVersion() > Horde_ActiveSync::VERSION_TWOFIVE && !$message->isGhosted('airsyncbasebody')) {\n            if ($message->airsyncbasebody->type == Horde_ActiveSync::BODYPREF_TYPE_HTML) {\n                $this->description = Horde_Text_Filter::filter($message->airsyncbasebody->data, 'Html2text');\n            } else {\n                $this->description = $message->airsyncbasebody->data;\n            }\n        }\n\n        if (!$message->isGhosted('location') &&\n            strlen($location = $message->getLocation())) {\n            $this->location = $location;\n        }\n\n        /* Date/times */\n        $tz = !$message->isGhosted('timezone')\n            ? $message->getTimezone()\n            : $this->timezone;\n        $dates = $message->getDatetime();\n        $this->start = !$message->isGhosted('starttime')\n            ? clone($dates['start'])\n            : $this->start;\n        $this->start->setTimezone($tz);\n\n        $this->end = !$message->isGhosted('endtime')\n            ? clone($dates['end'])\n            : $this->end;\n        $this->end->setTimezone($tz);\n\n        if (!$message->isGhosted('alldayevent')) {\n            $this->allday = $dates['allday'];\n        }\n        if ($tz != date_default_timezone_get()) {\n            $this->timezone = $tz;\n        }\n\n        /* Sensitivity */\n        if (!$message->isGhosted('sensitivity')) {\n            $this->private = ($message->getSensitivity() == Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE || $message->getSensitivity() == Horde_ActiveSync_Message_Appointment::SENSITIVITY_CONFIDENTIAL) ? true :  false;\n        }\n\n        /* Busy Status */\n        if (!$message->isGhosted('meetingstatus')) {\n            if ($message->getMeetingStatus() == Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED) {\n                $status = Kronolith::STATUS_CANCELLED;\n            } else {\n                $status = $message->getBusyStatus();\n                switch ($status) {\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_BUSY:\n                    $status = Kronolith::STATUS_CONFIRMED;\n                    break;\n\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE:\n                    $status = Kronolith::STATUS_FREE;\n                    break;\n\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_TENTATIVE:\n                    $status = Kronolith::STATUS_TENTATIVE;\n                    break;\n                // @TODO: not sure how \"Out\" should show in kronolith...\n                case Horde_ActiveSync_Message_Appointment::BUSYSTATUS_OUT:\n                    $status = Kronolith::STATUS_CONFIRMED;\n                default:\n                    // EAS Specifies default should be free.\n                    $status = Kronolith::STATUS_FREE;\n                }\n            }\n            $this->status = $status;\n        }\n\n        /* Alarm */\n        if (!$message->isGhosted('reminder') && ($alarm = $message->getReminder())) {\n            $this->alarm = $alarm;\n        }\n\n        /* Recurrence */\n        if (!$message->isGhosted('recurrence') && ($rrule = $message->getRecurrence())) {\n            /* Exceptions */\n            $kronolith_driver = $this->getDriver();\n            /* Since AS keeps exceptions as part of the original event, we need\n             * to delete all existing exceptions and re-create them. The only\n             * drawback to this is that the UIDs will change. */\n            $this->recurrence = $rrule;\n            if (!empty($this->uid)) {\n                $search = new StdClass();\n                $search->baseid = $this->uid;\n                $results = $kronolith_driver->search($search);\n                foreach ($results as $days) {\n                    foreach ($days as $exception) {\n                        $kronolith_driver->deleteEvent($exception->id);\n                    }\n                }\n            }\n\n            $erules = $message->getExceptions();\n            foreach ($erules as $rule){\n                /* Readd the exception event, but only if not deleted */\n                if (!$rule->deleted) {\n                    $event = $kronolith_driver->getEvent();\n                    $times = $rule->getDatetime();\n                    $original = $rule->getExceptionStartTime();\n                    $original->setTimezone($tz);\n                    $this->recurrence->addException($original->format('Y'), $original->format('m'), $original->format('d'));\n                    $event->start = $times['start'];\n                    $event->end = $times['end'];\n                    $event->start->setTimezone($tz);\n                    $event->end->setTimezone($tz);\n                    $event->allday = $times['allday'];\n                    $event->title = $rule->getSubject();\n                    $event->title = empty($event->title) ? $this->title : $event->title;\n                    $event->description = $rule->getBody();\n                    $event->description = empty($event->description) ? $this->description : $event->description;\n                    $event->baseid = $this->uid;\n                    $event->exceptionoriginaldate = $original;\n                    $event->initialized = true;\n                    if ($tz != date_default_timezone_get()) {\n                        $event->timezone = $tz;\n                    }\n                    $event->save();\n                } else {\n                    /* For exceptions that are deletions, just add the exception */\n                    $exceptiondt = $rule->getExceptionStartTime();\n                    $exceptiondt->setTimezone($tz);\n                    $this->recurrence->addException($exceptiondt->format('Y'), $exceptiondt->format('m'), $exceptiondt->format('d'));\n               }\n            }\n        }\n\n        /* Attendees */\n        if (!$message->isGhosted('attendees')) {\n            $attendees = $message->getAttendees();\n            foreach ($attendees as $attendee) {\n                switch ($attendee->status) {\n                case Horde_ActiveSync_Message_Attendee::STATUS_ACCEPT:\n                    $response_code = Kronolith::RESPONSE_ACCEPTED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::STATUS_DECLINE:\n                    $response_code = Kronolith::RESPONSE_DECLINED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::STATUS_TENTATIVE:\n                    $response_code = Kronolith::RESPONSE_TENTATIVE;\n                    break;\n                default:\n                    $response_code = Kronolith::RESPONSE_NONE;\n                }\n                switch ($attendee->type) {\n                case Horde_ActiveSync_Message_Attendee::TYPE_REQUIRED:\n                    $part_type = Kronolith::PART_REQUIRED;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::TYPE_OPTIONAL:\n                    $part_type = Kronolith::PART_OPTIONAL;\n                    break;\n                case Horde_ActiveSync_Message_Attendee::TYPE_RESOURCE:\n                    $part_type = Kronolith::PART_REQUIRED;\n                }\n\n                $this->addAttendee($attendee->email,\n                                   $part_type,\n                                   $response_code,\n                                   $attendee->name);\n            }\n        }\n\n        /* Categories (Tags) */\n        if (!$message->isGhosted('categories')) {\n            $this->_tags = $message->getCategories();\n        }\n\n        // 14.1\n        if ($message->getProtocolVersion() >= Horde_ActiveSync::VERSION_FOURTEENONE &&\n            !$message->isGhosted('onlinemeetingexternallink')) {\n            $this->url = $message->onlinemeetingexternallink;\n        }\n\n        /* Flag that we are initialized */\n        $this->initialized = true;\n    }\n\n    /**\n     * Export this event as a MS ActiveSync Message\n     *\n     * @param array $options  Options:\n     *   - protocolversion: (float)  The EAS version to support\n     *                      DEFAULT: 2.5\n     *   - bodyprefs: (array)  A BODYPREFERENCE array.\n     *                DEFAULT: none (No body prefs enforced).\n     *   - truncation: (integer)  Truncate event body to this length\n     *                 DEFAULT: none (No truncation).\n     *\n     * @return Horde_ActiveSync_Message_Appointment\n     */\n    public function toASAppointment(array $options = array())\n    {\n        global $prefs, $registry;\n\n        $message = new Horde_ActiveSync_Message_Appointment(\n            array(\n                'logger' => $GLOBALS['injector']->getInstance('Horde_Log_Logger'),\n                'protocolversion' => $options['protocolversion']\n            )\n        );\n\n        if (!$this->isPrivate()) {\n            // Handle body/truncation\n            if (!empty($options['bodyprefs'])) {\n                if (Horde_String::length($this->description) > 0) {\n                    $bp = $options['bodyprefs'];\n                    $note = new Horde_ActiveSync_Message_AirSyncBaseBody();\n                    // No HTML supported. Always use plaintext.\n                    $note->type = Horde_ActiveSync::BODYPREF_TYPE_PLAIN;\n                    if (isset($bp[Horde_ActiveSync::BODYPREF_TYPE_PLAIN]['truncationsize'])) {\n                        $truncation = $bp[Horde_ActiveSync::BODYPREF_TYPE_PLAIN]['truncationsize'];\n                    } elseif (isset($bp[Horde_ActiveSync::BODYPREF_TYPE_HTML])) {\n                        $truncation = $bp[Horde_ActiveSync::BODYPREF_TYPE_HTML]['truncationsize'];\n                        $this->description = Horde_Text_Filter::filter($this->description, 'Text2html', array('parselevel' => Horde_Text_Filter_Text2html::MICRO));\n                    } else {\n                        $truncation = false;\n                    }\n                    if ($truncation && Horde_String::length($this->description) > $truncation) {\n                        $note->data = Horde_String::substr($this->description, 0, $truncation);\n                        $note->truncated = 1;\n                    } else {\n                        $note->data = $this->description;\n                    }\n                    $note->estimateddatasize = Horde_String::length($this->description);\n                    $message->airsyncbasebody = $note;\n                }\n            } else {\n                $message->setBody($this->description);\n            }\n            $message->setLocation($this->location);\n        }\n\n        $message->setSubject($this->getTitle());\n        $message->setDatetime(array(\n            'start' => $this->start,\n            'end' => $this->end,\n            'allday' => $this->isAllDay())\n        );\n        $message->setTimezone($this->start);\n\n        // Organizer\n        if (count($this->attendees)) {\n            if ($this->creator == $registry->getAuth()) {\n                $as_ident = $prefs->getValue('activesync_identity') == 'horde'\n                    ? $prefs->getValue('default_identity')\n                    : $prefs->getValue('activesync_identity');\n\n                $name = $GLOBALS['injector']\n                    ->getInstance('Horde_Core_Factory_Identity')\n                    ->create($this->creator)->getValue('fullname', $as_ident);\n                $email = $GLOBALS['injector']\n                    ->getInstance('Horde_Core_Factory_Identity')\n                    ->create($this->creator)->getValue('from_addr', $as_ident);\n            } else {\n                $name = Kronolith::getUserName($this->creator);\n                $email = Kronolith::getUserEmail($this->creator);\n            }\n            $message->setOrganizer(array(\n                'name' => $name,\n                'email' => $email)\n            );\n        }\n\n        // Privacy\n        $message->setSensitivity($this->private ?\n            Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE :\n            Horde_ActiveSync_Message_Appointment::SENSITIVITY_NORMAL);\n\n        // Busy Status\n        switch ($this->status) {\n        case Kronolith::STATUS_CANCELLED:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE;\n            break;\n        case Kronolith::STATUS_CONFIRMED:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_BUSY;\n            break;\n        case Kronolith::STATUS_TENTATIVE:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_TENTATIVE;\n        case Kronolith::STATUS_FREE:\n        case Kronolith::STATUS_NONE:\n            $status = Horde_ActiveSync_Message_Appointment::BUSYSTATUS_FREE;\n        }\n        $message->setBusyStatus($status);\n\n        // DTStamp\n        $message->setDTStamp($_SERVER['REQUEST_TIME']);\n\n        // Recurrence\n        if ($this->recurs()) {\n            $message->setRecurrence($this->recurrence, $GLOBALS['prefs']->getValue('week_start_monday'));\n\n            /* Exceptions are tricky. Exceptions, even those that represent\n             * deleted instances of a recurring event, must be added. To do this\n             * we query the storage for all the events that represent exceptions\n             * (those with the baseid == $this->uid) and then remove the\n             * exceptionoriginaldate from the list of exceptions we know about.\n             * Any dates left in this list when we are done, must represent\n             * deleted instances of this recurring event.*/\n            if (!empty($this->recurrence) && $exceptions = $this->recurrence->getExceptions()) {\n                $results = $this->boundExceptions();\n                foreach ($results as $exception) {\n                    $e = new Horde_ActiveSync_Message_Exception(array(\n                        'protocolversion' => $options['protocolversion']));\n                    $e->setDateTime(array(\n                        'start' => $exception->start,\n                        'end' => $exception->end,\n                        'allday' => $exception->isAllDay()));\n\n                    // The start time of the *original* recurring event\n                    $e->setExceptionStartTime($exception->exceptionoriginaldate);\n                    $originaldate = $exception->exceptionoriginaldate->format('Ymd');\n                    $key = array_search($originaldate, $exceptions);\n                    if ($key !== false) {\n                        unset($exceptions[$key]);\n                    }\n\n                    // Remaining properties that could be different\n                    $e->setSubject($exception->getTitle());\n                    if (!$exception->isPrivate()) {\n                        $e->setLocation($exception->location);\n                        $e->setBody($exception->description);\n                    }\n\n                    $e->setSensitivity($exception->private ?\n                        Horde_ActiveSync_Message_Appointment::SENSITIVITY_PRIVATE :\n                        Horde_ActiveSync_Message_Appointment::SENSITIVITY_NORMAL);\n                    $e->setReminder($exception->alarm);\n                    $e->setDTStamp($_SERVER['REQUEST_TIME']);\n\n                    if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWELVEONE) {\n                        switch ($exception->status) {\n                        case Kronolith::STATUS_TENTATIVE;\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_TENTATIVE;\n                            break;\n                        case Kronolith::STATUS_NONE:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NORESPONSE;\n                            break;\n                        case Kronolith::STATUS_CONFIRMED:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_ACCEPTED;\n                            break;\n                        default:\n                            $e->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NONE;\n                        }\n                    }\n\n                    // Tags/Categories\n                    if (!$exception->isPrivate()) {\n                        foreach ($exception->tags as $tag) {\n                            $e->addCategory($tag);\n                        }\n                    }\n\n                    $message->addexception($e);\n                }\n\n                // Any dates left in $exceptions must be deleted exceptions\n                foreach ($exceptions as $deleted) {\n                    $e = new Horde_ActiveSync_Message_Exception(array(\n                        'protocolversion' => $options['protocolversion']));\n                    // Kronolith stores the date only, but some AS clients need\n                    // the datetime.\n                    list($year, $month, $mday) = sscanf($deleted, '%04d%02d%02d');\n                    $st = clone $this->start;\n                    $st->year = $year;\n                    $st->month = $month;\n                    $st->mday = $mday;\n                    $e->setExceptionStartTime($st);\n                    $e->deleted = true;\n                    $message->addException($e);\n                }\n            }\n        }\n\n        // Attendees\n        if (!$this->isPrivate() && count($this->attendees)) {\n            $message->setMeetingStatus(\n                $this->status == Kronolith::STATUS_CANCELLED\n                    ? Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED\n                    : Horde_ActiveSync_Message_Appointment::MEETING_IS_MEETING\n            );\n            foreach ($this->attendees as $email => $properties) {\n                $attendee = new Horde_ActiveSync_Message_Attendee(array(\n                    'protocolversion' => $options['protocolversion']));\n                $adr_obj = new Horde_Mail_Rfc822_Address($email);\n                $attendee->name = $adr_obj->label;\n                $attendee->email = $adr_obj->bare_address;\n\n                // AS only has required or optional, and only EAS Version > 2.5\n                if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWOFIVE) {\n                    $attendee->type = ($properties['attendance'] !== Kronolith::PART_REQUIRED\n                        ? Horde_ActiveSync_Message_Attendee::TYPE_OPTIONAL\n                        : Horde_ActiveSync_Message_Attendee::TYPE_REQUIRED);\n\n                    switch ($properties['response']) {\n                    case Kronolith::RESPONSE_NONE:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_NORESPONSE;\n                        break;\n                    case Kronolith::RESPONSE_ACCEPTED:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_ACCEPT;\n                        break;\n                    case Kronolith::RESPONSE_DECLINED:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_DECLINE;\n                        break;\n                    case Kronolith::RESPONSE_TENTATIVE:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_TENTATIVE;\n                        break;\n                    default:\n                        $attendee->status = Horde_ActiveSync_Message_Attendee::STATUS_UNKNOWN;\n                    }\n                }\n\n                $message->addAttendee($attendee);\n            }\n        } elseif ($this->status == Kronolith::STATUS_CANCELLED) {\n            $message->setMeetingStatus(Horde_ActiveSync_Message_Appointment::MEETING_CANCELLED);\n        } else {\n            $message->setMeetingStatus(Horde_ActiveSync_Message_Appointment::MEETING_NOT_MEETING);\n        }\n\n        // Resources\n        if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWOFIVE) {\n            $r = $this->getResources();\n            foreach ($r as $id => $data) {\n                $resource = Kronolith::getDriver('Resource')->getResource($id);\n                // EAS *REQUIRES* an email field for Resources. If it is missing\n                // a number of clients will fail, losing push.\n                if ($resource->get('email')) {\n                    $attendee = new Horde_ActiveSync_Message_Attendee(array(\n                        'protocolversion' => $options['protocolversion']));\n                    $attendee->email = $resource->get('email');\n                    $attendee->type = Horde_ActiveSync_Message_Attendee::TYPE_RESOURCE;\n                    $attendee->name = $data['name'];\n                    $attendee->status = $data['response'];\n                    $message->addAttendee($attendee);\n                }\n           }\n        }\n\n        // Reminder\n        if ($this->alarm) {\n            $message->setReminder($this->alarm);\n        }\n\n        // Categories (tags)\n        if (!$this->isPrivate()) {\n            foreach ($this->tags as $tag) {\n                $message->addCategory($tag);\n            }\n        }\n\n        // EAS 14\n        if ($options['protocolversion'] > Horde_ActiveSync::VERSION_TWELVEONE) {\n            // We don't track the actual responses we sent to other's invitations.\n            // Set this based on the status flag.\n            switch ($this->status) {\n            case Kronolith::STATUS_TENTATIVE;\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_TENTATIVE;\n                break;\n            case Kronolith::STATUS_NONE:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NORESPONSE;\n                break;\n            case Kronolith::STATUS_CONFIRMED:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_ACCEPTED;\n                break;\n            default:\n                $message->responsetype = Horde_ActiveSync_Message_Appointment::RESPONSE_NONE;\n            }\n        }\n\n        // 14.1\n        if ($options['protocolversion'] >= Horde_ActiveSync::VERSION_FOURTEENONE) {\n            $message->onlinemeetingexternallink = $this->url;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Imports the values for this event from an array of values.\n     *\n     * @param array $hash  Array containing all the values.\n     *\n     * @throws Kronolith_Exception\n     */\n    public function fromHash($hash)\n    {\n        // See if it's a new event.\n        if ($this->id === null) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n\n        if (!empty($hash['title'])) {\n            $this->title = $hash['title'];\n        } else {\n            throw new Kronolith_Exception(_(\"Events must have a title.\"));\n        }\n\n        $this->start = null;\n        if (!empty($hash['start_date'])) {\n            $date = array_map('intval', explode('-', $hash['start_date']));\n            if (empty($hash['start_time'])) {\n                $time = array(0, 0, 0);\n            } else {\n                $time = array_map('intval', explode(':', $hash['start_time']));\n                if (count($time) == 2) {\n                    $time[2] = 0;\n                }\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                if ($date[0] < 100) {\n                    $date[0] += (date('Y') / 100 | 0) * 100;\n                }\n                $this->start = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n            }\n        }\n        if (!isset($this->start)) {\n            throw new Kronolith_Exception(_(\"Events must have a start date.\"));\n        }\n\n        if (empty($hash['duration'])) {\n            if (empty($hash['end_date'])) {\n                $hash['end_date'] = $hash['start_date'];\n            }\n            if (empty($hash['end_time'])) {\n                $hash['end_time'] = $hash['start_time'];\n            }\n        } else {\n            $weeks = str_replace('W', '', $hash['duration'][1]);\n            $days = str_replace('D', '', $hash['duration'][2]);\n            $hours = str_replace('H', '', $hash['duration'][4]);\n            $minutes = isset($hash['duration'][5]) ? str_replace('M', '', $hash['duration'][5]) : 0;\n            $seconds = isset($hash['duration'][6]) ? str_replace('S', '', $hash['duration'][6]) : 0;\n            $hash['duration'] = ($weeks * 60 * 60 * 24 * 7) + ($days * 60 * 60 * 24) + ($hours * 60 * 60) + ($minutes * 60) + $seconds;\n            $this->end = new Horde_Date($this->start);\n            $this->end->sec += $hash['duration'];\n        }\n        if (!empty($hash['end_date'])) {\n            $date = array_map('intval', explode('-', $hash['end_date']));\n            if (empty($hash['end_time'])) {\n                $time = array(0, 0, 0);\n            } else {\n                $time = array_map('intval', explode(':', $hash['end_time']));\n                if (count($time) == 2) {\n                    $time[2] = 0;\n                }\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                if ($date[0] < 100) {\n                    $date[0] += (date('Y') / 100 | 0) * 100;\n                }\n                $this->end = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n            }\n        }\n\n        if (!empty($hash['alarm'])) {\n            $this->alarm = (int)$hash['alarm'];\n        } elseif (!empty($hash['alarm_date']) &&\n                  !empty($hash['alarm_time'])) {\n            $date = array_map('intval', explode('-', $hash['alarm_date']));\n            $time = array_map('intval', explode(':', $hash['alarm_time']));\n            if (count($time) == 2) {\n                $time[2] = 0;\n            }\n            if (count($time) == 3 && count($date) == 3 &&\n                !empty($date[1]) && !empty($date[2])) {\n                $alarm = new Horde_Date(\n                    array(\n                        'year'  => $date[0],\n                        'month' => $date[1],\n                        'mday'  => $date[2],\n                        'hour'  => $time[0],\n                        'min'   => $time[1],\n                        'sec'   => $time[2]\n                    ),\n                    isset($hash['timezone']) ? $hash['timezone'] : null\n                );\n                $this->alarm = ($this->start->timestamp() - $alarm->timestamp()) / 60;\n            }\n        }\n\n        $this->allday = !empty($hash['allday']);\n\n        if (!empty($hash['description'])) {\n            $this->description = $hash['description'];\n        }\n\n        if (!empty($hash['location'])) {\n            $this->location = $hash['location'];\n        }\n\n        // Import once we support organizers.\n        /*\n        if (!empty($hash['organizer'])) {\n            $this->organizer = $hash['organizer'];\n        }\n        */\n\n        if (!empty($hash['private'])) {\n            $this->private = true;\n        }\n\n        if (!empty($hash['recur_type'])) {\n            $this->recurrence = new Horde_Date_Recurrence($this->start);\n            $this->recurrence->setRecurType($hash['recur_type']);\n            if (!empty($hash['recur_count'])) {\n                $this->recurrence->setRecurCount($hash['recur_count']);\n            } elseif (!empty($hash['recur_end_date'])) {\n                $date = array_map('intval', explode('-', $hash['recur_end_date']));\n                if (count($date) == 3 && !empty($date[1]) && !empty($date[2])) {\n                    $this->recurrence->setRecurEnd(\n                        new Horde_Date(array(\n                            'year'  => $date[0],\n                            'month' => $date[1],\n                            'mday'  => $date[2]\n                        ))\n                    );\n                }\n            }\n            if (!empty($hash['recur_interval'])) {\n                $this->recurrence->setRecurInterval($hash['recur_interval']);\n            }\n            if (!empty($hash['recur_data'])) {\n                $this->recurrence->setRecurOnDay($hash['recur_data']);\n            }\n            if (!empty($hash['recur_exceptions'])) {\n                foreach ($hash['recur_exceptions'] as $exception) {\n                    $parts = explode('-', $exception);\n                    if (count($parts) == 3) {\n                        $this->recurrence->addException($parts[0], $parts[1], $parts[2]);\n                    }\n                }\n            }\n        }\n\n        if (isset($hash['sequence'])) {\n            $this->sequence = $hash['sequence'];\n        }\n\n        if (!empty($hash['tags'])) {\n            $this->tags = $hash['tags'];\n        }\n\n        if (!empty($hash['timezone'])) {\n            $this->timezone = $hash['timezone'];\n        }\n\n        if (!empty($hash['uid'])) {\n            $this->uid = $hash['uid'];\n        }\n\n        $this->initialized = true;\n    }\n\n    /**\n     * Returns an alarm hash of this event suitable for Horde_Alarm.\n     *\n     * @param Horde_Date $time  Time of alarm.\n     * @param string $user      The user to return alarms for.\n     * @param Prefs $prefs      A Prefs instance.\n     *\n     * @return array  Alarm hash or null.\n     */\n    public function toAlarm($time, $user = null, $prefs = null)\n    {\n        if (!$this->alarm || $this->status == Kronolith::STATUS_CANCELLED) {\n            return;\n        }\n\n        if ($this->recurs()) {\n            $eventDate = $this->recurrence->nextRecurrence($time);\n            if (!$eventDate || ($eventDate && $this->recurrence->hasException($eventDate->year, $eventDate->month, $eventDate->mday))) {\n                return;\n            }\n            $start = clone $eventDate;\n            $diff = Date_Calc::dateDiff(\n                $this->start->mday,\n                $this->start->month,\n                $this->start->year,\n                $this->end->mday,\n                $this->end->month,\n                $this->end->year\n            );\n            if ($diff == -1) {\n                $diff = 0;\n            }\n            $end = new Horde_Date(array(\n                'year' => $start->year,\n                'month' => $start->month,\n                'mday' => $start->mday + $diff,\n                'hour' => $this->end->hour,\n                'min' => $this->end->min,\n                'sec' => $this->end->sec)\n            );\n        } else {\n            $start = clone $this->start;\n            $end = clone $this->end;\n        }\n\n        $serverName = $_SERVER['SERVER_NAME'];\n        $serverConf = $GLOBALS['conf']['server']['name'];\n        if (!empty($GLOBALS['conf']['reminder']['server_name'])) {\n            $_SERVER['SERVER_NAME'] = $GLOBALS['conf']['server']['name'] = $GLOBALS['conf']['reminder']['server_name'];\n        }\n\n        if (empty($user)) {\n            $user = $GLOBALS['registry']->getAuth();\n        }\n        if (empty($prefs)) {\n            $prefs = $GLOBALS['prefs'];\n        }\n\n        $methods = !empty($this->methods) ? $this->methods : @unserialize($prefs->getValue('event_alarms'));\n        if (isset($methods['notify'])) {\n            $methods['notify']['show'] = array(\n                '__app' => $GLOBALS['registry']->getApp(),\n                'event' => $this->id,\n                'calendar' => $this->calendar);\n            $methods['notify']['ajax'] = 'event:' . $this->calendarType . '|' . $this->calendar . ':' . $this->id . ':' . $start->dateString();\n            if (!empty($methods['notify']['sound'])) {\n                if ($methods['notify']['sound'] == 'on') {\n                    // Handle boolean sound preferences.\n                    $methods['notify']['sound'] = (string)Horde_Themes::sound('theetone.wav');\n                } else {\n                    // Else we know we have a sound name that can be\n                    // served from Horde.\n                    $methods['notify']['sound'] = (string)Horde_Themes::sound($methods['notify']['sound']);\n                }\n            }\n            if ($this->isAllDay()) {\n                if ($start->compareDate($end) == 0) {\n                    $methods['notify']['subtitle'] = sprintf(_(\"On %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')) . '</strong>');\n                } else {\n                    $methods['notify']['subtitle'] = sprintf(_(\"From %s to %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')) . '</strong>', '<strong>' . $end->strftime($prefs->getValue('date_format')) . '</strong>');\n                }\n            } else {\n                $methods['notify']['subtitle'] = sprintf(_(\"From %s at %s to %s at %s\"), '<strong>' . $start->strftime($prefs->getValue('date_format')), $start->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia') . '</strong>', '<strong>' . $end->strftime($prefs->getValue('date_format')), $this->end->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia') . '</strong>');\n            }\n        }\n        if (isset($methods['mail'])) {\n            $image = Kronolith::getImagePart('big_alarm.png');\n\n            $view = new Horde_View(array('templatePath' => KRONOLITH_TEMPLATES . '/alarm', 'encoding' => 'UTF-8'));\n            new Horde_View_Helper_Text($view);\n            $view->event = $this;\n            $view->imageId = $image->getContentId();\n            $view->user = $user;\n            $view->dateFormat = $prefs->getValue('date_format');\n            $view->timeFormat = $prefs->getValue('twentyFour') ? 'H:i' : 'h:ia';\n            $view->start = $start;\n            if (!$prefs->isLocked('event_reminder')) {\n                $view->prefsUrl = Horde::url($GLOBALS['registry']->getServiceLink('prefs', 'kronolith'), true)->remove(session_name());\n            }\n            if ($this->attendees) {\n                $view->attendees = Kronolith::getAttendeeEmailList($this->attendees)->addresses;\n            }\n\n            $methods['mail']['mimepart'] = Kronolith::buildMimeMessage($view, 'mail', $image);\n        }\n        if (isset($methods['desktop'])) {\n            if ($this->isAllDay()) {\n                if ($this->start->compareDate($this->end) == 0) {\n                    $methods['desktop']['subtitle'] = sprintf(_(\"On %s\"), $start->strftime($prefs->getValue('date_format')));\n                } else {\n                    $methods['desktop']['subtitle'] = sprintf(_(\"From %s to %s\"), $start->strftime($prefs->getValue('date_format')), $end->strftime($prefs->getValue('date_format')));\n                }\n            } else {\n                $methods['desktop']['subtitle'] = sprintf(_(\"From %s at %s to %s at %s\"), $start->strftime($prefs->getValue('date_format')), $start->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia'), $end->strftime($prefs->getValue('date_format')), $this->end->format($prefs->getValue('twentyFour') ? 'H:i' : 'h:ia'));\n            }\n            $methods['desktop']['url'] = strval($this->getViewUrl(array(), true, false));\n        }\n\n        $alarmStart = clone $start;\n        $alarmStart->min -= $this->alarm;\n        $alarm = array(\n            'id' => $this->uid,\n            'user' => $user,\n            'start' => $alarmStart,\n            'end' => $end,\n            'methods' => array_keys($methods),\n            'params' => $methods,\n            'title' => $this->getTitle($user),\n            'text' => $this->description,\n            'instanceid' => $this->recurs() ? $eventDate->dateString() : null);\n\n        $_SERVER['SERVER_NAME'] = $serverName;\n        $GLOBALS['conf']['server']['name'] = $serverConf;\n\n        return $alarm;\n    }\n\n    /**\n     * Returns a simple object suitable for json transport representing this\n     * event.\n     *\n     * Possible properties are:\n     * - t: title\n     * - d: description\n     * - c: calendar id\n     * - s: start date\n     * - e: end date\n     * - fi: first day of a multi-day event\n     * - la: last day of a multi-day event\n     * - x: status (Kronolith::STATUS_* constant)\n     * - al: all-day?\n     * - bg: background color\n     * - fg: foreground color\n     * - pe: edit permissions?\n     * - pd: delete permissions?\n     * - vl: variable, i.e. editable length?\n     * - a: alarm text or minutes\n     * - r: recurrence type (Horde_Date_Recurrence::RECUR_* constant)\n     * - bid: The baseid for an event representing an exception\n     * - eod: The original date that an exception is replacing\n     * - ic: icon\n     * - ln: link\n     * - aj: ajax link\n     * - id: event id\n     * - ty: calendar type (driver)\n     * - l: location\n     * - u: url\n     * - sd: formatted start date\n     * - st: formatted start time\n     * - ed: formatted end date\n     * - et: formatted end time\n     * - at: attendees\n     * - rs:  resources\n     * - tg: tag list,\n     * - mt: meeting (Boolean true if event has attendees, false otherwise).\n     *\n     * @param boolean $allDay      If not null, overrides whether the event is\n     *                             an all-day event.\n     * @param boolean $full        Whether to return all event details.\n     * @param string $time_format  The date() format to use for time formatting.\n     *\n     * @return stdClass  A simple object.\n     */\n    public function toJson($allDay = null, $full = false, $time_format = 'H:i')\n    {\n        $json = new stdClass;\n        $json->uid = $this->uid;\n        $json->t = $this->getTitle();\n        $json->c = $this->calendar;\n        $json->s = $this->start->toJson();\n        $json->e = $this->end->toJson();\n        $json->fi = $this->first;\n        $json->la = $this->last;\n        $json->x = (int)$this->status;\n        $json->al = is_null($allDay) ? $this->isAllDay() : $allDay;\n        $json->pe = $this->hasPermission(Horde_Perms::EDIT);\n        $json->pd = $this->hasPermission(Horde_Perms::DELETE);\n        $json->l = $this->getLocation();\n        $json->mt = !empty($this->attendees);\n        $json->sort = sprintf(\n            '%010s%06s',\n            $this->originalStart->timestamp(),\n            240000 - $this->end->format('His')\n        );\n\n        if ($this->icon) {\n            $json->ic = $this->icon;\n        }\n        if ($this->alarm) {\n            if ($this->alarm % 10080 == 0) {\n                $alarm_value = $this->alarm / 10080;\n                $json->a = sprintf(ngettext(\"%d week\", \"%d weeks\", $alarm_value), $alarm_value);\n            } elseif ($this->alarm % 1440 == 0) {\n                $alarm_value = $this->alarm / 1440;\n                $json->a = sprintf(ngettext(\"%d day\", \"%d days\", $alarm_value), $alarm_value);\n            } elseif ($this->alarm % 60 == 0) {\n                $alarm_value = $this->alarm / 60;\n                $json->a = sprintf(ngettext(\"%d hour\", \"%d hours\", $alarm_value), $alarm_value);\n            } else {\n                $alarm_value = $this->alarm;\n                $json->a = sprintf(ngettext(\"%d minute\", \"%d minutes\", $alarm_value), $alarm_value);\n            }\n        }\n        if ($this->recurs()) {\n            $json->r = $this->recurrence->getRecurType();\n        } elseif ($this->baseid) {\n            $json->bid = $this->baseid;\n            if ($this->exceptionoriginaldate) {\n                $json->eod = sprintf(_(\"%s at %s\"), $this->exceptionoriginaldate->strftime($GLOBALS['prefs']->getValue('date_format')), $this->exceptionoriginaldate->strftime(($GLOBALS['prefs']->getValue('twentyFour') ? '%H:%M' : '%I:%M %p')));\n            }\n        }\n        if ($this->_resources) {\n            $json->rs = $this->_resources;\n        }\n        if ($full) {\n            $json->id = $this->id;\n            $json->ty = $this->calendarType;\n            $json->sd = $this->start->strftime('%x');\n            $json->st = $this->start->format($time_format);\n            $json->ed = $this->end->strftime('%x');\n            $json->et = $this->end->format($time_format);\n            $json->tz = $this->timezone;\n            $json->a = $this->alarm;\n            $json->pv = $this->private;\n            if ($this->recurs()) {\n                $json->r = $this->recurrence->toJson();\n            }\n            if (!$this->isPrivate()) {\n                $json->d = $this->description;\n                $json->u =  htmlentities($this->url);\n                $json->uhl = htmlentities($GLOBALS['injector']->getInstance('Horde_Core_Factory_TextFilter')->filter($this->url, 'linkurls'));\n                $json->tg = array_values($this->tags);\n                $json->gl = $this->geoLocation;\n                if ($this->attendees) {\n                    $attendees = array();\n                    foreach ($this->attendees as $email => $info) {\n                        $tmp = new Horde_Mail_Rfc822_Address($email);\n                        if (!empty($info['name'])) {\n                            $tmp->personal = $info['name'];\n                        }\n\n                        $attendees[] = array(\n                            'a' => intval($info['attendance']),\n                            'e' => $tmp->bare_address,\n                            'r' => intval($info['response']),\n                            'l' => strval($tmp)\n                        );\n                        $json->at = $attendees;\n                    }\n                }\n            }\n            if ($this->methods) {\n                $json->m = $this->methods;\n            }\n        }\n\n        return $json;\n    }\n\n    /**\n     * Checks if the current event is already present in the calendar.\n     *\n     * Does the check based on the uid.\n     *\n     * @return boolean  True if event exists, false otherwise.\n     */\n    public function exists()\n    {\n        if (!isset($this->uid) || !isset($this->calendar)) {\n            return false;\n        }\n        try {\n            $eventID = $this->getDriver()->exists($this->uid, $this->calendar);\n            if (!$eventID) {\n                return false;\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        $this->id = $eventID;\n        return true;\n    }\n\n    /**\n     * Converts this event between the event's and the local timezone.\n     *\n     * @param boolean $to_orginal  If true converts to the event's timezone.\n     */\n    public function setTimezone($to_original)\n    {\n        if (!$this->timezone || !$this->getDriver()->supportsTimezones()) {\n            return;\n        }\n        $timezone = $to_original ? $this->timezone : date_default_timezone_get();\n        $this->start->setTimezone($timezone);\n        $this->end->setTimezone($timezone);\n        if ($this->recurs() && $this->recurrence->hasRecurEnd()) {\n            /* @todo Check if have to go through all recurrence\n               exceptions too. */\n            $this->recurrence->start->setTimezone($timezone);\n            $this->recurrence->recurEnd->setTimezone($timezone);\n        }\n    }\n\n    public function getDuration()\n    {\n        if (isset($this->_duration)) {\n            return $this->_duration;\n        }\n\n        if ($this->start && $this->end) {\n            $dur_day_match = Date_Calc::dateDiff($this->start->mday,\n                                                 $this->start->month,\n                                                 $this->start->year,\n                                                 $this->end->mday,\n                                                 $this->end->month,\n                                                 $this->end->year);\n            $dur_hour_match = $this->end->hour - $this->start->hour;\n            $dur_min_match = $this->end->min - $this->start->min;\n            while ($dur_min_match < 0) {\n                $dur_min_match += 60;\n                --$dur_hour_match;\n            }\n            while ($dur_hour_match < 0) {\n                $dur_hour_match += 24;\n                --$dur_day_match;\n            }\n        } else {\n            $dur_day_match = 0;\n            $dur_hour_match = 1;\n            $dur_min_match = 0;\n        }\n\n        $this->_duration = new stdClass;\n        $this->_duration->day = $dur_day_match;\n        $this->_duration->hour = $dur_hour_match;\n        $this->_duration->min = $dur_min_match;\n        $this->_duration->wholeDay = $this->isAllDay();\n\n        return $this->_duration;\n    }\n\n    /**\n     * Returns whether this event is a recurring event.\n     *\n     * @return boolean  True if this is a recurring event.\n     */\n    public function recurs()\n    {\n        return isset($this->recurrence) &&\n            !$this->recurrence->hasRecurType(Horde_Date_Recurrence::RECUR_NONE) &&\n            empty($this->baseid);\n    }\n\n    /**\n     * Returns a description of this event's recurring type.\n     *\n     * @return string  Human readable recurring type.\n     */\n    public function getRecurName()\n    {\n        if (empty($this->baseid)) {\n            return $this->recurs()\n                ? $this->recurrence->getRecurName()\n                : _(\"No recurrence\");\n        } else {\n            return _(\"Exception\");\n        }\n    }\n\n    /**\n     * Returns a correcty formatted exception date for recurring events and a\n     * link to delete this exception.\n     *\n     * @param string $date  Exception in the format Ymd.\n     *\n     * @return string  The formatted date and delete link.\n     */\n    public function exceptionLink($date)\n    {\n        if (!preg_match('/(\\d{4})(\\d{2})(\\d{2})/', $date, $match)) {\n            return '';\n        }\n        $horde_date = new Horde_Date(array('year' => $match[1],\n                                           'month' => $match[2],\n                                           'mday' => $match[3]));\n        $formatted = $horde_date->strftime($GLOBALS['prefs']->getValue('date_format'));\n        return $formatted\n            . Horde::url('edit.php')\n            ->add(array('calendar' => $this->calendarType . '_' .$this->calendar,\n                        'eventID' => $this->id,\n                        'del_exception' => $date,\n                        'url' => Horde_Util::getFormData('url')))\n            ->link(array('title' => sprintf(_(\"Delete exception on %s\"), $formatted)))\n            . Horde::img('delete-small.png', _(\"Delete\"))\n            . '</a>';\n    }\n\n    /**\n     * Returns a list of exception dates for recurring events including links\n     * to delete them.\n     *\n     * @return string  List of exception dates and delete links.\n     */\n    public function exceptionsList()\n    {\n        $exceptions = $this->recurrence->getExceptions();\n        asort($exceptions);\n        return implode(', ', array_map(array($this, 'exceptionLink'), $exceptions));\n    }\n\n    /**\n     * Returns a list of events that represent exceptions to this event's\n     * recurrence series, if any. If this event does not recur, an empty array\n     * is returned.\n     *\n     * @param boolean $flat  If true (the default), returns a flat array\n     *                       containing Kronolith_Event objects. If false,\n     *                       results are in the format of listEvents calls. @see\n     *                       Kronolith::listEvents().\n     *\n     * @return array  An array of Kronolith_Event objects whose baseid property\n     *                is equal to this event's uid. I.e., it is a bound\n     *                exception.\n     *\n     * @since 4.2.2\n     */\n    public function boundExceptions($flat = true)\n    {\n        if (!$this->recurrence || !$this->uid) {\n            return array();\n        }\n        $return = array();\n        $search = new stdClass();\n        $search->baseid = $this->uid;\n        $results = $this->getDriver()->search($search);\n\n        if (!$flat) {\n            return $results;\n        }\n\n        foreach ($results as $days) {\n            foreach ($days as $exception) {\n                $return[] = $exception;\n            }\n        }\n\n        return $return;\n    }\n\n    /**\n     * Returns whether the event should be considered private.\n     *\n     * @param string $user  The current user. If omitted, uses the current user.\n     *\n     * @return boolean  Whether to consider the event as private.\n     */\n    public function isPrivate($user = null)\n    {\n        global $registry;\n\n        if ($user === null) {\n            $user = $registry->getAuth();\n        }\n\n        // Never private if private is not true or if the current user is the\n        // event creator.\n        if ((!$this->private || $this->creator == $user) &&\n            $this->hasPermission(Horde_Perms::READ, $user)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the title of this event, considering private flags.\n     *\n     * @param string $user  The current user.\n     *\n     * @return string  The title of this event.\n     */\n    public function getTitle($user = null)\n    {\n        if (!$this->initialized) {\n            return '';\n        }\n\n        return $this->isPrivate($user)\n            ? _(\"busy\")\n            : (strlen($this->title) ? $this->title : _(\"[Unnamed event]\"));\n    }\n\n    /**\n     * Returns the location of this event, considering private flags.\n     *\n     * @param string $user  The current user.\n     *\n     * @return string  The location of this event.\n     */\n    public function getLocation($user = null)\n    {\n        return $this->isPrivate($user) ? '' : $this->location;\n    }\n\n    /**\n     * Checks to see whether the specified attendee is associated with the\n     * current event.\n     *\n     * @param string $email  The email address of the attendee.\n     *\n     * @return boolean  True if the specified attendee is present for this\n     *                  event.\n     */\n    public function hasAttendee($email)\n    {\n        return isset($this->attendees[Horde_String::lower($email)]);\n    }\n\n    /**\n     * Adds a new attendee to the current event.\n     *\n     * This will overwrite an existing attendee if one exists with the same\n     * email address.\n     *\n     * @param string $email        The email address of the attendee.\n     * @param integer $attendance  The attendance code of the attendee.\n     * @param integer $response    The response code of the attendee.\n     * @param string $name         The name of the attendee.\n     */\n    public function addAttendee($email, $attendance, $response, $name = null)\n    {\n        if ($attendance == Kronolith::PART_IGNORE) {\n            if (isset($this->attendees[$email])) {\n                $attendance = $this->attendees[$email]['attendance'];\n            } else {\n                $attendance = Kronolith::PART_REQUIRED;\n            }\n        }\n        if (empty($name) && isset($this->attendees[$email]) &&\n            !empty($this->attendees[$email]['name'])) {\n            $name = $this->attendees[$email]['name'];\n        }\n\n        $this->attendees[$email] = array(\n            'attendance' => $attendance,\n            'response' => $response,\n            'name' => $name\n        );\n    }\n\n    /**\n     * Adds a single resource to this event.\n     *\n     * No validation or acceptence/denial is done here...it should be done\n     * when saving the event.\n     *\n     * @param Kronolith_Resource $resource  The resource to add.\n     */\n    public function addResource($resource, $response)\n    {\n        $this->_resources[$resource->getId()] = array(\n            'attendance' => Kronolith::PART_REQUIRED,\n            'response' => $response,\n            'name' => $resource->get('name'),\n            'calendar' => $resource->get('calendar')\n        );\n    }\n\n    /**\n     * Removes a resource from this event.\n     *\n     * @param Kronolith_Resource $resource  The resource to remove.\n     */\n    public function removeResource($resource)\n    {\n        if (isset($this->_resources[$resource->getId()])) {\n            unset($this->_resources[$resource->getId()]);\n        }\n    }\n\n    /**\n     * Returns all resources.\n     *\n     * @return array  A copy of the resources array.\n     */\n    public function getResources()\n    {\n        return $this->_resources;\n    }\n\n    /**\n     * Set the entire resource array. Only used when copying an Event.\n     *\n     * @param array  $resources  The resource array.\n     * @since 4.2.6\n     */\n    public function setResources(array $resources)\n    {\n        $this->_resources = $resources;\n    }\n\n    public function isAllDay()\n    {\n        return $this->allday ||\n            ($this->start->hour == 0 && $this->start->min == 0 && $this->start->sec == 0 &&\n             (($this->end->hour == 23 && $this->end->min == 59) ||\n              ($this->end->hour == 0 && $this->end->min == 0 && $this->end->sec == 0 &&\n               ($this->end->mday > $this->start->mday ||\n                $this->end->month > $this->start->month ||\n                $this->end->year > $this->start->year))));\n    }\n\n    /**\n     * Syncronizes tags from the tagging backend with the task storage backend,\n     * if necessary.\n     *\n     * @param array $tags  Tags from the tagging backend.\n     */\n    public function synchronizeTags($tags)\n    {\n        if (isset($this->_internaltags)) {\n            $lower_internaltags = array_map('Horde_String::lower', $this->_internaltags);\n            $lower_tags = array_map('Horde_String::lower', $tags);\n            usort($lower_tags, 'strcoll');\n\n            if (array_diff($lower_internaltags, $lower_tags)) {\n                Kronolith::getTagger()->replaceTags(\n                    $this->uid,\n                    $this->_internaltags,\n                    $this->_creator,\n                    Kronolith_Tagger::TYPE_EVENT\n                );\n            }\n            $this->_tags = $this->_internaltags;\n        } else {\n            $this->_tags = $tags;\n        }\n    }\n\n    /**\n     * Reads form/post data and updates this event's properties.\n     *\n     * @param  Kronolith_Event|null $existing  If this is an exception event\n     *                                         this is taken as the base event.\n     *                                         @since 4.2.6\n     *\n     */\n    public function readForm(Kronolith_Event $existing = null)\n    {\n        global $prefs, $session;\n\n        // Event owner.\n        $targetcalendar = Horde_Util::getFormData('targetcalendar');\n        if (strpos($targetcalendar, '\\\\')) {\n            list(, $this->creator) = explode('\\\\', $targetcalendar, 2);\n        } elseif (!isset($this->_id)) {\n            $this->creator = $GLOBALS['registry']->getAuth();\n        }\n\n        // Basic fields.\n        $this->title = Horde_Util::getFormData('title', $this->title);\n        $this->description = Horde_Util::getFormData('description', $this->description);\n        $this->location = Horde_Util::getFormData('location', $this->location);\n        $this->timezone = Horde_Util::getFormData('timezone', $this->timezone);\n        $this->private = (bool)Horde_Util::getFormData('private');\n\n        // URL.\n        $url = Horde_Util::getFormData('eventurl', $this->url);\n        if (strlen($url)) {\n            // Analyze and re-construct.\n            $url = @parse_url($url);\n            if ($url) {\n                if (function_exists('http_build_url')) {\n                    if (empty($url['path'])) {\n                        $url['path'] = '/';\n                    }\n                    $url = http_build_url($url);\n                } else {\n                    $new_url = '';\n                    if (isset($url['scheme'])) {\n                        $new_url .= $url['scheme'] . '://';\n                    }\n                    if (isset($url['user'])) {\n                        $new_url .= $url['user'];\n                        if (isset($url['pass'])) {\n                            $new_url .= ':' . $url['pass'];\n                        }\n                        $new_url .= '@';\n                    }\n                    if (isset($url['host'])) {\n                        // Convert IDN hosts to ASCII.\n                        if (function_exists('idn_to_ascii')) {\n                            $url['host'] = @idn_to_ascii($url['host']);\n                        } elseif (Horde_Mime::is8bit($url['host'])) {\n                            //throw new Kronolith_Exception(_(\"Invalid character in URL.\"));\n                            $url['host'] = '';\n                        }\n                        $new_url .= $url['host'];\n                    }\n                    if (isset($url['path'])) {\n                        $new_url .= $url['path'];\n                    }\n                    if (isset($url['query'])) {\n                        $new_url .= '?' . $url['query'];\n                    }\n                    if (isset($url['fragment'])) {\n                        $new_url .= '#' . $url['fragment'];\n                    }\n                    $url = $new_url;\n                }\n            }\n        }\n        $this->url = $url;\n\n        // Status.\n        $this->status = Horde_Util::getFormData('status', $this->status);\n\n        // Attendees.\n        $attendees = $session->get('kronolith', 'attendees', Horde_Session::TYPE_ARRAY);\n        if (!is_null($newattendees = Horde_Util::getFormData('attendees'))) {\n            $newattendees = Kronolith::parseAttendees(trim($newattendees));\n            foreach ($newattendees as $email => $attendee) {\n                if (!isset($attendees[$email])) {\n                    $attendees[$email] = $attendee;\n                }\n            }\n            foreach (array_keys($attendees) as $email) {\n                if (!isset($newattendees[$email])) {\n                    unset($attendees[$email]);\n                }\n            }\n        }\n        $this->attendees = $attendees;\n\n        // Event start.\n        $allDay = Horde_Util::getFormData('whole_day');\n        if ($start_date = Horde_Util::getFormData('start_date')) {\n            // From ajax interface.\n            $this->start = Kronolith::parseDate($start_date . ' ' . Horde_Util::getFormData('start_time'), true, $this->timezone);\n            if ($allDay) {\n                $this->start->hour = $this->start->min = $this->start->sec = 0;\n            }\n        } elseif ($start = Horde_Util::getFormData('start')) {\n            // From traditional interface.\n            $start_year = $start['year'];\n            $start_month = $start['month'];\n            $start_day = $start['day'];\n            $start_hour = Horde_Util::getFormData('start_hour');\n            $start_min = Horde_Util::getFormData('start_min');\n            $am_pm = Horde_Util::getFormData('am_pm');\n\n            if (!$prefs->getValue('twentyFour')) {\n                if ($am_pm == 'PM') {\n                    if ($start_hour != 12) {\n                        $start_hour += 12;\n                    }\n                } elseif ($start_hour == 12) {\n                    $start_hour = 0;\n                }\n            }\n\n            if (Horde_Util::getFormData('end_or_dur') == 1) {\n                if ($allDay) {\n                    $start_hour = 0;\n                    $start_min = 0;\n                    $dur_day = 0;\n                    $dur_hour = 24;\n                    $dur_min = 0;\n                } else {\n                    $dur_day = (int)Horde_Util::getFormData('dur_day');\n                    $dur_hour = (int)Horde_Util::getFormData('dur_hour');\n                    $dur_min = (int)Horde_Util::getFormData('dur_min');\n                }\n            }\n\n            $this->start = new Horde_Date(array('hour' => $start_hour,\n                                                'min' => $start_min,\n                                                'month' => $start_month,\n                                                'mday' => $start_day,\n                                                'year' => $start_year),\n                                          $this->timezone);\n        }\n\n        // Event end.\n        if ($end_date = Horde_Util::getFormData('end_date')) {\n            // From ajax interface.\n            $this->end = Kronolith::parseDate($end_date . ' ' . Horde_Util::getFormData('end_time'), true, $this->timezone);\n            if ($allDay) {\n                $this->end->hour = $this->end->min = $this->end->sec = 0;\n                $this->end->mday++;\n            }\n        } elseif (Horde_Util::getFormData('end_or_dur') == 1) {\n            // Event duration from traditional interface.\n            $this->end = new Horde_Date(array('hour' => $start_hour + $dur_hour,\n                                              'min' => $start_min + $dur_min,\n                                              'month' => $start_month,\n                                              'mday' => $start_day + $dur_day,\n                                              'year' => $start_year));\n        } elseif ($end = Horde_Util::getFormData('end')) {\n            // From traditional interface.\n            $end_year = $end['year'];\n            $end_month = $end['month'];\n            $end_day = $end['day'];\n            $end_hour = Horde_Util::getFormData('end_hour');\n            $end_min = Horde_Util::getFormData('end_min');\n            $end_am_pm = Horde_Util::getFormData('end_am_pm');\n\n            if (!$prefs->getValue('twentyFour')) {\n                if ($end_am_pm == 'PM') {\n                    if ($end_hour != 12) {\n                        $end_hour += 12;\n                    }\n                } elseif ($end_hour == 12) {\n                    $end_hour = 0;\n                }\n            }\n\n            $this->end = new Horde_Date(array('hour' => $end_hour,\n                                              'min' => $end_min,\n                                              'month' => $end_month,\n                                              'mday' => $end_day,\n                                              'year' => $end_year),\n                                        $this->timezone);\n            if ($this->end->compareDateTime($this->start) < 0) {\n                $this->end = new Horde_Date($this->start);\n            }\n        }\n\n        $this->allday = false;\n\n        // Alarm.\n        if (!is_null($alarm = Horde_Util::getFormData('alarm'))) {\n            if ($alarm) {\n                $value = Horde_Util::getFormData('alarm_value');\n                $unit = Horde_Util::getFormData('alarm_unit');\n                if ($value == 0) {\n                    $value = $unit = 1;\n                }\n                $this->alarm = $value * $unit;\n                // Notification.\n                if (Horde_Util::getFormData('alarm_change_method')) {\n                    $types = Horde_Util::getFormData('event_alarms');\n                    $methods = array();\n                    if (!empty($types)) {\n                        foreach ($types as $type) {\n                            $methods[$type] = array();\n                            switch ($type){\n                            case 'notify':\n                                $methods[$type]['sound'] = Horde_Util::getFormData('event_alarms_sound');\n                                break;\n                            case 'mail':\n                                $methods[$type]['email'] = Horde_Util::getFormData('event_alarms_email');\n                                break;\n                            case 'popup':\n                                break;\n                            }\n                        }\n                    }\n                    $this->methods = $methods;\n                } else {\n                    $this->methods = array();\n                }\n            } else {\n                $this->alarm = 0;\n                $this->methods = array();\n            }\n        }\n\n        // Recurrence.\n        $this->recurrence = $this->readRecurrenceForm(\n            $this->start, $this->timezone, $this->recurrence);\n\n        // Convert to local timezone.\n        $this->setTimezone(false);\n\n        $this->_handleResources($existing);\n\n        // Tags.\n        $this->tags = Horde_Util::getFormData('tags', $this->tags);\n\n        // Geolocation\n        if (Horde_Util::getFormData('lat') && Horde_Util::getFormData('lon')) {\n            $this->geoLocation = array('lat' => Horde_Util::getFormData('lat'),\n                                       'lon' => Horde_Util::getFormData('lon'),\n                                       'zoom' => Horde_Util::getFormData('zoom'));\n        }\n\n        $this->initialized = true;\n    }\n\n    static public function readRecurrenceForm($start, $timezone,\n                                              $recurrence = null)\n    {\n        $recur = Horde_Util::getFormData('recur');\n        if (!strlen($recur)) {\n            return $recurrence;\n        }\n        if (!isset($recurrence)) {\n            $recurrence = new Horde_Date_Recurrence($start);\n        } else {\n            $recurrence->setRecurStart($start);\n        }\n        if (Horde_Util::getFormData('recur_end_type') == 'date') {\n            $end_date = Horde_Util::getFormData('recur_end_date', false);\n            if ($end_date !== false) {\n                // From ajax interface.\n                if (empty($end_date)) {\n                    throw new Kronolith_Exception(\"Missing required end date of recurrence.\");\n                }\n                $date_ob = Kronolith::parseDate($end_date, false);\n                $recur_enddate = array(\n                    'year'  => $date_ob->year,\n                    'month' => $date_ob->month,\n                    'day'  => $date_ob->mday);\n            } else {\n                // From traditional interface.\n                $recur_enddate = Horde_Util::getFormData('recur_end');\n            }\n            if ($recurrence->hasRecurEnd()) {\n                $recurEnd = $recurrence->recurEnd;\n                $recurEnd->month = $recur_enddate['month'];\n                $recurEnd->mday = $recur_enddate['day'];\n                $recurEnd->year = $recur_enddate['year'];\n            } else {\n                $recurEnd = new Horde_Date(\n                    array('hour' => 23,\n                          'min' => 59,\n                          'sec' => 59,\n                          'month' => $recur_enddate['month'],\n                          'mday' => $recur_enddate['day'],\n                          'year' => $recur_enddate['year']),\n                    $timezone);\n            }\n            $recurrence->setRecurEnd($recurEnd);\n        } elseif (Horde_Util::getFormData('recur_end_type') == 'count') {\n            $recurrence->setRecurCount(Horde_Util::getFormData('recur_count'));\n        } elseif (Horde_Util::getFormData('recur_end_type') == 'none') {\n            $recurrence->setRecurCount(0);\n            $recurrence->setRecurEnd(null);\n        }\n\n        $recurrence->setRecurType($recur);\n        switch ($recur) {\n        case Horde_Date_Recurrence::RECUR_DAILY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_daily_interval', 1));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_WEEKLY:\n            $weekly = Horde_Util::getFormData('weekly');\n            $weekdays = 0;\n            if (is_array($weekly)) {\n                foreach ($weekly as $day) {\n                    $weekdays |= $day;\n                }\n            }\n\n            if ($weekdays == 0) {\n                // Sunday starts at 0.\n                switch ($start->dayOfWeek()) {\n                case 0: $weekdays |= Horde_Date::MASK_SUNDAY; break;\n                case 1: $weekdays |= Horde_Date::MASK_MONDAY; break;\n                case 2: $weekdays |= Horde_Date::MASK_TUESDAY; break;\n                case 3: $weekdays |= Horde_Date::MASK_WEDNESDAY; break;\n                case 4: $weekdays |= Horde_Date::MASK_THURSDAY; break;\n                case 5: $weekdays |= Horde_Date::MASK_FRIDAY; break;\n                case 6: $weekdays |= Horde_Date::MASK_SATURDAY; break;\n                }\n            }\n\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_weekly_interval', 1));\n            $recurrence->setRecurOnDay($weekdays);\n            break;\n\n        case Horde_Date_Recurrence::RECUR_MONTHLY_DATE:\n            switch (Horde_Util::getFormData('recur_monthly_scheme')) {\n            case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n                $recurrence->setRecurType(Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY);\n            case Horde_Date_Recurrence::RECUR_MONTHLY_DATE:\n                $recurrence->setRecurInterval(\n                    Horde_Util::getFormData('recur_monthly')\n                        ? 1\n                        : Horde_Util::getFormData('recur_monthly_interval', 1)\n                );\n                break;\n            default:\n                $recurrence->setRecurInterval(Horde_Util::getFormData('recur_day_of_month_interval', 1));\n                break;\n            }\n            break;\n\n        case Horde_Date_Recurrence::RECUR_MONTHLY_WEEKDAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_week_of_month_interval', 1));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_DATE:\n            switch (Horde_Util::getFormData('recur_yearly_scheme')) {\n            case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            case Horde_Date_Recurrence::RECUR_YEARLY_DAY:\n                $recurrence->setRecurType(Horde_Util::getFormData('recur_yearly_scheme'));\n            case Horde_Date_Recurrence::RECUR_YEARLY_DATE:\n                $recurrence->setRecurInterval(\n                    Horde_Util::getFormData('recur_yearly')\n                        ? 1\n                        : Horde_Util::getFormData('recur_yearly_interval', 1)\n                );\n                break;\n            default:\n                $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_interval', 1));\n                break;\n            }\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_DAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_day_interval', $yearly_interval));\n            break;\n\n        case Horde_Date_Recurrence::RECUR_YEARLY_WEEKDAY:\n            $recurrence->setRecurInterval(Horde_Util::getFormData('recur_yearly_weekday_interval', $yearly_interval));\n            break;\n        }\n\n        foreach (array('exceptions', 'completions') as $what) {\n            if ($data = Horde_Util::getFormData($what)) {\n                if (!is_array($data)) {\n                    $data = explode(',', $data);\n                }\n                foreach ($data as $date) {\n                    list($year, $month, $mday) = sscanf($date, '%04d%02d%02d');\n                    if ($what == 'exceptions') {\n                        $recurrence->addException($year, $month, $mday);\n                    } else {\n                        $recurrence->addCompletion($year, $month, $mday);\n                    }\n                }\n            }\n        }\n\n        return $recurrence;\n    }\n\n    /**\n     * Handles updating/saving this event's resources. Unless this event recurs,\n     * this will delete this event from any resource calendars that are no\n     * longer needed (as when a resource is removed from an existing event). If\n     * this event is an exception, i.e., contains a baseid, AND $existing is\n     * provided, the resources from the original event are used for purposes\n     * of determining any resources that need to be removed.\n     *\n     *\n     * @param  Kronolith_Event|null $existing  An existing base event.\n     * @since 4.2.6\n     */\n    protected function _handleResources(Kronolith_Event $existing = null)\n    {\n        global $session;\n\n        if (Horde_Util::getFormData('isajax', false)) {\n            $resources = array();\n        } else {\n            $resources = $session->get('kronolith', 'resources', Horde_Session::TYPE_ARRAY);\n        }\n\n        $existingResources = $this->_resources;\n        $newresources = Horde_Util::getFormData('resources');\n        if (!empty($newresources)) {\n            foreach (explode(',', $newresources) as $id) {\n                try {\n                    $resource = Kronolith::getDriver('Resource')->getResource($id);\n                } catch (Kronolith_Exception $e) {\n                    $GLOBALS['notification']->push($e->getMessage(), 'horde.error');\n                    continue;\n                }\n                if (!($resource instanceof Kronolith_Resource_Group) ||\n                    $resource->isFree($this)) {\n                    $resources[$resource->getId()] = array(\n                        'attendance' => Kronolith::PART_REQUIRED,\n                        'response'   => Kronolith::RESPONSE_NONE,\n                        'name'       => $resource->get('name')\n                    );\n                } else {\n                    $GLOBALS['notification']->push(_(\"No resources from this group were available\"), 'horde.error');\n                }\n            }\n        }\n        $this->_resources = $resources;\n\n\n        // Have the base event, and this is an exception so we must\n        // match the recurrence in the resource's copy of the base event.\n        if (!empty($existing) && $existing->recurs() && !$this->recurs()) {\n            foreach ($existing->getResources() as $rid => $data) {\n                $resource = Kronolith::getDriver('Resource')->getResource($key);\n                $r_event = Kronolith::getDriver('Resource')->getByUID($existing->uid, $resource->calendar);\n                $r_event->recurrence = $event->recurrence;\n                $r_event->save();\n            }\n        }\n\n        // If we don't recur, check for removal of any resources so we can\n        // update those resources' calendars.\n        if (!$this->recurs()) {\n            $merged = $existingResources + $this->_resources;\n            $delete = array_diff(array_keys($existingResources), array_keys($this->_resources));\n            foreach ($delete as $key) {\n                // Resource might be declined, in which case it won't have the event\n                // on it's calendar.\n                if ($merged[$key]['response'] != Kronolith::RESPONSE_DECLINED) {\n                    try {\n                        Kronolith::getDriver('Resource')\n                            ->getResource($key)\n                            ->removeEvent($this);\n                    } catch (Kronolith_Exception $e) {\n                        $GLOBALS['notification']->push('foo', 'horde.error');\n                    }\n                }\n            }\n        }\n    }\n\n    public function html($property)\n    {\n        global $prefs;\n\n        $options = array();\n        $attributes = '';\n        $sel = false;\n        $label = '';\n\n        switch ($property) {\n        case 'start[year]':\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"Start Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $this->start->year .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'start[month]':\n            $sel = $this->start->month;\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"Start Month\");\n            break;\n\n        case 'start[day]':\n            $sel = $this->start->mday;\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Start Day\");\n            break;\n\n        case 'start_hour':\n            $sel = $this->start->format($prefs->getValue('twentyFour') ? 'G' : 'g');\n            $hour_min = $prefs->getValue('twentyFour') ? 0 : 1;\n            $hour_max = $prefs->getValue('twentyFour') ? 24 : 13;\n            for ($i = $hour_min; $i < $hour_max; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Start Hour\");\n            break;\n\n        case 'start_min':\n            $sel = sprintf('%02d', $this->start->min);\n            for ($i = 0; $i < 12; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"Start Minute\");\n            break;\n\n        case 'end[year]':\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"End Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $this->end->year .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'end[month]':\n            $sel = $this->end ? $this->end->month : $this->start->month;\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"End Month\");\n            break;\n\n        case 'end[day]':\n            $sel = $this->end ? $this->end->mday : $this->start->mday;\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"End Day\");\n            break;\n\n        case 'end_hour':\n            $sel = $this->end\n                ? $this->end->format($prefs->getValue('twentyFour') ? 'G' : 'g')\n                : $this->start->format($prefs->getValue('twentyFour') ? 'G' : 'g') + 1;\n            $hour_min = $prefs->getValue('twentyFour') ? 0 : 1;\n            $hour_max = $prefs->getValue('twentyFour') ? 24 : 13;\n            for ($i = $hour_min; $i < $hour_max; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"End Hour\");\n            break;\n\n        case 'end_min':\n            $sel = $this->end ? $this->end->min : $this->start->min;\n            $sel = sprintf('%02d', $sel);\n            for ($i = 0; $i < 12; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"End Minute\");\n            break;\n\n        case 'dur_day':\n            $dur = $this->getDuration();\n            return  '<label for=\"' . $property . '\" class=\"hidden\">' . _(\"Duration Day\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $dur->day .\n                '\" type=\"text\"' .\n                ' id=\"' . $property . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'dur_hour':\n            $dur = $this->getDuration();\n            $sel = $dur->hour;\n            for ($i = 0; $i < 24; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Duration Hour\");\n            break;\n\n        case 'dur_min':\n            $dur = $this->getDuration();\n            $sel = $dur->min;\n            for ($i = 0; $i < 13; ++$i) {\n                $min = sprintf('%02d', $i * 5);\n                $options[$min] = $min;\n            }\n            $label = _(\"Duration Minute\");\n            break;\n\n        case 'recur_end[year]':\n            if ($this->end) {\n                $end = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                        ? $this->recurrence->recurEnd->year\n                        : $this->end->year;\n            } else {\n                $end = $this->start->year;\n            }\n            return  '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . _(\"Recurrence End Year\") . '</label>' .\n                '<input name=\"' . $property . '\" value=\"' . $end .\n                '\" type=\"text\"' .\n                ' id=\"' . $this->_formIDEncode($property) . '\" size=\"4\" maxlength=\"4\" />';\n\n        case 'recur_end[month]':\n            if ($this->end) {\n                $sel = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                    ? $this->recurrence->recurEnd->month\n                    : $this->end->month;\n            } else {\n                $sel = $this->start->month;\n            }\n            for ($i = 1; $i < 13; ++$i) {\n                $options[$i] = strftime('%b', mktime(1, 1, 1, $i, 1));\n            }\n            $label = _(\"Recurrence End Month\");\n            break;\n\n        case 'recur_end[day]':\n            if ($this->end) {\n                $sel = ($this->recurs() && $this->recurrence->hasRecurEnd())\n                    ? $this->recurrence->recurEnd->mday\n                    : $this->end->mday;\n            } else {\n                $sel = $this->start->mday;\n            }\n            for ($i = 1; $i < 32; ++$i) {\n                $options[$i] = $i;\n            }\n            $label = _(\"Recurrence End Day\");\n            break;\n        }\n\n        if (!$this->_varRenderer) {\n            $this->_varRenderer = Horde_Core_Ui_VarRenderer::factory('Html');\n        }\n\n        return '<label for=\"' . $this->_formIDEncode($property) . '\" class=\"hidden\">' . $label . '</label>' .\n            '<select name=\"' . $property . '\"' . $attributes . ' id=\"' . $this->_formIDEncode($property) . '\">' .\n            $this->_varRenderer->selectOptions($options, $sel) .\n            '</select>';\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getViewUrl($params = array(), $full = false, $encoded = true)\n    {\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->setRaw(!$encoded)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getEditUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'EditEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getDeleteUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'DeleteEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    /**\n     * @param array $params\n     *\n     * @return Horde_Url\n     */\n    public function getExportUrl($params = array(), $full = false)\n    {\n        $params['view'] = 'ExportEvent';\n        $params['eventID'] = $this->id;\n        $params['calendar'] = $this->calendar;\n        $params['type'] = $this->calendarType;\n\n        return Horde::url('event.php', $full)->add($params);\n    }\n\n    public function getLink($datetime = null, $icons = true, $from_url = null,\n                            $full = false, $encoded = true)\n    {\n        global $prefs;\n\n        if (is_null($datetime)) {\n            $datetime = $this->start;\n        }\n        if (is_null($from_url)) {\n            $from_url = Horde::selfUrl(true, false, true);\n        }\n\n        $event_title = $this->getTitle();\n        $view_url = $this->getViewUrl(array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'), 'url' => $from_url), $full, $encoded);\n        $read_permission = $this->hasPermission(Horde_Perms::READ);\n\n        $link = '<span' . $this->getCSSColors() . '>';\n        if ($read_permission && $view_url) {\n            $link .= Horde::linkTooltip($view_url,\n                                       $event_title,\n                                       $this->getStatusClass(),\n                                       '',\n                                       '',\n                                       $this->getTooltip(),\n                                       '',\n                                       array('style' => $this->getCSSColors(false)));\n        }\n        $link .= htmlspecialchars($event_title);\n        if ($read_permission && $view_url) {\n            $link .= '</a>';\n        }\n\n        if ($icons && $prefs->getValue('show_icons')) {\n            $icon_color = $this->_foregroundColor == '#000' ? '000' : 'fff';\n            $status = '';\n            if ($this->alarm) {\n                if ($this->alarm % 10080 == 0) {\n                    $alarm_value = $this->alarm / 10080;\n                    $title = sprintf(ngettext(\"Alarm %d week before\", \"Alarm %d weeks before\", $alarm_value), $alarm_value);\n                } elseif ($this->alarm % 1440 == 0) {\n                    $alarm_value = $this->alarm / 1440;\n                    $title = sprintf(ngettext(\"Alarm %d day before\", \"Alarm %d days before\", $alarm_value), $alarm_value);\n                } elseif ($this->alarm % 60 == 0) {\n                    $alarm_value = $this->alarm / 60;\n                    $title = sprintf(ngettext(\"Alarm %d hour before\", \"Alarm %d hours before\", $alarm_value), $alarm_value);\n                } else {\n                    $alarm_value = $this->alarm;\n                    $title = sprintf(ngettext(\"Alarm %d minute before\", \"Alarm %d minutes before\", $alarm_value), $alarm_value);\n                }\n                $status .= Horde::fullSrcImg('alarm-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconAlarm')));\n            }\n\n            if ($this->recurs()) {\n                $title = Kronolith::recurToString($this->recurrence->getRecurType());\n                $status .= Horde::fullSrcImg('recur-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconRecur')));\n            } elseif ($this->baseid) {\n                $title = _(\"Exception\");\n                $status .= Horde::fullSrcImg('exception-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconRecur')));\n            }\n\n            if ($this->private) {\n                $title = _(\"Private event\");\n                $status .= Horde::fullSrcImg('private-' . $icon_color . '.png', array('attr' => array('alt' => $title, 'title' => $title, 'class' => 'iconPrivate')));\n            }\n\n            if (!empty($this->attendees)) {\n                $status .= Horde::fullSrcImg('attendees-' . $icon_color . '.png', array('attr' => array('alt' => _(\"Meeting\"), 'title' => _(\"Meeting\"), 'class' => 'iconPeople')));\n            }\n\n            $space = ' ';\n            if (!empty($this->icon)) {\n                $link = $status . ' <img class=\"kronolithEventIcon\" src=\"' . $this->icon . '\" /> ' . $link;\n            } elseif (!empty($status)) {\n                $link .= ' ' . $status;\n                $space = '';\n            }\n\n            if ((!$this->private ||\n                 $this->creator == $GLOBALS['registry']->getAuth()) &&\n                Kronolith::getDefaultCalendar(Horde_Perms::EDIT)) {\n                $url = $this->getEditUrl(\n                    array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'),\n                          'url' => $from_url),\n                    $full);\n                if ($url) {\n                    $link .= $space\n                        . $url->link(array('title' => sprintf(_(\"Edit %s\"), $event_title),\n                                           'class' => 'iconEdit'))\n                        . Horde::fullSrcImg('edit-' . $icon_color . '.png',\n                                            array('attr' => array('alt' => _(\"Edit\"))))\n                        . '</a>';\n                    $space = '';\n                }\n            }\n            if ($this->hasPermission(Horde_Perms::DELETE)) {\n                $url = $this->getDeleteUrl(\n                    array('datetime' => $datetime->strftime('%Y%m%d%H%M%S'),\n                          'url' => $from_url),\n                    $full);\n                if ($url) {\n                    $link .= $space\n                        . $url->link(array('title' => sprintf(_(\"Delete %s\"), $event_title),\n                                           'class' => 'iconDelete'))\n                        . Horde::fullSrcImg('delete-' . $icon_color . '.png',\n                                            array('attr' => array('alt' => _(\"Delete\"))))\n                        . '</a>';\n                }\n            }\n        }\n\n        return $link . '</span>';\n    }\n\n    /**\n     * Returns the CSS color definition for this event.\n     *\n     * @param boolean $with_attribute  Whether to wrap the colors inside a\n     *                                 \"style\" attribute.\n     *\n     * @return string  A CSS string with color definitions.\n     */\n    public function getCSSColors($with_attribute = true)\n    {\n        $css = 'background-color:' . $this->_backgroundColor . ';color:' . $this->_foregroundColor;\n        if ($with_attribute) {\n            $css = ' style=\"' . $css . '\"';\n        }\n        return $css;\n    }\n\n    /**\n     * @return string  A tooltip for quick descriptions of this event.\n     */\n    public function getTooltip()\n    {\n        $tooltip = $this->getTimeRange()\n            . \"\\n\" . sprintf(_(\"Owner: %s\"), ($this->creator == $GLOBALS['registry']->getAuth() ?\n                                              _(\"Me\") : Kronolith::getUserName($this->creator)));\n\n        if (!$this->isPrivate()) {\n            if ($this->location) {\n                $tooltip .= \"\\n\" . _(\"Location\") . ': ' . $this->location;\n            }\n\n            if ($this->description) {\n                $tooltip .= \"\\n\\n\" . Horde_String::wrap($this->description);\n            }\n        }\n\n        return $tooltip;\n    }\n\n    /**\n     * @return string  The time range of the event (\"All Day\", \"1:00pm-3:00pm\",\n     *                 \"08:00-22:00\").\n     */\n    public function getTimeRange()\n    {\n        if ($this->isAllDay()) {\n            return _(\"All day\");\n        } elseif (($cmp = $this->start->compareDate($this->end)) > 0) {\n            $df = $GLOBALS['prefs']->getValue('date_format');\n            if ($cmp > 0) {\n                return $this->end->strftime($df) . '-'\n                    . $this->start->strftime($df);\n            } else {\n                return $this->start->strftime($df) . '-'\n                    . $this->end->strftime($df);\n            }\n        } else {\n            $twentyFour = $GLOBALS['prefs']->getValue('twentyFour');\n            return $this->start->format($twentyFour ? 'G:i' : 'g:ia')\n                . '-'\n                . $this->end->format($twentyFour ? 'G:i' : 'g:ia');\n        }\n    }\n\n    /**\n     * @return string  The CSS class for the event based on its status.\n     */\n    public function getStatusClass()\n    {\n        switch ($this->status) {\n        case Kronolith::STATUS_CANCELLED:\n            return 'kronolith-event-cancelled';\n\n        case Kronolith::STATUS_TENTATIVE:\n        case Kronolith::STATUS_FREE:\n            return 'kronolith-event-tentative';\n        }\n    }\n\n    protected function _formIDEncode($id)\n    {\n        return str_replace(array('[', ']'),\n                           array('_', ''),\n                           $id);\n    }\n\n    /**\n     * Ensure the given string is valid UTF-8.\n     *\n     * @param string $text  The string to ensure contains no invalid UTF-8 sequences.\n     *\n     * @return string|boolean  The valid UTF-8 string, possibly with illegal sequences removed.\n     */\n    protected function _ensureUtf8($text)\n    {\n        if (Horde_String::validUtf8($text)) {\n            return $text;\n        }\n\n        return preg_replace('/[^\\x09\\x0A\\x0D\\x20-\\x7E]/', '', $text);\n    }\n}\n"], "filenames": ["lib/Event.php"], "buggy_code_start_loc": [2405], "buggy_code_end_loc": [2407], "fixing_code_start_loc": [2405], "fixing_code_end_loc": [2407], "type": "CWE-79", "message": "In Horde Groupware 5.2.19-5.2.22, there is XSS via the URL field in a \"Calendar -> New Event\" action.", "other": {"cve": {"id": "CVE-2017-16906", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-20T20:29:00.340", "lastModified": "2020-08-29T22:15:13.327", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Horde Groupware 5.2.19-5.2.22, there is XSS via the URL field in a \"Calendar -> New Event\" action."}, {"lang": "es", "value": "En Horde Groupware 5.2.19-5.2.22, existe XSS mediante el campo URL en una acci\u00f3n \"Calendar -> New Event\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:horde:groupware:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2.19", "versionEndIncluding": "5.2.22", "matchCriteriaId": "19922FDE-5ACF-4BDA-A569-E8579F047E60"}]}]}], "references": [{"url": "http://code610.blogspot.com/2017/11/rce-via-xss-horde-5219.html", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/horde/kronolith/commit/09d90141292f9ec516a7a2007bf828ce2bbdf60d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/starnightcyber/Miscellaneous/blob/master/Horde/README.md", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00049.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/horde/kronolith/commit/09d90141292f9ec516a7a2007bf828ce2bbdf60d"}}