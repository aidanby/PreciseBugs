{"buggy_code": ["Products.CMFCore Changelog\n==========================\n\n3.2 (unreleased)\n----------------\n\n- Nothing changed yet.\n\n\n3.1 (2023-06-01)\n----------------\n\n- Provide a way to not publish items that are acquired.\n\n\n3.0 (2023-04-25)\n----------------\n\n- SkinsTool: fix Find form with Zope ZMI\n  (`#127 <https://github.com/zopefoundation/Products.CMFCore/pull/127>`_).\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n- Drop support for ``Zope 4.x``.\n\n- Make tests compatible with ``Zope >= 5.7.1``.\n\n\n2.7.0 (2022-12-16)\n------------------\n\n- Fix insidious buildout configuration bug for tests against Zope 4.\n\n- Add support for Python 3.11.\n\n\n2.6.0 (2022-07-13)\n------------------\n\n- Fix cookie test failure\n  (`#120 <https://github.com/zopefoundation/Products.CMFCore/pull/120>`_).\n\n- Add support for Python 3.10.\n\n\n2.5.4 (2021-07-29)\n------------------\n\n- Fix code and tests when running on ``Products.GenericSetup >= 2.1.2``, thus\n  requiring at least that version.\n\n\n2.5.3 (2021-06-30)\n------------------\n\n- Do not break at startup when ``subscribers.zcml`` is included but no\n  ``portal_catalog`` object is in the database, e. g. when starting for the\n  first time.\n  (`#115 <https://github.com/zopefoundation/Products.CMFCore/pull/115>`_)\n\n\n2.5.2 (2021-06-24)\n------------------\n\n- Avoid DeprecationWarning for changed import location for ``rfc1123_date``\n\n- Fix several DeprecationWarnings during unit tests\n  (`#112 <https://github.com/zopefoundation/Products.CMFCore/issues/112>`_)\n\n- Set Cache-Control header in '304 Not Modified' response case as well.\n  (`#111 <https://github.com/zopefoundation/Products.CMFCore/issues/111>`_)\n\n\n2.5.1 (2021-03-12)\n------------------\n\n- Make sure ``getSkinNameFromRequest`` only returns sane values\n  (`#109 <https://github.com/zopefoundation/Products.CMFCore/issues/109>`_)\n\n- Fix Python 3 incompatibility in ``CookieCrumbler.credentialsChanged``\n\n\n2.5.0 (2021-02-09)\n------------------\n\n- Update configuration for version 5 of ``isort``.\n\n- Fix deprecation warnings occurring on Zope 5.\n\n- Added support for Python 3.9.\n\n\n2.4.8 (2020-07-03)\n------------------\n\n- Fix an issue with the indexing queue where an UNINDEX followed by REINDEX was\n  wrongly optimized to UNINDEX instead of REINDEX.\n  (`#96 <https://github.com/zopefoundation/Products.CMFCore/pull/96>`_)\n\n\n2.4.7 (2020-06-24)\n------------------\n\n- Change the default value of uid to None on CMFCatalogAware's reindexObject method (`#87 <https://github.com/zopefoundation/Products.CMFCore/issues/87>`_)\n\n\n2.4.6 (2020-04-14)\n------------------\n\n- Redid most filesystem content type ZMI Customize views.\n\n\n2.4.5 (2020-03-27)\n------------------\n\n- Fix tests to be able to run on Zope 4.3.\n\n- Fix not declared dependency on ``Products.DCWorkflow`` in `subscribers.zcml`.\n\n\n2.4.4 (2020-01-29)\n------------------\n\n- Remove Zope Help System fossils so this products is compatible with Zope 5\n\n\n2.4.3 (2020-01-10)\n------------------\n\n- Fix encoding detection for XML files.\n  (`#85 <https://github.com/zopefoundation/Products.CMFCore/issues/85>`_)\n\n\n2.4.2 (2019-11-28)\n------------------\n\n- Resolve ``docutils`` dependency conflict with ``Zope``.\n  (`#83 <https://github.com/zopefoundation/Products.CMFCore/issues/83>`_)\n\n\n2.4.1 (2019-11-27)\n------------------\n\n- Make sure ``FSFile.__str__`` returns correct native strings under Python 3.\n  (`#76 <https://github.com/zopefoundation/Products.CMFCore/issues/76>`_)\n\n- Add a ``__bytes__`` method to ``FSFile``.\n\n- Add more files types to the FSFile registrations.\n\n\n2.4.0 (2019-05-10)\n------------------\n\n- Set default encoding values on FSDTMLMethods.\n\n\n2.4.0b8 (2019-04-30)\n--------------------\n\n- Fix up all ZMI forms to work better with the Zope 4 ZMI.\n  (`#73 <https://github.com/zopefoundation/Products.CMFCore/issues/73>`_)\n\n- Ensure Content Type Registries don't use a ZMI add dialog in the Zope 4 ZMI.\n  (`#72 <https://github.com/zopefoundation/Products.CMFCore/issues/72>`_)\n\n\n2.4.0b7 (2019-04-08)\n--------------------\n\n- Expose the Cookie Crumbler title property.\n  (`#70 <https://github.com/zopefoundation/Products.CMFCore/issues/70>`_)\n\n- Clean up test and linting configurations.\n\n- Add ``project_urls`` with relevant links in ``setup.py``.\n\n- Specify supported Python versions using ``python_requires`` in setup.py.\n\n- Added support for Python 3.8.\n\n- Deprecated unused method ``PortalCatalogProcessor.get_dispatcher``.\n  (`#57 <https://github.com/zopefoundation/Products.CMFCore/issues/57>`_)\n\n- Backport plone/collective.indexing#16 to use the catalog queue\n  also when reindexing the object security.\n  (`#58 <https://github.com/zopefoundation/Products.CMFCore/issues/58>`_)\n\n- Code cleanup: avoid to call the ``keys`` method on dictionary\n  when not needed.\n  [ale-rt]\n\n\n2.4.0b6 (2018-12-14)\n--------------------\n\n- Change `im_self` to `__self__` for Python 3 compatibility.\n  (`#54 <https://github.com/zopefoundation/Products.CMFCore/pull/54>`_)\n  [ale-rt, vangheem]\n\n- Remove support for testing using ``'python setup.py test``.\n  (`#51 <https://github.com/zopefoundation/Products.CMFCore/issues/51>`_)\n\n- Add more ZMI icons for the Zope 4 ZMI.\n  (`#47 <https://github.com/zopefoundation/Products.CMFCore/issues/47>`_)\n\n- Prevent warnings on Zope start about permissions for not existing methods.\n  This requires `Zope >= 4.0b8`.\n  (`#53 <https://github.com/zopefoundation/Products.CMFCore/pull/53>`_)\n\n- Fix deprecation warnings occurring during test runs.\n\n- Update tests to `Products.GenericSetup >= 2.0b5`.\n\n\n2.4.0b5 (2018-11-07)\n--------------------\n\n- Fix ``notifyModified`` called on a wrong object.\n  [mamico]\n\n- Add support for Python 3.7.\n\n- Add support for `Zope >= 4.0b6`, thus requiring at least this version.\n\n\n2.4.0b4 (2018-05-17)\n--------------------\n\n- Add support for Python 3.5 and 3.6.\n  [ale-rt]\n\n- `sortKey` for a DataManager must be text to be sortable.\n  [pbauer]\n\n\n2.4.0b3 (2018-03-16)\n--------------------\n\n- Remove dependency on ``five.globalrequest``, its functionality\n  is provided by ``zope.globalrequest``.\n\n- Do not autogenerate `string:${portal_url}/`, when no input for\n  `content_icon` was provided.\n  [pgrunewald]\n\n- Avoid writing MemberData to the member data tool until\n  properties are actually set.\n  [davisagli]\n\n- Python 2 / 3 compatible imports.\n  [rudaporto]\n\n- Update Products.MailHost dependency to 4.0\n  [dataflake]\n\n- Add icons for Bootstrap ZMI.\n  [icemac, dwt]\n\n\n2.4.0b2 (2017-05-05)\n--------------------\n\n- Factored support for FSZSQL methods out into a setup extra.\n  If you need support for Filesystem ZSQL methods, install the\n  egg specifying the ``zsql`` extra.\n  [dataflake]\n\n- Use ``zope.interface.implementer`` decorator instead of\n  ``zope.interface.implements``\n  [dataflake]\n\n- Use security declaration decorator notation where possible.\n  [dataflake]\n\n- Improve the new indexing object wrapping for unindexing by using a\n  module-level wrapper class based on zope.proxy instead of a class\n  at method level.\n  Some discussion available at GitHub PR #15.\n  [dataflake]\n\n- Queue and process indexing operations (index, reindex, unindex) at\n  transaction boundaries. This allows to reduce redundant operations\n  and thus improving performance.\n  Operations are processed just at transaction boundaries or whenever\n  a catalog search is performed.\n  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n  [gforcada]\n\n- Provide a ``CATALOG_OPTIMIZATION_DISABLED`` environment variable to\n  disable any catalog optimization. This is mostly meant to be used so that\n  tests which may need some adaptation do not break after updating to\n  this version. Set it to ``true``, i.e.\n  ``export CATALOG_OPTIMIZATION_DISABLED=true`` before running tests.\n  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n  [gforcada]\n\n\n2.4.0b1 (2017-05-04)\n--------------------\n\n- Target use with Zope 4:  no longer support 2.13.x.\n\n- Make sure RegistrationTool.addMember is not published\n  [vangheem]\n\n- Don't fail on catalog inconsistency when doing `reindexObjectSecurity`\n  [tomgross]\n\n2.3.0 (2015-02-20)\n------------------\n\n- Fall back to DAV aware marshaller when importing or exporting folderish\n  content, so types now retain their metadata when being round-tripped.\n  [MatthewWilkes]\n\n- IndexableObjectWrapper: Made sure portal_type doesn't return None.\n  Products.ZCatalog 3 indexes can no longer handle None values.\n\n- interfaces: Fixed dotted names by setting __module__ explicitly.\n\n- Skinnable: The skins tool is now looked up as utility.\n  'getSkinsFolderName' is no longer supported, that method was removed.\n\n- permissions: Fixed some issues in permissions.zcml.\n\n- support unset portal_skins request variables in HTTP headers\n  (see https://dev.plone.org/ticket/10071) [fRiSi]\n\n2.3.0-beta2 (2012-03-31)\n------------------------\n\n- added fixes for migrating CMF 2.2 sites.\n\n\n2.3.0-beta (2012-03-21)\n------------------------\n\n- DynamicType: Modified 'icon' method.\n  The specified icon might be registered for a ZTK layer that is not available\n  in the ZMI. If the icon can't be found, an empty string is returned.\n\n- exportimport.tests.test_mailhost:  Accomodate 'smtp_queue' and\n  'smtp_queue_directory' exports (newly added in GenericSetup).\n\n- tools: Converted all tools into local utilities.\n  The registration is not done here, see CMFDefault_ as an example of a\n  registration via GenericSetup.\n\n- MemberDataTool: Changed property modes to 'w' and added 'fullname' property.\n\n- setup handlers: Improved content type registry handler.\n  The 'insert-before' and 'insert-after' directives are now supported.\n\n- Optimize `SkinnableObjectManager.__getattr__` to short circuit view (`@`) and\n  traverser (`+`) lookup in addition to `_` and `aq_`.\n\n- Avoid a shallow dependency on `Products.ZReST`.\n\n- Fixed types tool test to only test creation for type infos.\n\n- utils: Fixed '_OldCacheHeaders' and '_FSCacheHeaders' methods.\n  DateTimeErrors caused by invalid HTTP headers were not caught.\n\n- setup handlers: Added export/import support for member data tool settings.\n\n- MemberDataTool: Fixed tool initialization.\n  The default boolean and date property values were not set correctly.\n\n- MemberDataTool: Modified 'setProperties' method.\n  It now can be used by user managers as well.\n\n- MembershipTool: Added 'isMemberAccessAllowed' method.\n  If you don't have the 'Manage users' permission for the membership tool, you\n  shouldn't have write access to other members.\n\n- MemberDataTool: Removed obsolete MemberData factory lookup.\n  This feature was added in CMF 2.2, but now the MemberAdapter should be\n  overridden instead.\n\n- MemberDataTool: Split up MemberData class.\n  The old MemberData API is now provided by the new MemberAdapter. The\n  persistent MemberData objects are just used for storing member data.\n\n- interfaces: Added 'IMember' interface.\n\n- permissions: Marked 'setDefaultRoles' as deprecated.\n\n- DirectoryView: Added 'bobobase_modification_time' method to FSObject.\n  The \"Contents\" tab in the ZMI now shows useful 'Last Modified' values.\n\n- DirectoryView: Changed debug mode behavior.\n  No additional subdirs are registered in debug mode. If you add new subdirs,\n  you have to restart your instance.\n  (https://bugs.launchpad.net/zope-cmf/+bug/271027)\n\n- DirectoryView: Improved debug mode speed on NTFS partitions.\n  The much faster non-Windows implementation is now used on Windows as well if\n  non-FAT32 time stamps are detected. In rare cases that heuristic approach\n  might fail to detected NTFS partitions.\n\n- DirectoryView: Modernized debug mode lookup.\n  Now getConfiguration().debug_mode is used instead of Globals.DevelopmentMode.\n\n- Fix content exportimport when Title or Description are unicode (merge from\n  2.2 branch).\n\n- tests base: Tightened security for anonymous test user.\n\n- Load permissions.zcml from Products.Five in the test to fix tests\n  with Zope 2.12.\n\n- notifyWorkflowCreated only to IWorkflowAware, possibly following adaption on\n  IObjectAddedEvent.\n\n- Adapterize workflow storage lookups.\n\n- utils: Added FakeExecutableObject.\n  It can be used to set proxy roles in trusted code.\n\n- tests base: Removed obsolete test utils.\n\n- testing: Removed broken run function.\n  Unit test modules are no longer directly executable.\n\n- CookieCrumbler: Removed redirect support.\n  The Unauthorized handling and redirects are now part of CMFDefault.\n\n- Added a permissions.zcml file defining our own permissions. This was\n  formerly done in Zope 2's Products.Five.\n\n- Removed zope.app.testing dependency.\n\n- Import BeforeTraverseEvent from new location if available.\n\n- Skinnable and MembershipTool: Removed support for missing REQUEST argument.\n  'changeSkin', 'setupCurrentSkin' and 'credentialsChanged' will no longer\n  try to acquire the request if it is not passed in explicitly.\n\n- Tools and PortalFolder: Removed support for deprecated marker attributes.\n  '_isDirectoryView', '_isPortalRoot', '_isTypeInformation' and '_isAWorkflow'\n  are no longer supported.\n\n- utils: Removed deprecated functions.\n  'getToolByInterfaceName', 'initializeBasesPhase1', 'initializeBasesPhase2',\n  'expandpath' and 'minimalpath' are no longer available.\n\n- DirectoryView: Removed support for deprecated old API.\n\n- Require at least Zope 2.13.12.\n\n.. _CMFDefault : https://github.com/zopefoundation/Products.CMFDefault/blob/master/Products/CMFDefault/profiles/default/componentregistry.xml\n\n2.2.5 (2011-11-01)\n------------------\n\n- Added two missing explicit InitializeClass calls.\n\n\n2.2.4 (2011-04-02)\n------------------\n\n- Fix content exportimport when Title or Description are unicode.\n\n\n2.2.3 (2010-10-31)\n------------------\n\n- Make the error raised when trying to rename an instance of ImmutableId\n  indicate the id of the object.\n\n- DateTime 2.12.5 does away with a special case representing\n  DateTime values for midnight (00:00:00) without their time and\n  time zone values. So DateTimes formerly rendered as\n  ``2010/01/01`` in the UTC timezone now render as\n  ``2010/01/01 00:00:00 UTC``. Several unit tests that relied on\n  the old-style representation had to be fixed.\n\n- Get most tests working under Zope 2.13.0a2.\n\n- Added dependency on the new ``Products.ZSQLMethods`` distribution and updated\n  Zope2 requirement accordingly.\n\n\n2.2.2 (2010-07-04)\n------------------\n\n- Backport test setup fixes for Zope 2.13 compatibility.\n\n- Use the standard libraries doctest module.\n\n- Updated setDefaultRoles to use the addPermission API if available.\n\n- Updated test to work with zope.contenttype >= 3.4.3.\n\n\n2.2.1 (2010-04-07)\n------------------\n\n- Actions and TypeInformation: Clear the compiled NNN_expr_object\n  property when the NNN_expr property is cleared.\n\n- Actions: Return None if 'link_target' is an empty string.\n  This helps to avoid invalid empty 'target' attributes in HTML output.\n\n\n2.2.0 (2010-01-04)\n------------------\n\n- Changed GenericSetup import handlers to fail silently if they\n  are called in a context that does not contain the items they\n  import.\n\n\n2.2.0-beta (2009-12-06)\n-----------------------\n\n- TypesTool: Made it an ordered container.\n  This allows to control the order of the add actions.\n\n- TypeInformation: Removed redundant 'content_icon' property.\n  For backwards compatibility old settings containing 'content_icon' instead\n  of 'icon_expr' are converted on import. CMFDefault provides the necessary\n  upgrade steps for migrating existing sites.\n\n- DynamicType: Added 'getIconURL' method.\n  This replaces the now deprecated 'getIcon' method.\n\n- TypeInformation: Added 'getIconExprObject' method.\n  This replaces the now deprecated 'getIcon' method.\n\n\n2.2.0-alpha (2009-11-13)\n------------------------\n\n- Got rid of redundant icon related type info properties.\n  (https://bugs.launchpad.net/zope-cmf/+bug/397795)\n\n- PortalFolder: Ensure that pasting an object into a folder takes\n  workflow instance creation conditions into account.\n  (https://bugs.launchpad.net/zope-cmf/+bug/308947)\n\n- Made calls to reindexObjectSecurity in the membership tool conditional\n  after the CMFCatalogAware refactoring.\n\n- PortalFolder: Removed unused ICatalogAware and IWorkflowAware methods.\n\n- CMFCatalogAware: Split up CMFCatalogAware mixin.\n  CatalogAware, WorkflowAware and OpaqueItemManager are now separate mixins.\n\n- Changed testing.py to directly load zope.traversing's ZCML instead of going\n  via the Five traversing.zcml BBB shim.\n\n- moved the Zope dependency to version 2.12.0b3dev\n\n- PortalFolder: Modified allowedContentTypes method to check\n  isConstructionAllowed only for allowed types, not for all content types.\n\n- Fixed typo in the acquisition wrapping of the found utility in\n  getToolByName.\n\n- Actions: Add a link_target attribute to store a value for the\n  final rendered link tag's \"target\" attribute\n  (https://bugs.launchpad.net/zope-cmf/+bug/376951)\n\n- MemberData tool: Make it easier to override the default\n  MemberData implementation by trying to look up a named\n  factory utility named \"MemberData\" before falling back on the\n  default MemberData class.\n  (https://bugs.launchpad.net/zope-cmf/+bug/377208)\n\n- FSPageTemplate: Change the charset/encoding detection to consider\n  charset specifications in the content type, and replace the\n  hardcoded Latin-15 fallback with the mechanism used by the\n  Products.PageTemplate code, which can be influenced by setting\n  the environment variable \"ZPT_PREFERRED_ENCODING\"\n  (https://bugs.launchpad.net/zope-cmf/+bug/322263)\n\n- Expose the ZMI manage view of the \"_components\" object manager as\n  a new \"Components Folder\" tab in the ZMI.\n\n- ActionsTool: The \"Action Providers\" tab in the ZMI did not render\n  actions from the WorkflowTool correctly since those are not\n  'new-style' actions.\n  (https://bugs.launchpad.net/zope-cmf/+bug/322300)\n\n- FSPageTemplate: Prevent reading the underlying file without doing\n  anything with the data in some cases.\n\n- FSObject: Ensure that ZCache invalidations only happens if the\n  filesystem modification time differs from the internally stored\n  previous modification time.\n  (https://bugs.launchpad.net/zope-cmf/+bug/325246)\n\n- TypeInformation: DCWorkflow instances define a method and a guard\n  for vetoing object creation, but it was never used. Now\n  TypeInformation objects will consult these guard conditions during\n  object creation.\n  (https://bugs.launchpad.net/zope-cmf/+bug/308947)\n\n- PortalCatalog: Changed to use a multi-adaptor to allow a pluggable\n  IndexableObjectWrapper class.  Objects that implement IIndexableObject\n  are not wrapped.  The change will assist in integrating with\n  other indexing strategies from third-party packages.\n\n- Events: Changed 'handleContentishEvent' behavior for IObjectCopiedEvent.\n  'WorkflowTool.notifyCreated' no longer resets the workflow state, so the\n  the event subscriber clears the workflow history instead.\n\n- WorkflowTool: 'notifyCreated' no longer overrides assigned workflow states.\n\n- No longer catch a `NotImplemented` string exception in the MembershipTool\n  in deleteMembers.\n\n- Cleaned up / normalized imports:\n\n  o Don't import from Globals;  instead, use real locations.\n\n  o Make other imports use the actual source module, rather than an\n    intermediate (e.g., prefer importing 'ClassSecurityInfo' from\n    'AccessControl.SecurityInfo' rather than from 'AccessControl').\n\n  o Avoid relative imports, which will break in later versions of Python.\n\n- Added `icon_expr` as a new property to type information. This allows you\n  to specify the `content_icon` as an expression and store it. This avoids\n  creating the expression on the fly at rendering time.\n\n- Removed superGetAttr fallback from SkinnableObjectManager. None of its base\n  classes have a `__getattr__` method anymore.\n\n- PortalObject: Removed backwards compatibility code in getSiteManager.\n  Please use CMFDefault's upgrade steps for upgrading old CMF sites.\n\n- Fixed compatibility with non-string exceptions on Zope trunk.\n\n- Added remove support to GenericSetup types tool exportimport handler.\n\n- FiveActionsTool: Removed the tool and all functionality for bridging\n  between Zope 3-style menu items and CMF actions. The CMF has been going\n  a different route for a long time and the code is unused and\n  unmaintained.\n\n- Actions: Added deprecation warnings to the ZMI actions tab and\n  most listActions methods where old-style actions are found\n  asking developers to move to new-style actions instead. These\n  warnings allow us to remove old-style actions code by version 2.4.\n\n- Discussion tool: Removed the listActions method that would return\n  a hardcoded Reply action. This action has been handled by the\n  Actions tool itself for a while now, and the Discussions tool was\n  not set as an action provider anymore.\n\n- actions tool export/import: The actions tool export/import mechanism\n  is no longer attempting to handle actions stored on tools other than\n  itself. Other tools are themselves responsible for their actions.\n  The importer has been fixed to add all action providers to the actions\n  tool, not just a select list of providers we know about.\n  (https://bugs.launchpad.net/zope-cmf/+bug/177675)\n\n- tool interfaces: Replace non-existing IMember interface with the\n  correct IMemberData.\n\n- CatalogTool: If proxy roles are set on a script that uses the catalog\n  and those proxy roles have been unset using the ZMI, which results\n  in an empty tuple as proxy roles, then the catalog would not correctly\n  determine what the current user is allowed to see.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161729)\n\n- Properties export/import: Get the string encoding for property\n  imports from the import context and fall back to UTF-8, which\n  mirrors the behavior for exports. This fixes property export/import\n  round tripping.\n  (https://bugs.launchpad.net/zope-cmf/+bug/248853)\n\n- traversal: Added ++add++ namespace for add views.\n\n- Skinstool import: Fix imports that manipulate existing skins.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161732)\n\n- ActionInformation: extend the ActionInformation and ActionInfo classes\n  to support a icon URL just like the newer Action class already does\n\n- WorkflowTool: Passing the \"magic\" chain name \"(Default)\" to the\n  setChainForPortalTypes method did not set the chain to the default\n  chain value as expected.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161702)\n\n- ZMI: Prevent users from creating content through the ZMI by hiding the\n  entry for \"CMFCore Content\".\n\n- utils: Add a new optional argument to ContentInit that allows hiding\n  a content item's ZMI add list entry. The default is to leave the item\n  visible, which reflects the previous behavior.\n\n- FSMetadata: Remove handling of .security and .properties metadata\n  files which was supposed to have been removed in CMF 2.0 already.\n\n- SkinsTool: Added the ability to do a diff comparison between items\n  found using the portal_skins \"Find\" ZMI tab.\n  (https://bugs.launchpad.net/zope-cmf/+bug/238489)\n\n- TypeInformation and TypesTool: Added support for add view actions.\n  Type infos now have a new 'add_view_expr' property and implement IAction.\n  'listActions' of the types tool includes type infos as 'add' actions.\n\n- interfaces: Fixed some docstrings.\n  There is no IActionInformation. ActionInformation is an old action class\n  that implements IAction, non-persistent IActionInfo objects adapt action\n  objects to a given context.\n\n- FSSTXMethod: Fixed Zope 2.12 compatibility.\n  zope.structuredtext is now used instead of StructuredText.\n\n- removed the five.localsitemanager svn:external and its import hack\n  in favor of stating the dependency for separate installation in\n  DEPENDENCIES.txt and automatic installation in setup.py.\n\n- TypesTool: Refactored content creation.\n  Moved addCreator call to IObjectCreatedEvent handler and moved\n  notifyWorkflowCreated and indexObject calls to IObjectAddedEvent handler.\n  Please make sure all oldstyle content factory methods use _setObject with\n  suppress_events=True. CMF factory methods don't finish object creation,\n  so they should not send the IObjectAddedEvent.\n\n- interfaces: Added new interfaces for CMFCatalogAware methods.\n  In the long run ICatalogAware, IWorkflowAware and IOpaqueItemManager will\n  become deprecated. Don't expect that CMF content always implements them.\n\n- setup handlers: All import and export steps are now registered globally.\n\n- MembershipTool: Removed ancient LoginManager compatibility code and\n  deprecated the no longer needed __getPUS method.\n\n- interfaces: Removed deprecated oldstyle interfaces.\n\n\n2.1.2 (2008-09-13)\n------------------\n\n- fiveactionstool: fix typo in a method name that isn't even used in the CMF\n  or Plone.\n  (https://bugs.launchpad.net/zope-cmf/+bug/257259)\n\n2.1.2-beta (2008-08-26)\n-----------------------\n\n- completed devolution from monolithic CMF package into its component\n  products that are distributed as eggs from PyPI.\n\n\n2.1.1 (2008-01-06)\n------------------\n\n- exportimport.content: Add simple guard against import failures when\n  the \".objects\" file contains empty lines.\n  (https://bugs.launchpad.net/zope-cmf/+bug/176328)\n\n\n2.1.1-beta (2007-12-29)\n-----------------------\n\n- Testing: Derive test layers from ZopeLite layer if available.\n\n- Updated to the 0.3 release of five.localsitemanager.\n\n- Events: Fixed some handleContentishEvent issues.\n  Moved _clearLocalRolesAfterClone code to separate handler that is\n  triggered before indexing and also for folders. Made sure notifyModified\n  is not called if objects are just moved.\n\n- PortalObject: Added setSite to getSiteManager for old instances. This\n  fixes migrations from Plone 2.1 to 3.0.\n\n- FSImage: Supply class-level defaults for 'alt', 'height', and 'width',\n  to avoid acquiring objects with the same names.\n  (http://www.zope.org/Collectors/CMF/507)\n\n- Testing: Derive test layers from ZopeLite layer if available.\n\n- PortalObject: Fixed a bug in the site manager creation code, which would\n  assign the __parent__ pointer to the Aq-wrapper and not the actual\n  object.\n\n\n2.1.0 (2007-08-08)\n------------------\n\n- Fixed all componentregistry.xml files to use plain object paths and strip\n  and slashes. GenericSetup does only support registering objects which are\n  in the site root.\n\n- PortalFolder: Enabled 'Components' ZMI tab.\n  This GenericSetup tab allows to inspect and edit component registrations.\n\n- First egg release.  For changes up through this release, please see\n  the overall \"CMF changelog\",\n  http://svn.zope.org/CMF/tags/2.1.0/CHANGES.txt?rev=78713&view=markup\n\n\n2.1.0-beta2 (2007-07-12)\n------------------------\n\n- moved the Zope dependency to version 2.10.4\n\n- Remove antique usage of marker attributes in favor of interfaces,\n  leaving BBB behind for places potentially affecting third-party code.\n  (http://www.zope.org/Collectors/CMF/440)\n\n- Add POST-only protections to security critical methods.\n  http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0240)\n\n- exportimport.skins: Added the ability to remove whole skin selections using a\n  GS profile.\n  (http://www.zope.org/Collectors/CMF/479)\n\n- UndoTool: Fixed 'listUndoableTransactionsFor'.\n  The required 'object' argument is now respected. This doesn't change the\n  behavior as long as 'object' is the site root object.\n\n- TypesTool: Corrected method signature of all_meta_types to have\n  an interface keyword argument, as per the underlying OFS.ObjectManager\n  interface declaration.\n\n- SkinnableObjectManager: Changed the way skins are set up.\n  Acquisition wrapping no longer triggers 'setupCurrentSkin'. This is now\n  done on publishing traversal after the BeforeTraverseEvent triggers\n  'setSite'. This fix replaces a temporary hack introduced in 2.1.0-beta,\n  making sure ISkinsTool is looked up after setting the site.\n\n- CMFBTreeFolder: CMFBTreeFolders could not be used as the\n  toplevel /Members container.\n  (http://www.zope.org/Collectors/CMF/441)\n\n- TypesTool: Pass 'object' through to TypeInformation objects'\n  'listActions'.\n  (http://www.zope.org/Collectors/CMF/482)\n\n- Removed extraneous \"Cache\" tab from FS-based skin objects.\n  (http://www.zope.org/Collectors/CMF/343)\n\n- WorkflowTool: Using the '(Default)' keyword for a type's\n  workflow chain will now reset any custom workflow chains for the type.\n  (http://www.zope.org/Collectors/CMF/475)\n\n- SkinsTool: Use the property API to get the member specific skin,\n  because direct attribute access won't work with PAS based membership.\n  (http://dev.plone.org/plone/ticket/5904)\n\n- Allow customization from DirectoryViews to be redirected into\n  alternate folders, and use manually-built clones.\n  (http://www.zope.org/Collectors/CMF/382)\n\n\n2.1.0-beta (2007-03-09)\n-----------------------\n\n- moved the Zope dependency to verson 2.10.2\n\n- Tool lookup and registration is now done \"the Zope 3 way\" as utilities, see\n  http://svn.zope.org/CMF/branches/2.1/docs/ToolsAreUtilities.stx?view=auto\n\n- DirectoryView: Added 'registerDirectory' ZCML directive.\n  Using the old registerDirectory method in __init__.py is now deprecated.\n  See zcml.IRegisterDirectoryDirective for details.\n\n- DirectoryView: Added support for non-product packages.\n  This introduces new registry keys. Old registry keys stored in\n  persistent DirectoryView objects are updated on the fly.\n  (http://www.zope.org/Collectors/CMF/467)\n\n- setup handlers: Improved properties handler.\n  It now works with properties using a default_charset other than UTF-8.\n\n- MembershipTool: Fixed inconsistent behavior where member lookup\n  would take all user folders up to the Zope root into account whereas\n  member area creation would not.\n\n- MembershipTool: when using an object without a __nonzero__ but with a\n  __len__ (ala CMFBTreeFolder) as a member folder, the createMemberArea\n  method would believe there was no members folder if the folder was\n  empty, and so would fail (change \"not membersfolder\" to\n  \"membersfolder is not None\") .\n\n- DynamicType: Fixed behaviour regarding default view.\n  DynamicType was making it impossible to use a Zope3-style\n  default view for CMF content types.\n  (http://www.zope.org/Collectors/CMF/459)\n\n- utils: Marked 'minimalpath' and 'expandpath' as deprecated.\n\n- Merged patches from Martin Aspeli to enable generating events before\n  and after DCWorkflow transitions, and in the 'notify' methods of the\n  workflow tool (http://www.zope.org/Collectors/CMF/461).\n\n\n2.1.0-alpha2 (2006-11-23)\n-------------------------\n\n- moved the Zope dependency to version 2.10.1\n\n- Fixed test breakage induced by use of Z3 pagetemplates in Zope 2.10+.\n\n- browser views: Added some zope.formlib based forms.\n\n- testing: Added test layers for setting up ZCML.\n\n- WorkflowTool: Added the IConfigurableWorkflowTool interface.\n  This change includes the new 'getDefaultChain' and 'listChainOverrides'\n  methods and an improved 'setChainForPortalTypes' method. The import\n  handler now supports the 'remove' attribute for removing overrides.\n  (http://www.zope.org/Collectors/CMF/457)\n\n- CachingPolicyManager: Implemented the old OFS.Cache.CacheManager\n  API. Now objects other than CMF content or CMF templates can have their\n  caching headers set by the caching policy manager with the same\n  fine-grained control.\n  (http://www.zope.org/Collectors/CMF/408)\n\n- Added CMFCore.FSRestMethod:  ReST equivalent of FSSTXMethod.\n\n- FSSTXMethod:  Modernized, added tests, made customization\n  possible (now renders via ZPT by default, using 'main_template').\n\n- CachingPolicyManager: Prevent firing of caching policies\n  for templates (DTML or ZPT) that are rendered in-line (without a\n  separate request) while rendering the requested content item's view.\n  (http://www.zope.org/Collectors/CMF/456)\n\n\n2.1.0-alpha (2006-10-09)\n------------------------\n\n- skins: Changed encoding of translated portal_status_messages.\n  Now getBrowserCharset is used to play nice with Five forms. Customized\n  setRedirect and getMainGlobals scripts have to be updated.\n\n- Profiles: All profiles are now registered by ZCML.\n\n- ZClasses: Removed unmaintained support for ZClasses.\n  Marked the 'initializeBases*' methods as deprecated.\n\n- Content: Added IFactory utilities for all content classes.\n  They are now used by default instead of the old constructor methods.\n\n- Content: All content classes are now registered by ZCML.\n  ContentInit is still used to register oldstyle constructors.\n\n- setup handlers: Removed support for CMF 1.5 CMFSetup profiles.\n\n- FactoryTypeInformation: Added support for Zope3 style factories.\n  If the 'product' property of a type info instance is empty the 'factory'\n  property is interpreted as an IFactory name.\n\n- ActionInformation: don't use a fixed set of properties for\n  ActionInformation. (http://www.zope.org/Collectors/CMF/232/)\n\n- CatalogTool: Use current executable's proxy roles, if any,\n  in place of user's roles when computing 'allowedRolesAndUsers' for\n  a query. (http://www.zope.org/Collectors/CMF/380)\n\n- FSFile: Added registration for 'txt' extension.\n\n- CMFCatalogAware: Added 'handleObjectEvent' subscriber.\n  This replaces the deprecated 'manage_afterAdd', 'manage_afterClone' and\n  'manage_beforeDelete' hooks.\n\n\nEarlier releases\n----------------\n\nFor a complete list of changes before version 2.1.0-alpha, see the HISTORY.txt\nfile on the CMF-2.1 branch:\nhttps://web.archive.org/web/20130123004606/http://svn.zope.org/CMF/branches/2.1/HISTORY.txt?view=auto\n", "##############################################################################\n#\n# Copyright (c) 2001 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" PortalFolder: CMF-enabled Folder objects.\n\"\"\"\n\nimport marshal\nimport re\n\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom AccessControl.SecurityManagement import getSecurityManager\nfrom Acquisition import aq_base\nfrom Acquisition import aq_inner\nfrom Acquisition import aq_parent\nfrom OFS.Folder import Folder\nfrom OFS.OrderSupport import OrderSupport\nfrom zope.component import getUtility\nfrom zope.component import queryUtility\nfrom zope.component.factory import Factory\nfrom zope.interface import implementer\n\nfrom .CMFCatalogAware import OpaqueItemManager\nfrom .DynamicType import DynamicType\nfrom .exceptions import AccessControl_Unauthorized\nfrom .exceptions import BadRequest\nfrom .exceptions import zExceptions_Unauthorized\nfrom .interfaces import IContentTypeRegistry\nfrom .interfaces import IFolderish\nfrom .interfaces import IMutableMinimalDublinCore\nfrom .interfaces import ISiteRoot\nfrom .interfaces import ITypesTool\nfrom .permissions import AddPortalContent\nfrom .permissions import AddPortalFolders\nfrom .permissions import DeleteObjects\nfrom .permissions import ListFolderContents\nfrom .permissions import ManagePortal\nfrom .permissions import ManageProperties\nfrom .permissions import View\nfrom .utils import _checkPermission\nfrom .utils import base64_decode\nfrom .utils import base64_encode\n\n\n@implementer(IFolderish, IMutableMinimalDublinCore)\nclass PortalFolderBase(DynamicType, OpaqueItemManager, Folder):\n\n    \"\"\"Base class for portal folder.\n    \"\"\"\n\n    security = ClassSecurityInfo()\n\n    description = ''\n\n    manage_options = (Folder.manage_options[:1]\n                      + ({'label': 'Components',\n                          'action': 'manage_components'},)\n                      + ({'label': 'Components Folder',\n                          'action': '++etc++site/manage_main'},)\n                      + Folder.manage_options[1:])\n\n    def __init__(self, id, title='', description=''):\n        self.id = id\n        self.title = title\n        self.description = description\n\n    #\n    #   'IMutableMinimalDublinCore' interface methods\n    #\n    @security.protected(View)\n    def Title(self):\n        \"\"\" Dublin Core Title element - resource name.\n        \"\"\"\n        return self.title\n\n    @security.protected(View)\n    def Description(self):\n        \"\"\" Dublin Core Description element - resource summary.\n        \"\"\"\n        return self.description\n\n    @security.protected(View)\n    def Type(self):\n        \"\"\" Dublin Core Type element - resource type.\n        \"\"\"\n        ti = self.getTypeInfo()\n        return ti is not None and ti.Title() or 'Unknown'\n\n    @security.protected(ManageProperties)\n    def setTitle(self, title):\n        \"\"\" Set Dublin Core Title element - resource name.\n        \"\"\"\n        self.title = title\n\n    @security.protected(ManageProperties)\n    def setDescription(self, description):\n        \"\"\" Set Dublin Core Description element - resource summary.\n        \"\"\"\n        self.description = description\n\n    #\n    #   other methods\n    #\n    @security.protected(ManageProperties)\n    def edit(self, title='', description=''):\n        \"\"\"\n        Edit the folder title (and possibly other attributes later)\n        \"\"\"\n        self.setTitle(title)\n        self.setDescription(description)\n        # BBB: for ICatalogAware subclasses\n        if getattr(self, 'reindexObject', None) is not None:\n            self.reindexObject()\n\n    @security.public\n    def allowedContentTypes(self):\n        \"\"\"\n            List type info objects for types which can be added in\n            this folder.\n        \"\"\"\n        ttool = getUtility(ITypesTool)\n        myType = ttool.getTypeInfo(self)\n        result = ttool.listTypeInfo()\n\n        if myType is not None:\n            return [t for t in result if myType.allowType(t.getId()) and\n                    t.isConstructionAllowed(self)]\n\n        return [t for t in result if t.isConstructionAllowed(self)]\n\n    def _filteredItems(self, ids, filt):\n        \"\"\"\n            Apply filter, a mapping, to child objects indicated by 'ids',\n            returning a sequence of (id, obj) tuples.\n        \"\"\"\n        # Restrict allowed content types\n        if filt is None:\n            filt = {}\n        else:\n            # We'll modify it, work on a copy.\n            filt = filt.copy()\n        pt = filt.get('portal_type', [])\n        if isinstance(pt, str):\n            pt = [pt]\n        ttool = getUtility(ITypesTool)\n        allowed_types = ttool.listContentTypes()\n        if not pt:\n            pt = allowed_types\n        else:\n            pt = [t for t in pt if t in allowed_types]\n        if not pt:\n            # After filtering, no types remain, so nothing should be\n            # returned.\n            return []\n        filt['portal_type'] = pt\n\n        query = ContentFilter(**filt)\n        result = []\n        append = result.append\n        get = self._getOb\n        for id in ids:\n            obj = get(id)\n            if query(obj):\n                append((id, obj))\n        return result\n\n    #\n    #   'IFolderish' interface methods\n    #\n    @security.public\n    def contentItems(self, filter=None):\n        # List contentish and folderish sub-objects and their IDs.\n        # (method is without docstring to disable publishing)\n        #\n        ids = self.objectIds()\n        return self._filteredItems(ids, filter)\n\n    @security.public\n    def contentIds(self, filter=None):\n        # List IDs of contentish and folderish sub-objects.\n        # (method is without docstring to disable publishing)\n        #\n        return [item[0] for item in self.contentItems(filter)]\n\n    @security.public\n    def contentValues(self, filter=None):\n        # List contentish and folderish sub-objects.\n        # (method is without docstring to disable publishing)\n        #\n        return [item[1] for item in self.contentItems(filter)]\n\n    @security.protected(ListFolderContents)\n    def listFolderContents(self, contentFilter=None):\n        \"\"\" List viewable contentish and folderish sub-objects.\n        \"\"\"\n        fc_list = []\n        for id, obj in self.contentItems(contentFilter):\n            # validate() can either raise Unauthorized or return 0 to\n            # mean unauthorized.\n            try:\n                if getSecurityManager().validate(self, self, id, obj):\n                    fc_list.append(obj)\n            except zExceptions_Unauthorized:  # Catch *all* Unauths!\n                pass\n        return fc_list\n\n    #\n    #   webdav Resource method\n    #\n\n    # protected by 'WebDAV access'\n    def listDAVObjects(self):\n        # List sub-objects for PROPFIND requests.\n        # (method is without docstring to disable publishing)\n        #\n        if _checkPermission(ManagePortal, self):\n            return self.objectValues()\n        else:\n            return self.listFolderContents()\n\n    #\n    #   other methods\n    #\n    @security.public\n    def encodeFolderFilter(self, REQUEST):\n        \"\"\"\n            Parse cookie string for using variables in dtml.\n        \"\"\"\n        filter = {}\n        for key, value in REQUEST.items():\n            if key[:10] == 'filter_by_':\n                filter[key[10:]] = value\n        encoded = base64_encode(marshal.dumps(filter))\n        encoded = ''.join(encoded.split('\\n'))\n        return encoded\n\n    @security.public\n    def decodeFolderFilter(self, encoded):\n        \"\"\"\n            Parse cookie string for using variables in dtml.\n        \"\"\"\n        filter = {}\n        if encoded:\n            filter.update(marshal.loads(base64_decode(encoded)))\n        return filter\n\n    def content_type(self):\n        \"\"\"\n            WebDAV needs this to do the Right Thing (TM).\n        \"\"\"\n        return None\n\n    def PUT_factory(self, name, typ, body):\n        \"\"\" Factory for PUT requests to objects which do not yet exist.\n\n        Used by NullResource.PUT.\n\n        Returns -- Bare and empty object of the appropriate type (or None, if\n        we don't know what to do)\n        \"\"\"\n        ctr = queryUtility(IContentTypeRegistry)\n        if ctr is None:\n            return None\n\n        typeObjectName = ctr.findTypeName(name, typ, body)\n        if typeObjectName is None:\n            return None\n\n        self.invokeFactory(typeObjectName, name)\n\n        # invokeFactory does too much, so the object has to be removed again\n        obj = aq_base(self._getOb(name))\n        self._delObject(name)\n        return obj\n\n    @security.protected(AddPortalContent)\n    def invokeFactory(self, type_name, id, RESPONSE=None, *args, **kw):\n        \"\"\" Invokes the portal_types tool.\n        \"\"\"\n        ttool = getUtility(ITypesTool)\n        myType = ttool.getTypeInfo(self)\n\n        if myType is not None:\n            if not myType.allowType(type_name):\n                raise ValueError('Disallowed subobject type: %s' % type_name)\n\n        return ttool.constructContent(type_name, self, id, RESPONSE,\n                                      *args, **kw)\n\n    @security.protected(AddPortalContent)\n    def checkIdAvailable(self, id):\n        try:\n            self._checkId(id)\n        except BadRequest:\n            return False\n        else:\n            return True\n\n    def MKCOL_handler(self, id, REQUEST=None, RESPONSE=None):\n        \"\"\"\n            Handle WebDAV MKCOL.\n        \"\"\"\n        self.manage_addFolder(id=id, title='')\n\n    def _checkId(self, id, allow_dup=0):\n        PortalFolderBase.inheritedAttribute('_checkId')(self, id, allow_dup)\n\n        if allow_dup:\n            return\n\n        # FIXME: needed to allow index_html for join code\n        if id == 'index_html':\n            return\n\n        # Another exception: Must allow \"syndication_information\" to enable\n        # Syndication...\n        if id == 'syndication_information':\n            return\n\n        # IDs starting with '@@' are reserved for views.\n        if id[:2] == '@@':\n            raise BadRequest('The id \"%s\" is invalid because it begins with '\n                             '\"@@\".' % id)\n\n        # This code prevents people other than the portal manager from\n        # overriding skinned names and tools.\n        if not getSecurityManager().checkPermission(ManagePortal, self):\n            ob = aq_inner(self)\n            while ob is not None:\n                if ISiteRoot.providedBy(ob):\n                    break\n                ob = aq_parent(ob)\n\n            if ob is not None:\n                # If the portal root has a non-contentish object by this name,\n                # don't allow an override.\n                if hasattr(ob, id) and \\\n                   id not in ob.contentIds() and \\\n                   not id.startswith('.'):\n                    raise BadRequest('The id \"%s\" is reserved.' % id)\n            # Don't allow ids used by Method Aliases.\n            ti = self.getTypeInfo()\n            if ti and ti.queryMethodID(id, context=self):\n                raise BadRequest('The id \"%s\" is reserved.' % id)\n        # Otherwise we're ok.\n\n    def _verifyObjectPaste(self, object, validate_src=1):\n        # This assists the version in OFS.CopySupport.\n        # It enables the clipboard to function correctly\n        # with objects created by a multi-factory.\n        mt = getattr(object, '__factory_meta_type__', None)\n        meta_types = getattr(self, 'all_meta_types', None)\n\n        if mt is not None and meta_types is not None:\n            mt_permission = None\n\n            if callable(meta_types):\n                meta_types = meta_types()\n\n            for d in meta_types:\n                if d['name'] == mt:\n                    mt_permission = d.get('permission')\n                    break\n\n            if mt_permission is not None:\n                sm = getSecurityManager()\n\n                if sm.checkPermission(mt_permission, self):\n                    if validate_src:\n                        # Ensure the user is allowed to access the object on\n                        # the clipboard.\n                        parent = aq_parent(aq_inner(object))\n\n                        if not sm.validate(None, parent, None, object):\n                            raise AccessControl_Unauthorized(object.getId())\n\n                        if validate_src == 2:  # moving\n                            if not sm.checkPermission(DeleteObjects, parent):\n                                raise AccessControl_Unauthorized('Delete not '\n                                                                 'allowed.')\n                else:\n                    raise AccessControl_Unauthorized(\n                            'You do not possess the '\n                            '%r permission in the context of the container '\n                            'into which you are pasting, thus you are not '\n                            'able to perform this operation.' % mt_permission)\n            else:\n                raise AccessControl_Unauthorized(\n                        'The object %r does not '\n                        'support this operation.' % object.getId())\n        else:\n            # Call OFS' _verifyObjectPaste if necessary\n            PortalFolderBase.inheritedAttribute(\n                '_verifyObjectPaste')(self, object, validate_src)\n\n        # Finally, check allowed content types\n        if hasattr(aq_base(object), 'getPortalTypeName'):\n\n            type_name = object.getPortalTypeName()\n\n            if type_name is not None:\n\n                ttool = getUtility(ITypesTool)\n                myType = ttool.getTypeInfo(self)\n\n                if myType is not None and not myType.allowType(type_name):\n                    raise ValueError('Disallowed subobject type: %s' %\n                                     type_name)\n\n                # Check for workflow guards\n                objType = ttool.getTypeInfo(type_name)\n                if objType is not None and \\\n                   not objType._checkWorkflowAllowed(self):\n                    raise ValueError('Pasting not allowed in this workflow')\n\n    security.setPermissionDefault(AddPortalContent, ('Owner', 'Manager'))\n\n    @security.protected(AddPortalFolders)\n    def manage_addFolder(self, id, title='', REQUEST=None):\n        \"\"\" Add a new folder-like object with id *id*.\n\n        IF present, use the parent object's 'mkdir' alias; otherwise, just add\n        a PortalFolder.\n        \"\"\"\n        ti = self.getTypeInfo()\n        method_id = ti and ti.queryMethodID('mkdir', context=self)\n        if method_id:\n            # call it\n            getattr(self, method_id)(id=id)\n        else:\n            self.invokeFactory(type_name='Folder', id=id)\n\n        ob = self._getOb(id)\n        ob.setTitle(title)\n        try:\n            ob.reindexObject()\n        except AttributeError:\n            pass\n\n        if REQUEST is not None:\n            return self.manage_main(self, REQUEST, update_menu=1)\n\n\nInitializeClass(PortalFolderBase)\n\n\nclass PortalFolder(OrderSupport, PortalFolderBase):\n\n    \"\"\"Implements portal content management, but not UI details.\n    \"\"\"\n\n    portal_type = 'Folder'\n\n    security = ClassSecurityInfo()\n\n    manage_options = (OrderSupport.manage_options +\n                      PortalFolderBase.manage_options[1:])\n\n    @security.protected(AddPortalFolders)\n    def manage_addPortalFolder(self, id, title='', REQUEST=None):\n        \"\"\"Add a new PortalFolder object with id *id*.\n        \"\"\"\n        ob = PortalFolder(id, title)\n        self._setObject(id, ob, suppress_events=True)\n        if REQUEST is not None:\n            return self.folder_contents(  # XXX: ick!\n                self, REQUEST, portal_status_message='Folder added')\n\n\nInitializeClass(PortalFolder)\n\nPortalFolderFactory = Factory(PortalFolder)\n\nmanage_addPortalFolder = PortalFolder.manage_addPortalFolder\n\n\nclass ContentFilter:\n\n    \"\"\"Represent a predicate against a content object's metadata.\n    \"\"\"\n\n    MARKER = []\n    filterSubject = []\n\n    def __init__(self, Title=MARKER, Creator=MARKER, Subject=MARKER,\n                 Description=MARKER, created=MARKER, created_usage='range:min',\n                 modified=MARKER, modified_usage='range:min', Type=MARKER,\n                 portal_type=MARKER, **Ignored):\n\n        self.predicates = []\n        self.description = []\n\n        if Title is not self.MARKER:\n            self.predicates.append(lambda x, pat=re.compile(Title):\n                                   pat.search(x.Title()))\n            self.description.append('Title: %s' % Title)\n\n        if Creator and Creator is not self.MARKER:\n            self.predicates.append(lambda x, creator=Creator:\n                                   creator in x.listCreators())\n            self.description.append('Creator: %s' % Creator)\n\n        if Subject and Subject is not self.MARKER:\n            self.filterSubject = Subject\n            self.predicates.append(self.hasSubject)\n            self.description.append('Subject: %s' % ', '.join(Subject))\n\n        if Description is not self.MARKER:\n            self.predicates.append(lambda x, pat=re.compile(Description):\n                                   pat.search(x.Description()))\n            self.description.append('Description: %s' % Description)\n\n        if created is not self.MARKER:\n            if created_usage == 'range:min':\n                self.predicates.append(lambda x, cd=created:\n                                       cd <= x.created())\n                self.description.append('Created since: %s' % created)\n            if created_usage == 'range:max':\n                self.predicates.append(lambda x, cd=created:\n                                       cd >= x.created())\n                self.description.append('Created before: %s' % created)\n\n        if modified is not self.MARKER:\n            if modified_usage == 'range:min':\n                self.predicates.append(lambda x, md=modified:\n                                       md <= x.modified())\n                self.description.append('Modified since: %s' % modified)\n            if modified_usage == 'range:max':\n                self.predicates.append(lambda x, md=modified:\n                                       md >= x.modified())\n                self.description.append('Modified before: %s' % modified)\n\n        if Type:\n            if isinstance(Type, str):\n                Type = [Type]\n            self.predicates.append(lambda x, Type=Type: x.Type() in Type)\n            self.description.append('Type: %s' % ', '.join(Type))\n\n        if portal_type and portal_type is not self.MARKER:\n            if isinstance(portal_type, str):\n                portal_type = [portal_type]\n            self.predicates.append(lambda x, pt=portal_type:\n                                   hasattr(aq_base(x), 'getPortalTypeName')\n                                   and x.getPortalTypeName() in pt)\n            self.description.append('Portal Type: %s' % ', '.join(portal_type))\n\n    def hasSubject(self, obj):\n        \"\"\"\n        Converts Subject string into a List for content filter view.\n        \"\"\"\n        for sub in obj.Subject():\n            if sub in self.filterSubject:\n                return 1\n        return 0\n\n    def __call__(self, content):\n\n        for predicate in self.predicates:\n\n            try:\n                if not predicate(content):\n                    return 0\n            except (AttributeError, KeyError, IndexError, ValueError):\n                # predicates are *not* allowed to throw exceptions\n                return 0\n\n        return 1\n\n    def __str__(self):\n        \"\"\"\n            Return a stringified description of the filter.\n        \"\"\"\n        return '; '.join(self.description)\n", "##############################################################################\n#\n# Copyright (c) 2001 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Unit tests for PortalFolder module.\n\"\"\"\n\nimport unittest\n\nimport transaction\nfrom AccessControl import SecurityManager\nfrom AccessControl import Unauthorized\nfrom AccessControl.SecurityManagement import newSecurityManager\nfrom Acquisition import Implicit\nfrom Acquisition import aq_base\nfrom DateTime import DateTime\nfrom OFS.Image import manage_addFile\nfrom zope.component import getSiteManager\nfrom zope.component.interfaces import IFactory\nfrom zope.interface import implementer\nfrom zope.interface.verify import verifyClass\n\nfrom ..exceptions import BadRequest\nfrom ..interfaces import ICatalogTool\nfrom ..interfaces import ITypesTool\nfrom ..interfaces import IWorkflowTool\nfrom ..testing import ConformsToFolder\nfrom ..testing import TraversingEventZCMLLayer\nfrom ..TypesTool import FactoryTypeInformation as FTI\nfrom ..TypesTool import TypesTool\nfrom ..WorkflowTool import WorkflowTool\nfrom .base.dummy import DummyContent\nfrom .base.dummy import DummyFactoryDispatcher\nfrom .base.dummy import DummySite\nfrom .base.dummy import DummyUserFolder\nfrom .base.testcase import SecurityTest\nfrom .base.tidata import FTIDATA_CMF\nfrom .base.tidata import FTIDATA_DUMMY\n\n\ndef extra_meta_types():\n    return [{'name': 'Dummy', 'action': 'manage_addFolder',\n             'permission': 'View'}]\n\n\n@implementer(ICatalogTool)\nclass DummyCatalogTool:\n\n    def __init__(self):\n        self.paths = []\n        self.ids = []\n\n    def indexObject(self, object):\n        self.paths.append('/'.join(object.getPhysicalPath()))\n        self.ids.append(object.getId())\n\n    def unindexObject(self, object):\n        self.paths.remove('/'.join(object.getPhysicalPath()))\n        self.ids.append(object.getId())\n\n    def reindexObject(self, object):\n        pass\n\n    def __len__(self):\n        return len(self.paths)\n\n\ndef has_path(catalog, path):\n    if isinstance(path, tuple):\n        path = '/'.join(path)\n    return path in catalog.paths\n\n\ndef has_id(catalog, id):\n    return id in catalog.ids\n\n\nclass PortalFolderFactoryTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n    _PORTAL_TYPE = 'Test Folder'\n\n    def _getTargetObject(self):\n        from ..PortalFolder import PortalFolderFactory\n\n        return PortalFolderFactory\n\n    def setUp(self):\n        from ..PortalFolder import PortalFolder\n\n        SecurityTest.setUp(self)\n        self.site = DummySite('site').__of__(self.app)\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n\n        self.ttool = ttool = TypesTool()\n        ttool._setObject(self._PORTAL_TYPE,\n                         FTI(id=self._PORTAL_TYPE,\n                             title='Folder or Directory',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder',\n                             filter_content_types=0))\n        ttool._setObject('Dummy Content', FTI(**FTIDATA_DUMMY[0].copy()))\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n        sm.registerUtility(self._getTargetObject(), IFactory, 'cmf.folder')\n\n        self.f = self.site._setObject('container', PortalFolder('container'))\n        self.f._setPortalTypeName(self._PORTAL_TYPE)\n\n    def test_invokeFactory(self):\n        f = self.f\n        self.assertFalse('foo' in f.objectIds())\n\n        f.manage_addProduct = {'FooProduct': DummyFactoryDispatcher(f)}\n        f.invokeFactory(type_name='Dummy Content', id='foo')\n\n        self.assertTrue('foo' in f.objectIds())\n        foo = f.foo\n        self.assertEqual(foo.getId(), 'foo')\n        self.assertEqual(foo.getPortalTypeName(), 'Dummy Content')\n        self.assertEqual(foo.Type(), 'Dummy Content Title')\n\n    def test_invokeFactory_disallowed_type(self):\n        f = self.f\n        ftype = getattr(self.ttool, self._PORTAL_TYPE)\n        ftype.filter_content_types = 1\n        self.assertRaises(ValueError,\n                          f.invokeFactory, self._PORTAL_TYPE, 'sub')\n\n        ftype.allowed_content_types = (self._PORTAL_TYPE,)\n        f.invokeFactory(self._PORTAL_TYPE, id='sub')\n        self.assertTrue('sub' in f.objectIds())\n        self.assertRaises(ValueError, f.invokeFactory, 'Dummy Content', 'foo')\n\n\nclass PortalFolderTests(ConformsToFolder, unittest.TestCase):\n\n    def _getTargetClass(self):\n        from ..PortalFolder import PortalFolder\n\n        return PortalFolder\n\n    def test_interfaces(self):\n        from OFS.interfaces import IOrderedContainer\n\n        verifyClass(IOrderedContainer, self._getTargetClass())\n\n\nclass PortalFolderSecurityTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def _getTargetClass(self):\n        from ..PortalFolder import PortalFolder\n\n        return PortalFolder\n\n    def _makeOne(self, id, *args, **kw):\n        return self.site._setObject(id,\n                                    self._getTargetClass()(id, *args, **kw))\n\n    def setUp(self):\n        SecurityTest.setUp(self)\n        self.site = DummySite('site').__of__(self.app)\n\n    def test_contents_methods(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n\n        ttool = TypesTool()\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        f = self._makeOne('foo')\n        self.assertEqual(f.objectValues(), [])\n        self.assertEqual(f.contentIds(), [])\n        self.assertEqual(f.contentItems(), [])\n        self.assertEqual(f.contentValues(), [])\n        self.assertEqual(f.listFolderContents(), [])\n        self.assertEqual(f.listDAVObjects(), [])\n\n        f._setObject('sub1', DummyContent('sub1'))\n        self.assertEqual(f.objectValues(), [f.sub1])\n        self.assertEqual(f.contentIds(), [])\n        self.assertEqual(f.contentItems(), [])\n        self.assertEqual(f.contentValues(), [])\n        self.assertEqual(f.listFolderContents(), [])\n        self.assertEqual(f.listDAVObjects(), [f.sub1])\n\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        self.assertEqual(f.objectValues(), [f.sub1])\n        self.assertEqual(f.contentIds(), ['sub1'])\n        self.assertEqual(f.contentItems(), [('sub1', f.sub1)])\n        self.assertEqual(f.contentValues(), [f.sub1])\n        self.assertEqual(f.listFolderContents(), [f.sub1])\n        self.assertEqual(f.listDAVObjects(), [f.sub1])\n\n        f._setObject('hidden_sub2', DummyContent('hidden_sub2'))\n        self.assertEqual(f.objectValues(), [f.sub1, f.hidden_sub2])\n        self.assertEqual(f.contentIds(), ['sub1', 'hidden_sub2'])\n        self.assertEqual(f.contentItems(), [('sub1', f.sub1),\n                                            ('hidden_sub2', f.hidden_sub2)])\n        self.assertEqual(f.contentValues(), [f.sub1, f.hidden_sub2])\n        self.assertEqual(f.listFolderContents(), [f.sub1])\n        self.assertEqual(f.listDAVObjects(), [f.sub1, f.hidden_sub2])\n\n    def test_deletePropagation(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        foo = DummyContent('foo')\n        foo.reset()\n        self.assertFalse(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n        test._setObject('foo', foo)\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n        foo.reset()\n        test._delObject('foo')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n\n        foo.reset()\n        test._setObject('foo', foo)\n        test._delOb('foo')    # doesn't propagate\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n    def test_manageDelObjects(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        foo = DummyContent('foo')\n\n        test._setObject('foo', foo)\n        foo.reset()\n        test.manage_delObjects(ids=['foo'])\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n\n    def test_catalogUnindexAndIndex(self):\n        #\n        # Test is a new object does get cataloged upon _setObject\n        # and uncataloged upon manage_deleteObjects\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        ctool = DummyCatalogTool()\n        self.assertEqual(len(ctool), 0)\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(TypesTool(), ITypesTool)\n\n        test._setObject('foo', DummyContent('foo', catalog=1))\n        foo = test.foo\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n        self.assertEqual(len(ctool), 1)\n\n        foo.reset()\n        test._delObject('foo')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n        self.assertEqual(len(ctool), 0)\n\n    def test_portalfolder_cataloging(self):\n        #\n        # Test to ensure a portal folder itself is *not* cataloged upon\n        # instantiation (Tracker issue 309)\n        #\n        ctool = DummyCatalogTool()\n        wtool = WorkflowTool()\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(wtool, IWorkflowTool)\n\n        test = self._makeOne('test')\n        wtool.notifyCreated(test)\n        self.assertEqual(len(ctool), 0)\n\n    def test_tracker261(self):\n        #\n        #   Tracker issue #261 says that content in a deleted folder\n        #   is not being uncatalogued.  Try creating a subfolder with\n        #   content object, and test.\n        #\n        from ..PortalFolder import PortalFolder\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        ctool = DummyCatalogTool()\n        getSiteManager().registerUtility(ctool, ICatalogTool)\n        self.assertEqual(len(ctool), 0)\n\n        test._setObject('sub', PortalFolder('sub', ''))\n        sub = test.sub\n\n        sub._setObject('foo', DummyContent('foo', catalog=1))\n        foo = sub.foo\n\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n        self.assertEqual(len(ctool), 1)\n\n        foo.reset()\n        test._delObject('sub')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n        self.assertEqual(len(ctool), 0)\n\n    def test_manageAddFolder(self):\n        #\n        #   Does MKDIR/MKCOL intercept work?\n        #\n        from ..PortalFolder import PortalFolder\n        from ..PortalFolder import PortalFolderFactory\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n\n        ttool = TypesTool()\n        ttool._setObject('Folder',\n                         FTI(id='Folder',\n                             title='Folder or Directory',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder',\n                             filter_content_types=0))\n        ttool._setObject('Grabbed',\n                         FTI('Grabbed',\n                             title='Grabbed Content',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder'))\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n        sm.registerUtility(PortalFolderFactory, IFactory, 'cmf.folder')\n\n        # First, test default behavior\n        test.manage_addFolder(id='simple', title='Simple')\n        self.assertEqual(test.simple.getPortalTypeName(), 'Folder')\n        self.assertEqual(test.simple.Type(), 'Folder or Directory')\n        self.assertEqual(test.simple.getId(), 'simple')\n        self.assertEqual(test.simple.Title(), 'Simple')\n\n        # Now, test overridden behavior\n        ttool.Folder.setMethodAliases({'mkdir': 'grabbed'})\n\n        class Grabbed:\n\n            _grabbed_with = None\n\n            def __init__(self, context):\n                self._context = context\n\n            def __call__(self, id):\n                self._grabbed_with = id\n                self._context._setOb(id, PortalFolder(id))\n                self._context._getOb(id)._setPortalTypeName('Grabbed')\n\n        self.app.grabbed = Grabbed(test)\n\n        test.manage_addFolder(id='indirect', title='Indirect')\n        self.assertEqual(test.indirect.getPortalTypeName(), 'Grabbed')\n        self.assertEqual(test.indirect.Type(), 'Grabbed Content')\n        self.assertEqual(test.indirect.getId(), 'indirect')\n        self.assertEqual(test.indirect.Title(), 'Indirect')\n\n    def test_contentPasteAllowedTypes(self):\n        #\n        #   _verifyObjectPaste() should honor allowed content types\n        #\n        ttool = TypesTool()\n        getSiteManager().registerUtility(ttool, ITypesTool)\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        ttool._setObject('Folder', FTI(**fti))\n        sub1 = self._makeOne('sub1')\n        sub1._setObject('dummy', DummyContent('dummy'))\n        sub2 = self._makeOne('sub2')\n        sub2.all_meta_types = extra_meta_types()\n\n        # Allow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=False)\n\n        # Copy/paste should work fine\n        cookie = sub1.manage_copyObjects(ids=['dummy'])\n        sub2.manage_pasteObjects(cookie)\n\n        # Disallow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=True)\n\n        # Now copy/paste should raise a ValueError\n        cookie = sub1.manage_copyObjects(ids=('dummy',))\n        self.assertRaises(ValueError, sub2.manage_pasteObjects, cookie)\n\n    def test_contentPasteFollowsWorkflowGuards(self):\n        #\n        # Copy/Paste should obey workflow guards\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ttool = TypesTool()\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        ttool._setObject('Folder', FTI(**fti))\n        folder = self._makeOne('folder', 'Folder')\n        content = self._makeOne('content')\n        folder._setObject('content', content)\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n\n        # Allow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=False)\n\n        # Copy/paste verification should work fine\n        folder._verifyObjectPaste(content)\n\n        # Add a workflow with a blocking guard\n        # Based on TypesTools tests\n        class DummyWorkflow:\n\n            _allow = False\n\n            def allowCreate(self, container, type_id):\n                return self._allow\n\n        class DummyWorkflowTool:\n\n            def __init__(self):\n                self._workflows = [DummyWorkflow()]\n\n            def getWorkflowsFor(self, type_id):\n                return self._workflows\n\n        # Now copy/paste verification should raise a ValueError\n        sm.registerUtility(DummyWorkflowTool(), IWorkflowTool)\n        self.assertRaises(ValueError, folder._verifyObjectPaste, content)\n\n    def test_setObjectRaisesBadRequest(self):\n        #\n        #   _setObject() should raise BadRequest on duplicate id\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertRaises(BadRequest, test._setObject, 'foo',\n                          DummyContent('foo'))\n\n    def test__checkId_Duplicate(self):\n        #\n        #   _checkId() should raise BadRequest on duplicate id\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertRaises(BadRequest, test._checkId, 'foo')\n\n    def test__checkId_PortalRoot(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        test._checkId('acl_users')\n        newSecurityManager(None, acl_users.user_foo)\n        self.assertRaises(BadRequest, test._checkId, 'acl_users')\n\n    def test__checkId_MethodAlias(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setPortalTypeName('Dummy Content 15')\n        ttool = TypesTool()\n        ttool._setObject('Dummy Content 15', FTI(**FTIDATA_CMF[0]))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        test._checkId('view')\n        newSecurityManager(None, acl_users.user_foo)\n        self.assertRaises(BadRequest, test._checkId, 'view')\n\n    def test__checkId_starting_with_dot(self):\n        #\n        # doted prefixed names at the root of the portal can be overriden\n        #\n\n        # Create a .foo at the root\n        self.site._setObject('.foo', DummyContent('.foo'))\n\n        # Create a sub-folder\n        sub = self._makeOne('sub')\n\n        # It should be possible to create another .foo object in the\n        # sub-folder\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.user_foo)\n\n        self.assertTrue(sub.checkIdAvailable('.foo'))\n\n    def test__checkId_Five(self):\n        test = self._makeOne('test')\n        self.assertRaises(BadRequest, test._checkId, '@@view')\n\n    def test_checkIdAvailableCatchesBadRequest(self):\n        #\n        #   checkIdAvailable() should catch BadRequest\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertFalse(test.checkIdAvailable('foo'))\n\n\nclass PortalFolderMoveTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def setUp(self):\n        SecurityTest.setUp(self)\n        self.app._setObject('site', DummySite('site'))\n        self.site = self.app.site\n\n    def _makeOne(self, id, *args, **kw):\n        from ..PortalFolder import PortalFolder\n\n        return self.site._setObject(id, PortalFolder(id, *args, **kw))\n\n    def test_folderMove(self):\n        #\n        #   Does the catalog stay synched when folders are moved?\n        #\n        from ..PortalFolder import PortalFolder\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ctool = DummyCatalogTool()\n        sm = getSiteManager()\n        sm.registerUtility(TypesTool(), ITypesTool)\n        sm.registerUtility(ctool, ICatalogTool)\n        self.assertEqual(len(ctool), 0)\n\n        folder = self._makeOne('folder')\n        folder._setObject('sub', PortalFolder('sub', ''))\n        folder.sub._setObject('foo', DummyContent('foo', catalog=1))\n        self.assertEqual(len(ctool), 1)\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/sub/foo'))\n\n        transaction.savepoint(optimistic=True)\n        folder.manage_renameObject(id='sub', new_id='new_sub')\n        self.assertEqual(len(ctool), 1)\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/new_sub/foo'))\n\n        folder._setObject('bar', DummyContent('bar', catalog=1))\n        self.assertEqual(len(ctool), 2)\n        self.assertTrue(has_id(ctool, 'bar'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/bar'))\n\n        folder._setObject('sub2', PortalFolder('sub2', ''))\n        sub2 = folder.sub2\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub2.all_meta_types = []\n        sub2.all_meta_types.extend(sub2.all_meta_types)\n        sub2.all_meta_types.extend(extra_meta_types())\n\n        transaction.savepoint(optimistic=True)\n        cookie = folder.manage_cutObjects(ids=['bar'])\n        sub2.manage_pasteObjects(cookie)\n\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_id(ctool, 'bar'))\n        self.assertEqual(len(ctool), 2)\n        self.assertTrue(has_path(ctool, '/bar/site/folder/sub2/bar'))\n\n    def test_contentPaste(self):\n        #\n        #   Does copy / paste work?\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ctool = DummyCatalogTool()\n        ttool = TypesTool()\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        sub1 = self._makeOne('sub1')\n        sub2 = self._makeOne('sub2')\n        sub3 = self._makeOne('sub3')\n        self.assertEqual(len(ctool), 0)\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(ttool, ITypesTool)\n\n        sub1._setObject('dummy', DummyContent('dummy', catalog=1))\n        self.assertTrue('dummy' in sub1.objectIds())\n        self.assertTrue('dummy' in sub1.contentIds())\n        self.assertFalse('dummy' in sub2.objectIds())\n        self.assertFalse('dummy' in sub2.contentIds())\n        self.assertFalse('dummy' in sub3.objectIds())\n        self.assertFalse('dummy' in sub3.contentIds())\n        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))\n\n        cookie = sub1.manage_copyObjects(ids=('dummy',))\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub2.all_meta_types = []\n        sub2.all_meta_types.extend(sub2.all_meta_types)\n        sub2.all_meta_types.extend(extra_meta_types())\n        sub2.manage_pasteObjects(cookie)\n        self.assertTrue('dummy' in sub1.objectIds())\n        self.assertTrue('dummy' in sub1.contentIds())\n        self.assertTrue('dummy' in sub2.objectIds())\n        self.assertTrue('dummy' in sub2.contentIds())\n        self.assertFalse('dummy' in sub3.objectIds())\n        self.assertFalse('dummy' in sub3.contentIds())\n        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))\n\n        transaction.savepoint(optimistic=True)\n        cookie = sub1.manage_cutObjects(ids=('dummy',))\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub3.all_meta_types = []\n        sub3.all_meta_types.extend(sub3.all_meta_types)\n        sub3.all_meta_types.extend(extra_meta_types())\n        sub3.manage_pasteObjects(cookie)\n        self.assertFalse('dummy' in sub1.objectIds())\n        self.assertFalse('dummy' in sub1.contentIds())\n        self.assertTrue('dummy' in sub2.objectIds())\n        self.assertTrue('dummy' in sub2.contentIds())\n        self.assertTrue('dummy' in sub3.objectIds())\n        self.assertTrue('dummy' in sub3.contentIds())\n        self.assertFalse(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub3/dummy'))\n\n\nclass ContentFilterTests(unittest.TestCase):\n\n    def setUp(self):\n        self.dummy = DummyContent('Dummy')\n\n    def test_empty(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter()\n        dummy = self.dummy\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = [_f for _f in desc.split('; ') if _f]\n        self.assertFalse(lines)\n\n    def test_Type(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Type='foo')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        cfilter = ContentFilter(Type='Dummy Content Title')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Type: Dummy Content Title')\n\n        cfilter = ContentFilter(Type=('foo', 'bar'))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        cfilter = ContentFilter(Type=('Dummy Content Title', 'something else'))\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Type: Dummy Content Title, something else')\n\n    def test_portal_type(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(portal_type='some_pt')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'asdf'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'some_ptyyy'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'xxxsome_ptyyy'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'some_pt'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Portal Type: some_pt')\n\n    def test_Title(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Title='foo')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.title = 'asdf'\n        self.assertFalse(cfilter(dummy))\n        dummy.title = 'foolish'\n        self.assertTrue(cfilter(dummy))\n        dummy.title = 'ohsofoolish'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Title: foo')\n\n    def test_Creator(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Creator='moe')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.creators = ('curly',)\n        self.assertFalse(cfilter(dummy))\n        dummy.creators = ('moe',)\n        self.assertTrue(cfilter(dummy))\n        dummy.creators = ('moe', 'curly')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Creator: moe')\n\n    def test_Description(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Description='funny')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.description = 'sad'\n        self.assertFalse(cfilter(dummy))\n        dummy.description = 'funny'\n        self.assertTrue(cfilter(dummy))\n        dummy.description = 'it is funny you should mention it...'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Description: funny')\n\n    def test_Subject(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Subject=('foo',))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('bar',)\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('foo',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo', 'bar')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Subject: foo')\n\n    def test_Subject2(self):\n        # Now test with mutli-valued\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Subject=('foo', 'bar'))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('baz',)\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('bar',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo', 'bar')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Subject: foo, bar')\n\n    def test_created(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=creation_date,\n                                created_usage='range:min')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Created since: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_created2(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=creation_date,\n                                created_usage='range:max')\n\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Created before: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_modified(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(modified=DateTime('2001/01/01'),\n                                modified_usage='range:min')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Modified since: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_modified2(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(modified=DateTime('2001/01/01'),\n                                modified_usage='range:max')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Modified before: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_mixed(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=DateTime('2001/01/01'),\n                                created_usage='range:max', Title='foo')\n\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertFalse(cfilter(dummy))\n\n        dummy.title = 'ohsofoolish'\n        del dummy.created_date\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 2)\n        self.assertTrue('Created before: 2001/01/01 00:00:00 %s' % tz in lines)\n        self.assertTrue('Title: foo' in lines)\n\n\n# -----------------------------------------------------------------------------\n#   Tests for security-related CopySupport lifted from the Zope 2.7\n#   / head OFS.tests.testCopySupport (see Collector #259).\n# -----------------------------------------------------------------------------\nADD_IMAGES_AND_FILES = 'Add images and files'\nFILE_META_TYPES = ({'name': 'File',\n                    'action': 'manage_addFile',\n                    'permission': ADD_IMAGES_AND_FILES},)\n\n\nclass _SensitiveSecurityPolicy:\n\n    def __init__(self, validate_lambda, checkPermission_lambda):\n        self._lambdas = (validate_lambda, checkPermission_lambda)\n\n    def validate(self, *args, **kw):\n        if self._lambdas[0](*args, **kw):\n            return True\n        raise Unauthorized\n\n    def checkPermission(self, *args, **kw):\n        return self._lambdas[1](*args, **kw)\n\n\nclass _AllowedUser(Implicit):\n\n    def __init__(self, allowed_lambda):\n        self._lambdas = (allowed_lambda,)\n\n    def getId(self):\n        return 'unit_tester'\n\n    def getUserName(self):\n        return 'Unit Tester'\n\n    def allowed(self, object, object_roles=None):\n        return self._lambdas[0](object, object_roles)\n\n\nclass PortalFolderCopySupportTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def _initFolders(self):\n        from ..PortalFolder import PortalFolder\n\n        self.app._setObject('folder1', PortalFolder('folder1'))\n        self.app._setObject('folder2', PortalFolder('folder2'))\n        folder1 = getattr(self.app, 'folder1')\n        manage_addFile(folder1, 'file', file='', content_type='text/plain')\n\n        # Hack, we need a _p_mtime for the file, so we make sure that it\n        # has one. We use a subtransaction, which means we can rollback\n        # later and pretend we didn't touch the ZODB.\n        transaction.savepoint(optimistic=True)\n        return self.app._getOb('folder1'), self.app._getOb('folder2')\n\n    def _assertCopyErrorUnauth(self, callable, *args, **kw):\n        import re\n\n        from OFS.CopySupport import CopyError\n\n        from ..exceptions import zExceptions_Unauthorized\n\n        ce_regex = kw.get('ce_regex')\n        if ce_regex is not None:\n            del kw['ce_regex']\n\n        try:\n            callable(*args, **kw)\n        except CopyError as e:\n            if ce_regex is not None:\n                pattern = re.compile(ce_regex, re.DOTALL)\n                if pattern.search(str(e)) is None:\n                    self.fail(\"Paste failed; didn't match pattern:\\n%s\" % e)\n            else:\n                self.fail('Paste failed; no pattern:\\n%s' % e)\n\n        except zExceptions_Unauthorized:\n            pass\n        else:\n            self.fail('Paste allowed unexpectedly.')\n\n    def _initPolicyAndUser(self, a_lambda=None, v_lambda=None, c_lambda=None):\n        def _promiscuous(*args, **kw):\n            return 1\n\n        if a_lambda is None:\n            a_lambda = _promiscuous\n\n        if v_lambda is None:\n            v_lambda = _promiscuous\n\n        if c_lambda is None:\n            c_lambda = _promiscuous\n\n        scp = _SensitiveSecurityPolicy(v_lambda, c_lambda)\n        SecurityManager.setSecurityPolicy(scp)\n\n        newSecurityManager(None,\n                           _AllowedUser(a_lambda).__of__(self.app.acl_users))\n\n    def test_copy_baseline(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        self._initPolicyAndUser()\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertFalse('file' in folder2.objectIds())\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        folder2.manage_pasteObjects(cookie)\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertTrue('file' in folder2.objectIds())\n\n    def test_copy_cant_read_source(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        a_file = folder1._getOb('file')\n\n        def _validate(a, c, n, v, *args, **kw):\n            return aq_base(v) is not aq_base(a_file)\n\n        self._initPolicyAndUser(v_lambda=_validate)\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects,\n                                    cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_copy_cant_create_target_metatype_not_supported(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = ()\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Not Supported')\n\n    def test_move_baseline(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertFalse('file' in folder2.objectIds())\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        folder2.manage_pasteObjects(cookie)\n\n        self.assertFalse('file' in folder1.objectIds())\n        self.assertTrue('file' in folder2.objectIds())\n\n    def test_move_cant_read_source(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        a_file = folder1._getOb('file')\n\n        def _validate(a, c, n, v, *args, **kw):\n            return aq_base(v) is not aq_base(a_file)\n\n        self._initPolicyAndUser(v_lambda=_validate)\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_move_cant_create_target_metatype_not_supported(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = ()\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Not Supported')\n\n    def test_move_cant_create_target_metatype_not_allowed(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        def _no_manage_addFile(a, c, n, v, *args, **kw):\n            return n != 'manage_addFile'\n\n        def _no_add_images_and_files(permission, object, context):\n            return permission != ADD_IMAGES_AND_FILES\n\n        self._initPolicyAndUser(v_lambda=_no_manage_addFile,\n                                c_lambda=_no_add_images_and_files)\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_move_cant_delete_source(self):\n        from AccessControl.Permissions import delete_objects as DeleteObjects\n\n        from ..PortalFolder import PortalFolder\n\n        folder1, folder2 = self._initFolders()\n        folder1.manage_permission(DeleteObjects, roles=(), acquire=0)\n\n        folder1._setObject('sub', PortalFolder('sub'))\n        transaction.savepoint(optimistic=True)  # get a _p_jar for 'sub'\n\n        def _no_delete_objects(permission, object, context):\n            return permission != DeleteObjects\n\n        self._initPolicyAndUser(c_lambda=_no_delete_objects)\n\n        cookie = folder1.manage_cutObjects(ids=('sub',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient Privileges'\n                                    + '.*%s' % DeleteObjects)\n\n    def test_paste_with_restricted_item_content_type_not_allowed(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the item being pasted does not allow adding such\n        #   objects to containers which do not explicitly grant access.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Item'\n        UNRESTRICTED_TYPE = 'Unrestricted Container'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = UNRESTRICTED_TYPE\n        folder2.portal_type = RESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=0))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=0))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should raise\n        # an exception\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)\n\n    def test_paste_with_restricted_item_content_type_allowed(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the item being pasted *does8 allow adding such\n        #   objects to containers which *do* explicitly grant access.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Item'\n        UNRESTRICTED_TYPE = 'Unrestricted Container'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = UNRESTRICTED_TYPE\n        folder2.portal_type = RESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=0))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=1,\n                             allowed_content_types=[RESTRICTED_TYPE]))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should *not* raise\n        # an exception, because the folder's type allows it.\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        folder1.manage_pasteObjects(copy_cookie)\n        self.assertTrue('folder2' in folder1.objectIds())\n\n    def test_paste_with_restricted_container_content_type(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the container does not allow adding items of the\n        #   type being pasted.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Container'\n        UNRESTRICTED_TYPE = 'Unrestricted Item'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = RESTRICTED_TYPE\n        folder2.portal_type = UNRESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=1,\n                             allowed_content_types=()))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=1))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should raise\n        # an exception\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)\n\n\ndef test_suite():\n    loadTestsFromTestCase = unittest.defaultTestLoader.loadTestsFromTestCase\n    return unittest.TestSuite((\n        loadTestsFromTestCase(PortalFolderFactoryTests),\n        loadTestsFromTestCase(PortalFolderTests),\n        loadTestsFromTestCase(PortalFolderSecurityTests),\n        loadTestsFromTestCase(PortalFolderMoveTests),\n        loadTestsFromTestCase(ContentFilterTests),\n        loadTestsFromTestCase(PortalFolderCopySupportTests)))\n"], "fixing_code": ["Products.CMFCore Changelog\n==========================\n\n3.2 (unreleased)\n----------------\n\n- Improve handling of PortalFolder filter input.\n\n\n3.1 (2023-06-01)\n----------------\n\n- Provide a way to not publish items that are acquired.\n\n\n3.0 (2023-04-25)\n----------------\n\n- SkinsTool: fix Find form with Zope ZMI\n  (`#127 <https://github.com/zopefoundation/Products.CMFCore/pull/127>`_).\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n- Drop support for ``Zope 4.x``.\n\n- Make tests compatible with ``Zope >= 5.7.1``.\n\n\n2.7.0 (2022-12-16)\n------------------\n\n- Fix insidious buildout configuration bug for tests against Zope 4.\n\n- Add support for Python 3.11.\n\n\n2.6.0 (2022-07-13)\n------------------\n\n- Fix cookie test failure\n  (`#120 <https://github.com/zopefoundation/Products.CMFCore/pull/120>`_).\n\n- Add support for Python 3.10.\n\n\n2.5.4 (2021-07-29)\n------------------\n\n- Fix code and tests when running on ``Products.GenericSetup >= 2.1.2``, thus\n  requiring at least that version.\n\n\n2.5.3 (2021-06-30)\n------------------\n\n- Do not break at startup when ``subscribers.zcml`` is included but no\n  ``portal_catalog`` object is in the database, e. g. when starting for the\n  first time.\n  (`#115 <https://github.com/zopefoundation/Products.CMFCore/pull/115>`_)\n\n\n2.5.2 (2021-06-24)\n------------------\n\n- Avoid DeprecationWarning for changed import location for ``rfc1123_date``\n\n- Fix several DeprecationWarnings during unit tests\n  (`#112 <https://github.com/zopefoundation/Products.CMFCore/issues/112>`_)\n\n- Set Cache-Control header in '304 Not Modified' response case as well.\n  (`#111 <https://github.com/zopefoundation/Products.CMFCore/issues/111>`_)\n\n\n2.5.1 (2021-03-12)\n------------------\n\n- Make sure ``getSkinNameFromRequest`` only returns sane values\n  (`#109 <https://github.com/zopefoundation/Products.CMFCore/issues/109>`_)\n\n- Fix Python 3 incompatibility in ``CookieCrumbler.credentialsChanged``\n\n\n2.5.0 (2021-02-09)\n------------------\n\n- Update configuration for version 5 of ``isort``.\n\n- Fix deprecation warnings occurring on Zope 5.\n\n- Added support for Python 3.9.\n\n\n2.4.8 (2020-07-03)\n------------------\n\n- Fix an issue with the indexing queue where an UNINDEX followed by REINDEX was\n  wrongly optimized to UNINDEX instead of REINDEX.\n  (`#96 <https://github.com/zopefoundation/Products.CMFCore/pull/96>`_)\n\n\n2.4.7 (2020-06-24)\n------------------\n\n- Change the default value of uid to None on CMFCatalogAware's reindexObject method (`#87 <https://github.com/zopefoundation/Products.CMFCore/issues/87>`_)\n\n\n2.4.6 (2020-04-14)\n------------------\n\n- Redid most filesystem content type ZMI Customize views.\n\n\n2.4.5 (2020-03-27)\n------------------\n\n- Fix tests to be able to run on Zope 4.3.\n\n- Fix not declared dependency on ``Products.DCWorkflow`` in `subscribers.zcml`.\n\n\n2.4.4 (2020-01-29)\n------------------\n\n- Remove Zope Help System fossils so this products is compatible with Zope 5\n\n\n2.4.3 (2020-01-10)\n------------------\n\n- Fix encoding detection for XML files.\n  (`#85 <https://github.com/zopefoundation/Products.CMFCore/issues/85>`_)\n\n\n2.4.2 (2019-11-28)\n------------------\n\n- Resolve ``docutils`` dependency conflict with ``Zope``.\n  (`#83 <https://github.com/zopefoundation/Products.CMFCore/issues/83>`_)\n\n\n2.4.1 (2019-11-27)\n------------------\n\n- Make sure ``FSFile.__str__`` returns correct native strings under Python 3.\n  (`#76 <https://github.com/zopefoundation/Products.CMFCore/issues/76>`_)\n\n- Add a ``__bytes__`` method to ``FSFile``.\n\n- Add more files types to the FSFile registrations.\n\n\n2.4.0 (2019-05-10)\n------------------\n\n- Set default encoding values on FSDTMLMethods.\n\n\n2.4.0b8 (2019-04-30)\n--------------------\n\n- Fix up all ZMI forms to work better with the Zope 4 ZMI.\n  (`#73 <https://github.com/zopefoundation/Products.CMFCore/issues/73>`_)\n\n- Ensure Content Type Registries don't use a ZMI add dialog in the Zope 4 ZMI.\n  (`#72 <https://github.com/zopefoundation/Products.CMFCore/issues/72>`_)\n\n\n2.4.0b7 (2019-04-08)\n--------------------\n\n- Expose the Cookie Crumbler title property.\n  (`#70 <https://github.com/zopefoundation/Products.CMFCore/issues/70>`_)\n\n- Clean up test and linting configurations.\n\n- Add ``project_urls`` with relevant links in ``setup.py``.\n\n- Specify supported Python versions using ``python_requires`` in setup.py.\n\n- Added support for Python 3.8.\n\n- Deprecated unused method ``PortalCatalogProcessor.get_dispatcher``.\n  (`#57 <https://github.com/zopefoundation/Products.CMFCore/issues/57>`_)\n\n- Backport plone/collective.indexing#16 to use the catalog queue\n  also when reindexing the object security.\n  (`#58 <https://github.com/zopefoundation/Products.CMFCore/issues/58>`_)\n\n- Code cleanup: avoid to call the ``keys`` method on dictionary\n  when not needed.\n  [ale-rt]\n\n\n2.4.0b6 (2018-12-14)\n--------------------\n\n- Change `im_self` to `__self__` for Python 3 compatibility.\n  (`#54 <https://github.com/zopefoundation/Products.CMFCore/pull/54>`_)\n  [ale-rt, vangheem]\n\n- Remove support for testing using ``'python setup.py test``.\n  (`#51 <https://github.com/zopefoundation/Products.CMFCore/issues/51>`_)\n\n- Add more ZMI icons for the Zope 4 ZMI.\n  (`#47 <https://github.com/zopefoundation/Products.CMFCore/issues/47>`_)\n\n- Prevent warnings on Zope start about permissions for not existing methods.\n  This requires `Zope >= 4.0b8`.\n  (`#53 <https://github.com/zopefoundation/Products.CMFCore/pull/53>`_)\n\n- Fix deprecation warnings occurring during test runs.\n\n- Update tests to `Products.GenericSetup >= 2.0b5`.\n\n\n2.4.0b5 (2018-11-07)\n--------------------\n\n- Fix ``notifyModified`` called on a wrong object.\n  [mamico]\n\n- Add support for Python 3.7.\n\n- Add support for `Zope >= 4.0b6`, thus requiring at least this version.\n\n\n2.4.0b4 (2018-05-17)\n--------------------\n\n- Add support for Python 3.5 and 3.6.\n  [ale-rt]\n\n- `sortKey` for a DataManager must be text to be sortable.\n  [pbauer]\n\n\n2.4.0b3 (2018-03-16)\n--------------------\n\n- Remove dependency on ``five.globalrequest``, its functionality\n  is provided by ``zope.globalrequest``.\n\n- Do not autogenerate `string:${portal_url}/`, when no input for\n  `content_icon` was provided.\n  [pgrunewald]\n\n- Avoid writing MemberData to the member data tool until\n  properties are actually set.\n  [davisagli]\n\n- Python 2 / 3 compatible imports.\n  [rudaporto]\n\n- Update Products.MailHost dependency to 4.0\n  [dataflake]\n\n- Add icons for Bootstrap ZMI.\n  [icemac, dwt]\n\n\n2.4.0b2 (2017-05-05)\n--------------------\n\n- Factored support for FSZSQL methods out into a setup extra.\n  If you need support for Filesystem ZSQL methods, install the\n  egg specifying the ``zsql`` extra.\n  [dataflake]\n\n- Use ``zope.interface.implementer`` decorator instead of\n  ``zope.interface.implements``\n  [dataflake]\n\n- Use security declaration decorator notation where possible.\n  [dataflake]\n\n- Improve the new indexing object wrapping for unindexing by using a\n  module-level wrapper class based on zope.proxy instead of a class\n  at method level.\n  Some discussion available at GitHub PR #15.\n  [dataflake]\n\n- Queue and process indexing operations (index, reindex, unindex) at\n  transaction boundaries. This allows to reduce redundant operations\n  and thus improving performance.\n  Operations are processed just at transaction boundaries or whenever\n  a catalog search is performed.\n  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n  [gforcada]\n\n- Provide a ``CATALOG_OPTIMIZATION_DISABLED`` environment variable to\n  disable any catalog optimization. This is mostly meant to be used so that\n  tests which may need some adaptation do not break after updating to\n  this version. Set it to ``true``, i.e.\n  ``export CATALOG_OPTIMIZATION_DISABLED=true`` before running tests.\n  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n  [gforcada]\n\n\n2.4.0b1 (2017-05-04)\n--------------------\n\n- Target use with Zope 4:  no longer support 2.13.x.\n\n- Make sure RegistrationTool.addMember is not published\n  [vangheem]\n\n- Don't fail on catalog inconsistency when doing `reindexObjectSecurity`\n  [tomgross]\n\n2.3.0 (2015-02-20)\n------------------\n\n- Fall back to DAV aware marshaller when importing or exporting folderish\n  content, so types now retain their metadata when being round-tripped.\n  [MatthewWilkes]\n\n- IndexableObjectWrapper: Made sure portal_type doesn't return None.\n  Products.ZCatalog 3 indexes can no longer handle None values.\n\n- interfaces: Fixed dotted names by setting __module__ explicitly.\n\n- Skinnable: The skins tool is now looked up as utility.\n  'getSkinsFolderName' is no longer supported, that method was removed.\n\n- permissions: Fixed some issues in permissions.zcml.\n\n- support unset portal_skins request variables in HTTP headers\n  (see https://dev.plone.org/ticket/10071) [fRiSi]\n\n2.3.0-beta2 (2012-03-31)\n------------------------\n\n- added fixes for migrating CMF 2.2 sites.\n\n\n2.3.0-beta (2012-03-21)\n------------------------\n\n- DynamicType: Modified 'icon' method.\n  The specified icon might be registered for a ZTK layer that is not available\n  in the ZMI. If the icon can't be found, an empty string is returned.\n\n- exportimport.tests.test_mailhost:  Accomodate 'smtp_queue' and\n  'smtp_queue_directory' exports (newly added in GenericSetup).\n\n- tools: Converted all tools into local utilities.\n  The registration is not done here, see CMFDefault_ as an example of a\n  registration via GenericSetup.\n\n- MemberDataTool: Changed property modes to 'w' and added 'fullname' property.\n\n- setup handlers: Improved content type registry handler.\n  The 'insert-before' and 'insert-after' directives are now supported.\n\n- Optimize `SkinnableObjectManager.__getattr__` to short circuit view (`@`) and\n  traverser (`+`) lookup in addition to `_` and `aq_`.\n\n- Avoid a shallow dependency on `Products.ZReST`.\n\n- Fixed types tool test to only test creation for type infos.\n\n- utils: Fixed '_OldCacheHeaders' and '_FSCacheHeaders' methods.\n  DateTimeErrors caused by invalid HTTP headers were not caught.\n\n- setup handlers: Added export/import support for member data tool settings.\n\n- MemberDataTool: Fixed tool initialization.\n  The default boolean and date property values were not set correctly.\n\n- MemberDataTool: Modified 'setProperties' method.\n  It now can be used by user managers as well.\n\n- MembershipTool: Added 'isMemberAccessAllowed' method.\n  If you don't have the 'Manage users' permission for the membership tool, you\n  shouldn't have write access to other members.\n\n- MemberDataTool: Removed obsolete MemberData factory lookup.\n  This feature was added in CMF 2.2, but now the MemberAdapter should be\n  overridden instead.\n\n- MemberDataTool: Split up MemberData class.\n  The old MemberData API is now provided by the new MemberAdapter. The\n  persistent MemberData objects are just used for storing member data.\n\n- interfaces: Added 'IMember' interface.\n\n- permissions: Marked 'setDefaultRoles' as deprecated.\n\n- DirectoryView: Added 'bobobase_modification_time' method to FSObject.\n  The \"Contents\" tab in the ZMI now shows useful 'Last Modified' values.\n\n- DirectoryView: Changed debug mode behavior.\n  No additional subdirs are registered in debug mode. If you add new subdirs,\n  you have to restart your instance.\n  (https://bugs.launchpad.net/zope-cmf/+bug/271027)\n\n- DirectoryView: Improved debug mode speed on NTFS partitions.\n  The much faster non-Windows implementation is now used on Windows as well if\n  non-FAT32 time stamps are detected. In rare cases that heuristic approach\n  might fail to detected NTFS partitions.\n\n- DirectoryView: Modernized debug mode lookup.\n  Now getConfiguration().debug_mode is used instead of Globals.DevelopmentMode.\n\n- Fix content exportimport when Title or Description are unicode (merge from\n  2.2 branch).\n\n- tests base: Tightened security for anonymous test user.\n\n- Load permissions.zcml from Products.Five in the test to fix tests\n  with Zope 2.12.\n\n- notifyWorkflowCreated only to IWorkflowAware, possibly following adaption on\n  IObjectAddedEvent.\n\n- Adapterize workflow storage lookups.\n\n- utils: Added FakeExecutableObject.\n  It can be used to set proxy roles in trusted code.\n\n- tests base: Removed obsolete test utils.\n\n- testing: Removed broken run function.\n  Unit test modules are no longer directly executable.\n\n- CookieCrumbler: Removed redirect support.\n  The Unauthorized handling and redirects are now part of CMFDefault.\n\n- Added a permissions.zcml file defining our own permissions. This was\n  formerly done in Zope 2's Products.Five.\n\n- Removed zope.app.testing dependency.\n\n- Import BeforeTraverseEvent from new location if available.\n\n- Skinnable and MembershipTool: Removed support for missing REQUEST argument.\n  'changeSkin', 'setupCurrentSkin' and 'credentialsChanged' will no longer\n  try to acquire the request if it is not passed in explicitly.\n\n- Tools and PortalFolder: Removed support for deprecated marker attributes.\n  '_isDirectoryView', '_isPortalRoot', '_isTypeInformation' and '_isAWorkflow'\n  are no longer supported.\n\n- utils: Removed deprecated functions.\n  'getToolByInterfaceName', 'initializeBasesPhase1', 'initializeBasesPhase2',\n  'expandpath' and 'minimalpath' are no longer available.\n\n- DirectoryView: Removed support for deprecated old API.\n\n- Require at least Zope 2.13.12.\n\n.. _CMFDefault : https://github.com/zopefoundation/Products.CMFDefault/blob/master/Products/CMFDefault/profiles/default/componentregistry.xml\n\n2.2.5 (2011-11-01)\n------------------\n\n- Added two missing explicit InitializeClass calls.\n\n\n2.2.4 (2011-04-02)\n------------------\n\n- Fix content exportimport when Title or Description are unicode.\n\n\n2.2.3 (2010-10-31)\n------------------\n\n- Make the error raised when trying to rename an instance of ImmutableId\n  indicate the id of the object.\n\n- DateTime 2.12.5 does away with a special case representing\n  DateTime values for midnight (00:00:00) without their time and\n  time zone values. So DateTimes formerly rendered as\n  ``2010/01/01`` in the UTC timezone now render as\n  ``2010/01/01 00:00:00 UTC``. Several unit tests that relied on\n  the old-style representation had to be fixed.\n\n- Get most tests working under Zope 2.13.0a2.\n\n- Added dependency on the new ``Products.ZSQLMethods`` distribution and updated\n  Zope2 requirement accordingly.\n\n\n2.2.2 (2010-07-04)\n------------------\n\n- Backport test setup fixes for Zope 2.13 compatibility.\n\n- Use the standard libraries doctest module.\n\n- Updated setDefaultRoles to use the addPermission API if available.\n\n- Updated test to work with zope.contenttype >= 3.4.3.\n\n\n2.2.1 (2010-04-07)\n------------------\n\n- Actions and TypeInformation: Clear the compiled NNN_expr_object\n  property when the NNN_expr property is cleared.\n\n- Actions: Return None if 'link_target' is an empty string.\n  This helps to avoid invalid empty 'target' attributes in HTML output.\n\n\n2.2.0 (2010-01-04)\n------------------\n\n- Changed GenericSetup import handlers to fail silently if they\n  are called in a context that does not contain the items they\n  import.\n\n\n2.2.0-beta (2009-12-06)\n-----------------------\n\n- TypesTool: Made it an ordered container.\n  This allows to control the order of the add actions.\n\n- TypeInformation: Removed redundant 'content_icon' property.\n  For backwards compatibility old settings containing 'content_icon' instead\n  of 'icon_expr' are converted on import. CMFDefault provides the necessary\n  upgrade steps for migrating existing sites.\n\n- DynamicType: Added 'getIconURL' method.\n  This replaces the now deprecated 'getIcon' method.\n\n- TypeInformation: Added 'getIconExprObject' method.\n  This replaces the now deprecated 'getIcon' method.\n\n\n2.2.0-alpha (2009-11-13)\n------------------------\n\n- Got rid of redundant icon related type info properties.\n  (https://bugs.launchpad.net/zope-cmf/+bug/397795)\n\n- PortalFolder: Ensure that pasting an object into a folder takes\n  workflow instance creation conditions into account.\n  (https://bugs.launchpad.net/zope-cmf/+bug/308947)\n\n- Made calls to reindexObjectSecurity in the membership tool conditional\n  after the CMFCatalogAware refactoring.\n\n- PortalFolder: Removed unused ICatalogAware and IWorkflowAware methods.\n\n- CMFCatalogAware: Split up CMFCatalogAware mixin.\n  CatalogAware, WorkflowAware and OpaqueItemManager are now separate mixins.\n\n- Changed testing.py to directly load zope.traversing's ZCML instead of going\n  via the Five traversing.zcml BBB shim.\n\n- moved the Zope dependency to version 2.12.0b3dev\n\n- PortalFolder: Modified allowedContentTypes method to check\n  isConstructionAllowed only for allowed types, not for all content types.\n\n- Fixed typo in the acquisition wrapping of the found utility in\n  getToolByName.\n\n- Actions: Add a link_target attribute to store a value for the\n  final rendered link tag's \"target\" attribute\n  (https://bugs.launchpad.net/zope-cmf/+bug/376951)\n\n- MemberData tool: Make it easier to override the default\n  MemberData implementation by trying to look up a named\n  factory utility named \"MemberData\" before falling back on the\n  default MemberData class.\n  (https://bugs.launchpad.net/zope-cmf/+bug/377208)\n\n- FSPageTemplate: Change the charset/encoding detection to consider\n  charset specifications in the content type, and replace the\n  hardcoded Latin-15 fallback with the mechanism used by the\n  Products.PageTemplate code, which can be influenced by setting\n  the environment variable \"ZPT_PREFERRED_ENCODING\"\n  (https://bugs.launchpad.net/zope-cmf/+bug/322263)\n\n- Expose the ZMI manage view of the \"_components\" object manager as\n  a new \"Components Folder\" tab in the ZMI.\n\n- ActionsTool: The \"Action Providers\" tab in the ZMI did not render\n  actions from the WorkflowTool correctly since those are not\n  'new-style' actions.\n  (https://bugs.launchpad.net/zope-cmf/+bug/322300)\n\n- FSPageTemplate: Prevent reading the underlying file without doing\n  anything with the data in some cases.\n\n- FSObject: Ensure that ZCache invalidations only happens if the\n  filesystem modification time differs from the internally stored\n  previous modification time.\n  (https://bugs.launchpad.net/zope-cmf/+bug/325246)\n\n- TypeInformation: DCWorkflow instances define a method and a guard\n  for vetoing object creation, but it was never used. Now\n  TypeInformation objects will consult these guard conditions during\n  object creation.\n  (https://bugs.launchpad.net/zope-cmf/+bug/308947)\n\n- PortalCatalog: Changed to use a multi-adaptor to allow a pluggable\n  IndexableObjectWrapper class.  Objects that implement IIndexableObject\n  are not wrapped.  The change will assist in integrating with\n  other indexing strategies from third-party packages.\n\n- Events: Changed 'handleContentishEvent' behavior for IObjectCopiedEvent.\n  'WorkflowTool.notifyCreated' no longer resets the workflow state, so the\n  the event subscriber clears the workflow history instead.\n\n- WorkflowTool: 'notifyCreated' no longer overrides assigned workflow states.\n\n- No longer catch a `NotImplemented` string exception in the MembershipTool\n  in deleteMembers.\n\n- Cleaned up / normalized imports:\n\n  o Don't import from Globals;  instead, use real locations.\n\n  o Make other imports use the actual source module, rather than an\n    intermediate (e.g., prefer importing 'ClassSecurityInfo' from\n    'AccessControl.SecurityInfo' rather than from 'AccessControl').\n\n  o Avoid relative imports, which will break in later versions of Python.\n\n- Added `icon_expr` as a new property to type information. This allows you\n  to specify the `content_icon` as an expression and store it. This avoids\n  creating the expression on the fly at rendering time.\n\n- Removed superGetAttr fallback from SkinnableObjectManager. None of its base\n  classes have a `__getattr__` method anymore.\n\n- PortalObject: Removed backwards compatibility code in getSiteManager.\n  Please use CMFDefault's upgrade steps for upgrading old CMF sites.\n\n- Fixed compatibility with non-string exceptions on Zope trunk.\n\n- Added remove support to GenericSetup types tool exportimport handler.\n\n- FiveActionsTool: Removed the tool and all functionality for bridging\n  between Zope 3-style menu items and CMF actions. The CMF has been going\n  a different route for a long time and the code is unused and\n  unmaintained.\n\n- Actions: Added deprecation warnings to the ZMI actions tab and\n  most listActions methods where old-style actions are found\n  asking developers to move to new-style actions instead. These\n  warnings allow us to remove old-style actions code by version 2.4.\n\n- Discussion tool: Removed the listActions method that would return\n  a hardcoded Reply action. This action has been handled by the\n  Actions tool itself for a while now, and the Discussions tool was\n  not set as an action provider anymore.\n\n- actions tool export/import: The actions tool export/import mechanism\n  is no longer attempting to handle actions stored on tools other than\n  itself. Other tools are themselves responsible for their actions.\n  The importer has been fixed to add all action providers to the actions\n  tool, not just a select list of providers we know about.\n  (https://bugs.launchpad.net/zope-cmf/+bug/177675)\n\n- tool interfaces: Replace non-existing IMember interface with the\n  correct IMemberData.\n\n- CatalogTool: If proxy roles are set on a script that uses the catalog\n  and those proxy roles have been unset using the ZMI, which results\n  in an empty tuple as proxy roles, then the catalog would not correctly\n  determine what the current user is allowed to see.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161729)\n\n- Properties export/import: Get the string encoding for property\n  imports from the import context and fall back to UTF-8, which\n  mirrors the behavior for exports. This fixes property export/import\n  round tripping.\n  (https://bugs.launchpad.net/zope-cmf/+bug/248853)\n\n- traversal: Added ++add++ namespace for add views.\n\n- Skinstool import: Fix imports that manipulate existing skins.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161732)\n\n- ActionInformation: extend the ActionInformation and ActionInfo classes\n  to support a icon URL just like the newer Action class already does\n\n- WorkflowTool: Passing the \"magic\" chain name \"(Default)\" to the\n  setChainForPortalTypes method did not set the chain to the default\n  chain value as expected.\n  (https://bugs.launchpad.net/zope-cmf/+bug/161702)\n\n- ZMI: Prevent users from creating content through the ZMI by hiding the\n  entry for \"CMFCore Content\".\n\n- utils: Add a new optional argument to ContentInit that allows hiding\n  a content item's ZMI add list entry. The default is to leave the item\n  visible, which reflects the previous behavior.\n\n- FSMetadata: Remove handling of .security and .properties metadata\n  files which was supposed to have been removed in CMF 2.0 already.\n\n- SkinsTool: Added the ability to do a diff comparison between items\n  found using the portal_skins \"Find\" ZMI tab.\n  (https://bugs.launchpad.net/zope-cmf/+bug/238489)\n\n- TypeInformation and TypesTool: Added support for add view actions.\n  Type infos now have a new 'add_view_expr' property and implement IAction.\n  'listActions' of the types tool includes type infos as 'add' actions.\n\n- interfaces: Fixed some docstrings.\n  There is no IActionInformation. ActionInformation is an old action class\n  that implements IAction, non-persistent IActionInfo objects adapt action\n  objects to a given context.\n\n- FSSTXMethod: Fixed Zope 2.12 compatibility.\n  zope.structuredtext is now used instead of StructuredText.\n\n- removed the five.localsitemanager svn:external and its import hack\n  in favor of stating the dependency for separate installation in\n  DEPENDENCIES.txt and automatic installation in setup.py.\n\n- TypesTool: Refactored content creation.\n  Moved addCreator call to IObjectCreatedEvent handler and moved\n  notifyWorkflowCreated and indexObject calls to IObjectAddedEvent handler.\n  Please make sure all oldstyle content factory methods use _setObject with\n  suppress_events=True. CMF factory methods don't finish object creation,\n  so they should not send the IObjectAddedEvent.\n\n- interfaces: Added new interfaces for CMFCatalogAware methods.\n  In the long run ICatalogAware, IWorkflowAware and IOpaqueItemManager will\n  become deprecated. Don't expect that CMF content always implements them.\n\n- setup handlers: All import and export steps are now registered globally.\n\n- MembershipTool: Removed ancient LoginManager compatibility code and\n  deprecated the no longer needed __getPUS method.\n\n- interfaces: Removed deprecated oldstyle interfaces.\n\n\n2.1.2 (2008-09-13)\n------------------\n\n- fiveactionstool: fix typo in a method name that isn't even used in the CMF\n  or Plone.\n  (https://bugs.launchpad.net/zope-cmf/+bug/257259)\n\n2.1.2-beta (2008-08-26)\n-----------------------\n\n- completed devolution from monolithic CMF package into its component\n  products that are distributed as eggs from PyPI.\n\n\n2.1.1 (2008-01-06)\n------------------\n\n- exportimport.content: Add simple guard against import failures when\n  the \".objects\" file contains empty lines.\n  (https://bugs.launchpad.net/zope-cmf/+bug/176328)\n\n\n2.1.1-beta (2007-12-29)\n-----------------------\n\n- Testing: Derive test layers from ZopeLite layer if available.\n\n- Updated to the 0.3 release of five.localsitemanager.\n\n- Events: Fixed some handleContentishEvent issues.\n  Moved _clearLocalRolesAfterClone code to separate handler that is\n  triggered before indexing and also for folders. Made sure notifyModified\n  is not called if objects are just moved.\n\n- PortalObject: Added setSite to getSiteManager for old instances. This\n  fixes migrations from Plone 2.1 to 3.0.\n\n- FSImage: Supply class-level defaults for 'alt', 'height', and 'width',\n  to avoid acquiring objects with the same names.\n  (http://www.zope.org/Collectors/CMF/507)\n\n- Testing: Derive test layers from ZopeLite layer if available.\n\n- PortalObject: Fixed a bug in the site manager creation code, which would\n  assign the __parent__ pointer to the Aq-wrapper and not the actual\n  object.\n\n\n2.1.0 (2007-08-08)\n------------------\n\n- Fixed all componentregistry.xml files to use plain object paths and strip\n  and slashes. GenericSetup does only support registering objects which are\n  in the site root.\n\n- PortalFolder: Enabled 'Components' ZMI tab.\n  This GenericSetup tab allows to inspect and edit component registrations.\n\n- First egg release.  For changes up through this release, please see\n  the overall \"CMF changelog\",\n  http://svn.zope.org/CMF/tags/2.1.0/CHANGES.txt?rev=78713&view=markup\n\n\n2.1.0-beta2 (2007-07-12)\n------------------------\n\n- moved the Zope dependency to version 2.10.4\n\n- Remove antique usage of marker attributes in favor of interfaces,\n  leaving BBB behind for places potentially affecting third-party code.\n  (http://www.zope.org/Collectors/CMF/440)\n\n- Add POST-only protections to security critical methods.\n  http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0240)\n\n- exportimport.skins: Added the ability to remove whole skin selections using a\n  GS profile.\n  (http://www.zope.org/Collectors/CMF/479)\n\n- UndoTool: Fixed 'listUndoableTransactionsFor'.\n  The required 'object' argument is now respected. This doesn't change the\n  behavior as long as 'object' is the site root object.\n\n- TypesTool: Corrected method signature of all_meta_types to have\n  an interface keyword argument, as per the underlying OFS.ObjectManager\n  interface declaration.\n\n- SkinnableObjectManager: Changed the way skins are set up.\n  Acquisition wrapping no longer triggers 'setupCurrentSkin'. This is now\n  done on publishing traversal after the BeforeTraverseEvent triggers\n  'setSite'. This fix replaces a temporary hack introduced in 2.1.0-beta,\n  making sure ISkinsTool is looked up after setting the site.\n\n- CMFBTreeFolder: CMFBTreeFolders could not be used as the\n  toplevel /Members container.\n  (http://www.zope.org/Collectors/CMF/441)\n\n- TypesTool: Pass 'object' through to TypeInformation objects'\n  'listActions'.\n  (http://www.zope.org/Collectors/CMF/482)\n\n- Removed extraneous \"Cache\" tab from FS-based skin objects.\n  (http://www.zope.org/Collectors/CMF/343)\n\n- WorkflowTool: Using the '(Default)' keyword for a type's\n  workflow chain will now reset any custom workflow chains for the type.\n  (http://www.zope.org/Collectors/CMF/475)\n\n- SkinsTool: Use the property API to get the member specific skin,\n  because direct attribute access won't work with PAS based membership.\n  (http://dev.plone.org/plone/ticket/5904)\n\n- Allow customization from DirectoryViews to be redirected into\n  alternate folders, and use manually-built clones.\n  (http://www.zope.org/Collectors/CMF/382)\n\n\n2.1.0-beta (2007-03-09)\n-----------------------\n\n- moved the Zope dependency to verson 2.10.2\n\n- Tool lookup and registration is now done \"the Zope 3 way\" as utilities, see\n  http://svn.zope.org/CMF/branches/2.1/docs/ToolsAreUtilities.stx?view=auto\n\n- DirectoryView: Added 'registerDirectory' ZCML directive.\n  Using the old registerDirectory method in __init__.py is now deprecated.\n  See zcml.IRegisterDirectoryDirective for details.\n\n- DirectoryView: Added support for non-product packages.\n  This introduces new registry keys. Old registry keys stored in\n  persistent DirectoryView objects are updated on the fly.\n  (http://www.zope.org/Collectors/CMF/467)\n\n- setup handlers: Improved properties handler.\n  It now works with properties using a default_charset other than UTF-8.\n\n- MembershipTool: Fixed inconsistent behavior where member lookup\n  would take all user folders up to the Zope root into account whereas\n  member area creation would not.\n\n- MembershipTool: when using an object without a __nonzero__ but with a\n  __len__ (ala CMFBTreeFolder) as a member folder, the createMemberArea\n  method would believe there was no members folder if the folder was\n  empty, and so would fail (change \"not membersfolder\" to\n  \"membersfolder is not None\") .\n\n- DynamicType: Fixed behaviour regarding default view.\n  DynamicType was making it impossible to use a Zope3-style\n  default view for CMF content types.\n  (http://www.zope.org/Collectors/CMF/459)\n\n- utils: Marked 'minimalpath' and 'expandpath' as deprecated.\n\n- Merged patches from Martin Aspeli to enable generating events before\n  and after DCWorkflow transitions, and in the 'notify' methods of the\n  workflow tool (http://www.zope.org/Collectors/CMF/461).\n\n\n2.1.0-alpha2 (2006-11-23)\n-------------------------\n\n- moved the Zope dependency to version 2.10.1\n\n- Fixed test breakage induced by use of Z3 pagetemplates in Zope 2.10+.\n\n- browser views: Added some zope.formlib based forms.\n\n- testing: Added test layers for setting up ZCML.\n\n- WorkflowTool: Added the IConfigurableWorkflowTool interface.\n  This change includes the new 'getDefaultChain' and 'listChainOverrides'\n  methods and an improved 'setChainForPortalTypes' method. The import\n  handler now supports the 'remove' attribute for removing overrides.\n  (http://www.zope.org/Collectors/CMF/457)\n\n- CachingPolicyManager: Implemented the old OFS.Cache.CacheManager\n  API. Now objects other than CMF content or CMF templates can have their\n  caching headers set by the caching policy manager with the same\n  fine-grained control.\n  (http://www.zope.org/Collectors/CMF/408)\n\n- Added CMFCore.FSRestMethod:  ReST equivalent of FSSTXMethod.\n\n- FSSTXMethod:  Modernized, added tests, made customization\n  possible (now renders via ZPT by default, using 'main_template').\n\n- CachingPolicyManager: Prevent firing of caching policies\n  for templates (DTML or ZPT) that are rendered in-line (without a\n  separate request) while rendering the requested content item's view.\n  (http://www.zope.org/Collectors/CMF/456)\n\n\n2.1.0-alpha (2006-10-09)\n------------------------\n\n- skins: Changed encoding of translated portal_status_messages.\n  Now getBrowserCharset is used to play nice with Five forms. Customized\n  setRedirect and getMainGlobals scripts have to be updated.\n\n- Profiles: All profiles are now registered by ZCML.\n\n- ZClasses: Removed unmaintained support for ZClasses.\n  Marked the 'initializeBases*' methods as deprecated.\n\n- Content: Added IFactory utilities for all content classes.\n  They are now used by default instead of the old constructor methods.\n\n- Content: All content classes are now registered by ZCML.\n  ContentInit is still used to register oldstyle constructors.\n\n- setup handlers: Removed support for CMF 1.5 CMFSetup profiles.\n\n- FactoryTypeInformation: Added support for Zope3 style factories.\n  If the 'product' property of a type info instance is empty the 'factory'\n  property is interpreted as an IFactory name.\n\n- ActionInformation: don't use a fixed set of properties for\n  ActionInformation. (http://www.zope.org/Collectors/CMF/232/)\n\n- CatalogTool: Use current executable's proxy roles, if any,\n  in place of user's roles when computing 'allowedRolesAndUsers' for\n  a query. (http://www.zope.org/Collectors/CMF/380)\n\n- FSFile: Added registration for 'txt' extension.\n\n- CMFCatalogAware: Added 'handleObjectEvent' subscriber.\n  This replaces the deprecated 'manage_afterAdd', 'manage_afterClone' and\n  'manage_beforeDelete' hooks.\n\n\nEarlier releases\n----------------\n\nFor a complete list of changes before version 2.1.0-alpha, see the HISTORY.txt\nfile on the CMF-2.1 branch:\nhttps://web.archive.org/web/20130123004606/http://svn.zope.org/CMF/branches/2.1/HISTORY.txt?view=auto\n", "##############################################################################\n#\n# Copyright (c) 2001 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" PortalFolder: CMF-enabled Folder objects.\n\"\"\"\n\nimport json\nimport re\n\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom AccessControl.SecurityManagement import getSecurityManager\nfrom Acquisition import aq_base\nfrom Acquisition import aq_inner\nfrom Acquisition import aq_parent\nfrom OFS.Folder import Folder\nfrom OFS.OrderSupport import OrderSupport\nfrom zope.component import getUtility\nfrom zope.component import queryUtility\nfrom zope.component.factory import Factory\nfrom zope.interface import implementer\n\nfrom .CMFCatalogAware import OpaqueItemManager\nfrom .DynamicType import DynamicType\nfrom .exceptions import AccessControl_Unauthorized\nfrom .exceptions import BadRequest\nfrom .exceptions import zExceptions_Unauthorized\nfrom .interfaces import IContentTypeRegistry\nfrom .interfaces import IFolderish\nfrom .interfaces import IMutableMinimalDublinCore\nfrom .interfaces import ISiteRoot\nfrom .interfaces import ITypesTool\nfrom .permissions import AddPortalContent\nfrom .permissions import AddPortalFolders\nfrom .permissions import DeleteObjects\nfrom .permissions import ListFolderContents\nfrom .permissions import ManagePortal\nfrom .permissions import ManageProperties\nfrom .permissions import View\nfrom .utils import _checkPermission\nfrom .utils import base64_decode\nfrom .utils import base64_encode\n\n\n@implementer(IFolderish, IMutableMinimalDublinCore)\nclass PortalFolderBase(DynamicType, OpaqueItemManager, Folder):\n\n    \"\"\"Base class for portal folder.\n    \"\"\"\n\n    security = ClassSecurityInfo()\n\n    description = ''\n\n    manage_options = (Folder.manage_options[:1]\n                      + ({'label': 'Components',\n                          'action': 'manage_components'},)\n                      + ({'label': 'Components Folder',\n                          'action': '++etc++site/manage_main'},)\n                      + Folder.manage_options[1:])\n\n    def __init__(self, id, title='', description=''):\n        self.id = id\n        self.title = title\n        self.description = description\n\n    #\n    #   'IMutableMinimalDublinCore' interface methods\n    #\n    @security.protected(View)\n    def Title(self):\n        \"\"\" Dublin Core Title element - resource name.\n        \"\"\"\n        return self.title\n\n    @security.protected(View)\n    def Description(self):\n        \"\"\" Dublin Core Description element - resource summary.\n        \"\"\"\n        return self.description\n\n    @security.protected(View)\n    def Type(self):\n        \"\"\" Dublin Core Type element - resource type.\n        \"\"\"\n        ti = self.getTypeInfo()\n        return ti is not None and ti.Title() or 'Unknown'\n\n    @security.protected(ManageProperties)\n    def setTitle(self, title):\n        \"\"\" Set Dublin Core Title element - resource name.\n        \"\"\"\n        self.title = title\n\n    @security.protected(ManageProperties)\n    def setDescription(self, description):\n        \"\"\" Set Dublin Core Description element - resource summary.\n        \"\"\"\n        self.description = description\n\n    #\n    #   other methods\n    #\n    @security.protected(ManageProperties)\n    def edit(self, title='', description=''):\n        \"\"\"\n        Edit the folder title (and possibly other attributes later)\n        \"\"\"\n        self.setTitle(title)\n        self.setDescription(description)\n        # BBB: for ICatalogAware subclasses\n        if getattr(self, 'reindexObject', None) is not None:\n            self.reindexObject()\n\n    @security.public\n    def allowedContentTypes(self):\n        \"\"\"\n            List type info objects for types which can be added in\n            this folder.\n        \"\"\"\n        ttool = getUtility(ITypesTool)\n        myType = ttool.getTypeInfo(self)\n        result = ttool.listTypeInfo()\n\n        if myType is not None:\n            return [t for t in result if myType.allowType(t.getId()) and\n                    t.isConstructionAllowed(self)]\n\n        return [t for t in result if t.isConstructionAllowed(self)]\n\n    def _filteredItems(self, ids, filt):\n        \"\"\"\n            Apply filter, a mapping, to child objects indicated by 'ids',\n            returning a sequence of (id, obj) tuples.\n        \"\"\"\n        # Restrict allowed content types\n        if filt is None:\n            filt = {}\n        else:\n            # We'll modify it, work on a copy.\n            filt = filt.copy()\n        pt = filt.get('portal_type', [])\n        if isinstance(pt, str):\n            pt = [pt]\n        ttool = getUtility(ITypesTool)\n        allowed_types = ttool.listContentTypes()\n        if not pt:\n            pt = allowed_types\n        else:\n            pt = [t for t in pt if t in allowed_types]\n        if not pt:\n            # After filtering, no types remain, so nothing should be\n            # returned.\n            return []\n        filt['portal_type'] = pt\n\n        query = ContentFilter(**filt)\n        result = []\n        append = result.append\n        get = self._getOb\n        for id in ids:\n            obj = get(id)\n            if query(obj):\n                append((id, obj))\n        return result\n\n    #\n    #   'IFolderish' interface methods\n    #\n    @security.public\n    def contentItems(self, filter=None):\n        # List contentish and folderish sub-objects and their IDs.\n        # (method is without docstring to disable publishing)\n        #\n        ids = self.objectIds()\n        return self._filteredItems(ids, filter)\n\n    @security.public\n    def contentIds(self, filter=None):\n        # List IDs of contentish and folderish sub-objects.\n        # (method is without docstring to disable publishing)\n        #\n        return [item[0] for item in self.contentItems(filter)]\n\n    @security.public\n    def contentValues(self, filter=None):\n        # List contentish and folderish sub-objects.\n        # (method is without docstring to disable publishing)\n        #\n        return [item[1] for item in self.contentItems(filter)]\n\n    @security.protected(ListFolderContents)\n    def listFolderContents(self, contentFilter=None):\n        \"\"\" List viewable contentish and folderish sub-objects.\n        \"\"\"\n        fc_list = []\n        for id, obj in self.contentItems(contentFilter):\n            # validate() can either raise Unauthorized or return 0 to\n            # mean unauthorized.\n            try:\n                if getSecurityManager().validate(self, self, id, obj):\n                    fc_list.append(obj)\n            except zExceptions_Unauthorized:  # Catch *all* Unauths!\n                pass\n        return fc_list\n\n    #\n    #   webdav Resource method\n    #\n\n    # protected by 'WebDAV access'\n    def listDAVObjects(self):\n        # List sub-objects for PROPFIND requests.\n        # (method is without docstring to disable publishing)\n        #\n        if _checkPermission(ManagePortal, self):\n            return self.objectValues()\n        else:\n            return self.listFolderContents()\n\n    #\n    #   other methods\n    #\n    @security.public\n    def encodeFolderFilter(self, REQUEST):\n        \"\"\"\n            Parse cookie string for using variables in dtml.\n        \"\"\"\n        folder_filter = {}\n        for key, value in REQUEST.items():\n            if key[:10] == 'filter_by_':\n                folder_filter[key[10:]] = value\n        encoded = base64_encode(json.dumps(folder_filter).encode())\n        encoded = b''.join(encoded.split(b'\\n'))\n        return encoded\n\n    @security.public\n    def decodeFolderFilter(self, encoded):\n        \"\"\" Parse cookie string for using variables in dtml.\n\n        This is a public method and the input is not under our control.\n        To prevent a DOS this method will refuse to decode data that seems\n        conspicuously large.\n        \"\"\"\n        folder_filter = {}\n        if encoded and len(encoded) < 1000:\n            folder_filter.update(json.loads(base64_decode(encoded)))\n        return folder_filter\n\n    def content_type(self):\n        \"\"\"\n            WebDAV needs this to do the Right Thing (TM).\n        \"\"\"\n        return None\n\n    def PUT_factory(self, name, typ, body):\n        \"\"\" Factory for PUT requests to objects which do not yet exist.\n\n        Used by NullResource.PUT.\n\n        Returns -- Bare and empty object of the appropriate type (or None, if\n        we don't know what to do)\n        \"\"\"\n        ctr = queryUtility(IContentTypeRegistry)\n        if ctr is None:\n            return None\n\n        typeObjectName = ctr.findTypeName(name, typ, body)\n        if typeObjectName is None:\n            return None\n\n        self.invokeFactory(typeObjectName, name)\n\n        # invokeFactory does too much, so the object has to be removed again\n        obj = aq_base(self._getOb(name))\n        self._delObject(name)\n        return obj\n\n    @security.protected(AddPortalContent)\n    def invokeFactory(self, type_name, id, RESPONSE=None, *args, **kw):\n        \"\"\" Invokes the portal_types tool.\n        \"\"\"\n        ttool = getUtility(ITypesTool)\n        myType = ttool.getTypeInfo(self)\n\n        if myType is not None:\n            if not myType.allowType(type_name):\n                raise ValueError('Disallowed subobject type: %s' % type_name)\n\n        return ttool.constructContent(type_name, self, id, RESPONSE,\n                                      *args, **kw)\n\n    @security.protected(AddPortalContent)\n    def checkIdAvailable(self, id):\n        try:\n            self._checkId(id)\n        except BadRequest:\n            return False\n        else:\n            return True\n\n    def MKCOL_handler(self, id, REQUEST=None, RESPONSE=None):\n        \"\"\"\n            Handle WebDAV MKCOL.\n        \"\"\"\n        self.manage_addFolder(id=id, title='')\n\n    def _checkId(self, id, allow_dup=0):\n        PortalFolderBase.inheritedAttribute('_checkId')(self, id, allow_dup)\n\n        if allow_dup:\n            return\n\n        # FIXME: needed to allow index_html for join code\n        if id == 'index_html':\n            return\n\n        # Another exception: Must allow \"syndication_information\" to enable\n        # Syndication...\n        if id == 'syndication_information':\n            return\n\n        # IDs starting with '@@' are reserved for views.\n        if id[:2] == '@@':\n            raise BadRequest('The id \"%s\" is invalid because it begins with '\n                             '\"@@\".' % id)\n\n        # This code prevents people other than the portal manager from\n        # overriding skinned names and tools.\n        if not getSecurityManager().checkPermission(ManagePortal, self):\n            ob = aq_inner(self)\n            while ob is not None:\n                if ISiteRoot.providedBy(ob):\n                    break\n                ob = aq_parent(ob)\n\n            if ob is not None:\n                # If the portal root has a non-contentish object by this name,\n                # don't allow an override.\n                if hasattr(ob, id) and \\\n                   id not in ob.contentIds() and \\\n                   not id.startswith('.'):\n                    raise BadRequest('The id \"%s\" is reserved.' % id)\n            # Don't allow ids used by Method Aliases.\n            ti = self.getTypeInfo()\n            if ti and ti.queryMethodID(id, context=self):\n                raise BadRequest('The id \"%s\" is reserved.' % id)\n        # Otherwise we're ok.\n\n    def _verifyObjectPaste(self, object, validate_src=1):\n        # This assists the version in OFS.CopySupport.\n        # It enables the clipboard to function correctly\n        # with objects created by a multi-factory.\n        mt = getattr(object, '__factory_meta_type__', None)\n        meta_types = getattr(self, 'all_meta_types', None)\n\n        if mt is not None and meta_types is not None:\n            mt_permission = None\n\n            if callable(meta_types):\n                meta_types = meta_types()\n\n            for d in meta_types:\n                if d['name'] == mt:\n                    mt_permission = d.get('permission')\n                    break\n\n            if mt_permission is not None:\n                sm = getSecurityManager()\n\n                if sm.checkPermission(mt_permission, self):\n                    if validate_src:\n                        # Ensure the user is allowed to access the object on\n                        # the clipboard.\n                        parent = aq_parent(aq_inner(object))\n\n                        if not sm.validate(None, parent, None, object):\n                            raise AccessControl_Unauthorized(object.getId())\n\n                        if validate_src == 2:  # moving\n                            if not sm.checkPermission(DeleteObjects, parent):\n                                raise AccessControl_Unauthorized('Delete not '\n                                                                 'allowed.')\n                else:\n                    raise AccessControl_Unauthorized(\n                            'You do not possess the '\n                            '%r permission in the context of the container '\n                            'into which you are pasting, thus you are not '\n                            'able to perform this operation.' % mt_permission)\n            else:\n                raise AccessControl_Unauthorized(\n                        'The object %r does not '\n                        'support this operation.' % object.getId())\n        else:\n            # Call OFS' _verifyObjectPaste if necessary\n            PortalFolderBase.inheritedAttribute(\n                '_verifyObjectPaste')(self, object, validate_src)\n\n        # Finally, check allowed content types\n        if hasattr(aq_base(object), 'getPortalTypeName'):\n\n            type_name = object.getPortalTypeName()\n\n            if type_name is not None:\n\n                ttool = getUtility(ITypesTool)\n                myType = ttool.getTypeInfo(self)\n\n                if myType is not None and not myType.allowType(type_name):\n                    raise ValueError('Disallowed subobject type: %s' %\n                                     type_name)\n\n                # Check for workflow guards\n                objType = ttool.getTypeInfo(type_name)\n                if objType is not None and \\\n                   not objType._checkWorkflowAllowed(self):\n                    raise ValueError('Pasting not allowed in this workflow')\n\n    security.setPermissionDefault(AddPortalContent, ('Owner', 'Manager'))\n\n    @security.protected(AddPortalFolders)\n    def manage_addFolder(self, id, title='', REQUEST=None):\n        \"\"\" Add a new folder-like object with id *id*.\n\n        IF present, use the parent object's 'mkdir' alias; otherwise, just add\n        a PortalFolder.\n        \"\"\"\n        ti = self.getTypeInfo()\n        method_id = ti and ti.queryMethodID('mkdir', context=self)\n        if method_id:\n            # call it\n            getattr(self, method_id)(id=id)\n        else:\n            self.invokeFactory(type_name='Folder', id=id)\n\n        ob = self._getOb(id)\n        ob.setTitle(title)\n        try:\n            ob.reindexObject()\n        except AttributeError:\n            pass\n\n        if REQUEST is not None:\n            return self.manage_main(self, REQUEST, update_menu=1)\n\n\nInitializeClass(PortalFolderBase)\n\n\nclass PortalFolder(OrderSupport, PortalFolderBase):\n\n    \"\"\"Implements portal content management, but not UI details.\n    \"\"\"\n\n    portal_type = 'Folder'\n\n    security = ClassSecurityInfo()\n\n    manage_options = (OrderSupport.manage_options +\n                      PortalFolderBase.manage_options[1:])\n\n    @security.protected(AddPortalFolders)\n    def manage_addPortalFolder(self, id, title='', REQUEST=None):\n        \"\"\"Add a new PortalFolder object with id *id*.\n        \"\"\"\n        ob = PortalFolder(id, title)\n        self._setObject(id, ob, suppress_events=True)\n        if REQUEST is not None:\n            return self.folder_contents(  # XXX: ick!\n                self, REQUEST, portal_status_message='Folder added')\n\n\nInitializeClass(PortalFolder)\n\nPortalFolderFactory = Factory(PortalFolder)\n\nmanage_addPortalFolder = PortalFolder.manage_addPortalFolder\n\n\nclass ContentFilter:\n\n    \"\"\"Represent a predicate against a content object's metadata.\n    \"\"\"\n\n    MARKER = []\n    filterSubject = []\n\n    def __init__(self, Title=MARKER, Creator=MARKER, Subject=MARKER,\n                 Description=MARKER, created=MARKER, created_usage='range:min',\n                 modified=MARKER, modified_usage='range:min', Type=MARKER,\n                 portal_type=MARKER, **Ignored):\n\n        self.predicates = []\n        self.description = []\n\n        if Title is not self.MARKER:\n            self.predicates.append(lambda x, pat=re.compile(Title):\n                                   pat.search(x.Title()))\n            self.description.append('Title: %s' % Title)\n\n        if Creator and Creator is not self.MARKER:\n            self.predicates.append(lambda x, creator=Creator:\n                                   creator in x.listCreators())\n            self.description.append('Creator: %s' % Creator)\n\n        if Subject and Subject is not self.MARKER:\n            self.filterSubject = Subject\n            self.predicates.append(self.hasSubject)\n            self.description.append('Subject: %s' % ', '.join(Subject))\n\n        if Description is not self.MARKER:\n            self.predicates.append(lambda x, pat=re.compile(Description):\n                                   pat.search(x.Description()))\n            self.description.append('Description: %s' % Description)\n\n        if created is not self.MARKER:\n            if created_usage == 'range:min':\n                self.predicates.append(lambda x, cd=created:\n                                       cd <= x.created())\n                self.description.append('Created since: %s' % created)\n            if created_usage == 'range:max':\n                self.predicates.append(lambda x, cd=created:\n                                       cd >= x.created())\n                self.description.append('Created before: %s' % created)\n\n        if modified is not self.MARKER:\n            if modified_usage == 'range:min':\n                self.predicates.append(lambda x, md=modified:\n                                       md <= x.modified())\n                self.description.append('Modified since: %s' % modified)\n            if modified_usage == 'range:max':\n                self.predicates.append(lambda x, md=modified:\n                                       md >= x.modified())\n                self.description.append('Modified before: %s' % modified)\n\n        if Type:\n            if isinstance(Type, str):\n                Type = [Type]\n            self.predicates.append(lambda x, Type=Type: x.Type() in Type)\n            self.description.append('Type: %s' % ', '.join(Type))\n\n        if portal_type and portal_type is not self.MARKER:\n            if isinstance(portal_type, str):\n                portal_type = [portal_type]\n            self.predicates.append(lambda x, pt=portal_type:\n                                   hasattr(aq_base(x), 'getPortalTypeName')\n                                   and x.getPortalTypeName() in pt)\n            self.description.append('Portal Type: %s' % ', '.join(portal_type))\n\n    def hasSubject(self, obj):\n        \"\"\"\n        Converts Subject string into a List for content filter view.\n        \"\"\"\n        for sub in obj.Subject():\n            if sub in self.filterSubject:\n                return 1\n        return 0\n\n    def __call__(self, content):\n\n        for predicate in self.predicates:\n\n            try:\n                if not predicate(content):\n                    return 0\n            except (AttributeError, KeyError, IndexError, ValueError):\n                # predicates are *not* allowed to throw exceptions\n                return 0\n\n        return 1\n\n    def __str__(self):\n        \"\"\"\n            Return a stringified description of the filter.\n        \"\"\"\n        return '; '.join(self.description)\n", "##############################################################################\n#\n# Copyright (c) 2001 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\" Unit tests for PortalFolder module.\n\"\"\"\n\nimport unittest\n\nimport transaction\nfrom AccessControl import SecurityManager\nfrom AccessControl import Unauthorized\nfrom AccessControl.SecurityManagement import newSecurityManager\nfrom Acquisition import Implicit\nfrom Acquisition import aq_base\nfrom DateTime import DateTime\nfrom OFS.Image import manage_addFile\nfrom zope.component import getSiteManager\nfrom zope.component.interfaces import IFactory\nfrom zope.interface import implementer\nfrom zope.interface.verify import verifyClass\n\nfrom ..exceptions import BadRequest\nfrom ..interfaces import ICatalogTool\nfrom ..interfaces import ITypesTool\nfrom ..interfaces import IWorkflowTool\nfrom ..testing import ConformsToFolder\nfrom ..testing import TraversingEventZCMLLayer\nfrom ..TypesTool import FactoryTypeInformation as FTI\nfrom ..TypesTool import TypesTool\nfrom ..WorkflowTool import WorkflowTool\nfrom .base.dummy import DummyContent\nfrom .base.dummy import DummyFactoryDispatcher\nfrom .base.dummy import DummySite\nfrom .base.dummy import DummyUserFolder\nfrom .base.testcase import SecurityTest\nfrom .base.tidata import FTIDATA_CMF\nfrom .base.tidata import FTIDATA_DUMMY\n\n\ndef extra_meta_types():\n    return [{'name': 'Dummy', 'action': 'manage_addFolder',\n             'permission': 'View'}]\n\n\n@implementer(ICatalogTool)\nclass DummyCatalogTool:\n\n    def __init__(self):\n        self.paths = []\n        self.ids = []\n\n    def indexObject(self, object):\n        self.paths.append('/'.join(object.getPhysicalPath()))\n        self.ids.append(object.getId())\n\n    def unindexObject(self, object):\n        self.paths.remove('/'.join(object.getPhysicalPath()))\n        self.ids.append(object.getId())\n\n    def reindexObject(self, object):\n        pass\n\n    def __len__(self):\n        return len(self.paths)\n\n\ndef has_path(catalog, path):\n    if isinstance(path, tuple):\n        path = '/'.join(path)\n    return path in catalog.paths\n\n\ndef has_id(catalog, id):\n    return id in catalog.ids\n\n\nclass PortalFolderFactoryTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n    _PORTAL_TYPE = 'Test Folder'\n\n    def _getTargetObject(self):\n        from ..PortalFolder import PortalFolderFactory\n\n        return PortalFolderFactory\n\n    def setUp(self):\n        from ..PortalFolder import PortalFolder\n\n        SecurityTest.setUp(self)\n        self.site = DummySite('site').__of__(self.app)\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n\n        self.ttool = ttool = TypesTool()\n        ttool._setObject(self._PORTAL_TYPE,\n                         FTI(id=self._PORTAL_TYPE,\n                             title='Folder or Directory',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder',\n                             filter_content_types=0))\n        ttool._setObject('Dummy Content', FTI(**FTIDATA_DUMMY[0].copy()))\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n        sm.registerUtility(self._getTargetObject(), IFactory, 'cmf.folder')\n\n        self.f = self.site._setObject('container', PortalFolder('container'))\n        self.f._setPortalTypeName(self._PORTAL_TYPE)\n\n    def test_invokeFactory(self):\n        f = self.f\n        self.assertFalse('foo' in f.objectIds())\n\n        f.manage_addProduct = {'FooProduct': DummyFactoryDispatcher(f)}\n        f.invokeFactory(type_name='Dummy Content', id='foo')\n\n        self.assertTrue('foo' in f.objectIds())\n        foo = f.foo\n        self.assertEqual(foo.getId(), 'foo')\n        self.assertEqual(foo.getPortalTypeName(), 'Dummy Content')\n        self.assertEqual(foo.Type(), 'Dummy Content Title')\n\n    def test_invokeFactory_disallowed_type(self):\n        f = self.f\n        ftype = getattr(self.ttool, self._PORTAL_TYPE)\n        ftype.filter_content_types = 1\n        self.assertRaises(ValueError,\n                          f.invokeFactory, self._PORTAL_TYPE, 'sub')\n\n        ftype.allowed_content_types = (self._PORTAL_TYPE,)\n        f.invokeFactory(self._PORTAL_TYPE, id='sub')\n        self.assertTrue('sub' in f.objectIds())\n        self.assertRaises(ValueError, f.invokeFactory, 'Dummy Content', 'foo')\n\n\nclass PortalFolderTests(ConformsToFolder, unittest.TestCase):\n\n    def _getTargetClass(self):\n        from ..PortalFolder import PortalFolder\n\n        return PortalFolder\n\n    def test_interfaces(self):\n        from OFS.interfaces import IOrderedContainer\n\n        verifyClass(IOrderedContainer, self._getTargetClass())\n\n    def test_FolderFilter(self):\n        folder = self._getTargetClass()('test_id')\n\n        # No filter\n        request = {}\n        encoded_filter = folder.encodeFolderFilter(request)\n        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})\n\n        # Simple filter\n        request = {'filter_by_id': 'foobar'}\n        encoded_filter = folder.encodeFolderFilter(request)\n        self.assertEqual(folder.decodeFolderFilter(encoded_filter),\n                         {'id': 'foobar'})\n\n        # Multiple filters\n        request = {'filter_by_id': 'foobar',\n                   'filter_by_title': 'baz'}\n        encoded_filter = folder.encodeFolderFilter(request)\n        self.assertEqual(folder.decodeFolderFilter(encoded_filter),\n                         {'id': 'foobar', 'title': 'baz'})\n\n        # Non-filter request values are ignored\n        request = {'filter_by_id': 'foobar', 'somekey': 'somevalue'}\n        encoded_filter = folder.encodeFolderFilter(request)\n        self.assertEqual(folder.decodeFolderFilter(encoded_filter),\n                         {'id': 'foobar'})\n\n        # Conspicuously large input values to the decode operation\n        # are ignored to prevent a DOS\n        encoded_filter = 'x' * 2000\n        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})\n\n\nclass PortalFolderSecurityTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def _getTargetClass(self):\n        from ..PortalFolder import PortalFolder\n\n        return PortalFolder\n\n    def _makeOne(self, id, *args, **kw):\n        return self.site._setObject(id,\n                                    self._getTargetClass()(id, *args, **kw))\n\n    def setUp(self):\n        SecurityTest.setUp(self)\n        self.site = DummySite('site').__of__(self.app)\n\n    def test_contents_methods(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n\n        ttool = TypesTool()\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        f = self._makeOne('foo')\n        self.assertEqual(f.objectValues(), [])\n        self.assertEqual(f.contentIds(), [])\n        self.assertEqual(f.contentItems(), [])\n        self.assertEqual(f.contentValues(), [])\n        self.assertEqual(f.listFolderContents(), [])\n        self.assertEqual(f.listDAVObjects(), [])\n\n        f._setObject('sub1', DummyContent('sub1'))\n        self.assertEqual(f.objectValues(), [f.sub1])\n        self.assertEqual(f.contentIds(), [])\n        self.assertEqual(f.contentItems(), [])\n        self.assertEqual(f.contentValues(), [])\n        self.assertEqual(f.listFolderContents(), [])\n        self.assertEqual(f.listDAVObjects(), [f.sub1])\n\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        self.assertEqual(f.objectValues(), [f.sub1])\n        self.assertEqual(f.contentIds(), ['sub1'])\n        self.assertEqual(f.contentItems(), [('sub1', f.sub1)])\n        self.assertEqual(f.contentValues(), [f.sub1])\n        self.assertEqual(f.listFolderContents(), [f.sub1])\n        self.assertEqual(f.listDAVObjects(), [f.sub1])\n\n        f._setObject('hidden_sub2', DummyContent('hidden_sub2'))\n        self.assertEqual(f.objectValues(), [f.sub1, f.hidden_sub2])\n        self.assertEqual(f.contentIds(), ['sub1', 'hidden_sub2'])\n        self.assertEqual(f.contentItems(), [('sub1', f.sub1),\n                                            ('hidden_sub2', f.hidden_sub2)])\n        self.assertEqual(f.contentValues(), [f.sub1, f.hidden_sub2])\n        self.assertEqual(f.listFolderContents(), [f.sub1])\n        self.assertEqual(f.listDAVObjects(), [f.sub1, f.hidden_sub2])\n\n    def test_deletePropagation(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        foo = DummyContent('foo')\n        foo.reset()\n        self.assertFalse(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n        test._setObject('foo', foo)\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n        foo.reset()\n        test._delObject('foo')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n\n        foo.reset()\n        test._setObject('foo', foo)\n        test._delOb('foo')    # doesn't propagate\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n\n    def test_manageDelObjects(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        foo = DummyContent('foo')\n\n        test._setObject('foo', foo)\n        foo.reset()\n        test.manage_delObjects(ids=['foo'])\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n\n    def test_catalogUnindexAndIndex(self):\n        #\n        # Test is a new object does get cataloged upon _setObject\n        # and uncataloged upon manage_deleteObjects\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        ctool = DummyCatalogTool()\n        self.assertEqual(len(ctool), 0)\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(TypesTool(), ITypesTool)\n\n        test._setObject('foo', DummyContent('foo', catalog=1))\n        foo = test.foo\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n        self.assertEqual(len(ctool), 1)\n\n        foo.reset()\n        test._delObject('foo')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n        self.assertEqual(len(ctool), 0)\n\n    def test_portalfolder_cataloging(self):\n        #\n        # Test to ensure a portal folder itself is *not* cataloged upon\n        # instantiation (Tracker issue 309)\n        #\n        ctool = DummyCatalogTool()\n        wtool = WorkflowTool()\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(wtool, IWorkflowTool)\n\n        test = self._makeOne('test')\n        wtool.notifyCreated(test)\n        self.assertEqual(len(ctool), 0)\n\n    def test_tracker261(self):\n        #\n        #   Tracker issue #261 says that content in a deleted folder\n        #   is not being uncatalogued.  Try creating a subfolder with\n        #   content object, and test.\n        #\n        from ..PortalFolder import PortalFolder\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        ctool = DummyCatalogTool()\n        getSiteManager().registerUtility(ctool, ICatalogTool)\n        self.assertEqual(len(ctool), 0)\n\n        test._setObject('sub', PortalFolder('sub', ''))\n        sub = test.sub\n\n        sub._setObject('foo', DummyContent('foo', catalog=1))\n        foo = sub.foo\n\n        self.assertTrue(foo.after_add_called)\n        self.assertFalse(foo.before_delete_called)\n        self.assertEqual(len(ctool), 1)\n\n        foo.reset()\n        test._delObject('sub')\n        self.assertFalse(foo.after_add_called)\n        self.assertTrue(foo.before_delete_called)\n        self.assertEqual(len(ctool), 0)\n\n    def test_manageAddFolder(self):\n        #\n        #   Does MKDIR/MKCOL intercept work?\n        #\n        from ..PortalFolder import PortalFolder\n        from ..PortalFolder import PortalFolderFactory\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n\n        ttool = TypesTool()\n        ttool._setObject('Folder',\n                         FTI(id='Folder',\n                             title='Folder or Directory',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder',\n                             filter_content_types=0))\n        ttool._setObject('Grabbed',\n                         FTI('Grabbed',\n                             title='Grabbed Content',\n                             meta_type=PortalFolder.meta_type,\n                             factory='cmf.folder'))\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n        sm.registerUtility(PortalFolderFactory, IFactory, 'cmf.folder')\n\n        # First, test default behavior\n        test.manage_addFolder(id='simple', title='Simple')\n        self.assertEqual(test.simple.getPortalTypeName(), 'Folder')\n        self.assertEqual(test.simple.Type(), 'Folder or Directory')\n        self.assertEqual(test.simple.getId(), 'simple')\n        self.assertEqual(test.simple.Title(), 'Simple')\n\n        # Now, test overridden behavior\n        ttool.Folder.setMethodAliases({'mkdir': 'grabbed'})\n\n        class Grabbed:\n\n            _grabbed_with = None\n\n            def __init__(self, context):\n                self._context = context\n\n            def __call__(self, id):\n                self._grabbed_with = id\n                self._context._setOb(id, PortalFolder(id))\n                self._context._getOb(id)._setPortalTypeName('Grabbed')\n\n        self.app.grabbed = Grabbed(test)\n\n        test.manage_addFolder(id='indirect', title='Indirect')\n        self.assertEqual(test.indirect.getPortalTypeName(), 'Grabbed')\n        self.assertEqual(test.indirect.Type(), 'Grabbed Content')\n        self.assertEqual(test.indirect.getId(), 'indirect')\n        self.assertEqual(test.indirect.Title(), 'Indirect')\n\n    def test_contentPasteAllowedTypes(self):\n        #\n        #   _verifyObjectPaste() should honor allowed content types\n        #\n        ttool = TypesTool()\n        getSiteManager().registerUtility(ttool, ITypesTool)\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        ttool._setObject('Folder', FTI(**fti))\n        sub1 = self._makeOne('sub1')\n        sub1._setObject('dummy', DummyContent('dummy'))\n        sub2 = self._makeOne('sub2')\n        sub2.all_meta_types = extra_meta_types()\n\n        # Allow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=False)\n\n        # Copy/paste should work fine\n        cookie = sub1.manage_copyObjects(ids=['dummy'])\n        sub2.manage_pasteObjects(cookie)\n\n        # Disallow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=True)\n\n        # Now copy/paste should raise a ValueError\n        cookie = sub1.manage_copyObjects(ids=('dummy',))\n        self.assertRaises(ValueError, sub2.manage_pasteObjects, cookie)\n\n    def test_contentPasteFollowsWorkflowGuards(self):\n        #\n        # Copy/Paste should obey workflow guards\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ttool = TypesTool()\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        ttool._setObject('Folder', FTI(**fti))\n        folder = self._makeOne('folder', 'Folder')\n        content = self._makeOne('content')\n        folder._setObject('content', content)\n        sm = getSiteManager()\n        sm.registerUtility(ttool, ITypesTool)\n\n        # Allow adding of Dummy Content\n        ttool.Folder.manage_changeProperties(filter_content_types=False)\n\n        # Copy/paste verification should work fine\n        folder._verifyObjectPaste(content)\n\n        # Add a workflow with a blocking guard\n        # Based on TypesTools tests\n        class DummyWorkflow:\n\n            _allow = False\n\n            def allowCreate(self, container, type_id):\n                return self._allow\n\n        class DummyWorkflowTool:\n\n            def __init__(self):\n                self._workflows = [DummyWorkflow()]\n\n            def getWorkflowsFor(self, type_id):\n                return self._workflows\n\n        # Now copy/paste verification should raise a ValueError\n        sm.registerUtility(DummyWorkflowTool(), IWorkflowTool)\n        self.assertRaises(ValueError, folder._verifyObjectPaste, content)\n\n    def test_setObjectRaisesBadRequest(self):\n        #\n        #   _setObject() should raise BadRequest on duplicate id\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertRaises(BadRequest, test._setObject, 'foo',\n                          DummyContent('foo'))\n\n    def test__checkId_Duplicate(self):\n        #\n        #   _checkId() should raise BadRequest on duplicate id\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertRaises(BadRequest, test._checkId, 'foo')\n\n    def test__checkId_PortalRoot(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        test._checkId('acl_users')\n        newSecurityManager(None, acl_users.user_foo)\n        self.assertRaises(BadRequest, test._checkId, 'acl_users')\n\n    def test__checkId_MethodAlias(self):\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setPortalTypeName('Dummy Content 15')\n        ttool = TypesTool()\n        ttool._setObject('Dummy Content 15', FTI(**FTIDATA_CMF[0]))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        test._checkId('view')\n        newSecurityManager(None, acl_users.user_foo)\n        self.assertRaises(BadRequest, test._checkId, 'view')\n\n    def test__checkId_starting_with_dot(self):\n        #\n        # doted prefixed names at the root of the portal can be overriden\n        #\n\n        # Create a .foo at the root\n        self.site._setObject('.foo', DummyContent('.foo'))\n\n        # Create a sub-folder\n        sub = self._makeOne('sub')\n\n        # It should be possible to create another .foo object in the\n        # sub-folder\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.user_foo)\n\n        self.assertTrue(sub.checkIdAvailable('.foo'))\n\n    def test__checkId_Five(self):\n        test = self._makeOne('test')\n        self.assertRaises(BadRequest, test._checkId, '@@view')\n\n    def test_checkIdAvailableCatchesBadRequest(self):\n        #\n        #   checkIdAvailable() should catch BadRequest\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        test = self._makeOne('test')\n        test._setObject('foo', DummyContent('foo'))\n        self.assertFalse(test.checkIdAvailable('foo'))\n\n\nclass PortalFolderMoveTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def setUp(self):\n        SecurityTest.setUp(self)\n        self.app._setObject('site', DummySite('site'))\n        self.site = self.app.site\n\n    def _makeOne(self, id, *args, **kw):\n        from ..PortalFolder import PortalFolder\n\n        return self.site._setObject(id, PortalFolder(id, *args, **kw))\n\n    def test_folderMove(self):\n        #\n        #   Does the catalog stay synched when folders are moved?\n        #\n        from ..PortalFolder import PortalFolder\n\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ctool = DummyCatalogTool()\n        sm = getSiteManager()\n        sm.registerUtility(TypesTool(), ITypesTool)\n        sm.registerUtility(ctool, ICatalogTool)\n        self.assertEqual(len(ctool), 0)\n\n        folder = self._makeOne('folder')\n        folder._setObject('sub', PortalFolder('sub', ''))\n        folder.sub._setObject('foo', DummyContent('foo', catalog=1))\n        self.assertEqual(len(ctool), 1)\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/sub/foo'))\n\n        transaction.savepoint(optimistic=True)\n        folder.manage_renameObject(id='sub', new_id='new_sub')\n        self.assertEqual(len(ctool), 1)\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/new_sub/foo'))\n\n        folder._setObject('bar', DummyContent('bar', catalog=1))\n        self.assertEqual(len(ctool), 2)\n        self.assertTrue(has_id(ctool, 'bar'))\n        self.assertTrue(has_path(ctool, '/bar/site/folder/bar'))\n\n        folder._setObject('sub2', PortalFolder('sub2', ''))\n        sub2 = folder.sub2\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub2.all_meta_types = []\n        sub2.all_meta_types.extend(sub2.all_meta_types)\n        sub2.all_meta_types.extend(extra_meta_types())\n\n        transaction.savepoint(optimistic=True)\n        cookie = folder.manage_cutObjects(ids=['bar'])\n        sub2.manage_pasteObjects(cookie)\n\n        self.assertTrue(has_id(ctool, 'foo'))\n        self.assertTrue(has_id(ctool, 'bar'))\n        self.assertEqual(len(ctool), 2)\n        self.assertTrue(has_path(ctool, '/bar/site/folder/sub2/bar'))\n\n    def test_contentPaste(self):\n        #\n        #   Does copy / paste work?\n        #\n        acl_users = self.site._setObject('acl_users', DummyUserFolder())\n        newSecurityManager(None, acl_users.all_powerful_Oz)\n        ctool = DummyCatalogTool()\n        ttool = TypesTool()\n        fti = FTIDATA_DUMMY[0].copy()\n        ttool._setObject('Dummy Content', FTI(**fti))\n        sub1 = self._makeOne('sub1')\n        sub2 = self._makeOne('sub2')\n        sub3 = self._makeOne('sub3')\n        self.assertEqual(len(ctool), 0)\n        sm = getSiteManager()\n        sm.registerUtility(ctool, ICatalogTool)\n        sm.registerUtility(ttool, ITypesTool)\n\n        sub1._setObject('dummy', DummyContent('dummy', catalog=1))\n        self.assertTrue('dummy' in sub1.objectIds())\n        self.assertTrue('dummy' in sub1.contentIds())\n        self.assertFalse('dummy' in sub2.objectIds())\n        self.assertFalse('dummy' in sub2.contentIds())\n        self.assertFalse('dummy' in sub3.objectIds())\n        self.assertFalse('dummy' in sub3.contentIds())\n        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))\n\n        cookie = sub1.manage_copyObjects(ids=('dummy',))\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub2.all_meta_types = []\n        sub2.all_meta_types.extend(sub2.all_meta_types)\n        sub2.all_meta_types.extend(extra_meta_types())\n        sub2.manage_pasteObjects(cookie)\n        self.assertTrue('dummy' in sub1.objectIds())\n        self.assertTrue('dummy' in sub1.contentIds())\n        self.assertTrue('dummy' in sub2.objectIds())\n        self.assertTrue('dummy' in sub2.contentIds())\n        self.assertFalse('dummy' in sub3.objectIds())\n        self.assertFalse('dummy' in sub3.contentIds())\n        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))\n\n        transaction.savepoint(optimistic=True)\n        cookie = sub1.manage_cutObjects(ids=('dummy',))\n        # Waaa! force sub2 to allow paste of Dummy object.\n        sub3.all_meta_types = []\n        sub3.all_meta_types.extend(sub3.all_meta_types)\n        sub3.all_meta_types.extend(extra_meta_types())\n        sub3.manage_pasteObjects(cookie)\n        self.assertFalse('dummy' in sub1.objectIds())\n        self.assertFalse('dummy' in sub1.contentIds())\n        self.assertTrue('dummy' in sub2.objectIds())\n        self.assertTrue('dummy' in sub2.contentIds())\n        self.assertTrue('dummy' in sub3.objectIds())\n        self.assertTrue('dummy' in sub3.contentIds())\n        self.assertFalse(has_path(ctool, '/bar/site/sub1/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))\n        self.assertTrue(has_path(ctool, '/bar/site/sub3/dummy'))\n\n\nclass ContentFilterTests(unittest.TestCase):\n\n    def setUp(self):\n        self.dummy = DummyContent('Dummy')\n\n    def test_empty(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter()\n        dummy = self.dummy\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = [_f for _f in desc.split('; ') if _f]\n        self.assertFalse(lines)\n\n    def test_Type(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Type='foo')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        cfilter = ContentFilter(Type='Dummy Content Title')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Type: Dummy Content Title')\n\n        cfilter = ContentFilter(Type=('foo', 'bar'))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        cfilter = ContentFilter(Type=('Dummy Content Title', 'something else'))\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Type: Dummy Content Title, something else')\n\n    def test_portal_type(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(portal_type='some_pt')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'asdf'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'some_ptyyy'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'xxxsome_ptyyy'\n        self.assertFalse(cfilter(dummy))\n        dummy.portal_type = 'some_pt'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Portal Type: some_pt')\n\n    def test_Title(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Title='foo')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.title = 'asdf'\n        self.assertFalse(cfilter(dummy))\n        dummy.title = 'foolish'\n        self.assertTrue(cfilter(dummy))\n        dummy.title = 'ohsofoolish'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Title: foo')\n\n    def test_Creator(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Creator='moe')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.creators = ('curly',)\n        self.assertFalse(cfilter(dummy))\n        dummy.creators = ('moe',)\n        self.assertTrue(cfilter(dummy))\n        dummy.creators = ('moe', 'curly')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Creator: moe')\n\n    def test_Description(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Description='funny')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.description = 'sad'\n        self.assertFalse(cfilter(dummy))\n        dummy.description = 'funny'\n        self.assertTrue(cfilter(dummy))\n        dummy.description = 'it is funny you should mention it...'\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Description: funny')\n\n    def test_Subject(self):\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Subject=('foo',))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('bar',)\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('foo',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo', 'bar')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Subject: foo')\n\n    def test_Subject2(self):\n        # Now test with mutli-valued\n        from ..PortalFolder import ContentFilter\n\n        cfilter = ContentFilter(Subject=('foo', 'bar'))\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('baz',)\n        self.assertFalse(cfilter(dummy))\n        dummy.subject = ('bar',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo',)\n        self.assertTrue(cfilter(dummy))\n        dummy.subject = ('foo', 'bar')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0], 'Subject: foo, bar')\n\n    def test_created(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=creation_date,\n                                created_usage='range:min')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Created since: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_created2(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=creation_date,\n                                created_usage='range:max')\n\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Created before: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_modified(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(modified=DateTime('2001/01/01'),\n                                modified_usage='range:min')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Modified since: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_modified2(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(modified=DateTime('2001/01/01'),\n                                modified_usage='range:max')\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.modified_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 1)\n        self.assertEqual(lines[0],\n                         'Modified before: 2001/01/01 00:00:00 %s' % tz)\n\n    def test_mixed(self):\n        from ..PortalFolder import ContentFilter\n\n        creation_date = DateTime('2001/01/01')\n        tz = creation_date.timezone()\n        cfilter = ContentFilter(created=DateTime('2001/01/01'),\n                                created_usage='range:max', Title='foo')\n\n        dummy = self.dummy\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertFalse(cfilter(dummy))\n\n        dummy.title = 'ohsofoolish'\n        del dummy.created_date\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2000/12/31')\n        self.assertTrue(cfilter(dummy))\n        dummy.created_date = DateTime('2001/12/31')\n        self.assertFalse(cfilter(dummy))\n        dummy.created_date = DateTime('2001/01/01')\n        self.assertTrue(cfilter(dummy))\n\n        desc = str(cfilter)\n        lines = desc.split('; ')\n        self.assertEqual(len(lines), 2)\n        self.assertTrue('Created before: 2001/01/01 00:00:00 %s' % tz in lines)\n        self.assertTrue('Title: foo' in lines)\n\n\n# -----------------------------------------------------------------------------\n#   Tests for security-related CopySupport lifted from the Zope 2.7\n#   / head OFS.tests.testCopySupport (see Collector #259).\n# -----------------------------------------------------------------------------\nADD_IMAGES_AND_FILES = 'Add images and files'\nFILE_META_TYPES = ({'name': 'File',\n                    'action': 'manage_addFile',\n                    'permission': ADD_IMAGES_AND_FILES},)\n\n\nclass _SensitiveSecurityPolicy:\n\n    def __init__(self, validate_lambda, checkPermission_lambda):\n        self._lambdas = (validate_lambda, checkPermission_lambda)\n\n    def validate(self, *args, **kw):\n        if self._lambdas[0](*args, **kw):\n            return True\n        raise Unauthorized\n\n    def checkPermission(self, *args, **kw):\n        return self._lambdas[1](*args, **kw)\n\n\nclass _AllowedUser(Implicit):\n\n    def __init__(self, allowed_lambda):\n        self._lambdas = (allowed_lambda,)\n\n    def getId(self):\n        return 'unit_tester'\n\n    def getUserName(self):\n        return 'Unit Tester'\n\n    def allowed(self, object, object_roles=None):\n        return self._lambdas[0](object, object_roles)\n\n\nclass PortalFolderCopySupportTests(SecurityTest):\n\n    layer = TraversingEventZCMLLayer\n\n    def _initFolders(self):\n        from ..PortalFolder import PortalFolder\n\n        self.app._setObject('folder1', PortalFolder('folder1'))\n        self.app._setObject('folder2', PortalFolder('folder2'))\n        folder1 = getattr(self.app, 'folder1')\n        manage_addFile(folder1, 'file', file='', content_type='text/plain')\n\n        # Hack, we need a _p_mtime for the file, so we make sure that it\n        # has one. We use a subtransaction, which means we can rollback\n        # later and pretend we didn't touch the ZODB.\n        transaction.savepoint(optimistic=True)\n        return self.app._getOb('folder1'), self.app._getOb('folder2')\n\n    def _assertCopyErrorUnauth(self, callable, *args, **kw):\n        import re\n\n        from OFS.CopySupport import CopyError\n\n        from ..exceptions import zExceptions_Unauthorized\n\n        ce_regex = kw.get('ce_regex')\n        if ce_regex is not None:\n            del kw['ce_regex']\n\n        try:\n            callable(*args, **kw)\n        except CopyError as e:\n            if ce_regex is not None:\n                pattern = re.compile(ce_regex, re.DOTALL)\n                if pattern.search(str(e)) is None:\n                    self.fail(\"Paste failed; didn't match pattern:\\n%s\" % e)\n            else:\n                self.fail('Paste failed; no pattern:\\n%s' % e)\n\n        except zExceptions_Unauthorized:\n            pass\n        else:\n            self.fail('Paste allowed unexpectedly.')\n\n    def _initPolicyAndUser(self, a_lambda=None, v_lambda=None, c_lambda=None):\n        def _promiscuous(*args, **kw):\n            return 1\n\n        if a_lambda is None:\n            a_lambda = _promiscuous\n\n        if v_lambda is None:\n            v_lambda = _promiscuous\n\n        if c_lambda is None:\n            c_lambda = _promiscuous\n\n        scp = _SensitiveSecurityPolicy(v_lambda, c_lambda)\n        SecurityManager.setSecurityPolicy(scp)\n\n        newSecurityManager(None,\n                           _AllowedUser(a_lambda).__of__(self.app.acl_users))\n\n    def test_copy_baseline(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        self._initPolicyAndUser()\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertFalse('file' in folder2.objectIds())\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        folder2.manage_pasteObjects(cookie)\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertTrue('file' in folder2.objectIds())\n\n    def test_copy_cant_read_source(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        a_file = folder1._getOb('file')\n\n        def _validate(a, c, n, v, *args, **kw):\n            return aq_base(v) is not aq_base(a_file)\n\n        self._initPolicyAndUser(v_lambda=_validate)\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects,\n                                    cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_copy_cant_create_target_metatype_not_supported(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = ()\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_copyObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Not Supported')\n\n    def test_move_baseline(self):\n\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        self.assertTrue('file' in folder1.objectIds())\n        self.assertFalse('file' in folder2.objectIds())\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        folder2.manage_pasteObjects(cookie)\n\n        self.assertFalse('file' in folder1.objectIds())\n        self.assertTrue('file' in folder2.objectIds())\n\n    def test_move_cant_read_source(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        a_file = folder1._getOb('file')\n\n        def _validate(a, c, n, v, *args, **kw):\n            return aq_base(v) is not aq_base(a_file)\n\n        self._initPolicyAndUser(v_lambda=_validate)\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_move_cant_create_target_metatype_not_supported(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = ()\n\n        self._initPolicyAndUser()\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Not Supported')\n\n    def test_move_cant_create_target_metatype_not_allowed(self):\n        folder1, folder2 = self._initFolders()\n        folder2.all_meta_types = FILE_META_TYPES\n\n        def _no_manage_addFile(a, c, n, v, *args, **kw):\n            return n != 'manage_addFile'\n\n        def _no_add_images_and_files(permission, object, context):\n            return permission != ADD_IMAGES_AND_FILES\n\n        self._initPolicyAndUser(v_lambda=_no_manage_addFile,\n                                c_lambda=_no_add_images_and_files)\n\n        cookie = folder1.manage_cutObjects(ids=('file',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient privileges')\n\n    def test_move_cant_delete_source(self):\n        from AccessControl.Permissions import delete_objects as DeleteObjects\n\n        from ..PortalFolder import PortalFolder\n\n        folder1, folder2 = self._initFolders()\n        folder1.manage_permission(DeleteObjects, roles=(), acquire=0)\n\n        folder1._setObject('sub', PortalFolder('sub'))\n        transaction.savepoint(optimistic=True)  # get a _p_jar for 'sub'\n\n        def _no_delete_objects(permission, object, context):\n            return permission != DeleteObjects\n\n        self._initPolicyAndUser(c_lambda=_no_delete_objects)\n\n        cookie = folder1.manage_cutObjects(ids=('sub',))\n        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,\n                                    ce_regex='Insufficient Privileges'\n                                    + '.*%s' % DeleteObjects)\n\n    def test_paste_with_restricted_item_content_type_not_allowed(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the item being pasted does not allow adding such\n        #   objects to containers which do not explicitly grant access.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Item'\n        UNRESTRICTED_TYPE = 'Unrestricted Container'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = UNRESTRICTED_TYPE\n        folder2.portal_type = RESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=0))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=0))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should raise\n        # an exception\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)\n\n    def test_paste_with_restricted_item_content_type_allowed(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the item being pasted *does8 allow adding such\n        #   objects to containers which *do* explicitly grant access.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Item'\n        UNRESTRICTED_TYPE = 'Unrestricted Container'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = UNRESTRICTED_TYPE\n        folder2.portal_type = RESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=0))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=1,\n                             allowed_content_types=[RESTRICTED_TYPE]))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should *not* raise\n        # an exception, because the folder's type allows it.\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        folder1.manage_pasteObjects(copy_cookie)\n        self.assertTrue('folder2' in folder1.objectIds())\n\n    def test_paste_with_restricted_container_content_type(self):\n        #   Test from CMF Collector #216 (Plone #2186), for the case\n        #   in which the container does not allow adding items of the\n        #   type being pasted.\n        from ..PortalFolder import PortalFolder\n\n        RESTRICTED_TYPE = 'Restricted Container'\n        UNRESTRICTED_TYPE = 'Unrestricted Item'\n\n        folder1, folder2 = self._initFolders()\n        folder1.portal_type = RESTRICTED_TYPE\n        folder2.portal_type = UNRESTRICTED_TYPE\n\n        self._initPolicyAndUser()  # ensure that sec. machinery allows paste\n\n        ttool = TypesTool()\n        ttool._setObject(RESTRICTED_TYPE,\n                         FTI(id=RESTRICTED_TYPE,\n                             title=RESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             filter_content_types=1,\n                             allowed_content_types=()))\n        ttool._setObject(UNRESTRICTED_TYPE,\n                         FTI(id=UNRESTRICTED_TYPE,\n                             title=UNRESTRICTED_TYPE,\n                             meta_type=PortalFolder.meta_type,\n                             product='CMFCore',\n                             factory='manage_addPortalFolder',\n                             global_allow=1))\n        getSiteManager().registerUtility(ttool, ITypesTool)\n\n        # copy and pasting the object into the folder should raise\n        # an exception\n        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])\n        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)\n\n\ndef test_suite():\n    loadTestsFromTestCase = unittest.defaultTestLoader.loadTestsFromTestCase\n    return unittest.TestSuite((\n        loadTestsFromTestCase(PortalFolderFactoryTests),\n        loadTestsFromTestCase(PortalFolderTests),\n        loadTestsFromTestCase(PortalFolderSecurityTests),\n        loadTestsFromTestCase(PortalFolderMoveTests),\n        loadTestsFromTestCase(ContentFilterTests),\n        loadTestsFromTestCase(PortalFolderCopySupportTests)))\n"], "filenames": ["CHANGES.rst", "src/Products/CMFCore/PortalFolder.py", "src/Products/CMFCore/tests/test_PortalFolder.py"], "buggy_code_start_loc": [7, 16, 155], "buggy_code_end_loc": [8, 255, 155], "fixing_code_start_loc": [7, 16, 156], "fixing_code_end_loc": [8, 258, 188], "type": "CWE-770", "message": "Products.CMFCore are the key framework services for the Zope Content Management Framework (CMF). The use of Python's marshal module to handle unchecked input in a public method on `PortalFolder` objects can lead to an unauthenticated denial of service and crash situation. The code in question is exposed by all portal software built on top of `Products.CMFCore`, such as Plone. All deployments are vulnerable. The code has been fixed in `Products.CMFCore` version 3.2.", "other": {"cve": {"id": "CVE-2023-36814", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-03T17:15:09.393", "lastModified": "2023-07-17T18:56:57.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Products.CMFCore are the key framework services for the Zope Content Management Framework (CMF). The use of Python's marshal module to handle unchecked input in a public method on `PortalFolder` objects can lead to an unauthenticated denial of service and crash situation. The code in question is exposed by all portal software built on top of `Products.CMFCore`, such as Plone. All deployments are vulnerable. The code has been fixed in `Products.CMFCore` version 3.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zope:products.cmfcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2", "matchCriteriaId": "0E3F8A54-65FB-4B2D-81FC-05099054C7A6"}]}]}], "references": [{"url": "https://github.com/zopefoundation/Products.CMFCore/commit/40f03f43a60f28ca9485c8ef429efef729be54e5", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/zopefoundation/Products.CMFCore/security/advisories/GHSA-4hpj-8rhv-9x87", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zopefoundation/Products.CMFCore/commit/40f03f43a60f28ca9485c8ef429efef729be54e5"}}