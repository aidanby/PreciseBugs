{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     L       AAA   BBBB   EEEEE  L                           %\n%                     L      A   A  B   B  E      L                           %\n%                     L      AAAAA  BBBB   EEE    L                           %\n%                     L      A   A  B   B  E      L                           %\n%                     LLLLL  A   A  BBBB   EEEEE  LLLLL                       %\n%                                                                             %\n%                                                                             %\n%                      Read ASCII String As An Image.                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/annotate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/draw.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n#include \"magick/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d L A B E L I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadLABELImage() reads a LABEL image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadLABELImage method is:\n%\n%      Image *ReadLABELImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadLABELImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MaxTextExtent],\n    *property;\n\n  const char\n    *label;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  property=InterpretImageProperties(image_info,image,image_info->filename);\n  (void) SetImageProperty(image,\"label\",property);\n  property=DestroyString(property);\n  label=GetImageProperty(image,\"label\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->text=ConstantString(label);\n  metrics.width=0;\n  metrics.ascent=0.0;\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if ((image->columns == 0) && (image->rows == 0))\n    {\n      image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);\n      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n    }\n  else\n    if (((image->columns == 0) || (image->rows == 0)) ||\n        (fabs(image_info->pointsize) < MagickEpsilon))\n      {\n        double\n          high,\n          low;\n\n        /*\n          Auto fit text into bounding box.\n        */\n        for ( ; ; draw_info->pointsize*=2.0)\n        {\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width >= image->columns) && (height >= image->rows))\n                break;\n            }\n          else\n            if (((image->columns != 0) && (width >= image->columns)) ||\n                ((image->rows != 0) && (height >= image->rows)))\n              break;\n        }\n        high=draw_info->pointsize;\n        for (low=1.0; (high-low) > 0.5; )\n        {\n          draw_info->pointsize=(low+high)/2.0;\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width < image->columns) && (height < image->rows))\n                low=draw_info->pointsize+0.5;\n              else\n                high=draw_info->pointsize-0.5;\n            }\n          else\n            if (((image->columns != 0) && (width < image->columns)) ||\n                ((image->rows != 0) && (height < image->rows)))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n        }\n        draw_info->pointsize=(low+high)/2.0-0.5;\n      }\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image->columns == 0)\n    image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);\n  if (image->columns == 0)\n    image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) (metrics.ascent-metrics.descent+\n      draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Draw label.\n  */\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n    metrics.ascent : 0.0);\n  draw_info->geometry=AcquireString(geometry);\n  status=AnnotateImage(image,draw_info);\n  if (image_info->pointsize == 0.0)\n    {\n      char\n        pointsize[MaxTextExtent];\n\n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"label:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r L A B E L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterLABELImage() adds properties for the LABEL image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterLABELImage method is:\n%\n%      size_t RegisterLABELImage(void)\n%\n*/\nModuleExport size_t RegisterLABELImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"LABEL\");\n  entry->decoder=(DecodeImageHandler *) ReadLABELImage;\n  entry->adjoin=MagickFalse;\n  entry->format_type=ImplicitFormatType;\n  entry->description=ConstantString(\"Image label\");\n  entry->module=ConstantString(\"LABEL\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r L A B E L I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterLABELImage() removes format registrations made by the\n%  LABEL module from the list of supported formats.\n%\n%  The format of the UnregisterLABELImage method is:\n%\n%      UnregisterLABELImage(void)\n%\n*/\nModuleExport void UnregisterLABELImage(void)\n{\n  (void) UnregisterMagickInfo(\"LABEL\");\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    (void) ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            if (AcquireImageColormap(image,image->colors) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                (unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                  (unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n    image->storage_class=\n      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(MagickRealType) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        if (image->storage_class != PseudoClass)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(indexes+x+bit,quantum);\n             }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(indexes+x+bit,quantum);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n            SetPixelIndex(indexes+x,*p++);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].red);\n                  index=(ssize_t) GetPixelGreen(q);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].green);\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].blue);\n                }\n              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n              p++;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"VIFF\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  entry->description=ConstantString(\"Khoros Visualization image\");\n  entry->module=ConstantString(\"VIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"XV\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->description=ConstantString(\"Khoros Visualization image\");\n  entry->module=ConstantString(\"VIFF\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\");\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->matte ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,&image->exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(p));\n            if (image->matte != MagickFalse)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(p)));\n            p++;\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            (void) SetImageType(image,BilevelType);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p++;\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        EEEEE  X   X   CCCC  EEEEE  PPPP  TTTTT  IIIII   OOO   N   N         %\n%        E       X X   C      E      P   P   T      I    O   O  NN  N         %\n%        EEE      X    C      EEE    PPPP    T      I    O   O  N N N         %\n%        E       X X   C      E      P       T      I    O   O  N  NN         %\n%        EEEEE   X  X   CCCC  EEEEE  P       T    IIIII   OOO   N   N         %\n%                                                                             %\n%                                                                             %\n%                        MagickCore Exception Methods                         %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                                July 1993                                    %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/client.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/locale_.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/string_.h\"\n#include \"magick/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic void\n  DefaultErrorHandler(const ExceptionType,const char *,const char *),\n  DefaultFatalErrorHandler(const ExceptionType,const char *,const char *),\n  DefaultWarningHandler(const ExceptionType,const char *,const char *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic ErrorHandler\n  error_handler = DefaultErrorHandler;\n\nstatic FatalErrorHandler\n  fatal_error_handler = DefaultFatalErrorHandler;\n\nstatic WarningHandler\n  warning_handler = DefaultWarningHandler;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e E x c e p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireExceptionInfo() allocates the ExceptionInfo structure.\n%\n%  The format of the AcquireExceptionInfo method is:\n%\n%      ExceptionInfo *AcquireExceptionInfo(void)\n%\n*/\nMagickExport ExceptionInfo *AcquireExceptionInfo(void)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) AcquireMagickMemory(sizeof(*exception));\n  if (exception == (ExceptionInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  InitializeExceptionInfo(exception);\n  exception->relinquish=MagickTrue;\n  return(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l e a r M a g i c k E x c e p t i o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClearMagickException() clears any exception that may not have been caught\n%  yet.\n%\n%  The format of the ClearMagickException method is:\n%\n%      ClearMagickException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\n\nstatic void *DestroyExceptionElement(void *exception)\n{\n  register ExceptionInfo\n    *p;\n\n  p=(ExceptionInfo *) exception;\n  if (p->reason != (char *) NULL)\n    p->reason=DestroyString(p->reason);\n  if (p->description != (char *) NULL)\n    p->description=DestroyString(p->description);\n  p=(ExceptionInfo *) RelinquishMagickMemory(p);\n  return((void *) NULL);\n}\n\nMagickExport void ClearMagickException(ExceptionInfo *exception)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->exceptions == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ClearLinkedList((LinkedListInfo *) exception->exceptions,\n    DestroyExceptionElement);\n  exception->severity=UndefinedException;\n  exception->reason=(char *) NULL;\n  exception->description=(char *) NULL;\n  UnlockSemaphoreInfo(exception->semaphore);\n  errno=0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h E x c e p t i o n                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchException() returns if no exceptions is found otherwise it reports\n%  the exception as a warning, error, or fatal depending on the severity.\n%\n%  The format of the CatchException method is:\n%\n%      CatchException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e E x c e p t i o n I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneExceptionInfo() clones the ExceptionInfo structure.\n%\n%  The format of the CloneExceptionInfo method is:\n%\n%      ExceptionInfo *CloneException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickExport ExceptionInfo *CloneExceptionInfo(ExceptionInfo *exception)\n{\n  ExceptionInfo\n    *clone_exception;\n\n  clone_exception=(ExceptionInfo *) AcquireMagickMemory(sizeof(*exception));\n  if (clone_exception == (ExceptionInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  InitializeExceptionInfo(clone_exception);\n  InheritException(clone_exception,exception);\n  clone_exception->relinquish=MagickTrue;\n  return(clone_exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t E r r o r H a n d l e r                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultErrorHandler() displays an error reason.\n%\n%  The format of the DefaultErrorHandler method is:\n%\n%      void MagickError(const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultErrorHandler(const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t F a t a l E r r o r H a n d l e r                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultFatalErrorHandler() displays an error reason and then terminates the\n%  program.\n%\n%  The format of the DefaultFatalErrorHandler method is:\n%\n%      void MagickFatalError(const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultFatalErrorHandler(const ExceptionType severity,\n  const char *reason,const char *description)\n{\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n  MagickCoreTerminus();\n  exit((int) (severity-FatalErrorException)+1);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t W a r n i n g H a n d l e r                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultWarningHandler() displays a warning reason.\n%\n%  The format of the DefaultWarningHandler method is:\n%\n%      void DefaultWarningHandler(const ExceptionType severity,\n%        const char *reason,const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric warning category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultWarningHandler(const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y E x c e p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyExceptionInfo() deallocates memory associated with an exception.\n%\n%  The format of the DestroyExceptionInfo method is:\n%\n%      ExceptionInfo *DestroyExceptionInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\n\nMagickPrivate MagickBooleanType ClearExceptionInfo(ExceptionInfo *exception,\n  MagickBooleanType relinquish)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&exception->semaphore);\n  LockSemaphoreInfo(exception->semaphore);\n  if (relinquish == MagickFalse)\n    relinquish=exception->relinquish;\n  exception->severity=UndefinedException;\n  if (relinquish != MagickFalse)\n    {\n      exception->signature=(~MagickSignature);\n      if (exception->exceptions != (void *) NULL)\n        exception->exceptions=(void *) DestroyLinkedList((LinkedListInfo *)\n          exception->exceptions,DestroyExceptionElement);\n    }\n  else if (exception->exceptions != (void *) NULL)\n    ClearLinkedList((LinkedListInfo *) exception->exceptions,\n      DestroyExceptionElement);\n  UnlockSemaphoreInfo(exception->semaphore);\n  if (relinquish != MagickFalse)\n    DestroySemaphoreInfo(&exception->semaphore);\n  return(relinquish);\n}\n\nMagickExport ExceptionInfo *DestroyExceptionInfo(ExceptionInfo *exception)\n{\n  if (ClearExceptionInfo(exception,MagickFalse) != MagickFalse)\n    exception=(ExceptionInfo *) RelinquishMagickMemory(exception);\n  return(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t E x c e p t i o n M e s s a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetExceptionMessage() returns the error message defined by the specified\n%  error code.\n%\n%  The format of the GetExceptionMessage method is:\n%\n%      char *GetExceptionMessage(const int error)\n%\n%  A description of each parameter follows:\n%\n%    o error: the error code.\n%\n*/\nMagickExport char *GetExceptionMessage(const int error)\n{\n  char\n    exception[MaxTextExtent];\n\n  *exception='\\0';\n#if defined(MAGICKCORE_HAVE_STRERROR_R)\n#if !defined(MAGICKCORE_STRERROR_R_CHAR_P)\n  (void) strerror_r(error,exception,sizeof(exception));\n#else\n  (void) CopyMagickString(exception,strerror_r(error,exception,\n    sizeof(exception)),sizeof(exception));\n#endif\n#else\n  (void) CopyMagickString(exception,strerror(error),sizeof(exception));\n#endif\n  return(ConstantString(exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e E x c e p t i o n M e s s a g e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleExceptionMessage() converts a enumerated exception severity and tag\n%  to a message in the current locale.\n%\n%  The format of the GetLocaleExceptionMessage method is:\n%\n%      const char *GetLocaleExceptionMessage(const ExceptionType severity,\n%        const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o severity: the severity of the exception.\n%\n%    o tag: the message tag.\n%\n*/\n\nstatic const char *ExceptionSeverityToTag(const ExceptionType severity)\n{\n  switch (severity)\n  {\n    case ResourceLimitWarning: return(\"Resource/Limit/Warning/\");\n    case TypeWarning: return(\"Type/Warning/\");\n    case OptionWarning: return(\"Option/Warning/\");\n    case DelegateWarning: return(\"Delegate/Warning/\");\n    case MissingDelegateWarning: return(\"Missing/Delegate/Warning/\");\n    case CorruptImageWarning: return(\"Corrupt/Image/Warning/\");\n    case FileOpenWarning: return(\"File/Open/Warning/\");\n    case BlobWarning: return(\"Blob/Warning/\");\n    case StreamWarning: return(\"Stream/Warning/\");\n    case CacheWarning: return(\"Cache/Warning/\");\n    case CoderWarning: return(\"Coder/Warning/\");\n    case FilterWarning: return(\"Filter/Warning/\");\n    case ModuleWarning: return(\"Module/Warning/\");\n    case DrawWarning: return(\"Draw/Warning/\");\n    case ImageWarning: return(\"Image/Warning/\");\n    case WandWarning: return(\"Wand/Warning/\");\n    case XServerWarning: return(\"XServer/Warning/\");\n    case MonitorWarning: return(\"Monitor/Warning/\");\n    case RegistryWarning: return(\"Registry/Warning/\");\n    case ConfigureWarning: return(\"Configure/Warning/\");\n    case PolicyWarning: return(\"Policy/Warning/\");\n    case ResourceLimitError: return(\"Resource/Limit/Error/\");\n    case TypeError: return(\"Type/Error/\");\n    case OptionError: return(\"Option/Error/\");\n    case DelegateError: return(\"Delegate/Error/\");\n    case MissingDelegateError: return(\"Missing/Delegate/Error/\");\n    case CorruptImageError: return(\"Corrupt/Image/Error/\");\n    case FileOpenError: return(\"File/Open/Error/\");\n    case BlobError: return(\"Blob/Error/\");\n    case StreamError: return(\"Stream/Error/\");\n    case CacheError: return(\"Cache/Error/\");\n    case CoderError: return(\"Coder/Error/\");\n    case FilterError: return(\"Filter/Error/\");\n    case ModuleError: return(\"Module/Error/\");\n    case DrawError: return(\"Draw/Error/\");\n    case ImageError: return(\"Image/Error/\");\n    case WandError: return(\"Wand/Error/\");\n    case XServerError: return(\"XServer/Error/\");\n    case MonitorError: return(\"Monitor/Error/\");\n    case RegistryError: return(\"Registry/Error/\");\n    case ConfigureError: return(\"Configure/Error/\");\n    case PolicyError: return(\"Policy/Error/\");\n    case ResourceLimitFatalError: return(\"Resource/Limit/FatalError/\");\n    case TypeFatalError: return(\"Type/FatalError/\");\n    case OptionFatalError: return(\"Option/FatalError/\");\n    case DelegateFatalError: return(\"Delegate/FatalError/\");\n    case MissingDelegateFatalError: return(\"Missing/Delegate/FatalError/\");\n    case CorruptImageFatalError: return(\"Corrupt/Image/FatalError/\");\n    case FileOpenFatalError: return(\"File/Open/FatalError/\");\n    case BlobFatalError: return(\"Blob/FatalError/\");\n    case StreamFatalError: return(\"Stream/FatalError/\");\n    case CacheFatalError: return(\"Cache/FatalError/\");\n    case CoderFatalError: return(\"Coder/FatalError/\");\n    case FilterFatalError: return(\"Filter/FatalError/\");\n    case ModuleFatalError: return(\"Module/FatalError/\");\n    case DrawFatalError: return(\"Draw/FatalError/\");\n    case ImageFatalError: return(\"Image/FatalError/\");\n    case WandFatalError: return(\"Wand/FatalError/\");\n    case XServerFatalError: return(\"XServer/FatalError/\");\n    case MonitorFatalError: return(\"Monitor/FatalError/\");\n    case RegistryFatalError: return(\"Registry/FatalError/\");\n    case ConfigureFatalError: return(\"Configure/FatalError/\");\n    case PolicyFatalError: return(\"Policy/FatalError/\");\n    default: break;\n  }\n  return(\"\");\n}\n\nMagickExport const char *GetLocaleExceptionMessage(const ExceptionType severity,\n  const char *tag)\n{\n  char\n    message[MaxTextExtent];\n\n  const char\n    *locale_message;\n\n  assert(tag != (const char *) NULL);\n  (void) FormatLocaleString(message,MaxTextExtent,\"Exception/%s%s\",\n    ExceptionSeverityToTag(severity),tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == (const char *) NULL)\n    return(tag);\n  if (locale_message == message)\n    return(tag);\n  return(locale_message);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n h e r i t E x c e p t i o n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InheritException() inherits an exception from a related exception.\n%\n%  The format of the InheritException method is:\n%\n%      InheritException(ExceptionInfo *exception,const ExceptionInfo *relative)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o relative: the related exception info.\n%\n*/\nMagickExport void InheritException(ExceptionInfo *exception,\n  const ExceptionInfo *relative)\n{\n  register const ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  assert(relative != (ExceptionInfo *) NULL);\n  assert(relative->signature == MagickSignature);\n  assert(exception != relative);\n  if (relative->exceptions == (void *) NULL)\n    return;\n  LockSemaphoreInfo(relative->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) relative->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    relative->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    (void) ThrowException(exception,p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      relative->exceptions);\n  }\n  UnlockSemaphoreInfo(relative->semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n i t i a l i z e E x c e p t i o n I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InitializeExceptionInfo() initializes an exception to default values.\n%\n%  The format of the InitializeExceptionInfo method is:\n%\n%      InitializeExceptionInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickPrivate void InitializeExceptionInfo(ExceptionInfo *exception)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) ResetMagickMemory(exception,0,sizeof(*exception));\n  exception->severity=UndefinedException;\n  exception->exceptions=(void *) NewLinkedList(0);\n  exception->semaphore=AllocateSemaphoreInfo();\n  exception->signature=MagickSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k E r r o r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickError() calls the exception handler methods with an error reason.\n%\n%  The format of the MagickError method is:\n%\n%      void MagickError(const ExceptionType error,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nMagickExport void MagickError(const ExceptionType error,const char *reason,\n  const char *description)\n{\n  if (error_handler != (ErrorHandler) NULL)\n    (*error_handler)(error,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k F a t al E r r o r                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickFatalError() calls the fatal exception handler methods with an error\n%  reason.\n%\n%  The format of the MagickError method is:\n%\n%      void MagickFatalError(const ExceptionType error,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nMagickExport void MagickFatalError(const ExceptionType error,const char *reason,\n  const char *description)\n{\n  if (fatal_error_handler != (ErrorHandler) NULL)\n    (*fatal_error_handler)(error,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k W a r n i n g                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickWarning() calls the warning handler methods with a warning reason.\n%\n%  The format of the MagickWarning method is:\n%\n%      void MagickWarning(const ExceptionType warning,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o warning: the warning severity.\n%\n%    o reason: Define the reason for the warning.\n%\n%    o description: Describe the warning.\n%\n*/\nMagickExport void MagickWarning(const ExceptionType warning,const char *reason,\n  const char *description)\n{\n  if (warning_handler != (WarningHandler) NULL)\n    (*warning_handler)(warning,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t E r r o r H a n d l e r                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetErrorHandler() sets the exception handler to the specified method\n%  and returns the previous exception handler.\n%\n%  The format of the SetErrorHandler method is:\n%\n%      ErrorHandler SetErrorHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle errors.\n%\n*/\nMagickExport ErrorHandler SetErrorHandler(ErrorHandler handler)\n{\n  ErrorHandler\n    previous_handler;\n\n  previous_handler=error_handler;\n  error_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t F a t a l E r r o r H a n d l e r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetFatalErrorHandler() sets the fatal exception handler to the specified\n%  method and returns the previous fatal exception handler.\n%\n%  The format of the SetErrorHandler method is:\n%\n%      ErrorHandler SetErrorHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle errors.\n%\n*/\nMagickExport FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)\n{\n  FatalErrorHandler\n    previous_handler;\n\n  previous_handler=fatal_error_handler;\n  fatal_error_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t W a r n i n g H a n d l e r                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetWarningHandler() sets the warning handler to the specified method\n%  and returns the previous warning handler.\n%\n%  The format of the SetWarningHandler method is:\n%\n%      ErrorHandler SetWarningHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle warnings.\n%\n*/\nMagickExport WarningHandler SetWarningHandler(WarningHandler handler)\n{\n  WarningHandler\n    previous_handler;\n\n  previous_handler=warning_handler;\n  warning_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T h r o w E x c e p t i o n                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ThrowException() throws an exception with the specified severity code,\n%  reason, and optional description.\n%\n%  The format of the ThrowException method is:\n%\n%      MagickBooleanType ThrowException(ExceptionInfo *exception,\n%        const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o severity: the severity of the exception.\n%\n%    o reason: the reason for the exception.\n%\n%    o description: the exception description.\n%\n*/\nMagickExport MagickBooleanType ThrowException(ExceptionInfo *exception,\n  const ExceptionType severity,const char *reason,const char *description)\n{\n  register ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  LockSemaphoreInfo(exception->semaphore);\n  p=(ExceptionInfo *) GetLastValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  if ((p != (ExceptionInfo *) NULL) && (p->severity == severity) &&\n      (LocaleCompare(exception->reason,reason) == 0) &&\n      (LocaleCompare(exception->description,description) == 0))\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      return(MagickTrue);\n    }\n  p=(ExceptionInfo *) AcquireMagickMemory(sizeof(*p));\n  if (p == (ExceptionInfo *) NULL)\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(p,0,sizeof(*p));\n  p->severity=severity;\n  if (reason != (const char *) NULL)\n    p->reason=ConstantString(reason);\n  if (description != (const char *) NULL)\n    p->description=ConstantString(description);\n  p->signature=MagickSignature;\n  (void) AppendValueToLinkedList((LinkedListInfo *) exception->exceptions,p);\n  if (p->severity >= exception->severity)\n    {\n      exception->severity=p->severity;\n      exception->reason=p->reason;\n      exception->description=p->description;\n    }\n  UnlockSemaphoreInfo(exception->semaphore);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T h r o w M a g i c k E x c e p t i o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ThrowMagickException logs an exception as determined by the log configuration\n%  file.  If an error occurs, MagickFalse is returned otherwise MagickTrue.\n%\n%  The format of the ThrowMagickException method is:\n%\n%      MagickBooleanType ThrowFileException(ExceptionInfo *exception,\n%        const char *module,const char *function,const size_t line,\n%        const ExceptionType severity,const char *tag,const char *format,...)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o filename: the source module filename.\n%\n%    o function: the function name.\n%\n%    o line: the line number of the source module.\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o tag: the locale tag.\n%\n%    o format: the output format.\n%\n*/\n\nMagickExport MagickBooleanType ThrowMagickExceptionList(\n  ExceptionInfo *exception,const char *module,const char *function,\n  const size_t line,const ExceptionType severity,const char *tag,\n  const char *format,va_list operands)\n{\n  char\n    message[MaxTextExtent],\n    path[MaxTextExtent],\n    reason[MaxTextExtent];\n\n  const char\n    *locale,\n    *type;\n\n  int\n    n;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  locale=GetLocaleExceptionMessage(severity,tag);\n  (void) CopyMagickString(reason,locale,MaxTextExtent);\n  (void) ConcatenateMagickString(reason,\" \",MaxTextExtent);\n  length=strlen(reason);\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  n=vsnprintf(reason+length,MaxTextExtent-length,format,operands);\n#else\n  n=vsprintf(reason+length,format,operands);\n#endif\n  if (n < 0)\n    reason[MaxTextExtent-1]='\\0';\n  status=LogMagickEvent(ExceptionEvent,module,function,line,\"%s\",reason);\n  GetPathComponent(module,TailPath,path);\n  type=\"undefined\";\n  if ((severity >= WarningException) && (severity < ErrorException))\n    type=\"warning\";\n  if ((severity >= ErrorException) && (severity < FatalErrorException))\n    type=\"error\";\n  if (severity >= FatalErrorException)\n    type=\"fatal\";\n  (void) FormatLocaleString(message,MaxTextExtent,\"%s @ %s/%s/%s/%.20g\",reason,\n    type,path,function,(double) line);\n  (void) ThrowException(exception,severity,message,(char *) NULL);\n  return(status);\n}\n\nMagickExport MagickBooleanType ThrowMagickException(ExceptionInfo *exception,\n  const char *module,const char *function,const size_t line,\n  const ExceptionType severity,const char *tag,const char *format,...)\n{\n  MagickBooleanType\n    status;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  status=ThrowMagickExceptionList(exception,module,function,line,severity,tag,\n    format,operands);\n  va_end(operands);\n  return(status);\n}\n", "/*\n  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n  \n  You may not use this file except in compliance with the License.\n  obtain a copy of the License at\n  \n    http://www.imagemagick.org/script/license.php\n  \n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore private memory methods.\n*/\n#ifndef _MAGICKCORE_MEMORY_PRIVATE_H\n#define _MAGICKCORE_MEMORY_PRIVATE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(MAGICK_TARGET_CPU) && (MAGICK_TARGET_CPU == powerpc)\n#  define CACHE_LINE_SIZE 128\n#else\n#  define CACHE_LINE_SIZE 64\n#endif\n\n#define CacheAlign(size)  ((size) < CACHE_LINE_SIZE ? CACHE_LINE_SIZE : (size))\n\n#if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 6))\n#if !defined(__ICC)\n#define MagickAssumeAligned(address) \\\n  __builtin_assume_aligned((address),CACHE_LINE_SIZE)\n#else\n#define MagickAssumeAligned(address)  (address)\n#endif\n#else\n#define MagickAssumeAligned(address)  (address)\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                    M   M  EEEEE  M   M   OOO   RRRR   Y   Y                 %\n%                    MM MM  E      MM MM  O   O  R   R   Y Y                  %\n%                    M M M  EEE    M M M  O   O  RRRR     Y                   %\n%                    M   M  E      M   M  O   O  R R      Y                   %\n%                    M   M  EEEEE  M   M   OOO   R  R     Y                   %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Memory Allocation Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Segregate our memory requirements from any program that calls our API.  This\n%  should help reduce the risk of others changing our program state or causing\n%  memory corruption.\n%\n%  Our custom memory allocation manager implements a best-fit allocation policy\n%  using segregated free lists.  It uses a linear distribution of size classes\n%  for lower sizes and a power of two distribution of size classes at higher\n%  sizes.  It is based on the paper, \"Fast Memory Allocation using Lazy Fits.\"\n%  written by Yoo C. Chung.\n%\n%  By default, ANSI memory methods are called (e.g. malloc).  Use the\n%  custom memory allocator by defining MAGICKCORE_ZERO_CONFIGURATION_SUPPORT\n%  to allocate memory with private anonymous mapping rather than from the\n%  heap.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/string_.h\"\n#include \"magick/utility-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define BlockFooter(block,size) \\\n  ((size_t *) ((char *) (block)+(size)-2*sizeof(size_t)))\n#define BlockHeader(block)  ((size_t *) (block)-1)\n#define BlockSize  4096\n#define BlockThreshold  1024\n#define MaxBlockExponent  16\n#define MaxBlocks ((BlockThreshold/(4*sizeof(size_t)))+MaxBlockExponent+1)\n#define MaxSegments  1024\n#define MemoryGuard  ((0xdeadbeef << 31)+0xdeafdeed)\n#define NextBlock(block)  ((char *) (block)+SizeOfBlock(block))\n#define NextBlockInList(block)  (*(void **) (block))\n#define PreviousBlock(block)  ((char *) (block)-(*((size_t *) (block)-2)))\n#define PreviousBlockBit  0x01\n#define PreviousBlockInList(block)  (*((void **) (block)+1))\n#define SegmentSize  (2*1024*1024)\n#define SizeMask  (~0x01)\n#define SizeOfBlock(block)  (*BlockHeader(block) & SizeMask)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  UndefinedVirtualMemory,\n  AlignedVirtualMemory,\n  MapVirtualMemory,\n  UnalignedVirtualMemory\n} VirtualMemoryType;\n\ntypedef struct _DataSegmentInfo\n{\n  void\n    *allocation,\n    *bound;\n\n  MagickBooleanType\n    mapped;\n\n  size_t\n    length;\n\n  struct _DataSegmentInfo\n    *previous,\n    *next;\n} DataSegmentInfo;\n\ntypedef struct _MagickMemoryMethods\n{\n  AcquireMemoryHandler\n    acquire_memory_handler;\n\n  ResizeMemoryHandler\n    resize_memory_handler;\n\n  DestroyMemoryHandler\n    destroy_memory_handler;\n} MagickMemoryMethods;\n\nstruct _MemoryInfo\n{\n  char\n    filename[MaxTextExtent];\n\n  VirtualMemoryType\n    type;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  size_t\n    signature;\n};\n\ntypedef struct _MemoryPool\n{\n  size_t\n    allocation;\n\n  void\n    *blocks[MaxBlocks+1];\n\n  size_t\n    number_segments;\n\n  DataSegmentInfo\n    *segments[MaxSegments],\n    segment_pool[MaxSegments];\n} MemoryPool;\n\f\n/*\n  Global declarations.\n*/\n#if defined _MSC_VER\nstatic void* MSCMalloc(size_t size)\n{\n  return malloc(size);\n}\nstatic void* MSCRealloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\nstatic void MSCFree(void* ptr)\n{\n  free(ptr);\n}\n#endif\n\nstatic MagickMemoryMethods\n  memory_methods =\n  {\n#if defined _MSC_VER\n    (AcquireMemoryHandler) MSCMalloc,\n    (ResizeMemoryHandler) MSCRealloc,\n    (DestroyMemoryHandler) MSCFree\n#else\n    (AcquireMemoryHandler) malloc,\n    (ResizeMemoryHandler) realloc,\n    (DestroyMemoryHandler) free\n#endif\n  };\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic MemoryPool\n  memory_pool;\n\nstatic SemaphoreInfo\n  *memory_semaphore = (SemaphoreInfo *) NULL;\n\nstatic volatile DataSegmentInfo\n  *free_segments = (DataSegmentInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  ExpandHeap(size_t);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e A l i g n e d M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireAlignedMemory() returns a pointer to a block of memory at least size\n%  bytes whose address is a multiple of 16*sizeof(void *).\n%\n%  The format of the AcquireAlignedMemory method is:\n%\n%      void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\n\nstatic MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\nMagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n\n  size_t\n    alignment,\n    extent,\n    size;\n\n  void\n    *memory;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e B l o c k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireBlock() returns a pointer to a block of memory at least size bytes\n%  suitably aligned for any use.\n%\n%  The format of the AcquireBlock method is:\n%\n%      void *AcquireBlock(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\n\nstatic inline size_t AllocationPolicy(size_t size)\n{\n  register size_t\n    blocksize;\n\n  /*\n    The linear distribution.\n  */\n  assert(size != 0);\n  assert(size % (4*sizeof(size_t)) == 0);\n  if (size <= BlockThreshold)\n    return(size/(4*sizeof(size_t)));\n  /*\n    Check for the largest block size.\n  */\n  if (size > (size_t) (BlockThreshold*(1L << (MaxBlockExponent-1L))))\n    return(MaxBlocks-1L);\n  /*\n    Otherwise use a power of two distribution.\n  */\n  blocksize=BlockThreshold/(4*sizeof(size_t));\n  for ( ; size > BlockThreshold; size/=2)\n    blocksize++;\n  assert(blocksize > (BlockThreshold/(4*sizeof(size_t))));\n  assert(blocksize < (MaxBlocks-1L));\n  return(blocksize);\n}\n\nstatic inline void InsertFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  size_t\n    size;\n\n  size=SizeOfBlock(block);\n  previous=(void *) NULL;\n  next=memory_pool.blocks[i];\n  while ((next != (void *) NULL) && (SizeOfBlock(next) < size))\n  {\n    previous=next;\n    next=NextBlockInList(next);\n  }\n  PreviousBlockInList(block)=previous;\n  NextBlockInList(block)=next;\n  if (previous != (void *) NULL)\n    NextBlockInList(previous)=block;\n  else\n    memory_pool.blocks[i]=block;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=block;\n}\n\nstatic inline void RemoveFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  next=NextBlockInList(block);\n  previous=PreviousBlockInList(block);\n  if (previous == (void *) NULL)\n    memory_pool.blocks[i]=next;\n  else\n    NextBlockInList(previous)=next;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=previous;\n}\n\nstatic void *AcquireBlock(size_t size)\n{\n  register size_t\n    i;\n\n  register void\n    *block;\n\n  /*\n    Find free block.\n  */\n  size=(size_t) (size+sizeof(size_t)+6*sizeof(size_t)-1) & -(4U*sizeof(size_t));\n  i=AllocationPolicy(size);\n  block=memory_pool.blocks[i];\n  while ((block != (void *) NULL) && (SizeOfBlock(block) < size))\n    block=NextBlockInList(block);\n  if (block == (void *) NULL)\n    {\n      i++;\n      while (memory_pool.blocks[i] == (void *) NULL)\n        i++;\n      block=memory_pool.blocks[i];\n      if (i >= MaxBlocks)\n        return((void *) NULL);\n    }\n  assert((*BlockHeader(NextBlock(block)) & PreviousBlockBit) == 0);\n  assert(SizeOfBlock(block) >= size);\n  RemoveFreeBlock(block,AllocationPolicy(SizeOfBlock(block)));\n  if (SizeOfBlock(block) > size)\n    {\n      size_t\n        blocksize;\n\n      void\n        *next;\n\n      /*\n        Split block.\n      */\n      next=(char *) block+size;\n      blocksize=SizeOfBlock(block)-size;\n      *BlockHeader(next)=blocksize;\n      *BlockFooter(next,blocksize)=blocksize;\n      InsertFreeBlock(next,AllocationPolicy(blocksize));\n      *BlockHeader(block)=size | (*BlockHeader(block) & ~SizeMask);\n    }\n  assert(size == SizeOfBlock(block));\n  *BlockHeader(NextBlock(block))|=PreviousBlockBit;\n  memory_pool.allocation+=size;\n  return(block);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireMagickMemory() returns a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireMagickMemory method is:\n%\n%      void *AcquireMagickMemory(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumMemory() returns a pointer to a block of memory at least\n%  count * quantum bytes suitably aligned for any use.\n%\n%  The format of the AcquireQuantumMemory method is:\n%\n%      void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e V i r t u a l M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireVirtualMemory() allocates a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireVirtualMemory method is:\n%\n%      MemoryInfo *AcquireVirtualMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename='\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y M a g i c k M e m o r y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyMagickMemory() copies size bytes from memory area source to the\n%  destination.  Copying between objects that overlap will take place\n%  correctly.  It returns destination.\n%\n%  The format of the CopyMagickMemory method is:\n%\n%      void *CopyMagickMemory(void *destination,const void *source,\n%        const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o destination: the destination.\n%\n%    o source: the source.\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *CopyMagickMemory(void *destination,const void *source,\n  const size_t size)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  assert(destination != (void *) NULL);\n  assert(source != (const void *) NULL);\n  p=(const unsigned char *) source;\n  q=(unsigned char *) destination;\n  if (((q+size) < p) || (q > (p+size)))\n    switch (size)\n    {\n      default: return(memcpy(destination,source,size));\n      case 8: *q++=(*p++);\n      case 7: *q++=(*p++);\n      case 6: *q++=(*p++);\n      case 5: *q++=(*p++);\n      case 4: *q++=(*p++);\n      case 3: *q++=(*p++);\n      case 2: *q++=(*p++);\n      case 1: *q++=(*p++);\n      case 0: return(destination);\n    }\n  return(memmove(destination,source,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyMagickMemory() deallocates memory associated with the memory manager.\n%\n%  The format of the DestroyMagickMemory method is:\n%\n%      DestroyMagickMemory(void)\n%\n*/\nMagickExport void DestroyMagickMemory(void)\n{\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  register ssize_t\n    i;\n\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  LockSemaphoreInfo(memory_semaphore);\n  for (i=0; i < (ssize_t) memory_pool.number_segments; i++)\n    if (memory_pool.segments[i]->mapped == MagickFalse)\n      memory_methods.destroy_memory_handler(\n        memory_pool.segments[i]->allocation);\n    else\n      (void) UnmapBlob(memory_pool.segments[i]->allocation,\n        memory_pool.segments[i]->length);\n  free_segments=(DataSegmentInfo *) NULL;\n  (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n  UnlockSemaphoreInfo(memory_semaphore);\n  DestroySemaphoreInfo(&memory_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p a n d H e a p                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExpandHeap() get more memory from the system.  It returns MagickTrue on\n%  success otherwise MagickFalse.\n%\n%  The format of the ExpandHeap method is:\n%\n%      MagickBooleanType ExpandHeap(size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes we require.\n%\n*/\nstatic MagickBooleanType ExpandHeap(size_t size)\n{\n  DataSegmentInfo\n    *segment_info;\n\n  MagickBooleanType\n    mapped;\n\n  register ssize_t\n    i;\n\n  register void\n    *block;\n\n  size_t\n    blocksize;\n\n  void\n    *segment;\n\n  blocksize=((size+12*sizeof(size_t))+SegmentSize-1) & -SegmentSize;\n  assert(memory_pool.number_segments < MaxSegments);\n  segment=MapBlob(-1,IOMode,0,blocksize);\n  mapped=segment != (void *) NULL ? MagickTrue : MagickFalse;\n  if (segment == (void *) NULL)\n    segment=(void *) memory_methods.acquire_memory_handler(blocksize);\n  if (segment == (void *) NULL)\n    return(MagickFalse);\n  segment_info=(DataSegmentInfo *) free_segments;\n  free_segments=segment_info->next;\n  segment_info->mapped=mapped;\n  segment_info->length=blocksize;\n  segment_info->allocation=segment;\n  segment_info->bound=(char *) segment+blocksize;\n  i=(ssize_t) memory_pool.number_segments-1;\n  for ( ; (i >= 0) && (memory_pool.segments[i]->allocation > segment); i--)\n    memory_pool.segments[i+1]=memory_pool.segments[i];\n  memory_pool.segments[i+1]=segment_info;\n  memory_pool.number_segments++;\n  size=blocksize-12*sizeof(size_t);\n  block=(char *) segment_info->allocation+4*sizeof(size_t);\n  *BlockHeader(block)=size | PreviousBlockBit;\n  *BlockFooter(block,size)=size;\n  InsertFreeBlock(block,AllocationPolicy(size));\n  block=NextBlock(block);\n  assert(block < segment_info->bound);\n  *BlockHeader(block)=2*sizeof(size_t);\n  *BlockHeader(NextBlock(block))=PreviousBlockBit;\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickMemoryMethods() gets the methods to acquire, resize, and destroy\n%  memory.\n%\n%  The format of the GetMagickMemoryMethods() method is:\n%\n%      void GetMagickMemoryMethods(AcquireMemoryHandler *acquire_memory_handler,\n%        ResizeMemoryHandler *resize_memory_handler,\n%        DestroyMemoryHandler *destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void GetMagickMemoryMethods(\n  AcquireMemoryHandler *acquire_memory_handler,\n  ResizeMemoryHandler *resize_memory_handler,\n  DestroyMemoryHandler *destroy_memory_handler)\n{\n  assert(acquire_memory_handler != (AcquireMemoryHandler *) NULL);\n  assert(resize_memory_handler != (ResizeMemoryHandler *) NULL);\n  assert(destroy_memory_handler != (DestroyMemoryHandler *) NULL);\n  *acquire_memory_handler=memory_methods.acquire_memory_handler;\n  *resize_memory_handler=memory_methods.resize_memory_handler;\n  *destroy_memory_handler=memory_methods.destroy_memory_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e m o r y B l o b                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMemoryBlob() returns the virtual memory blob associated with the\n%  specified MemoryInfo structure.\n%\n%  The format of the GetVirtualMemoryBlob method is:\n%\n%      void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: The MemoryInfo structure.\n*/\nMagickExport void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n{\n  assert(memory_info != (const MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickSignature);\n  return(memory_info->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h A l i g n e d M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishAlignedMemory() frees memory acquired with AcquireAlignedMemory()\n%  or reuse.\n%\n%  The format of the RelinquishAlignedMemory method is:\n%\n%      void *RelinquishAlignedMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h M a g i c k M e m o r y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishMagickMemory() frees memory acquired with AcquireMagickMemory()\n%  or AcquireQuantumMemory() for reuse.\n%\n%  The format of the RelinquishMagickMemory method is:\n%\n%      void *RelinquishMagickMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishMagickMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory_methods.destroy_memory_handler(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  assert((SizeOfBlock(memory) % (4*sizeof(size_t))) == 0);\n  assert((*BlockHeader(NextBlock(memory)) & PreviousBlockBit) != 0);\n  if ((*BlockHeader(memory) & PreviousBlockBit) == 0)\n    {\n      void\n        *previous;\n\n      /*\n        Coalesce with previous adjacent block.\n      */\n      previous=PreviousBlock(memory);\n      RemoveFreeBlock(previous,AllocationPolicy(SizeOfBlock(previous)));\n      *BlockHeader(previous)=(SizeOfBlock(previous)+SizeOfBlock(memory)) |\n        (*BlockHeader(previous) & ~SizeMask);\n      memory=previous;\n    }\n  if ((*BlockHeader(NextBlock(NextBlock(memory))) & PreviousBlockBit) == 0)\n    {\n      void\n        *next;\n\n      /*\n        Coalesce with next adjacent block.\n      */\n      next=NextBlock(memory);\n      RemoveFreeBlock(next,AllocationPolicy(SizeOfBlock(next)));\n      *BlockHeader(memory)=(SizeOfBlock(memory)+SizeOfBlock(next)) |\n        (*BlockHeader(memory) & ~SizeMask);\n    }\n  *BlockFooter(memory,SizeOfBlock(memory))=SizeOfBlock(memory);\n  *BlockHeader(NextBlock(memory))&=(~PreviousBlockBit);\n  InsertFreeBlock(memory,AllocationPolicy(SizeOfBlock(memory)));\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return((void *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h V i r t u a l M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishVirtualMemory() frees memory acquired with AcquireVirtualMemory().\n%\n%  The format of the RelinquishVirtualMemory method is:\n%\n%      MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n{\n  assert(memory_info != (MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickSignature);\n  if (memory_info->blob != (void *) NULL)\n    switch (memory_info->type)\n    {\n      case AlignedVirtualMemory:\n      {\n        memory_info->blob=RelinquishAlignedMemory(memory_info->blob);\n        RelinquishMagickResource(MemoryResource,memory_info->length);\n        break;\n      }\n      case MapVirtualMemory:\n      {\n        (void) UnmapBlob(memory_info->blob,memory_info->length);\n        memory_info->blob=NULL;\n        RelinquishMagickResource(MapResource,memory_info->length);\n        if (*memory_info->filename != '\\0')\n          {\n            (void) RelinquishUniqueFileResource(memory_info->filename);\n            RelinquishMagickResource(DiskResource,memory_info->length);\n          }\n        break;\n      }\n      case UnalignedVirtualMemory:\n      default:\n      {\n        memory_info->blob=RelinquishMagickMemory(memory_info->blob);\n        break;\n      }\n    }\n  memory_info->signature=(~MagickSignature);\n  memory_info=(MemoryInfo *) RelinquishAlignedMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t M a g i c k M e m o r y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetMagickMemory() fills the first size bytes of the memory area pointed to\n%  by memory with the constant byte c.\n%\n%  The format of the ResetMagickMemory method is:\n%\n%      void *ResetMagickMemory(void *memory,int byte,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: a pointer to a memory allocation.\n%\n%    o byte: set the memory to this value.\n%\n%    o size: size of the memory to reset.\n%\n*/\nMagickExport void *ResetMagickMemory(void *memory,int byte,const size_t size)\n{\n  assert(memory != (void *) NULL);\n  return(memset(memory,byte,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e M a g i c k M e m o r y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeMagickMemory() changes the size of the memory and returns a pointer to\n%  the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeMagickMemory method is:\n%\n%      void *ResizeMagickMemory(void *memory,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o size: the new size of the allocated memory.\n%\n*/\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic inline void *ResizeBlock(void *block,size_t size)\n{\n  register void\n    *memory;\n\n  if (block == (void *) NULL)\n    return(AcquireBlock(size));\n  memory=AcquireBlock(size);\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n  if (size <= (SizeOfBlock(block)-sizeof(size_t)))\n    (void) memcpy(memory,block,size);\n  else\n    (void) memcpy(memory,block,SizeOfBlock(block)-sizeof(size_t));\n  memory_pool.allocation+=size;\n  return(memory);\n}\n#endif\n\nMagickExport void *ResizeMagickMemory(void *memory,const size_t size)\n{\n  register void\n    *block;\n\n  if (memory == (void *) NULL)\n    return(AcquireMagickMemory(size));\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  block=memory_methods.resize_memory_handler(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    memory=RelinquishMagickMemory(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  block=ResizeBlock(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) == MagickFalse)\n        {\n          UnlockSemaphoreInfo(memory_semaphore);\n          memory=RelinquishMagickMemory(memory);\n          ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n        }\n      block=ResizeBlock(memory,size == 0 ? 1UL : size);\n      assert(block != (void *) NULL);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n  memory=RelinquishMagickMemory(memory);\n#endif\n  return(block);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e Q u a n t u m M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeQuantumMemory() changes the size of the memory and returns a pointer\n%  to the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeQuantumMemory method is:\n%\n%      void *ResizeQuantumMemory(void *memory,const size_t count,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMagickMemoryMethods() sets the methods to acquire, resize, and destroy\n%  memory. Your custom memory methods must be set prior to the\n%  MagickCoreGenesis() method.\n%\n%  The format of the SetMagickMemoryMethods() method is:\n%\n%      SetMagickMemoryMethods(AcquireMemoryHandler acquire_memory_handler,\n%        ResizeMemoryHandler resize_memory_handler,\n%        DestroyMemoryHandler destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void SetMagickMemoryMethods(\n  AcquireMemoryHandler acquire_memory_handler,\n  ResizeMemoryHandler resize_memory_handler,\n  DestroyMemoryHandler destroy_memory_handler)\n{\n  /*\n    Set memory methods.\n  */\n  if (acquire_memory_handler != (AcquireMemoryHandler) NULL)\n    memory_methods.acquire_memory_handler=acquire_memory_handler;\n  if (resize_memory_handler != (ResizeMemoryHandler) NULL)\n    memory_methods.resize_memory_handler=resize_memory_handler;\n  if (destroy_memory_handler != (DestroyMemoryHandler) NULL)\n    memory_methods.destroy_memory_handler=destroy_memory_handler;\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     L       AAA   BBBB   EEEEE  L                           %\n%                     L      A   A  B   B  E      L                           %\n%                     L      AAAAA  BBBB   EEE    L                           %\n%                     L      A   A  B   B  E      L                           %\n%                     LLLLL  A   A  BBBB   EEEEE  LLLLL                       %\n%                                                                             %\n%                                                                             %\n%                      Read ASCII String As An Image.                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/annotate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/draw.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n#include \"magick/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d L A B E L I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadLABELImage() reads a LABEL image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadLABELImage method is:\n%\n%      Image *ReadLABELImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadLABELImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MaxTextExtent],\n    *property;\n\n  const char\n    *label;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  property=InterpretImageProperties(image_info,image,image_info->filename);\n  (void) SetImageProperty(image,\"label\",property);\n  property=DestroyString(property);\n  label=GetImageProperty(image,\"label\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->text=ConstantString(label);\n  metrics.width=0;\n  metrics.ascent=0.0;\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if ((image->columns == 0) && (image->rows == 0))\n    {\n      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n    }\n  else\n    if (((image->columns == 0) || (image->rows == 0)) ||\n        (fabs(image_info->pointsize) < MagickEpsilon))\n      {\n        double\n          high,\n          low;\n\n        /*\n          Auto fit text into bounding box.\n        */\n        for ( ; ; draw_info->pointsize*=2.0)\n        {\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width >= image->columns) && (height >= image->rows))\n                break;\n            }\n          else\n            if (((image->columns != 0) && (width >= image->columns)) ||\n                ((image->rows != 0) && (height >= image->rows)))\n              break;\n        }\n        high=draw_info->pointsize;\n        for (low=1.0; (high-low) > 0.5; )\n        {\n          draw_info->pointsize=(low+high)/2.0;\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width < image->columns) && (height < image->rows))\n                low=draw_info->pointsize+0.5;\n              else\n                high=draw_info->pointsize-0.5;\n            }\n          else\n            if (((image->columns != 0) && (width < image->columns)) ||\n                ((image->rows != 0) && (height < image->rows)))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n        }\n        draw_info->pointsize=(low+high)/2.0-0.5;\n      }\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image->columns == 0)\n    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n  if (image->columns == 0)\n    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(metrics.ascent-metrics.descent+\n      draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Draw label.\n  */\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n    metrics.ascent : 0.0);\n  draw_info->geometry=AcquireString(geometry);\n  status=AnnotateImage(image,draw_info);\n  if (image_info->pointsize == 0.0)\n    {\n      char\n        pointsize[MaxTextExtent];\n\n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"label:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r L A B E L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterLABELImage() adds properties for the LABEL image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterLABELImage method is:\n%\n%      size_t RegisterLABELImage(void)\n%\n*/\nModuleExport size_t RegisterLABELImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"LABEL\");\n  entry->decoder=(DecodeImageHandler *) ReadLABELImage;\n  entry->adjoin=MagickFalse;\n  entry->format_type=ImplicitFormatType;\n  entry->description=ConstantString(\"Image label\");\n  entry->module=ConstantString(\"LABEL\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r L A B E L I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterLABELImage() removes format registrations made by the\n%  LABEL module from the list of supported formats.\n%\n%  The format of the UnregisterLABELImage method is:\n%\n%      UnregisterLABELImage(void)\n%\n*/\nModuleExport void UnregisterLABELImage(void)\n{\n  (void) UnregisterMagickInfo(\"LABEL\");\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    (void) ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            if (AcquireImageColormap(image,image->colors) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                (unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                  (unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n    image->storage_class=\n      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(MagickRealType) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        if (image->storage_class != PseudoClass)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(indexes+x+bit,quantum);\n             }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(indexes+x+bit,quantum);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n            SetPixelIndex(indexes+x,*p++);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].red);\n                  index=(ssize_t) GetPixelGreen(q);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].green);\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].blue);\n                }\n              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n              p++;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"VIFF\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  entry->description=ConstantString(\"Khoros Visualization image\");\n  entry->module=ConstantString(\"VIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"XV\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->description=ConstantString(\"Khoros Visualization image\");\n  entry->module=ConstantString(\"VIFF\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\");\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->matte ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,&image->exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(p));\n            if (image->matte != MagickFalse)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(p)));\n            p++;\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            (void) SetImageType(image,BilevelType);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p++;\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        EEEEE  X   X   CCCC  EEEEE  PPPP  TTTTT  IIIII   OOO   N   N         %\n%        E       X X   C      E      P   P   T      I    O   O  NN  N         %\n%        EEE      X    C      EEE    PPPP    T      I    O   O  N N N         %\n%        E       X X   C      E      P       T      I    O   O  N  NN         %\n%        EEEEE   X  X   CCCC  EEEEE  P       T    IIIII   OOO   N   N         %\n%                                                                             %\n%                                                                             %\n%                        MagickCore Exception Methods                         %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                                July 1993                                    %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/client.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/locale_.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/string_.h\"\n#include \"magick/utility.h\"\n\f\n/*\n  Global declarations.\n*/\n#define MaxExceptions  128\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic void\n  DefaultErrorHandler(const ExceptionType,const char *,const char *),\n  DefaultFatalErrorHandler(const ExceptionType,const char *,const char *),\n  DefaultWarningHandler(const ExceptionType,const char *,const char *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic ErrorHandler\n  error_handler = DefaultErrorHandler;\n\nstatic FatalErrorHandler\n  fatal_error_handler = DefaultFatalErrorHandler;\n\nstatic WarningHandler\n  warning_handler = DefaultWarningHandler;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e E x c e p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireExceptionInfo() allocates the ExceptionInfo structure.\n%\n%  The format of the AcquireExceptionInfo method is:\n%\n%      ExceptionInfo *AcquireExceptionInfo(void)\n%\n*/\nMagickExport ExceptionInfo *AcquireExceptionInfo(void)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) AcquireMagickMemory(sizeof(*exception));\n  if (exception == (ExceptionInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  InitializeExceptionInfo(exception);\n  exception->relinquish=MagickTrue;\n  return(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l e a r M a g i c k E x c e p t i o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClearMagickException() clears any exception that may not have been caught\n%  yet.\n%\n%  The format of the ClearMagickException method is:\n%\n%      ClearMagickException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\n\nstatic void *DestroyExceptionElement(void *exception)\n{\n  register ExceptionInfo\n    *p;\n\n  p=(ExceptionInfo *) exception;\n  if (p->reason != (char *) NULL)\n    p->reason=DestroyString(p->reason);\n  if (p->description != (char *) NULL)\n    p->description=DestroyString(p->description);\n  p=(ExceptionInfo *) RelinquishMagickMemory(p);\n  return((void *) NULL);\n}\n\nMagickExport void ClearMagickException(ExceptionInfo *exception)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->exceptions == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ClearLinkedList((LinkedListInfo *) exception->exceptions,\n    DestroyExceptionElement);\n  exception->severity=UndefinedException;\n  exception->reason=(char *) NULL;\n  exception->description=(char *) NULL;\n  UnlockSemaphoreInfo(exception->semaphore);\n  errno=0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h E x c e p t i o n                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchException() returns if no exceptions is found otherwise it reports\n%  the exception as a warning, error, or fatal depending on the severity.\n%\n%  The format of the CatchException method is:\n%\n%      CatchException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n\n  ssize_t\n    i;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  for (i=0; p != (const ExceptionInfo *) NULL; i++)\n  {\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    if (i < MaxExceptions)\n      {\n        if ((p->severity >= ErrorException) && \n            (p->severity < FatalErrorException))\n          MagickError(p->severity,p->reason,p->description);\n        if ((p->severity >= WarningException) && (p->severity < ErrorException))\n          MagickWarning(p->severity,p->reason,p->description);\n      }\n    else\n      if (i == MaxExceptions)\n        MagickError(ResourceLimitError,\"too many exceptions\",\n          \"exception processing suspended\");\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e E x c e p t i o n I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneExceptionInfo() clones the ExceptionInfo structure.\n%\n%  The format of the CloneExceptionInfo method is:\n%\n%      ExceptionInfo *CloneException(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickExport ExceptionInfo *CloneExceptionInfo(ExceptionInfo *exception)\n{\n  ExceptionInfo\n    *clone_exception;\n\n  clone_exception=(ExceptionInfo *) AcquireMagickMemory(sizeof(*exception));\n  if (clone_exception == (ExceptionInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  InitializeExceptionInfo(clone_exception);\n  InheritException(clone_exception,exception);\n  clone_exception->relinquish=MagickTrue;\n  return(clone_exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t E r r o r H a n d l e r                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultErrorHandler() displays an error reason.\n%\n%  The format of the DefaultErrorHandler method is:\n%\n%      void MagickError(const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultErrorHandler(const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t F a t a l E r r o r H a n d l e r                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultFatalErrorHandler() displays an error reason and then terminates the\n%  program.\n%\n%  The format of the DefaultFatalErrorHandler method is:\n%\n%      void MagickFatalError(const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultFatalErrorHandler(const ExceptionType severity,\n  const char *reason,const char *description)\n{\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n  MagickCoreTerminus();\n  exit((int) (severity-FatalErrorException)+1);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e f a u l t W a r n i n g H a n d l e r                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefaultWarningHandler() displays a warning reason.\n%\n%  The format of the DefaultWarningHandler method is:\n%\n%      void DefaultWarningHandler(const ExceptionType severity,\n%        const char *reason,const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o severity: Specifies the numeric warning category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nstatic void DefaultWarningHandler(const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y E x c e p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyExceptionInfo() deallocates memory associated with an exception.\n%\n%  The format of the DestroyExceptionInfo method is:\n%\n%      ExceptionInfo *DestroyExceptionInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\n\nMagickPrivate MagickBooleanType ClearExceptionInfo(ExceptionInfo *exception,\n  MagickBooleanType relinquish)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (exception->semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&exception->semaphore);\n  LockSemaphoreInfo(exception->semaphore);\n  if (relinquish == MagickFalse)\n    relinquish=exception->relinquish;\n  exception->severity=UndefinedException;\n  if (relinquish != MagickFalse)\n    {\n      exception->signature=(~MagickSignature);\n      if (exception->exceptions != (void *) NULL)\n        exception->exceptions=(void *) DestroyLinkedList((LinkedListInfo *)\n          exception->exceptions,DestroyExceptionElement);\n    }\n  else if (exception->exceptions != (void *) NULL)\n    ClearLinkedList((LinkedListInfo *) exception->exceptions,\n      DestroyExceptionElement);\n  UnlockSemaphoreInfo(exception->semaphore);\n  if (relinquish != MagickFalse)\n    DestroySemaphoreInfo(&exception->semaphore);\n  return(relinquish);\n}\n\nMagickExport ExceptionInfo *DestroyExceptionInfo(ExceptionInfo *exception)\n{\n  if (ClearExceptionInfo(exception,MagickFalse) != MagickFalse)\n    exception=(ExceptionInfo *) RelinquishMagickMemory(exception);\n  return(exception);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t E x c e p t i o n M e s s a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetExceptionMessage() returns the error message defined by the specified\n%  error code.\n%\n%  The format of the GetExceptionMessage method is:\n%\n%      char *GetExceptionMessage(const int error)\n%\n%  A description of each parameter follows:\n%\n%    o error: the error code.\n%\n*/\nMagickExport char *GetExceptionMessage(const int error)\n{\n  char\n    exception[MaxTextExtent];\n\n  *exception='\\0';\n#if defined(MAGICKCORE_HAVE_STRERROR_R)\n#if !defined(MAGICKCORE_STRERROR_R_CHAR_P)\n  (void) strerror_r(error,exception,sizeof(exception));\n#else\n  (void) CopyMagickString(exception,strerror_r(error,exception,\n    sizeof(exception)),sizeof(exception));\n#endif\n#else\n  (void) CopyMagickString(exception,strerror(error),sizeof(exception));\n#endif\n  return(ConstantString(exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e E x c e p t i o n M e s s a g e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleExceptionMessage() converts a enumerated exception severity and tag\n%  to a message in the current locale.\n%\n%  The format of the GetLocaleExceptionMessage method is:\n%\n%      const char *GetLocaleExceptionMessage(const ExceptionType severity,\n%        const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o severity: the severity of the exception.\n%\n%    o tag: the message tag.\n%\n*/\n\nstatic const char *ExceptionSeverityToTag(const ExceptionType severity)\n{\n  switch (severity)\n  {\n    case ResourceLimitWarning: return(\"Resource/Limit/Warning/\");\n    case TypeWarning: return(\"Type/Warning/\");\n    case OptionWarning: return(\"Option/Warning/\");\n    case DelegateWarning: return(\"Delegate/Warning/\");\n    case MissingDelegateWarning: return(\"Missing/Delegate/Warning/\");\n    case CorruptImageWarning: return(\"Corrupt/Image/Warning/\");\n    case FileOpenWarning: return(\"File/Open/Warning/\");\n    case BlobWarning: return(\"Blob/Warning/\");\n    case StreamWarning: return(\"Stream/Warning/\");\n    case CacheWarning: return(\"Cache/Warning/\");\n    case CoderWarning: return(\"Coder/Warning/\");\n    case FilterWarning: return(\"Filter/Warning/\");\n    case ModuleWarning: return(\"Module/Warning/\");\n    case DrawWarning: return(\"Draw/Warning/\");\n    case ImageWarning: return(\"Image/Warning/\");\n    case WandWarning: return(\"Wand/Warning/\");\n    case XServerWarning: return(\"XServer/Warning/\");\n    case MonitorWarning: return(\"Monitor/Warning/\");\n    case RegistryWarning: return(\"Registry/Warning/\");\n    case ConfigureWarning: return(\"Configure/Warning/\");\n    case PolicyWarning: return(\"Policy/Warning/\");\n    case ResourceLimitError: return(\"Resource/Limit/Error/\");\n    case TypeError: return(\"Type/Error/\");\n    case OptionError: return(\"Option/Error/\");\n    case DelegateError: return(\"Delegate/Error/\");\n    case MissingDelegateError: return(\"Missing/Delegate/Error/\");\n    case CorruptImageError: return(\"Corrupt/Image/Error/\");\n    case FileOpenError: return(\"File/Open/Error/\");\n    case BlobError: return(\"Blob/Error/\");\n    case StreamError: return(\"Stream/Error/\");\n    case CacheError: return(\"Cache/Error/\");\n    case CoderError: return(\"Coder/Error/\");\n    case FilterError: return(\"Filter/Error/\");\n    case ModuleError: return(\"Module/Error/\");\n    case DrawError: return(\"Draw/Error/\");\n    case ImageError: return(\"Image/Error/\");\n    case WandError: return(\"Wand/Error/\");\n    case XServerError: return(\"XServer/Error/\");\n    case MonitorError: return(\"Monitor/Error/\");\n    case RegistryError: return(\"Registry/Error/\");\n    case ConfigureError: return(\"Configure/Error/\");\n    case PolicyError: return(\"Policy/Error/\");\n    case ResourceLimitFatalError: return(\"Resource/Limit/FatalError/\");\n    case TypeFatalError: return(\"Type/FatalError/\");\n    case OptionFatalError: return(\"Option/FatalError/\");\n    case DelegateFatalError: return(\"Delegate/FatalError/\");\n    case MissingDelegateFatalError: return(\"Missing/Delegate/FatalError/\");\n    case CorruptImageFatalError: return(\"Corrupt/Image/FatalError/\");\n    case FileOpenFatalError: return(\"File/Open/FatalError/\");\n    case BlobFatalError: return(\"Blob/FatalError/\");\n    case StreamFatalError: return(\"Stream/FatalError/\");\n    case CacheFatalError: return(\"Cache/FatalError/\");\n    case CoderFatalError: return(\"Coder/FatalError/\");\n    case FilterFatalError: return(\"Filter/FatalError/\");\n    case ModuleFatalError: return(\"Module/FatalError/\");\n    case DrawFatalError: return(\"Draw/FatalError/\");\n    case ImageFatalError: return(\"Image/FatalError/\");\n    case WandFatalError: return(\"Wand/FatalError/\");\n    case XServerFatalError: return(\"XServer/FatalError/\");\n    case MonitorFatalError: return(\"Monitor/FatalError/\");\n    case RegistryFatalError: return(\"Registry/FatalError/\");\n    case ConfigureFatalError: return(\"Configure/FatalError/\");\n    case PolicyFatalError: return(\"Policy/FatalError/\");\n    default: break;\n  }\n  return(\"\");\n}\n\nMagickExport const char *GetLocaleExceptionMessage(const ExceptionType severity,\n  const char *tag)\n{\n  char\n    message[MaxTextExtent];\n\n  const char\n    *locale_message;\n\n  assert(tag != (const char *) NULL);\n  (void) FormatLocaleString(message,MaxTextExtent,\"Exception/%s%s\",\n    ExceptionSeverityToTag(severity),tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == (const char *) NULL)\n    return(tag);\n  if (locale_message == message)\n    return(tag);\n  return(locale_message);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n h e r i t E x c e p t i o n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InheritException() inherits an exception from a related exception.\n%\n%  The format of the InheritException method is:\n%\n%      InheritException(ExceptionInfo *exception,const ExceptionInfo *relative)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o relative: the related exception info.\n%\n*/\nMagickExport void InheritException(ExceptionInfo *exception,\n  const ExceptionInfo *relative)\n{\n  register const ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  assert(relative != (ExceptionInfo *) NULL);\n  assert(relative->signature == MagickSignature);\n  assert(exception != relative);\n  if (relative->exceptions == (void *) NULL)\n    return;\n  LockSemaphoreInfo(relative->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) relative->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    relative->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    (void) ThrowException(exception,p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      relative->exceptions);\n  }\n  UnlockSemaphoreInfo(relative->semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n i t i a l i z e E x c e p t i o n I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InitializeExceptionInfo() initializes an exception to default values.\n%\n%  The format of the InitializeExceptionInfo method is:\n%\n%      InitializeExceptionInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n*/\nMagickPrivate void InitializeExceptionInfo(ExceptionInfo *exception)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) ResetMagickMemory(exception,0,sizeof(*exception));\n  exception->severity=UndefinedException;\n  exception->exceptions=(void *) NewLinkedList(0);\n  exception->semaphore=AllocateSemaphoreInfo();\n  exception->signature=MagickSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k E r r o r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickError() calls the exception handler methods with an error reason.\n%\n%  The format of the MagickError method is:\n%\n%      void MagickError(const ExceptionType error,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nMagickExport void MagickError(const ExceptionType error,const char *reason,\n  const char *description)\n{\n  if (error_handler != (ErrorHandler) NULL)\n    (*error_handler)(error,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k F a t al E r r o r                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickFatalError() calls the fatal exception handler methods with an error\n%  reason.\n%\n%  The format of the MagickError method is:\n%\n%      void MagickFatalError(const ExceptionType error,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: Specifies the numeric error category.\n%\n%    o reason: Specifies the reason to display before terminating the\n%      program.\n%\n%    o description: Specifies any description to the reason.\n%\n*/\nMagickExport void MagickFatalError(const ExceptionType error,const char *reason,\n  const char *description)\n{\n  if (fatal_error_handler != (ErrorHandler) NULL)\n    (*fatal_error_handler)(error,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M a g i c k W a r n i n g                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickWarning() calls the warning handler methods with a warning reason.\n%\n%  The format of the MagickWarning method is:\n%\n%      void MagickWarning(const ExceptionType warning,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o warning: the warning severity.\n%\n%    o reason: Define the reason for the warning.\n%\n%    o description: Describe the warning.\n%\n*/\nMagickExport void MagickWarning(const ExceptionType warning,const char *reason,\n  const char *description)\n{\n  if (warning_handler != (WarningHandler) NULL)\n    (*warning_handler)(warning,reason,description);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t E r r o r H a n d l e r                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetErrorHandler() sets the exception handler to the specified method\n%  and returns the previous exception handler.\n%\n%  The format of the SetErrorHandler method is:\n%\n%      ErrorHandler SetErrorHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle errors.\n%\n*/\nMagickExport ErrorHandler SetErrorHandler(ErrorHandler handler)\n{\n  ErrorHandler\n    previous_handler;\n\n  previous_handler=error_handler;\n  error_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t F a t a l E r r o r H a n d l e r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetFatalErrorHandler() sets the fatal exception handler to the specified\n%  method and returns the previous fatal exception handler.\n%\n%  The format of the SetErrorHandler method is:\n%\n%      ErrorHandler SetErrorHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle errors.\n%\n*/\nMagickExport FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)\n{\n  FatalErrorHandler\n    previous_handler;\n\n  previous_handler=fatal_error_handler;\n  fatal_error_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t W a r n i n g H a n d l e r                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetWarningHandler() sets the warning handler to the specified method\n%  and returns the previous warning handler.\n%\n%  The format of the SetWarningHandler method is:\n%\n%      ErrorHandler SetWarningHandler(ErrorHandler handler)\n%\n%  A description of each parameter follows:\n%\n%    o handler: the method to handle warnings.\n%\n*/\nMagickExport WarningHandler SetWarningHandler(WarningHandler handler)\n{\n  WarningHandler\n    previous_handler;\n\n  previous_handler=warning_handler;\n  warning_handler=handler;\n  return(previous_handler);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T h r o w E x c e p t i o n                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ThrowException() throws an exception with the specified severity code,\n%  reason, and optional description.\n%\n%  The format of the ThrowException method is:\n%\n%      MagickBooleanType ThrowException(ExceptionInfo *exception,\n%        const ExceptionType severity,const char *reason,\n%        const char *description)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o severity: the severity of the exception.\n%\n%    o reason: the reason for the exception.\n%\n%    o description: the exception description.\n%\n*/\nMagickExport MagickBooleanType ThrowException(ExceptionInfo *exception,\n  const ExceptionType severity,const char *reason,const char *description)\n{\n  register ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  LockSemaphoreInfo(exception->semaphore);\n  p=(ExceptionInfo *) GetLastValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  if ((p != (ExceptionInfo *) NULL) && (p->severity == severity) &&\n      (LocaleCompare(exception->reason,reason) == 0) &&\n      (LocaleCompare(exception->description,description) == 0))\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      return(MagickTrue);\n    }\n  p=(ExceptionInfo *) AcquireMagickMemory(sizeof(*p));\n  if (p == (ExceptionInfo *) NULL)\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(p,0,sizeof(*p));\n  p->severity=severity;\n  if (reason != (const char *) NULL)\n    p->reason=ConstantString(reason);\n  if (description != (const char *) NULL)\n    p->description=ConstantString(description);\n  p->signature=MagickSignature;\n  (void) AppendValueToLinkedList((LinkedListInfo *) exception->exceptions,p);\n  if (p->severity >= exception->severity)\n    {\n      exception->severity=p->severity;\n      exception->reason=p->reason;\n      exception->description=p->description;\n    }\n  UnlockSemaphoreInfo(exception->semaphore);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T h r o w M a g i c k E x c e p t i o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ThrowMagickException logs an exception as determined by the log configuration\n%  file.  If an error occurs, MagickFalse is returned otherwise MagickTrue.\n%\n%  The format of the ThrowMagickException method is:\n%\n%      MagickBooleanType ThrowFileException(ExceptionInfo *exception,\n%        const char *module,const char *function,const size_t line,\n%        const ExceptionType severity,const char *tag,const char *format,...)\n%\n%  A description of each parameter follows:\n%\n%    o exception: the exception info.\n%\n%    o filename: the source module filename.\n%\n%    o function: the function name.\n%\n%    o line: the line number of the source module.\n%\n%    o severity: Specifies the numeric error category.\n%\n%    o tag: the locale tag.\n%\n%    o format: the output format.\n%\n*/\n\nMagickExport MagickBooleanType ThrowMagickExceptionList(\n  ExceptionInfo *exception,const char *module,const char *function,\n  const size_t line,const ExceptionType severity,const char *tag,\n  const char *format,va_list operands)\n{\n  char\n    message[MaxTextExtent],\n    path[MaxTextExtent],\n    reason[MaxTextExtent];\n\n  const char\n    *locale,\n    *type;\n\n  int\n    n;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  locale=GetLocaleExceptionMessage(severity,tag);\n  (void) CopyMagickString(reason,locale,MaxTextExtent);\n  (void) ConcatenateMagickString(reason,\" \",MaxTextExtent);\n  length=strlen(reason);\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  n=vsnprintf(reason+length,MaxTextExtent-length,format,operands);\n#else\n  n=vsprintf(reason+length,format,operands);\n#endif\n  if (n < 0)\n    reason[MaxTextExtent-1]='\\0';\n  status=LogMagickEvent(ExceptionEvent,module,function,line,\"%s\",reason);\n  GetPathComponent(module,TailPath,path);\n  type=\"undefined\";\n  if ((severity >= WarningException) && (severity < ErrorException))\n    type=\"warning\";\n  if ((severity >= ErrorException) && (severity < FatalErrorException))\n    type=\"error\";\n  if (severity >= FatalErrorException)\n    type=\"fatal\";\n  (void) FormatLocaleString(message,MaxTextExtent,\"%s @ %s/%s/%s/%.20g\",reason,\n    type,path,function,(double) line);\n  (void) ThrowException(exception,severity,message,(char *) NULL);\n  return(status);\n}\n\nMagickExport MagickBooleanType ThrowMagickException(ExceptionInfo *exception,\n  const char *module,const char *function,const size_t line,\n  const ExceptionType severity,const char *tag,const char *format,...)\n{\n  MagickBooleanType\n    status;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  status=ThrowMagickExceptionList(exception,module,function,line,severity,tag,\n    format,operands);\n  va_end(operands);\n  return(status);\n}\n", "/*\n  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n  \n  You may not use this file except in compliance with the License.\n  obtain a copy of the License at\n  \n    http://www.imagemagick.org/script/license.php\n  \n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore private memory methods.\n*/\n#ifndef _MAGICKCORE_MEMORY_PRIVATE_H\n#define _MAGICKCORE_MEMORY_PRIVATE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(MAGICK_TARGET_CPU) && (MAGICK_TARGET_CPU == powerpc)\n#  define CACHE_LINE_SIZE 128\n#else\n#  define CACHE_LINE_SIZE 64\n#endif\n\n#define CacheAlign(size)  ((size) < CACHE_LINE_SIZE ? CACHE_LINE_SIZE : (size))\n\n#if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 6))\n#if !defined(__ICC)\n#define MagickAssumeAligned(address) \\\n  __builtin_assume_aligned((address),CACHE_LINE_SIZE)\n#else\n#define MagickAssumeAligned(address)  (address)\n#endif\n#else\n#define MagickAssumeAligned(address)  (address)\n#endif\n\nMagickExport MagickBooleanType\n  HeapOverflowSanityCheck(const size_t,const size_t) magick_alloc_sizes(1,2);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                    M   M  EEEEE  M   M   OOO   RRRR   Y   Y                 %\n%                    MM MM  E      MM MM  O   O  R   R   Y Y                  %\n%                    M M M  EEE    M M M  O   O  RRRR     Y                   %\n%                    M   M  E      M   M  O   O  R R      Y                   %\n%                    M   M  EEEEE  M   M   OOO   R  R     Y                   %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Memory Allocation Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Segregate our memory requirements from any program that calls our API.  This\n%  should help reduce the risk of others changing our program state or causing\n%  memory corruption.\n%\n%  Our custom memory allocation manager implements a best-fit allocation policy\n%  using segregated free lists.  It uses a linear distribution of size classes\n%  for lower sizes and a power of two distribution of size classes at higher\n%  sizes.  It is based on the paper, \"Fast Memory Allocation using Lazy Fits.\"\n%  written by Yoo C. Chung.\n%\n%  By default, ANSI memory methods are called (e.g. malloc).  Use the\n%  custom memory allocator by defining MAGICKCORE_ZERO_CONFIGURATION_SUPPORT\n%  to allocate memory with private anonymous mapping rather than from the\n%  heap.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/string_.h\"\n#include \"magick/utility-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define BlockFooter(block,size) \\\n  ((size_t *) ((char *) (block)+(size)-2*sizeof(size_t)))\n#define BlockHeader(block)  ((size_t *) (block)-1)\n#define BlockSize  4096\n#define BlockThreshold  1024\n#define MaxBlockExponent  16\n#define MaxBlocks ((BlockThreshold/(4*sizeof(size_t)))+MaxBlockExponent+1)\n#define MaxSegments  1024\n#define MemoryGuard  ((0xdeadbeef << 31)+0xdeafdeed)\n#define NextBlock(block)  ((char *) (block)+SizeOfBlock(block))\n#define NextBlockInList(block)  (*(void **) (block))\n#define PreviousBlock(block)  ((char *) (block)-(*((size_t *) (block)-2)))\n#define PreviousBlockBit  0x01\n#define PreviousBlockInList(block)  (*((void **) (block)+1))\n#define SegmentSize  (2*1024*1024)\n#define SizeMask  (~0x01)\n#define SizeOfBlock(block)  (*BlockHeader(block) & SizeMask)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  UndefinedVirtualMemory,\n  AlignedVirtualMemory,\n  MapVirtualMemory,\n  UnalignedVirtualMemory\n} VirtualMemoryType;\n\ntypedef struct _DataSegmentInfo\n{\n  void\n    *allocation,\n    *bound;\n\n  MagickBooleanType\n    mapped;\n\n  size_t\n    length;\n\n  struct _DataSegmentInfo\n    *previous,\n    *next;\n} DataSegmentInfo;\n\ntypedef struct _MagickMemoryMethods\n{\n  AcquireMemoryHandler\n    acquire_memory_handler;\n\n  ResizeMemoryHandler\n    resize_memory_handler;\n\n  DestroyMemoryHandler\n    destroy_memory_handler;\n} MagickMemoryMethods;\n\nstruct _MemoryInfo\n{\n  char\n    filename[MaxTextExtent];\n\n  VirtualMemoryType\n    type;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  size_t\n    signature;\n};\n\ntypedef struct _MemoryPool\n{\n  size_t\n    allocation;\n\n  void\n    *blocks[MaxBlocks+1];\n\n  size_t\n    number_segments;\n\n  DataSegmentInfo\n    *segments[MaxSegments],\n    segment_pool[MaxSegments];\n} MemoryPool;\n\f\n/*\n  Global declarations.\n*/\n#if defined _MSC_VER\nstatic void* MSCMalloc(size_t size)\n{\n  return malloc(size);\n}\nstatic void* MSCRealloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\nstatic void MSCFree(void* ptr)\n{\n  free(ptr);\n}\n#endif\n\nstatic MagickMemoryMethods\n  memory_methods =\n  {\n#if defined _MSC_VER\n    (AcquireMemoryHandler) MSCMalloc,\n    (ResizeMemoryHandler) MSCRealloc,\n    (DestroyMemoryHandler) MSCFree\n#else\n    (AcquireMemoryHandler) malloc,\n    (ResizeMemoryHandler) realloc,\n    (DestroyMemoryHandler) free\n#endif\n  };\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic MemoryPool\n  memory_pool;\n\nstatic SemaphoreInfo\n  *memory_semaphore = (SemaphoreInfo *) NULL;\n\nstatic volatile DataSegmentInfo\n  *free_segments = (DataSegmentInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  ExpandHeap(size_t);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e A l i g n e d M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireAlignedMemory() returns a pointer to a block of memory at least size\n%  bytes whose address is a multiple of 16*sizeof(void *).\n%\n%  The format of the AcquireAlignedMemory method is:\n%\n%      void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n\n  size_t\n    alignment,\n    extent,\n    size;\n\n  void\n    *memory;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e B l o c k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireBlock() returns a pointer to a block of memory at least size bytes\n%  suitably aligned for any use.\n%\n%  The format of the AcquireBlock method is:\n%\n%      void *AcquireBlock(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\n\nstatic inline size_t AllocationPolicy(size_t size)\n{\n  register size_t\n    blocksize;\n\n  /*\n    The linear distribution.\n  */\n  assert(size != 0);\n  assert(size % (4*sizeof(size_t)) == 0);\n  if (size <= BlockThreshold)\n    return(size/(4*sizeof(size_t)));\n  /*\n    Check for the largest block size.\n  */\n  if (size > (size_t) (BlockThreshold*(1L << (MaxBlockExponent-1L))))\n    return(MaxBlocks-1L);\n  /*\n    Otherwise use a power of two distribution.\n  */\n  blocksize=BlockThreshold/(4*sizeof(size_t));\n  for ( ; size > BlockThreshold; size/=2)\n    blocksize++;\n  assert(blocksize > (BlockThreshold/(4*sizeof(size_t))));\n  assert(blocksize < (MaxBlocks-1L));\n  return(blocksize);\n}\n\nstatic inline void InsertFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  size_t\n    size;\n\n  size=SizeOfBlock(block);\n  previous=(void *) NULL;\n  next=memory_pool.blocks[i];\n  while ((next != (void *) NULL) && (SizeOfBlock(next) < size))\n  {\n    previous=next;\n    next=NextBlockInList(next);\n  }\n  PreviousBlockInList(block)=previous;\n  NextBlockInList(block)=next;\n  if (previous != (void *) NULL)\n    NextBlockInList(previous)=block;\n  else\n    memory_pool.blocks[i]=block;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=block;\n}\n\nstatic inline void RemoveFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  next=NextBlockInList(block);\n  previous=PreviousBlockInList(block);\n  if (previous == (void *) NULL)\n    memory_pool.blocks[i]=next;\n  else\n    NextBlockInList(previous)=next;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=previous;\n}\n\nstatic void *AcquireBlock(size_t size)\n{\n  register size_t\n    i;\n\n  register void\n    *block;\n\n  /*\n    Find free block.\n  */\n  size=(size_t) (size+sizeof(size_t)+6*sizeof(size_t)-1) & -(4U*sizeof(size_t));\n  i=AllocationPolicy(size);\n  block=memory_pool.blocks[i];\n  while ((block != (void *) NULL) && (SizeOfBlock(block) < size))\n    block=NextBlockInList(block);\n  if (block == (void *) NULL)\n    {\n      i++;\n      while (memory_pool.blocks[i] == (void *) NULL)\n        i++;\n      block=memory_pool.blocks[i];\n      if (i >= MaxBlocks)\n        return((void *) NULL);\n    }\n  assert((*BlockHeader(NextBlock(block)) & PreviousBlockBit) == 0);\n  assert(SizeOfBlock(block) >= size);\n  RemoveFreeBlock(block,AllocationPolicy(SizeOfBlock(block)));\n  if (SizeOfBlock(block) > size)\n    {\n      size_t\n        blocksize;\n\n      void\n        *next;\n\n      /*\n        Split block.\n      */\n      next=(char *) block+size;\n      blocksize=SizeOfBlock(block)-size;\n      *BlockHeader(next)=blocksize;\n      *BlockFooter(next,blocksize)=blocksize;\n      InsertFreeBlock(next,AllocationPolicy(blocksize));\n      *BlockHeader(block)=size | (*BlockHeader(block) & ~SizeMask);\n    }\n  assert(size == SizeOfBlock(block));\n  *BlockHeader(NextBlock(block))|=PreviousBlockBit;\n  memory_pool.allocation+=size;\n  return(block);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireMagickMemory() returns a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireMagickMemory method is:\n%\n%      void *AcquireMagickMemory(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumMemory() returns a pointer to a block of memory at least\n%  count * quantum bytes suitably aligned for any use.\n%\n%  The format of the AcquireQuantumMemory method is:\n%\n%      void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e V i r t u a l M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireVirtualMemory() allocates a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireVirtualMemory method is:\n%\n%      MemoryInfo *AcquireVirtualMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename='\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y M a g i c k M e m o r y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyMagickMemory() copies size bytes from memory area source to the\n%  destination.  Copying between objects that overlap will take place\n%  correctly.  It returns destination.\n%\n%  The format of the CopyMagickMemory method is:\n%\n%      void *CopyMagickMemory(void *destination,const void *source,\n%        const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o destination: the destination.\n%\n%    o source: the source.\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *CopyMagickMemory(void *destination,const void *source,\n  const size_t size)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  assert(destination != (void *) NULL);\n  assert(source != (const void *) NULL);\n  p=(const unsigned char *) source;\n  q=(unsigned char *) destination;\n  if (((q+size) < p) || (q > (p+size)))\n    switch (size)\n    {\n      default: return(memcpy(destination,source,size));\n      case 8: *q++=(*p++);\n      case 7: *q++=(*p++);\n      case 6: *q++=(*p++);\n      case 5: *q++=(*p++);\n      case 4: *q++=(*p++);\n      case 3: *q++=(*p++);\n      case 2: *q++=(*p++);\n      case 1: *q++=(*p++);\n      case 0: return(destination);\n    }\n  return(memmove(destination,source,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyMagickMemory() deallocates memory associated with the memory manager.\n%\n%  The format of the DestroyMagickMemory method is:\n%\n%      DestroyMagickMemory(void)\n%\n*/\nMagickExport void DestroyMagickMemory(void)\n{\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  register ssize_t\n    i;\n\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  LockSemaphoreInfo(memory_semaphore);\n  for (i=0; i < (ssize_t) memory_pool.number_segments; i++)\n    if (memory_pool.segments[i]->mapped == MagickFalse)\n      memory_methods.destroy_memory_handler(\n        memory_pool.segments[i]->allocation);\n    else\n      (void) UnmapBlob(memory_pool.segments[i]->allocation,\n        memory_pool.segments[i]->length);\n  free_segments=(DataSegmentInfo *) NULL;\n  (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n  UnlockSemaphoreInfo(memory_semaphore);\n  DestroySemaphoreInfo(&memory_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p a n d H e a p                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExpandHeap() get more memory from the system.  It returns MagickTrue on\n%  success otherwise MagickFalse.\n%\n%  The format of the ExpandHeap method is:\n%\n%      MagickBooleanType ExpandHeap(size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes we require.\n%\n*/\nstatic MagickBooleanType ExpandHeap(size_t size)\n{\n  DataSegmentInfo\n    *segment_info;\n\n  MagickBooleanType\n    mapped;\n\n  register ssize_t\n    i;\n\n  register void\n    *block;\n\n  size_t\n    blocksize;\n\n  void\n    *segment;\n\n  blocksize=((size+12*sizeof(size_t))+SegmentSize-1) & -SegmentSize;\n  assert(memory_pool.number_segments < MaxSegments);\n  segment=MapBlob(-1,IOMode,0,blocksize);\n  mapped=segment != (void *) NULL ? MagickTrue : MagickFalse;\n  if (segment == (void *) NULL)\n    segment=(void *) memory_methods.acquire_memory_handler(blocksize);\n  if (segment == (void *) NULL)\n    return(MagickFalse);\n  segment_info=(DataSegmentInfo *) free_segments;\n  free_segments=segment_info->next;\n  segment_info->mapped=mapped;\n  segment_info->length=blocksize;\n  segment_info->allocation=segment;\n  segment_info->bound=(char *) segment+blocksize;\n  i=(ssize_t) memory_pool.number_segments-1;\n  for ( ; (i >= 0) && (memory_pool.segments[i]->allocation > segment); i--)\n    memory_pool.segments[i+1]=memory_pool.segments[i];\n  memory_pool.segments[i+1]=segment_info;\n  memory_pool.number_segments++;\n  size=blocksize-12*sizeof(size_t);\n  block=(char *) segment_info->allocation+4*sizeof(size_t);\n  *BlockHeader(block)=size | PreviousBlockBit;\n  *BlockFooter(block,size)=size;\n  InsertFreeBlock(block,AllocationPolicy(size));\n  block=NextBlock(block);\n  assert(block < segment_info->bound);\n  *BlockHeader(block)=2*sizeof(size_t);\n  *BlockHeader(NextBlock(block))=PreviousBlockBit;\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickMemoryMethods() gets the methods to acquire, resize, and destroy\n%  memory.\n%\n%  The format of the GetMagickMemoryMethods() method is:\n%\n%      void GetMagickMemoryMethods(AcquireMemoryHandler *acquire_memory_handler,\n%        ResizeMemoryHandler *resize_memory_handler,\n%        DestroyMemoryHandler *destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void GetMagickMemoryMethods(\n  AcquireMemoryHandler *acquire_memory_handler,\n  ResizeMemoryHandler *resize_memory_handler,\n  DestroyMemoryHandler *destroy_memory_handler)\n{\n  assert(acquire_memory_handler != (AcquireMemoryHandler *) NULL);\n  assert(resize_memory_handler != (ResizeMemoryHandler *) NULL);\n  assert(destroy_memory_handler != (DestroyMemoryHandler *) NULL);\n  *acquire_memory_handler=memory_methods.acquire_memory_handler;\n  *resize_memory_handler=memory_methods.resize_memory_handler;\n  *destroy_memory_handler=memory_methods.destroy_memory_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e m o r y B l o b                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMemoryBlob() returns the virtual memory blob associated with the\n%  specified MemoryInfo structure.\n%\n%  The format of the GetVirtualMemoryBlob method is:\n%\n%      void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: The MemoryInfo structure.\n*/\nMagickExport void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n{\n  assert(memory_info != (const MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickSignature);\n  return(memory_info->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   H e a p O v e r f l o w S a n i t y C h e c k                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  HeapOverflowSanityCheck() returns MagickTrue if the heap allocation request\n%  does not exceed the maximum limits of a size_t otherwise MagickFalse.\n%\n%  The format of the HeapOverflowSanityCheck method is:\n%\n%      MagickBooleanType HeapOverflowSanityCheck(const size_t count,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes we require.\n%\n*/\nMagickExport MagickBooleanType HeapOverflowSanityCheck(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h A l i g n e d M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishAlignedMemory() frees memory acquired with AcquireAlignedMemory()\n%  or reuse.\n%\n%  The format of the RelinquishAlignedMemory method is:\n%\n%      void *RelinquishAlignedMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h M a g i c k M e m o r y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishMagickMemory() frees memory acquired with AcquireMagickMemory()\n%  or AcquireQuantumMemory() for reuse.\n%\n%  The format of the RelinquishMagickMemory method is:\n%\n%      void *RelinquishMagickMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishMagickMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory_methods.destroy_memory_handler(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  assert((SizeOfBlock(memory) % (4*sizeof(size_t))) == 0);\n  assert((*BlockHeader(NextBlock(memory)) & PreviousBlockBit) != 0);\n  if ((*BlockHeader(memory) & PreviousBlockBit) == 0)\n    {\n      void\n        *previous;\n\n      /*\n        Coalesce with previous adjacent block.\n      */\n      previous=PreviousBlock(memory);\n      RemoveFreeBlock(previous,AllocationPolicy(SizeOfBlock(previous)));\n      *BlockHeader(previous)=(SizeOfBlock(previous)+SizeOfBlock(memory)) |\n        (*BlockHeader(previous) & ~SizeMask);\n      memory=previous;\n    }\n  if ((*BlockHeader(NextBlock(NextBlock(memory))) & PreviousBlockBit) == 0)\n    {\n      void\n        *next;\n\n      /*\n        Coalesce with next adjacent block.\n      */\n      next=NextBlock(memory);\n      RemoveFreeBlock(next,AllocationPolicy(SizeOfBlock(next)));\n      *BlockHeader(memory)=(SizeOfBlock(memory)+SizeOfBlock(next)) |\n        (*BlockHeader(memory) & ~SizeMask);\n    }\n  *BlockFooter(memory,SizeOfBlock(memory))=SizeOfBlock(memory);\n  *BlockHeader(NextBlock(memory))&=(~PreviousBlockBit);\n  InsertFreeBlock(memory,AllocationPolicy(SizeOfBlock(memory)));\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return((void *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h V i r t u a l M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishVirtualMemory() frees memory acquired with AcquireVirtualMemory().\n%\n%  The format of the RelinquishVirtualMemory method is:\n%\n%      MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n{\n  assert(memory_info != (MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickSignature);\n  if (memory_info->blob != (void *) NULL)\n    switch (memory_info->type)\n    {\n      case AlignedVirtualMemory:\n      {\n        memory_info->blob=RelinquishAlignedMemory(memory_info->blob);\n        RelinquishMagickResource(MemoryResource,memory_info->length);\n        break;\n      }\n      case MapVirtualMemory:\n      {\n        (void) UnmapBlob(memory_info->blob,memory_info->length);\n        memory_info->blob=NULL;\n        RelinquishMagickResource(MapResource,memory_info->length);\n        if (*memory_info->filename != '\\0')\n          {\n            (void) RelinquishUniqueFileResource(memory_info->filename);\n            RelinquishMagickResource(DiskResource,memory_info->length);\n          }\n        break;\n      }\n      case UnalignedVirtualMemory:\n      default:\n      {\n        memory_info->blob=RelinquishMagickMemory(memory_info->blob);\n        break;\n      }\n    }\n  memory_info->signature=(~MagickSignature);\n  memory_info=(MemoryInfo *) RelinquishAlignedMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t M a g i c k M e m o r y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetMagickMemory() fills the first size bytes of the memory area pointed to\n%  by memory with the constant byte c.\n%\n%  The format of the ResetMagickMemory method is:\n%\n%      void *ResetMagickMemory(void *memory,int byte,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: a pointer to a memory allocation.\n%\n%    o byte: set the memory to this value.\n%\n%    o size: size of the memory to reset.\n%\n*/\nMagickExport void *ResetMagickMemory(void *memory,int byte,const size_t size)\n{\n  assert(memory != (void *) NULL);\n  return(memset(memory,byte,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e M a g i c k M e m o r y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeMagickMemory() changes the size of the memory and returns a pointer to\n%  the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeMagickMemory method is:\n%\n%      void *ResizeMagickMemory(void *memory,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o size: the new size of the allocated memory.\n%\n*/\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic inline void *ResizeBlock(void *block,size_t size)\n{\n  register void\n    *memory;\n\n  if (block == (void *) NULL)\n    return(AcquireBlock(size));\n  memory=AcquireBlock(size);\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n  if (size <= (SizeOfBlock(block)-sizeof(size_t)))\n    (void) memcpy(memory,block,size);\n  else\n    (void) memcpy(memory,block,SizeOfBlock(block)-sizeof(size_t));\n  memory_pool.allocation+=size;\n  return(memory);\n}\n#endif\n\nMagickExport void *ResizeMagickMemory(void *memory,const size_t size)\n{\n  register void\n    *block;\n\n  if (memory == (void *) NULL)\n    return(AcquireMagickMemory(size));\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  block=memory_methods.resize_memory_handler(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    memory=RelinquishMagickMemory(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  block=ResizeBlock(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) == MagickFalse)\n        {\n          UnlockSemaphoreInfo(memory_semaphore);\n          memory=RelinquishMagickMemory(memory);\n          ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n        }\n      block=ResizeBlock(memory,size == 0 ? 1UL : size);\n      assert(block != (void *) NULL);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n  memory=RelinquishMagickMemory(memory);\n#endif\n  return(block);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e Q u a n t u m M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeQuantumMemory() changes the size of the memory and returns a pointer\n%  to the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeQuantumMemory method is:\n%\n%      void *ResizeQuantumMemory(void *memory,const size_t count,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMagickMemoryMethods() sets the methods to acquire, resize, and destroy\n%  memory. Your custom memory methods must be set prior to the\n%  MagickCoreGenesis() method.\n%\n%  The format of the SetMagickMemoryMethods() method is:\n%\n%      SetMagickMemoryMethods(AcquireMemoryHandler acquire_memory_handler,\n%        ResizeMemoryHandler resize_memory_handler,\n%        DestroyMemoryHandler destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void SetMagickMemoryMethods(\n  AcquireMemoryHandler acquire_memory_handler,\n  ResizeMemoryHandler resize_memory_handler,\n  DestroyMemoryHandler destroy_memory_handler)\n{\n  /*\n    Set memory methods.\n  */\n  if (acquire_memory_handler != (AcquireMemoryHandler) NULL)\n    memory_methods.acquire_memory_handler=acquire_memory_handler;\n  if (resize_memory_handler != (ResizeMemoryHandler) NULL)\n    memory_methods.resize_memory_handler=resize_memory_handler;\n  if (destroy_memory_handler != (DestroyMemoryHandler) NULL)\n    memory_methods.destroy_memory_handler=destroy_memory_handler;\n}\n"], "filenames": ["coders/label.c", "coders/viff.c", "magick/exception.c", "magick/memory-private.h", "magick/memory.c"], "buggy_code_start_loc": [141, 144, 54, 43, 243], "buggy_code_end_loc": [218, 534, 217, 43, 1247], "fixing_code_start_loc": [141, 143, 55, 44, 242], "fixing_code_end_loc": [220, 518, 235, 47, 1271], "type": "CWE-119", "message": "magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving \"too many exceptions,\" which trigger a buffer overflow.", "other": {"cve": {"id": "CVE-2016-10067", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-02T21:59:00.443", "lastModified": "2017-03-07T14:11:48.713", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving \"too many exceptions,\" which trigger a buffer overflow."}, {"lang": "es", "value": "magick/memory.c en ImageMagick en versiones anteriores a 6.9.4-5 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de vectores que implican \"muchas excepciones\", lo que desencadena un desbordamiento de b\u00fafer."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.4-4", "matchCriteriaId": "CF13FBCF-4932-47D4-B303-398738E5C9EA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95220", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410494", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76"}}