{"buggy_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Encrypter represents an encrypter which produces an encrypted JWE object.\ntype Encrypter interface {\n\tEncrypt(plaintext []byte) (*JsonWebEncryption, error)\n\tEncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)\n\tSetCompression(alg CompressionAlgorithm)\n}\n\n// MultiEncrypter represents an encrypter which supports multiple recipients.\ntype MultiEncrypter interface {\n\tEncrypt(plaintext []byte) (*JsonWebEncryption, error)\n\tEncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)\n\tSetCompression(alg CompressionAlgorithm)\n\tAddRecipient(alg KeyAlgorithm, encryptionKey interface{}) error\n}\n\n// A generic content cipher\ntype contentCipher interface {\n\tkeySize() int\n\tencrypt(cek []byte, aad, plaintext []byte) (*aeadParts, error)\n\tdecrypt(cek []byte, aad []byte, parts *aeadParts) ([]byte, error)\n}\n\n// A key generator (for generating/getting a CEK)\ntype keyGenerator interface {\n\tkeySize() int\n\tgenKey() ([]byte, rawHeader, error)\n}\n\n// A generic key encrypter\ntype keyEncrypter interface {\n\tencryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) // Encrypt a key\n}\n\n// A generic key decrypter\ntype keyDecrypter interface {\n\tdecryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) // Decrypt a key\n}\n\n// A generic encrypter based on the given key encrypter and content cipher.\ntype genericEncrypter struct {\n\tcontentAlg     ContentEncryption\n\tcompressionAlg CompressionAlgorithm\n\tcipher         contentCipher\n\trecipients     []recipientKeyInfo\n\tkeyGenerator   keyGenerator\n}\n\ntype recipientKeyInfo struct {\n\tkeyID        string\n\tkeyAlg       KeyAlgorithm\n\tkeyEncrypter keyEncrypter\n}\n\n// SetCompression sets a compression algorithm to be applied before encryption.\nfunc (ctx *genericEncrypter) SetCompression(compressionAlg CompressionAlgorithm) {\n\tctx.compressionAlg = compressionAlg\n}\n\n// NewEncrypter creates an appropriate encrypter based on the key type\nfunc NewEncrypter(alg KeyAlgorithm, enc ContentEncryption, encryptionKey interface{}) (Encrypter, error) {\n\tencrypter := &genericEncrypter{\n\t\tcontentAlg:     enc,\n\t\tcompressionAlg: NONE,\n\t\trecipients:     []recipientKeyInfo{},\n\t\tcipher:         getContentCipher(enc),\n\t}\n\n\tif encrypter.cipher == nil {\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tvar keyID string\n\tvar rawKey interface{}\n\tswitch encryptionKey := encryptionKey.(type) {\n\tcase *JsonWebKey:\n\t\tkeyID = encryptionKey.KeyID\n\t\trawKey = encryptionKey.Key\n\tdefault:\n\t\trawKey = encryptionKey\n\t}\n\n\tswitch alg {\n\tcase DIRECT:\n\t\t// Direct encryption mode must be treated differently\n\t\tif reflect.TypeOf(rawKey) != reflect.TypeOf([]byte{}) {\n\t\t\treturn nil, ErrUnsupportedKeyType\n\t\t}\n\t\tencrypter.keyGenerator = staticKeyGenerator{\n\t\t\tkey: rawKey.([]byte),\n\t\t}\n\t\trecipient, _ := newSymmetricRecipient(alg, rawKey.([]byte))\n\t\tif keyID != \"\" {\n\t\t\trecipient.keyID = keyID\n\t\t}\n\t\tencrypter.recipients = []recipientKeyInfo{recipient}\n\t\treturn encrypter, nil\n\tcase ECDH_ES:\n\t\t// ECDH-ES (w/o key wrapping) is similar to DIRECT mode\n\t\ttypeOf := reflect.TypeOf(rawKey)\n\t\tif typeOf != reflect.TypeOf(&ecdsa.PublicKey{}) {\n\t\t\treturn nil, ErrUnsupportedKeyType\n\t\t}\n\t\tencrypter.keyGenerator = ecKeyGenerator{\n\t\t\tsize:      encrypter.cipher.keySize(),\n\t\t\talgID:     string(enc),\n\t\t\tpublicKey: rawKey.(*ecdsa.PublicKey),\n\t\t}\n\t\trecipient, _ := newECDHRecipient(alg, rawKey.(*ecdsa.PublicKey))\n\t\tif keyID != \"\" {\n\t\t\trecipient.keyID = keyID\n\t\t}\n\t\tencrypter.recipients = []recipientKeyInfo{recipient}\n\t\treturn encrypter, nil\n\tdefault:\n\t\t// Can just add a standard recipient\n\t\tencrypter.keyGenerator = randomKeyGenerator{\n\t\t\tsize: encrypter.cipher.keySize(),\n\t\t}\n\t\terr := encrypter.AddRecipient(alg, encryptionKey)\n\t\treturn encrypter, err\n\t}\n}\n\n// NewMultiEncrypter creates a multi-encrypter based on the given parameters\nfunc NewMultiEncrypter(enc ContentEncryption) (MultiEncrypter, error) {\n\tcipher := getContentCipher(enc)\n\n\tif cipher == nil {\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tencrypter := &genericEncrypter{\n\t\tcontentAlg:     enc,\n\t\tcompressionAlg: NONE,\n\t\trecipients:     []recipientKeyInfo{},\n\t\tcipher:         cipher,\n\t\tkeyGenerator: randomKeyGenerator{\n\t\t\tsize: cipher.keySize(),\n\t\t},\n\t}\n\n\treturn encrypter, nil\n}\n\nfunc (ctx *genericEncrypter) AddRecipient(alg KeyAlgorithm, encryptionKey interface{}) (err error) {\n\tvar recipient recipientKeyInfo\n\n\tswitch alg {\n\tcase DIRECT, ECDH_ES:\n\t\treturn fmt.Errorf(\"square/go-jose: key algorithm '%s' not supported in multi-recipient mode\", alg)\n\t}\n\n\trecipient, err = makeJWERecipient(alg, encryptionKey)\n\n\tif err == nil {\n\t\tctx.recipients = append(ctx.recipients, recipient)\n\t}\n\treturn err\n}\n\nfunc makeJWERecipient(alg KeyAlgorithm, encryptionKey interface{}) (recipientKeyInfo, error) {\n\tswitch encryptionKey := encryptionKey.(type) {\n\tcase *rsa.PublicKey:\n\t\treturn newRSARecipient(alg, encryptionKey)\n\tcase *ecdsa.PublicKey:\n\t\treturn newECDHRecipient(alg, encryptionKey)\n\tcase []byte:\n\t\treturn newSymmetricRecipient(alg, encryptionKey)\n\tcase *JsonWebKey:\n\t\trecipient, err := makeJWERecipient(alg, encryptionKey.Key)\n\t\tif err == nil && encryptionKey.KeyID != \"\" {\n\t\t\trecipient.keyID = encryptionKey.KeyID\n\t\t}\n\t\treturn recipient, err\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedKeyType\n\t}\n}\n\n// newDecrypter creates an appropriate decrypter based on the key type\nfunc newDecrypter(decryptionKey interface{}) (keyDecrypter, error) {\n\tswitch decryptionKey := decryptionKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn &rsaDecrypterSigner{\n\t\t\tprivateKey: decryptionKey,\n\t\t}, nil\n\tcase *ecdsa.PrivateKey:\n\t\treturn &ecDecrypterSigner{\n\t\t\tprivateKey: decryptionKey,\n\t\t}, nil\n\tcase []byte:\n\t\treturn &symmetricKeyCipher{\n\t\t\tkey: decryptionKey,\n\t\t}, nil\n\tcase *JsonWebKey:\n\t\treturn newDecrypter(decryptionKey.Key)\n\tdefault:\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n}\n\n// Implementation of encrypt method producing a JWE object.\nfunc (ctx *genericEncrypter) Encrypt(plaintext []byte) (*JsonWebEncryption, error) {\n\treturn ctx.EncryptWithAuthData(plaintext, nil)\n}\n\n// Implementation of encrypt method producing a JWE object.\nfunc (ctx *genericEncrypter) EncryptWithAuthData(plaintext, aad []byte) (*JsonWebEncryption, error) {\n\tobj := &JsonWebEncryption{}\n\tobj.aad = aad\n\n\tobj.protected = &rawHeader{\n\t\tEnc: ctx.contentAlg,\n\t}\n\tobj.recipients = make([]recipientInfo, len(ctx.recipients))\n\n\tif len(ctx.recipients) == 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: no recipients to encrypt to\")\n\t}\n\n\tcek, headers, err := ctx.keyGenerator.genKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobj.protected.merge(&headers)\n\n\tfor i, info := range ctx.recipients {\n\t\trecipient, err := info.keyEncrypter.encryptKey(cek, info.keyAlg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trecipient.header.Alg = string(info.keyAlg)\n\t\tif info.keyID != \"\" {\n\t\t\trecipient.header.Kid = info.keyID\n\t\t}\n\t\tobj.recipients[i] = recipient\n\t}\n\n\tif len(ctx.recipients) == 1 {\n\t\t// Move per-recipient headers into main protected header if there's\n\t\t// only a single recipient.\n\t\tobj.protected.merge(obj.recipients[0].header)\n\t\tobj.recipients[0].header = nil\n\t}\n\n\tif ctx.compressionAlg != NONE {\n\t\tplaintext, err = compress(ctx.compressionAlg, plaintext)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tobj.protected.Zip = ctx.compressionAlg\n\t}\n\n\tauthData := obj.computeAuthData()\n\tparts, err := ctx.cipher.encrypt(cek, authData, plaintext)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobj.iv = parts.iv\n\tobj.ciphertext = parts.ciphertext\n\tobj.tag = parts.tag\n\n\treturn obj, nil\n}\n\n// Decrypt and validate the object and return the plaintext.\nfunc (obj JsonWebEncryption) Decrypt(decryptionKey interface{}) ([]byte, error) {\n\theaders := obj.mergedHeaders(nil)\n\n\tif len(headers.Crit) > 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported crit header\")\n\t}\n\n\tdecrypter, err := newDecrypter(decryptionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcipher := getContentCipher(headers.Enc)\n\tif cipher == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported enc value '%s'\", string(headers.Enc))\n\t}\n\n\tgenerator := randomKeyGenerator{\n\t\tsize: cipher.keySize(),\n\t}\n\n\tparts := &aeadParts{\n\t\tiv:         obj.iv,\n\t\tciphertext: obj.ciphertext,\n\t\ttag:        obj.tag,\n\t}\n\n\tauthData := obj.computeAuthData()\n\n\tvar plaintext []byte\n\tfor _, recipient := range obj.recipients {\n\t\trecipientHeaders := obj.mergedHeaders(&recipient)\n\n\t\tcek, err := decrypter.decryptKey(recipientHeaders, &recipient, generator)\n\t\tif err == nil {\n\t\t\t// Found a valid CEK -- let's try to decrypt.\n\t\t\tplaintext, err = cipher.decrypt(cek, authData, parts)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif plaintext == nil {\n\t\treturn nil, ErrCryptoFailure\n\t}\n\n\t// The \"zip\" header parameter may only be present in the protected header.\n\tif obj.protected.Zip != \"\" {\n\t\tplaintext, err = decompress(obj.protected.Zip, plaintext)\n\t}\n\n\treturn plaintext, err\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n)\n\n// We generate only a single RSA and EC key for testing, speeds up tests.\nvar rsaTestKey, _ = rsa.GenerateKey(rand.Reader, 2048)\n\nvar ecTestKey256, _ = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\nvar ecTestKey384, _ = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\nvar ecTestKey521, _ = ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\nfunc RoundtripJWE(keyAlg KeyAlgorithm, encAlg ContentEncryption, compressionAlg CompressionAlgorithm, serializer func(*JsonWebEncryption) (string, error), corrupter func(*JsonWebEncryption) bool, aad []byte, encryptionKey interface{}, decryptionKey interface{}) error {\n\tenc, err := NewEncrypter(keyAlg, encAlg, encryptionKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on new encrypter: %s\", err)\n\t}\n\n\tenc.SetCompression(compressionAlg)\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := enc.EncryptWithAuthData(input, aad)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in encrypt: %s\", err)\n\t}\n\n\tmsg, err := serializer(obj)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in serializer: %s\", err)\n\t}\n\n\tparsed, err := ParseEncrypted(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in parse: %s, on msg '%s'\", err, msg)\n\t}\n\n\t// (Maybe) mangle object\n\tskip := corrupter(parsed)\n\tif skip {\n\t\treturn fmt.Errorf(\"corrupter indicated message should be skipped\")\n\t}\n\n\tif bytes.Compare(parsed.GetAuthData(), aad) != 0 {\n\t\treturn fmt.Errorf(\"auth data in parsed object does not match\")\n\t}\n\n\toutput, err := parsed.Decrypt(decryptionKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on decrypt: %s\", err)\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\treturn fmt.Errorf(\"Decrypted output does not match input, got '%s' but wanted '%s'\", output, input)\n\t}\n\n\treturn nil\n}\n\nfunc TestRoundtripsJWE(t *testing.T) {\n\t// Test matrix\n\tkeyAlgs := []KeyAlgorithm{\n\t\tDIRECT, ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW, A128KW, A192KW, A256KW,\n\t\tRSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW, A192GCMKW, A256GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\tzipAlgs := []CompressionAlgorithm{NONE, DEFLATE}\n\n\tserializers := []func(*JsonWebEncryption) (string, error){\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\t// Note: can't use AAD with compact serialization\n\taads := [][]byte{\n\t\tnil,\n\t\t[]byte(\"Ut enim ad minim veniam\"),\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor _, zip := range zipAlgs {\n\t\t\t\t\tfor i, serializer := range serializers {\n\t\t\t\t\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, aads[i], key.enc, key.dec)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Error(err, alg, enc, zip, i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRoundtripsJWECorrupted(t *testing.T) {\n\t// Test matrix\n\tkeyAlgs := []KeyAlgorithm{DIRECT, ECDH_ES, ECDH_ES_A128KW, A128KW, RSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\tzipAlgs := []CompressionAlgorithm{NONE, DEFLATE}\n\n\tserializers := []func(*JsonWebEncryption) (string, error){\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tbitflip := func(slice []byte) bool {\n\t\tif len(slice) > 0 {\n\t\t\tslice[0] ^= 0xFF\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tcorrupters := []func(*JsonWebEncryption) bool{\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid ciphertext\n\t\t\treturn bitflip(obj.ciphertext)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid auth tag\n\t\t\treturn bitflip(obj.tag)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid AAD\n\t\t\treturn bitflip(obj.aad)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Mess with encrypted key\n\t\t\treturn bitflip(obj.recipients[0].encryptedKey)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Mess with GCM-KW auth tag\n\t\t\treturn bitflip(obj.protected.Tag.bytes())\n\t\t},\n\t}\n\n\t// Note: can't use AAD with compact serialization\n\taads := [][]byte{\n\t\tnil,\n\t\t[]byte(\"Ut enim ad minim veniam\"),\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor _, zip := range zipAlgs {\n\t\t\t\t\tfor i, serializer := range serializers {\n\t\t\t\t\t\tfor j, corrupter := range corrupters {\n\t\t\t\t\t\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, aads[i], key.enc, key.dec)\n\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\tt.Error(\"failed to detect corrupt data\", err, alg, enc, zip, i, j)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEncrypterWithJWKAndKeyID(t *testing.T) {\n\tenc, err := NewEncrypter(A128KW, A128GCM, &JsonWebKey{\n\t\tKeyID: \"test-id\",\n\t\tKey:   []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tciphertext, _ := enc.Encrypt([]byte(\"Lorem ipsum dolor sit amet\"))\n\n\tserialized1, _ := ciphertext.CompactSerialize()\n\tserialized2 := ciphertext.FullSerialize()\n\n\tparsed1, _ := ParseEncrypted(serialized1)\n\tparsed2, _ := ParseEncrypted(serialized2)\n\n\tif parsed1.Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed1.Header.KeyID)\n\t}\n\tif parsed2.Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed2.Header.KeyID)\n\t}\n}\n\nfunc TestEncrypterWithBrokenRand(t *testing.T) {\n\tkeyAlgs := []KeyAlgorithm{ECDH_ES_A128KW, A128KW, RSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\n\tserializer := func(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() }\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\t// Break rand reader\n\treaders := []func() io.Reader{\n\t\t// Totally broken\n\t\tfunc() io.Reader { return bytes.NewReader([]byte{}) },\n\t\t// Not enough bytes\n\t\tfunc() io.Reader { return io.LimitReader(rand.Reader, 20) },\n\t}\n\n\tdefer resetRandReader()\n\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor i, getReader := range readers {\n\t\t\t\t\trandReader = getReader()\n\t\t\t\t\terr := RoundtripJWE(alg, enc, NONE, serializer, corrupter, nil, key.enc, key.dec)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tt.Error(\"encrypter should fail if rand is broken\", i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNewEncrypterErrors(t *testing.T) {\n\t_, err := NewEncrypter(\"XYZ\", \"XYZ\", nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid cipher\")\n\t}\n\n\t_, err = NewMultiEncrypter(\"XYZ\")\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate multi-encrypter with invalid cipher\")\n\t}\n\n\t_, err = NewEncrypter(DIRECT, A128GCM, nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid direct key\")\n\t}\n\n\t_, err = NewEncrypter(ECDH_ES, A128GCM, nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid EC key\")\n\t}\n}\n\nfunc TestMultiRecipientJWE(t *testing.T) {\n\tenc, err := NewMultiEncrypter(A128GCM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = enc.AddRecipient(RSA_OAEP, &rsaTestKey.PublicKey)\n\tif err != nil {\n\t\tt.Error(\"error when adding RSA recipient\", err)\n\t}\n\n\tsharedKey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\terr = enc.AddRecipient(A256GCMKW, sharedKey)\n\tif err != nil {\n\t\tt.Error(\"error when adding AES recipient: \", err)\n\t\treturn\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := enc.Encrypt(input)\n\tif err != nil {\n\t\tt.Error(\"error in encrypt: \", err)\n\t\treturn\n\t}\n\n\tmsg := obj.FullSerialize()\n\n\tparsed, err := ParseEncrypted(msg)\n\tif err != nil {\n\t\tt.Error(\"error in parse: \", err)\n\t\treturn\n\t}\n\n\toutput, err := parsed.Decrypt(rsaTestKey)\n\tif err != nil {\n\t\tt.Error(\"error on decrypt with RSA: \", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\tt.Error(\"Decrypted output does not match input: \", output, input)\n\t\treturn\n\t}\n\n\toutput, err = parsed.Decrypt(sharedKey)\n\tif err != nil {\n\t\tt.Error(\"error on decrypt with AES: \", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\tt.Error(\"Decrypted output does not match input\", output, input)\n\t\treturn\n\t}\n}\n\nfunc TestMultiRecipientErrors(t *testing.T) {\n\tenc, err := NewMultiEncrypter(A128GCM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\t_, err = enc.Encrypt(input)\n\tif err == nil {\n\t\tt.Error(\"should fail when encrypting to zero recipients\")\n\t}\n\n\terr = enc.AddRecipient(DIRECT, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject DIRECT mode when encrypting to multiple recipients\")\n\t}\n\n\terr = enc.AddRecipient(ECDH_ES, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject ECDH_ES mode when encrypting to multiple recipients\")\n\t}\n\n\terr = enc.AddRecipient(RSA1_5, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject invalid recipient key\")\n\t}\n}\n\ntype testKey struct {\n\tenc, dec interface{}\n}\n\nfunc symmetricTestKey(size int) []testKey {\n\tkey, _, _ := randomKeyGenerator{size: size}.genKey()\n\n\treturn []testKey{\n\t\ttestKey{\n\t\t\tenc: key,\n\t\t\tdec: key,\n\t\t},\n\t\ttestKey{\n\t\t\tenc: &JsonWebKey{KeyID: \"test\", Key: key},\n\t\t\tdec: &JsonWebKey{KeyID: \"test\", Key: key},\n\t\t},\n\t}\n}\n\nfunc generateTestKeys(keyAlg KeyAlgorithm, encAlg ContentEncryption) []testKey {\n\tswitch keyAlg {\n\tcase DIRECT:\n\t\treturn symmetricTestKey(getContentCipher(encAlg).keySize())\n\tcase ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\t\treturn []testKey{\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey256,\n\t\t\t\tenc: &ecTestKey256.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey384,\n\t\t\t\tenc: &ecTestKey384.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey521,\n\t\t\t\tenc: &ecTestKey521.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: &JsonWebKey{KeyID: \"test\", Key: ecTestKey256},\n\t\t\t\tenc: &JsonWebKey{KeyID: \"test\", Key: &ecTestKey256.PublicKey},\n\t\t\t},\n\t\t}\n\tcase A128GCMKW, A128KW:\n\t\treturn symmetricTestKey(16)\n\tcase A192GCMKW, A192KW:\n\t\treturn symmetricTestKey(24)\n\tcase A256GCMKW, A256KW:\n\t\treturn symmetricTestKey(32)\n\tcase RSA1_5, RSA_OAEP, RSA_OAEP_256:\n\t\treturn []testKey{testKey{\n\t\t\tdec: rsaTestKey,\n\t\t\tenc: &rsaTestKey.PublicKey,\n\t\t}}\n\t}\n\n\tpanic(\"Must update test case\")\n}\n\nfunc RunRoundtripsJWE(b *testing.B, alg KeyAlgorithm, enc ContentEncryption, zip CompressionAlgorithm, priv, pub interface{}) {\n\tserializer := func(obj *JsonWebEncryption) (string, error) {\n\t\treturn obj.CompactSerialize()\n\t}\n\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, nil, pub, priv)\n\t\tif err != nil {\n\t\t\tb.Error(err)\n\t\t}\n\t}\n}\n\nvar (\n\tchunks = map[string][]byte{\n\t\t\"1B\":   make([]byte, 1),\n\t\t\"64B\":  make([]byte, 64),\n\t\t\"1KB\":  make([]byte, 1024),\n\t\t\"64KB\": make([]byte, 65536),\n\t\t\"1MB\":  make([]byte, 1048576),\n\t\t\"64MB\": make([]byte, 67108864),\n\t}\n\n\tsymKey, _, _ = randomKeyGenerator{size: 32}.genKey()\n\n\tencrypters = map[string]Encrypter{\n\t\t\"OAEPAndGCM\":          mustEncrypter(RSA_OAEP, A128GCM, &rsaTestKey.PublicKey),\n\t\t\"PKCSAndGCM\":          mustEncrypter(RSA1_5, A128GCM, &rsaTestKey.PublicKey),\n\t\t\"OAEPAndCBC\":          mustEncrypter(RSA_OAEP, A128CBC_HS256, &rsaTestKey.PublicKey),\n\t\t\"PKCSAndCBC\":          mustEncrypter(RSA1_5, A128CBC_HS256, &rsaTestKey.PublicKey),\n\t\t\"DirectGCM128\":        mustEncrypter(DIRECT, A128GCM, symKey),\n\t\t\"DirectCBC128\":        mustEncrypter(DIRECT, A128CBC_HS256, symKey),\n\t\t\"DirectGCM256\":        mustEncrypter(DIRECT, A256GCM, symKey),\n\t\t\"DirectCBC256\":        mustEncrypter(DIRECT, A256CBC_HS512, symKey),\n\t\t\"AESKWAndGCM128\":      mustEncrypter(A128KW, A128GCM, symKey),\n\t\t\"AESKWAndCBC256\":      mustEncrypter(A256KW, A256GCM, symKey),\n\t\t\"ECDHOnP256AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey256.PublicKey),\n\t\t\"ECDHOnP384AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey384.PublicKey),\n\t\t\"ECDHOnP521AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey521.PublicKey),\n\t}\n)\n\nfunc BenchmarkEncrypt1BWithOAEPAndGCM(b *testing.B)   { benchEncrypt(\"1B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64BWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"64B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt1KBWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"1KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64KBWithOAEPAndGCM(b *testing.B) { benchEncrypt(\"64KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt1MBWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"1MB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64MBWithOAEPAndGCM(b *testing.B) { benchEncrypt(\"64MB\", \"OAEPAndGCM\", b) }\n\nfunc BenchmarkEncrypt1BWithPKCSAndGCM(b *testing.B)   { benchEncrypt(\"1B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64BWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"64B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt1KBWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"1KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64KBWithPKCSAndGCM(b *testing.B) { benchEncrypt(\"64KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt1MBWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"1MB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64MBWithPKCSAndGCM(b *testing.B) { benchEncrypt(\"64MB\", \"PKCSAndGCM\", b) }\n\nfunc BenchmarkEncrypt1BWithOAEPAndCBC(b *testing.B)   { benchEncrypt(\"1B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64BWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"64B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt1KBWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"1KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64KBWithOAEPAndCBC(b *testing.B) { benchEncrypt(\"64KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt1MBWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"1MB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64MBWithOAEPAndCBC(b *testing.B) { benchEncrypt(\"64MB\", \"OAEPAndCBC\", b) }\n\nfunc BenchmarkEncrypt1BWithPKCSAndCBC(b *testing.B)   { benchEncrypt(\"1B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64BWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"64B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt1KBWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"1KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64KBWithPKCSAndCBC(b *testing.B) { benchEncrypt(\"64KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt1MBWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"1MB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64MBWithPKCSAndCBC(b *testing.B) { benchEncrypt(\"64MB\", \"PKCSAndCBC\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectGCM128(b *testing.B)   { benchEncrypt(\"1B\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64BWithDirectGCM128(b *testing.B)  { benchEncrypt(\"64B\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt1KBWithDirectGCM128(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64KBWithDirectGCM128(b *testing.B) { benchEncrypt(\"64KB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt1MBWithDirectGCM128(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64MBWithDirectGCM128(b *testing.B) { benchEncrypt(\"64MB\", \"DirectGCM128\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectCBC128(b *testing.B)   { benchEncrypt(\"1B\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64BWithDirectCBC128(b *testing.B)  { benchEncrypt(\"64B\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt1KBWithDirectCBC128(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64KBWithDirectCBC128(b *testing.B) { benchEncrypt(\"64KB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt1MBWithDirectCBC128(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64MBWithDirectCBC128(b *testing.B) { benchEncrypt(\"64MB\", \"DirectCBC128\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectGCM256(b *testing.B)   { benchEncrypt(\"1B\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64BWithDirectGCM256(b *testing.B)  { benchEncrypt(\"64B\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt1KBWithDirectGCM256(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64KBWithDirectGCM256(b *testing.B) { benchEncrypt(\"64KB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt1MBWithDirectGCM256(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64MBWithDirectGCM256(b *testing.B) { benchEncrypt(\"64MB\", \"DirectGCM256\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectCBC256(b *testing.B)   { benchEncrypt(\"1B\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64BWithDirectCBC256(b *testing.B)  { benchEncrypt(\"64B\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt1KBWithDirectCBC256(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64KBWithDirectCBC256(b *testing.B) { benchEncrypt(\"64KB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt1MBWithDirectCBC256(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64MBWithDirectCBC256(b *testing.B) { benchEncrypt(\"64MB\", \"DirectCBC256\", b) }\n\nfunc BenchmarkEncrypt1BWithAESKWAndGCM128(b *testing.B)   { benchEncrypt(\"1B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64BWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"64B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt1KBWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"1KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64KBWithAESKWAndGCM128(b *testing.B) { benchEncrypt(\"64KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt1MBWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"1MB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64MBWithAESKWAndGCM128(b *testing.B) { benchEncrypt(\"64MB\", \"AESKWAndGCM128\", b) }\n\nfunc BenchmarkEncrypt1BWithAESKWAndCBC256(b *testing.B)   { benchEncrypt(\"1B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64BWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"64B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt1KBWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"1KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64KBWithAESKWAndCBC256(b *testing.B) { benchEncrypt(\"64KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt1MBWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"1MB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64MBWithAESKWAndCBC256(b *testing.B) { benchEncrypt(\"64MB\", \"AESKWAndCBC256\", b) }\n\nfunc BenchmarkEncrypt1BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP256AndGCM128\", b)\n}\n\nfunc BenchmarkEncrypt1BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP384AndGCM128\", b)\n}\n\nfunc BenchmarkEncrypt1BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP521AndGCM128\", b)\n}\n\nfunc benchEncrypt(chunkKey, primKey string, b *testing.B) {\n\tdata, ok := chunks[chunkKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown chunk size %s\", chunkKey)\n\t}\n\n\tenc, ok := encrypters[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown encrypter %s\", primKey)\n\t}\n\n\tb.SetBytes(int64(len(data)))\n\tfor i := 0; i < b.N; i++ {\n\t\tenc.Encrypt(data)\n\t}\n}\n\nvar (\n\tdecryptionKeys = map[string]interface{}{\n\t\t\"OAEPAndGCM\": rsaTestKey,\n\t\t\"PKCSAndGCM\": rsaTestKey,\n\t\t\"OAEPAndCBC\": rsaTestKey,\n\t\t\"PKCSAndCBC\": rsaTestKey,\n\n\t\t\"DirectGCM128\": symKey,\n\t\t\"DirectCBC128\": symKey,\n\t\t\"DirectGCM256\": symKey,\n\t\t\"DirectCBC256\": symKey,\n\n\t\t\"AESKWAndGCM128\": symKey,\n\t\t\"AESKWAndCBC256\": symKey,\n\n\t\t\"ECDHOnP256AndGCM128\": ecTestKey256,\n\t\t\"ECDHOnP384AndGCM128\": ecTestKey384,\n\t\t\"ECDHOnP521AndGCM128\": ecTestKey521,\n\t}\n)\n\nfunc BenchmarkDecrypt1BWithOAEPAndGCM(b *testing.B)   { benchDecrypt(\"1B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64BWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"64B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt1KBWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"1KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64KBWithOAEPAndGCM(b *testing.B) { benchDecrypt(\"64KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt1MBWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"1MB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64MBWithOAEPAndGCM(b *testing.B) { benchDecrypt(\"64MB\", \"OAEPAndGCM\", b) }\n\nfunc BenchmarkDecrypt1BWithPKCSAndGCM(b *testing.B)   { benchDecrypt(\"1B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64BWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"64B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt1KBWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"1KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64KBWithPKCSAndGCM(b *testing.B) { benchDecrypt(\"64KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt1MBWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"1MB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64MBWithPKCSAndGCM(b *testing.B) { benchDecrypt(\"64MB\", \"PKCSAndGCM\", b) }\n\nfunc BenchmarkDecrypt1BWithOAEPAndCBC(b *testing.B)   { benchDecrypt(\"1B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64BWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"64B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt1KBWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"1KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64KBWithOAEPAndCBC(b *testing.B) { benchDecrypt(\"64KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt1MBWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"1MB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64MBWithOAEPAndCBC(b *testing.B) { benchDecrypt(\"64MB\", \"OAEPAndCBC\", b) }\n\nfunc BenchmarkDecrypt1BWithPKCSAndCBC(b *testing.B)   { benchDecrypt(\"1B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64BWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"64B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt1KBWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"1KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64KBWithPKCSAndCBC(b *testing.B) { benchDecrypt(\"64KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt1MBWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"1MB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64MBWithPKCSAndCBC(b *testing.B) { benchDecrypt(\"64MB\", \"PKCSAndCBC\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectGCM128(b *testing.B)   { benchDecrypt(\"1B\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64BWithDirectGCM128(b *testing.B)  { benchDecrypt(\"64B\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt1KBWithDirectGCM128(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64KBWithDirectGCM128(b *testing.B) { benchDecrypt(\"64KB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt1MBWithDirectGCM128(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64MBWithDirectGCM128(b *testing.B) { benchDecrypt(\"64MB\", \"DirectGCM128\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectCBC128(b *testing.B)   { benchDecrypt(\"1B\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64BWithDirectCBC128(b *testing.B)  { benchDecrypt(\"64B\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt1KBWithDirectCBC128(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64KBWithDirectCBC128(b *testing.B) { benchDecrypt(\"64KB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt1MBWithDirectCBC128(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64MBWithDirectCBC128(b *testing.B) { benchDecrypt(\"64MB\", \"DirectCBC128\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectGCM256(b *testing.B)   { benchDecrypt(\"1B\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64BWithDirectGCM256(b *testing.B)  { benchDecrypt(\"64B\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt1KBWithDirectGCM256(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64KBWithDirectGCM256(b *testing.B) { benchDecrypt(\"64KB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt1MBWithDirectGCM256(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64MBWithDirectGCM256(b *testing.B) { benchDecrypt(\"64MB\", \"DirectGCM256\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectCBC256(b *testing.B)   { benchDecrypt(\"1B\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64BWithDirectCBC256(b *testing.B)  { benchDecrypt(\"64B\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt1KBWithDirectCBC256(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64KBWithDirectCBC256(b *testing.B) { benchDecrypt(\"64KB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt1MBWithDirectCBC256(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64MBWithDirectCBC256(b *testing.B) { benchDecrypt(\"64MB\", \"DirectCBC256\", b) }\n\nfunc BenchmarkDecrypt1BWithAESKWAndGCM128(b *testing.B)   { benchDecrypt(\"1B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64BWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"64B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt1KBWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"1KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64KBWithAESKWAndGCM128(b *testing.B) { benchDecrypt(\"64KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt1MBWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"1MB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64MBWithAESKWAndGCM128(b *testing.B) { benchDecrypt(\"64MB\", \"AESKWAndGCM128\", b) }\n\nfunc BenchmarkDecrypt1BWithAESKWAndCBC256(b *testing.B)   { benchDecrypt(\"1B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64BWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"64B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt1KBWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"1KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64KBWithAESKWAndCBC256(b *testing.B) { benchDecrypt(\"64KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt1MBWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"1MB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64MBWithAESKWAndCBC256(b *testing.B) { benchDecrypt(\"64MB\", \"AESKWAndCBC256\", b) }\n\nfunc BenchmarkDecrypt1BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP256AndGCM128\", b)\n}\n\nfunc BenchmarkDecrypt1BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP384AndGCM128\", b)\n}\n\nfunc BenchmarkDecrypt1BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP521AndGCM128\", b)\n}\n\nfunc benchDecrypt(chunkKey, primKey string, b *testing.B) {\n\tchunk, ok := chunks[chunkKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown chunk size %s\", chunkKey)\n\t}\n\n\tenc, ok := encrypters[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown encrypter %s\", primKey)\n\t}\n\n\tdec, ok := decryptionKeys[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown decryption key %s\", primKey)\n\t}\n\n\tdata, err := enc.Encrypt(chunk)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.SetBytes(int64(len(chunk)))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tdata.Decrypt(dec)\n\t}\n}\n\nfunc mustEncrypter(keyAlg KeyAlgorithm, encAlg ContentEncryption, encryptionKey interface{}) Encrypter {\n\tenc, err := NewEncrypter(keyAlg, encAlg, encryptionKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn enc\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\n// rawJsonWebSignature represents a raw JWS JSON object. Used for parsing/serializing.\ntype rawJsonWebSignature struct {\n\tPayload    *byteBuffer        `json:\"payload,omitempty\"`\n\tSignatures []rawSignatureInfo `json:\"signatures,omitempty\"`\n\tProtected  *byteBuffer        `json:\"protected,omitempty\"`\n\tHeader     *rawHeader         `json:\"header,omitempty\"`\n\tSignature  *byteBuffer        `json:\"signature,omitempty\"`\n}\n\n// rawSignatureInfo represents a single JWS signature over the JWS payload and protected header.\ntype rawSignatureInfo struct {\n\tProtected *byteBuffer `json:\"protected,omitempty\"`\n\tHeader    *rawHeader  `json:\"header,omitempty\"`\n\tSignature *byteBuffer `json:\"signature,omitempty\"`\n}\n\n// JsonWebSignature represents a signed JWS object after parsing.\ntype JsonWebSignature struct {\n\tpayload    []byte\n\tSignatures []Signature\n}\n\n// Signature represents a single signature over the JWS payload and protected header.\ntype Signature struct {\n\t// Header fields, such as the signature algorithm\n\tHeader JoseHeader\n\n\t// The actual signature value\n\tSignature []byte\n\n\tprotected *rawHeader\n\theader    *rawHeader\n\toriginal  *rawSignatureInfo\n}\n\n// ParseSigned parses a signed message in compact or full serialization format.\nfunc ParseSigned(input string) (*JsonWebSignature, error) {\n\tinput = stripWhitespace(input)\n\tif strings.HasPrefix(input, \"{\") {\n\t\treturn parseSignedFull(input)\n\t}\n\n\treturn parseSignedCompact(input)\n}\n\n// Get a header value\nfunc (sig Signature) mergedHeaders() rawHeader {\n\tout := rawHeader{}\n\tout.merge(sig.protected)\n\tout.merge(sig.header)\n\treturn out\n}\n\n// Compute data to be signed\nfunc (obj JsonWebSignature) computeAuthData(signature *Signature) []byte {\n\tvar serializedProtected string\n\n\tif signature.original != nil && signature.original.Protected != nil {\n\t\tserializedProtected = signature.original.Protected.base64()\n\t} else if signature.protected != nil {\n\t\tserializedProtected = base64URLEncode(mustSerializeJSON(signature.protected))\n\t} else {\n\t\tserializedProtected = \"\"\n\t}\n\n\treturn []byte(fmt.Sprintf(\"%s.%s\",\n\t\tserializedProtected,\n\t\tbase64URLEncode(obj.payload)))\n}\n\n// parseSignedFull parses a message in full format.\nfunc parseSignedFull(input string) (*JsonWebSignature, error) {\n\tvar parsed rawJsonWebSignature\n\terr := json.Unmarshal([]byte(input), &parsed)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn parsed.sanitized()\n}\n\n// sanitized produces a cleaned-up JWS object from the raw JSON.\nfunc (parsed *rawJsonWebSignature) sanitized() (*JsonWebSignature, error) {\n\tif parsed.Payload == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: missing payload in JWS message\")\n\t}\n\n\tobj := &JsonWebSignature{\n\t\tpayload:    parsed.Payload.bytes(),\n\t\tSignatures: make([]Signature, len(parsed.Signatures)),\n\t}\n\n\tif len(parsed.Signatures) == 0 {\n\t\t// No signatures array, must be flattened serialization\n\t\tsignature := Signature{}\n\t\tif parsed.Protected != nil && len(parsed.Protected.bytes()) > 0 {\n\t\t\tsignature.protected = &rawHeader{}\n\t\t\terr := json.Unmarshal(parsed.Protected.bytes(), signature.protected)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif parsed.Header != nil && parsed.Header.Nonce != \"\" {\n\t\t\treturn nil, ErrUnprotectedNonce\n\t\t}\n\n\t\tsignature.header = parsed.Header\n\t\tsignature.Signature = parsed.Signature.bytes()\n\t\t// Make a fake \"original\" rawSignatureInfo to store the unprocessed\n\t\t// Protected header. This is necessary because the Protected header can\n\t\t// contain arbitrary fields not registered as part of the spec. See\n\t\t// https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-4\n\t\t// If we unmarshal Protected into a rawHeader with its explicit list of fields,\n\t\t// we cannot marshal losslessly. So we have to keep around the original bytes.\n\t\t// This is used in computeAuthData, which will first attempt to use\n\t\t// the original bytes of a protected header, and fall back on marshaling the\n\t\t// header struct only if those bytes are not available.\n\t\tsignature.original = &rawSignatureInfo{\n\t\t\tProtected: parsed.Protected,\n\t\t\tHeader:    parsed.Header,\n\t\t\tSignature: parsed.Signature,\n\t\t}\n\n\t\tsignature.Header = signature.mergedHeaders().sanitized()\n\t\tobj.Signatures = append(obj.Signatures, signature)\n\t}\n\n\tfor i, sig := range parsed.Signatures {\n\t\tif sig.Protected != nil && len(sig.Protected.bytes()) > 0 {\n\t\t\tobj.Signatures[i].protected = &rawHeader{}\n\t\t\terr := json.Unmarshal(sig.Protected.bytes(), obj.Signatures[i].protected)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// Check that there is not a nonce in the unprotected header\n\t\tif sig.Header != nil && sig.Header.Nonce != \"\" {\n\t\t\treturn nil, ErrUnprotectedNonce\n\t\t}\n\n\t\tobj.Signatures[i].Signature = sig.Signature.bytes()\n\n\t\t// Copy value of sig\n\t\toriginal := sig\n\n\t\tobj.Signatures[i].header = sig.Header\n\t\tobj.Signatures[i].original = &original\n\t\tobj.Signatures[i].Header = obj.Signatures[i].mergedHeaders().sanitized()\n\t}\n\n\treturn obj, nil\n}\n\n// parseSignedCompact parses a message in compact format.\nfunc parseSignedCompact(input string) (*JsonWebSignature, error) {\n\tparts := strings.Split(input, \".\")\n\tif len(parts) != 3 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: compact JWS format must have three parts\")\n\t}\n\n\trawProtected, err := base64URLDecode(parts[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := base64URLDecode(parts[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsignature, err := base64URLDecode(parts[2])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\traw := &rawJsonWebSignature{\n\t\tPayload:   newBuffer(payload),\n\t\tProtected: newBuffer(rawProtected),\n\t\tSignature: newBuffer(signature),\n\t}\n\treturn raw.sanitized()\n}\n\n// CompactSerialize serializes an object using the compact serialization format.\nfunc (obj JsonWebSignature) CompactSerialize() (string, error) {\n\tif len(obj.Signatures) != 1 || obj.Signatures[0].header != nil || obj.Signatures[0].protected == nil {\n\t\treturn \"\", ErrNotSupported\n\t}\n\n\tserializedProtected := mustSerializeJSON(obj.Signatures[0].protected)\n\n\treturn fmt.Sprintf(\n\t\t\"%s.%s.%s\",\n\t\tbase64URLEncode(serializedProtected),\n\t\tbase64URLEncode(obj.payload),\n\t\tbase64URLEncode(obj.Signatures[0].Signature)), nil\n}\n\n// FullSerialize serializes an object using the full JSON serialization format.\nfunc (obj JsonWebSignature) FullSerialize() string {\n\traw := rawJsonWebSignature{\n\t\tPayload: newBuffer(obj.payload),\n\t}\n\n\tif len(obj.Signatures) == 1 {\n\t\tif obj.Signatures[0].protected != nil {\n\t\t\tserializedProtected := mustSerializeJSON(obj.Signatures[0].protected)\n\t\t\traw.Protected = newBuffer(serializedProtected)\n\t\t}\n\t\traw.Header = obj.Signatures[0].header\n\t\traw.Signature = newBuffer(obj.Signatures[0].Signature)\n\t} else {\n\t\traw.Signatures = make([]rawSignatureInfo, len(obj.Signatures))\n\t\tfor i, signature := range obj.Signatures {\n\t\t\traw.Signatures[i] = rawSignatureInfo{\n\t\t\t\tHeader:    signature.header,\n\t\t\t\tSignature: newBuffer(signature.Signature),\n\t\t\t}\n\n\t\t\tif signature.protected != nil {\n\t\t\t\traw.Signatures[i].Protected = newBuffer(mustSerializeJSON(signature.protected))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn string(mustSerializeJSON(raw))\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\n// NonceSource represents a source of random nonces to go into JWS objects\ntype NonceSource interface {\n\tNonce() (string, error)\n}\n\n// Signer represents a signer which takes a payload and produces a signed JWS object.\ntype Signer interface {\n\tSign(payload []byte) (*JsonWebSignature, error)\n\tSetNonceSource(source NonceSource)\n\tSetEmbedJwk(embed bool)\n}\n\n// MultiSigner represents a signer which supports multiple recipients.\ntype MultiSigner interface {\n\tSign(payload []byte) (*JsonWebSignature, error)\n\tSetNonceSource(source NonceSource)\n\tSetEmbedJwk(embed bool)\n\tAddRecipient(alg SignatureAlgorithm, signingKey interface{}) error\n}\n\ntype payloadSigner interface {\n\tsignPayload(payload []byte, alg SignatureAlgorithm) (Signature, error)\n}\n\ntype payloadVerifier interface {\n\tverifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error\n}\n\ntype genericSigner struct {\n\trecipients  []recipientSigInfo\n\tnonceSource NonceSource\n\tembedJwk    bool\n}\n\ntype recipientSigInfo struct {\n\tsigAlg    SignatureAlgorithm\n\tkeyID     string\n\tpublicKey *JsonWebKey\n\tsigner    payloadSigner\n}\n\n// NewSigner creates an appropriate signer based on the key type\nfunc NewSigner(alg SignatureAlgorithm, signingKey interface{}) (Signer, error) {\n\t// NewMultiSigner never fails (currently)\n\tsigner := NewMultiSigner()\n\n\terr := signer.AddRecipient(alg, signingKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signer, nil\n}\n\n// NewMultiSigner creates a signer for multiple recipients\nfunc NewMultiSigner() MultiSigner {\n\treturn &genericSigner{\n\t\trecipients: []recipientSigInfo{},\n\t\tembedJwk:   true,\n\t}\n}\n\n// newVerifier creates a verifier based on the key type\nfunc newVerifier(verificationKey interface{}) (payloadVerifier, error) {\n\tswitch verificationKey := verificationKey.(type) {\n\tcase *rsa.PublicKey:\n\t\treturn &rsaEncrypterVerifier{\n\t\t\tpublicKey: verificationKey,\n\t\t}, nil\n\tcase *ecdsa.PublicKey:\n\t\treturn &ecEncrypterVerifier{\n\t\t\tpublicKey: verificationKey,\n\t\t}, nil\n\tcase []byte:\n\t\treturn &symmetricMac{\n\t\t\tkey: verificationKey,\n\t\t}, nil\n\tcase *JsonWebKey:\n\t\treturn newVerifier(verificationKey.Key)\n\tdefault:\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n}\n\nfunc (ctx *genericSigner) AddRecipient(alg SignatureAlgorithm, signingKey interface{}) error {\n\trecipient, err := makeJWSRecipient(alg, signingKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx.recipients = append(ctx.recipients, recipient)\n\treturn nil\n}\n\nfunc makeJWSRecipient(alg SignatureAlgorithm, signingKey interface{}) (recipientSigInfo, error) {\n\tswitch signingKey := signingKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn newRSASigner(alg, signingKey)\n\tcase *ecdsa.PrivateKey:\n\t\treturn newECDSASigner(alg, signingKey)\n\tcase []byte:\n\t\treturn newSymmetricSigner(alg, signingKey)\n\tcase *JsonWebKey:\n\t\trecipient, err := makeJWSRecipient(alg, signingKey.Key)\n\t\tif err != nil {\n\t\t\treturn recipientSigInfo{}, err\n\t\t}\n\t\trecipient.keyID = signingKey.KeyID\n\t\treturn recipient, nil\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedKeyType\n\t}\n}\n\nfunc (ctx *genericSigner) Sign(payload []byte) (*JsonWebSignature, error) {\n\tobj := &JsonWebSignature{}\n\tobj.payload = payload\n\tobj.Signatures = make([]Signature, len(ctx.recipients))\n\n\tfor i, recipient := range ctx.recipients {\n\t\tprotected := &rawHeader{\n\t\t\tAlg: string(recipient.sigAlg),\n\t\t}\n\n\t\tif recipient.publicKey != nil && ctx.embedJwk {\n\t\t\tprotected.Jwk = recipient.publicKey\n\t\t}\n\t\tif recipient.keyID != \"\" {\n\t\t\tprotected.Kid = recipient.keyID\n\t\t}\n\n\t\tif ctx.nonceSource != nil {\n\t\t\tnonce, err := ctx.nonceSource.Nonce()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"square/go-jose: Error generating nonce: %v\", err)\n\t\t\t}\n\t\t\tprotected.Nonce = nonce\n\t\t}\n\n\t\tserializedProtected := mustSerializeJSON(protected)\n\n\t\tinput := []byte(fmt.Sprintf(\"%s.%s\",\n\t\t\tbase64URLEncode(serializedProtected),\n\t\t\tbase64URLEncode(payload)))\n\n\t\tsignatureInfo, err := recipient.signer.signPayload(input, recipient.sigAlg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsignatureInfo.protected = protected\n\t\tobj.Signatures[i] = signatureInfo\n\t}\n\n\treturn obj, nil\n}\n\n// SetNonceSource provides or updates a nonce pool to the first recipients.\n// After this method is called, the signer will consume one nonce per\n// signature, returning an error it is unable to get a nonce.\nfunc (ctx *genericSigner) SetNonceSource(source NonceSource) {\n\tctx.nonceSource = source\n}\n\n// SetEmbedJwk specifies if the signing key should be embedded in the protected header,\n// if any. It defaults to 'true'.\nfunc (ctx *genericSigner) SetEmbedJwk(embed bool) {\n\tctx.embedJwk = embed\n}\n\n// Verify validates the signature on the object and returns the payload.\nfunc (obj JsonWebSignature) Verify(verificationKey interface{}) ([]byte, error) {\n\tverifier, err := newVerifier(verificationKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, signature := range obj.Signatures {\n\t\theaders := signature.mergedHeaders()\n\t\tif len(headers.Crit) > 0 {\n\t\t\t// Unsupported crit header\n\t\t\tcontinue\n\t\t}\n\n\t\tinput := obj.computeAuthData(&signature)\n\t\talg := SignatureAlgorithm(headers.Alg)\n\t\terr := verifier.verifyPayload(input, signature.Signature, alg)\n\t\tif err == nil {\n\t\t\treturn obj.payload, nil\n\t\t}\n\t}\n\n\treturn nil, ErrCryptoFailure\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\ntype staticNonceSource string\n\nfunc (sns staticNonceSource) Nonce() (string, error) {\n\treturn string(sns), nil\n}\n\nfunc RoundtripJWS(sigAlg SignatureAlgorithm, serializer func(*JsonWebSignature) (string, error), corrupter func(*JsonWebSignature), signingKey interface{}, verificationKey interface{}, nonce string) error {\n\tsigner, err := NewSigner(sigAlg, signingKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on new signer: %s\", err)\n\t}\n\n\tif nonce != \"\" {\n\t\tsigner.SetNonceSource(staticNonceSource(nonce))\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on sign: %s\", err)\n\t}\n\n\tmsg, err := serializer(obj)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on serialize: %s\", err)\n\t}\n\n\tobj, err = ParseSigned(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on parse: %s\", err)\n\t}\n\n\t// (Maybe) mangle the object\n\tcorrupter(obj)\n\n\toutput, err := obj.Verify(verificationKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on verify: %s\", err)\n\t}\n\n\t// Check that verify works with embedded keys (if present)\n\tfor i, sig := range obj.Signatures {\n\t\tif sig.Header.JsonWebKey != nil {\n\t\t\t_, err = obj.Verify(sig.Header.JsonWebKey)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error on verify with embedded key %d: %s\", i, err)\n\t\t\t}\n\t\t}\n\n\t\t// Check that the nonce correctly round-tripped (if present)\n\t\tif sig.Header.Nonce != nonce {\n\t\t\treturn fmt.Errorf(\"Incorrect nonce returned: [%s]\", sig.Header.Nonce)\n\t\t}\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\treturn fmt.Errorf(\"input/output do not match, got '%s', expected '%s'\", output, input)\n\t}\n\n\treturn nil\n}\n\nfunc TestRoundtripsJWS(t *testing.T) {\n\t// Test matrix\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512, HS256, HS384, HS512, ES256, ES384, ES512}\n\n\tserializers := []func(*JsonWebSignature) (string, error){\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupter := func(obj *JsonWebSignature) {}\n\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\n\t\tfor i, serializer := range serializers {\n\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err, alg, i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRoundtripsJWSCorruptSignature(t *testing.T) {\n\t// Test matrix\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512, HS256, HS384, HS512, ES256, ES384, ES512}\n\n\tserializers := []func(*JsonWebSignature) (string, error){\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupters := []func(*JsonWebSignature){\n\t\tfunc(obj *JsonWebSignature) {\n\t\t\t// Changes bytes in signature\n\t\t\tobj.Signatures[0].Signature[10]++\n\t\t},\n\t\tfunc(obj *JsonWebSignature) {\n\t\t\t// Set totally invalid signature\n\t\t\tobj.Signatures[0].Signature = []byte(\"###\")\n\t\t},\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\n\t\tfor i, serializer := range serializers {\n\t\t\tfor j, corrupter := range corrupters {\n\t\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(\"failed to detect corrupt signature\", err, alg, i, j)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSignerWithBrokenRand(t *testing.T) {\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512}\n\n\tserializer := func(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() }\n\tcorrupter := func(obj *JsonWebSignature) {}\n\n\t// Break rand reader\n\treaders := []func() io.Reader{\n\t\t// Totally broken\n\t\tfunc() io.Reader { return bytes.NewReader([]byte{}) },\n\t\t// Not enough bytes\n\t\tfunc() io.Reader { return io.LimitReader(rand.Reader, 20) },\n\t}\n\n\tdefer resetRandReader()\n\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\t\tfor i, getReader := range readers {\n\t\t\trandReader = getReader()\n\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"signer should fail if rand is broken\", alg, i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestJWSInvalidKey(t *testing.T) {\n\tsigningKey0, verificationKey0 := GenerateSigningTestKey(RS256)\n\t_, verificationKey1 := GenerateSigningTestKey(ES256)\n\n\tsigner, err := NewSigner(RS256, signingKey0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Must work with correct key\n\t_, err = obj.Verify(verificationKey0)\n\tif err != nil {\n\t\tt.Error(\"error on verify\", err)\n\t}\n\n\t// Must not work with incorrect key\n\t_, err = obj.Verify(verificationKey1)\n\tif err == nil {\n\t\tt.Error(\"verification should fail with incorrect key\")\n\t}\n\n\t// Must not work with invalid key\n\t_, err = obj.Verify(\"\")\n\tif err == nil {\n\t\tt.Error(\"verification should fail with incorrect key\")\n\t}\n}\n\nfunc TestMultiRecipientJWS(t *testing.T) {\n\tsigner := NewMultiSigner()\n\n\tsharedKey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\tsigner.AddRecipient(RS256, rsaTestKey)\n\tsigner.AddRecipient(HS384, sharedKey)\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\tt.Error(\"error on sign: \", err)\n\t\treturn\n\t}\n\n\t_, err = obj.CompactSerialize()\n\tif err == nil {\n\t\tt.Error(\"message with multiple recipient was compact serialized\")\n\t}\n\n\tmsg := obj.FullSerialize()\n\n\tobj, err = ParseSigned(msg)\n\tif err != nil {\n\t\tt.Error(\"error on parse: \", err)\n\t\treturn\n\t}\n\n\toutput, err := obj.Verify(&rsaTestKey.PublicKey)\n\tif err != nil {\n\t\tt.Error(\"error on verify: \", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\tt.Error(\"input/output do not match\", output, input)\n\t\treturn\n\t}\n\n\toutput, err = obj.Verify(sharedKey)\n\tif err != nil {\n\t\tt.Error(\"error on verify: \", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\tt.Error(\"input/output do not match\", output, input)\n\t\treturn\n\t}\n}\n\nfunc GenerateSigningTestKey(sigAlg SignatureAlgorithm) (sig, ver interface{}) {\n\tswitch sigAlg {\n\tcase RS256, RS384, RS512, PS256, PS384, PS512:\n\t\tsig = rsaTestKey\n\t\tver = &rsaTestKey.PublicKey\n\tcase HS256, HS384, HS512:\n\t\tsig, _, _ = randomKeyGenerator{size: 16}.genKey()\n\t\tver = sig\n\tcase ES256:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tcase ES384:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tcase ES512:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tdefault:\n\t\tpanic(\"Must update test case\")\n\t}\n\n\treturn\n}\n\nfunc TestInvalidSignerAlg(t *testing.T) {\n\t_, err := NewSigner(\"XYZ\", nil)\n\tif err == nil {\n\t\tt.Error(\"should not accept invalid algorithm\")\n\t}\n\n\t_, err = NewSigner(\"XYZ\", []byte{})\n\tif err == nil {\n\t\tt.Error(\"should not accept invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidJWS(t *testing.T) {\n\tsigner, err := NewSigner(PS256, rsaTestKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tobj, err := signer.Sign([]byte(\"Lorem ipsum dolor sit amet\"))\n\tobj.Signatures[0].header = &rawHeader{\n\t\tCrit: []string{\"TEST\"},\n\t}\n\n\t_, err = obj.Verify(&rsaTestKey.PublicKey)\n\tif err == nil {\n\t\tt.Error(\"should not verify message with unknown crit header\")\n\t}\n\n\t// Try without alg header\n\tobj.Signatures[0].protected = &rawHeader{}\n\tobj.Signatures[0].header = &rawHeader{}\n\n\t_, err = obj.Verify(&rsaTestKey.PublicKey)\n\tif err == nil {\n\t\tt.Error(\"should not verify message with missing headers\")\n\t}\n}\n\nfunc TestSignerKid(t *testing.T) {\n\tkid := \"DEADBEEF\"\n\tpayload := []byte(\"Lorem ipsum dolor sit amet\")\n\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Error(\"problem generating test signing key\", err)\n\t}\n\n\tbasejwk := JsonWebKey{Key: key}\n\tjsonbar, err := basejwk.MarshalJSON()\n\tif err != nil {\n\t\tt.Error(\"problem marshalling base JWK\", err)\n\t}\n\n\tvar jsonmsi map[string]interface{}\n\terr = json.Unmarshal(jsonbar, &jsonmsi)\n\tif err != nil {\n\t\tt.Error(\"problem unmarshalling base JWK\", err)\n\t}\n\tjsonmsi[\"kid\"] = kid\n\tjsonbar2, err := json.Marshal(jsonmsi)\n\tif err != nil {\n\t\tt.Error(\"problem marshalling kided JWK\", err)\n\t}\n\n\tvar jwk JsonWebKey\n\terr = jwk.UnmarshalJSON(jsonbar2)\n\tif err != nil {\n\t\tt.Error(\"problem unmarshalling kided JWK\", err)\n\t}\n\n\tsigner, err := NewSigner(ES256, &jwk)\n\tif err != nil {\n\t\tt.Error(\"problem creating signer\", err)\n\t}\n\tsigned, err := signer.Sign(payload)\n\n\tserialized := signed.FullSerialize()\n\n\tparsed, err := ParseSigned(serialized)\n\tif err != nil {\n\t\tt.Error(\"problem parsing signed object\", err)\n\t}\n\n\tif parsed.Signatures[0].Header.KeyID != kid {\n\t\tt.Error(\"KeyID did not survive trip\")\n\t}\n}\n\nfunc TestEmbedJwk(t *testing.T) {\n\tvar payload = []byte(\"Lorem ipsum dolor sit amet\")\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Error(\"Failed to generate key\")\n\t}\n\n\tsigner, err := NewSigner(ES256, key)\n\tif err != nil {\n\t\tt.Error(\"Failed to create signer\")\n\t}\n\n\tobject, err := signer.Sign(payload)\n\tif err != nil {\n\t\tt.Error(\"Failed to sign payload\")\n\t}\n\n\tobject, err = ParseSigned(object.FullSerialize())\n\tif err != nil {\n\t\tt.Error(\"Failed to parse jws\")\n\t}\n\n\tif object.Signatures[0].protected.Jwk == nil {\n\t\tt.Error(\"JWK isn't set in protected header\")\n\t}\n\n\t// Now sign it again, but don't embed JWK.\n\tsigner.SetEmbedJwk(false)\n\n\tobject, err = signer.Sign(payload)\n\tif err != nil {\n\t\tt.Error(\"Failed to sign payload\")\n\t}\n\n\tobject, err = ParseSigned(object.FullSerialize())\n\tif err != nil {\n\t\tt.Error(\"Failed to parse jws\")\n\t}\n\n\tif object.Signatures[0].protected.Jwk != nil {\n\t\tt.Error(\"JWK is set in protected header\")\n\t}\n}\n\nfunc TestSignerWithJWKAndKeyID(t *testing.T) {\n\tenc, err := NewSigner(HS256, &JsonWebKey{\n\t\tKeyID: \"test-id\",\n\t\tKey:   []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tsigned, _ := enc.Sign([]byte(\"Lorem ipsum dolor sit amet\"))\n\n\tserialized1, _ := signed.CompactSerialize()\n\tserialized2 := signed.FullSerialize()\n\n\tparsed1, _ := ParseSigned(serialized1)\n\tparsed2, _ := ParseSigned(serialized2)\n\n\tif parsed1.Signatures[0].Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed1.Signatures[0].Header.KeyID)\n\t}\n\tif parsed2.Signatures[0].Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed2.Signatures[0].Header.KeyID)\n\t}\n}\n"], "fixing_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Encrypter represents an encrypter which produces an encrypted JWE object.\ntype Encrypter interface {\n\tEncrypt(plaintext []byte) (*JsonWebEncryption, error)\n\tEncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)\n\tSetCompression(alg CompressionAlgorithm)\n}\n\n// MultiEncrypter represents an encrypter which supports multiple recipients.\ntype MultiEncrypter interface {\n\tEncrypt(plaintext []byte) (*JsonWebEncryption, error)\n\tEncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)\n\tSetCompression(alg CompressionAlgorithm)\n\tAddRecipient(alg KeyAlgorithm, encryptionKey interface{}) error\n}\n\n// A generic content cipher\ntype contentCipher interface {\n\tkeySize() int\n\tencrypt(cek []byte, aad, plaintext []byte) (*aeadParts, error)\n\tdecrypt(cek []byte, aad []byte, parts *aeadParts) ([]byte, error)\n}\n\n// A key generator (for generating/getting a CEK)\ntype keyGenerator interface {\n\tkeySize() int\n\tgenKey() ([]byte, rawHeader, error)\n}\n\n// A generic key encrypter\ntype keyEncrypter interface {\n\tencryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) // Encrypt a key\n}\n\n// A generic key decrypter\ntype keyDecrypter interface {\n\tdecryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) // Decrypt a key\n}\n\n// A generic encrypter based on the given key encrypter and content cipher.\ntype genericEncrypter struct {\n\tcontentAlg     ContentEncryption\n\tcompressionAlg CompressionAlgorithm\n\tcipher         contentCipher\n\trecipients     []recipientKeyInfo\n\tkeyGenerator   keyGenerator\n}\n\ntype recipientKeyInfo struct {\n\tkeyID        string\n\tkeyAlg       KeyAlgorithm\n\tkeyEncrypter keyEncrypter\n}\n\n// SetCompression sets a compression algorithm to be applied before encryption.\nfunc (ctx *genericEncrypter) SetCompression(compressionAlg CompressionAlgorithm) {\n\tctx.compressionAlg = compressionAlg\n}\n\n// NewEncrypter creates an appropriate encrypter based on the key type\nfunc NewEncrypter(alg KeyAlgorithm, enc ContentEncryption, encryptionKey interface{}) (Encrypter, error) {\n\tencrypter := &genericEncrypter{\n\t\tcontentAlg:     enc,\n\t\tcompressionAlg: NONE,\n\t\trecipients:     []recipientKeyInfo{},\n\t\tcipher:         getContentCipher(enc),\n\t}\n\n\tif encrypter.cipher == nil {\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tvar keyID string\n\tvar rawKey interface{}\n\tswitch encryptionKey := encryptionKey.(type) {\n\tcase *JsonWebKey:\n\t\tkeyID = encryptionKey.KeyID\n\t\trawKey = encryptionKey.Key\n\tdefault:\n\t\trawKey = encryptionKey\n\t}\n\n\tswitch alg {\n\tcase DIRECT:\n\t\t// Direct encryption mode must be treated differently\n\t\tif reflect.TypeOf(rawKey) != reflect.TypeOf([]byte{}) {\n\t\t\treturn nil, ErrUnsupportedKeyType\n\t\t}\n\t\tencrypter.keyGenerator = staticKeyGenerator{\n\t\t\tkey: rawKey.([]byte),\n\t\t}\n\t\trecipient, _ := newSymmetricRecipient(alg, rawKey.([]byte))\n\t\tif keyID != \"\" {\n\t\t\trecipient.keyID = keyID\n\t\t}\n\t\tencrypter.recipients = []recipientKeyInfo{recipient}\n\t\treturn encrypter, nil\n\tcase ECDH_ES:\n\t\t// ECDH-ES (w/o key wrapping) is similar to DIRECT mode\n\t\ttypeOf := reflect.TypeOf(rawKey)\n\t\tif typeOf != reflect.TypeOf(&ecdsa.PublicKey{}) {\n\t\t\treturn nil, ErrUnsupportedKeyType\n\t\t}\n\t\tencrypter.keyGenerator = ecKeyGenerator{\n\t\t\tsize:      encrypter.cipher.keySize(),\n\t\t\talgID:     string(enc),\n\t\t\tpublicKey: rawKey.(*ecdsa.PublicKey),\n\t\t}\n\t\trecipient, _ := newECDHRecipient(alg, rawKey.(*ecdsa.PublicKey))\n\t\tif keyID != \"\" {\n\t\t\trecipient.keyID = keyID\n\t\t}\n\t\tencrypter.recipients = []recipientKeyInfo{recipient}\n\t\treturn encrypter, nil\n\tdefault:\n\t\t// Can just add a standard recipient\n\t\tencrypter.keyGenerator = randomKeyGenerator{\n\t\t\tsize: encrypter.cipher.keySize(),\n\t\t}\n\t\terr := encrypter.AddRecipient(alg, encryptionKey)\n\t\treturn encrypter, err\n\t}\n}\n\n// NewMultiEncrypter creates a multi-encrypter based on the given parameters\nfunc NewMultiEncrypter(enc ContentEncryption) (MultiEncrypter, error) {\n\tcipher := getContentCipher(enc)\n\n\tif cipher == nil {\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tencrypter := &genericEncrypter{\n\t\tcontentAlg:     enc,\n\t\tcompressionAlg: NONE,\n\t\trecipients:     []recipientKeyInfo{},\n\t\tcipher:         cipher,\n\t\tkeyGenerator: randomKeyGenerator{\n\t\t\tsize: cipher.keySize(),\n\t\t},\n\t}\n\n\treturn encrypter, nil\n}\n\nfunc (ctx *genericEncrypter) AddRecipient(alg KeyAlgorithm, encryptionKey interface{}) (err error) {\n\tvar recipient recipientKeyInfo\n\n\tswitch alg {\n\tcase DIRECT, ECDH_ES:\n\t\treturn fmt.Errorf(\"square/go-jose: key algorithm '%s' not supported in multi-recipient mode\", alg)\n\t}\n\n\trecipient, err = makeJWERecipient(alg, encryptionKey)\n\n\tif err == nil {\n\t\tctx.recipients = append(ctx.recipients, recipient)\n\t}\n\treturn err\n}\n\nfunc makeJWERecipient(alg KeyAlgorithm, encryptionKey interface{}) (recipientKeyInfo, error) {\n\tswitch encryptionKey := encryptionKey.(type) {\n\tcase *rsa.PublicKey:\n\t\treturn newRSARecipient(alg, encryptionKey)\n\tcase *ecdsa.PublicKey:\n\t\treturn newECDHRecipient(alg, encryptionKey)\n\tcase []byte:\n\t\treturn newSymmetricRecipient(alg, encryptionKey)\n\tcase *JsonWebKey:\n\t\trecipient, err := makeJWERecipient(alg, encryptionKey.Key)\n\t\tif err == nil && encryptionKey.KeyID != \"\" {\n\t\t\trecipient.keyID = encryptionKey.KeyID\n\t\t}\n\t\treturn recipient, err\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedKeyType\n\t}\n}\n\n// newDecrypter creates an appropriate decrypter based on the key type\nfunc newDecrypter(decryptionKey interface{}) (keyDecrypter, error) {\n\tswitch decryptionKey := decryptionKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn &rsaDecrypterSigner{\n\t\t\tprivateKey: decryptionKey,\n\t\t}, nil\n\tcase *ecdsa.PrivateKey:\n\t\treturn &ecDecrypterSigner{\n\t\t\tprivateKey: decryptionKey,\n\t\t}, nil\n\tcase []byte:\n\t\treturn &symmetricKeyCipher{\n\t\t\tkey: decryptionKey,\n\t\t}, nil\n\tcase *JsonWebKey:\n\t\treturn newDecrypter(decryptionKey.Key)\n\tdefault:\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n}\n\n// Implementation of encrypt method producing a JWE object.\nfunc (ctx *genericEncrypter) Encrypt(plaintext []byte) (*JsonWebEncryption, error) {\n\treturn ctx.EncryptWithAuthData(plaintext, nil)\n}\n\n// Implementation of encrypt method producing a JWE object.\nfunc (ctx *genericEncrypter) EncryptWithAuthData(plaintext, aad []byte) (*JsonWebEncryption, error) {\n\tobj := &JsonWebEncryption{}\n\tobj.aad = aad\n\n\tobj.protected = &rawHeader{\n\t\tEnc: ctx.contentAlg,\n\t}\n\tobj.recipients = make([]recipientInfo, len(ctx.recipients))\n\n\tif len(ctx.recipients) == 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: no recipients to encrypt to\")\n\t}\n\n\tcek, headers, err := ctx.keyGenerator.genKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobj.protected.merge(&headers)\n\n\tfor i, info := range ctx.recipients {\n\t\trecipient, err := info.keyEncrypter.encryptKey(cek, info.keyAlg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trecipient.header.Alg = string(info.keyAlg)\n\t\tif info.keyID != \"\" {\n\t\t\trecipient.header.Kid = info.keyID\n\t\t}\n\t\tobj.recipients[i] = recipient\n\t}\n\n\tif len(ctx.recipients) == 1 {\n\t\t// Move per-recipient headers into main protected header if there's\n\t\t// only a single recipient.\n\t\tobj.protected.merge(obj.recipients[0].header)\n\t\tobj.recipients[0].header = nil\n\t}\n\n\tif ctx.compressionAlg != NONE {\n\t\tplaintext, err = compress(ctx.compressionAlg, plaintext)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tobj.protected.Zip = ctx.compressionAlg\n\t}\n\n\tauthData := obj.computeAuthData()\n\tparts, err := ctx.cipher.encrypt(cek, authData, plaintext)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobj.iv = parts.iv\n\tobj.ciphertext = parts.ciphertext\n\tobj.tag = parts.tag\n\n\treturn obj, nil\n}\n\n// Decrypt and validate the object and return the plaintext. Note that this\n// function does not support multi-recipient, if you desire multi-recipient\n// decryption use DecryptMulti instead.\nfunc (obj JsonWebEncryption) Decrypt(decryptionKey interface{}) ([]byte, error) {\n\theaders := obj.mergedHeaders(nil)\n\n\tif len(obj.recipients) > 1 {\n\t\treturn nil, errors.New(\"square/go-jose: too many recipients in payload; expecting only one\")\n\t}\n\n\tif len(headers.Crit) > 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported crit header\")\n\t}\n\n\tdecrypter, err := newDecrypter(decryptionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcipher := getContentCipher(headers.Enc)\n\tif cipher == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported enc value '%s'\", string(headers.Enc))\n\t}\n\n\tgenerator := randomKeyGenerator{\n\t\tsize: cipher.keySize(),\n\t}\n\n\tparts := &aeadParts{\n\t\tiv:         obj.iv,\n\t\tciphertext: obj.ciphertext,\n\t\ttag:        obj.tag,\n\t}\n\n\tauthData := obj.computeAuthData()\n\n\tvar plaintext []byte\n\trecipient := obj.recipients[0]\n\trecipientHeaders := obj.mergedHeaders(&recipient)\n\n\tcek, err := decrypter.decryptKey(recipientHeaders, &recipient, generator)\n\tif err == nil {\n\t\t// Found a valid CEK -- let's try to decrypt.\n\t\tplaintext, err = cipher.decrypt(cek, authData, parts)\n\t}\n\n\tif plaintext == nil {\n\t\treturn nil, ErrCryptoFailure\n\t}\n\n\t// The \"zip\" header parameter may only be present in the protected header.\n\tif obj.protected.Zip != \"\" {\n\t\tplaintext, err = decompress(obj.protected.Zip, plaintext)\n\t}\n\n\treturn plaintext, err\n}\n\n// DecryptMulti decrypts and validates the object and returns the plaintexts,\n// with support for multiple recipients. It returns the index of the recipient\n// for which the decryption was successful, the merged headers for that recipient,\n// and the plaintext.\nfunc (obj JsonWebEncryption) DecryptMulti(decryptionKey interface{}) (int, JoseHeader, []byte, error) {\n\tglobalHeaders := obj.mergedHeaders(nil)\n\n\tif len(globalHeaders.Crit) > 0 {\n\t\treturn -1, JoseHeader{}, nil, fmt.Errorf(\"square/go-jose: unsupported crit header\")\n\t}\n\n\tdecrypter, err := newDecrypter(decryptionKey)\n\tif err != nil {\n\t\treturn -1, JoseHeader{}, nil, err\n\t}\n\n\tcipher := getContentCipher(globalHeaders.Enc)\n\tif cipher == nil {\n\t\treturn -1, JoseHeader{}, nil, fmt.Errorf(\"square/go-jose: unsupported enc value '%s'\", string(globalHeaders.Enc))\n\t}\n\n\tgenerator := randomKeyGenerator{\n\t\tsize: cipher.keySize(),\n\t}\n\n\tparts := &aeadParts{\n\t\tiv:         obj.iv,\n\t\tciphertext: obj.ciphertext,\n\t\ttag:        obj.tag,\n\t}\n\n\tauthData := obj.computeAuthData()\n\n\tindex := -1\n\tvar plaintext []byte\n\tvar headers rawHeader\n\n\tfor i, recipient := range obj.recipients {\n\t\trecipientHeaders := obj.mergedHeaders(&recipient)\n\n\t\tcek, err := decrypter.decryptKey(recipientHeaders, &recipient, generator)\n\t\tif err == nil {\n\t\t\t// Found a valid CEK -- let's try to decrypt.\n\t\t\tplaintext, err = cipher.decrypt(cek, authData, parts)\n\t\t\tif err == nil {\n\t\t\t\tindex = i\n\t\t\t\theaders = recipientHeaders\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif plaintext == nil || err != nil {\n\t\treturn -1, JoseHeader{}, nil, ErrCryptoFailure\n\t}\n\n\t// The \"zip\" header parameter may only be present in the protected header.\n\tif obj.protected.Zip != \"\" {\n\t\tplaintext, err = decompress(obj.protected.Zip, plaintext)\n\t}\n\n\treturn index, headers.sanitized(), plaintext, err\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n)\n\n// We generate only a single RSA and EC key for testing, speeds up tests.\nvar rsaTestKey, _ = rsa.GenerateKey(rand.Reader, 2048)\n\nvar ecTestKey256, _ = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\nvar ecTestKey384, _ = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\nvar ecTestKey521, _ = ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\nfunc RoundtripJWE(keyAlg KeyAlgorithm, encAlg ContentEncryption, compressionAlg CompressionAlgorithm, serializer func(*JsonWebEncryption) (string, error), corrupter func(*JsonWebEncryption) bool, aad []byte, encryptionKey interface{}, decryptionKey interface{}) error {\n\tenc, err := NewEncrypter(keyAlg, encAlg, encryptionKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on new encrypter: %s\", err)\n\t}\n\n\tenc.SetCompression(compressionAlg)\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := enc.EncryptWithAuthData(input, aad)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in encrypt: %s\", err)\n\t}\n\n\tmsg, err := serializer(obj)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in serializer: %s\", err)\n\t}\n\n\tparsed, err := ParseEncrypted(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error in parse: %s, on msg '%s'\", err, msg)\n\t}\n\n\t// (Maybe) mangle object\n\tskip := corrupter(parsed)\n\tif skip {\n\t\treturn fmt.Errorf(\"corrupter indicated message should be skipped\")\n\t}\n\n\tif bytes.Compare(parsed.GetAuthData(), aad) != 0 {\n\t\treturn fmt.Errorf(\"auth data in parsed object does not match\")\n\t}\n\n\toutput, err := parsed.Decrypt(decryptionKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on decrypt: %s\", err)\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\treturn fmt.Errorf(\"Decrypted output does not match input, got '%s' but wanted '%s'\", output, input)\n\t}\n\n\treturn nil\n}\n\nfunc TestRoundtripsJWE(t *testing.T) {\n\t// Test matrix\n\tkeyAlgs := []KeyAlgorithm{\n\t\tDIRECT, ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW, A128KW, A192KW, A256KW,\n\t\tRSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW, A192GCMKW, A256GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\tzipAlgs := []CompressionAlgorithm{NONE, DEFLATE}\n\n\tserializers := []func(*JsonWebEncryption) (string, error){\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\t// Note: can't use AAD with compact serialization\n\taads := [][]byte{\n\t\tnil,\n\t\t[]byte(\"Ut enim ad minim veniam\"),\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor _, zip := range zipAlgs {\n\t\t\t\t\tfor i, serializer := range serializers {\n\t\t\t\t\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, aads[i], key.enc, key.dec)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Error(err, alg, enc, zip, i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRoundtripsJWECorrupted(t *testing.T) {\n\t// Test matrix\n\tkeyAlgs := []KeyAlgorithm{DIRECT, ECDH_ES, ECDH_ES_A128KW, A128KW, RSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\tzipAlgs := []CompressionAlgorithm{NONE, DEFLATE}\n\n\tserializers := []func(*JsonWebEncryption) (string, error){\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebEncryption) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tbitflip := func(slice []byte) bool {\n\t\tif len(slice) > 0 {\n\t\t\tslice[0] ^= 0xFF\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tcorrupters := []func(*JsonWebEncryption) bool{\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid ciphertext\n\t\t\treturn bitflip(obj.ciphertext)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid auth tag\n\t\t\treturn bitflip(obj.tag)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Set invalid AAD\n\t\t\treturn bitflip(obj.aad)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Mess with encrypted key\n\t\t\treturn bitflip(obj.recipients[0].encryptedKey)\n\t\t},\n\t\tfunc(obj *JsonWebEncryption) bool {\n\t\t\t// Mess with GCM-KW auth tag\n\t\t\treturn bitflip(obj.protected.Tag.bytes())\n\t\t},\n\t}\n\n\t// Note: can't use AAD with compact serialization\n\taads := [][]byte{\n\t\tnil,\n\t\t[]byte(\"Ut enim ad minim veniam\"),\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor _, zip := range zipAlgs {\n\t\t\t\t\tfor i, serializer := range serializers {\n\t\t\t\t\t\tfor j, corrupter := range corrupters {\n\t\t\t\t\t\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, aads[i], key.enc, key.dec)\n\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\tt.Error(\"failed to detect corrupt data\", err, alg, enc, zip, i, j)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEncrypterWithJWKAndKeyID(t *testing.T) {\n\tenc, err := NewEncrypter(A128KW, A128GCM, &JsonWebKey{\n\t\tKeyID: \"test-id\",\n\t\tKey:   []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tciphertext, _ := enc.Encrypt([]byte(\"Lorem ipsum dolor sit amet\"))\n\n\tserialized1, _ := ciphertext.CompactSerialize()\n\tserialized2 := ciphertext.FullSerialize()\n\n\tparsed1, _ := ParseEncrypted(serialized1)\n\tparsed2, _ := ParseEncrypted(serialized2)\n\n\tif parsed1.Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed1.Header.KeyID)\n\t}\n\tif parsed2.Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed2.Header.KeyID)\n\t}\n}\n\nfunc TestEncrypterWithBrokenRand(t *testing.T) {\n\tkeyAlgs := []KeyAlgorithm{ECDH_ES_A128KW, A128KW, RSA1_5, RSA_OAEP, RSA_OAEP_256, A128GCMKW}\n\tencAlgs := []ContentEncryption{A128GCM, A192GCM, A256GCM, A128CBC_HS256, A192CBC_HS384, A256CBC_HS512}\n\n\tserializer := func(obj *JsonWebEncryption) (string, error) { return obj.CompactSerialize() }\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\t// Break rand reader\n\treaders := []func() io.Reader{\n\t\t// Totally broken\n\t\tfunc() io.Reader { return bytes.NewReader([]byte{}) },\n\t\t// Not enough bytes\n\t\tfunc() io.Reader { return io.LimitReader(rand.Reader, 20) },\n\t}\n\n\tdefer resetRandReader()\n\n\tfor _, alg := range keyAlgs {\n\t\tfor _, enc := range encAlgs {\n\t\t\tfor _, key := range generateTestKeys(alg, enc) {\n\t\t\t\tfor i, getReader := range readers {\n\t\t\t\t\trandReader = getReader()\n\t\t\t\t\terr := RoundtripJWE(alg, enc, NONE, serializer, corrupter, nil, key.enc, key.dec)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tt.Error(\"encrypter should fail if rand is broken\", i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNewEncrypterErrors(t *testing.T) {\n\t_, err := NewEncrypter(\"XYZ\", \"XYZ\", nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid cipher\")\n\t}\n\n\t_, err = NewMultiEncrypter(\"XYZ\")\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate multi-encrypter with invalid cipher\")\n\t}\n\n\t_, err = NewEncrypter(DIRECT, A128GCM, nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid direct key\")\n\t}\n\n\t_, err = NewEncrypter(ECDH_ES, A128GCM, nil)\n\tif err == nil {\n\t\tt.Error(\"was able to instantiate encrypter with invalid EC key\")\n\t}\n}\n\nfunc TestMultiRecipientJWE(t *testing.T) {\n\tenc, err := NewMultiEncrypter(A128GCM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = enc.AddRecipient(RSA_OAEP, &rsaTestKey.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(\"error when adding RSA recipient\", err)\n\t}\n\n\tsharedKey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\terr = enc.AddRecipient(A256GCMKW, sharedKey)\n\tif err != nil {\n\t\tt.Fatal(\"error when adding AES recipient: \", err)\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := enc.Encrypt(input)\n\tif err != nil {\n\t\tt.Fatal(\"error in encrypt: \", err)\n\t}\n\n\tmsg := obj.FullSerialize()\n\n\tparsed, err := ParseEncrypted(msg)\n\tif err != nil {\n\t\tt.Fatal(\"error in parse: \", err)\n\t}\n\n\ti, _, output, err := parsed.DecryptMulti(rsaTestKey)\n\tif err != nil {\n\t\tt.Fatal(\"error on decrypt with RSA: \", err)\n\t}\n\n\tif i != 0 {\n\t\tt.Fatal(\"recipient index should be 0 for RSA key\")\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\tt.Fatal(\"Decrypted output does not match input: \", output, input)\n\t}\n\n\ti, _, output, err = parsed.DecryptMulti(sharedKey)\n\tif err != nil {\n\t\tt.Fatal(\"error on decrypt with AES: \", err)\n\t}\n\n\tif i != 1 {\n\t\tt.Fatal(\"recipient index should be 1 for shared key\")\n\t}\n\n\tif bytes.Compare(input, output) != 0 {\n\t\tt.Fatal(\"Decrypted output does not match input\", output, input)\n\t}\n}\n\nfunc TestMultiRecipientErrors(t *testing.T) {\n\tenc, err := NewMultiEncrypter(A128GCM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\t_, err = enc.Encrypt(input)\n\tif err == nil {\n\t\tt.Error(\"should fail when encrypting to zero recipients\")\n\t}\n\n\terr = enc.AddRecipient(DIRECT, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject DIRECT mode when encrypting to multiple recipients\")\n\t}\n\n\terr = enc.AddRecipient(ECDH_ES, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject ECDH_ES mode when encrypting to multiple recipients\")\n\t}\n\n\terr = enc.AddRecipient(RSA1_5, nil)\n\tif err == nil {\n\t\tt.Error(\"should reject invalid recipient key\")\n\t}\n}\n\ntype testKey struct {\n\tenc, dec interface{}\n}\n\nfunc symmetricTestKey(size int) []testKey {\n\tkey, _, _ := randomKeyGenerator{size: size}.genKey()\n\n\treturn []testKey{\n\t\ttestKey{\n\t\t\tenc: key,\n\t\t\tdec: key,\n\t\t},\n\t\ttestKey{\n\t\t\tenc: &JsonWebKey{KeyID: \"test\", Key: key},\n\t\t\tdec: &JsonWebKey{KeyID: \"test\", Key: key},\n\t\t},\n\t}\n}\n\nfunc generateTestKeys(keyAlg KeyAlgorithm, encAlg ContentEncryption) []testKey {\n\tswitch keyAlg {\n\tcase DIRECT:\n\t\treturn symmetricTestKey(getContentCipher(encAlg).keySize())\n\tcase ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\t\treturn []testKey{\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey256,\n\t\t\t\tenc: &ecTestKey256.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey384,\n\t\t\t\tenc: &ecTestKey384.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: ecTestKey521,\n\t\t\t\tenc: &ecTestKey521.PublicKey,\n\t\t\t},\n\t\t\ttestKey{\n\t\t\t\tdec: &JsonWebKey{KeyID: \"test\", Key: ecTestKey256},\n\t\t\t\tenc: &JsonWebKey{KeyID: \"test\", Key: &ecTestKey256.PublicKey},\n\t\t\t},\n\t\t}\n\tcase A128GCMKW, A128KW:\n\t\treturn symmetricTestKey(16)\n\tcase A192GCMKW, A192KW:\n\t\treturn symmetricTestKey(24)\n\tcase A256GCMKW, A256KW:\n\t\treturn symmetricTestKey(32)\n\tcase RSA1_5, RSA_OAEP, RSA_OAEP_256:\n\t\treturn []testKey{testKey{\n\t\t\tdec: rsaTestKey,\n\t\t\tenc: &rsaTestKey.PublicKey,\n\t\t}}\n\t}\n\n\tpanic(\"Must update test case\")\n}\n\nfunc RunRoundtripsJWE(b *testing.B, alg KeyAlgorithm, enc ContentEncryption, zip CompressionAlgorithm, priv, pub interface{}) {\n\tserializer := func(obj *JsonWebEncryption) (string, error) {\n\t\treturn obj.CompactSerialize()\n\t}\n\n\tcorrupter := func(obj *JsonWebEncryption) bool { return false }\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr := RoundtripJWE(alg, enc, zip, serializer, corrupter, nil, pub, priv)\n\t\tif err != nil {\n\t\t\tb.Error(err)\n\t\t}\n\t}\n}\n\nvar (\n\tchunks = map[string][]byte{\n\t\t\"1B\":   make([]byte, 1),\n\t\t\"64B\":  make([]byte, 64),\n\t\t\"1KB\":  make([]byte, 1024),\n\t\t\"64KB\": make([]byte, 65536),\n\t\t\"1MB\":  make([]byte, 1048576),\n\t\t\"64MB\": make([]byte, 67108864),\n\t}\n\n\tsymKey, _, _ = randomKeyGenerator{size: 32}.genKey()\n\n\tencrypters = map[string]Encrypter{\n\t\t\"OAEPAndGCM\":          mustEncrypter(RSA_OAEP, A128GCM, &rsaTestKey.PublicKey),\n\t\t\"PKCSAndGCM\":          mustEncrypter(RSA1_5, A128GCM, &rsaTestKey.PublicKey),\n\t\t\"OAEPAndCBC\":          mustEncrypter(RSA_OAEP, A128CBC_HS256, &rsaTestKey.PublicKey),\n\t\t\"PKCSAndCBC\":          mustEncrypter(RSA1_5, A128CBC_HS256, &rsaTestKey.PublicKey),\n\t\t\"DirectGCM128\":        mustEncrypter(DIRECT, A128GCM, symKey),\n\t\t\"DirectCBC128\":        mustEncrypter(DIRECT, A128CBC_HS256, symKey),\n\t\t\"DirectGCM256\":        mustEncrypter(DIRECT, A256GCM, symKey),\n\t\t\"DirectCBC256\":        mustEncrypter(DIRECT, A256CBC_HS512, symKey),\n\t\t\"AESKWAndGCM128\":      mustEncrypter(A128KW, A128GCM, symKey),\n\t\t\"AESKWAndCBC256\":      mustEncrypter(A256KW, A256GCM, symKey),\n\t\t\"ECDHOnP256AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey256.PublicKey),\n\t\t\"ECDHOnP384AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey384.PublicKey),\n\t\t\"ECDHOnP521AndGCM128\": mustEncrypter(ECDH_ES, A128GCM, &ecTestKey521.PublicKey),\n\t}\n)\n\nfunc BenchmarkEncrypt1BWithOAEPAndGCM(b *testing.B)   { benchEncrypt(\"1B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64BWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"64B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt1KBWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"1KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64KBWithOAEPAndGCM(b *testing.B) { benchEncrypt(\"64KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt1MBWithOAEPAndGCM(b *testing.B)  { benchEncrypt(\"1MB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkEncrypt64MBWithOAEPAndGCM(b *testing.B) { benchEncrypt(\"64MB\", \"OAEPAndGCM\", b) }\n\nfunc BenchmarkEncrypt1BWithPKCSAndGCM(b *testing.B)   { benchEncrypt(\"1B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64BWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"64B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt1KBWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"1KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64KBWithPKCSAndGCM(b *testing.B) { benchEncrypt(\"64KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt1MBWithPKCSAndGCM(b *testing.B)  { benchEncrypt(\"1MB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkEncrypt64MBWithPKCSAndGCM(b *testing.B) { benchEncrypt(\"64MB\", \"PKCSAndGCM\", b) }\n\nfunc BenchmarkEncrypt1BWithOAEPAndCBC(b *testing.B)   { benchEncrypt(\"1B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64BWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"64B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt1KBWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"1KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64KBWithOAEPAndCBC(b *testing.B) { benchEncrypt(\"64KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt1MBWithOAEPAndCBC(b *testing.B)  { benchEncrypt(\"1MB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkEncrypt64MBWithOAEPAndCBC(b *testing.B) { benchEncrypt(\"64MB\", \"OAEPAndCBC\", b) }\n\nfunc BenchmarkEncrypt1BWithPKCSAndCBC(b *testing.B)   { benchEncrypt(\"1B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64BWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"64B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt1KBWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"1KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64KBWithPKCSAndCBC(b *testing.B) { benchEncrypt(\"64KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt1MBWithPKCSAndCBC(b *testing.B)  { benchEncrypt(\"1MB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkEncrypt64MBWithPKCSAndCBC(b *testing.B) { benchEncrypt(\"64MB\", \"PKCSAndCBC\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectGCM128(b *testing.B)   { benchEncrypt(\"1B\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64BWithDirectGCM128(b *testing.B)  { benchEncrypt(\"64B\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt1KBWithDirectGCM128(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64KBWithDirectGCM128(b *testing.B) { benchEncrypt(\"64KB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt1MBWithDirectGCM128(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectGCM128\", b) }\nfunc BenchmarkEncrypt64MBWithDirectGCM128(b *testing.B) { benchEncrypt(\"64MB\", \"DirectGCM128\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectCBC128(b *testing.B)   { benchEncrypt(\"1B\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64BWithDirectCBC128(b *testing.B)  { benchEncrypt(\"64B\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt1KBWithDirectCBC128(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64KBWithDirectCBC128(b *testing.B) { benchEncrypt(\"64KB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt1MBWithDirectCBC128(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectCBC128\", b) }\nfunc BenchmarkEncrypt64MBWithDirectCBC128(b *testing.B) { benchEncrypt(\"64MB\", \"DirectCBC128\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectGCM256(b *testing.B)   { benchEncrypt(\"1B\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64BWithDirectGCM256(b *testing.B)  { benchEncrypt(\"64B\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt1KBWithDirectGCM256(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64KBWithDirectGCM256(b *testing.B) { benchEncrypt(\"64KB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt1MBWithDirectGCM256(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectGCM256\", b) }\nfunc BenchmarkEncrypt64MBWithDirectGCM256(b *testing.B) { benchEncrypt(\"64MB\", \"DirectGCM256\", b) }\n\nfunc BenchmarkEncrypt1BWithDirectCBC256(b *testing.B)   { benchEncrypt(\"1B\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64BWithDirectCBC256(b *testing.B)  { benchEncrypt(\"64B\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt1KBWithDirectCBC256(b *testing.B)  { benchEncrypt(\"1KB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64KBWithDirectCBC256(b *testing.B) { benchEncrypt(\"64KB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt1MBWithDirectCBC256(b *testing.B)  { benchEncrypt(\"1MB\", \"DirectCBC256\", b) }\nfunc BenchmarkEncrypt64MBWithDirectCBC256(b *testing.B) { benchEncrypt(\"64MB\", \"DirectCBC256\", b) }\n\nfunc BenchmarkEncrypt1BWithAESKWAndGCM128(b *testing.B)   { benchEncrypt(\"1B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64BWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"64B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt1KBWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"1KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64KBWithAESKWAndGCM128(b *testing.B) { benchEncrypt(\"64KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt1MBWithAESKWAndGCM128(b *testing.B)  { benchEncrypt(\"1MB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkEncrypt64MBWithAESKWAndGCM128(b *testing.B) { benchEncrypt(\"64MB\", \"AESKWAndGCM128\", b) }\n\nfunc BenchmarkEncrypt1BWithAESKWAndCBC256(b *testing.B)   { benchEncrypt(\"1B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64BWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"64B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt1KBWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"1KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64KBWithAESKWAndCBC256(b *testing.B) { benchEncrypt(\"64KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt1MBWithAESKWAndCBC256(b *testing.B)  { benchEncrypt(\"1MB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkEncrypt64MBWithAESKWAndCBC256(b *testing.B) { benchEncrypt(\"64MB\", \"AESKWAndCBC256\", b) }\n\nfunc BenchmarkEncrypt1BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP256AndGCM128\", b)\n}\n\nfunc BenchmarkEncrypt1BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP384AndGCM128\", b)\n}\n\nfunc BenchmarkEncrypt1BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt1MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"1MB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkEncrypt64MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchEncrypt(\"64MB\", \"ECDHOnP521AndGCM128\", b)\n}\n\nfunc benchEncrypt(chunkKey, primKey string, b *testing.B) {\n\tdata, ok := chunks[chunkKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown chunk size %s\", chunkKey)\n\t}\n\n\tenc, ok := encrypters[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown encrypter %s\", primKey)\n\t}\n\n\tb.SetBytes(int64(len(data)))\n\tfor i := 0; i < b.N; i++ {\n\t\tenc.Encrypt(data)\n\t}\n}\n\nvar (\n\tdecryptionKeys = map[string]interface{}{\n\t\t\"OAEPAndGCM\": rsaTestKey,\n\t\t\"PKCSAndGCM\": rsaTestKey,\n\t\t\"OAEPAndCBC\": rsaTestKey,\n\t\t\"PKCSAndCBC\": rsaTestKey,\n\n\t\t\"DirectGCM128\": symKey,\n\t\t\"DirectCBC128\": symKey,\n\t\t\"DirectGCM256\": symKey,\n\t\t\"DirectCBC256\": symKey,\n\n\t\t\"AESKWAndGCM128\": symKey,\n\t\t\"AESKWAndCBC256\": symKey,\n\n\t\t\"ECDHOnP256AndGCM128\": ecTestKey256,\n\t\t\"ECDHOnP384AndGCM128\": ecTestKey384,\n\t\t\"ECDHOnP521AndGCM128\": ecTestKey521,\n\t}\n)\n\nfunc BenchmarkDecrypt1BWithOAEPAndGCM(b *testing.B)   { benchDecrypt(\"1B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64BWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"64B\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt1KBWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"1KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64KBWithOAEPAndGCM(b *testing.B) { benchDecrypt(\"64KB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt1MBWithOAEPAndGCM(b *testing.B)  { benchDecrypt(\"1MB\", \"OAEPAndGCM\", b) }\nfunc BenchmarkDecrypt64MBWithOAEPAndGCM(b *testing.B) { benchDecrypt(\"64MB\", \"OAEPAndGCM\", b) }\n\nfunc BenchmarkDecrypt1BWithPKCSAndGCM(b *testing.B)   { benchDecrypt(\"1B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64BWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"64B\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt1KBWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"1KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64KBWithPKCSAndGCM(b *testing.B) { benchDecrypt(\"64KB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt1MBWithPKCSAndGCM(b *testing.B)  { benchDecrypt(\"1MB\", \"PKCSAndGCM\", b) }\nfunc BenchmarkDecrypt64MBWithPKCSAndGCM(b *testing.B) { benchDecrypt(\"64MB\", \"PKCSAndGCM\", b) }\n\nfunc BenchmarkDecrypt1BWithOAEPAndCBC(b *testing.B)   { benchDecrypt(\"1B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64BWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"64B\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt1KBWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"1KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64KBWithOAEPAndCBC(b *testing.B) { benchDecrypt(\"64KB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt1MBWithOAEPAndCBC(b *testing.B)  { benchDecrypt(\"1MB\", \"OAEPAndCBC\", b) }\nfunc BenchmarkDecrypt64MBWithOAEPAndCBC(b *testing.B) { benchDecrypt(\"64MB\", \"OAEPAndCBC\", b) }\n\nfunc BenchmarkDecrypt1BWithPKCSAndCBC(b *testing.B)   { benchDecrypt(\"1B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64BWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"64B\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt1KBWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"1KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64KBWithPKCSAndCBC(b *testing.B) { benchDecrypt(\"64KB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt1MBWithPKCSAndCBC(b *testing.B)  { benchDecrypt(\"1MB\", \"PKCSAndCBC\", b) }\nfunc BenchmarkDecrypt64MBWithPKCSAndCBC(b *testing.B) { benchDecrypt(\"64MB\", \"PKCSAndCBC\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectGCM128(b *testing.B)   { benchDecrypt(\"1B\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64BWithDirectGCM128(b *testing.B)  { benchDecrypt(\"64B\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt1KBWithDirectGCM128(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64KBWithDirectGCM128(b *testing.B) { benchDecrypt(\"64KB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt1MBWithDirectGCM128(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectGCM128\", b) }\nfunc BenchmarkDecrypt64MBWithDirectGCM128(b *testing.B) { benchDecrypt(\"64MB\", \"DirectGCM128\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectCBC128(b *testing.B)   { benchDecrypt(\"1B\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64BWithDirectCBC128(b *testing.B)  { benchDecrypt(\"64B\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt1KBWithDirectCBC128(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64KBWithDirectCBC128(b *testing.B) { benchDecrypt(\"64KB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt1MBWithDirectCBC128(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectCBC128\", b) }\nfunc BenchmarkDecrypt64MBWithDirectCBC128(b *testing.B) { benchDecrypt(\"64MB\", \"DirectCBC128\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectGCM256(b *testing.B)   { benchDecrypt(\"1B\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64BWithDirectGCM256(b *testing.B)  { benchDecrypt(\"64B\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt1KBWithDirectGCM256(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64KBWithDirectGCM256(b *testing.B) { benchDecrypt(\"64KB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt1MBWithDirectGCM256(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectGCM256\", b) }\nfunc BenchmarkDecrypt64MBWithDirectGCM256(b *testing.B) { benchDecrypt(\"64MB\", \"DirectGCM256\", b) }\n\nfunc BenchmarkDecrypt1BWithDirectCBC256(b *testing.B)   { benchDecrypt(\"1B\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64BWithDirectCBC256(b *testing.B)  { benchDecrypt(\"64B\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt1KBWithDirectCBC256(b *testing.B)  { benchDecrypt(\"1KB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64KBWithDirectCBC256(b *testing.B) { benchDecrypt(\"64KB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt1MBWithDirectCBC256(b *testing.B)  { benchDecrypt(\"1MB\", \"DirectCBC256\", b) }\nfunc BenchmarkDecrypt64MBWithDirectCBC256(b *testing.B) { benchDecrypt(\"64MB\", \"DirectCBC256\", b) }\n\nfunc BenchmarkDecrypt1BWithAESKWAndGCM128(b *testing.B)   { benchDecrypt(\"1B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64BWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"64B\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt1KBWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"1KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64KBWithAESKWAndGCM128(b *testing.B) { benchDecrypt(\"64KB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt1MBWithAESKWAndGCM128(b *testing.B)  { benchDecrypt(\"1MB\", \"AESKWAndGCM128\", b) }\nfunc BenchmarkDecrypt64MBWithAESKWAndGCM128(b *testing.B) { benchDecrypt(\"64MB\", \"AESKWAndGCM128\", b) }\n\nfunc BenchmarkDecrypt1BWithAESKWAndCBC256(b *testing.B)   { benchDecrypt(\"1B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64BWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"64B\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt1KBWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"1KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64KBWithAESKWAndCBC256(b *testing.B) { benchDecrypt(\"64KB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt1MBWithAESKWAndCBC256(b *testing.B)  { benchDecrypt(\"1MB\", \"AESKWAndCBC256\", b) }\nfunc BenchmarkDecrypt64MBWithAESKWAndCBC256(b *testing.B) { benchDecrypt(\"64MB\", \"AESKWAndCBC256\", b) }\n\nfunc BenchmarkDecrypt1BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP256AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP256AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP256AndGCM128\", b)\n}\n\nfunc BenchmarkDecrypt1BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP384AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP384AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP384AndGCM128\", b)\n}\n\nfunc BenchmarkDecrypt1BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64BWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64B\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64KBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64KB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt1MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"1MB\", \"ECDHOnP521AndGCM128\", b)\n}\nfunc BenchmarkDecrypt64MBWithECDHOnP521AndGCM128(b *testing.B) {\n\tbenchDecrypt(\"64MB\", \"ECDHOnP521AndGCM128\", b)\n}\n\nfunc benchDecrypt(chunkKey, primKey string, b *testing.B) {\n\tchunk, ok := chunks[chunkKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown chunk size %s\", chunkKey)\n\t}\n\n\tenc, ok := encrypters[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown encrypter %s\", primKey)\n\t}\n\n\tdec, ok := decryptionKeys[primKey]\n\tif !ok {\n\t\tb.Fatalf(\"unknown decryption key %s\", primKey)\n\t}\n\n\tdata, err := enc.Encrypt(chunk)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.SetBytes(int64(len(chunk)))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tdata.Decrypt(dec)\n\t}\n}\n\nfunc mustEncrypter(keyAlg KeyAlgorithm, encAlg ContentEncryption, encryptionKey interface{}) Encrypter {\n\tenc, err := NewEncrypter(keyAlg, encAlg, encryptionKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn enc\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\n// rawJsonWebSignature represents a raw JWS JSON object. Used for parsing/serializing.\ntype rawJsonWebSignature struct {\n\tPayload    *byteBuffer        `json:\"payload,omitempty\"`\n\tSignatures []rawSignatureInfo `json:\"signatures,omitempty\"`\n\tProtected  *byteBuffer        `json:\"protected,omitempty\"`\n\tHeader     *rawHeader         `json:\"header,omitempty\"`\n\tSignature  *byteBuffer        `json:\"signature,omitempty\"`\n}\n\n// rawSignatureInfo represents a single JWS signature over the JWS payload and protected header.\ntype rawSignatureInfo struct {\n\tProtected *byteBuffer `json:\"protected,omitempty\"`\n\tHeader    *rawHeader  `json:\"header,omitempty\"`\n\tSignature *byteBuffer `json:\"signature,omitempty\"`\n}\n\n// JsonWebSignature represents a signed JWS object after parsing.\ntype JsonWebSignature struct {\n\tpayload []byte\n\t// Signatures attached to this object (may be more than one for multi-sig).\n\t// Be careful about accessing these directly, prefer to use Verify() or\n\t// VerifyMulti() to ensure that the data you're getting is verified.\n\tSignatures []Signature\n}\n\n// Signature represents a single signature over the JWS payload and protected header.\ntype Signature struct {\n\t// Header fields, such as the signature algorithm\n\tHeader JoseHeader\n\n\t// The actual signature value\n\tSignature []byte\n\n\tprotected *rawHeader\n\theader    *rawHeader\n\toriginal  *rawSignatureInfo\n}\n\n// ParseSigned parses a signed message in compact or full serialization format.\nfunc ParseSigned(input string) (*JsonWebSignature, error) {\n\tinput = stripWhitespace(input)\n\tif strings.HasPrefix(input, \"{\") {\n\t\treturn parseSignedFull(input)\n\t}\n\n\treturn parseSignedCompact(input)\n}\n\n// Get a header value\nfunc (sig Signature) mergedHeaders() rawHeader {\n\tout := rawHeader{}\n\tout.merge(sig.protected)\n\tout.merge(sig.header)\n\treturn out\n}\n\n// Compute data to be signed\nfunc (obj JsonWebSignature) computeAuthData(signature *Signature) []byte {\n\tvar serializedProtected string\n\n\tif signature.original != nil && signature.original.Protected != nil {\n\t\tserializedProtected = signature.original.Protected.base64()\n\t} else if signature.protected != nil {\n\t\tserializedProtected = base64URLEncode(mustSerializeJSON(signature.protected))\n\t} else {\n\t\tserializedProtected = \"\"\n\t}\n\n\treturn []byte(fmt.Sprintf(\"%s.%s\",\n\t\tserializedProtected,\n\t\tbase64URLEncode(obj.payload)))\n}\n\n// parseSignedFull parses a message in full format.\nfunc parseSignedFull(input string) (*JsonWebSignature, error) {\n\tvar parsed rawJsonWebSignature\n\terr := json.Unmarshal([]byte(input), &parsed)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn parsed.sanitized()\n}\n\n// sanitized produces a cleaned-up JWS object from the raw JSON.\nfunc (parsed *rawJsonWebSignature) sanitized() (*JsonWebSignature, error) {\n\tif parsed.Payload == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: missing payload in JWS message\")\n\t}\n\n\tobj := &JsonWebSignature{\n\t\tpayload:    parsed.Payload.bytes(),\n\t\tSignatures: make([]Signature, len(parsed.Signatures)),\n\t}\n\n\tif len(parsed.Signatures) == 0 {\n\t\t// No signatures array, must be flattened serialization\n\t\tsignature := Signature{}\n\t\tif parsed.Protected != nil && len(parsed.Protected.bytes()) > 0 {\n\t\t\tsignature.protected = &rawHeader{}\n\t\t\terr := json.Unmarshal(parsed.Protected.bytes(), signature.protected)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif parsed.Header != nil && parsed.Header.Nonce != \"\" {\n\t\t\treturn nil, ErrUnprotectedNonce\n\t\t}\n\n\t\tsignature.header = parsed.Header\n\t\tsignature.Signature = parsed.Signature.bytes()\n\t\t// Make a fake \"original\" rawSignatureInfo to store the unprocessed\n\t\t// Protected header. This is necessary because the Protected header can\n\t\t// contain arbitrary fields not registered as part of the spec. See\n\t\t// https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-4\n\t\t// If we unmarshal Protected into a rawHeader with its explicit list of fields,\n\t\t// we cannot marshal losslessly. So we have to keep around the original bytes.\n\t\t// This is used in computeAuthData, which will first attempt to use\n\t\t// the original bytes of a protected header, and fall back on marshaling the\n\t\t// header struct only if those bytes are not available.\n\t\tsignature.original = &rawSignatureInfo{\n\t\t\tProtected: parsed.Protected,\n\t\t\tHeader:    parsed.Header,\n\t\t\tSignature: parsed.Signature,\n\t\t}\n\n\t\tsignature.Header = signature.mergedHeaders().sanitized()\n\t\tobj.Signatures = append(obj.Signatures, signature)\n\t}\n\n\tfor i, sig := range parsed.Signatures {\n\t\tif sig.Protected != nil && len(sig.Protected.bytes()) > 0 {\n\t\t\tobj.Signatures[i].protected = &rawHeader{}\n\t\t\terr := json.Unmarshal(sig.Protected.bytes(), obj.Signatures[i].protected)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// Check that there is not a nonce in the unprotected header\n\t\tif sig.Header != nil && sig.Header.Nonce != \"\" {\n\t\t\treturn nil, ErrUnprotectedNonce\n\t\t}\n\n\t\tobj.Signatures[i].Signature = sig.Signature.bytes()\n\n\t\t// Copy value of sig\n\t\toriginal := sig\n\n\t\tobj.Signatures[i].header = sig.Header\n\t\tobj.Signatures[i].original = &original\n\t\tobj.Signatures[i].Header = obj.Signatures[i].mergedHeaders().sanitized()\n\t}\n\n\treturn obj, nil\n}\n\n// parseSignedCompact parses a message in compact format.\nfunc parseSignedCompact(input string) (*JsonWebSignature, error) {\n\tparts := strings.Split(input, \".\")\n\tif len(parts) != 3 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: compact JWS format must have three parts\")\n\t}\n\n\trawProtected, err := base64URLDecode(parts[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := base64URLDecode(parts[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsignature, err := base64URLDecode(parts[2])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\traw := &rawJsonWebSignature{\n\t\tPayload:   newBuffer(payload),\n\t\tProtected: newBuffer(rawProtected),\n\t\tSignature: newBuffer(signature),\n\t}\n\treturn raw.sanitized()\n}\n\n// CompactSerialize serializes an object using the compact serialization format.\nfunc (obj JsonWebSignature) CompactSerialize() (string, error) {\n\tif len(obj.Signatures) != 1 || obj.Signatures[0].header != nil || obj.Signatures[0].protected == nil {\n\t\treturn \"\", ErrNotSupported\n\t}\n\n\tserializedProtected := mustSerializeJSON(obj.Signatures[0].protected)\n\n\treturn fmt.Sprintf(\n\t\t\"%s.%s.%s\",\n\t\tbase64URLEncode(serializedProtected),\n\t\tbase64URLEncode(obj.payload),\n\t\tbase64URLEncode(obj.Signatures[0].Signature)), nil\n}\n\n// FullSerialize serializes an object using the full JSON serialization format.\nfunc (obj JsonWebSignature) FullSerialize() string {\n\traw := rawJsonWebSignature{\n\t\tPayload: newBuffer(obj.payload),\n\t}\n\n\tif len(obj.Signatures) == 1 {\n\t\tif obj.Signatures[0].protected != nil {\n\t\t\tserializedProtected := mustSerializeJSON(obj.Signatures[0].protected)\n\t\t\traw.Protected = newBuffer(serializedProtected)\n\t\t}\n\t\traw.Header = obj.Signatures[0].header\n\t\traw.Signature = newBuffer(obj.Signatures[0].Signature)\n\t} else {\n\t\traw.Signatures = make([]rawSignatureInfo, len(obj.Signatures))\n\t\tfor i, signature := range obj.Signatures {\n\t\t\traw.Signatures[i] = rawSignatureInfo{\n\t\t\t\tHeader:    signature.header,\n\t\t\t\tSignature: newBuffer(signature.Signature),\n\t\t\t}\n\n\t\t\tif signature.protected != nil {\n\t\t\t\traw.Signatures[i].Protected = newBuffer(mustSerializeJSON(signature.protected))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn string(mustSerializeJSON(raw))\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// NonceSource represents a source of random nonces to go into JWS objects\ntype NonceSource interface {\n\tNonce() (string, error)\n}\n\n// Signer represents a signer which takes a payload and produces a signed JWS object.\ntype Signer interface {\n\tSign(payload []byte) (*JsonWebSignature, error)\n\tSetNonceSource(source NonceSource)\n\tSetEmbedJwk(embed bool)\n}\n\n// MultiSigner represents a signer which supports multiple recipients.\ntype MultiSigner interface {\n\tSign(payload []byte) (*JsonWebSignature, error)\n\tSetNonceSource(source NonceSource)\n\tSetEmbedJwk(embed bool)\n\tAddRecipient(alg SignatureAlgorithm, signingKey interface{}) error\n}\n\ntype payloadSigner interface {\n\tsignPayload(payload []byte, alg SignatureAlgorithm) (Signature, error)\n}\n\ntype payloadVerifier interface {\n\tverifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error\n}\n\ntype genericSigner struct {\n\trecipients  []recipientSigInfo\n\tnonceSource NonceSource\n\tembedJwk    bool\n}\n\ntype recipientSigInfo struct {\n\tsigAlg    SignatureAlgorithm\n\tkeyID     string\n\tpublicKey *JsonWebKey\n\tsigner    payloadSigner\n}\n\n// NewSigner creates an appropriate signer based on the key type\nfunc NewSigner(alg SignatureAlgorithm, signingKey interface{}) (Signer, error) {\n\t// NewMultiSigner never fails (currently)\n\tsigner := NewMultiSigner()\n\n\terr := signer.AddRecipient(alg, signingKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signer, nil\n}\n\n// NewMultiSigner creates a signer for multiple recipients\nfunc NewMultiSigner() MultiSigner {\n\treturn &genericSigner{\n\t\trecipients: []recipientSigInfo{},\n\t\tembedJwk:   true,\n\t}\n}\n\n// newVerifier creates a verifier based on the key type\nfunc newVerifier(verificationKey interface{}) (payloadVerifier, error) {\n\tswitch verificationKey := verificationKey.(type) {\n\tcase *rsa.PublicKey:\n\t\treturn &rsaEncrypterVerifier{\n\t\t\tpublicKey: verificationKey,\n\t\t}, nil\n\tcase *ecdsa.PublicKey:\n\t\treturn &ecEncrypterVerifier{\n\t\t\tpublicKey: verificationKey,\n\t\t}, nil\n\tcase []byte:\n\t\treturn &symmetricMac{\n\t\t\tkey: verificationKey,\n\t\t}, nil\n\tcase *JsonWebKey:\n\t\treturn newVerifier(verificationKey.Key)\n\tdefault:\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n}\n\nfunc (ctx *genericSigner) AddRecipient(alg SignatureAlgorithm, signingKey interface{}) error {\n\trecipient, err := makeJWSRecipient(alg, signingKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx.recipients = append(ctx.recipients, recipient)\n\treturn nil\n}\n\nfunc makeJWSRecipient(alg SignatureAlgorithm, signingKey interface{}) (recipientSigInfo, error) {\n\tswitch signingKey := signingKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn newRSASigner(alg, signingKey)\n\tcase *ecdsa.PrivateKey:\n\t\treturn newECDSASigner(alg, signingKey)\n\tcase []byte:\n\t\treturn newSymmetricSigner(alg, signingKey)\n\tcase *JsonWebKey:\n\t\trecipient, err := makeJWSRecipient(alg, signingKey.Key)\n\t\tif err != nil {\n\t\t\treturn recipientSigInfo{}, err\n\t\t}\n\t\trecipient.keyID = signingKey.KeyID\n\t\treturn recipient, nil\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedKeyType\n\t}\n}\n\nfunc (ctx *genericSigner) Sign(payload []byte) (*JsonWebSignature, error) {\n\tobj := &JsonWebSignature{}\n\tobj.payload = payload\n\tobj.Signatures = make([]Signature, len(ctx.recipients))\n\n\tfor i, recipient := range ctx.recipients {\n\t\tprotected := &rawHeader{\n\t\t\tAlg: string(recipient.sigAlg),\n\t\t}\n\n\t\tif recipient.publicKey != nil && ctx.embedJwk {\n\t\t\tprotected.Jwk = recipient.publicKey\n\t\t}\n\t\tif recipient.keyID != \"\" {\n\t\t\tprotected.Kid = recipient.keyID\n\t\t}\n\n\t\tif ctx.nonceSource != nil {\n\t\t\tnonce, err := ctx.nonceSource.Nonce()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"square/go-jose: Error generating nonce: %v\", err)\n\t\t\t}\n\t\t\tprotected.Nonce = nonce\n\t\t}\n\n\t\tserializedProtected := mustSerializeJSON(protected)\n\n\t\tinput := []byte(fmt.Sprintf(\"%s.%s\",\n\t\t\tbase64URLEncode(serializedProtected),\n\t\t\tbase64URLEncode(payload)))\n\n\t\tsignatureInfo, err := recipient.signer.signPayload(input, recipient.sigAlg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsignatureInfo.protected = protected\n\t\tobj.Signatures[i] = signatureInfo\n\t}\n\n\treturn obj, nil\n}\n\n// SetNonceSource provides or updates a nonce pool to the first recipients.\n// After this method is called, the signer will consume one nonce per\n// signature, returning an error it is unable to get a nonce.\nfunc (ctx *genericSigner) SetNonceSource(source NonceSource) {\n\tctx.nonceSource = source\n}\n\n// SetEmbedJwk specifies if the signing key should be embedded in the protected header,\n// if any. It defaults to 'true'.\nfunc (ctx *genericSigner) SetEmbedJwk(embed bool) {\n\tctx.embedJwk = embed\n}\n\n// Verify validates the signature on the object and returns the payload.\n// Note that this function does not support multi-signature, if you desire\n// multi-sig verification use VerifyMulti instead.\nfunc (obj JsonWebSignature) Verify(verificationKey interface{}) ([]byte, error) {\n\tverifier, err := newVerifier(verificationKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(obj.Signatures) > 1 {\n\t\treturn nil, errors.New(\"square/go-jose: too many signatures in payload; expecting only one\")\n\t}\n\n\tsignature := obj.Signatures[0]\n\theaders := signature.mergedHeaders()\n\tif len(headers.Crit) > 0 {\n\t\t// Unsupported crit header\n\t\treturn nil, ErrCryptoFailure\n\t}\n\n\tinput := obj.computeAuthData(&signature)\n\talg := SignatureAlgorithm(headers.Alg)\n\terr = verifier.verifyPayload(input, signature.Signature, alg)\n\tif err == nil {\n\t\treturn obj.payload, nil\n\t}\n\n\treturn nil, ErrCryptoFailure\n}\n\n// VerifyMulti validates (one of the multiple) signatures on the object and\n// returns the index of the signature that was verified, along with the signature\n// object and the payload. We return the signature and index to guarantee that\n// callers are getting the verified value.\nfunc (obj JsonWebSignature) VerifyMulti(verificationKey interface{}) (int, Signature, []byte, error) {\n\tverifier, err := newVerifier(verificationKey)\n\tif err != nil {\n\t\treturn -1, Signature{}, nil, err\n\t}\n\n\tfor i, signature := range obj.Signatures {\n\t\theaders := signature.mergedHeaders()\n\t\tif len(headers.Crit) > 0 {\n\t\t\t// Unsupported crit header\n\t\t\tcontinue\n\t\t}\n\n\t\tinput := obj.computeAuthData(&signature)\n\t\talg := SignatureAlgorithm(headers.Alg)\n\t\terr := verifier.verifyPayload(input, signature.Signature, alg)\n\t\tif err == nil {\n\t\t\treturn i, signature, obj.payload, nil\n\t\t}\n\t}\n\n\treturn -1, Signature{}, nil, ErrCryptoFailure\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\ntype staticNonceSource string\n\nfunc (sns staticNonceSource) Nonce() (string, error) {\n\treturn string(sns), nil\n}\n\nfunc RoundtripJWS(sigAlg SignatureAlgorithm, serializer func(*JsonWebSignature) (string, error), corrupter func(*JsonWebSignature), signingKey interface{}, verificationKey interface{}, nonce string) error {\n\tsigner, err := NewSigner(sigAlg, signingKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on new signer: %s\", err)\n\t}\n\n\tif nonce != \"\" {\n\t\tsigner.SetNonceSource(staticNonceSource(nonce))\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on sign: %s\", err)\n\t}\n\n\tmsg, err := serializer(obj)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on serialize: %s\", err)\n\t}\n\n\tobj, err = ParseSigned(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on parse: %s\", err)\n\t}\n\n\t// (Maybe) mangle the object\n\tcorrupter(obj)\n\n\toutput, err := obj.Verify(verificationKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on verify: %s\", err)\n\t}\n\n\t// Check that verify works with embedded keys (if present)\n\tfor i, sig := range obj.Signatures {\n\t\tif sig.Header.JsonWebKey != nil {\n\t\t\t_, err = obj.Verify(sig.Header.JsonWebKey)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error on verify with embedded key %d: %s\", i, err)\n\t\t\t}\n\t\t}\n\n\t\t// Check that the nonce correctly round-tripped (if present)\n\t\tif sig.Header.Nonce != nonce {\n\t\t\treturn fmt.Errorf(\"Incorrect nonce returned: [%s]\", sig.Header.Nonce)\n\t\t}\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\treturn fmt.Errorf(\"input/output do not match, got '%s', expected '%s'\", output, input)\n\t}\n\n\treturn nil\n}\n\nfunc TestRoundtripsJWS(t *testing.T) {\n\t// Test matrix\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512, HS256, HS384, HS512, ES256, ES384, ES512}\n\n\tserializers := []func(*JsonWebSignature) (string, error){\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupter := func(obj *JsonWebSignature) {}\n\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\n\t\tfor i, serializer := range serializers {\n\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err, alg, i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRoundtripsJWSCorruptSignature(t *testing.T) {\n\t// Test matrix\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512, HS256, HS384, HS512, ES256, ES384, ES512}\n\n\tserializers := []func(*JsonWebSignature) (string, error){\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() },\n\t\tfunc(obj *JsonWebSignature) (string, error) { return obj.FullSerialize(), nil },\n\t}\n\n\tcorrupters := []func(*JsonWebSignature){\n\t\tfunc(obj *JsonWebSignature) {\n\t\t\t// Changes bytes in signature\n\t\t\tobj.Signatures[0].Signature[10]++\n\t\t},\n\t\tfunc(obj *JsonWebSignature) {\n\t\t\t// Set totally invalid signature\n\t\t\tobj.Signatures[0].Signature = []byte(\"###\")\n\t\t},\n\t}\n\n\t// Test all different configurations\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\n\t\tfor i, serializer := range serializers {\n\t\t\tfor j, corrupter := range corrupters {\n\t\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(\"failed to detect corrupt signature\", err, alg, i, j)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSignerWithBrokenRand(t *testing.T) {\n\tsigAlgs := []SignatureAlgorithm{RS256, RS384, RS512, PS256, PS384, PS512}\n\n\tserializer := func(obj *JsonWebSignature) (string, error) { return obj.CompactSerialize() }\n\tcorrupter := func(obj *JsonWebSignature) {}\n\n\t// Break rand reader\n\treaders := []func() io.Reader{\n\t\t// Totally broken\n\t\tfunc() io.Reader { return bytes.NewReader([]byte{}) },\n\t\t// Not enough bytes\n\t\tfunc() io.Reader { return io.LimitReader(rand.Reader, 20) },\n\t}\n\n\tdefer resetRandReader()\n\n\tfor _, alg := range sigAlgs {\n\t\tsigningKey, verificationKey := GenerateSigningTestKey(alg)\n\t\tfor i, getReader := range readers {\n\t\t\trandReader = getReader()\n\t\t\terr := RoundtripJWS(alg, serializer, corrupter, signingKey, verificationKey, \"test_nonce\")\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"signer should fail if rand is broken\", alg, i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestJWSInvalidKey(t *testing.T) {\n\tsigningKey0, verificationKey0 := GenerateSigningTestKey(RS256)\n\t_, verificationKey1 := GenerateSigningTestKey(ES256)\n\n\tsigner, err := NewSigner(RS256, signingKey0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Must work with correct key\n\t_, err = obj.Verify(verificationKey0)\n\tif err != nil {\n\t\tt.Error(\"error on verify\", err)\n\t}\n\n\t// Must not work with incorrect key\n\t_, err = obj.Verify(verificationKey1)\n\tif err == nil {\n\t\tt.Error(\"verification should fail with incorrect key\")\n\t}\n\n\t// Must not work with invalid key\n\t_, err = obj.Verify(\"\")\n\tif err == nil {\n\t\tt.Error(\"verification should fail with incorrect key\")\n\t}\n}\n\nfunc TestMultiRecipientJWS(t *testing.T) {\n\tsigner := NewMultiSigner()\n\n\tsharedKey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\tsigner.AddRecipient(RS256, rsaTestKey)\n\tsigner.AddRecipient(HS384, sharedKey)\n\n\tinput := []byte(\"Lorem ipsum dolor sit amet\")\n\tobj, err := signer.Sign(input)\n\tif err != nil {\n\t\tt.Fatal(\"error on sign: \", err)\n\t}\n\n\t_, err = obj.CompactSerialize()\n\tif err == nil {\n\t\tt.Fatal(\"message with multiple recipient was compact serialized\")\n\t}\n\n\tmsg := obj.FullSerialize()\n\n\tobj, err = ParseSigned(msg)\n\tif err != nil {\n\t\tt.Fatal(\"error on parse: \", err)\n\t}\n\n\ti, _, output, err := obj.VerifyMulti(&rsaTestKey.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(\"error on verify: \", err)\n\t}\n\n\tif i != 0 {\n\t\tt.Fatal(\"signature index should be 0 for RSA key\")\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\tt.Fatal(\"input/output do not match\", output, input)\n\t}\n\n\ti, _, output, err = obj.VerifyMulti(sharedKey)\n\tif err != nil {\n\t\tt.Fatal(\"error on verify: \", err)\n\t}\n\n\tif i != 1 {\n\t\tt.Fatal(\"signature index should be 1 for EC key\")\n\t}\n\n\tif bytes.Compare(output, input) != 0 {\n\t\tt.Fatal(\"input/output do not match\", output, input)\n\t}\n}\n\nfunc GenerateSigningTestKey(sigAlg SignatureAlgorithm) (sig, ver interface{}) {\n\tswitch sigAlg {\n\tcase RS256, RS384, RS512, PS256, PS384, PS512:\n\t\tsig = rsaTestKey\n\t\tver = &rsaTestKey.PublicKey\n\tcase HS256, HS384, HS512:\n\t\tsig, _, _ = randomKeyGenerator{size: 16}.genKey()\n\t\tver = sig\n\tcase ES256:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tcase ES384:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tcase ES512:\n\t\tkey, _ := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\t\tsig = key\n\t\tver = &key.PublicKey\n\tdefault:\n\t\tpanic(\"Must update test case\")\n\t}\n\n\treturn\n}\n\nfunc TestInvalidSignerAlg(t *testing.T) {\n\t_, err := NewSigner(\"XYZ\", nil)\n\tif err == nil {\n\t\tt.Error(\"should not accept invalid algorithm\")\n\t}\n\n\t_, err = NewSigner(\"XYZ\", []byte{})\n\tif err == nil {\n\t\tt.Error(\"should not accept invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidJWS(t *testing.T) {\n\tsigner, err := NewSigner(PS256, rsaTestKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tobj, err := signer.Sign([]byte(\"Lorem ipsum dolor sit amet\"))\n\tobj.Signatures[0].header = &rawHeader{\n\t\tCrit: []string{\"TEST\"},\n\t}\n\n\t_, err = obj.Verify(&rsaTestKey.PublicKey)\n\tif err == nil {\n\t\tt.Error(\"should not verify message with unknown crit header\")\n\t}\n\n\t// Try without alg header\n\tobj.Signatures[0].protected = &rawHeader{}\n\tobj.Signatures[0].header = &rawHeader{}\n\n\t_, err = obj.Verify(&rsaTestKey.PublicKey)\n\tif err == nil {\n\t\tt.Error(\"should not verify message with missing headers\")\n\t}\n}\n\nfunc TestSignerKid(t *testing.T) {\n\tkid := \"DEADBEEF\"\n\tpayload := []byte(\"Lorem ipsum dolor sit amet\")\n\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Error(\"problem generating test signing key\", err)\n\t}\n\n\tbasejwk := JsonWebKey{Key: key}\n\tjsonbar, err := basejwk.MarshalJSON()\n\tif err != nil {\n\t\tt.Error(\"problem marshalling base JWK\", err)\n\t}\n\n\tvar jsonmsi map[string]interface{}\n\terr = json.Unmarshal(jsonbar, &jsonmsi)\n\tif err != nil {\n\t\tt.Error(\"problem unmarshalling base JWK\", err)\n\t}\n\tjsonmsi[\"kid\"] = kid\n\tjsonbar2, err := json.Marshal(jsonmsi)\n\tif err != nil {\n\t\tt.Error(\"problem marshalling kided JWK\", err)\n\t}\n\n\tvar jwk JsonWebKey\n\terr = jwk.UnmarshalJSON(jsonbar2)\n\tif err != nil {\n\t\tt.Error(\"problem unmarshalling kided JWK\", err)\n\t}\n\n\tsigner, err := NewSigner(ES256, &jwk)\n\tif err != nil {\n\t\tt.Error(\"problem creating signer\", err)\n\t}\n\tsigned, err := signer.Sign(payload)\n\n\tserialized := signed.FullSerialize()\n\n\tparsed, err := ParseSigned(serialized)\n\tif err != nil {\n\t\tt.Error(\"problem parsing signed object\", err)\n\t}\n\n\tif parsed.Signatures[0].Header.KeyID != kid {\n\t\tt.Error(\"KeyID did not survive trip\")\n\t}\n}\n\nfunc TestEmbedJwk(t *testing.T) {\n\tvar payload = []byte(\"Lorem ipsum dolor sit amet\")\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Error(\"Failed to generate key\")\n\t}\n\n\tsigner, err := NewSigner(ES256, key)\n\tif err != nil {\n\t\tt.Error(\"Failed to create signer\")\n\t}\n\n\tobject, err := signer.Sign(payload)\n\tif err != nil {\n\t\tt.Error(\"Failed to sign payload\")\n\t}\n\n\tobject, err = ParseSigned(object.FullSerialize())\n\tif err != nil {\n\t\tt.Error(\"Failed to parse jws\")\n\t}\n\n\tif object.Signatures[0].protected.Jwk == nil {\n\t\tt.Error(\"JWK isn't set in protected header\")\n\t}\n\n\t// Now sign it again, but don't embed JWK.\n\tsigner.SetEmbedJwk(false)\n\n\tobject, err = signer.Sign(payload)\n\tif err != nil {\n\t\tt.Error(\"Failed to sign payload\")\n\t}\n\n\tobject, err = ParseSigned(object.FullSerialize())\n\tif err != nil {\n\t\tt.Error(\"Failed to parse jws\")\n\t}\n\n\tif object.Signatures[0].protected.Jwk != nil {\n\t\tt.Error(\"JWK is set in protected header\")\n\t}\n}\n\nfunc TestSignerWithJWKAndKeyID(t *testing.T) {\n\tenc, err := NewSigner(HS256, &JsonWebKey{\n\t\tKeyID: \"test-id\",\n\t\tKey:   []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tsigned, _ := enc.Sign([]byte(\"Lorem ipsum dolor sit amet\"))\n\n\tserialized1, _ := signed.CompactSerialize()\n\tserialized2 := signed.FullSerialize()\n\n\tparsed1, _ := ParseSigned(serialized1)\n\tparsed2, _ := ParseSigned(serialized2)\n\n\tif parsed1.Signatures[0].Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed1.Signatures[0].Header.KeyID)\n\t}\n\tif parsed2.Signatures[0].Header.KeyID != \"test-id\" {\n\t\tt.Errorf(\"expected message to have key id from JWK, but found '%s' instead\", parsed2.Signatures[0].Header.KeyID)\n\t}\n}\n"], "filenames": ["crypter.go", "crypter_test.go", "jws.go", "signing.go", "signing_test.go"], "buggy_code_start_loc": [21, 275, 44, 21, 227], "buggy_code_end_loc": [350, 324, 45, 219, 264], "fixing_code_start_loc": [22, 275, 44, 22, 227], "fixing_code_end_loc": [417, 325, 48, 253, 266], "type": "CWE-284", "message": "go-jose before 1.0.4 suffers from multiple signatures exploitation. The go-jose library supports messages with multiple signatures. However, when validating a signed message the API did not indicate which signature was valid, which could potentially lead to confusion. For example, users of the library might mistakenly read protected header values from an attached signature that was different from the one originally validated.", "other": {"cve": {"id": "CVE-2016-9122", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:00.260", "lastModified": "2017-03-29T17:49:32.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-jose before 1.0.4 suffers from multiple signatures exploitation. The go-jose library supports messages with multiple signatures. However, when validating a signed message the API did not indicate which signature was valid, which could potentially lead to confusion. For example, users of the library might mistakenly read protected header values from an attached signature that was different from the one originally validated."}, {"lang": "es", "value": "go-jose en versiones anteriores a 1.0.4 sufre de la explotaci\u00f3n de m\u00faltiples firmas. La librer\u00eda go-jose soporta mensajes con varias firmas. Sin embargo, al validar un mensaje firmado el API no indic\u00f3 qu\u00e9 firma era v\u00e1lida, lo que podr\u00eda conducir a confusi\u00f3n. Por ejemplo, los usuarios de la biblioteca pueden leer de forma err\u00f3nea valores de cabecera protegidos de una firma adjunta que era diferente de la validada originalmente."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-jose_project:go-jose:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.3", "matchCriteriaId": "461700A0-1ABE-4A30-9C79-80C835D8B62E"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/03/1", "source": "support@hackerone.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/square/go-jose/commit/2c5656adca9909843c4ff50acf1d2cf8f32da7e6", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/169629", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/square/go-jose/commit/2c5656adca9909843c4ff50acf1d2cf8f32da7e6"}}