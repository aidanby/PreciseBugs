{"buggy_code": ["/* This code is ripped from Autotrace-0.29. Small modifications by pts. */\n\n/* input-tga.ci reads tga files */\n\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma implementation\n#endif\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* #include <unistd.h> */\n\n#include \"at_bitmap.h\"\n/* #include \"message.h\" */\n/* #include \"xstd.h\" */\n/* #include \"input-tga.h\" */ /* BUGFIX by pts: bmp -> tga */\n\n/* TODO:\n   - Handle loading images that aren't 8 bits per channel.\n*/\n\n/* Round up a division to the nearest integer. */\n#define ROUNDUP_DIVIDE(n,d) (((n) + (d - 1)) / (d))\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\n#define INDEXED 1\n#define INDEXEDA 2\n#define GRAY 3\n#define TGA_RGB 5\n#define INDEXED_IMAGE 1\n#define INDEXEDA_IMAGE 2\n#define GRAY_IMAGE 3\n#define GRAYA_IMAGE 4\n#define TGA_RGB_IMAGE 5\n#define TGA_RGBA_IMAGE 6\n\ntypedef struct _TgaSaveVals\n{\n  int rle;\n} TgaSaveVals;\n\ntypedef struct _TgaSaveInterface\n{\n  int run;\n} TgaSaveInterface;\n\nstruct tga_header\n{\n  unsigned char idLength;\n  unsigned char colorMapType;\n\n  /* The image type. */\n#define TGA_TYPE_MAPPED      1\n#define TGA_TYPE_COLOR       2\n#define TGA_TYPE_GRAY        3\n#define TGA_TYPE_MAPPED_RLE  9\n#define TGA_TYPE_COLOR_RLE  10\n#define TGA_TYPE_GRAY_RLE   11\n  unsigned char imageType;\n\n  /* Color Map Specification. */\n  /* We need to separately specify high and low bytes to avoid endianness\n     and alignment problems. */\n  unsigned char colorMapIndexLo, colorMapIndexHi;\n  unsigned char colorMapLengthLo, colorMapLengthHi;\n  unsigned char colorMapSize;\n\n  /* Image Specification. */\n  unsigned char xOriginLo, xOriginHi;\n  unsigned char yOriginLo, yOriginHi;\n\n  unsigned char widthLo, widthHi;\n  unsigned char heightLo, heightHi;\n\n  unsigned char bpp;\n\n  /* Image descriptor.\n     3-0: attribute bpp\n     4:   left-to-right ordering\n     5:   top-to-bottom ordering\n     7-6: zero\n     */\n#define TGA_DESC_ABITS      0x0f\n#define TGA_DESC_HORIZONTAL 0x10\n#define TGA_DESC_VERTICAL   0x20\n  unsigned char descriptor;\n};\n\n#if 0\nstatic struct\n{\n  unsigned int extensionAreaOffset;\n  unsigned int developerDirectoryOffset;\n#define TGA_SIGNATURE \"TRUEVISION-XFILE\"\n  char signature[16];\n  char dot;\n  char null;\n} tga_footer;\n#endif\n\n\nstatic bitmap_type ReadImage (FILE *fp,\n                         struct tga_header *hdr);\n#if PTS_SAM2P /**** pts ****/\nbitmap_type tga_load_image (FILE* filename)\n#else\nbitmap_type tga_load_image (at_string filename)\n#endif\n{\n  FILE *fp;\n  struct tga_header hdr;\n\n  bitmap_type image;\n\n  image.bitmap = NULL;\n\n  #if PTS_SAM2P /**** pts ****/\n    fp=filename;\n  #else\n    fp = fopen (filename, \"rb\");\n    if (!fp)\n        FATAL1 (\"TGA: can't open \\\"%s\\\"\\n\", filename);\n  #endif\n\n  memset(&hdr, '\\0', sizeof(hdr));\n\n#if 0\n  /* Check the footer. */\n  if (fseek (fp, 0L - (sizeof (tga_footer)), SEEK_END)\n      || fread (&tga_footer, sizeof (tga_footer), 1, fp) != 1)\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot read footer\");\n#else\n      FATAL1 (\"TGA: Cannot read footer from \\\"%s\\\"\\n\", filename);\n#endif\n  /* Check the signature. */\n  if (fseek (fp, 0, SEEK_SET) ||\n#else\n  if (0 ||\n#endif\n      fread (&hdr, sizeof (hdr), 1, fp) != 1)\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot read header\");\n#else\n      FATAL1 (\"TGA: Cannot read header from \\\"%s\\\"\\n\", filename);\n#endif\n\n  /* Skip the image ID field. */\n  {\n#if 0\n    if (hdr.idLength && fseek (fp, hdr.idLength, SEEK_CUR))\n#else\n    char buf[256];\n    if (hdr.idLength!=fread(buf, 1, hdr.idLength, fp))\n#endif\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot skip ID field\");\n#else\n      FATAL1 (\"TGA: Cannot skip ID field in \\\"%s\\\"\\n\", filename);\n#endif\n  }\n\n  image = ReadImage (fp, &hdr);\n  /* fclose (fp); */\n  return image;\n}\n\n\nstatic int\nstd_fread (unsigned char *buf,\n           int     datasize,\n           int     nelems,\n           FILE   *fp)\n{\n\n  return fread (buf, datasize, nelems, fp);\n}\n\n#define RLE_PACKETSIZE 0x80\n\n/* Decode a bufferful of file. */\nstatic int\nrle_fread (unsigned char *buf,\n           int     datasize,\n           int     nelems,\n           FILE   *fp)\n{\n  static unsigned char *statebuf = 0;\n  static int statelen = 0;\n  static int laststate = 0;\n\n  int j, k;\n  int buflen, count, bytes;\n  unsigned char *p;\n\n  /* Scale the buffer length. */\n  buflen = nelems * datasize;\n\n  j = 0;\n  while (j < buflen)\n    {\n      if (laststate < statelen)\n        {\n          /* Copy bytes from our previously decoded buffer. */\n          bytes = MIN (buflen - j, statelen - laststate);\n          memcpy (buf + j, statebuf + laststate, bytes);\n          j += bytes;\n          laststate += bytes;\n\n          /* If we used up all of our state bytes, then reset them. */\n          if (laststate >= statelen)\n            {\n              laststate = 0;\n              statelen = 0;\n            }\n\n          /* If we filled the buffer, then exit the loop. */\n          if (j >= buflen)\n            break;\n        }\n\n      /* Decode the next packet. */\n      count = fgetc (fp);\n      if (count == EOF)\n        {\n\t    return j / datasize;\n        }\n\n      /* Scale the byte length to the size of the data. */\n      bytes = ((count & ~RLE_PACKETSIZE) + 1) * datasize;\n\n      if (j + bytes <= buflen)\n        {\n          /* We can copy directly into the image buffer. */\n          p = buf + j;\n        }\n      else {\n\t  /* Allocate the state buffer if we haven't already. */\n        if (!statebuf)\n          statebuf = (unsigned char *) malloc (RLE_PACKETSIZE * datasize);\n        p = statebuf;\n      }\n\n      if (count & RLE_PACKETSIZE)\n        {\n          /* Fill the buffer with the next value. */\n          if (fread (p, datasize, 1, fp) != 1)\n            {\n\t\t  \t\t\t\treturn j / datasize;\n            }\n\n          /* Optimized case for single-byte encoded data. */\n          if (datasize == 1)\n            memset (p + 1, *p, bytes - 1);\n          else\n            for (k = datasize; k < bytes; k += datasize)\n              memcpy (p + k, p, datasize);\n        }\n      else\n        {\n          /* Read in the buffer. */\n          if (fread (p, bytes, 1, fp) != 1)\n            {\n\t       return j / datasize;\n            }\n        }\n\n      /* We may need to copy bytes from the state buffer. */\n      if (p == statebuf)\n        statelen = bytes;\n      else\n        j += bytes;\n    }\n\nreturn nelems;\n}\n\nstatic bitmap_type\nReadImage (FILE              *fp,\n           struct tga_header *hdr)\n{\n  bitmap_type image;\n  unsigned char *buffer;\n  unsigned char *alphas;\n\n  int width, height, bpp, abpp, pbpp;\n  unsigned nalphas = 0, ncolors = 0;\n  int wh, wh3, whp;\n  int j, k;\n  int pelbytes, wbytes, bsize, npels, pels;\n  int rle;\n  char badread = 0, badalpha = 0, badcolor = 0;\n  int itype=0;\n  unsigned char *cmap = NULL;\n  int (*myfread)(unsigned char *, int, int, FILE *);\n\n  /* Find out whether the image is horizontally or vertically reversed. */\n  char horzrev = (char) (hdr->descriptor & TGA_DESC_HORIZONTAL);\n  char vertrev = (char) (!(hdr->descriptor & TGA_DESC_VERTICAL));\n\n  image.bitmap = NULL;\n\n  /* Reassemble the multi-byte values correctly, regardless of\n     host endianness. */\n  width = (hdr->widthHi << 8) | hdr->widthLo;\n  height = (hdr->heightHi << 8) | hdr->heightLo;\n\n  bpp = hdr->bpp;\n  abpp = hdr->descriptor & TGA_DESC_ABITS;\n\n  if (hdr->imageType == TGA_TYPE_COLOR ||\n      hdr->imageType == TGA_TYPE_COLOR_RLE)\n    pbpp = MIN (bpp / 3, 8) * 3;\n  else if (abpp < bpp)\n    pbpp = bpp - abpp;\n  else\n    pbpp = bpp;\n\n  if (abpp + pbpp > bpp)\n    {\n      WARNINGP3 (\"TGA: \",pbpp,\" bit image, \",abpp,\" bit alpha is greater than \",bpp,\" total bits per pixel\");\n\n      /* Assume that alpha bits were set incorrectly. */\n      abpp = bpp - pbpp;\n      WARNINGP1 (\"TGA: reducing to * bit alpha: \", abpp);\n    }\n  else if (abpp + pbpp < bpp)\n    {\n      WARNINGP3 (\"TGA: \",pbpp,\" bit image, \",abpp,\" bit alpha is less than \",bpp,\" total bits per pixel\");\n\n      /* Again, assume that alpha bits were set incorrectly. */\n      abpp = bpp - pbpp;\n      WARNINGP1 (\"TGA: increasing to * bit alpha: \", abpp);\n    }\n\n  rle = 0;\n  switch (hdr->imageType)\n    {\n    case TGA_TYPE_MAPPED_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_MAPPED:\n      itype = INDEXED;\n\n      /* Find the size of palette elements. */\n      pbpp = MIN (hdr->colorMapSize / 3, 8) * 3;\n      if (pbpp < hdr->colorMapSize)\n        abpp = hdr->colorMapSize - pbpp;\n      else\n        abpp = 0;\n\n\n      if (bpp != 8)\n\t    /* We can only cope with 8-bit indices. */\n          FATALP (\"TGA: index sizes other than 8 bits are unimplemented\");\n      break;\n\n    case TGA_TYPE_GRAY_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_GRAY:\n      itype = GRAY;\n      break;\n\n    case TGA_TYPE_COLOR_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_COLOR:\n      itype = TGA_RGB;\n      break;\n\n    default:\n      FATALP1 (\"TGA: unrecognized image type \", (unsigned)hdr->imageType);\n}\n\n  if ((abpp && abpp != 8) ||\n      ((itype == TGA_RGB || itype == INDEXED) && pbpp != 24) ||\n      (itype == GRAY && pbpp != 8))\n      /* FIXME: We haven't implemented bit-packed fields yet. */\n      FATALP (\"TGA: channel sizes other than 8 bits are unimplemented\");\n\n  /* Check that we have a color map only when we need it. */\n  if (itype == INDEXED)\n    {\n      if (hdr->colorMapType != 1)\n\t    FATALP1 (\"TGA: indexed image has invalid color map type \",\n                  (unsigned)hdr->colorMapType);\n    }\n  else if (hdr->colorMapType != 0)\n      FATALP1 (\"TGA: non-indexed image has invalid color map type \",\n              (unsigned)hdr->colorMapType);\n\n  alphas = 0;\n  if (hdr->colorMapType == 1)\n    {\n      /* We need to read in the colormap. */\n      unsigned index, length, j, k;\n\n      index = (hdr->colorMapIndexHi << 8) | hdr->colorMapIndexLo;\n      length = (hdr->colorMapLengthHi << 8) | hdr->colorMapLengthLo;\n\n\t  if (length == 0)\n        FATALP1 (\"TGA: invalid color map length \", length);\n\n      pelbytes = ROUNDUP_DIVIDE (hdr->colorMapSize, 8);\n      ncolors = length + index;\n      cmap = (unsigned char *) malloc (ncolors * pelbytes);\n\n      /* Zero the entries up to the beginning of the map. */\n      memset (cmap, 0, index * pelbytes);\n\n      /* Read in the rest of the colormap. */\n      if (fread (cmap + (index * pelbytes), pelbytes, length, fp) != length)\n        FATALP1 (\"TGA: error reading colormap; ftell == \", ftell (fp));\n\n      /* If we have an alpha channel, then create a mapping to the alpha\n         values. */\n      if (pelbytes > 3)\n        alphas = (unsigned char *) malloc (ncolors);\n\n      for (j = k = 0; j < ncolors * pelbytes; j += pelbytes)\n        {\n          /* Swap from BGR to TGA_RGB. */\n          unsigned char tmp = cmap[j];\n          cmap[k ++] = cmap[j + 2];\n          cmap[k ++] = cmap[j + 1];\n          cmap[k ++] = tmp;\n\n          /* Take the alpha values out of the colormap. */\n          if (alphas)\n            alphas[nalphas ++] = cmap[j + 3];\n        }\n\n#if 0  /**** pts ****/\n      /* If the last color was transparent, then omit it from the\n         mapping. */\n      if (nalphas && alphas[nalphas - 1] == 0)\n        ncolors --;\n#endif\n\n      /* Now pretend as if we only have 8 bpp. */\n      abpp = 0;\n      pbpp = 8;\n\t  pelbytes = 1;\n    }\n  else\n\t  pelbytes = 3;\n\n  wh = (unsigned)width * height;\n  if (wh / width != height) {\n   idl_error:\n    FATALP(\"TGA: image dimensions too large\");\n  }\n  wh3 = 3U * wh;\n  if (wh3 / 3 != wh) goto idl_error;\n  whp = (unsigned)pelbytes * wh;\n  if (whp / pelbytes != wh) goto idl_error;\n\n  image.bitmap = (unsigned char *) malloc (wh3);\n  BITMAP_WIDTH (image) = (unsigned short) width;\n  BITMAP_HEIGHT (image) = (unsigned short) height;\n  BITMAP_PLANES (image) = (unsigned short) 3;\n\n   /* Calculate TGA bytes per pixel. */\n  bpp = ROUNDUP_DIVIDE (pbpp + abpp, 8);\n\n  /* Maybe we need to reverse the data. */\n  buffer = NULL;\n  if (horzrev || vertrev)\n    buffer = (unsigned char *) malloc (whp);\n  if (rle)\n    myfread = rle_fread;\n  else\n    myfread = std_fread;\n\n  wbytes = width * pelbytes;\n\n  npels = wh;\n  bsize = wbytes * height;\n\n  /* Suck in the data one height at a time. */\n  if (badread)\n    pels = 0;\n  else\n    pels = (*myfread) (image.bitmap, bpp, npels, fp);\n\n  if (pels != npels)\n    {\n      if (!badread)\n        {\n          /* Probably premature end of file. */\n          WARNINGP1 (\"TGA: error reading; ftell == \", ftell (fp));\n          badread = 1;\n        }\n\n\n      /* Fill the rest of this tile with zeros. */\n      memset (image.bitmap + (pels * bpp), 0, ((npels - pels) * bpp));\n    }\n  /* If we have indexed alphas, then set them. */\n  if (nalphas)\n    {\n      /* Start at the end of the buffer, and work backwards. */\n      k = (npels - 1) * bpp;\n      for (j = bsize - pelbytes; j >= 0; j -= pelbytes)\n        {\n          /* Find the alpha for this index. */\n          const unsigned char tmp = image.bitmap[k--];\n          if (tmp >= nalphas) {\n            if (!badalpha) {\n              WARNINGP (\"TGA: alpha index too large\");\n              badalpha = 1;\n            }\n            image.bitmap[j + 1] = 0;\n          } else {\n            image.bitmap[j + 1] = alphas[tmp];\n          }\n          image.bitmap[j] = tmp;\n        }\n    }\n\n   if (itype == GRAY)\n      for (j = bsize/3 - 1; j >= 0; j -= 1)\n        {\n          /* Find the alpha for this index. */\n          image.bitmap[3*j] = image.bitmap[j];\n          image.bitmap[3*j+1] = image.bitmap[j];\n          image.bitmap[3*j+2] = image.bitmap[j];\n        }\n\n\n  if (pelbytes >= 3)\n    {\n      /* Rearrange the colors from BGR to TGA_RGB. */\n      for (j = 0; j < bsize; j += pelbytes)\n        {\n          const unsigned char tmp = image.bitmap[j];\n          image.bitmap[j] = image.bitmap[j + 2];\n          image.bitmap[j + 2] = tmp;\n        }\n    }\n\n\n\n  if (horzrev || vertrev)\n    {\n      unsigned char *tmp;\n      if (vertrev)\n        {\n          /* We need to mirror only vertically. */\n          for (j = 0; j < bsize; j += wbytes)\n            memcpy (buffer + j,\n              image.bitmap + bsize - (j + wbytes), wbytes);\n        }\n      else if (horzrev)\n        {\n          /* We need to mirror only horizontally. */\n          for (j = 0; j < bsize; j += wbytes)\n            for (k = 0; k < wbytes; k += pelbytes)\n              memcpy (buffer + k + j,\n                image.bitmap + (j + wbytes) - (k + pelbytes), pelbytes);\n        }\n      else\n        {\n          /* Completely reverse the pixels in the buffer. */\n          for (j = 0; j < bsize; j += pelbytes)\n            memcpy (buffer + j,\n              image.bitmap + bsize - (j + pelbytes), pelbytes);\n        }\n\n       /* Swap the buffers because we modified them. */\n      tmp = buffer;\n      buffer = image.bitmap;\n      image.bitmap = tmp;\n    }\n\n  if (fgetc (fp) != EOF)\n    WARNINGP (\"TGA: too much input data, ignoring extra...\");\n\n  free (buffer);\n\n  if (hdr->colorMapType == 1)\n    {\n      unsigned char *temp, *temp2, *temp3;\n      int xpos, ypos;\n\n      temp2 = temp = image.bitmap;\n      image.bitmap = temp3 = (unsigned char *) malloc (wh3);\n\n      for (ypos = 0; ypos < height; ypos++)\n        {\n          for (xpos = 0; xpos < width; xpos++)\n            {\n               const unsigned char index = *temp2++;\n               if (index >= ncolors) {\n                 if (!badcolor) {\n                   WARNINGP (\"TGA: color index too large\");\n                   badcolor = 1;\n                 }\n                 *temp3++ = 0;\n                 *temp3++ = 0;\n                 *temp3++ = 0;\n               } else {\n                 unsigned char *cdata = cmap + 3 * index;\n                 *temp3++ = *cdata++;\n                 *temp3++ = *cdata++;\n                 *temp3++ = *cdata;\n               }\n\t    }\n        }\n      free (temp);\n      free (cmap);\n    }\n\n  if (alphas)\n    free (alphas);\n\n  return image;\n}  /* read_image */\n"], "fixing_code": ["/* This code is ripped from Autotrace-0.29. Small modifications by pts. */\n\n/* input-tga.ci reads tga files */\n\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma implementation\n#endif\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* #include <unistd.h> */\n\n#include \"at_bitmap.h\"\n/* #include \"message.h\" */\n/* #include \"xstd.h\" */\n/* #include \"input-tga.h\" */ /* BUGFIX by pts: bmp -> tga */\n\n/* TODO:\n   - Handle loading images that aren't 8 bits per channel.\n*/\n\n/* Round up a division to the nearest integer. */\n#define ROUNDUP_DIVIDE(n,d) (((n) + (d - 1)) / (d))\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\n#define INDEXED 1\n#define INDEXEDA 2\n#define GRAY 3\n#define TGA_RGB 5\n#define INDEXED_IMAGE 1\n#define INDEXEDA_IMAGE 2\n#define GRAY_IMAGE 3\n#define GRAYA_IMAGE 4\n#define TGA_RGB_IMAGE 5\n#define TGA_RGBA_IMAGE 6\n\ntypedef struct _TgaSaveVals\n{\n  int rle;\n} TgaSaveVals;\n\ntypedef struct _TgaSaveInterface\n{\n  int run;\n} TgaSaveInterface;\n\nstruct tga_header\n{\n  unsigned char idLength;\n  unsigned char colorMapType;\n\n  /* The image type. */\n#define TGA_TYPE_MAPPED      1\n#define TGA_TYPE_COLOR       2\n#define TGA_TYPE_GRAY        3\n#define TGA_TYPE_MAPPED_RLE  9\n#define TGA_TYPE_COLOR_RLE  10\n#define TGA_TYPE_GRAY_RLE   11\n  unsigned char imageType;\n\n  /* Color Map Specification. */\n  /* We need to separately specify high and low bytes to avoid endianness\n     and alignment problems. */\n  unsigned char colorMapIndexLo, colorMapIndexHi;\n  unsigned char colorMapLengthLo, colorMapLengthHi;\n  unsigned char colorMapSize;\n\n  /* Image Specification. */\n  unsigned char xOriginLo, xOriginHi;\n  unsigned char yOriginLo, yOriginHi;\n\n  unsigned char widthLo, widthHi;\n  unsigned char heightLo, heightHi;\n\n  unsigned char bpp;\n\n  /* Image descriptor.\n     3-0: attribute bpp\n     4:   left-to-right ordering\n     5:   top-to-bottom ordering\n     7-6: zero\n     */\n#define TGA_DESC_ABITS      0x0f\n#define TGA_DESC_HORIZONTAL 0x10\n#define TGA_DESC_VERTICAL   0x20\n  unsigned char descriptor;\n};\n\n#if 0\nstatic struct\n{\n  unsigned int extensionAreaOffset;\n  unsigned int developerDirectoryOffset;\n#define TGA_SIGNATURE \"TRUEVISION-XFILE\"\n  char signature[16];\n  char dot;\n  char null;\n} tga_footer;\n#endif\n\n\nstatic bitmap_type ReadImage (FILE *fp,\n                         struct tga_header *hdr);\n#if PTS_SAM2P /**** pts ****/\nbitmap_type tga_load_image (FILE* filename)\n#else\nbitmap_type tga_load_image (at_string filename)\n#endif\n{\n  FILE *fp;\n  struct tga_header hdr;\n\n  bitmap_type image;\n\n  image.bitmap = NULL;\n\n  #if PTS_SAM2P /**** pts ****/\n    fp=filename;\n  #else\n    fp = fopen (filename, \"rb\");\n    if (!fp)\n        FATAL1 (\"TGA: can't open \\\"%s\\\"\\n\", filename);\n  #endif\n\n  memset(&hdr, '\\0', sizeof(hdr));\n\n#if 0\n  /* Check the footer. */\n  if (fseek (fp, 0L - (sizeof (tga_footer)), SEEK_END)\n      || fread (&tga_footer, sizeof (tga_footer), 1, fp) != 1)\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot read footer\");\n#else\n      FATAL1 (\"TGA: Cannot read footer from \\\"%s\\\"\\n\", filename);\n#endif\n  /* Check the signature. */\n  if (fseek (fp, 0, SEEK_SET) ||\n#else\n  if (0 ||\n#endif\n      fread (&hdr, sizeof (hdr), 1, fp) != 1)\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot read header\");\n#else\n      FATAL1 (\"TGA: Cannot read header from \\\"%s\\\"\\n\", filename);\n#endif\n\n  /* Skip the image ID field. */\n  {\n#if 0\n    if (hdr.idLength && fseek (fp, hdr.idLength, SEEK_CUR))\n#else\n    char buf[256];\n    if (hdr.idLength!=fread(buf, 1, hdr.idLength, fp))\n#endif\n#if PTS_SAM2P\n      FATALP(\"TGA: Cannot skip ID field\");\n#else\n      FATAL1 (\"TGA: Cannot skip ID field in \\\"%s\\\"\\n\", filename);\n#endif\n  }\n\n  image = ReadImage (fp, &hdr);\n  /* fclose (fp); */\n  return image;\n}\n\n\nstatic int\nstd_fread (unsigned char *buf,\n           int     datasize,\n           int     nelems,\n           FILE   *fp)\n{\n\n  return fread (buf, datasize, nelems, fp);\n}\n\n#define RLE_PACKETSIZE 0x80\n\n/* Decode a bufferful of file. */\nstatic int\nrle_fread (unsigned char *buf,\n           int     datasize,\n           int     nelems,\n           FILE   *fp)\n{\n  static unsigned char *statebuf = 0;\n  static int statelen = 0;\n  static int laststate = 0;\n\n  int j, k;\n  int buflen, count, bytes;\n  unsigned char *p;\n\n  /* Scale the buffer length. */\n  buflen = nelems * datasize;\n\n  j = 0;\n  while (j < buflen)\n    {\n      if (laststate < statelen)\n        {\n          /* Copy bytes from our previously decoded buffer. */\n          bytes = MIN (buflen - j, statelen - laststate);\n          memcpy (buf + j, statebuf + laststate, bytes);\n          j += bytes;\n          laststate += bytes;\n\n          /* If we used up all of our state bytes, then reset them. */\n          if (laststate >= statelen)\n            {\n              laststate = 0;\n              statelen = 0;\n            }\n\n          /* If we filled the buffer, then exit the loop. */\n          if (j >= buflen)\n            break;\n        }\n\n      /* Decode the next packet. */\n      count = fgetc (fp);\n      if (count == EOF)\n        {\n\t    return j / datasize;\n        }\n\n      /* Scale the byte length to the size of the data. */\n      bytes = ((count & ~RLE_PACKETSIZE) + 1) * datasize;\n\n      if (j + bytes <= buflen)\n        {\n          /* We can copy directly into the image buffer. */\n          p = buf + j;\n        }\n      else {\n\t  /* Allocate the state buffer if we haven't already. */\n        if (!statebuf)\n          statebuf = (unsigned char *) malloc (RLE_PACKETSIZE * datasize);\n        p = statebuf;\n      }\n\n      if (count & RLE_PACKETSIZE)\n        {\n          /* Fill the buffer with the next value. */\n          if (fread (p, datasize, 1, fp) != 1)\n            {\n\t\t  \t\t\t\treturn j / datasize;\n            }\n\n          /* Optimized case for single-byte encoded data. */\n          if (datasize == 1)\n            memset (p + 1, *p, bytes - 1);\n          else\n            for (k = datasize; k < bytes; k += datasize)\n              memcpy (p + k, p, datasize);\n        }\n      else\n        {\n          /* Read in the buffer. */\n          if (fread (p, bytes, 1, fp) != 1)\n            {\n\t       return j / datasize;\n            }\n        }\n\n      /* We may need to copy bytes from the state buffer. */\n      if (p == statebuf)\n        statelen = bytes;\n      else\n        j += bytes;\n    }\n\nreturn nelems;\n}\n\nstatic bitmap_type\nReadImage (FILE              *fp,\n           struct tga_header *hdr)\n{\n  bitmap_type image;\n  unsigned char *buffer;\n  unsigned char *alphas;\n\n  int width, height, bpp, abpp, pbpp;\n  unsigned nalphas = 0, ncolors = 0;\n  int wh, wh3, whp;\n  int j, k;\n  int pelbytes, wbytes, bsize, npels, pels;\n  int rle;\n  char badread = 0, badalpha = 0, badcolor = 0;\n  int itype=0;\n  unsigned char *cmap = NULL;\n  int (*myfread)(unsigned char *, int, int, FILE *);\n\n  /* Find out whether the image is horizontally or vertically reversed. */\n  char horzrev = (char) (hdr->descriptor & TGA_DESC_HORIZONTAL);\n  char vertrev = (char) (!(hdr->descriptor & TGA_DESC_VERTICAL));\n\n  image.bitmap = NULL;\n\n  /* Reassemble the multi-byte values correctly, regardless of\n     host endianness. */\n  width = (hdr->widthHi << 8) | hdr->widthLo;\n  height = (hdr->heightHi << 8) | hdr->heightLo;\n\n  bpp = hdr->bpp;\n  abpp = hdr->descriptor & TGA_DESC_ABITS;\n\n  if (hdr->imageType == TGA_TYPE_COLOR ||\n      hdr->imageType == TGA_TYPE_COLOR_RLE)\n    pbpp = MIN (bpp / 3, 8) * 3;\n  else if (abpp < bpp)\n    pbpp = bpp - abpp;\n  else\n    pbpp = bpp;\n\n  if (abpp + pbpp > bpp)\n    {\n      WARNINGP3 (\"TGA: \",pbpp,\" bit image, \",abpp,\" bit alpha is greater than \",bpp,\" total bits per pixel\");\n\n      /* Assume that alpha bits were set incorrectly. */\n      abpp = bpp - pbpp;\n      WARNINGP1 (\"TGA: reducing to * bit alpha: \", abpp);\n    }\n  else if (abpp + pbpp < bpp)\n    {\n      WARNINGP3 (\"TGA: \",pbpp,\" bit image, \",abpp,\" bit alpha is less than \",bpp,\" total bits per pixel\");\n\n      /* Again, assume that alpha bits were set incorrectly. */\n      abpp = bpp - pbpp;\n      WARNINGP1 (\"TGA: increasing to * bit alpha: \", abpp);\n    }\n\n  rle = 0;\n  switch (hdr->imageType)\n    {\n    case TGA_TYPE_MAPPED_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_MAPPED:\n      itype = INDEXED;\n\n      /* Find the size of palette elements. */\n      pbpp = MIN (hdr->colorMapSize / 3, 8) * 3;\n      if (pbpp < hdr->colorMapSize)\n        abpp = hdr->colorMapSize - pbpp;\n      else\n        abpp = 0;\n\n\n      if (bpp != 8)\n\t    /* We can only cope with 8-bit indices. */\n          FATALP (\"TGA: index sizes other than 8 bits are unimplemented\");\n      break;\n\n    case TGA_TYPE_GRAY_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_GRAY:\n      itype = GRAY;\n      break;\n\n    case TGA_TYPE_COLOR_RLE:\n      rle = 1;\n      /*fallthrough*/\n    case TGA_TYPE_COLOR:\n      itype = TGA_RGB;\n      break;\n\n    default:\n      FATALP1 (\"TGA: unrecognized image type \", (unsigned)hdr->imageType);\n}\n\n  if ((abpp && abpp != 8) ||\n      ((itype == TGA_RGB || itype == INDEXED) && pbpp != 24) ||\n      (itype == GRAY && pbpp != 8))\n      /* FIXME: We haven't implemented bit-packed fields yet. */\n      FATALP (\"TGA: channel sizes other than 8 bits are unimplemented\");\n\n  /* Check that we have a color map only when we need it. */\n  if (itype == INDEXED)\n    {\n      if (hdr->colorMapType != 1)\n\t    FATALP1 (\"TGA: indexed image has invalid color map type \",\n                  (unsigned)hdr->colorMapType);\n    }\n  else if (hdr->colorMapType != 0)\n      FATALP1 (\"TGA: non-indexed image has invalid color map type \",\n              (unsigned)hdr->colorMapType);\n\n  alphas = 0;\n  if (hdr->colorMapType == 1)\n    {\n      /* We need to read in the colormap. */\n      unsigned index, length, j, k;\n\n      index = (hdr->colorMapIndexHi << 8) | hdr->colorMapIndexLo;\n      length = (hdr->colorMapLengthHi << 8) | hdr->colorMapLengthLo;\n\n\t  if (length == 0)\n        FATALP1 (\"TGA: invalid color map length \", length);\n\n      pelbytes = ROUNDUP_DIVIDE (hdr->colorMapSize, 8);\n      ncolors = length + index;\n      cmap = (unsigned char *) malloc (ncolors * pelbytes);\n\n      /* Zero the entries up to the beginning of the map. */\n      memset (cmap, 0, index * pelbytes);\n\n      /* Read in the rest of the colormap. */\n      if (fread (cmap + (index * pelbytes), pelbytes, length, fp) != length)\n        FATALP1 (\"TGA: error reading colormap; ftell == \", ftell (fp));\n\n      /* If we have an alpha channel, then create a mapping to the alpha\n         values. */\n      if (pelbytes > 3)\n        alphas = (unsigned char *) malloc (ncolors);\n\n      for (j = k = 0; j < ncolors * pelbytes; j += pelbytes)\n        {\n          /* Swap from BGR to TGA_RGB. */\n          unsigned char tmp = cmap[j];\n          cmap[k ++] = cmap[j + 2];\n          cmap[k ++] = cmap[j + 1];\n          cmap[k ++] = tmp;\n\n          /* Take the alpha values out of the colormap. */\n          if (alphas)\n            alphas[nalphas ++] = cmap[j + 3];\n        }\n\n#if 0  /**** pts ****/\n      /* If the last color was transparent, then omit it from the\n         mapping. */\n      if (nalphas && alphas[nalphas - 1] == 0)\n        ncolors --;\n#endif\n\n      /* Now pretend as if we only have 8 bpp. */\n      abpp = 0;\n      pbpp = 8;\n\t  pelbytes = 1;\n    }\n  else\n\t  pelbytes = 3;\n\n  wh = (unsigned)width * height;\n  if (width != 0 && wh / width != height) {\n   idl_error:\n    FATALP(\"TGA: image dimensions too large\");\n  }\n  wh3 = 3U * wh;\n  if (wh3 / 3 != wh) goto idl_error;\n  whp = (unsigned)pelbytes * wh;\n  if (whp / pelbytes != wh) goto idl_error;\n\n  image.bitmap = (unsigned char *) malloc (wh3);\n  BITMAP_WIDTH (image) = (unsigned short) width;\n  BITMAP_HEIGHT (image) = (unsigned short) height;\n  BITMAP_PLANES (image) = (unsigned short) 3;\n\n   /* Calculate TGA bytes per pixel. */\n  bpp = ROUNDUP_DIVIDE (pbpp + abpp, 8);\n\n  /* Maybe we need to reverse the data. */\n  buffer = NULL;\n  if (horzrev || vertrev)\n    buffer = (unsigned char *) malloc (whp);\n  if (rle)\n    myfread = rle_fread;\n  else\n    myfread = std_fread;\n\n  wbytes = width * pelbytes;\n\n  npels = wh;\n  bsize = wbytes * height;\n\n  /* Suck in the data one height at a time. */\n  if (badread)\n    pels = 0;\n  else\n    pels = (*myfread) (image.bitmap, bpp, npels, fp);\n\n  if (pels != npels)\n    {\n      if (!badread)\n        {\n          /* Probably premature end of file. */\n          WARNINGP1 (\"TGA: error reading; ftell == \", ftell (fp));\n          badread = 1;\n        }\n\n\n      /* Fill the rest of this tile with zeros. */\n      memset (image.bitmap + (pels * bpp), 0, ((npels - pels) * bpp));\n    }\n  /* If we have indexed alphas, then set them. */\n  if (nalphas)\n    {\n      /* Start at the end of the buffer, and work backwards. */\n      k = (npels - 1) * bpp;\n      for (j = bsize - pelbytes; j >= 0; j -= pelbytes)\n        {\n          /* Find the alpha for this index. */\n          const unsigned char tmp = image.bitmap[k--];\n          if (tmp >= nalphas) {\n            if (!badalpha) {\n              WARNINGP (\"TGA: alpha index too large\");\n              badalpha = 1;\n            }\n            image.bitmap[j + 1] = 0;\n          } else {\n            image.bitmap[j + 1] = alphas[tmp];\n          }\n          image.bitmap[j] = tmp;\n        }\n    }\n\n   if (itype == GRAY)\n      for (j = bsize/3 - 1; j >= 0; j -= 1)\n        {\n          /* Find the alpha for this index. */\n          image.bitmap[3*j] = image.bitmap[j];\n          image.bitmap[3*j+1] = image.bitmap[j];\n          image.bitmap[3*j+2] = image.bitmap[j];\n        }\n\n\n  if (pelbytes >= 3)\n    {\n      /* Rearrange the colors from BGR to TGA_RGB. */\n      for (j = 0; j < bsize; j += pelbytes)\n        {\n          const unsigned char tmp = image.bitmap[j];\n          image.bitmap[j] = image.bitmap[j + 2];\n          image.bitmap[j + 2] = tmp;\n        }\n    }\n\n\n\n  if (horzrev || vertrev)\n    {\n      unsigned char *tmp;\n      if (vertrev)\n        {\n          /* We need to mirror only vertically. */\n          for (j = 0; j < bsize; j += wbytes)\n            memcpy (buffer + j,\n              image.bitmap + bsize - (j + wbytes), wbytes);\n        }\n      else if (horzrev)\n        {\n          /* We need to mirror only horizontally. */\n          for (j = 0; j < bsize; j += wbytes)\n            for (k = 0; k < wbytes; k += pelbytes)\n              memcpy (buffer + k + j,\n                image.bitmap + (j + wbytes) - (k + pelbytes), pelbytes);\n        }\n      else\n        {\n          /* Completely reverse the pixels in the buffer. */\n          for (j = 0; j < bsize; j += pelbytes)\n            memcpy (buffer + j,\n              image.bitmap + bsize - (j + pelbytes), pelbytes);\n        }\n\n       /* Swap the buffers because we modified them. */\n      tmp = buffer;\n      buffer = image.bitmap;\n      image.bitmap = tmp;\n    }\n\n  if (fgetc (fp) != EOF)\n    WARNINGP (\"TGA: too much input data, ignoring extra...\");\n\n  free (buffer);\n\n  if (hdr->colorMapType == 1)\n    {\n      unsigned char *temp, *temp2, *temp3;\n      int xpos, ypos;\n\n      temp2 = temp = image.bitmap;\n      image.bitmap = temp3 = (unsigned char *) malloc (wh3);\n\n      for (ypos = 0; ypos < height; ypos++)\n        {\n          for (xpos = 0; xpos < width; xpos++)\n            {\n               const unsigned char index = *temp2++;\n               if (index >= ncolors) {\n                 if (!badcolor) {\n                   WARNINGP (\"TGA: color index too large\");\n                   badcolor = 1;\n                 }\n                 *temp3++ = 0;\n                 *temp3++ = 0;\n                 *temp3++ = 0;\n               } else {\n                 unsigned char *cdata = cmap + 3 * index;\n                 *temp3++ = *cdata++;\n                 *temp3++ = *cdata++;\n                 *temp3++ = *cdata;\n               }\n\t    }\n        }\n      free (temp);\n      free (cmap);\n    }\n\n  if (alphas)\n    free (alphas);\n\n  return image;\n}  /* read_image */\n"], "filenames": ["input-tga.ci"], "buggy_code_start_loc": [455], "buggy_code_end_loc": [456], "fixing_code_start_loc": [455], "fixing_code_end_loc": [456], "type": "NVD-CWE-noinfo", "message": "There is a floating point exception in ReadImage that leads to a Segmentation fault in sam2p 0.49.4. A crafted input will lead to a denial of service or possibly unspecified other impact.", "other": {"cve": {"id": "CVE-2020-19492", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:09.063", "lastModified": "2021-07-30T16:45:14.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a floating point exception in ReadImage that leads to a Segmentation fault in sam2p 0.49.4. A crafted input will lead to a denial of service or possibly unspecified other impact."}, {"lang": "es", "value": "Se presenta una excepci\u00f3n de punto flotante en la funci\u00f3n ReadImage que conlleva un Fallo de Segmentaci\u00f3n en sam2p versi\u00f3n 0.49.4. Una entrada dise\u00f1ada conllevar\u00eda a una denegaci\u00f3n de servicio o posiblemente otros impactos no especificado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sam2p_project:sam2p:0.49.4:*:*:*:*:*:*:*", "matchCriteriaId": "EE79927B-648D-46F8-ACDF-5E96440FDD02"}]}]}], "references": [{"url": "https://github.com/pts/sam2p/commit/b953f63307c4a83fa4615a4863e3fb250205cd98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pts/sam2p/issues/66", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pts/sam2p/commit/b953f63307c4a83fa4615a4863e3fb250205cd98"}}