{"buggy_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author  Dmitry (dio) Levashov\n * @author  Troex Nevelin\n * @author  Alexey Sukhotin\n **/\nclass elFinder\n{\n\n    /**\n     * API version number\n     *\n     * @var float\n     **/\n    protected static $ApiVersion = 2.1;\n\n    /**\n     * API version number\n     *\n     * @deprecated\n     * @var string\n     **/\n    protected $version;\n\n    /**\n     * API revision that this connector supports all functions\n     *\n     * @var integer\n     */\n    protected static $ApiRevision = 58;\n\n    /**\n     * Storages (root dirs)\n     *\n     * @var array\n     **/\n    protected $volumes = array();\n\n    /**\n     * elFinder instance\n     *\n     * @var object\n     */\n    public static $instance = null;\n\n    /**\n     * Current request args\n     *\n     * @var array\n     */\n    public static $currentArgs = array();\n\n    /**\n     * Network mount drivers\n     *\n     * @var array\n     */\n    public static $netDrivers = array();\n\n    /**\n     * elFinder global locale\n     *\n     * @var string\n     */\n    public static $locale = '';\n\n    /**\n     * elFinderVolumeDriver default mime.type file path\n     *\n     * @var string\n     */\n    public static $defaultMimefile = '';\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkUrl = '';\n\n    /**\n     * Temporary content URL lifetime (seconds)\n     *\n     * @var integer\n     */\n    public static $tmpLinkLifeTime = 3600;\n\n    /**\n     * MIME type list handled as a text file\n     *\n     * @var array\n     */\n    public static $textMimes = array(\n        'application/dash+xml',\n        'application/docbook+xml',\n        'application/javascript',\n        'application/json',\n        'application/plt',\n        'application/sat',\n        'application/sql',\n        'application/step',\n        'application/vnd.hp-hpgl',\n        'application/x-awk',\n        'application/x-config',\n        'application/x-csh',\n        'application/x-empty',\n        'application/x-mpegurl',\n        'application/x-perl',\n        'application/x-php',\n        'application/x-web-config',\n        'application/xhtml+xml',\n        'application/xml',\n        'audio/x-mp3-playlist',\n        'image/cgm',\n        'image/svg+xml',\n        'image/vnd.dxf',\n        'model/iges'\n    );\n\n    /**\n     * Maximum memory size to be extended during GD processing\n     * (0: not expanded, -1: unlimited or memory size notation)\n     *\n     * @var integer|string\n     */\n    public static $memoryLimitGD = 0;\n\n    /**\n     * Path of current request flag file for abort check\n     *\n     * @var string\n     */\n    protected static $abortCheckFile = null;\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * elFinder global sessionCacheKey\n     *\n     * @deprecated\n     * @var string\n     */\n    public static $sessionCacheKey = '';\n\n    /**\n     * Is session closed\n     *\n     * @deprecated\n     * @var bool\n     */\n    private static $sessionClosed = false;\n\n    /**\n     * elFinder base64encodeSessionData\n     * elFinder save session data as `UTF-8`\n     * If the session storage mechanism of the system does not allow `UTF-8`\n     * And it must be `true` option 'base64encodeSessionData' of elFinder\n     * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n     * it make vulnerable to the object injection attack, so use it carefully.\n     * see https://github.com/Studio-42/elFinder/issues/2345\n     *\n     * @var bool\n     */\n    protected static $base64encodeSessionData = false;\n\n    /**\n     * elFinder common tempraly path\n     *\n     * @var string\n     * @default \"./.tmp\" or sys_get_temp_dir()\n     **/\n    protected static $commonTempPath = '';\n\n    /**\n     * Callable function for URL upload filter\n     * The first argument is a URL and the second argument is an instance of the elFinder class\n     * A filter should be return true (to allow) / false (to disallow)\n     *\n     * @var callable\n     * @default null\n     */\n    protected $urlUploadFilter = null;\n\n    /**\n     * Connection flag files path that connection check of current request\n     *\n     * @var string\n     * @default value of $commonTempPath\n     */\n    protected static $connectionFlagsPath = '';\n\n    /**\n     * Additional volume root options for network mounting volume\n     *\n     * @var array\n     */\n    protected $optionsNetVolumes = array();\n\n    /**\n     * Session key of net mount volumes\n     *\n     * @deprecated\n     * @var string\n     */\n    protected $netVolumesSessionKey = '';\n\n    /**\n     * Mounted volumes count\n     * Required to create unique volume id\n     *\n     * @var int\n     **/\n    public static $volumesCnt = 1;\n\n    /**\n     * Default root (storage)\n     *\n     * @var elFinderVolumeDriver\n     **/\n    protected $default = null;\n\n    /**\n     * Commands and required arguments list\n     *\n     * @var array\n     **/\n    protected $commands = array(\n        'abort' => array('id' => true),\n        'archive' => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n        'callback' => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n        'chmod' => array('targets' => true, 'mode' => true),\n        'dim' => array('target' => true, 'substitute' => false),\n        'duplicate' => array('targets' => true, 'suffix' => false),\n        'editor' => array('name' => true, 'method' => true, 'args' => false),\n        'extract' => array('target' => true, 'mimes' => false, 'makedir' => false),\n        'file' => array('target' => true, 'download' => false, 'cpath' => false, 'onetime' => false),\n        'get' => array('target' => true, 'conv' => false),\n        'info' => array('targets' => true, 'compare' => false),\n        'ls' => array('target' => true, 'mimes' => false, 'intersect' => false),\n        'mkdir' => array('target' => true, 'name' => false, 'dirs' => false),\n        'mkfile' => array('target' => true, 'name' => true, 'mimes' => false),\n        'netmount' => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n        'open' => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n        'parents' => array('target' => true, 'until' => false),\n        'paste' => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n        'put' => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n        'rename' => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n        'resize' => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n        'rm' => array('targets' => true),\n        'search' => array('q' => true, 'mimes' => false, 'target' => false, 'type' => false),\n        'size' => array('targets' => true),\n        'subdirs' => array('targets' => true),\n        'tmb' => array('targets' => true),\n        'tree' => array('target' => true),\n        'upload' => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false, 'contentSaveId' => false),\n        'url' => array('target' => true, 'options' => false),\n        'zipdl' => array('targets' => true, 'download' => false)\n    );\n\n    /**\n     * Plugins instance\n     *\n     * @var array\n     **/\n    protected $plugins = array();\n\n    /**\n     * Commands listeners\n     *\n     * @var array\n     **/\n    protected $listeners = array();\n\n    /**\n     * script work time for debug\n     *\n     * @var string\n     **/\n    protected $time = 0;\n    /**\n     * Is elFinder init correctly?\n     *\n     * @var bool\n     **/\n    protected $loaded = false;\n    /**\n     * Send debug to client?\n     *\n     * @var string\n     **/\n    protected $debug = false;\n\n    /**\n     * Call `session_write_close()` before exec command?\n     *\n     * @var bool\n     */\n    protected $sessionCloseEarlier = true;\n\n    /**\n     * SESSION use commands @see __construct()\n     *\n     * @var array\n     */\n    protected $sessionUseCmds = array();\n\n    /**\n     * session expires timeout\n     *\n     * @var int\n     **/\n    protected $timeout = 0;\n\n    /**\n     * Temp dir path for Upload\n     *\n     * @var string\n     */\n    protected $uploadTempPath = '';\n\n    /**\n     * Max allowed archive files size (0 - no limit)\n     *\n     * @var integer\n     */\n    protected $maxArcFilesSize = 0;\n\n    /**\n     * undocumented class variable\n     *\n     * @var string\n     **/\n    protected $uploadDebug = '';\n\n    /**\n     * Max allowed numbar of targets (0 - no limit)\n     *\n     * @var integer\n     */\n    public $maxTargets = 1000;\n\n    /**\n     * Errors from PHP\n     *\n     * @var array\n     **/\n    public static $phpErrors = array();\n\n    /**\n     * Errors from not mounted volumes\n     *\n     * @var array\n     **/\n    public $mountErrors = array();\n\n\n    /**\n     * Archivers cache\n     *\n     * @var array\n     */\n    public static $archivers = array();\n\n    /**\n     * URL for callback output window for CORS\n     * redirect to this URL when callback output\n     *\n     * @var string URL\n     */\n    protected $callbackWindowURL = '';\n\n    /**\n     * hash of items to unlock on command completion\n     *\n     * @var array hashes\n     */\n    protected $autoUnlocks = array();\n\n    /**\n     * Item locking expiration (seconds)\n     * Default: 3600 secs\n     *\n     * @var integer\n     */\n    protected $itemLockExpire = 3600;\n\n    /**\n     * Additional request querys\n     *\n     * @var array|null\n     */\n    protected $customData = null;\n\n    /**\n     * Ids to remove of session var \"urlContentSaveIds\" for contents uploading by URL\n     *\n     * @var array\n     */\n    protected $removeContentSaveIds = array();\n\n    /**\n     * Flag of throw Error on exec()\n     *\n     * @var boolean\n     */\n    protected $throwErrorOnExec = false;\n\n    /**\n     * Default params of toastParams\n     *\n     * @var        array\n     */\n    protected $toastParamsDefault = array(\n        'mode'   => 'warning',\n        'prefix' => ''\n    );\n\n    /**\n     * Toast params of runtime notification\n     *\n     * @var        array\n     */\n    private $toastParams = array();\n\n    /**\n     * Toast messages of runtime notification\n     *\n     * @var        array\n     */\n    private $toastMessages = array();\n\n    /**\n     * Optional UTF-8 encoder\n     *\n     * @var        callable || null\n     */\n    private $utf8Encoder = null;\n\n    /**\n     * Seekable URL file pointer ids -  for getStreamByUrl()\n     *\n     * @var        array\n     */\n    private static $seekableUrlFps = array();\n\n    // Errors messages\n    const ERROR_ACCESS_DENIED = 'errAccess';\n    const ERROR_ARC_MAXSIZE = 'errArcMaxSize';\n    const ERROR_ARC_SYMLINKS = 'errArcSymlinks';\n    const ERROR_ARCHIVE = 'errArchive';\n    const ERROR_ARCHIVE_EXEC = 'errArchiveExec';\n    const ERROR_ARCHIVE_TYPE = 'errArcType';\n    const ERROR_CONF = 'errConf';\n    const ERROR_CONF_NO_JSON = 'errJSON';\n    const ERROR_CONF_NO_VOL = 'errNoVolumes';\n    const ERROR_CONV_UTF8 = 'errConvUTF8';\n    const ERROR_COPY = 'errCopy';\n    const ERROR_COPY_FROM = 'errCopyFrom';\n    const ERROR_COPY_ITSELF = 'errCopyInItself';\n    const ERROR_COPY_TO = 'errCopyTo';\n    const ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n    const ERROR_DIR_NOT_FOUND = 'errFolderNotFound';\n    const ERROR_EXISTS = 'errExists';        // 'File named \"$1\" already exists.'\n    const ERROR_EXTRACT = 'errExtract';\n    const ERROR_EXTRACT_EXEC = 'errExtractExec';\n    const ERROR_FILE_NOT_FOUND = 'errFileNotFound';     // 'File not found.'\n    const ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n    const ERROR_FTP_MKDIR = 'errFtpMkdir';\n    const ERROR_FTP_UPLOAD_FILE = 'errFtpUploadFile';\n    const ERROR_INV_PARAMS = 'errCmdParams';\n    const ERROR_INVALID_DIRNAME = 'errInvDirname';    // 'Invalid folder name.'\n    const ERROR_INVALID_NAME = 'errInvName';       // 'Invalid file name.'\n    const ERROR_LOCKED = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n    const ERROR_MAX_TARGTES = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n    const ERROR_MKDIR = 'errMkdir';\n    const ERROR_MKFILE = 'errMkfile';\n    const ERROR_MKOUTLINK = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n    const ERROR_MOVE = 'errMove';\n    const ERROR_NETMOUNT = 'errNetMount';\n    const ERROR_NETMOUNT_FAILED = 'errNetMountFailed';\n    const ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n    const ERROR_NETUNMOUNT = 'errNetUnMount';\n    const ERROR_NOT_ARCHIVE = 'errNoArchive';\n    const ERROR_NOT_DIR = 'errNotFolder';\n    const ERROR_NOT_FILE = 'errNotFile';\n    const ERROR_NOT_REPLACE = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n    const ERROR_NOT_UTF8_CONTENT = 'errNotUTF8Content';\n    const ERROR_OPEN = 'errOpen';\n    const ERROR_PERM_DENIED = 'errPerm';\n    const ERROR_REAUTH_REQUIRE = 'errReauthRequire';  // 'Re-authorization is required.'\n    const ERROR_RENAME = 'errRename';\n    const ERROR_REPLACE = 'errReplace';          // 'Unable to replace \"$1\".'\n    const ERROR_RESIZE = 'errResize';\n    const ERROR_RESIZESIZE = 'errResizeSize';\n    const ERROR_RM = 'errRm';               // 'Unable to remove \"$1\".'\n    const ERROR_RM_SRC = 'errRmSrc';            // 'Unable remove source file(s)'\n    const ERROR_SAVE = 'errSave';\n    const ERROR_SEARCH_TIMEOUT = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n    const ERROR_SESSION_EXPIRES = 'errSessionExpires';\n    const ERROR_TRGDIR_NOT_FOUND = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n    const ERROR_UNKNOWN = 'errUnknown';\n    const ERROR_UNKNOWN_CMD = 'errUnknownCmd';\n    const ERROR_UNSUPPORT_TYPE = 'errUsupportType';\n    const ERROR_UPLOAD = 'errUpload';           // 'Upload error.'\n    const ERROR_UPLOAD_FILE = 'errUploadFile';       // 'Unable to upload \"$1\".'\n    const ERROR_UPLOAD_FILE_MIME = 'errUploadMime';       // 'File type not allowed.'\n    const ERROR_UPLOAD_FILE_SIZE = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n    const ERROR_UPLOAD_NO_FILES = 'errUploadNoFiles';    // 'No files found for upload.'\n    const ERROR_UPLOAD_TEMP = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n    const ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n    const ERROR_UPLOAD_TRANSFER = 'errUploadTransfer';   // '\"$1\" transfer error.'\n    const ERROR_MAX_MKDIRS = 'errMaxMkdirs'; // 'You can create up to $1 folders at one time.'\n\n    /**\n     * Constructor\n     *\n     * @param  array  elFinder and roots configurations\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct($opts)\n    {\n        // set default_charset\n        if (version_compare(PHP_VERSION, '5.6', '>=')) {\n            if (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('iconv.internal_encoding', '');\n            }\n            if (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('mbstring.internal_encoding', '');\n            }\n            if (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('internal_encoding', '');\n            }\n        } else {\n            if (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n                iconv_set_encoding('internal_encoding', 'UTF-8');\n            }\n            if (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n                mb_internal_encoding('UTF-8');\n            }\n        }\n        ini_set('default_charset', 'UTF-8');\n\n        // define accept constant of server commands path\n        !defined('ELFINDER_TAR_PATH') && define('ELFINDER_TAR_PATH', 'tar');\n        !defined('ELFINDER_GZIP_PATH') && define('ELFINDER_GZIP_PATH', 'gzip');\n        !defined('ELFINDER_BZIP2_PATH') && define('ELFINDER_BZIP2_PATH', 'bzip2');\n        !defined('ELFINDER_XZ_PATH') && define('ELFINDER_XZ_PATH', 'xz');\n        !defined('ELFINDER_ZIP_PATH') && define('ELFINDER_ZIP_PATH', 'zip');\n        !defined('ELFINDER_UNZIP_PATH') && define('ELFINDER_UNZIP_PATH', 'unzip');\n        !defined('ELFINDER_RAR_PATH') && define('ELFINDER_RAR_PATH', 'rar');\n        // Create archive in RAR4 format even when using RAR5 library (true or false)\n        !defined('ELFINDER_RAR_MA4') && define('ELFINDER_RAR_MA4', false);\n        !defined('ELFINDER_UNRAR_PATH') && define('ELFINDER_UNRAR_PATH', 'unrar');\n        !defined('ELFINDER_7Z_PATH') && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN') ? '7z' : '7za');\n        !defined('ELFINDER_CONVERT_PATH') && define('ELFINDER_CONVERT_PATH', 'convert');\n        !defined('ELFINDER_IDENTIFY_PATH') && define('ELFINDER_IDENTIFY_PATH', 'identify');\n        !defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n        !defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n        !defined('ELFINDER_FFMPEG_PATH') && define('ELFINDER_FFMPEG_PATH', 'ffmpeg');\n\n        !defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n        // enable(true)/disable(false) handling postscript on ImageMagick\n        // Should be `false` as long as there is a Ghostscript vulnerability\n        // see https://artifex.com/news/ghostscript-security-resolved/\n        !defined('ELFINDER_IMAGEMAGICK_PS') && define('ELFINDER_IMAGEMAGICK_PS', false);\n\n        // for backward compat\n        $this->version = (string)self::$ApiVersion;\n\n        // set error handler of WARNING, NOTICE\n        $errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n        if (defined('E_DEPRECATED')) {\n            $errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n        }\n        set_error_handler('elFinder::phpErrorHandler', $errLevel);\n\n        // Associative array of file pointers to close at the end of script: ['temp file pointer' => true]\n        $GLOBALS['elFinderTempFps'] = array();\n        // Associative array of files to delete at the end of script: ['temp file path' => true]\n        $GLOBALS['elFinderTempFiles'] = array();\n        // regist Shutdown function\n        register_shutdown_function(array('elFinder', 'onShutdown'));\n\n        // convert PATH_INFO to GET query\n        if (!empty($_SERVER['PATH_INFO'])) {\n            $_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n            if (!isset($_GET['cmd'])) {\n                $_cmd = $_ps[0];\n                if (isset($this->commands[$_cmd])) {\n                    $_GET['cmd'] = $_cmd;\n                    $_i = 1;\n                    foreach (array_keys($this->commands[$_cmd]) as $_k) {\n                        if (isset($_ps[$_i])) {\n                            if (!isset($_GET[$_k])) {\n                                $_GET[$_k] = $_ps[$_i++];\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // set elFinder instance\n        elFinder::$instance = $this;\n\n        // setup debug mode\n        $this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n        if ($this->debug) {\n            error_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL') ? ELFINDER_DEBUG_ERRORLEVEL : -1);\n            ini_set('display_errors', '1');\n            // clear output buffer and stop output filters\n            while (ob_get_level() && ob_end_clean()) {\n            }\n        }\n\n        if (!interface_exists('elFinderSessionInterface')) {\n            include_once dirname(__FILE__) . '/elFinderSessionInterface.php';\n        }\n\n        // session handler\n        if (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n            $this->session = $opts['session'];\n        } else {\n            $sessionOpts = array(\n                'base64encode' => !empty($opts['base64encodeSessionData']),\n                'keys' => array(\n                    'default' => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n                    'netvolume' => !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n                )\n            );\n            if (!class_exists('elFinderSession')) {\n                include_once dirname(__FILE__) . '/elFinderSession.php';\n            }\n            $this->session = new elFinderSession($sessionOpts);\n        }\n        // try session start | restart\n        $this->session->start();\n\n        // 'netmount' added to handle requests synchronously on unmount\n        $sessionUseCmds = array('netmount');\n        if (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n            $sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n        }\n\n        // set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n        if (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n            self::$volumesCnt = $volumesCntStart;\n        }\n\n        $this->time = $this->utime();\n        $this->sessionCloseEarlier = isset($opts['sessionCloseEarlier']) ? (bool)$opts['sessionCloseEarlier'] : true;\n        $this->sessionUseCmds = array_flip($sessionUseCmds);\n        $this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n        $this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n        $this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n        $this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n        elFinder::$commonTempPath = (isset($opts['commonTempPath']) ? realpath($opts['commonTempPath']) : dirname(__FILE__) . '/.tmp');\n        if (!is_writable(elFinder::$commonTempPath)) {\n            elFinder::$commonTempPath = sys_get_temp_dir();\n            if (!is_writable(elFinder::$commonTempPath)) {\n                elFinder::$commonTempPath = '';\n            }\n        }\n        if (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'] = realpath($opts['connectionFlagsPath']))) {\n            elFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n        } else {\n            elFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n        }\n\n        if (!empty($opts['tmpLinkPath'])) {\n            elFinder::$tmpLinkPath = realpath($opts['tmpLinkPath']);\n        }\n        if (!empty($opts['tmpLinkUrl'])) {\n            elFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n        }\n        if (!empty($opts['tmpLinkLifeTime'])) {\n            elFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n        }\n        if (!empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n            elfinder::$textMimes = $opts['textMimes'];\n        }\n        if (!empty($opts['urlUploadFilter'])) {\n            $this->urlUploadFilter = $opts['urlUploadFilter'];\n        }\n        $this->maxArcFilesSize = isset($opts['maxArcFilesSize']) ? intval($opts['maxArcFilesSize']) : 0;\n        $this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes'])) ? $opts['optionsNetVolumes'] : array();\n        if (isset($opts['itemLockExpire'])) {\n            $this->itemLockExpire = intval($opts['itemLockExpire']);\n        }\n\n        // deprecated settings\n        $this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n        self::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\n        // check session cache\n        $_optsMD5 = md5(json_encode($opts['roots']));\n        if ($this->session->get('_optsMD5') !== $_optsMD5) {\n            $this->session->set('_optsMD5', $_optsMD5);\n        }\n\n        // setlocale and global locale regists to elFinder::locale\n        self::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN' ? 'C' : 'en_US.UTF-8');\n        if (false === setlocale(LC_ALL, self::$locale)) {\n            self::$locale = setlocale(LC_ALL, '0');\n        }\n\n        // set defaultMimefile\n        elFinder::$defaultMimefile = isset($opts['defaultMimefile']) ? $opts['defaultMimefile'] : '';\n\n        // set memoryLimitGD\n        elFinder::$memoryLimitGD = isset($opts['memoryLimitGD']) ? $opts['memoryLimitGD'] : 0;\n\n        // set flag of throwErrorOnExec\n        // `true` need `try{}` block for `$connector->run();`\n        $this->throwErrorOnExec = !empty($opts['throwErrorOnExec']);\n\n        // set archivers\n        elFinder::$archivers = isset($opts['archivers']) && is_array($opts['archivers']) ? $opts['archivers'] : array();\n\n        // set utf8Encoder\n        if (isset($opts['utf8Encoder']) && is_callable($opts['utf8Encoder'])) {\n            $this->utf8Encoder = $opts['utf8Encoder'];\n        }\n\n        // bind events listeners\n        if (!empty($opts['bind']) && is_array($opts['bind'])) {\n            $_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n            $_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n            foreach ($opts['bind'] as $cmd => $handlers) {\n                $doRegist = (strpos($cmd, '*') !== false);\n                if (!$doRegist) {\n                    $doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n                }\n                if ($doRegist) {\n                    // for backward compatibility\n                    if (!is_array($handlers)) {\n                        $handlers = array($handlers);\n                    } else {\n                        if (count($handlers) === 2 && is_callable($handlers)) {\n                            $handlers = array($handlers);\n                        }\n                    }\n                    foreach ($handlers as $handler) {\n                        if ($handler) {\n                            if (is_string($handler) && strpos($handler, '.')) {\n                                list($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n                                if (strcasecmp($_domain, 'plugin') === 0) {\n                                    if ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name]) ? $opts['plugin'][$_name] : array())\n                                        and method_exists($plugin, $_method)) {\n                                        $this->bind($cmd, array($plugin, $_method));\n                                    }\n                                }\n                            } else {\n                                $this->bind($cmd, $handler);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isset($opts['roots']) || !is_array($opts['roots'])) {\n            $opts['roots'] = array();\n        }\n\n        // try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n        if (empty(elFinder::$netDrivers['ziparchive'])) {\n            elFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n        }\n\n        // check for net volumes stored in session\n        $netVolumes = $this->getNetVolumes();\n        foreach ($netVolumes as $key => $root) {\n            if (!isset($root['id'])) {\n                // given fixed unique id\n                if (!$root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                    $this->mountErrors[] = 'Netmount Driver \"' . $root['driver'] . '\" : Could\\'t given volume id.';\n                    continue;\n                }\n            }\n            $root['_isNetVolume'] = true;\n            $opts['roots'][$key] = $root;\n        }\n\n        // \"mount\" volumes\n        foreach ($opts['roots'] as $i => $o) {\n            $class = 'elFinderVolume' . (isset($o['driver']) ? $o['driver'] : '');\n\n            if (class_exists($class)) {\n                /* @var elFinderVolumeDriver $volume */\n                $volume = new $class();\n\n                try {\n                    if ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n                        $o['maxArcFilesSize'] = $this->maxArcFilesSize;\n                    }\n                    // pass session handler\n                    $volume->setSession($this->session);\n                    if (!$this->default) {\n                        $volume->setNeedOnline(true);\n                    }\n                    if ($volume->mount($o)) {\n                        // unique volume id (ends on \"_\") - used as prefix to files hash\n                        $id = $volume->id();\n\n                        $this->volumes[$id] = $volume;\n                        if ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n                            $this->default = $volume;\n                        }\n                    } else {\n                        if (!empty($o['_isNetVolume'])) {\n                            $this->removeNetVolume($i, $volume);\n                        }\n                        $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . implode(' ', $volume->error());\n                    }\n                } catch (Exception $e) {\n                    if (!empty($o['_isNetVolume'])) {\n                        $this->removeNetVolume($i, $volume);\n                    }\n                    $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . $e->getMessage();\n                }\n            } else {\n                if (!empty($o['_isNetVolume'])) {\n                    $this->removeNetVolume($i, $volume);\n                }\n                $this->mountErrors[] = 'Driver \"' . $class . '\" does not exist';\n            }\n        }\n\n        // if at least one readable volume - ii desu >_<\n        $this->loaded = !empty($this->default);\n\n        // restore error handler for now\n        restore_error_handler();\n    }\n\n    /**\n     * Return elFinder session wrapper instance\n     *\n     * @return  elFinderSessionInterface\n     **/\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Return true if fm init correctly\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function loaded()\n    {\n        return $this->loaded;\n    }\n\n    /**\n     * Return version (api) number\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function version()\n    {\n        return self::$ApiVersion;\n    }\n\n    /**\n     * Return revision (api) number\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function revision()\n    {\n        return self::$ApiRevision;\n    }\n\n    /**\n     * Add handler to elFinder command\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function bind($cmd, $handler)\n    {\n        $allCmds = array_keys($this->commands);\n        $cmds = array();\n        foreach (explode(' ', $cmd) as $_cmd) {\n            if ($_cmd !== '') {\n                if ($all = strpos($_cmd, '*') !== false) {\n                    list(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n                    if ($sub) {\n                        $sub = str_replace('\\'', '\\\\\\'', $sub);\n                        $subs = array_fill(0, count($allCmds), $sub);\n                        $cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n                    } else {\n                        $cmds = array_merge($cmds, $allCmds);\n                    }\n                } else {\n                    $cmds[] = $_cmd;\n                }\n            }\n        }\n        $cmds = array_unique($cmds);\n\n        foreach ($cmds as $cmd) {\n            if (!isset($this->listeners[$cmd])) {\n                $this->listeners[$cmd] = array();\n            }\n\n            if (is_callable($handler)) {\n                $this->listeners[$cmd][] = $handler;\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Remove event (command exec) handler\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function unbind($cmd, $handler)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $i => $h) {\n                if ($h === $handler) {\n                    unset($this->listeners[$cmd][$i]);\n                    return $this;\n                }\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Trigger binded functions\n     *\n     * @param      string  $cmd     binded command name\n     * @param      array   $vars    variables to pass to listeners\n     * @param      array   $errors  array into which the error is written\n     */\n    public function trigger($cmd, $vars, &$errors)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                $_res = call_user_func_array($handler, $vars);\n                if ($_res && is_array($_res)) {\n                    $_err = !empty($_res['error'])? $_res['error'] : (!empty($_res['warning'])? $_res['warning'] : null);\n                    if ($_err) {\n                        if (is_array($_err)) {\n                            $errors = array_merge($errors, $_err);\n                        } else {\n                            $errors[] = (string)$_err;\n                        }\n                        if ($_res['error']) {\n                            throw new elFinderTriggerException();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Return true if command exists\n     *\n     * @param  string  command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandExists($cmd)\n    {\n        return $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n    }\n\n    /**\n     * Return root - file's owner (public func of volume())\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver\n     * @author Naoki Sawada\n     */\n    public function getVolume($hash)\n    {\n        return $this->volume($hash);\n    }\n\n    /**\n     * Return command required arguments info\n     *\n     * @param  string  command name\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandArgsList($cmd)\n    {\n        if ($this->commandExists($cmd)) {\n            $list = $this->commands[$cmd];\n            $list['reqid'] = false;\n        } else {\n            $list = array();\n        }\n        return $list;\n    }\n\n    private function session_expires()\n    {\n\n        if (!$last = $this->session->get(':LAST_ACTIVITY')) {\n            $this->session->set(':LAST_ACTIVITY', time());\n            return false;\n        }\n\n        if (($this->timeout > 0) && (time() - $last > $this->timeout)) {\n            return true;\n        }\n\n        $this->session->set(':LAST_ACTIVITY', time());\n        return false;\n    }\n\n    /**\n     * Exec command and return result\n     *\n     * @param  string $cmd  command name\n     * @param  array  $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException|Exception\n     * @author Dmitry (dio) Levashov\n     **/\n    public function exec($cmd, $args)\n    {\n        // set error handler of WARNING, NOTICE\n        set_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\n        // set current request args\n        self::$currentArgs = $args;\n\n        if (!$this->loaded) {\n            return array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n        }\n\n        if ($this->session_expires()) {\n            return array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n        }\n\n        if (!$this->commandExists($cmd)) {\n            return array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n        }\n\n        // check request id\n        $args['reqid'] = preg_replace('[^0-9a-fA-F]', '', !empty($args['reqid']) ? $args['reqid'] : (!empty($_SERVER['HTTP_X_ELFINDERREQID']) ? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\n        // to abort this request\n        if ($cmd === 'abort') {\n            $this->abort($args);\n            return array('error' => 0);\n        }\n\n        // make flag file and set self::$abortCheckFile\n        if ($args['reqid']) {\n            $this->abort(array('makeFile' => $args['reqid']));\n        }\n\n        if (!empty($args['mimes']) && is_array($args['mimes'])) {\n            foreach ($this->volumes as $id => $v) {\n                $this->volumes[$id]->setMimesFilter($args['mimes']);\n            }\n        }\n\n        // regist shutdown function as fallback\n        register_shutdown_function(array($this, 'itemAutoUnlock'));\n\n        // detect destination dirHash and volume\n        $dstVolume = false;\n        $dst = !empty($args['target']) ? $args['target'] : (!empty($args['dst']) ? $args['dst'] : '');\n        if ($dst) {\n            $dstVolume = $this->volume($dst);\n        } else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n            $dst = $args['targets'][0];\n            $dstVolume = $this->volume($dst);\n            if ($dstVolume && ($_stat = $dstVolume->file($dst)) && !empty($_stat['phash'])) {\n                $dst = $_stat['phash'];\n            } else {\n                $dst = '';\n            }\n        } else if ($cmd === 'open') {\n            // for initial open without args `target`\n            $dstVolume = $this->default;\n            $dst = $dstVolume->defaultPath();\n        }\n\n        $result = null;\n\n        // call pre handlers for this command\n        $args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd]) ? false : $this->sessionCloseEarlier;\n        if (!empty($this->listeners[$cmd . '.pre'])) {\n            foreach ($this->listeners[$cmd . '.pre'] as $handler) {\n                $_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n                if (is_array($_res)) {\n                    if (!empty($_res['preventexec'])) {\n                        $result = array('error' => true);\n                        if ($cmd === 'upload' && !empty($args['node'])) {\n                            $result['callback'] = array(\n                                'node' => $args['node'],\n                                'bind' => $cmd\n                            );\n                        }\n                        if (!empty($_res['results']) && is_array($_res['results'])) {\n                            $result = array_merge($result, $_res['results']);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        // unlock session data for multiple access\n        if ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n            $this->session->close();\n            // deprecated property\n            elFinder::$sessionClosed = true;\n        }\n\n        if (substr(PHP_OS, 0, 3) === 'WIN') {\n            // set time out\n            elFinder::extendTimeLimit(300);\n        }\n\n        if (!is_array($result)) {\n            try {\n                $result = $this->$cmd($args);\n            } catch (elFinderAbortException $e) {\n                throw $e;\n            } catch (Exception $e) {\n                $result = array(\n                    'error' => htmlspecialchars($e->getMessage()),\n                    'sync' => true\n                );\n                if ($this->throwErrorOnExec) {\n                    throw $e;\n                }\n            }\n        }\n\n        // check change dstDir\n        $changeDst = false;\n        if ($dst && $dstVolume && (!empty($result['added']) || !empty($result['removed']))) {\n            $changeDst = true;\n        }\n\n        foreach ($this->volumes as $volume) {\n            $removed = $volume->removed();\n            if (!empty($removed)) {\n                if (!isset($result['removed'])) {\n                    $result['removed'] = array();\n                }\n                $result['removed'] = array_merge($result['removed'], $removed);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $added = $volume->added();\n            if (!empty($added)) {\n                if (!isset($result['added'])) {\n                    $result['added'] = array();\n                }\n                $result['added'] = array_merge($result['added'], $added);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $volume->resetResultStat();\n        }\n\n        // dstDir is changed\n        if ($changeDst) {\n            if ($dstDir = $dstVolume->dir($dst)) {\n                if (!isset($result['changed'])) {\n                    $result['changed'] = array();\n                }\n                $result['changed'][] = $dstDir;\n            }\n        }\n\n        // call handlers for this command\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                if (call_user_func_array($handler, array($cmd, &$result, $args, $this, $dstVolume))) {\n                    // handler return true to force sync client after command completed\n                    $result['sync'] = true;\n                }\n            }\n        }\n\n        // replace removed files info with removed files hashes\n        if (!empty($result['removed'])) {\n            $removed = array();\n            foreach ($result['removed'] as $file) {\n                $removed[] = $file['hash'];\n            }\n            $result['removed'] = array_unique($removed);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['added'])) {\n            $result['added'] = $this->filter($result['added']);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['changed'])) {\n            $result['changed'] = $this->filter($result['changed']);\n        }\n        // add toasts\n        if ($this->toastMessages) {\n            $result['toasts'] = array_merge(((isset($result['toasts']) && is_array($result['toasts']))? $result['toasts'] : array()), $this->toastMessages);\n        }\n\n        if ($this->debug || !empty($args['debug'])) {\n            $result['debug'] = array(\n                'connector' => 'php',\n                'phpver' => PHP_VERSION,\n                'time' => $this->utime() - $this->time,\n                'memory' => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage() / 1024) . 'Kb / ' : '') . ceil(memory_get_usage() / 1024) . 'Kb / ' . ini_get('memory_limit'),\n                'upload' => $this->uploadDebug,\n                'volumes' => array(),\n                'mountErrors' => $this->mountErrors\n            );\n\n            foreach ($this->volumes as $id => $volume) {\n                $result['debug']['volumes'][] = $volume->debug();\n            }\n        }\n\n        // remove sesstion var 'urlContentSaveIds'\n        if ($this->removeContentSaveIds) {\n            $urlContentSaveIds = $this->session->get('urlContentSaveIds', array());\n            foreach (array_keys($this->removeContentSaveIds) as $contentSaveId) {\n                if (isset($urlContentSaveIds[$contentSaveId])) {\n                    unset($urlContentSaveIds[$contentSaveId]);\n                }\n            }\n            if ($urlContentSaveIds) {\n                $this->session->set('urlContentSaveIds', $urlContentSaveIds);\n            } else {\n                $this->session->remove('urlContentSaveIds');\n            }\n        }\n\n        foreach ($this->volumes as $volume) {\n            $volume->saveSessionCache();\n            $volume->umount();\n        }\n\n        // unlock locked items\n        $this->itemAutoUnlock();\n\n        // custom data\n        if ($this->customData !== null) {\n            $result['customData'] = $this->customData ? json_encode($this->customData) : '';\n        }\n\n        if (!empty($result['debug'])) {\n            $result['debug']['backendErrors'] = elFinder::$phpErrors;\n        }\n        elFinder::$phpErrors = array();\n        restore_error_handler();\n\n        if (!empty($result['callback'])) {\n            $result['callback']['json'] = json_encode($result);\n            $this->callback($result['callback']);\n            return array();\n        } else {\n            return $result;\n        }\n    }\n\n    /**\n     * Return file real path\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        if (($volume = $this->volume($hash)) == false) {\n            return false;\n        }\n        return $volume->realpath($hash);\n    }\n\n    /**\n     * Sets custom data(s).\n     *\n     * @param  string|array $key The key or data array\n     * @param  mixed        $val The value\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function setCustomData($key, $val = null)\n    {\n        if (is_array($key)) {\n            foreach ($key as $k => $v) {\n                $this->customData[$k] = $v;\n            }\n        } else {\n            $this->customData[$key] = $val;\n        }\n        return $this;\n    }\n\n    /**\n     * Removes a custom data.\n     *\n     * @param  string $key The key\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function removeCustomData($key)\n    {\n        $this->customData[$key] = null;\n        return $this;\n    }\n\n    /**\n     * Update sesstion value of a NetVolume option\n     *\n     * @param string $netKey\n     * @param string $optionKey\n     * @param mixed  $val\n     *\n     * @return bool\n     */\n    public function updateNetVolumeOption($netKey, $optionKey, $val)\n    {\n        $netVolumes = $this->getNetVolumes();\n        if (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n            $netVolumes[$netKey][$optionKey] = $val;\n            $this->saveNetVolumes($netVolumes);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * remove of session var \"urlContentSaveIds\"\n     *\n     * @param string $id\n     */\n    public function removeUrlContentSaveId($id)\n    {\n        $this->removeContentSaveIds[$id] = true;\n    }\n\n    /**\n     * Return network volumes config.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function getNetVolumes()\n    {\n        if ($data = $this->session->get('netvolume', array())) {\n            return $data;\n        }\n        return array();\n    }\n\n    /**\n     * Save network volumes config.\n     *\n     * @param  array $volumes volumes config\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function saveNetVolumes($volumes)\n    {\n        $this->session->set('netvolume', $volumes);\n    }\n\n    /**\n     * Remove netmount volume\n     *\n     * @param string $key    netvolume key\n     * @param object $volume volume driver instance\n     *\n     * @return bool\n     */\n    protected function removeNetVolume($key, $volume)\n    {\n        $netVolumes = $this->getNetVolumes();\n        $res = true;\n        if (is_object($volume) && method_exists($volume, 'netunmount')) {\n            $res = $volume->netunmount($netVolumes, $key);\n            $volume->clearSessionCache();\n        }\n        if ($res) {\n            if (is_string($key) && isset($netVolumes[$key])) {\n                unset($netVolumes[$key]);\n                $this->saveNetVolumes($netVolumes);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get plugin instance & set to $this->plugins\n     *\n     * @param  string $name Plugin name (dirctory name)\n     * @param  array  $opts Plugin options (optional)\n     *\n     * @return object | bool Plugin object instance Or false\n     * @author Naoki Sawada\n     */\n    protected function getPluginInstance($name, $opts = array())\n    {\n        $key = strtolower($name);\n        if (!isset($this->plugins[$key])) {\n            $class = 'elFinderPlugin' . $name;\n            // to try auto load\n            if (!class_exists($class)) {\n                $p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n                if (is_file($p_file)) {\n                    include_once $p_file;\n                }\n            }\n            if (class_exists($class, false)) {\n                $this->plugins[$key] = new $class($opts);\n            } else {\n                $this->plugins[$key] = false;\n            }\n        }\n        return $this->plugins[$key];\n    }\n\n    /***************************************************************************/\n    /*                                 commands                                */\n    /***************************************************************************/\n\n    /**\n     * Normalize error messages\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        $errors = array();\n\n        foreach (func_get_args() as $msg) {\n            if (is_array($msg)) {\n                $errors = array_merge($errors, $msg);\n            } else {\n                $errors[] = $msg;\n            }\n        }\n\n        return count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n    }\n\n    /**\n     * @param $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function netmount($args)\n    {\n        $options = array();\n        $protocol = $args['protocol'];\n        $toast = '';\n\n        if ($protocol === 'netunmount') {\n            if (!empty($args['user']) && $volume = $this->volume($args['user'])) {\n                if ($this->removeNetVolume($args['host'], $volume)) {\n                    return array('removed' => array(array('hash' => $volume->root())));\n                }\n            }\n            return array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n        }\n\n        $driver = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n        $class = 'elFinderVolume' . $driver;\n\n        if (!class_exists($class)) {\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n        }\n\n        if (!$args['path']) {\n            $args['path'] = '/';\n        }\n\n        foreach ($args as $k => $v) {\n            if ($k != 'options' && $k != 'protocol' && $v) {\n                $options[$k] = $v;\n            }\n        }\n\n        if (is_array($args['options'])) {\n            foreach ($args['options'] as $key => $value) {\n                $options[$key] = $value;\n            }\n        }\n\n        /* @var elFinderVolumeDriver $volume */\n        $volume = new $class();\n\n        // pass session handler\n        $volume->setSession($this->session);\n\n        $volume->setNeedOnline(true);\n\n        if (is_callable(array($volume, 'netmountPrepare'))) {\n            $options = $volume->netmountPrepare($options);\n            if (isset($options['exit'])) {\n                if ($options['exit'] === 'callback') {\n                    $this->callback($options['out']);\n                }\n                return $options;\n            }\n            if (!empty($options['toast'])) {\n                $toast = $options['toast'];\n                unset($options['toast']);\n            }\n        }\n\n        $netVolumes = $this->getNetVolumes();\n\n        if (!isset($options['id'])) {\n            // given fixed unique id\n            if (!$options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n            }\n        }\n\n        // load additional volume root options\n        if (!empty($this->optionsNetVolumes['*'])) {\n            $options = array_merge($this->optionsNetVolumes['*'], $options);\n        }\n        if (!empty($this->optionsNetVolumes[$protocol])) {\n            $options = array_merge($this->optionsNetVolumes[$protocol], $options);\n        }\n\n        if (!$key = $volume->netMountKey) {\n            $key = md5($protocol . '-' . serialize($options));\n        }\n        $options['netkey'] = $key;\n\n        if (!isset($netVolumes[$key]) && $volume->mount($options)) {\n            // call post-process function of netmount\n            if (is_callable(array($volume, 'postNetmount'))) {\n                $volume->postNetmount($options);\n            }\n            $options['driver'] = $driver;\n            $netVolumes[$key] = $options;\n            $this->saveNetVolumes($netVolumes);\n            $rootstat = $volume->file($volume->root());\n            $res = array('added' => array($rootstat));\n            if ($toast) {\n                $res['toast'] = $toast;\n            }\n            return $res;\n        } else {\n            $this->removeNetVolume(null, $volume);\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n        }\n    }\n\n    /**\n     * \"Open\" directory\n     * Return array with following elements\n     *  - cwd          - opened dir info\n     *  - files        - opened dir content [and dirs tree if $args[tree]]\n     *  - api          - api version (if $args[init])\n     *  - uplMaxSize   - if $args[init]\n     *  - error        - on failed\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function open($args)\n    {\n        $target = $args['target'];\n        $init = !empty($args['init']);\n        $tree = !empty($args['tree']);\n        $volume = $this->volume($target);\n        $cwd = $volume ? $volume->dir($target) : false;\n        $hash = $init ? 'default folder' : '#' . $target;\n        $compare = '';\n\n        // on init request we can get invalid dir hash -\n        // dir which can not be opened now, but remembered by client,\n        // so open default dir\n        if ((!$cwd || !$cwd['read']) && $init) {\n            $volume = $this->default;\n            $target = $volume->defaultPath();\n            $cwd = $volume->dir($target);\n        }\n\n        if (!$cwd) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n        }\n        if (!$cwd['read']) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n        }\n\n        $files = array();\n\n        // get current working directory files list\n        if (($ls = $volume->scandir($cwd['hash'])) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n        }\n\n        if (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n            $cwd = $volume->dir($target);\n        }\n\n        // get other volume root\n        if ($tree) {\n            foreach ($this->volumes as $id => $v) {\n                $files[] = $v->file($v->root());\n            }\n        }\n\n        // long polling mode\n        if ($args['compare']) {\n            $sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n            $standby = (int)$volume->getOption('plStandby');\n            if ($standby > 0 && $sleep > $standby) {\n                $standby = $sleep;\n            }\n            $limit = max(0, floor($standby / $sleep)) + 1;\n            do {\n                elFinder::extendTimeLimit(30 + $sleep);\n                $_mtime = 0;\n                foreach ($ls as $_f) {\n                    if (isset($_f['ts'])) {\n                        $_mtime = max($_mtime, $_f['ts']);\n                    }\n                }\n                $compare = strval(count($ls)) . ':' . strval($_mtime);\n                if ($compare !== $args['compare']) {\n                    break;\n                }\n                if (--$limit) {\n                    sleep($sleep);\n                    $volume->clearstatcache();\n                    if (($ls = $volume->scandir($cwd['hash'])) === false) {\n                        break;\n                    }\n                }\n            } while ($limit);\n            if ($ls === false) {\n                return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n            }\n        }\n\n        if ($ls) {\n            if ($files) {\n                $files = array_merge($files, $ls);\n            } else {\n                $files = $ls;\n            }\n        }\n\n        $result = array(\n            'cwd' => $cwd,\n            'options' => $volume->options($cwd['hash']),\n            'files' => $files\n        );\n\n        if ($compare) {\n            $result['cwd']['compare'] = $compare;\n        }\n\n        if (!empty($args['init'])) {\n            $result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n            $result['uplMaxSize'] = ini_get('upload_max_filesize');\n            $result['uplMaxFile'] = ini_get('max_file_uploads');\n            $result['netDrivers'] = array_keys(self::$netDrivers);\n            $result['maxTargets'] = $this->maxTargets;\n            if ($volume) {\n                $result['cwd']['root'] = $volume->root();\n            }\n            if (elfinder::$textMimes) {\n                $result['textMimes'] = elfinder::$textMimes;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function ls($args)\n    {\n        $target = $args['target'];\n        $intersect = isset($args['intersect']) ? $args['intersect'] : array();\n\n        if (($volume = $this->volume($target)) == false\n            || ($list = $volume->ls($target, $intersect)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n        return array('list' => $list);\n    }\n\n    /**\n     * Return subdirs for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tree($args)\n    {\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->tree($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return parents dir for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function parents($args)\n    {\n        $target = $args['target'];\n        $until = $args['until'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->parents($target, false, $until)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return new created thumbnails list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function tmb($args)\n    {\n\n        $result = array('images' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) != false\n                && (($tmb = $volume->tmb($target)) != false)) {\n                $result['images'][$target] = $tmb;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Download files/folders as an archive file\n     * 1st: Return srrsy contains download archive file info\n     * 2nd: Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function zipdl($args)\n    {\n        $targets = $args['targets'];\n        $download = !empty($args['download']);\n        $h404 = 'HTTP/1.x 404 Not Found';\n        $CriOS = isset($_SERVER['HTTP_USER_AGENT'])? (strpos($_SERVER['HTTP_USER_AGENT'], 'CriOS') !== false) : false;\n\n        if (!$download) {\n            //1st: Return array contains download archive file info\n            $error = array(self::ERROR_ARCHIVE);\n            if (($volume = $this->volume($targets[0])) !== false) {\n                if ($dlres = $volume->zipdl($targets)) {\n                    $path = $dlres['path'];\n                    register_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n                    if (count($targets) === 1) {\n                        $name = basename($volume->path($targets[0]));\n                    } else {\n                        $name = $dlres['prefix'] . '_Files';\n                    }\n                    $name .= '.' . $dlres['ext'];\n                    $uniqid = uniqid();\n                    $this->session->set('zipdl' . $uniqid, basename($path));\n                    $result = array(\n                        'zipdl' => array(\n                            'file' => $CriOS? basename($path) : $uniqid,\n                            'name' => $name,\n                            'mime' => $dlres['mime']\n                        )\n                    );\n                    return $result;\n                }\n                $error = array_merge($error, $volume->error());\n            }\n            return array('error' => $error);\n        } else {\n            // 2nd: Return array contains opened file session key, root itself and required headers\n\n            // Detect Chrome on iOS\n            // It has access twice on downloading\n            $CriOSinit = false;\n            if ($CriOS) {\n                $accept = isset($_SERVER['HTTP_ACCEPT'])? $_SERVER['HTTP_ACCEPT'] : '';\n                if ($accept && $accept !== '*' && $accept !== '*/*') {\n                    $CriOSinit = true;\n                }\n            }\n            // data check\n            if (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false || !($file = $CriOS? $targets[1] : $this->session->get('zipdl' . $targets[1]))) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $path = $volume->getTempPath() . DIRECTORY_SEPARATOR . basename($file);\n            // remove session data of \"zipdl...\"\n            $this->session->remove('zipdl' . $targets[1]);\n            if (!$CriOSinit) {\n                // register auto delete on shutdown\n                $GLOBALS['elFinderTempFiles'][$path] = true;\n            }\n            if ($volume->commandDisabled('zipdl')) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            if (!is_readable($path) || !is_writable($path)) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            // for HTTP headers\n            $name = $targets[2];\n            $mime = $targets[3];\n\n            $filenameEncoded = rawurlencode($name);\n            if (strpos($filenameEncoded, '%') === false) { // ASCII only\n                $filename = 'filename=\"' . $name . '\"';\n            } else {\n                $ua = $_SERVER['HTTP_USER_AGENT'];\n                if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename=\"' . $filenameEncoded . '\"';\n                } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                    $filename = 'filename=\"' . str_replace('\"', '', $name) . '\"';\n                } else { // RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n                }\n            }\n\n            $fp = fopen($path, 'rb');\n            $file = fstat($fp);\n            $result = array(\n                'pointer' => $fp,\n                'header' => array(\n                    'Content-Type: ' . $mime,\n                    'Content-Disposition: attachment; ' . $filename,\n                    'Content-Transfer-Encoding: binary',\n                    'Content-Length: ' . $file['size'],\n                    'Accept-Ranges: none',\n                    'Connection: close'\n                )\n            );\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n            return $result;\n        }\n    }\n\n    /**\n     * Required to output file in browser when volume URL is not set\n     * Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function file($args)\n    {\n        $target = $args['target'];\n        $download = !empty($args['download']);\n        $onetime = !empty($args['onetime']);\n        //$h304     = 'HTTP/1.1 304 Not Modified';\n        $h403 = 'HTTP/1.0 403 Access Denied';\n        $a403 = array('error' => 'Access Denied', 'header' => $h403, 'raw' => true);\n        $h404 = 'HTTP/1.0 404 Not Found';\n        $a404 = array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\n        if ($onetime) {\n            $volume = null;\n            $tmpdir = elFinder::$commonTempPath;\n            if (!$tmpdir || !is_file($tmpf = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $target)) {\n                return $a404;\n            }\n            $GLOBALS['elFinderTempFiles'][$tmpf] = true;\n            if ($file = json_decode(file_get_contents($tmpf), true)) {\n                $src = base64_decode($file['file']);\n                if (!is_file($src) || !($fp = fopen($src, 'rb'))) {\n                    return $a404;\n                }\n                if (strpos($src, $tmpdir) === 0) {\n                    $GLOBALS['elFinderTempFiles'][$src] = true;\n                }\n                unset($file['file']);\n                $file['read'] = true;\n                $file['size'] = filesize($src);\n            } else {\n                return $a404;\n            }\n        } else {\n            if (($volume = $this->volume($target)) == false) {\n                return $a404;\n            }\n\n            if ($volume->commandDisabled('file')) {\n                return $a403;\n            }\n\n            if (($file = $volume->file($target)) == false) {\n                return $a404;\n            }\n\n            if (!$file['read']) {\n                return $a404;\n            }\n\n            $opts = array();\n            if (!empty($_SERVER['HTTP_RANGE'])) {\n                $opts['httpheaders'] = array('Range: ' . $_SERVER['HTTP_RANGE']);\n            }\n            if (($fp = $volume->open($target, $opts)) == false) {\n                return $a404;\n            }\n        }\n\n        // check aborted by user\n        elFinder::checkAborted();\n\n        // allow change MIME type by 'file.pre' callback functions\n        $mime = isset($args['mime']) ? $args['mime'] : $file['mime'];\n        if ($download || $onetime) {\n            $disp = 'attachment';\n        } else {\n            $dispInlineRegex = $volume->getOption('dispInlineRegex');\n            $inlineRegex = false;\n            if ($dispInlineRegex) {\n                $inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n                try {\n                    preg_match($inlineRegex, '');\n                } catch (Exception $e) {\n                    $inlineRegex = false;\n                }\n            }\n            if (!$inlineRegex) {\n                $inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n            }\n            $disp = preg_match($inlineRegex, $mime) ? 'inline' : 'attachment';\n        }\n\n        $filenameEncoded = rawurlencode($file['name']);\n        if (strpos($filenameEncoded, '%') === false) { // ASCII only\n            $filename = 'filename=\"' . $file['name'] . '\"';\n        } else {\n            $ua = isset($_SERVER['HTTP_USER_AGENT'])? $_SERVER['HTTP_USER_AGENT'] : '';\n            if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename=\"' . $filenameEncoded . '\"';\n            } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                $filename = 'filename=\"' . str_replace('\"', '', $file['name']) . '\"';\n            } else { // RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n            }\n        }\n\n        if ($args['cpath'] && $args['reqid']) {\n            setcookie('elfdl' . $args['reqid'], '1', 0, $args['cpath']);\n        }\n\n        $result = array(\n            'volume' => $volume,\n            'pointer' => $fp,\n            'info' => $file,\n            'header' => array(\n                'Content-Type: ' . $mime,\n                'Content-Disposition: ' . $disp . '; ' . $filename,\n                'Content-Transfer-Encoding: binary',\n                'Content-Length: ' . $file['size'],\n                'Last-Modified: ' . gmdate('D, d M Y H:i:s T', $file['ts']),\n                'Connection: close'\n            )\n        );\n\n        if (!$onetime) {\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n\n            // check 'xsendfile'\n            $xsendfile = $volume->getOption('xsendfile');\n            $path = null;\n            if ($xsendfile) {\n                $info = stream_get_meta_data($fp);\n                if ($path = empty($info['uri']) ? null : $info['uri']) {\n                    $basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n                    if ($basePath) {\n                        $root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n                        if (strpos($path, $root) === 0) {\n                            $path = $basePath . substr($path, strlen($root));\n                        } else {\n                            $path = null;\n                        }\n                    }\n                }\n            }\n            if ($path) {\n                $result['header'][] = $xsendfile . ': ' . $path;\n                $result['info']['xsendfile'] = $xsendfile;\n            }\n        }\n\n        // add \"Content-Location\" if file has url data\n        if (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n            $result['header'][] = 'Content-Location: ' . $file['url'];\n        }\n        return $result;\n    }\n\n    /**\n     * Count total files size\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function size($args)\n    {\n        $size = 0;\n        $files = 0;\n        $dirs = 0;\n        $itemCount = true;\n        $sizes = array();\n\n        foreach ($args['targets'] as $target) {\n            elFinder::checkAborted();\n            if (($volume = $this->volume($target)) == false\n                || ($file = $volume->file($target)) == false\n                || !$file['read']) {\n                return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n            }\n\n            $volRes = $volume->size($target);\n            if (is_array($volRes)) {\n                $sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n                if (!empty($volRes['size'])) {\n                    $sizeInfo['size'] = $volRes['size'];\n                    $size += $volRes['size'];\n                }\n                if (!empty($volRes['files'])) {\n                    $sizeInfo['fileCnt'] = $volRes['files'];\n                }\n                if (!empty($volRes['dirs'])) {\n                    $sizeInfo['dirCnt'] = $volRes['dirs'];\n                }\n                if ($itemCount) {\n                    $files += $sizeInfo['fileCnt'];\n                    $dirs += $sizeInfo['dirCnt'];\n                }\n                $sizes[$target] = $sizeInfo;\n            } else if (is_numeric($volRes)) {\n                $size += $volRes;\n                $files = $dirs = 'unknown';\n                $itemCount = false;\n            }\n        }\n        return array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n    }\n\n    /**\n     * Create directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkdir($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $dirs = $args['dirs'];\n        if ($name === '' && !$dirs) {\n            return array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n        }\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n        if ($dirs) {\n            $maxDirs = $volume->getOption('uploadMaxMkdirs');\n            if ($maxDirs && $maxDirs < count($dirs)) {\n                return array('error' => $this->error(self::ERROR_MAX_MKDIRS, $maxDirs));\n            }\n            sort($dirs);\n            $reset = null;\n            $mkdirs = array();\n            foreach ($dirs as $dir) {\n                $tgt =& $mkdirs;\n                $_names = explode('/', trim($dir, '/'));\n                foreach ($_names as $_key => $_name) {\n                    if (!isset($tgt[$_name])) {\n                        $tgt[$_name] = array();\n                    }\n                    $tgt =& $tgt[$_name];\n                }\n                $tgt =& $reset;\n            }\n            $res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n            $ret = array(\n                'added' => $res['stats'],\n                'hashes' => $res['hashes']\n            );\n            if ($res['error']) {\n                $ret['warning'] = $this->error(self::ERROR_MKDIR, $res['error'][0], $volume->error());\n            }\n            return $ret;\n        } else {\n            return ($dir = $volume->mkdir($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n                : array('added' => array($dir));\n        }\n    }\n\n    /**\n     * Create empty file\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkfile($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n\n        return ($file = $volume->mkfile($target, $args['name'])) == false\n            ? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n            : array('added' => array($file));\n    }\n\n    /**\n     * Rename file, Accept multiple items >= API 2.1031\n     *\n     * @param  array $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function rename($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $query = (!empty($args['q']) && strpos($args['q'], '*') !== false) ? $args['q'] : '';\n        $targets = !empty($args['targets'])? $args['targets'] : false;\n        $rms = array();\n        $notfounds = array();\n        $locked = array();\n        $errs = array();\n        $files = array();\n        $removed = array();\n        $res = array();\n        $type = 'normal';\n\n        if (!($volume = $this->volume($target))) {\n            return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($targets) {\n            array_unshift($targets, $target);\n            foreach ($targets as $h) {\n                if ($rm = $volume->file($h)) {\n                    if ($this->itemLocked($h)) {\n                        $locked[] = $rm['name'];\n                    } else {\n                        $rm['realpath'] = $volume->realpath($h);\n                        $rms[] = $rm;\n                    }\n                } else {\n                    $notfounds[] = '#' . $h;\n                }\n            }\n            if (!$rms) {\n                $res['error'] = array();\n                if ($notfounds) {\n                    $res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n                }\n                if ($locked) {\n                    array_push($res['error'], self::ERROR_LOCKED, join(', ', $locked));\n                }\n                return $res;\n            }\n\n            $res['warning'] = array();\n            if ($notfounds) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n            }\n            if ($locked) {\n                array_push($res['warning'], self::ERROR_LOCKED, join(', ', $locked));\n            }\n\n            if ($query) {\n                // batch rename\n                $splits = elFinder::splitFileExtention($query);\n                if ($splits[1] && $splits[0] === '*') {\n                    $type = 'extention';\n                    $name = $splits[1];\n                } else if (strlen($splits[0]) > 1) {\n                    if (substr($splits[0], -1) === '*') {\n                        $type = 'prefix';\n                        $name = substr($splits[0], 0, strlen($splits[0]) - 1);\n                    } else if (substr($splits[0], 0, 1) === '*') {\n                        $type = 'suffix';\n                        $name = substr($splits[0], 1);\n                    }\n                }\n                if ($type !== 'normal') {\n                    if (!empty($this->listeners['rename.pre'])) {\n                        $_args = array('name' => $name);\n                        foreach ($this->listeners['rename.pre'] as $handler) {\n                            $_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n                            if (!empty($_res['preventexec'])) {\n                                break;\n                            }\n                        }\n                        $name = $_args['name'];\n                    }\n                }\n            }\n            foreach ($rms as $rm) {\n                if ($type === 'normal') {\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n                } else {\n                    $rname = $name;\n                    if ($type === 'extention') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . '.' . $name;\n                    } else if ($type === 'prefix') {\n                        $rname = $name . $rm['name'];\n                    } else if ($type === 'suffix') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . $name . ($splits[1] ? ('.' . $splits[1]) : '');\n                    }\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n                }\n                if ($file = $volume->rename($rm['hash'], $rname)) {\n                    $files[] = $file;\n                    $removed[] = $rm;\n                } else {\n                    $errs[] = $rm['name'];\n                }\n            }\n\n            if (!$files) {\n                $res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n                if (!$res['warning']) {\n                    unset($res['warning']);\n                }\n                return $res;\n            }\n            if ($errs) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n            }\n            if (!$res['warning']) {\n                unset($res['warning']);\n            }\n            $res['added'] = $files;\n            $res['removed'] = $removed;\n            return $res;\n        } else {\n            if (!($rm = $volume->file($target))) {\n                return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n            }\n            if ($this->itemLocked($target)) {\n                return array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n            }\n            $rm['realpath'] = $volume->realpath($target);\n\n            $file = $volume->rename($target, $name);\n            if ($file === false) {\n                return array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()));\n            } else {\n                if ($file['hash'] !== $rm['hash']) {\n                    return array('added' => array($file), 'removed' => array($rm));\n                } else {\n                    return array('changed' => array($file));\n                }\n            }\n        }\n    }\n\n    /**\n     * Duplicate file - create copy with \"copy %d\" suffix\n     *\n     * @param array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function duplicate($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array();\n        $suffix = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\n        $this->itemLock($targets);\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false\n                || ($src = $volume->file($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_COPY, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if (($file = $volume->duplicate($target, $suffix)) == false) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Remove dirs/files\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function rm($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array('removed' => array());\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_RM, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if ($this->itemLocked($target)) {\n                $rm = $volume->file($target);\n                $result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n                break;\n            }\n\n            if (!$volume->rm($target)) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry Naoki Sawada\n     **/\n    protected function subdirs($args)\n    {\n\n        $result = array('subdirs' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            if (($volume = $this->volume($target)) !== false) {\n                $result['subdirs'][$target] = $volume->subdirs($target) ? 1 : 0;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Gateway for custom contents editor\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function editor($args = array())\n    {\n        /* @var elFinderEditor $editor */\n        $name = $args['name'];\n        if (is_array($name)) {\n            $res = array();\n            foreach ($name as $c) {\n                $class = 'elFinderEditor' . $c;\n                if (class_exists($class)) {\n                    $editor = new $class($this, $args['args']);\n                    $res[$c] = $editor->enabled();\n                } else {\n                    $res[$c] = 0;\n                }\n            }\n            return $res;\n        } else {\n            $class = 'elFinderEditor' . $name;\n            $method = '';\n            if (class_exists($class)) {\n                $editor = new $class($this, $args['args']);\n                $method = $args['method'];\n                if ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n                    return $editor->$method();\n                }\n            }\n            return array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.' . $name . '.' . $method));\n        }\n    }\n\n    /**\n     * Abort current request and make flag file to running check\n     *\n     * @param array $args\n     *\n     * @return void\n     */\n    protected function abort($args = array())\n    {\n        if (!elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n            return;\n        }\n        $flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n        if (!empty($args['makeFile'])) {\n            self::$abortCheckFile = sprintf($flagFile, $args['makeFile']);\n            touch(self::$abortCheckFile);\n            $GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n            return;\n        }\n\n        $file = !empty($args['id']) ? sprintf($flagFile, $args['id']) : self::$abortCheckFile;\n        $file && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Get remote contents\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $fp\n     *\n     * @return string, resource or bool(false)\n     * @retval  string contents\n     * @retval  resource conttents\n     * @rettval false  error\n     * @author  Naoki Sawada\n     **/\n    protected function get_remote_contents(&$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null)\n    {\n        if (preg_match('~^(?:ht|f)tps?://[-_.!\\~*\\'()a-z0-9;/?:\\@&=+\\$,%#\\*\\[\\]]+~i', $url)) {\n            $info = parse_url($url);\n            $host = trim(strtolower($info['host']), '.');\n            // do not support IPv6 address\n            if (preg_match('/^\\[.*\\]$/', $host)) {\n                return false;\n            }\n            // do not support non dot host\n            if (strpos($host, '.') === false) {\n                return false;\n            }\n            // do not support URL-encoded host\n            if (strpos($host, '%') !== false) {\n                return false;\n            }\n            // disallow including \"localhost\" and \"localdomain\"\n            if (preg_match('/\\b(?:localhost|localdomain)\\b/', $host)) {\n                return false;\n            }\n            // wildcard DNS (e.g xip.io)\n            if (preg_match('/0x[0-9a-f]+|[0-9]+(?:\\.(?:0x[0-9a-f]+|[0-9]+)){1,3}/', $host)) {\n                $host = gethostbyname($host);\n            }\n            // check IPv4 local loopback, private network and link local\n            if (preg_match('/^0x[0-9a-f]+|[0-9]+(?:\\.(?:0x[0-9a-f]+|[0-9]+)){1,3}$/', $host, $m)) {\n                $long = (int)sprintf('%u', ip2long($host));\n                if (!$long) {\n                    return false;\n                }\n                $local = (int)sprintf('%u', ip2long('127.255.255.255')) >> 24;\n                $prv1 = (int)sprintf('%u', ip2long('10.255.255.255')) >> 24;\n                $prv2 = (int)sprintf('%u', ip2long('172.31.255.255')) >> 20;\n                $prv3 = (int)sprintf('%u', ip2long('192.168.255.255')) >> 16;\n                $link = (int)sprintf('%u', ip2long('169.254.255.255')) >> 16;\n\n                if ($long >> 24 === $local || $long >> 24 === $prv1 || $long >> 20 === $prv2 || $long >> 16 === $prv3 || $long >> 16 === $link) {\n                    return false;\n                }\n            }\n            // dose not support 'user' and 'pass' for security reasons\n            $url = $info['scheme'].'://'.$host.(!empty($info['port'])? (':'.$info['port']) : '').$info['path'].(!empty($info['query'])? ('?'.$info['query']) : '').(!empty($info['fragment'])? ('#'.$info['fragment']) : '');\n            // check by URL upload filter\n            if ($this->urlUploadFilter && is_callable($this->urlUploadFilter)) {\n                if (!call_user_func_array($this->urlUploadFilter, array($url, $this))) {\n                    return false;\n                }\n            }\n            $method = (function_exists('curl_exec') && !ini_get('safe_mode') && !ini_get('open_basedir')) ? 'curl_get_contents' : 'fsock_get_contents';\n            return $this->$method($url, $timeout, $redirect_max, $ua, $fp);\n        }\n        return false;\n    }\n\n    /**\n     * Get remote contents with cURL\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @author Naoki Sawada\n     **/\n    protected function curl_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        if ($outfp) {\n            curl_setopt($ch, CURLOPT_FILE, $outfp);\n        } else {\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n        }\n        curl_setopt($ch, CURLOPT_LOW_SPEED_LIMIT, 1);\n        curl_setopt($ch, CURLOPT_LOW_SPEED_TIME, $timeout);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, $redirect_max);\n        curl_setopt($ch, CURLOPT_USERAGENT, $ua);\n        $result = curl_exec($ch);\n        $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);\n        curl_close($ch);\n        return $outfp ? $outfp : $result;\n    }\n\n    /**\n     * Get remote contents with fsockopen()\n     *\n     * @param  string   $url          url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function fsock_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $connect_timeout = 3;\n        $connect_try = 3;\n        $method = 'GET';\n        $readsize = 4096;\n        $ssl = '';\n\n        $getSize = null;\n        $headers = '';\n\n        $arr = parse_url($url);\n        if (!$arr) {\n            // Bad request\n            return false;\n        }\n        if ($arr['scheme'] === 'https') {\n            $ssl = 'ssl://';\n        }\n\n        // query\n        $arr['query'] = isset($arr['query']) ? '?' . $arr['query'] : '';\n        // port\n        $port = isset($arr['port']) ? $arr['port'] : '';\n        $arr['port'] = $port ? $port : ($ssl ? 443 : 80);\n\n        $url_base = $arr['scheme'] . '://' . $arr['host'] . ($port ? (':' . $port) : '');\n        $url_path = isset($arr['path']) ? $arr['path'] : '/';\n        $uri = $url_path . $arr['query'];\n\n        $query = $method . ' ' . $uri . \" HTTP/1.0\\r\\n\";\n        $query .= \"Host: \" . $arr['host'] . \"\\r\\n\";\n        $query .= \"Accept: */*\\r\\n\";\n        $query .= \"Connection: close\\r\\n\";\n        if (!empty($ua)) $query .= \"User-Agent: \" . $ua . \"\\r\\n\";\n        if (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\n        $query .= $headers;\n\n        $query .= \"\\r\\n\";\n\n        $fp = $connect_try_count = 0;\n        while (!$fp && $connect_try_count < $connect_try) {\n\n            $errno = 0;\n            $errstr = \"\";\n            $fp = fsockopen(\n                $ssl . $arr['host'],\n                $arr['port'],\n                $errno, $errstr, $connect_timeout);\n            if ($fp) break;\n            $connect_try_count++;\n            if (connection_aborted()) {\n                throw new elFinderAbortException();\n            }\n            sleep(1); // wait 1sec\n        }\n\n        if (!$fp) {\n            return false;\n        }\n\n        $fwrite = 0;\n        for ($written = 0; $written < strlen($query); $written += $fwrite) {\n            $fwrite = fwrite($fp, substr($query, $written));\n            if (!$fwrite) {\n                break;\n            }\n        }\n\n        if ($timeout) {\n            socket_set_timeout($fp, $timeout);\n        }\n\n        $_response = '';\n        $header = '';\n        while ($_response !== \"\\r\\n\") {\n            $_response = fgets($fp, $readsize);\n            $header .= $_response;\n        };\n\n        $rccd = array_pad(explode(' ', $header, 2), 2, ''); // array('HTTP/1.1','200')\n        $rc = (int)$rccd[1];\n\n        $ret = false;\n        // Redirect\n        switch ($rc) {\n            case 307: // Temporary Redirect\n            case 303: // See Other\n            case 302: // Moved Temporarily\n            case 301: // Moved Permanently\n                $matches = array();\n                if (preg_match('/^Location: (.+?)(#.+)?$/im', $header, $matches) && --$redirect_max > 0) {\n                    $_url = $url;\n                    $url = trim($matches[1]);\n                    if (!preg_match('/^https?:\\//', $url)) { // no scheme\n                        if ($url[0] != '/') { // Relative path\n                            // to Absolute path\n                            $url = substr($url_path, 0, strrpos($url_path, '/')) . '/' . $url;\n                        }\n                        // add sheme,host\n                        $url = $url_base . $url;\n                    }\n                    if ($_url === $url) {\n                        sleep(1);\n                    }\n                    fclose($fp);\n                    return $this->fsock_get_contents($url, $timeout, $redirect_max, $ua, $outfp);\n                }\n                break;\n            case 200:\n                $ret = true;\n        }\n        if (!$ret) {\n            fclose($fp);\n            return false;\n        }\n\n        $body = '';\n        if (!$outfp) {\n            $outfp = fopen('php://temp', 'rwb');\n            $body = true;\n        }\n        while (fwrite($outfp, fread($fp, $readsize))) {\n            if ($timeout) {\n                $_status = socket_get_status($fp);\n                if ($_status['timed_out']) {\n                    fclose($outfp);\n                    fclose($fp);\n                    return false; // Request Time-out\n                }\n            }\n        }\n        if ($body) {\n            rewind($outfp);\n            $body = stream_get_contents($outfp);\n            fclose($outfp);\n            $outfp = null;\n        }\n\n        fclose($fp);\n\n        return $outfp ? $outfp : $body; // Data\n    }\n\n    /**\n     * Parse Data URI scheme\n     *\n     * @param  string $str\n     * @param  array  $extTable\n     * @param  array  $args\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function parse_data_scheme($str, $extTable, $args = null)\n    {\n        $data = $name = $mime = '';\n        // Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n        if ($fp = fopen('data://' . substr($str, 5), 'rb')) {\n            if ($data = stream_get_contents($fp)) {\n                $meta = stream_get_meta_data($fp);\n                $mime = $meta['mediatype'];\n            }\n            fclose($fp);\n        } else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n            $data = base64_decode(substr($str, strlen($m[0])));\n            if ($m[1]) {\n                $mime = $m[1];\n            }\n        }\n        if ($data) {\n            $ext = ($mime && isset($extTable[$mime])) ? '.' . $extTable[$mime] : '';\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (is_array($args['name']) && isset($args['name'][0])) {\n                $name = $args['name'][0];\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n            } else {\n                $name = substr(md5($data), 0, 8);\n            }\n            $name .= $ext;\n        } else {\n            $data = $name = '';\n        }\n        return array($data, $name);\n    }\n\n    /**\n     * Detect file MIME Type by local path\n     *\n     * @param  string $path Local path\n     *\n     * @return string file MIME Type\n     * @author Naoki Sawada\n     */\n    protected function detectMimeType($path)\n    {\n        static $type, $finfo;\n        if (!$type) {\n            if (class_exists('finfo', false)) {\n                $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n            } else {\n                $tmpFileInfo = false;\n            }\n            $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n            if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $type = 'finfo';\n                $finfo = finfo_open(FILEINFO_MIME);\n            } elseif (function_exists('mime_content_type')\n                && ($_ctypes = explode(';', mime_content_type(__FILE__)))\n                && preg_match($regexp, array_shift($_ctypes))) {\n                $type = 'mime_content_type';\n            } elseif (function_exists('getimagesize')) {\n                $type = 'getimagesize';\n            } else {\n                $type = 'none';\n            }\n        }\n\n        $mime = '';\n        if ($type === 'finfo') {\n            $mime = finfo_file($finfo, $path);\n        } elseif ($type === 'mime_content_type') {\n            $mime = mime_content_type($path);\n        } elseif ($type === 'getimagesize') {\n            if ($img = getimagesize($path)) {\n                $mime = $img['mime'];\n            }\n        }\n\n        if ($mime) {\n            $mime = explode(';', $mime);\n            $mime = trim($mime[0]);\n\n            if (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n                // finfo return this mime for empty files\n                $mime = 'text/plain';\n            } elseif ($mime == 'application/x-zip') {\n                // http://elrte.org/redmine/issues/163\n                $mime = 'application/zip';\n            }\n        }\n\n        return $mime ? $mime : 'unknown';\n    }\n\n    /**\n     * Detect file type extension by local path\n     *\n     * @param  object $volume elFinderVolumeDriver instance\n     * @param  string $path   Local path\n     * @param  string $name   Filename to save\n     *\n     * @return string file type extension with dot\n     * @author Naoki Sawada\n     */\n    protected function detectFileExtension($volume, $path, $name)\n    {\n        $mime = $this->detectMimeType($path);\n        if ($mime === 'unknown') {\n            $mime = 'application/octet-stream';\n        }\n        $ext = $volume->getExtentionByMime($volume->mimeTypeNormalize($mime, $name));\n        return $ext ? ('.' . $ext) : '';\n    }\n\n    /**\n     * Get temporary directory path\n     *\n     * @param  string $volumeTempPath\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    private function getTempDir($volumeTempPath = null)\n    {\n        $testDirs = array();\n        if ($this->uploadTempPath) {\n            $testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n        }\n        if ($volumeTempPath) {\n            $testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n        }\n        if (elFinder::$commonTempPath) {\n            $testDirs[] = elFinder::$commonTempPath;\n        }\n        $tempDir = '';\n        foreach ($testDirs as $testDir) {\n            if (!$testDir || !is_dir($testDir)) continue;\n            if (is_writable($testDir)) {\n                $tempDir = $testDir;\n                $gc = time() - 3600;\n                foreach (glob($tempDir . DIRECTORY_SEPARATOR . 'ELF*') as $cf) {\n                    if (filemtime($cf) < $gc) {\n                        unlink($cf);\n                    }\n                }\n                break;\n            }\n        }\n        return $tempDir;\n    }\n\n    /**\n     * chmod\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author David Bartle\n     */\n    protected function chmod($args)\n    {\n        $targets = $args['targets'];\n        $mode = intval((string)$args['mode'], 8);\n\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        $result = array();\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            $result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n            return $result;\n        }\n\n        $this->itemLock($targets);\n\n        $files = array();\n        $errors = array();\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            $file = $volume->chmod($target, $mode);\n            if ($file) {\n                $files = array_merge($files, is_array($file) ? $file : array($file));\n            } else {\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        if ($files) {\n            $result['changed'] = $files;\n            if ($errors) {\n                $result['warning'] = $this->error($errors);\n            }\n        } else {\n            $result['error'] = $this->error($errors);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check chunked upload files\n     *\n     * @param string $tmpname uploaded temporary file path\n     * @param string $chunk   uploaded chunk file name\n     * @param string $cid     uploaded chunked file id\n     * @param string $tempDir temporary dirctroy path\n     * @param null   $volume\n     *\n     * @return array|null\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    private function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null)\n    {\n        /* @var elFinderVolumeDriver $volume */\n        if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n            $fname = $m[1];\n            $encname = md5($cid . '_' . $fname);\n            $base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n            $clast = intval($m[3]);\n            if (is_null($tmpname)) {\n                ignore_user_abort(true);\n                // chunked file upload fail\n                foreach (glob($base . '*') as $cf) {\n                    unlink($cf);\n                }\n                ignore_user_abort(false);\n                return null;\n            }\n\n            $range = isset($_POST['range']) ? trim($_POST['range']) : '';\n            if ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n                $start = $ranges[1];\n                $len = $ranges[2];\n                $size = $ranges[3];\n                $tmp = $base . '.part';\n                $csize = filesize($tmpname);\n\n                $tmpExists = is_file($tmp);\n                if (!$tmpExists) {\n                    // check upload max size\n                    $uploadMaxSize = $volume ? $volume->getUploadMaxSize() : 0;\n                    if ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n                        return array(self::ERROR_UPLOAD_FILE_SIZE, false);\n                    }\n                    // make temp file\n                    $ok = false;\n                    if ($fp = fopen($tmp, 'wb')) {\n                        flock($fp, LOCK_EX);\n                        $ok = ftruncate($fp, $size);\n                        flock($fp, LOCK_UN);\n                        fclose($fp);\n                        touch($base);\n                    }\n                    if (!$ok) {\n                        unlink($tmp);\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                } else {\n                    // wait until makeing temp file (for anothor session)\n                    $cnt = 1200; // Time limit 120 sec\n                    while (!is_file($base) && --$cnt) {\n                        usleep(100000); // wait 100ms\n                    }\n                    if (!$cnt) {\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                }\n\n                // check size info\n                if ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write chunk data\n                $src = fopen($tmpname, 'rb');\n                $fp = fopen($tmp, 'cb');\n                fseek($fp, $start);\n                $writelen = stream_copy_to_stream($src, $fp, $len);\n                fclose($fp);\n                fclose($src);\n\n                try {\n                    // to check connection is aborted\n                    elFinder::checkAborted();\n                } catch (elFinderAbortException $e) {\n                    unlink($tmpname);\n                    is_file($tmp) && unlink($tmp);\n                    is_file($base) && unlink($base);\n                    throw $e;\n                }\n\n                if ($writelen != $len) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write counts\n                file_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\n                if (filesize($base) >= $clast + 1) {\n                    // Completion\n                    unlink($base);\n                    return array($tmp, $fname);\n                }\n            } else {\n                // old way\n                $part = $base . $m[2];\n                if (move_uploaded_file($tmpname, $part)) {\n                    chmod($part, 0600);\n                    if ($clast < count(glob($base . '*'))) {\n                        $parts = array();\n                        for ($i = 0; $i <= $clast; $i++) {\n                            $name = $base . '.' . $i . '_' . $clast;\n                            if (is_readable($name)) {\n                                $parts[] = $name;\n                            } else {\n                                $parts = null;\n                                break;\n                            }\n                        }\n                        if ($parts) {\n                            if (!is_file($base)) {\n                                touch($base);\n                                if ($resfile = tempnam($tempDir, 'ELF')) {\n                                    $target = fopen($resfile, 'wb');\n                                    foreach ($parts as $f) {\n                                        $fp = fopen($f, 'rb');\n                                        while (!feof($fp)) {\n                                            fwrite($target, fread($fp, 8192));\n                                        }\n                                        fclose($fp);\n                                        unlink($f);\n                                    }\n                                    fclose($target);\n                                    unlink($base);\n                                    return array($resfile, $fname);\n                                }\n                                unlink($base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return array('', '');\n    }\n\n    /**\n     * Save uploaded files\n     *\n     * @param  array\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function upload($args)\n    {\n        $ngReg = '/[\\/\\\\?*:|\"<>]/';\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $files = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n        $header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n        $result = array_merge(array('added' => array()), $header);\n        $paths = $args['upload_path'] ? $args['upload_path'] : array();\n        $chunk = $args['chunk'] ? $args['chunk'] : '';\n        $cid = $args['cid'] ? (int)$args['cid'] : '';\n        $mtimes = $args['mtime'] ? $args['mtime'] : array();\n        $tmpfname = '';\n\n        if (!$volume) {\n            return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target)), $header);\n        }\n\n        // check $chunk\n        if (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n            return array('error' => $this->error(self::ERROR_UPLOAD));\n        }\n\n        if ($args['overwrite'] !== '') {\n            $volume->setUploadOverwrite($args['overwrite']);\n        }\n\n        $renames = $hashes = array();\n        $suffix = '~';\n        if ($args['renames'] && is_array($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match($ngReg, $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if ($args['hashes'] && is_array($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        $this->itemLock($target);\n\n        // file extentions table by MIME\n        $extTable = array_flip(array_unique($volume->getMimeTable()));\n\n        if (empty($files)) {\n            if (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n                $names = array();\n                foreach ($args['upload'] as $i => $url) {\n                    // check chunked file upload commit\n                    if ($chunk) {\n                        if ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n                            $this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n                            if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n                                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TEMP);\n                            }\n                            return $result;\n                        } else {\n                            $tmpfname = $tempDir . '/' . $chunk;\n                            $files['tmp_name'][$i] = $tmpfname;\n                            $files['name'][$i] = $url;\n                            $files['error'][$i] = 0;\n                            $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                            break;\n                        }\n                    }\n\n                    $tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url . microtime(true));\n                    $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\n                    $_name = '';\n                    // check is data:\n                    if (substr($url, 0, 5) === 'data:') {\n                        list($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n                    } else {\n                        $fp = fopen($tmpfname, 'wb');\n                        if ($data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp)) {\n                            // to check connection is aborted\n                            try {\n                                elFinder::checkAborted();\n                            } catch(elFinderAbortException $e) {\n                                fclose($fp);\n                                throw $e;\n                            }\n                            $_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n                            // Check `Content-Disposition` response header\n                            if (($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n                                if (preg_match('/filename\\*=(?:([a-zA-Z0-9_-]+?)\\'\\')\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[2]);\n                                    if ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n                                        $_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n                                    }\n                                } else if (preg_match('/filename=\"?([ a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[1]);\n                                }\n                            }\n                        } else {\n                            fclose($fp);\n                        }\n                    }\n                    if ($data) {\n                        if (isset($args['name'][$i])) {\n                            $_name = $args['name'][$i];\n                        }\n                        if ($_name) {\n                            $_ext = '';\n                            if (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n                                $_ext = $_match[1];\n                            }\n                            if ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n                                $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                                $_name = preg_replace($ngReg, '_', $_name);\n                                list($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n                                if ($_b === '') {\n                                    if ($_ext) {\n                                        rename($tmpfname, $tmpfname . $_ext);\n                                        $tmpfname = $tmpfname . $_ext;\n                                    }\n                                    $_b = $this->detectFileExtension($volume, $tmpfname, $_name);\n                                    $_name = $_a . $_b;\n                                } else {\n                                    $_b = '.' . $_b;\n                                }\n                                if (isset($names[$_name])) {\n                                    $_name = $_a . '_' . $names[$_name]++ . $_b;\n                                } else {\n                                    $names[$_name] = 1;\n                                }\n                                $files['tmp_name'][$i] = $tmpfname;\n                                $files['name'][$i] = $_name;\n                                $files['error'][$i] = 0;\n                                // set to auto rename\n                                $volume->setUploadOverwrite(false);\n                            } else {\n                                unlink($tmpfname);\n                            }\n                        }\n                    }\n                }\n            }\n            if (empty($files)) {\n                return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n            }\n        }\n\n        $addedDirs = array();\n        $errors = array();\n        foreach ($files['name'] as $i => $name) {\n            if (($error = $files['error'][$i]) > 0) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER, $error);\n                $this->uploadDebug = 'Upload error code: ' . $error;\n                break;\n            }\n\n            $tmpname = $files['tmp_name'][$i];\n            $thash = ($paths && isset($paths[$i])) ? $paths[$i] : $target;\n            $mtime = isset($mtimes[$i]) ? $mtimes[$i] : 0;\n            if ($name === 'blob') {\n                if ($chunk) {\n                    if ($tempDir = $this->getTempDir($volume->getTempPath())) {\n                        list($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n                        if ($tmpname) {\n                            if ($name === false) {\n                                preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n                                $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n                                $result['_chunkfailure'] = true;\n                                $this->uploadDebug = 'Upload error: ' . $tmpname;\n                            } else if ($name) {\n                                $result['_chunkmerged'] = basename($tmpname);\n                                $result['_name'] = $name;\n                                $result['_mtime'] = $mtime;\n                            }\n                        }\n                    } else {\n                        $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TEMP);\n                        $this->uploadDebug = 'Upload error: unable open tmp file';\n                    }\n                    return $result;\n                } else {\n                    // for form clipboard with Google Chrome or Opera\n                    $name = 'image.png';\n                }\n            }\n\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n                $type = $files['type'][$i];\n                $name = $args['name'][$i];\n                $ext = isset($extTable[$type]) ? '.' . $extTable[$type] : '';\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n                $name .= $ext;\n            }\n\n            // do hook function 'upload.presave'\n            try {\n                $this->trigger('upload.presave', array(&$thash, &$name, $tmpname, $this, $volume), $errors);\n            } catch (elFinderTriggerException $e) {\n                if (!is_uploaded_file($tmpname) && unlink($tmpname) && $tmpfname) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                }\n                continue;\n            }\n\n            clearstatcache();\n            if ($mtime && is_file($tmpname)) {\n                // for keep timestamp option in the LocalFileSystem volume\n                touch($tmpname, $mtime);\n            }\n\n            $fp = null;\n            if (!is_file($tmpname) || ($fp = fopen($tmpname, 'rb')) === false) {\n                $errors = array_merge($errors, array(self::ERROR_UPLOAD_FILE, $name, ($fp === false? self::ERROR_UPLOAD_TEMP : self::ERROR_UPLOAD_TRANSFER)));\n                $this->uploadDebug = 'Upload error: unable open tmp file';\n                if (!is_uploaded_file($tmpname)) {\n                    if (unlink($tmpname) && $tmpfname) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                    continue;\n                }\n                break;\n            }\n            $rnres = array();\n            if ($thash !== '' && $thash !== $target) {\n                if ($dir = $volume->dir($thash)) {\n                    $_target = $thash;\n                    if (!isset($addedDirs[$thash])) {\n                        $addedDirs[$thash] = true;\n                        $result['added'][] = $dir;\n                        // to support multi-level directory creation\n                        $_phash = isset($dir['phash']) ? $dir['phash'] : null;\n                        while ($_phash && !isset($addedDirs[$_phash]) && $_phash !== $target) {\n                            if ($_dir = $volume->dir($_phash)) {\n                                $addedDirs[$_phash] = true;\n                                $result['added'][] = $_dir;\n                                $_phash = isset($_dir['phash']) ? $_dir['phash'] : null;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    $result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@' . $thash);\n                    break;\n                }\n            } else {\n                $_target = $target;\n                // file rename for backup\n                if (isset($renames[$name])) {\n                    $dir = $volume->realpath($_target);\n                    if (isset($hashes[$name])) {\n                        $hash = $hashes[$name];\n                    } else {\n                        $hash = $volume->getHash($dir, $name);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = $rnres['error'];\n                        if (!is_array($rnres['error'])) {\n                            $errors = array_push($errors, $rnres['error']);\n                        } else {\n                            $errors = array_merge($errors, $rnres['error']);\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (!$_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, ($_target === $target) ? $hashes : array())) === false) {\n                $errors = array_merge($errors, $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error()));\n                fclose($fp);\n                if (!is_uploaded_file($tmpname) && unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n                continue;\n            }\n\n            is_resource($fp) && fclose($fp);\n            if (!is_uploaded_file($tmpname)) {\n                clearstatcache();\n                if (!is_file($tmpname) || unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n            }\n            $result['added'][] = $file;\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n\n        if ($GLOBALS['elFinderTempFiles']) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n                is_file($_temp) && is_writable($_temp) && unlink($_temp);\n            }\n        }\n        $result['removed'] = $volume->removed();\n\n        if (!empty($args['node'])) {\n            $result['callback'] = array(\n                'node' => $args['node'],\n                'bind' => 'upload'\n            );\n        }\n        return $result;\n    }\n\n    /**\n     * Copy/move files into new destination\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function paste($args)\n    {\n        $dst = $args['dst'];\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $cut = !empty($args['cut']);\n        $error = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n        $result = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\n        if (($dstVolume = $this->volume($dst)) == false) {\n            return array('error' => $this->error($error, '#' . $targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#' . $dst));\n        }\n\n        $this->itemLock($dst);\n\n        $hashes = $renames = array();\n        $suffix = '~';\n        if (!empty($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if (!empty($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($srcVolume = $this->volume($target)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n                continue;\n            }\n\n            $rnres = array();\n            if ($renames) {\n                $file = $srcVolume->file($target);\n                if (isset($renames[$file['name']])) {\n                    $dir = $dstVolume->realpath($dst);\n                    $dstName = $file['name'];\n                    if ($srcVolume !== $dstVolume) {\n                        $errors = array();\n                        try {\n                            $this->trigger('paste.copyfrom', array(&$dst, &$dstName, '', $this, $dstVolume), $errors);\n                        } catch (elFinderTriggerException $e) {\n                            $result['warning'] = array_merge($result['warning'], $errors);\n                            continue;\n                        }\n                    }\n                    if (isset($hashes[$file['name']])) {\n                        $hash = $hashes[$file['name']];\n                    } else {\n                        $hash = $dstVolume->getHash($dir, $dstName);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $dstName, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = array_merge($result['warning'], $rnres['error']);\n                        continue;\n                    }\n                }\n            }\n\n            if ($cut && $this->itemLocked($target)) {\n                $rm = $srcVolume->file($target);\n                $result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n                continue;\n            }\n\n            if (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n                continue;\n            }\n\n            if ($error = $dstVolume->error()) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error));\n            }\n\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n        if (count($result['warning']) < 1) {\n            unset($result['warning']);\n        } else {\n            $result['sync'] = true;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return file content\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function get($args)\n    {\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $enc = false;\n\n        if (!$volume || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($volume->commandDisabled('get')) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_ACCESS_DENIED));\n        }\n\n        if (($content = $volume->getContents($target)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n        }\n\n        $mime = isset($file['mime']) ? $file['mime'] : '';\n        if ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n            $enc = '';\n            if ($content !== '') {\n                if (!$args['conv'] || $args['conv'] == '1') {\n                    // detect encoding\n                    if (function_exists('mb_detect_encoding')) {\n                        if ($enc = mb_detect_encoding($content, mb_detect_order(), true)) {\n                            $encu = strtoupper($enc);\n                            if ($encu === 'UTF-8' || $encu === 'ASCII') {\n                                $enc = '';\n                            }\n                        } else {\n                            $enc = 'unknown';\n                        }\n                    } else if (!preg_match('//u', $content)) {\n                        $enc = 'unknown';\n                    }\n                    if ($enc === 'unknown') {\n                        $enc = $volume->getOption('encoding');\n                        if (!$enc || strtoupper($enc) === 'UTF-8') {\n                            $enc = 'unknown';\n                        }\n                    }\n                    // call callbacks 'get.detectencoding'\n                    if (!empty($this->listeners['get.detectencoding'])) {\n                        foreach ($this->listeners['get.detectencoding'] as $handler) {\n                            call_user_func_array($handler, array('get', &$enc, array_merge($args, array('content' => $content)), $this, $volume));\n                        }\n                    }\n                    if ($enc && $enc !== 'unknown') {\n                        $errlev = error_reporting();\n                        error_reporting($errlev ^ E_NOTICE);\n                        $utf8 = iconv($enc, 'UTF-8', $content);\n                        if ($utf8 === false && function_exists('mb_convert_encoding')) {\n                            error_reporting($errlev ^ E_WARNING);\n                            $utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n                            if (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n                                $enc = 'unknown';\n                            }\n                        } else {\n                            if ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n                                $enc = 'unknown';\n                            }\n                        }\n                        error_reporting($errlev);\n                        if ($enc !== 'unknown') {\n                            $content = $utf8;\n                        }\n                    }\n                    if ($enc) {\n                        if ($args['conv'] == '1') {\n                            $args['conv'] = '';\n                            if ($enc === 'unknown') {\n                                $content = false;\n                            }\n                        } else if ($enc === 'unknown') {\n                            return array('doconv' => $enc);\n                        }\n                    }\n                    if ($args['conv'] == '1') {\n                        $args['conv'] = '';\n                    }\n                }\n                if ($args['conv']) {\n                    $enc = $args['conv'];\n                    if (strtoupper($enc) !== 'UTF-8') {\n                        $_content = $content;\n                        $errlev = error_reporting();\n                        $this->setToastErrorHandler(array(\n                            'prefix' => 'Notice: '\n                        ));\n                        error_reporting($errlev | E_NOTICE | E_WARNING);\n                        $content = iconv($enc, 'UTF-8//TRANSLIT', $content);\n                        if ($content === false && function_exists('mb_convert_encoding')) {\n                            $content = mb_convert_encoding($_content, 'UTF-8', $enc);\n                        }\n                        error_reporting($errlev);\n                        $this->setToastErrorHandler(false);\n                    } else {\n                        $enc = '';\n                    }\n                }\n            }\n        } else {\n            $content = 'data:' . ($mime ? $mime : 'application/octet-stream') . ';base64,' . base64_encode($content);\n        }\n\n        if ($enc !== false) {\n            $json = false;\n            if ($content !== false) {\n                $json = json_encode($content);\n            }\n            if ($content === false || $json === false || strlen($json) < strlen($content)) {\n                return array('doconv' => 'unknown');\n            }\n        }\n\n        $res = array(\n            'header' => array(\n                'Content-Type: application/json'\n            ),\n            'content' => $content\n        );\n\n        // add cache control headers\n        if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n            $res['header'] = array_merge($res['header'], $cacheHeaders);\n        }\n\n        if ($enc) {\n            $res['encoding'] = $enc;\n        }\n        return $res;\n    }\n\n    /**\n     * Save content into text file\n     *\n     * @param $args\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function put($args)\n    {\n        $target = $args['target'];\n        $encoding = isset($args['encoding']) ? $args['encoding'] : '';\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $this->itemLock($target);\n\n        if ($encoding === 'scheme') {\n            if (preg_match('~^https?://~i', $args['content'])) {\n                /** @var resource $fp */\n                $fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n                if (!$fp) {\n                    return array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n                }\n                $fmeta = stream_get_meta_data($fp);\n                $mime = $this->detectMimeType($fmeta['uri']);\n                if ($mime === 'unknown') {\n                    $mime = 'application/octet-stream';\n                }\n                $mime = $volume->mimeTypeNormalize($mime, $file['name']);\n                $args['content'] = 'data:' . $mime . ';base64,' . base64_encode(file_get_contents($fmeta['uri']));\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        } else if ($encoding === 'hash') {\n            $_hash = $args['content'];\n            if ($_src = $this->getVolume($_hash)) {\n                if ($_file = $_src->file($_hash)) {\n                    if ($_data = $_src->getContents($_hash)) {\n                        $args['content'] = 'data:' . $file['mime'] . ';base64,' . base64_encode($_data);\n                    }\n                }\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        }\n        if ($encoding) {\n            $content = iconv('UTF-8', $encoding, $args['content']);\n            if ($content === false && function_exists('mb_detect_encoding')) {\n                $content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n            }\n            if ($content !== false) {\n                $args['content'] = $content;\n            }\n        }\n        if (($file = $volume->putContents($target, $args['content'])) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n        }\n\n        return array('changed' => array($file));\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    protected function extract($args)\n    {\n        $target = $args['target'];\n        $makedir = isset($args['makedir']) ? (bool)$args['makedir'] : null;\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_EXTRACT, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $res = array();\n        if ($file = $volume->extract($target, $makedir)) {\n            $res['added'] = isset($file['read']) ? array($file) : $file;\n            if ($err = $volume->error()) {\n                $res['warning'] = $err;\n            }\n        } else {\n            $res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n        }\n        return $res;\n    }\n\n    /**\n     * Create archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function archive($args)\n    {\n        $targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n        $name = isset($args['name']) ? $args['name'] : '';\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            return $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n        }\n\n        foreach ($targets as $target) {\n            $this->itemLock($target);\n        }\n\n        return ($file = $volume->archive($targets, $args['type'], $name))\n            ? array('added' => array($file))\n            : array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function search($args)\n    {\n        $q = trim($args['q']);\n        $mimes = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n        $target = !empty($args['target']) ? $args['target'] : null;\n        $type = !empty($args['type']) ? $args['type'] : null;\n        $result = array();\n        $errors = array();\n\n        if ($target) {\n            if ($volume = $this->volume($target)) {\n                $result = $volume->search($q, $mimes, $target, $type);\n                $errors = array_merge($errors, $volume->error());\n            }\n        } else {\n            foreach ($this->volumes as $volume) {\n                $result = array_merge($result, $volume->search($q, $mimes, null, $type));\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        $result = array('files' => $result);\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n        return $result;\n    }\n\n    /**\n     * Return file info (used by client \"places\" ui)\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function info($args)\n    {\n        $files = array();\n        $compare = null;\n        // long polling mode\n        if ($args['compare'] && count($args['targets']) === 1) {\n            $compare = intval($args['compare']);\n            $hash = $args['targets'][0];\n            if ($volume = $this->volume($hash)) {\n                $standby = (int)$volume->getOption('plStandby');\n                $_compare = false;\n                if (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n                    $_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n                }\n                if ($_compare !== false) {\n                    $compare = $_compare;\n                } else {\n                    $sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n                    $limit = max(1, $standby / $sleep) + 1;\n                    do {\n                        elFinder::extendTimeLimit(30 + $sleep);\n                        $volume->clearstatcache();\n                        if (($info = $volume->file($hash)) != false) {\n                            if ($info['ts'] != $compare) {\n                                $compare = $info['ts'];\n                                break;\n                            }\n                        } else {\n                            $compare = 0;\n                            break;\n                        }\n                        if (--$limit) {\n                            sleep($sleep);\n                        }\n                    } while ($limit);\n                }\n            }\n        } else {\n            foreach ($args['targets'] as $hash) {\n                elFinder::checkAborted();\n                if (($volume = $this->volume($hash)) != false\n                    && ($info = $volume->file($hash)) != false) {\n                    $info['path'] = $volume->path($hash);\n                    $files[] = $info;\n                }\n            }\n        }\n\n        $result = array('files' => $files);\n        if (!is_null($compare)) {\n            $result['compare'] = strval($compare);\n        }\n        return $result;\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function dim($args)\n    {\n        $res = array();\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) != false) {\n            if ($dim = $volume->dimensions($target, $args)) {\n                if (is_array($dim) && isset($dim['dim'])) {\n                    $res = $dim;\n                } else {\n                    $res = array('dim' => $dim);\n                    if ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n                        $res['url'] = $subImgLink;\n                    }\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function resize($args)\n    {\n        $target = $args['target'];\n        $width = (int)$args['width'];\n        $height = (int)$args['height'];\n        $x = (int)$args['x'];\n        $y = (int)$args['y'];\n        $mode = $args['mode'];\n        $bg = $args['bg'];\n        $degree = (int)$args['degree'];\n        $quality = (int)$args['quality'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_RESIZE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n            return array('error' => $this->error(self::ERROR_RESIZESIZE));\n        }\n        return ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n            ? (!empty($file['losslessRotate']) ? $file : array('changed' => array($file)))\n            : array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n    }\n\n    /**\n     * Return content URL\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function url($args)\n    {\n        $target = $args['target'];\n        $options = isset($args['options']) ? $args['options'] : array();\n        if (($volume = $this->volume($target)) != false) {\n            if (!$volume->commandDisabled('url')) {\n                $url = $volume->getContentUrl($target, $options);\n                return $url ? array('url' => $url) : array();\n            }\n        }\n        return array();\n    }\n\n    /**\n     * Output callback result with JavaScript that control elFinder\n     * or HTTP redirect to callbackWindowURL\n     *\n     * @param  array  command arguments\n     *\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function callback($args)\n    {\n        $checkReg = '/[^a-zA-Z0-9;._-]/';\n        $node = (isset($args['node']) && !preg_match($checkReg, $args['node'])) ? $args['node'] : '';\n        $json = (isset($args['json']) && json_decode($args['json'])) ? $args['json'] : '{}';\n        $bind = (isset($args['bind']) && !preg_match($checkReg, $args['bind'])) ? $args['bind'] : '';\n        $done = (!empty($args['done']));\n\n        while (ob_get_level()) {\n            if (!ob_end_clean()) {\n                break;\n            }\n        }\n\n        if ($done || !$this->callbackWindowURL) {\n            $script = '';\n            if ($node) {\n                if ($bind) {\n                    $trigger = 'elf.trigger(\\'' . $bind . '\\', data);';\n                    $triggerdone = 'elf.trigger(\\'' . $bind . 'done\\');';\n                    $triggerfail = 'elf.trigger(\\'' . $bind . 'fail\\', data);';\n                } else {\n                    $trigger = $triggerdone = $triggerfail = '';\n                }\n                $origin = isset($_SERVER['HTTP_ORIGIN'])? str_replace('\\'', '\\\\\\'', $_SERVER['HTTP_ORIGIN']) : '*';\n                $script .= '\nvar go = function() {\n    var w = window.opener || window.parent || window,\n        close = function(){\n            window.open(\"about:blank\",\"_self\").close();\n            return false;\n        };\n    try {\n        var elf = w.document.getElementById(\\'' . $node . '\\').elfinder;\n        if (elf) {\n            var data = ' . $json . ';\n            if (data.error) {\n                ' . $triggerfail . '\n                elf.error(data.error);\n            } else {\n                data.warning && elf.error(data.warning);\n                data.removed && data.removed.length && elf.remove(data);\n                data.added   && data.added.length   && elf.add(data);\n                data.changed && data.changed.length && elf.change(data);\n                ' . $trigger . '\n                ' . $triggerdone . '\n                data.sync && elf.sync();\n            }\n        }\n    } catch(e) {\n        // for CORS\n        w.postMessage && w.postMessage(JSON.stringify({bind:\\'' . $bind . '\\',data:' . $json . '}), \\'' . $origin . '\\');\n    }\n    close();\n    setTimeout(function() {\n        var msg = document.getElementById(\\'msg\\');\n        msg.style.display = \\'inline\\';\n        msg.onclick = close;\n    }, 100);\n};\n';\n            }\n\n            $out = '<!DOCTYPE html><html lang=\"en\"><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=2\"><script>' . $script . '</script></head><body><h2 id=\"msg\" style=\"display:none;\"><a href=\"#\">Please close this tab.</a></h2><script>go();</script></body></html>';\n\n            header('Content-Type: text/html; charset=utf-8');\n            header('Content-Length: ' . strlen($out));\n            header('Cache-Control: private');\n            header('Pragma: no-cache');\n\n            echo $out;\n\n        } else {\n            $url = $this->callbackWindowURL;\n            $url .= ((strpos($url, '?') === false) ? '?' : '&')\n                . '&node=' . rawurlencode($node)\n                . (($json !== '{}') ? ('&json=' . rawurlencode($json)) : '')\n                . ($bind ? ('&bind=' . rawurlencode($bind)) : '')\n                . '&done=1';\n\n            header('Location: ' . $url);\n\n        }\n        throw new elFinderAbortException();\n    }\n\n    /**\n     * Error handler for send toast message to client side\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    protected function toastErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        $proc = false;\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n        $toast = array();\n        $toast['mode'] = $this->toastParams['mode'];\n        $toast['msg'] = $this->toastParams['prefix'] . $errstr;\n        $this->toastMessages[] = $toast;\n        return true;\n    }\n\n    /**\n     * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    public static function phpErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        static $base = null;\n\n        $proc = false;\n\n        if (is_null($base)) {\n            $base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n        }\n\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n\n        $errfile = str_replace($base, '', $errfile);\n\n        switch ($errno) {\n            case E_WARNING:\n            case E_USER_WARNING:\n                elFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_NOTICE:\n            case E_USER_NOTICE:\n                elFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_STRICT:\n                elFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_RECOVERABLE_ERROR:\n                elFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n        }\n\n        if (defined('E_DEPRECATED')) {\n            switch ($errno) {\n                case E_DEPRECATED:\n                case E_USER_DEPRECATED:\n                    elFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n                    $proc = true;\n                    break;\n            }\n        }\n\n        return $proc;\n    }\n\n    /***************************************************************************/\n    /*                                   utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return root - file's owner\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver|boolean (false)\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function volume($hash)\n    {\n        foreach ($this->volumes as $id => $v) {\n            if (strpos('' . $hash, $id) === 0) {\n                return $this->volumes[$id];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return files info array\n     *\n     * @param  array $data one file info or files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function toArray($data)\n    {\n        return isset($data['hash']) || !is_array($data) ? array($data) : $data;\n    }\n\n    /**\n     * Return fils hashes list\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function hashes($files)\n    {\n        $ret = array();\n        foreach ($files as $file) {\n            $ret[] = $file['hash'];\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove from files list hidden files and files with required mime types\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function filter($files)\n    {\n        $exists = array();\n        foreach ($files as $i => $file) {\n            if (isset($file['hash'])) {\n                if (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n                    unset($files[$i]);\n                }\n                $exists[$file['hash']] = true;\n            }\n        }\n        return array_values($files);\n    }\n\n    protected function utime()\n    {\n        $time = explode(\" \", microtime());\n        return (double)$time[1] + (double)$time[0];\n    }\n\n    /**\n     * Return Network mount volume unique ID\n     *\n     * @param  array  $netVolumes Saved netvolumes array\n     * @param  string $prefix     Id prefix\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     **/\n    protected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm')\n    {\n        if (is_null($netVolumes)) {\n            $netVolumes = $this->getNetVolumes();\n        }\n        $ids = array();\n        foreach ($netVolumes as $vOps) {\n            if (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n                $ids[$vOps['id']] = true;\n            }\n        }\n        if (!$ids) {\n            $id = $prefix . '1';\n        } else {\n            $i = 0;\n            while (isset($ids[$prefix . ++$i]) && $i < 10000) ;\n            $id = $prefix . $i;\n            if (isset($ids[$id])) {\n                $id = false;\n            }\n        }\n        return $id;\n    }\n\n    /**\n     * Is item locked?\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemLocked($hash)\n    {\n        if (!elFinder::$commonTempPath) {\n            return false;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        if (file_exists($lock)) {\n            if (filemtime($lock) + $this->itemLockExpire < time()) {\n                unlink($lock);\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Do lock target item\n     *\n     * @param array|string $hashes\n     * @param boolean      $autoUnlock\n     *\n     * @return void\n     */\n    protected function itemLock($hashes, $autoUnlock = true)\n    {\n        if (!elFinder::$commonTempPath) {\n            return;\n        }\n        if (!is_array($hashes)) {\n            $hashes = array($hashes);\n        }\n        foreach ($hashes as $hash) {\n            $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n            if ($this->itemLocked($hash)) {\n                $cnt = file_get_contents($lock) + 1;\n            } else {\n                $cnt = 1;\n            }\n            if (file_put_contents($lock, $cnt, LOCK_EX)) {\n                if ($autoUnlock) {\n                    $this->autoUnlocks[] = $hash;\n                }\n            }\n        }\n    }\n\n    /**\n     * Do unlock target item\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemUnlock($hash)\n    {\n        if (!$this->itemLocked($hash)) {\n            return true;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        $cnt = file_get_contents($lock);\n        if (--$cnt < 1) {\n            unlink($lock);\n            return true;\n        } else {\n            file_put_contents($lock, $cnt, LOCK_EX);\n            return false;\n        }\n    }\n\n    /**\n     * unlock locked items on command completion\n     *\n     * @return void\n     */\n    public function itemAutoUnlock()\n    {\n        if ($this->autoUnlocks) {\n            foreach ($this->autoUnlocks as $hash) {\n                $this->itemUnlock($hash);\n            }\n            $this->autoUnlocks = array();\n        }\n    }\n\n    /**\n     * Ensure directories recursively\n     *\n     * @param  object $volume Volume object\n     * @param  string $target Target hash\n     * @param  array  $dirs   Array of directory tree to ensure\n     * @param  string $path   Relative path form target hash\n     *\n     * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n     * @author Naoki Sawada\n     **/\n    protected function ensureDirsRecursively($volume, $target, $dirs, $path = '')\n    {\n        $res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n        foreach ($dirs as $name => $sub) {\n            $name = (string)$name;\n            $dir = $newDir = null;\n            if ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n                $_path = $path . '/' . $name;\n                if ($newDir) {\n                    $res['makes'][] = $newDir['hash'];\n                    $dir = $newDir;\n                }\n                $res['stats'][] = $dir;\n                $res['hashes'][$_path] = $dir['hash'];\n                if (count($sub)) {\n                    $res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n                }\n            } else {\n                $res['error'][] = $name;\n            }\n        }\n        return $res;\n    }\n\n    /**\n     * Sets the toast error handler.\n     *\n     * @param array $opts The options\n     */\n    public function setToastErrorHandler($opts)\n    {\n        $this->toastParams = $this->toastParamsDefault;\n        if (!$opts) {\n            restore_error_handler();\n        } else {\n            $this->toastParams = array_merge($this->toastParams, $opts);\n            set_error_handler(array($this, 'toastErrorHandler'));\n        }\n    }\n\n    /**\n     * String encode convert to UTF-8\n     *\n     * @param      string  $str  Input string\n     *\n     * @return     string  UTF-8 string\n     */\n    public function utf8Encode($str)\n    {\n        static $mbencode = null;\n        $str = (string) $str;\n        if (@iconv('utf-8', 'utf-8//IGNORE', $str) === $str) {\n            return $str;\n        }\n\n        if ($this->utf8Encoder) {\n            return $this->utf8Encoder($str);\n        }\n\n        if ($mbencode === null) {\n            $mbencode = function_exists('mb_convert_encoding') && function_exists('mb_detect_encoding');\n        }\n\n        if ($mbencode) {\n            if ($enc = mb_detect_encoding($str, mb_detect_order(), true)) {\n                $_str = mb_convert_encoding($str, 'UTF-8', $enc);\n                if (@iconv('utf-8', 'utf-8//IGNORE', $_str) === $_str) {\n                    return $_str;\n                }\n            }\n        }\n        return utf8_encode($str);\n    }\n\n    /***************************************************************************/\n    /*                           static  utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return full version of API that this connector supports all functions\n     *\n     * @return string\n     */\n    public static function getApiFullVersion()\n    {\n        return (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n    }\n\n    /**\n     * Return Is Animation Gif\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationGif($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_GIF:\n                break;\n            default:\n                return false;\n        }\n\n        $imgcnt = 0;\n        $fp = fopen($path, 'rb');\n        fread($fp, 4);\n        $c = fread($fp, 1);\n        if (ord($c) != 0x39) {  // GIF89a\n            return false;\n        }\n\n        while (!feof($fp)) {\n            do {\n                $c = fread($fp, 1);\n            } while (ord($c) != 0x21 && !feof($fp));\n\n            if (feof($fp)) {\n                break;\n            }\n\n            $c2 = fread($fp, 2);\n            if (bin2hex($c2) == \"f904\") {\n                $imgcnt++;\n                if ($imgcnt === 2) {\n                    break;\n                }\n            }\n\n            if (feof($fp)) {\n                break;\n            }\n        }\n\n        if ($imgcnt > 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Return Is Animation Png\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationPng($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_PNG:\n                break;\n            default:\n                return false;\n        }\n\n        $fp = fopen($path, 'rb');\n        $img_bytes = fread($fp, 1024);\n        fclose($fp);\n        if ($img_bytes) {\n            if (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return Is seekable stream resource\n     *\n     * @param resource $resource\n     *\n     * @return bool\n     */\n    public static function isSeekableStream($resource)\n    {\n        $metadata = stream_get_meta_data($resource);\n        return $metadata['seekable'];\n    }\n\n    /**\n     * Rewind stream resource\n     *\n     * @param resource $resource\n     *\n     * @return void\n     */\n    public static function rewind($resource)\n    {\n        self::isSeekableStream($resource) && rewind($resource);\n    }\n\n    /**\n     * Determines whether the specified resource is seekable url.\n     *\n     * @param      <type>   $resource  The resource\n     *\n     * @return     boolean  True if the specified resource is seekable url, False otherwise.\n     */\n    public static function isSeekableUrl($resource)\n    {\n        $id = (int)$resource;\n        if (isset(elFinder::$seekableUrlFps[$id])) {\n            return elFinder::$seekableUrlFps[$id];\n        }\n        return null;\n    }\n\n    /**\n     * serialize and base64_encode of session data (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var target variable\n     *\n     * @author Naoki Sawada\n     * @return mixed|string\n     */\n    public static function sessionDataEncode($var)\n    {\n        if (self::$base64encodeSessionData) {\n            $var = base64_encode(serialize($var));\n        }\n        return $var;\n    }\n\n    /**\n     * base64_decode and unserialize of session data  (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var     target variable\n     * @param  bool  $checkIs data type for check (array|string|object|int)\n     *\n     * @author Naoki Sawada\n     * @return bool|mixed\n     */\n    public static function sessionDataDecode(&$var, $checkIs = null)\n    {\n        if (self::$base64encodeSessionData) {\n            $data = unserialize(base64_decode($var));\n        } else {\n            $data = $var;\n        }\n        $chk = true;\n        if ($checkIs) {\n            switch ($checkIs) {\n                case 'array':\n                    $chk = is_array($data);\n                    break;\n                case 'string':\n                    $chk = is_string($data);\n                    break;\n                case 'object':\n                    $chk = is_object($data);\n                    break;\n                case 'int':\n                    $chk = is_int($data);\n                    break;\n            }\n        }\n        if (!$chk) {\n            unset($var);\n            return false;\n        }\n        return $data;\n    }\n\n    /**\n     * Call session_write_close() if session is restarted\n     *\n     * @deprecated\n     * @return void\n     */\n    public static function sessionWrite()\n    {\n        if (session_id()) {\n            session_write_close();\n        }\n    }\n\n    /**\n     * Return elFinder static variable\n     *\n     * @param $key\n     *\n     * @return mixed|null\n     */\n    public static function getStaticVar($key)\n    {\n        return isset(elFinder::$$key) ? elFinder::$$key : null;\n    }\n\n    /**\n     * Extend PHP execution time limit and also check connection is aborted\n     *\n     * @param Int $time\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function extendTimeLimit($time = null)\n    {\n        static $defLimit = null;\n        if (!self::aborted()) {\n            if (is_null($defLimit)) {\n                $defLimit = ini_get('max_execution_time');\n            }\n            if ($defLimit != 0) {\n                $time = is_null($time) ? $defLimit : max($defLimit, $time);\n                set_time_limit($time);\n            }\n        } else {\n            throw new elFinderAbortException();\n        }\n    }\n\n    /**\n     * Check connection is aborted\n     * Script stop immediately if connection aborted\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function checkAborted()\n    {\n        elFinder::extendTimeLimit();\n    }\n\n    /**\n     * Return bytes from php.ini value\n     *\n     * @param string $iniName\n     * @param string $val\n     *\n     * @return number\n     */\n    public static function getIniBytes($iniName = '', $val = '')\n    {\n        if ($iniName !== '') {\n            $val = ini_get($iniName);\n            if ($val === false) {\n                return 0;\n            }\n        }\n        $val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n        $last = strtolower($val[strlen($val) - 1]);\n        $val = sprintf('%u', $val);\n        switch ($last) {\n            case 'y':\n                $val = elFinder::xKilobyte($val);\n            case 'z':\n                $val = elFinder::xKilobyte($val);\n            case 'e':\n                $val = elFinder::xKilobyte($val);\n            case 'p':\n                $val = elFinder::xKilobyte($val);\n            case 't':\n                $val = elFinder::xKilobyte($val);\n            case 'g':\n                $val = elFinder::xKilobyte($val);\n            case 'm':\n                $val = elFinder::xKilobyte($val);\n            case 'k':\n                $val = elFinder::xKilobyte($val);\n        }\n        return $val;\n    }\n\n    /**\n     * Return X 1KByte\n     *\n     * @param      integer|string  $val    The value\n     *\n     * @return     number\n     */\n    public static function xKilobyte($val)\n    {\n        if (strpos((string)$val * 1024, 'E') !== false) {\n            if (strpos((string)$val * 1.024, 'E') === false) {\n                $val *= 1.024;\n            }\n            $val .= '000';\n        } else {\n            $val *= 1024;\n        }\n        return $val;\n    }\n\n    /**\n     * Get script url.\n     *\n     * @return string full URL\n     * @author Naoki Sawada\n     */\n    public static function getConnectorUrl()\n    {\n        if (defined('ELFINDER_CONNECTOR_URL')) {\n            return ELFINDER_CONNECTOR_URL;\n        }\n\n        $https = (!empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n        $url = ($https ? 'https://' : 'http://')\n            . $_SERVER['SERVER_NAME']                                              // host\n            . ((empty($_SERVER['SERVER_PORT']) || (!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n            . $_SERVER['REQUEST_URI'];                                             // path & query\n        list($url) = explode('?', $url);\n\n        return $url;\n    }\n\n    /**\n     * Get stream resource pointer by URL\n     *\n     * @param array $data array('target'=>'URL', 'headers' => array())\n     * @param int   $redirectLimit\n     *\n     * @return resource|boolean\n     * @author Naoki Sawada\n     */\n    public static function getStreamByUrl($data, $redirectLimit = 5)\n    {\n        if (isset($data['target'])) {\n            $data = array(\n                'cnt' => 0,\n                'url' => $data['target'],\n                'headers' => isset($data['headers']) ? $data['headers'] : array(),\n                'postData' => isset($data['postData']) ? $data['postData'] : array(),\n                'cookies' => array(),\n            );\n        }\n        if ($data['cnt'] > $redirectLimit) {\n            return false;\n        }\n        $dlurl = $data['url'];\n        $data['url'] = '';\n        $headers = $data['headers'];\n\n        if ($dlurl) {\n            $url = parse_url($dlurl);\n            $ports = array(\n                'http' => '80',\n                'https' => '443',\n                'ftp' => '21'\n            );\n            $url['scheme'] = strtolower($url['scheme']);\n            if (!isset($url['port']) && isset($ports[$url['scheme']])) {\n                $url['port'] = $ports[$url['scheme']];\n            }\n            if (!isset($url['port'])) {\n                return false;\n            }\n            $cookies = array();\n            if ($data['cookies']) {\n                foreach ($data['cookies'] as $d => $c) {\n                    if (strpos($url['host'], $d) !== false) {\n                        $cookies[] = $c;\n                    }\n                }\n            }\n\n            $transport = ($url['scheme'] === 'https') ? 'ssl' : 'tcp';\n            $query = isset($url['query']) ? '?' . $url['query'] : '';\n            if (!($stream = stream_socket_client($transport . '://' . $url['host'] . ':' . $url['port']))) {\n                return false;\n            }\n\n            $body = '';\n            if (!empty($data['postData'])) {\n                $method = 'POST';\n                if (is_array($data['postData'])) {\n                    $body = http_build_query($data['postData']);\n                } else {\n                    $body = $data['postData'];\n                }\n            } else {\n                $method = 'GET';\n            }\n\n            $sends = array();\n            $sends[] = \"$method {$url['path']}{$query} HTTP/1.1\";\n            $sends[] = \"Host: {$url['host']}\";\n            foreach ($headers as $header) {\n                $sends[] = trim($header, \"\\r\\n\");\n            }\n            $sends[] = 'Connection: Close';\n            if ($cookies) {\n                $sends[] = 'Cookie: ' . implode('; ', $cookies);\n            }\n            if ($method === 'POST') {\n                $sends[] = 'Content-Type: application/x-www-form-urlencoded';\n                $sends[] = 'Content-Length: ' . strlen($body);\n            }\n            $sends[] = \"\\r\\n\" . $body;\n\n            stream_set_timeout($stream, 300);\n            fputs($stream, join(\"\\r\\n\", $sends) . \"\\r\\n\");\n\n            while (($res = trim(fgets($stream))) !== '') {\n                // find redirect\n                if (preg_match('/^Location: (.+)$/i', $res, $m)) {\n                    $data['url'] = $m[1];\n                }\n                // fetch cookie\n                if (strpos($res, 'Set-Cookie:') === 0) {\n                    $domain = $url['host'];\n                    if (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n                        if (!empty($c1[2])) {\n                            $domain = trim($c1[2]);\n                        }\n                        if (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n                            $data['cookies'][$domain] = $c2[1];\n                        }\n                    }\n                }\n                // is seekable url\n                if (preg_match('/^(Accept-Ranges|Content-Range): bytes/i', $res)) {\n                    elFinder::$seekableUrlFps[(int)$stream] = true;\n                }\n            }\n            if ($data['url']) {\n                ++$data['cnt'];\n                fclose($stream);\n\n                return self::getStreamByUrl($data, $redirectLimit);\n            }\n\n            return $stream;\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the fetch cookie file for curl.\n     *\n     * @return string  The fetch cookie file.\n     */\n    public function getFetchCookieFile()\n    {\n        $file = '';\n        if ($tmpDir = $this->getTempDir()) {\n            $file = $tmpDir . '/.elFinderAnonymousCookie';\n        }\n        return $file;\n    }\n\n    /**\n     * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n     *\n     * @param resource $curl\n     * @param array    $options\n     * @param array    $headers\n     * @param array    $postData\n     *\n     * @throws \\Exception\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public static function curlExec($curl, $options = array(), $headers = array(), $postData = array())\n    {\n        $followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'));\n        if ($followLocation) {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($options) {\n            curl_setopt_array($curl, $options);\n        }\n\n        if ($headers) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($curl);\n\n        if (!$followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n            if ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers, 'postData' => $postData))) {\n                $result = stream_get_contents($stream);\n            }\n        }\n\n        if ($result === false) {\n            if (curl_errno($curl)) {\n                throw new \\Exception('curl_exec() failed: ' . curl_error($curl));\n            } else {\n                throw new \\Exception('curl_exec(): empty response');\n            }\n        }\n\n        curl_close($curl);\n\n        return $result;\n    }\n\n    /**\n     * Return bool that current request was aborted by client side\n     *\n     * @return boolean\n     */\n    public static function aborted()\n    {\n        if ($file = self::$abortCheckFile) {\n            (version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n            if (!is_file($file)) {\n                // GC (expire 12h)\n                list($ptn) = explode('elfreq', $file);\n                self::GlobGC($ptn . 'elfreq*', 43200);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return array [\"name without extention\", \"extention\"] by filename\n     *\n     * @param string $name\n     *\n     * @return array\n     */\n    public static function splitFileExtention($name)\n    {\n        if (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,10})$/i', $name, $m)) {\n            return array((string)$m[1], $m[2]);\n        } else {\n            return array($name, '');\n        }\n    }\n\n    /**\n     * Gets the memory size by imageinfo.\n     *\n     * @param      array $imgInfo array that result of getimagesize()\n     *\n     * @return     integer  The memory size by imageinfo.\n     */\n    public static function getMemorySizeByImageInfo($imgInfo)\n    {\n        $width = $imgInfo[0];\n        $height = $imgInfo[1];\n        $bits = isset($imgInfo['bits']) ? $imgInfo['bits'] : 24;\n        $channels = isset($imgInfo['channels']) ? $imgInfo['channels'] : 3;\n        return round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n    }\n\n    /**\n     * Auto expand memory for GD processing\n     *\n     * @param      array $imgInfos The image infos\n     */\n    public static function expandMemoryForGD($imgInfos)\n    {\n        if (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n            if (!is_array($imgInfos[0])) {\n                $imgInfos = array($imgInfos);\n            }\n            $limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n            $memLimit = self::getIniBytes('memory_limit');\n            $needs = 0;\n            foreach ($imgInfos as $info) {\n                $needs += self::getMemorySizeByImageInfo($info);\n            }\n            $needs += memory_get_usage();\n            if ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n                ini_set('memory_limit', $needs);\n            }\n        }\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     * @param  null   $cwd          cwd\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    public static function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n\n        static $allowed = null;\n\n        if ($allowed === null) {\n            if ($allowed = function_exists('proc_open')) {\n                if ($disabled = ini_get('disable_functions')) {\n                    $funcs = array_map('trim', explode(',', $disabled));\n                    $allowed = !in_array('proc_open', $funcs);\n                }\n            }\n        }\n\n        if (!$allowed) {\n            $return_var = -1;\n            return $return_var;\n        }\n\n        if (!$command) {\n            $return_var = 0;\n            return $return_var;\n        }\n\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),  // stdin\n            1 => array(\"pipe\", \"w\"),  // stdout\n            2 => array(\"pipe\", \"w\")   // stderr\n        );\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd, null);\n\n        if (is_resource($process)) {\n            stream_set_blocking($pipes[1], 0);\n            stream_set_blocking($pipes[2], 0);\n\n            fclose($pipes[0]);\n\n            $tmpout = '';\n            $tmperr = '';\n            while (feof($pipes[1]) === false || feof($pipes[2]) === false) {\n                elFinder::extendTimeLimit();\n                $read = array($pipes[1], $pipes[2]);\n                $write = null;\n                $except = null;\n                $ret = stream_select($read, $write, $except, 1);\n                if ($ret === false) {\n                    // error\n                    break;\n                } else if ($ret === 0) {\n                    // timeout\n                    continue;\n                } else {\n                    foreach ($read as $sock) {\n                        if ($sock === $pipes[1]) {\n                            $tmpout .= fread($sock, 4096);\n                        } else if ($sock === $pipes[2]) {\n                            $tmperr .= fread($sock, 4096);\n                        }\n                    }\n                }\n            }\n\n            fclose($pipes[1]);\n            fclose($pipes[2]);\n\n            $output = $tmpout;\n            $error_output = $tmperr;\n            $return_var = proc_close($process);\n\n        } else {\n            $return_var = -1;\n        }\n\n        return $return_var;\n\n    }\n\n    /***************************************************************************/\n    /*                                 callbacks                               */\n    /***************************************************************************/\n\n    /**\n     * Get command name of binded \"commandName.subName\"\n     *\n     * @param string $cmd\n     *\n     * @return string\n     */\n    protected static function getCmdOfBind($cmd)\n    {\n        list($ret) = explode('.', $cmd);\n        return trim($ret);\n    }\n\n    /**\n     * Add subName to commandName\n     *\n     * @param string $cmd\n     * @param string $sub\n     *\n     * @return string\n     */\n    protected static function addSubToBindName($cmd, $sub)\n    {\n        return $cmd . '.' . trim($sub);\n    }\n\n    /**\n     * Remove a file if connection is disconnected\n     *\n     * @param string $file\n     */\n    public static function rmFileInDisconnected($file)\n    {\n        (connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Call back function on shutdown\n     *  - delete files in $GLOBALS['elFinderTempFiles']\n     */\n    public static function onShutdown()\n    {\n        self::$abortCheckFile = null;\n        if (!empty($GLOBALS['elFinderTempFps'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFps']) as $fp) {\n                is_resource($fp) && fclose($fp);\n            }\n        }\n        if (!empty($GLOBALS['elFinderTempFiles'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $f) {\n                is_file($f) && is_writable($f) && unlink($f);\n            }\n        }\n    }\n\n    /**\n     * Garbage collection with glob\n     *\n     * @param string  $pattern\n     * @param integer $time\n     */\n    public static function GlobGC($pattern, $time)\n    {\n        $now = time();\n        foreach (glob($pattern) as $file) {\n            (filemtime($file) < ($now - $time)) && unlink($file);\n        }\n    }\n\n} // END class\n\n/**\n * Custom exception class for aborting request\n */\nclass elFinderAbortException extends Exception\n{\n}\n\nclass elFinderTriggerException extends Exception\n{\n}", "<?php\n\n/**\n * Base class for elFinder volume.\n * Provide 2 layers:\n *  1. Public API (commands)\n *  2. abstract fs API\n * All abstract methods begin with \"_\"\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n * @method netmountPrepare(array $options)\n * @method postNetmount(array $options)\n */\nabstract class elFinderVolumeDriver\n{\n\n    /**\n     * Net mount key\n     *\n     * @var string\n     **/\n    public $netMountKey = '';\n\n    /**\n     * Request args\n     * $_POST or $_GET values\n     *\n     * @var array\n     */\n    protected $ARGS = array();\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'a';\n\n    /**\n     * Volume id - used as prefix for files hashes\n     *\n     * @var string\n     **/\n    protected $id = '';\n\n    /**\n     * Flag - volume \"mounted\" and available\n     *\n     * @var bool\n     **/\n    protected $mounted = false;\n\n    /**\n     * Root directory path\n     *\n     * @var string\n     **/\n    protected $root = '';\n\n    /**\n     * Root basename | alias\n     *\n     * @var string\n     **/\n    protected $rootName = '';\n\n    /**\n     * Default directory to open\n     *\n     * @var string\n     **/\n    protected $startPath = '';\n\n    /**\n     * Base URL\n     *\n     * @var string\n     **/\n    protected $URL = '';\n\n    /**\n     * Path to temporary directory\n     *\n     * @var string\n     */\n    protected $tmp;\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector Path/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector URL/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkUrl = '';\n\n    /**\n     * Thumbnails dir path\n     *\n     * @var string\n     **/\n    protected $tmbPath = '';\n\n    /**\n     * Is thumbnails dir writable\n     *\n     * @var bool\n     **/\n    protected $tmbPathWritable = false;\n\n    /**\n     * Thumbnails base URL\n     *\n     * @var string\n     **/\n    protected $tmbURL = '';\n\n    /**\n     * Thumbnails size in px\n     *\n     * @var int\n     **/\n    protected $tmbSize = 48;\n\n    /**\n     * Image manipulation lib name\n     * auto|imagick|gd|convert\n     *\n     * @var string\n     **/\n    protected $imgLib = 'auto';\n\n    /**\n     * Video to Image converter\n     *\n     * @var array\n     */\n    protected $imgConverter = array();\n\n    /**\n     * Library to crypt files name\n     *\n     * @var string\n     **/\n    protected $cryptLib = '';\n\n    /**\n     * Archivers config\n     *\n     * @var array\n     **/\n    protected $archivers = array(\n        'create' => array(),\n        'extract' => array()\n    );\n\n    /**\n     * Static var of $this->options['maxArcFilesSize']\n     * \n     * @var int|string\n     */\n    protected static $maxArcFilesSize;\n\n    /**\n     * Server character encoding\n     *\n     * @var string or null\n     **/\n    protected $encoding = null;\n\n    /**\n     * How many subdirs levels return for tree\n     *\n     * @var int\n     **/\n    protected $treeDeep = 1;\n\n    /**\n     * Errors from last failed action\n     *\n     * @var array\n     **/\n    protected $error = array();\n\n    /**\n     * Today 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $today = 0;\n\n    /**\n     * Yesterday 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $yesterday = 0;\n\n    /**\n     * Force make dirctory on extract\n     *\n     * @var int\n     **/\n    protected $extractToNewdir = 'auto';\n\n    /**\n     * Object configuration\n     *\n     * @var array\n     **/\n    protected $options = array(\n        // Driver ID (Prefix of volume ID), Normally, the value specified for each volume driver is used.\n        'driverId' => '',\n        // Id (Suffix of volume ID), Normally, the number incremented according to the specified number of volumes is used.\n        'id' => '',\n        // revision id of root directory that uses for caching control of root stat\n        'rootRev' => '',\n        // driver type it uses volume root's CSS class name. e.g. 'group' -> Adds 'elfinder-group' to CSS class name.\n        'type' => '',\n        // root directory path\n        'path' => '',\n        // Folder hash value on elFinder to be the parent of this volume\n        'phash' => '',\n        // Folder hash value on elFinder to trash bin of this volume, it require 'copyJoin' to true\n        'trashHash' => '',\n        // open this path on initial request instead of root path\n        'startPath' => '',\n        // how many subdirs levels return per request\n        'treeDeep' => 1,\n        // root url, not set to URL via the connector. If you want to hide the file URL, do not set this value. (replacement for old \"fileURL\" option)\n        'URL' => '',\n        // enable onetime URL to a file - (true, false, 'auto' (true if a temporary directory is available) or callable (A function that return onetime URL))\n        'onetimeUrl' => 'auto',\n        // directory link url to own manager url with folder hash (`true`, `false`, `'hide'`(No show) or default `'auto'`: URL is empty then `true` else `false`)\n        'dirUrlOwn' => 'auto',\n        // directory separator. required by client to show paths correctly\n        'separator' => DIRECTORY_SEPARATOR,\n        // Use '/' as directory separator when the path hash encode/decode on the Windows server too\n        'winHashFix' => false,\n        // Server character encoding (default is '': UTF-8)\n        'encoding' => '',\n        // for convert character encoding (default is '': Not change locale)\n        'locale' => '',\n        // URL of volume icon image\n        'icon' => '',\n        // CSS Class of volume root in tree\n        'rootCssClass' => '',\n        // Items to disable session caching\n        'noSessionCache' => array(),\n        // enable i18n folder name that convert name to elFinderInstance.messages['folder_'+name]\n        'i18nFolderName' => false,\n        // Search timeout (sec)\n        'searchTimeout' => 30,\n        // Search exclusion directory regex pattern (require demiliter e.g. '#/path/to/exclude_directory#i')\n        'searchExDirReg' => '',\n        // library to crypt/uncrypt files names (not implemented)\n        'cryptLib' => '',\n        // how to detect files mimetypes. (auto/internal/finfo/mime_content_type)\n        'mimeDetect' => 'auto',\n        // mime.types file path (for mimeDetect==internal)\n        'mimefile' => '',\n        // Static extension/MIME of general server side scripts to security issues\n        'staticMineMap' => array(\n            'php:*' => 'text/x-php',\n            'pht:*' => 'text/x-php',\n            'php3:*' => 'text/x-php',\n            'php4:*' => 'text/x-php',\n            'php5:*' => 'text/x-php',\n            'php7:*' => 'text/x-php',\n            'phtml:*' => 'text/x-php',\n            'phar:*' => 'text/x-php',\n            'cgi:*' => 'text/x-httpd-cgi',\n            'pl:*' => 'text/x-perl',\n            'asp:*' => 'text/x-asap',\n            'aspx:*' => 'text/x-asap',\n            'py:*' => 'text/x-python',\n            'rb:*' => 'text/x-ruby',\n            'jsp:*' => 'text/x-jsp'\n        ),\n        // mime type normalize map : Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'mimeMap' => array(\n            'md:application/x-genesis-rom' => 'text/x-markdown',\n            'md:text/plain' => 'text/x-markdown',\n            'markdown:text/plain' => 'text/x-markdown',\n            'css:text/x-asm' => 'text/css',\n            'css:text/plain' => 'text/css',\n            'csv:text/plain' => 'text/csv',\n            'java:text/x-c' => 'text/x-java-source',\n            'json:text/plain' => 'application/json',\n            'sql:text/plain' => 'text/x-sql',\n            'rtf:text/rtf' => 'application/rtf',\n            'rtfd:text/rtfd' => 'application/rtfd',\n            'ico:image/vnd.microsoft.icon' => 'image/x-icon',\n            'svg:text/plain' => 'image/svg+xml',\n            'pxd:application/octet-stream' => 'image/x-pixlr-data',\n            'dng:image/tiff' => 'image/x-adobe-dng',\n            'sketch:application/zip' => 'image/x-sketch',\n            'sketch:application/octet-stream' => 'image/x-sketch',\n            'xcf:application/octet-stream' => 'image/x-xcf',\n            'amr:application/octet-stream' => 'audio/amr',\n            'm4a:video/mp4' => 'audio/mp4',\n            'oga:application/ogg' => 'audio/ogg',\n            'ogv:application/ogg' => 'video/ogg',\n            'zip:application/x-zip' => 'application/zip',\n            'm3u8:text/plain' => 'application/x-mpegURL',\n            'mpd:text/plain' => 'application/dash+xml',\n            'mpd:application/xml' => 'application/dash+xml',\n            '*:application/x-dosexec' => 'application/x-executable',\n            'doc:application/vnd.ms-office' => 'application/msword',\n            'xls:application/vnd.ms-office' => 'application/vnd.ms-excel',\n            'ppt:application/vnd.ms-office' => 'application/vnd.ms-powerpoint',\n            'yml:text/plain' => 'text/x-yaml',\n            'ai:application/pdf' => 'application/postscript',\n            'cgm:text/plain' => 'image/cgm',\n            'dxf:text/plain' => 'image/vnd.dxf',\n            'dds:application/octet-stream' => 'image/vnd-ms.dds',\n            'hpgl:text/plain' => 'application/vnd.hp-hpgl',\n            'igs:text/plain' => 'model/iges',\n            'iges:text/plain' => 'model/iges',\n            'plt:application/octet-stream' => 'application/plt',\n            'plt:text/plain' => 'application/plt',\n            'sat:text/plain' => 'application/sat',\n            'step:text/plain' => 'application/step',\n            'stp:text/plain' => 'application/step'\n        ),\n        // An option to add MimeMap to the `mimeMap` option\n        // Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'additionalMimeMap' => array(),\n        // MIME-Type of filetype detected as unknown\n        'mimeTypeUnknown' => 'application/octet-stream',\n        // MIME regex of send HTTP header \"Content-Disposition: inline\" or allow preview in quicklook\n        // '.' is allow inline of all of MIME types\n        // '$^' is not allow inline of all of MIME types\n        'dispInlineRegex' => '^(?:(?:video|audio)|image/(?!.+\\+xml)|application/(?:ogg|x-mpegURL|dash\\+xml)|(?:text/plain|application/pdf)$)',\n        // temporary content URL's base path\n        'tmpLinkPath' => '',\n        // temporary content URL's base URL\n        'tmpLinkUrl' => '',\n        // directory for thumbnails\n        'tmbPath' => '.tmb',\n        // mode to create thumbnails dir\n        'tmbPathMode' => 0777,\n        // thumbnails dir URL. Set it if store thumbnails outside root directory\n        'tmbURL' => '',\n        // thumbnails size (px)\n        'tmbSize' => 48,\n        // thumbnails crop (true - crop, false - scale image to fit thumbnail size)\n        'tmbCrop' => true,\n        // thumbnail URL require custom data as the GET query\n        'tmbReqCustomData' => false,\n        // thumbnails background color (hex #rrggbb or 'transparent')\n        'tmbBgColor' => 'transparent',\n        // image rotate fallback background color (hex #rrggbb)\n        'bgColorFb' => '#ffffff',\n        // image manipulations library (imagick|gd|convert|auto|none, none - Does not check the image library at all.)\n        'imgLib' => 'auto',\n        // Fallback self image to thumbnail (nothing imgLib)\n        'tmbFbSelf' => true,\n        // Video to Image converters ['TYPE or MIME' => ['func' => function($file){ /* Converts $file to Image */ return true; }, 'maxlen' => (int)TransferLength]]\n        'imgConverter' => array(),\n        // Max length of transfer to image converter\n        'tmbVideoConvLen' => 10000000,\n        // Captre point seccond\n        'tmbVideoConvSec' => 6,\n        // Life time (hour) for thumbnail garbage collection (\"0\" means no GC)\n        'tmbGcMaxlifeHour' => 0,\n        // Percentage of garbage collection executed for thumbnail creation command (\"1\" means \"1%\")\n        'tmbGcPercentage' => 1,\n        // Resource path of fallback icon images defailt: php/resouces\n        'resourcePath' => '',\n        // Jpeg image saveing quality\n        'jpgQuality' => 100,\n        // Save as progressive JPEG on image editing\n        'jpgProgressive' => true,\n        // enable to get substitute image with command `dim`\n        'substituteImg' => true,\n        // on paste file -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'copyOverwrite' => true,\n        // if true - join new and old directories content on paste\n        'copyJoin' => true,\n        // on upload -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'uploadOverwrite' => true,\n        // mimetypes allowed to upload\n        'uploadAllow' => array(),\n        // mimetypes not allowed to upload\n        'uploadDeny' => array(),\n        // order to process uploadAllow and uploadDeny options\n        'uploadOrder' => array('deny', 'allow'),\n        // maximum upload file size. NOTE - this is size for every uploaded files\n        'uploadMaxSize' => 0,\n        // Maximum number of folders that can be created at one time. (0: unlimited)\n        'uploadMaxMkdirs' => 0,\n        // maximum number of chunked upload connection. `-1` to disable chunked upload\n        'uploadMaxConn' => 3,\n        // maximum get file size. NOTE - Maximum value is 50% of PHP memory_limit\n        'getMaxSize' => 0,\n        // files dates format\n        'dateFormat' => 'j M Y H:i',\n        // files time format\n        'timeFormat' => 'H:i',\n        // if true - every folder will be check for children folders, -1 - every folder will be check asynchronously, false -  all folders will be marked as having subfolders\n        'checkSubfolders' => true, // true, false or -1\n        // allow to copy from this volume to other ones?\n        'copyFrom' => true,\n        // allow to copy from other volumes to this one?\n        'copyTo' => true,\n        // cmd duplicate suffix format e.g. '_%s_' to without spaces\n        'duplicateSuffix' => ' %s ',\n        // unique name numbar format e.g. '(%d)' to (1), (2)...\n        'uniqueNumFormat' => '%d',\n        // list of commands disabled on this root\n        'disabled' => array(),\n        // enable file owner, group & mode info, `false` to inactivate \"chmod\" command.\n        'statOwner' => false,\n        // allow exec chmod of read-only files\n        'allowChmodReadOnly' => false,\n        // regexp or function name to validate new file name\n        'acceptedName' => '/^[^\\.].*/', // Notice: overwritten it in some volume drivers contractor\n        // regexp or function name to validate new directory name\n        'acceptedDirname' => '', // used `acceptedName` if empty value\n        // function/class method to control files permissions\n        'accessControl' => null,\n        // some data required by access control\n        'accessControlData' => null,\n        // root stat that return without asking the system when mounted and not the current volume. Query to the system with false. array|false\n        'rapidRootStat' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false,\n            'size' => 0,  // Unknown\n            'ts' => 0,    // Unknown\n            'dirs' => -1, // Check on demand for subdirectories\n            'mime' => 'directory'\n        ),\n        // default permissions.\n        'defaults' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false\n        ),\n        // files attributes\n        'attributes' => array(),\n        // max allowed archive files size (0 - no limit)\n        'maxArcFilesSize' => '2G',\n        // Allowed archive's mimetypes to create. Leave empty for all available types.\n        'archiveMimes' => array(),\n        // Manual config for archivers. See example below. Leave empty for auto detect\n        'archivers' => array(),\n        // Use Archive function for remote volume\n        'useRemoteArchive' => false,\n        // plugin settings\n        'plugin' => array(),\n        // Is support parent directory time stamp update on add|remove|rename item\n        // Default `null` is auto detection that is LocalFileSystem, FTP or Dropbox are `true`\n        'syncChkAsTs' => null,\n        // Long pooling sync checker function for syncChkAsTs is true\n        // Calls with args (TARGET DIRCTORY PATH, STAND-BY(sec), OLD TIMESTAMP, VOLUME DRIVER INSTANCE, ELFINDER INSTANCE)\n        // This function must return the following values. Changed: New Timestamp or Same: Old Timestamp or Error: false\n        // Default `null` is try use elFinderVolumeLocalFileSystem::localFileSystemInotify() on LocalFileSystem driver\n        // another driver use elFinder stat() checker\n        'syncCheckFunc' => null,\n        // Long polling sync stand-by time (sec)\n        'plStandby' => 30,\n        // Sleep time (sec) for elFinder stat() checker (syncChkAsTs is true)\n        'tsPlSleep' => 10,\n        // Sleep time (sec) for elFinder ls() checker (syncChkAsTs is false)\n        'lsPlSleep' => 30,\n        // Client side sync interval minimum (ms)\n        // Default `null` is auto set to ('tsPlSleep' or 'lsPlSleep') * 1000\n        // `0` to disable auto sync\n        'syncMinMs' => null,\n        // required to fix bug on macos\n        // However, we recommend to use the Normalizer plugin instead this option\n        'utf8fix' => false,\n        //                           \u0439                 \u0451              \u0419               \u0401              \u00d8         \u00c5\n        'utf8patterns' => array(\"\\u0438\\u0306\", \"\\u0435\\u0308\", \"\\u0418\\u0306\", \"\\u0415\\u0308\", \"\\u00d8A\", \"\\u030a\"),\n        'utf8replace' => array(\"\\u0439\", \"\\u0451\", \"\\u0419\", \"\\u0401\", \"\\u00d8\", \"\\u00c5\"),\n        // cache control HTTP headers for commands `file` and  `get`\n        'cacheHeaders' => array(\n            'Cache-Control: max-age=3600',\n            'Expires:',\n            'Pragma:'\n        ),\n        // Header to use to accelerate sending local files to clients (e.g. 'X-Sendfile', 'X-Accel-Redirect')\n        'xsendfile' => '',\n        // Root path to xsendfile target. Probably, this is required for 'X-Accel-Redirect' on Nginx.\n        'xsendfilePath' => ''\n    );\n\n    /**\n     * Defaults permissions\n     *\n     * @var array\n     **/\n    protected $defaults = array(\n        'read' => true,\n        'write' => true,\n        'locked' => false,\n        'hidden' => false\n    );\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $attributes = array();\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $access = null;\n\n    /**\n     * Mime types allowed to upload\n     *\n     * @var array\n     **/\n    protected $uploadAllow = array();\n\n    /**\n     * Mime types denied to upload\n     *\n     * @var array\n     **/\n    protected $uploadDeny = array();\n\n    /**\n     * Order to validate uploadAllow and uploadDeny\n     *\n     * @var array\n     **/\n    protected $uploadOrder = array();\n\n    /**\n     * Maximum allowed upload file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $uploadMaxSize = 0;\n\n    /**\n     * Run time setting of overwrite items on upload\n     *\n     * @var string\n     */\n    protected $uploadOverwrite = true;\n\n    /**\n     * Maximum allowed get file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $getMaxSize = -1;\n\n    /**\n     * Mimetype detect method\n     *\n     * @var string\n     **/\n    protected $mimeDetect = 'auto';\n\n    /**\n     * Flag - mimetypes from externail file was loaded\n     *\n     * @var bool\n     **/\n    private static $mimetypesLoaded = false;\n\n    /**\n     * Finfo resource for mimeDetect == 'finfo'\n     *\n     * @var resource\n     **/\n    protected $finfo = null;\n\n    /**\n     * List of disabled client's commands\n     *\n     * @var array\n     **/\n    protected $disabled = array();\n\n    /**\n     * overwrite extensions/mimetypes to mime.types\n     *\n     * @var array\n     **/\n    protected static $mimetypes = array(\n        // applications\n        'exe' => 'application/x-executable',\n        'jar' => 'application/x-jar',\n        // archives\n        'gz' => 'application/x-gzip',\n        'tgz' => 'application/x-gzip',\n        'tbz' => 'application/x-bzip2',\n        'rar' => 'application/x-rar',\n        // texts\n        'php' => 'text/x-php',\n        'js' => 'text/javascript',\n        'rtfd' => 'application/rtfd',\n        'py' => 'text/x-python',\n        'rb' => 'text/x-ruby',\n        'sh' => 'text/x-shellscript',\n        'pl' => 'text/x-perl',\n        'xml' => 'text/xml',\n        'c' => 'text/x-csrc',\n        'h' => 'text/x-chdr',\n        'cpp' => 'text/x-c++src',\n        'hh' => 'text/x-c++hdr',\n        'md' => 'text/x-markdown',\n        'markdown' => 'text/x-markdown',\n        'yml' => 'text/x-yaml',\n        // images\n        'bmp' => 'image/x-ms-bmp',\n        'tga' => 'image/x-targa',\n        'xbm' => 'image/xbm',\n        'pxm' => 'image/pxm',\n        //audio\n        'wav' => 'audio/wav',\n        // video\n        'dv' => 'video/x-dv',\n        'wm' => 'video/x-ms-wmv',\n        'ogm' => 'video/ogg',\n        'm2ts' => 'video/MP2T',\n        'mts' => 'video/MP2T',\n        'ts' => 'video/MP2T',\n        'm3u8' => 'application/x-mpegURL',\n        'mpd' => 'application/dash+xml'\n    );\n\n    /**\n     * Directory separator - required by client\n     *\n     * @var string\n     **/\n    protected $separator = DIRECTORY_SEPARATOR;\n\n    /**\n     * Directory separator for decode/encode hash\n     *\n     * @var string\n     **/\n    protected $separatorForHash = '';\n\n    /**\n     * System Root path (Unix like: '/', Windows: '\\', 'C:\\' or 'D:\\'...)\n     *\n     * @var string\n     **/\n    protected $systemRoot = DIRECTORY_SEPARATOR;\n\n    /**\n     * Mimetypes allowed to display\n     *\n     * @var array\n     **/\n    protected $onlyMimes = array();\n\n    /**\n     * Store files moved or overwrited files info\n     *\n     * @var array\n     **/\n    protected $removed = array();\n\n    /**\n     * Store files added files info\n     *\n     * @var array\n     **/\n    protected $added = array();\n\n    /**\n     * Cache storage\n     *\n     * @var array\n     **/\n    protected $cache = array();\n\n    /**\n     * Cache by folders\n     *\n     * @var array\n     **/\n    protected $dirsCache = array();\n\n    /**\n     * You should use `$this->sessionCache['subdirs']` instead\n     *\n     * @var array\n     * @deprecated\n     */\n    protected $subdirsCache = array();\n\n    /**\n     * This volume session cache\n     *\n     * @var array\n     */\n    protected $sessionCache;\n\n    /**\n     * Session caching item list\n     *\n     * @var array\n     */\n    protected $sessionCaching = array('rootstat' => true, 'subdirs' => true);\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * Search start time\n     *\n     * @var int\n     */\n    protected $searchStart;\n\n    /**\n     * Current query word on doSearch\n     *\n     * @var array\n     **/\n    protected $doSearchCurrentQuery = array();\n\n    /**\n     * Is root modified (for clear root stat cache)\n     *\n     * @var bool\n     */\n    protected $rootModified = false;\n\n    /**\n     * Is disable of command `url`\n     *\n     * @var string\n     */\n    protected $disabledGetUrl = false;\n\n    /**\n     * Accepted filename validator\n     *\n     * @var string | callable\n     */\n    protected $nameValidator;\n\n    /**\n     * Accepted dirname validator\n     *\n     * @var string | callable\n     */\n    protected $dirnameValidator;\n\n    /**\n     * This request require online state\n     *\n     * @var boolean\n     */\n    protected $needOnline;\n\n    /*********************************************************************/\n    /*                            INITIALIZATION                         */\n    /*********************************************************************/\n\n    /**\n     * Sets the need online.\n     *\n     * @param  boolean  $state  The state\n     */\n    public function setNeedOnline($state = null)\n    {\n        if ($state !== null) {\n            $this->needOnline = (bool)$state;\n            return;\n        }\n\n        $need = false;\n        $arg = $this->ARGS;\n        $id = $this->id;\n\n        $target = !empty($arg['target'])? $arg['target'] : (!empty($arg['dst'])? $arg['dst'] : '');\n        $targets = !empty($arg['targets'])? $arg['targets'] : array();\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        if ($target && strpos($target, $id) === 0) {\n            $need = true;\n        } else if ($targets) {\n            foreach($targets as $t) {\n                if ($t && strpos($t, $id) === 0) {\n                    $need = true;\n                    break;\n                }\n            }\n        }\n\n        $this->needOnline = $need;\n    }\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function init()\n    {\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     * By default set thumbnails path and image manipulation library.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        // set thumbnails path\n        $path = $this->options['tmbPath'];\n        if ($path) {\n            if (!file_exists($path)) {\n                if (mkdir($path)) {\n                    chmod($path, $this->options['tmbPathMode']);\n                } else {\n                    $path = '';\n                }\n            }\n\n            if (is_dir($path) && is_readable($path)) {\n                $this->tmbPath = $path;\n                $this->tmbPathWritable = is_writable($path);\n            }\n        }\n        // set resouce path\n        if (!is_dir($this->options['resourcePath'])) {\n            $this->options['resourcePath'] = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'resources';\n        }\n\n        // set image manipulation library\n        $type = preg_match('/^(imagick|gd|convert|auto|none)$/i', $this->options['imgLib'])\n            ? strtolower($this->options['imgLib'])\n            : 'auto';\n\n        if ($type === 'none') {\n            $this->imgLib = '';\n        } else {\n            if (($type === 'imagick' || $type === 'auto') && extension_loaded('imagick')) {\n                $this->imgLib = 'imagick';\n            } else if (($type === 'gd' || $type === 'auto') && function_exists('gd_info')) {\n                $this->imgLib = 'gd';\n            } else {\n                $convertCache = 'imgLibConvert';\n                if (($convertCmd = $this->session->get($convertCache, false)) !== false) {\n                    $this->imgLib = $convertCmd;\n                } else {\n                    $this->imgLib = ($this->procExec(ELFINDER_CONVERT_PATH . ' -version') === 0) ? 'convert' : '';\n                    $this->session->set($convertCache, $this->imgLib);\n                }\n            }\n            if ($type !== 'auto' && $this->imgLib === '') {\n                // fallback\n                $this->imgLib = extension_loaded('imagick') ? 'imagick' : (function_exists('gd_info') ? 'gd' : '');\n            }\n        }\n\n        // check video to img converter\n        if (!empty($this->options['imgConverter']) && is_array($this->options['imgConverter'])) {\n            foreach ($this->options['imgConverter'] as $_type => $_converter) {\n                if (isset($_converter['func'])) {\n                    $this->imgConverter[strtolower($_type)] = $_converter;\n                }\n            }\n        }\n        if (!isset($this->imgConverter['video'])) {\n            $videoLibCache = 'videoLib';\n            if (($videoLibCmd = $this->session->get($videoLibCache, false)) === false) {\n                $videoLibCmd = ($this->procExec(ELFINDER_FFMPEG_PATH . ' -version') === 0) ? 'ffmpeg' : '';\n                $this->session->set($videoLibCache, $videoLibCmd);\n            }\n            if ($videoLibCmd) {\n                $this->imgConverter['video'] = array(\n                    'func' => array($this, $videoLibCmd . 'ToImg'),\n                    'maxlen' => $this->options['tmbVideoConvLen']\n                );\n            }\n        }\n\n        // check onetimeUrl\n        if (strtolower($this->options['onetimeUrl']) === 'auto') {\n            $this->options['onetimeUrl'] = elFinder::getStaticVar('commonTempPath')? true : false;\n        }\n\n        // check archivers\n        if (empty($this->archivers['create'])) {\n            $this->disabled[] = 'archive';\n        }\n        if (empty($this->archivers['extract'])) {\n            $this->disabled[] = 'extract';\n        }\n        $_arc = $this->getArchivers();\n        if (empty($_arc['create'])) {\n            $this->disabled[] = 'zipdl';\n        }\n\n        if ($this->options['maxArcFilesSize']) {\n            $this->options['maxArcFilesSize'] = elFinder::getIniBytes('', $this->options['maxArcFilesSize']);\n        }\n        self::$maxArcFilesSize = $this->options['maxArcFilesSize'];\n\n        // check 'statOwner' for command `chmod`\n        if (empty($this->options['statOwner'])) {\n            $this->disabled[] = 'chmod';\n        }\n\n        // check 'mimeMap'\n        if (!is_array($this->options['mimeMap'])) {\n            $this->options['mimeMap'] = array();\n        }\n        if (is_array($this->options['staticMineMap']) && $this->options['staticMineMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['staticMineMap']);\n        }\n        if (is_array($this->options['additionalMimeMap']) && $this->options['additionalMimeMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['additionalMimeMap']);\n        }\n\n        // check 'url' in disabled commands\n        if (in_array('url', $this->disabled)) {\n            $this->disabledGetUrl = true;\n        }\n\n        // set run time setting uploadOverwrite\n        $this->uploadOverwrite = $this->options['uploadOverwrite'];\n    }\n\n    /**\n     * @deprecated\n     */\n    protected function sessionRestart()\n    {\n        $this->sessionCache = $this->session->start()->get($this->id, array());\n        return true;\n    }\n\n    /*********************************************************************/\n    /*                              PUBLIC API                           */\n    /*********************************************************************/\n\n    /**\n     * Return driver id. Used as a part of volume id.\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function driverId()\n    {\n        return $this->driverId;\n    }\n\n    /**\n     * Return volume id\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function id()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Assign elFinder session wrapper object\n     *\n     * @param  $session  elFinderSessionInterface\n     */\n    public function setSession($session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Get elFinder sesson wrapper object\n     *\n     * @return object  The session object\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Save session cache data\n     * Calls this function before umount this volume on elFinder::exec()\n     *\n     * @return void\n     */\n    public function saveSessionCache()\n    {\n        $this->session->set($this->id, $this->sessionCache);\n    }\n\n    /**\n     * Return debug info for client\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function debug()\n    {\n        return array(\n            'id' => $this->id(),\n            'name' => strtolower(substr(get_class($this), strlen('elfinderdriver'))),\n            'mimeDetect' => $this->mimeDetect,\n            'imgLib' => $this->imgLib\n        );\n    }\n\n    /**\n     * chmod a file or folder\n     *\n     * @param  string $hash file or folder hash to chmod\n     * @param  string $mode octal string representing new permissions\n     *\n     * @return array|false\n     * @author David Bartle\n     **/\n    public function chmod($hash, $mode)\n    {\n        if ($this->commandDisabled('chmod')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$this->options['allowChmodReadOnly']) {\n            if (!$this->attr($this->decode($hash), 'write', null, ($file['mime'] === 'directory'))) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $write = $file['write'];\n\n        if ($this->convEncOut(!$this->_chmod($this->convEncIn($path), $mode))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n        }\n\n        $this->clearstatcache();\n        if ($path == $this->root) {\n            $this->rootModified = true;\n        }\n\n        if ($file = $this->stat($path)) {\n            $files = array($file);\n            if ($file['mime'] === 'directory' && $write !== $file['write']) {\n                foreach ($this->getScandir($path) as $stat) {\n                    if ($this->mimeAccepted($stat['mime'])) {\n                        $files[] = $stat;\n                    }\n                }\n            }\n            return $files;\n        } else {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n    }\n\n    /**\n     * stat a file or folder for elFinder cmd exec\n     *\n     * @param  string $hash file or folder hash to chmod\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function fstat($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path);\n    }\n\n    /**\n     * Clear PHP stat cache & all of inner stat caches\n     */\n    public function clearstatcache()\n    {\n        clearstatcache();\n        $this->clearcache();\n    }\n\n    /**\n     * Clear inner stat caches for target hash\n     *\n     * @param string $hash\n     */\n    public function clearcaches($hash = null)\n    {\n        if ($hash === null) {\n            $this->clearcache();\n        } else {\n            $path = $this->decode($hash);\n            unset($this->cache[$path], $this->dirsCache[$path]);\n        }\n    }\n\n    /**\n     * \"Mount\" volume.\n     * Return true if volume available for read or write,\n     * false - otherwise\n     *\n     * @param array $opts\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    public function mount(array $opts)\n    {\n        $this->options = array_merge($this->options, $opts);\n\n        if (!isset($this->options['path']) || $this->options['path'] === '') {\n            return $this->setError('Path undefined.');\n        }\n\n        if (!$this->session) {\n            return $this->setError('Session wrapper dose not set. Need to `$volume->setSession(elFinderSessionInterface);` before mount.');\n        }\n        if (!($this->session instanceof elFinderSessionInterface)) {\n            return $this->setError('Session wrapper instance must be \"elFinderSessionInterface\".');\n        }\n\n        // set driverId\n        if (!empty($this->options['driverId'])) {\n            $this->driverId = $this->options['driverId'];\n        }\n\n        $this->id = $this->driverId . (!empty($this->options['id']) ? $this->options['id'] : elFinder::$volumesCnt++) . '_';\n        $this->root = $this->normpathCE($this->options['path']);\n        $this->separator = isset($this->options['separator']) ? $this->options['separator'] : DIRECTORY_SEPARATOR;\n        if (!empty($this->options['winHashFix'])) {\n            $this->separatorForHash = ($this->separator !== '/') ? '/' : '';\n        }\n        $this->systemRoot = isset($this->options['systemRoot']) ? $this->options['systemRoot'] : $this->separator;\n\n        // set ARGS\n        $this->ARGS = $_SERVER['REQUEST_METHOD'] === 'POST' ? $_POST : $_GET;\n\n        $argInit = !empty($this->ARGS['init']);\n\n        // set $this->needOnline\n        if (!is_bool($this->needOnline)) {\n            $this->setNeedOnline();\n        }\n\n        // session cache\n        if ($argInit) {\n            $this->session->set($this->id, array());\n        }\n        $this->sessionCache = $this->session->get($this->id, array());\n\n        // default file attribute\n        $this->defaults = array(\n            'read' => isset($this->options['defaults']['read']) ? !!$this->options['defaults']['read'] : true,\n            'write' => isset($this->options['defaults']['write']) ? !!$this->options['defaults']['write'] : true,\n            'locked' => isset($this->options['defaults']['locked']) ? !!$this->options['defaults']['locked'] : false,\n            'hidden' => isset($this->options['defaults']['hidden']) ? !!$this->options['defaults']['hidden'] : false\n        );\n\n        // root attributes\n        $this->attributes[] = array(\n            'pattern' => '~^' . preg_quote($this->separator) . '$~',\n            'locked' => true,\n            'hidden' => false\n        );\n        // set files attributes\n        if (!empty($this->options['attributes']) && is_array($this->options['attributes'])) {\n\n            foreach ($this->options['attributes'] as $a) {\n                // attributes must contain pattern and at least one rule\n                if (!empty($a['pattern']) || (is_array($a) && count($a) > 1)) {\n                    $this->attributes[] = $a;\n                }\n            }\n        }\n\n        if (!empty($this->options['accessControl']) && is_callable($this->options['accessControl'])) {\n            $this->access = $this->options['accessControl'];\n        }\n\n        $this->today = mktime(0, 0, 0, date('m'), date('d'), date('Y'));\n        $this->yesterday = $this->today - 86400;\n\n        if (!$this->init()) {\n            return false;\n        }\n\n        // set server encoding\n        if (!empty($this->options['encoding']) && strtoupper($this->options['encoding']) !== 'UTF-8') {\n            $this->encoding = $this->options['encoding'];\n        } else {\n            $this->encoding = null;\n        }\n\n        // check some options is arrays\n        $this->uploadAllow = isset($this->options['uploadAllow']) && is_array($this->options['uploadAllow'])\n            ? $this->options['uploadAllow']\n            : array();\n\n        $this->uploadDeny = isset($this->options['uploadDeny']) && is_array($this->options['uploadDeny'])\n            ? $this->options['uploadDeny']\n            : array();\n\n        $this->options['uiCmdMap'] = (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))\n            ? $this->options['uiCmdMap']\n            : array();\n\n        if (is_string($this->options['uploadOrder'])) { // telephat_mode on, compatibility with 1.x\n            $parts = explode(',', isset($this->options['uploadOrder']) ? $this->options['uploadOrder'] : 'deny,allow');\n            $this->uploadOrder = array(trim($parts[0]), trim($parts[1]));\n        } else { // telephat_mode off\n            $this->uploadOrder = !empty($this->options['uploadOrder']) ? $this->options['uploadOrder'] : array('deny', 'allow');\n        }\n\n        if (!empty($this->options['uploadMaxSize'])) {\n            $this->uploadMaxSize = elFinder::getIniBytes('', $this->options['uploadMaxSize']);\n        }\n        // Set maximum to PHP_INT_MAX\n        if (!defined('PHP_INT_MAX')) {\n            define('PHP_INT_MAX', 2147483647);\n        }\n        if ($this->uploadMaxSize < 1 || $this->uploadMaxSize > PHP_INT_MAX) {\n            $this->uploadMaxSize = PHP_INT_MAX;\n        }\n\n        // Set to get maximum size to 50% of memory_limit\n        $memLimit = elFinder::getIniBytes('memory_limit') / 2;\n        if ($memLimit > 0) {\n            $this->getMaxSize = empty($this->options['getMaxSize']) ? $memLimit : min($memLimit, elFinder::getIniBytes('', $this->options['getMaxSize']));\n        } else {\n            $this->getMaxSize = -1;\n        }\n\n        $this->disabled = isset($this->options['disabled']) && is_array($this->options['disabled'])\n            ? array_values(array_diff($this->options['disabled'], array('open'))) // 'open' is required\n            : array();\n\n        $this->cryptLib = $this->options['cryptLib'];\n        $this->mimeDetect = $this->options['mimeDetect'];\n\n        // find available mimetype detect method\n        $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n        $auto_types = [];\n\n        if (class_exists('finfo', false)) {\n            $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n             if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $auto_types[] = 'finfo';\n            }\n        }\n        \n        if (function_exists('mime_content_type')) {\n            $_mimetypes = explode(';', mime_content_type(__FILE__));\n            if (preg_match($regexp, array_shift($_mimetypes))) {\n                $auto_types[] = 'mime_content_type';\n            }\n        }\n            \n        $auto_types[] = 'internal';\n\n        $type = strtolower($this->options['mimeDetect']);\n        if (!in_array($type, $auto_types)) {\n            $type = 'auto';\n        }\n\n        if ($type == 'auto') {\n            $type = array_shift($auto_types);\n        }\n\n        $this->mimeDetect = $type;\n\n        if ($this->mimeDetect == 'finfo') {\n            $this->finfo = finfo_open(FILEINFO_MIME);\n        } else if ($this->mimeDetect == 'internal' && !elFinderVolumeDriver::$mimetypesLoaded) {\n            // load mimes from external file for mimeDetect == 'internal'\n            // based on Alexey Sukhotin idea and patch: http://elrte.org/redmine/issues/163\n            // file must be in file directory or in parent one\n            elFinderVolumeDriver::loadMimeTypes(!empty($this->options['mimefile']) ? $this->options['mimefile'] : '');\n        }\n        $this->rootName = empty($this->options['alias']) ? $this->basenameCE($this->root) : $this->options['alias'];\n\n        // This get's triggered if $this->root == '/' and alias is empty.\n        // Maybe modify _basename instead?\n        if ($this->rootName === '') $this->rootName = $this->separator;\n\n        $this->_checkArchivers();\n\n        $root = $this->stat($this->root);\n\n        if (!$root) {\n            return $this->setError('Root folder does not exist.');\n        }\n        if (!$root['read'] && !$root['write']) {\n            return $this->setError('Root folder has not read and write permissions.');\n        }\n\n        if ($root['read']) {\n            if ($argInit) {\n                // check startPath - path to open by default instead of root\n                $startPath = $this->options['startPath'] ? $this->normpathCE($this->options['startPath']) : '';\n                if ($startPath) {\n                    $start = $this->stat($startPath);\n                    if (!empty($start)\n                        && $start['mime'] == 'directory'\n                        && $start['read']\n                        && empty($start['hidden'])\n                        && $this->inpathCE($startPath, $this->root)) {\n                        $this->startPath = $startPath;\n                        if (substr($this->startPath, -1, 1) == $this->options['separator']) {\n                            $this->startPath = substr($this->startPath, 0, -1);\n                        }\n                    }\n                }\n            }\n        } else {\n            $this->options['URL'] = '';\n            $this->options['tmbURL'] = '';\n            $this->options['tmbPath'] = '';\n            // read only volume\n            array_unshift($this->attributes, array(\n                'pattern' => '/.*/',\n                'read' => false\n            ));\n        }\n        $this->treeDeep = $this->options['treeDeep'] > 0 ? (int)$this->options['treeDeep'] : 1;\n        $this->tmbSize = $this->options['tmbSize'] > 0 ? (int)$this->options['tmbSize'] : 48;\n        $this->URL = $this->options['URL'];\n        if ($this->URL && preg_match(\"|[^/?&=]$|\", $this->URL)) {\n            $this->URL .= '/';\n        }\n\n        $dirUrlOwn = strtolower($this->options['dirUrlOwn']);\n        if ($dirUrlOwn === 'auto') {\n            $this->options['dirUrlOwn'] = $this->URL ? false : true;\n        } else if ($dirUrlOwn === 'hide') {\n            $this->options['dirUrlOwn'] = 'hide';\n        } else {\n            $this->options['dirUrlOwn'] = (bool)$this->options['dirUrlOwn'];\n        }\n\n        $this->tmbURL = !empty($this->options['tmbURL']) ? $this->options['tmbURL'] : '';\n        if ($this->tmbURL && $this->tmbURL !== 'self' && preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n            $this->tmbURL .= '/';\n        }\n\n        $this->nameValidator = !empty($this->options['acceptedName']) && (is_string($this->options['acceptedName']) || is_callable($this->options['acceptedName']))\n            ? $this->options['acceptedName']\n            : '';\n\n        $this->dirnameValidator = !empty($this->options['acceptedDirname']) && (is_callable($this->options['acceptedDirname']) || (is_string($this->options['acceptedDirname']) && preg_match($this->options['acceptedDirname'], '') !== false))\n            ? $this->options['acceptedDirname']\n            : $this->nameValidator;\n\n        // enabling archivers['create'] with options['useRemoteArchive']\n        if ($this->options['useRemoteArchive'] && empty($this->archivers['create']) && $this->getTempPath()) {\n            $_archivers = $this->getArchivers();\n            $this->archivers['create'] = $_archivers['create'];\n        }\n\n        // manual control archive types to create\n        if (!empty($this->options['archiveMimes']) && is_array($this->options['archiveMimes'])) {\n            foreach ($this->archivers['create'] as $mime => $v) {\n                if (!in_array($mime, $this->options['archiveMimes'])) {\n                    unset($this->archivers['create'][$mime]);\n                }\n            }\n        }\n\n        // manualy add archivers\n        if (!empty($this->options['archivers']['create']) && is_array($this->options['archivers']['create'])) {\n            foreach ($this->options['archivers']['create'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['create'][$mime])) {\n                    $this->archivers['create'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['archivers']['extract']) && is_array($this->options['archivers']['extract'])) {\n            foreach ($this->options['archivers']['extract'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['extract'][$mime])) {\n                    $this->archivers['extract'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['noSessionCache']) && is_array($this->options['noSessionCache'])) {\n            foreach ($this->options['noSessionCache'] as $_key) {\n                $this->sessionCaching[$_key] = false;\n                unset($this->sessionCache[$_key]);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            if (!isset($this->sessionCache['subdirs'])) {\n                $this->sessionCache['subdirs'] = array();\n            }\n        }\n\n\n        $this->configure();\n\n        // Normalize disabled (array_merge`for type array of JSON)\n        $this->disabled = array_values(array_unique($this->disabled));\n\n        // fix sync interval\n        if ($this->options['syncMinMs'] !== 0) {\n            $this->options['syncMinMs'] = max($this->options[$this->options['syncChkAsTs'] ? 'tsPlSleep' : 'lsPlSleep'] * 1000, intval($this->options['syncMinMs']));\n        }\n\n        // ` copyJoin` is required for the trash function\n        if ($this->options['trashHash'] && empty($this->options['copyJoin'])) {\n            $this->options['trashHash'] = '';\n        }\n\n        // set tmpLinkPath\n        if (elFinder::$tmpLinkPath && !$this->options['tmpLinkPath']) {\n            if (is_writeable(elFinder::$tmpLinkPath)) {\n                $this->options['tmpLinkPath'] = elFinder::$tmpLinkPath;\n            } else {\n                elFinder::$tmpLinkPath = '';\n            }\n        }\n        if ($this->options['tmpLinkPath'] && is_writable($this->options['tmpLinkPath'])) {\n            $this->tmpLinkPath = realpath($this->options['tmpLinkPath']);\n        } else if (!$this->tmpLinkPath && $this->tmbURL && $this->tmbPath) {\n            $this->tmpLinkPath = $this->tmbPath;\n            $this->options['tmpLinkUrl'] = $this->tmbURL;\n        } else if (!$this->options['URL'] && is_writable('../files/.tmb')) {\n            $this->tmpLinkPath = realpath('../files/.tmb');\n            $this->options['tmpLinkUrl'] = '';\n            if (!elFinder::$tmpLinkPath) {\n                elFinder::$tmpLinkPath = $this->tmpLinkPath;\n                elFinder::$tmpLinkUrl = '';\n            }\n        }\n\n        // set tmpLinkUrl\n        if (elFinder::$tmpLinkUrl && !$this->options['tmpLinkUrl']) {\n            $this->options['tmpLinkUrl'] = elFinder::$tmpLinkUrl;\n        }\n        if ($this->options['tmpLinkUrl']) {\n            $this->tmpLinkUrl = $this->options['tmpLinkUrl'];\n        }\n        if ($this->tmpLinkPath && !$this->tmpLinkUrl) {\n            $cur = realpath('./');\n            $i = 0;\n            while ($cur !== $this->systemRoot && strpos($this->tmpLinkPath, $cur) !== 0) {\n                $i++;\n                $cur = dirname($cur);\n            }\n            list($req) = explode('?', $_SERVER['REQUEST_URI']);\n            $reqs = explode('/', dirname($req));\n            $uri = join('/', array_slice($reqs, 0, count($reqs) - 1)) . substr($this->tmpLinkPath, strlen($cur));\n            $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n            $this->tmpLinkUrl = ($https ? 'https://' : 'http://')\n                . $_SERVER['SERVER_NAME'] // host\n                . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n                . $uri;\n            if (!elFinder::$tmpLinkUrl) {\n                elFinder::$tmpLinkUrl = $this->tmpLinkUrl;\n            }\n        }\n\n        // remove last '/'\n        if ($this->tmpLinkPath) {\n            $this->tmpLinkPath = rtrim($this->tmpLinkPath, '/');\n        }\n        if ($this->tmpLinkUrl) {\n            $this->tmpLinkUrl = rtrim($this->tmpLinkUrl, '/');\n        }\n\n        // to update options cache\n        if (isset($this->sessionCache['rootstat'])) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n        $this->updateCache($this->root, $root);\n\n        return $this->mounted = true;\n    }\n\n    /**\n     * Some \"unmount\" stuffs - may be required by virtual fs\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n    }\n\n    /**\n     * Remove session cache of this volume\n     */\n    public function clearSessionCache()\n    {\n        $this->sessionCache = array();\n    }\n\n    /**\n     * Return error message from last failed action\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        return $this->error;\n    }\n\n    /**\n     * Return is uploadable that given file name\n     *\n     * @param  string $name file name\n     * @param  bool   $allowUnknown\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function isUploadableByName($name, $allowUnknown = false)\n    {\n        $mimeByName = $this->mimetype($name, true);\n        return (($allowUnknown && $mimeByName === 'unknown') || $this->allowPutMime($mimeByName));\n    }\n\n    /**\n     * Return Extention/MIME Table (elFinderVolumeDriver::$mimetypes)\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    public function getMimeTable()\n    {\n        // load mime.types\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        return elFinderVolumeDriver::$mimetypes;\n    }\n\n    /**\n     * Return file extention detected by MIME type\n     *\n     * @param  string $mime   MIME type\n     * @param  string $suffix Additional suffix\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getExtentionByMime($mime, $suffix = '')\n    {\n        static $extTable = null;\n\n        if (is_null($extTable)) {\n            $extTable = array_flip(array_unique($this->getMimeTable()));\n            foreach ($this->options['mimeMap'] as $pair => $_mime) {\n                list($ext) = explode(':', $pair);\n                if ($ext !== '*' && !isset($extTable[$_mime])) {\n                    $extTable[$_mime] = $ext;\n                }\n            }\n        }\n\n        if ($mime && isset($extTable[$mime])) {\n            return $suffix ? ($extTable[$mime] . $suffix) : $extTable[$mime];\n        }\n        return '';\n    }\n\n    /**\n     * Set mimetypes allowed to display to client\n     *\n     * @param  array $mimes\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function setMimesFilter($mimes)\n    {\n        if (is_array($mimes)) {\n            $this->onlyMimes = $mimes;\n        }\n    }\n\n    /**\n     * Return root folder hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function root()\n    {\n        return $this->encode($this->root);\n    }\n\n    /**\n     * Return root path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function getRootPath()\n    {\n        return $this->root;\n    }\n\n    /**\n     * Return target path hash\n     *\n     * @param  string $path\n     * @param  string $name\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getHash($path, $name = '')\n    {\n        if ($name !== '') {\n            $path = $this->joinPathCE($path, $name);\n        }\n        return $this->encode($path);\n    }\n\n    /**\n     * Return decoded path of target hash\n     * This method do not check the stat of target\n     * Use method `realpath()` to do check of the stat of target\n     *\n     * @param  string $hash\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getPath($hash)\n    {\n        return $this->decode($hash);\n    }\n\n    /**\n     * Return root or startPath hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function defaultPath()\n    {\n        return $this->encode($this->startPath ? $this->startPath : $this->root);\n    }\n\n    /**\n     * Return volume options required by client:\n     *\n     * @param $hash\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    public function options($hash)\n    {\n        $create = $createext = array();\n        if (isset($this->archivers['create']) && is_array($this->archivers['create'])) {\n            foreach ($this->archivers['create'] as $m => $v) {\n                $create[] = $m;\n                $createext[$m] = $v['ext'];\n            }\n        }\n        $opts = array(\n            'path' => $hash ? $this->path($hash) : '',\n            'url' => $this->URL,\n            'tmbUrl' => (!$this->imgLib && $this->options['tmbFbSelf']) ? 'self' : $this->tmbURL,\n            'disabled' => $this->disabled,\n            'separator' => $this->separator,\n            'copyOverwrite' => intval($this->options['copyOverwrite']),\n            'uploadOverwrite' => intval($this->options['uploadOverwrite']),\n            'uploadMaxSize' => intval($this->uploadMaxSize),\n            'uploadMaxConn' => intval($this->options['uploadMaxConn']),\n            'uploadMime' => array(\n                'firstOrder' => isset($this->uploadOrder[0]) ? $this->uploadOrder[0] : 'deny',\n                'allow' => $this->uploadAllow,\n                'deny' => $this->uploadDeny\n            ),\n            'dispInlineRegex' => $this->options['dispInlineRegex'],\n            'jpgQuality' => intval($this->options['jpgQuality']),\n            'archivers' => array(\n                'create' => $create,\n                'extract' => isset($this->archivers['extract']) && is_array($this->archivers['extract']) ? array_keys($this->archivers['extract']) : array(),\n                'createext' => $createext\n            ),\n            'uiCmdMap' => (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap'])) ? $this->options['uiCmdMap'] : array(),\n            'syncChkAsTs' => intval($this->options['syncChkAsTs']),\n            'syncMinMs' => intval($this->options['syncMinMs']),\n            'i18nFolderName' => intval($this->options['i18nFolderName']),\n            'tmbCrop' => intval($this->options['tmbCrop']),\n            'tmbReqCustomData' => (bool)$this->options['tmbReqCustomData'],\n            'substituteImg' => (bool)$this->options['substituteImg'],\n            'onetimeUrl' => (bool)$this->options['onetimeUrl'],\n        );\n        if (!empty($this->options['trashHash'])) {\n            $opts['trashHash'] = $this->options['trashHash'];\n        }\n        if ($hash === null) {\n            // call from getRootStatExtra()\n            if (!empty($this->options['icon'])) {\n                $opts['icon'] = $this->options['icon'];\n            }\n            if (!empty($this->options['rootCssClass'])) {\n                $opts['csscls'] = $this->options['rootCssClass'];\n            }\n            if (isset($this->options['netkey'])) {\n                $opts['netkey'] = $this->options['netkey'];\n            }\n        }\n        return $opts;\n    }\n\n    /**\n     * Get option value of this volume\n     *\n     * @param string $name target option name\n     *\n     * @return NULL|mixed   target option value\n     * @author Naoki Sawada\n     */\n    public function getOption($name)\n    {\n        return isset($this->options[$name]) ? $this->options[$name] : null;\n    }\n\n    /**\n     * Get plugin values of this options\n     *\n     * @param string $name Plugin name\n     *\n     * @return NULL|array   Plugin values\n     * @author Naoki Sawada\n     */\n    public function getOptionsPlugin($name = '')\n    {\n        if ($name) {\n            return isset($this->options['plugin'][$name]) ? $this->options['plugin'][$name] : array();\n        } else {\n            return $this->options['plugin'];\n        }\n    }\n\n    /**\n     * Return true if command disabled in options\n     *\n     * @param  string $cmd command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandDisabled($cmd)\n    {\n        return in_array($cmd, $this->disabled);\n    }\n\n    /**\n     * Return true if mime is required mimes list\n     *\n     * @param  string    $mime  mime type to check\n     * @param  array     $mimes allowed mime types list or not set to use client mimes list\n     * @param  bool|null $empty what to return on empty list\n     *\n     * @return bool|null\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function mimeAccepted($mime, $mimes = null, $empty = true)\n    {\n        $mimes = is_array($mimes) ? $mimes : $this->onlyMimes;\n        if (empty($mimes)) {\n            return $empty;\n        }\n        return $mime == 'directory'\n            || in_array('all', $mimes)\n            || in_array('All', $mimes)\n            || in_array($mime, $mimes)\n            || in_array(substr($mime, 0, strpos($mime, '/')), $mimes);\n    }\n\n    /**\n     * Return true if voume is readable.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function isReadable()\n    {\n        $stat = $this->stat($this->root);\n        return $stat['read'];\n    }\n\n    /**\n     * Return true if copy from this volume allowed\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function copyFromAllowed()\n    {\n        return !!$this->options['copyFrom'];\n    }\n\n    /**\n     * Return file path related to root with convert encoging\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function path($hash)\n    {\n        return $this->convEncOut($this->_path($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Return file real path if file exists\n     *\n     * @param  string $hash file hash\n     *\n     * @return string | false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path) ? $path : false;\n    }\n\n    /**\n     * Return list of moved/overwrited files\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function removed()\n    {\n        if ($this->removed) {\n            $unsetSubdir = isset($this->sessionCache['subdirs']) ? true : false;\n            foreach ($this->removed as $item) {\n                if ($item['mime'] === 'directory') {\n                    $path = $this->decode($item['hash']);\n                    if ($unsetSubdir) {\n                        unset($this->sessionCache['subdirs'][$path]);\n                    }\n                    if ($item['phash'] !== '') {\n                        $parent = $this->decode($item['phash']);\n                        unset($this->cache[$parent]);\n                        if ($this->root === $parent) {\n                            $this->sessionCache['rootstat'] = array();\n                        }\n                        if ($unsetSubdir) {\n                            unset($this->sessionCache['subdirs'][$parent]);\n                        }\n                    }\n                }\n            }\n            $this->removed = array_values($this->removed);\n        }\n        return $this->removed;\n    }\n\n    /**\n     * Return list of added files\n     *\n     * @deprecated\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function added()\n    {\n        return $this->added;\n    }\n\n    /**\n     * Clean removed files list\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function resetRemoved()\n    {\n        $this->resetResultStat();\n    }\n\n    /**\n     * Clean added/removed files list\n     *\n     * @return void\n     **/\n    public function resetResultStat()\n    {\n        $this->removed = array();\n        $this->added = array();\n    }\n\n    /**\n     * Return file/dir hash or first founded child hash with required attr == $val\n     *\n     * @param  string $hash file hash\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function closest($hash, $attr, $val)\n    {\n        return ($path = $this->closestByAttr($this->decode($hash), $attr, $val)) ? $this->encode($path) : false;\n    }\n\n    /**\n     * Return file info or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @internal param bool $realpath add realpath field to file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function file($hash)\n    {\n        $file = $this->stat($this->decode($hash));\n\n        return ($file) ? $file : $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n    }\n\n    /**\n     * Return folder info\n     *\n     * @param  string $hash folder hash\n     * @param bool    $resolveLink\n     *\n     * @return array|false\n     * @internal param bool $hidden return hidden file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function dir($hash, $resolveLink = false)\n    {\n        if (($dir = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_DIR_NOT_FOUND);\n        }\n\n        if ($resolveLink && !empty($dir['thash'])) {\n            $dir = $this->file($dir['thash']);\n        }\n\n        return $dir && $dir['mime'] == 'directory' && empty($dir['hidden'])\n            ? $dir\n            : $this->setError(elFinder::ERROR_NOT_DIR);\n    }\n\n    /**\n     * Return directory content or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function scandir($hash)\n    {\n        if (($dir = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $path = $this->decode($hash);\n        if ($res = $dir['read']\n            ? $this->getScandir($path)\n            : $this->setError(elFinder::ERROR_PERM_DENIED)) {\n\n            $dirs = null;\n            if ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) {\n                $dirs = $this->sessionCache['subdirs'][$path];\n            }\n            if ($dirs !== null || (isset($dir['dirs']) && $dir['dirs'] != 1)) {\n                $_dir = $dir;\n                if ($dirs || $this->subdirs($hash)) {\n                    $dir['dirs'] = 1;\n                } else {\n                    unset($dir['dirs']);\n                }\n                if ($dir !== $_dir) {\n                    $this->updateCache($path, $dir);\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  string $hash file hash\n     * @param null    $intersect\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     */\n    public function ls($hash, $intersect = null)\n    {\n        if (($dir = $this->dir($hash)) == false || !$dir['read']) {\n            return false;\n        }\n\n        $list = array();\n        $path = $this->decode($hash);\n\n        $check = array();\n        if ($intersect) {\n            $check = array_flip($intersect);\n        }\n\n        foreach ($this->getScandir($path) as $stat) {\n            if (empty($stat['hidden']) && (!$check || isset($check[$stat['name']])) && $this->mimeAccepted($stat['mime'])) {\n                $list[$stat['hash']] = $stat['name'];\n            }\n        }\n\n        return $list;\n    }\n\n    /**\n     * Return subfolders for required folder or false on error\n     *\n     * @param  string $hash    folder hash or empty string to get tree from root folder\n     * @param  int    $deep    subdir deep\n     * @param  string $exclude dir hash which subfolders must be exluded from result, required to not get stat twice on cwd subfolders\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tree($hash = '', $deep = 0, $exclude = '')\n    {\n        $path = $hash ? $this->decode($hash) : $this->root;\n\n        if (($dir = $this->stat($path)) == false || $dir['mime'] != 'directory') {\n            return false;\n        }\n\n        $dirs = $this->gettree($path, $deep > 0 ? $deep - 1 : $this->treeDeep - 1, $exclude ? $this->decode($exclude) : null);\n        array_unshift($dirs, $dir);\n        return $dirs;\n    }\n\n    /**\n     * Return part of dirs tree from required dir up to root dir\n     *\n     * @param  string    $hash   directory hash\n     * @param  bool|null $lineal only lineal parents\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function parents($hash, $lineal = false)\n    {\n        if (($current = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $args = func_get_args();\n        // checks 3rd param `$until` (elFinder >= 2.1.24)\n        $until = '';\n        if (isset($args[2])) {\n            $until = $args[2];\n        }\n\n        $path = $this->decode($hash);\n        $tree = array();\n\n        while ($path && $path != $this->root) {\n            elFinder::checkAborted();\n            $path = $this->dirnameCE($path);\n            if (!($stat = $this->stat($path)) || !empty($stat['hidden']) || !$stat['read']) {\n                return false;\n            }\n\n            array_unshift($tree, $stat);\n            if (!$lineal) {\n                foreach ($this->gettree($path, 0) as $dir) {\n                    elFinder::checkAborted();\n                    if (!isset($tree[$dir['hash']])) {\n                        $tree[$dir['hash']] = $dir;\n                    }\n                }\n            }\n\n            if ($until && $until === $this->encode($path)) {\n                break;\n            }\n        }\n\n        return $tree ? array_values($tree) : array($current);\n    }\n\n    /**\n     * Create thumbnail for required file and return its name or false on failed\n     *\n     * @param $hash\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function tmb($hash)\n    {\n        $path = $this->decode($hash);\n        $stat = $this->stat($path);\n\n        if (isset($stat['tmb'])) {\n            $res = $stat['tmb'] == \"1\" ? $this->createTmb($path, $stat) : $stat['tmb'];\n            if (!$res) {\n                list($type) = explode('/', $stat['mime']);\n                $fallback = $this->options['resourcePath'] . DIRECTORY_SEPARATOR . strtolower($type) . '.png';\n                if (is_file($fallback)) {\n                    $res = $this->tmbname($stat);\n                    if (!copy($fallback, $this->tmbPath . DIRECTORY_SEPARATOR . $res)) {\n                        $res = false;\n                    }\n                }\n            }\n            // tmb garbage collection\n            if ($res && $this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                $rand = mt_rand(1, 10000);\n                if ($rand <= $this->options['tmbGcPercentage'] * 100) {\n                    register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmbPath . DIRECTORY_SEPARATOR . '*.png', $this->options['tmbGcMaxlifeHour'] * 3600);\n                }\n            }\n            return $res;\n        }\n        return false;\n    }\n\n    /**\n     * Return file size / total directory size\n     *\n     * @param  string   file hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function size($hash)\n    {\n        return $this->countSize($this->decode($hash));\n    }\n\n    /**\n     * Open file for reading and return file pointer\n     *\n     * @param  string   file hash\n     *\n     * @return Resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function open($hash)\n    {\n        if (($file = $this->file($hash)) == false\n            || $file['mime'] == 'directory') {\n            return false;\n        }\n        // check extra option for network stream pointer\n        if (func_num_args() > 1) {\n            $opts = func_get_arg(1);\n        } else {\n            $opts = array();\n        }\n        return $this->fopenCE($this->decode($hash), 'rb', $opts);\n    }\n\n    /**\n     * Close file pointer\n     *\n     * @param  Resource $fp   file pointer\n     * @param  string   $hash file hash\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function close($fp, $hash)\n    {\n        $this->fcloseCE($fp, $this->decode($hash));\n    }\n\n    /**\n     * Create directory and return dir info\n     *\n     * @param  string $dsthash destination directory hash\n     * @param  string $name    directory name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkdir($dsthash, $name)\n    {\n        if ($this->commandDisabled('mkdir')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, true)) {\n            return $this->setError(elFinder::ERROR_INVALID_DIRNAME);\n        }\n\n        if (($dir = $this->dir($dsthash)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dsthash);\n        }\n\n        $path = $this->decode($dsthash);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, true)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $dst = $this->joinPathCE($path, $name);\n        $stat = $this->isNameExists($dst);\n        if (!empty($stat)) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n        $this->clearcache();\n\n        $mkpath = $this->convEncOut($this->_mkdir($this->convEncIn($path), $this->convEncIn($name)));\n        if ($mkpath) {\n            $this->clearstatcache();\n            $this->updateSubdirsCache($path, true);\n            $this->updateSubdirsCache($mkpath, false);\n        }\n\n        return $mkpath ? $this->stat($mkpath) : false;\n    }\n\n    /**\n     * Create empty file and return its info\n     *\n     * @param  string $dst  destination directory\n     * @param  string $name file name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkfile($dst, $name)\n    {\n        if ($this->commandDisabled('mkfile')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = $this->mimetype($name, true);\n        if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        $path = $this->decode($dst);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, false)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->isNameExists($this->joinPathCE($path, $name))) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($path = $this->convEncOut($this->_mkfile($this->convEncIn($path), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Rename file and return file info\n     *\n     * @param  string $hash file hash\n     * @param  string $name new file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rename($hash, $name)\n    {\n        if ($this->commandDisabled('rename')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($name === $file['name']) {\n            return $file;\n        }\n\n        if (!empty($this->options['netkey']) && !empty($file['isroot'])) {\n            // change alias of netmount root\n            $rootKey = $this->getRootstatCachekey();\n            // delete old cache data\n            if ($this->sessionCaching['rootstat']) {\n                unset($this->sessionCaching['rootstat'][$rootKey]);\n            }\n            if (elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $name)) {\n                $this->clearcache();\n                $this->rootName = $this->options['alias'] = $name;\n                return $this->stat($this->root);\n            } else {\n                return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, $name);\n            }\n        }\n\n        if (!empty($file['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $file['name']);\n        }\n\n        $isDir = ($file['mime'] === 'directory');\n\n        if (!$this->nameAccepted($name, $isDir)) {\n            return $this->setError($isDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$isDir) {\n            $mimeByName = $this->mimetype($name, true);\n            if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $stat = $this->isNameExists($this->joinPathCE($dir, $name));\n        if ($stat) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $this->rmTmb($file); // remove old name tmbs, we cannot do this after dir move\n\n\n        if ($path = $this->convEncOut($this->_move($this->convEncIn($path), $this->convEncIn($dir), $this->convEncIn($name)))) {\n            $this->clearcache();\n            return $this->stat($path);\n        }\n        return false;\n    }\n\n    /**\n     * Create file copy with suffix \"copy number\" and return its info\n     *\n     * @param  string $hash   file hash\n     * @param  string $suffix suffix to add to file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function duplicate($hash, $suffix = 'copy')\n    {\n        if ($this->commandDisabled('duplicate')) {\n            return $this->setError(elFinder::ERROR_COPY, '#' . $hash, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_COPY, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $name = $this->uniqueName($dir, $file['name'], sprintf($this->options['duplicateSuffix'], $suffix));\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        return ($path = $this->copy($path, $dir, $name)) == false\n            ? false\n            : $this->stat($path);\n    }\n\n    /**\n     * Save uploaded file.\n     * On success return array with new file stat and with removed file hash (if existed file was replaced)\n     *\n     * @param  Resource $fp      file pointer\n     * @param  string   $dst     destination folder hash\n     * @param           $name\n     * @param  string   $tmpname file tmp name - required to detect mime type\n     * @param  array    $hashes  exists files hash array with filename as key\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $src file name\n     * @author   Dmitry (dio) Levashov\n     */\n    public function upload($fp, $dst, $name, $tmpname, $hashes = array())\n    {\n        if ($this->commandDisabled('upload')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (empty($dir['write'])) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = '';\n        if ($this->mimeDetect === 'internal') {\n            $mime = $this->mimetype($tmpname, $name);\n        } else {\n            $mime = $this->mimetype($tmpname, $name);\n            $mimeByName = $this->mimetype($name, true);\n            if ($mime === 'unknown') {\n                $mime = $mimeByName;\n            }\n        }\n\n        if (!$this->allowPutMime($mime) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, '(' . $mime . ')');\n        }\n\n        $tmpsize = (int)sprintf('%u', filesize($tmpname));\n        if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        $dstpath = $this->decode($dst);\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $file = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($dstpath, $name);\n            $file = $this->isNameExists($test);\n        }\n\n        $this->clearcache();\n\n        if ($file && $file['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->uploadOverwrite) {\n                if (!$file['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                } elseif ($file['mime'] == 'directory') {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $name);\n                }\n                $this->remove($test);\n            } else {\n                $name = $this->uniqueName($dstpath, $name, '-', false);\n            }\n        }\n\n        $stat = array(\n            'mime' => $mime,\n            'width' => 0,\n            'height' => 0,\n            'size' => $tmpsize);\n\n        // $w = $h = 0;\n        if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) {\n            $stat['width'] = $s[0];\n            $stat['height'] = $s[1];\n        }\n        // $this->clearcache();\n        if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) {\n            return false;\n        }\n\n        $stat = $this->stat($path);\n        // Try get URL\n        if (empty($stat['url']) && ($url = $this->getContentUrl($stat['hash']))) {\n            $stat['url'] = $url;\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Paste files\n     *\n     * @param  Object $volume source volume\n     * @param         $src\n     * @param  string $dst    destination dir hash\n     * @param  bool   $rmSrc  remove source after copy?\n     * @param array   $hashes\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $source file hash\n     * @author   Dmitry (dio) Levashov\n     */\n    public function paste($volume, $src, $dst, $rmSrc = false, $hashes = array())\n    {\n        $err = $rmSrc ? elFinder::ERROR_MOVE : elFinder::ERROR_COPY;\n\n        if ($this->commandDisabled('paste')) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $volume->file($src, $rmSrc)) == false) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $name = $file['name'];\n        $errpath = $volume->path($file['hash']);\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError($err, $errpath, elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (!$dir['write'] || !$file['read']) {\n            return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        $destination = $this->decode($dst);\n\n        if (($test = $volume->closest($src, $rmSrc ? 'locked' : 'read', $rmSrc))) {\n            return $rmSrc\n                ? $this->setError($err, $errpath, elFinder::ERROR_LOCKED, $volume->path($test))\n                : $this->setError($err, $errpath, empty($file['thash']) ? elFinder::ERROR_PERM_DENIED : elFinder::ERROR_MKOUTLINK);\n        }\n\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $stat = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($destination, $name);\n            $stat = $this->isNameExists($test);\n        }\n        $this->clearcache();\n        $dstDirExists = false;\n        if ($stat && $stat['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->options['copyOverwrite']) {\n                // do not replace file with dir or dir with file\n                if (!$this->isSameType($file['mime'], $stat['mime'])) {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $this->path($stat['hash']));\n                }\n                // existed file is not writable\n                if (empty($stat['write'])) {\n                    return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n                }\n                if ($this->options['copyJoin']) {\n                    if (!empty($stat['locked'])) {\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                } else {\n                    // existed file locked or has locked child\n                    if (($locked = $this->closestByAttr($test, 'locked', true))) {\n                        $stat = $this->stat($locked);\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                }\n                // target is entity file of alias\n                if ($volume === $this && ((isset($file['target']) && $test == $file['target']) || $test == $this->decode($src))) {\n                    return $this->setError(elFinder::ERROR_REPLACE, $errpath);\n                }\n                // remove existed file\n                if (!$this->options['copyJoin'] || $stat['mime'] !== 'directory') {\n                    if (!$this->remove($test)) {\n                        return $this->setError(elFinder::ERROR_REPLACE, $this->path($stat['hash']));\n                    }\n                } else if ($stat['mime'] === 'directory') {\n                    $dstDirExists = true;\n                }\n            } else {\n                $name = $this->uniqueName($destination, $name, ' ', false);\n            }\n        }\n\n        // copy/move inside current volume\n        if ($volume === $this) { //  changing == operand to === fixes issue #1285 - Paul Canning 24/03/2016\n            $source = $this->decode($src);\n            // do not copy into itself\n            if ($this->inpathCE($destination, $source)) {\n                return $this->setError(elFinder::ERROR_COPY_ITSELF, $errpath);\n            }\n            $rmDir = false;\n            if ($rmSrc) {\n                if ($dstDirExists) {\n                    $rmDir = true;\n                    $method = 'copy';\n                } else {\n                    $method = 'move';\n                }\n            } else {\n                $method = 'copy';\n            }\n            $this->clearcache();\n            if ($res = ($path = $this->$method($source, $destination, $name)) ? $this->stat($path) : false) {\n                if ($rmDir) {\n                    $this->remove($source);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            // copy/move from another volume\n            if (!$this->options['copyTo'] || !$volume->copyFromAllowed()) {\n                return $this->setError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n            }\n\n            $this->error = array();\n            if (($path = $this->copyFrom($volume, $src, $destination, $name)) == false) {\n                return false;\n            }\n\n            if ($rmSrc && !$this->error()) {\n                if (!$volume->rm($src)) {\n                    if ($volume->file($src)) {\n                        $this->addError(elFinder::ERROR_RM_SRC);\n                    } else {\n                        $this->removed[] = $file;\n                    }\n                }\n            }\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Return path info array to archive of target items\n     *\n     * @param  array $hashes\n     *\n     * @return array|false\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    public function zipdl($hashes)\n    {\n        if ($this->commandDisabled('zipdl')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $archivers = $this->getArchivers();\n        $cmd = null;\n        if (!$archivers || empty($archivers['create'])) {\n            return false;\n        }\n        $archivers = $archivers['create'];\n        if (!$archivers) {\n            return false;\n        }\n        $file = $mime = '';\n        foreach (array('zip', 'tgz') as $ext) {\n            $mime = $this->mimetype('file.' . $ext, true);\n            if (isset($archivers[$mime])) {\n                $cmd = $archivers[$mime];\n                break;\n            }\n        }\n        if (!$cmd) {\n            $cmd = array_shift($archivers);\n            if (!empty($ext)) {\n                $mime = $this->mimetype('file.' . $ext, true);\n            }\n        }\n        $ext = $cmd['ext'];\n        $res = false;\n        $mixed = false;\n        $hashes = array_values($hashes);\n        $dirname = dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[0])));\n        $cnt = count($hashes);\n        if ($cnt > 1) {\n            for ($i = 1; $i < $cnt; $i++) {\n                if ($dirname !== dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[$i])))) {\n                    $mixed = true;\n                    break;\n                }\n            }\n        }\n        if ($mixed || $this->root == $this->dirnameCE($this->decode($hashes[0]))) {\n            $prefix = $this->rootName;\n        } else {\n            $prefix = basename($dirname);\n        }\n        if ($dir = $this->getItemsInHand($hashes)) {\n            $tmppre = (substr(PHP_OS, 0, 3) === 'WIN') ? 'zd-' : 'elfzdl-';\n            $pdir = dirname($dir);\n            // garbage collection (expire 2h)\n            register_shutdown_function(array('elFinder', 'GlobGC'), $pdir . DIRECTORY_SEPARATOR . $tmppre . '*', 7200);\n            $files = self::localScandir($dir);\n            if ($files && ($arc = tempnam($dir, $tmppre))) {\n                unlink($arc);\n                $arc = $arc . '.' . $ext;\n                $name = basename($arc);\n                if ($arc = $this->makeArchive($dir, $files, $name, $cmd)) {\n                    $file = tempnam($pdir, $tmppre);\n                    unlink($file);\n                    $res = rename($arc, $file);\n                    $this->rmdirRecursive($dir);\n                }\n            }\n        }\n        return $res ? array('path' => $file, 'ext' => $ext, 'mime' => $mime, 'prefix' => $prefix) : false;\n    }\n\n    /**\n     * Return file contents\n     *\n     * @param  string $hash file hash\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function getContents($hash)\n    {\n        $file = $this->file($hash);\n\n        if (!$file) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($file['mime'] == 'directory') {\n            return $this->setError(elFinder::ERROR_NOT_FILE);\n        }\n\n        if (!$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->getMaxSize > 0 && $file['size'] > $this->getMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        return $file['size'] ? $this->_getContents($this->convEncIn($this->decode($hash), true)) : '';\n    }\n\n    /**\n     * Put content in text file and return file info.\n     *\n     * @param  string $hash    file hash\n     * @param  string $content new file content\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function putContents($hash, $content)\n    {\n        if ($this->commandDisabled('edit')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        // check data cheme\n        if (preg_match('~^\\0data:(.+?/.+?);base64,~', $content, $m)) {\n            $dMime = $m[1];\n            if ($file['size'] > 0 && $dMime !== $file['mime']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $content = base64_decode(substr($content, strlen($m[0])));\n        }\n\n        // check MIME\n        $name = $this->basenameCE($path);\n        $mime = '';\n        $mimeByName = $this->mimetype($name, true);\n        if ($this->mimeDetect !== 'internal') {\n            if ($tp = $this->tmpfile()) {\n                fwrite($tp, $content);\n                $info = stream_get_meta_data($tp);\n                $filepath = $info['uri'];\n                $mime = $this->mimetype($filepath, $name);\n                fclose($tp);\n            }\n        }\n        if (!$this->allowPutMime($mimeByName) || ($mime && !$this->allowPutMime($mime))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($this->convEncOut($this->_filePutContents($this->convEncIn($path), $content))) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $hash archive hash\n     * @param null    $makedir\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    public function extract($hash, $makedir = null)\n    {\n        if ($this->commandDisabled('extract')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $archiver = isset($this->archivers['extract'][$file['mime']])\n            ? $this->archivers['extract'][$file['mime']]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_NOT_ARCHIVE);\n        }\n\n        $path = $this->decode($hash);\n        $parent = $this->stat($this->dirnameCE($path));\n\n        if (!$file['read'] || !$parent['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n        $this->clearcache();\n        $this->extractToNewdir = is_null($makedir) ? 'auto' : (bool)$makedir;\n\n        if ($path = $this->convEncOut($this->_extract($this->convEncIn($path), $archiver))) {\n            if (is_array($path)) {\n                foreach ($path as $_k => $_p) {\n                    $path[$_k] = $this->stat($_p);\n                }\n            } else {\n                $path = $this->stat($path);\n            }\n            return $path;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Add files to archive\n     *\n     * @param        $hashes\n     * @param        $mime\n     * @param string $name\n     *\n     * @return array|bool\n     * @throws Exception\n     */\n    public function archive($hashes, $mime, $name = '')\n    {\n        if ($this->commandDisabled('archive')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($name !== '' && !$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $archiver = isset($this->archivers['create'][$mime])\n            ? $this->archivers['create'][$mime]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_ARCHIVE_TYPE);\n        }\n\n        $files = array();\n        $useRemoteArchive = !empty($this->options['useRemoteArchive']);\n\n        $dir = '';\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                return $this->setError(elFinder::ERROR_FILE_NOT_FOUND, '#' . $hash);\n            }\n            if (!$file['read']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $path = $this->decode($hash);\n            if ($dir === '') {\n                $dir = $this->dirnameCE($path);\n                $stat = $this->stat($dir);\n                if (!$stat['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                }\n            }\n\n            $files[] = $useRemoteArchive ? $hash : $this->basenameCE($path);\n        }\n\n        if ($name === '') {\n            $name = count($files) == 1 ? $files[0] : 'Archive';\n        } else {\n            $name = str_replace(array('/', '\\\\'), '_', preg_replace('/\\.' . preg_quote($archiver['ext'], '/') . '$/i', '', $name));\n        }\n        $name .= '.' . $archiver['ext'];\n        $name = $this->uniqueName($dir, $name, '');\n        $this->clearcache();\n        if ($useRemoteArchive) {\n            return ($path = $this->remoteArchive($files, $name, $archiver)) ? $this->stat($path) : false;\n        } else {\n            return ($path = $this->convEncOut($this->_archive($this->convEncIn($dir), $this->convEncIn($files), $this->convEncIn($name), $archiver))) ? $this->stat($path) : false;\n        }\n    }\n\n    /**\n     * Create an archive from remote items\n     *\n     * @param      array  $hashes files hashes list\n     * @param      string $name   archive name\n     * @param      array  $arc    archiver options\n     *\n     * @return     string|boolean  path of created archive\n     * @throws     Exception\n     */\n    protected function remoteArchive($hashes, $name, $arc)\n    {\n        $resPath = false;\n        $file0 = $this->file($hashes[0]);\n        if ($file0 && ($dir = $this->getItemsInHand($hashes))) {\n            $files = self::localScandir($dir);\n            if ($files) {\n                if ($arc = $this->makeArchive($dir, $files, $name, $arc)) {\n                    if ($fp = fopen($arc, 'rb')) {\n                        $fstat = stat($arc);\n                        $stat = array(\n                            'size' => $fstat['size'],\n                            'ts' => $fstat['mtime'],\n                            'mime' => $this->mimetype($arc, $name)\n                        );\n                        $path = $this->decode($file0['phash']);\n                        $resPath = $this->saveCE($fp, $path, $name, $stat);\n                        fclose($fp);\n                    }\n                }\n            }\n            $this->rmdirRecursive($dir);\n        }\n        return $resPath;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $hash       image file\n     * @param  int    $width      new width\n     * @param  int    $height     new height\n     * @param  int    $x          X start poistion for crop\n     * @param  int    $y          Y start poistion for crop\n     * @param  string $mode       action how to mainpulate image\n     * @param  string $bg         background color\n     * @param  int    $degree     rotete degree\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    public function resize($hash, $width, $height, $x, $y, $mode = 'resize', $bg = '', $degree = 0, $jpgQuality = null)\n    {\n        if ($this->commandDisabled('resize')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($mode === 'rotate' && $degree == 0) {\n            return array('losslessRotate' => ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0 || $this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0));\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write'] || !$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        $work_path = $this->getWorkFile($this->encoding ? $this->convEncIn($path, true) : $path);\n\n        if (!$work_path || !is_writable($work_path)) {\n            if ($work_path && $path !== $work_path && is_file($work_path)) {\n                unlink($work_path);\n            }\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n            if (elFinder::isAnimationGif($work_path)) {\n                return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n            }\n        }\n\n        if (elFinder::isAnimationPng($work_path)) {\n            return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n        }\n\n        switch ($mode) {\n\n            case 'propresize':\n                $result = $this->imgResize($work_path, $width, $height, true, true, null, $jpgQuality);\n                break;\n\n            case 'crop':\n                $result = $this->imgCrop($work_path, $width, $height, $x, $y, null, $jpgQuality);\n                break;\n\n            case 'fitsquare':\n                $result = $this->imgSquareFit($work_path, $width, $height, 'center', 'middle', ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            case 'rotate':\n                $result = $this->imgRotate($work_path, $degree, ($bg ? $bg : $this->options['bgColorFb']), null, $jpgQuality);\n                break;\n\n            default:\n                $result = $this->imgResize($work_path, $width, $height, false, true, null, $jpgQuality);\n                break;\n        }\n\n        $ret = false;\n        if ($result) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $fstat = stat($work_path);\n            $imgsize = getimagesize($work_path);\n            if ($path !== $work_path) {\n                $file['size'] = $fstat['size'];\n                $file['ts'] = $fstat['mtime'];\n                if ($imgsize) {\n                    $file['width'] = $imgsize[0];\n                    $file['height'] = $imgsize[1];\n                }\n                if ($fp = fopen($work_path, 'rb')) {\n                    $ret = $this->saveCE($fp, $this->dirnameCE($path), $this->basenameCE($path), $file);\n                    fclose($fp);\n                }\n            } else {\n                $ret = true;\n            }\n            if ($ret) {\n                $this->clearcache();\n                $ret = $this->stat($path);\n                if ($imgsize) {\n                    $ret['width'] = $imgsize[0];\n                    $ret['height'] = $imgsize[1];\n                }\n            }\n        }\n        if ($path !== $work_path) {\n            is_file($work_path) && unlink($work_path);\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Remove file/dir\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rm($hash)\n    {\n        return $this->commandDisabled('rm')\n            ? $this->setError(elFinder::ERROR_PERM_DENIED)\n            : $this->remove($this->decode($hash));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  string $q search string\n     * @param  array  $mimes\n     * @param null    $hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function search($q, $mimes, $hash = null)\n    {\n        $res = array();\n        $matchMethod = null;\n        $args = func_get_args();\n        if (!empty($args[3])) {\n            $matchMethod = 'searchMatch' . $args[3];\n            if (!is_callable(array($this, $matchMethod))) {\n                return array();\n            }\n        }\n\n        $dir = null;\n        if ($hash) {\n            $dir = $this->decode($hash);\n            $stat = $this->stat($dir);\n            if (!$stat || $stat['mime'] !== 'directory' || !$stat['read']) {\n                $q = '';\n            }\n        }\n        if ($mimes && $this->onlyMimes) {\n            $mimes = array_intersect($mimes, $this->onlyMimes);\n            if (!$mimes) {\n                $q = '';\n            }\n        }\n        $this->searchStart = time();\n\n        $qs = preg_split('/\"([^\"]+)\"| +/', $q, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n        $query = $excludes = array();\n        foreach ($qs as $_q) {\n            $_q = trim($_q);\n            if ($_q !== '') {\n                if ($_q[0] === '-') {\n                    if (isset($_q[1])) {\n                        $excludes[] = substr($_q, 1);\n                    }\n                } else {\n                    $query[] = $_q;\n                }\n            }\n        }\n        if (!$query) {\n            $q = '';\n        } else {\n            $q = join(' ', $query);\n            $this->doSearchCurrentQuery = array(\n                'q' => $q,\n                'excludes' => $excludes,\n                'matchMethod' => $matchMethod\n            );\n        }\n\n        if ($q === '' || $this->commandDisabled('search')) {\n            return $res;\n        }\n\n        // valided regex $this->options['searchExDirReg']\n        if ($this->options['searchExDirReg']) {\n            if (false === preg_match($this->options['searchExDirReg'], '')) {\n                $this->options['searchExDirReg'] = '';\n            }\n        }\n\n        // check the leaf root too\n        if (!$mimes && (is_null($dir) || $dir == $this->root)) {\n            $rootStat = $this->stat($this->root);\n            if (!empty($rootStat['phash'])) {\n                if ($this->stripos($rootStat['name'], $q) !== false) {\n                    $res = array($rootStat);\n                }\n            }\n        }\n\n        return array_merge($res, $this->doSearch(is_null($dir) ? $this->root : $dir, $q, $mimes));\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dimensions($hash)\n    {\n        if (($file = $this->file($hash)) == false) {\n            return false;\n        }\n        // Throw additional parameters for some drivers\n        if (func_num_args() > 1) {\n            $args = func_get_arg(1);\n        } else {\n            $args = array();\n        }\n        return $this->convEncOut($this->_dimensions($this->convEncIn($this->decode($hash)), $file['mime'], $args));\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function subdirs($hash)\n    {\n        return (bool)$this->subdirsCE($this->decode($hash));\n    }\n\n    /**\n     * Return content URL (for netmout volume driver)\n     * If file.url == 1 requests from JavaScript client with XHR\n     *\n     * @param string $hash    file hash\n     * @param array  $options options array\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getContentUrl($hash, $options = array())\n    {\n        if (($file = $this->file($hash)) === false) {\n            return false;\n        }\n        if (!empty($options['onetime']) && $this->options['onetimeUrl']) {\n            if (is_callable($this->options['onetimeUrl'])) {\n                return call_user_func_array($this->options['onetimeUrl'], array($file, $options, $this));\n            } else {\n                $ret = false;\n                if ($tmpdir = elFinder::getStaticVar('commonTempPath')) {\n                    if ($source = $this->open($hash)) {\n                        if ($_dat = tempnam($tmpdir, 'ELF')) {\n                            $token = md5($_dat . session_id());\n                            $dat = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $token;\n                            if (rename($_dat, $dat)) {\n                                $info = stream_get_meta_data($source);\n                                if (!empty($info['uri'])) {\n                                    $tmp = $info['uri'];\n                                } else {\n                                    $tmp = tempnam($tmpdir, 'ELF');\n                                    if ($dest = fopen($tmp, 'wb')) {\n                                        if (!stream_copy_to_stream($source, $dest)) {\n                                            $tmp = false;\n                                        }\n                                        fclose($dest);\n                                    }\n                                }\n                                $this->close($source, $hash);\n                                if ($tmp) {\n                                    $info = array(\n                                        'file' => base64_encode($tmp),\n                                        'name' => $file['name'],\n                                        'mime' => $file['mime'],\n                                        'ts' => $file['ts']\n                                    );\n                                    if (file_put_contents($dat, json_encode($info))) {\n                                        $conUrl = elFinder::getConnectorUrl();\n                                        $ret = $conUrl . (strpos($conUrl, '?') !== false? '&' : '?') . 'cmd=file&onetime=1&target=' . $token;\n\n                                    }\n                                }\n                                if (!$ret) {\n                                    unlink($dat);\n                                }\n                            } else {\n                                unlink($_dat);\n                            }\n                        }\n                    }\n                }\n                return $ret;\n            }\n        }\n        if (empty($file['url']) && $this->URL) {\n            $path = str_replace($this->separator, '/', substr($this->decode($hash), strlen(rtrim($this->root, '/' . $this->separator)) + 1));\n            if ($this->encoding) {\n                $path = $this->convEncIn($path, true);\n            }\n            $path = str_replace('%2F', '/', rawurlencode($path));\n            return $this->URL . $path;\n        } else {\n            $ret = false;\n            if (!empty($file['url']) && $file['url'] != 1) {\n                return $file['url'];\n            } else if (!empty($options['temporary']) && ($tempInfo = $this->getTempLinkInfo('temp_' . md5($hash . session_id())))) {\n                if (is_readable($tempInfo['path'])) {\n                    touch($tempInfo['path']);\n                    $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                } else if ($source = $this->open($hash)) {\n                    if ($dest = fopen($tempInfo['path'], 'wb')) {\n                        if (stream_copy_to_stream($source, $dest)) {\n                            $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                        }\n                        fclose($dest);\n                    }\n                    $this->close($source, $hash);\n                }\n            }\n            return $ret;\n        }\n    }\n\n    /**\n     * Get temporary contents link infomation\n     *\n     * @param string $name\n     *\n     * @return boolean|array\n     * @author Naoki Sawada\n     */\n    public function getTempLinkInfo($name = null)\n    {\n        if ($this->tmpLinkPath) {\n            if (!$name) {\n                $name = 'temp_' . md5($_SERVER['REMOTE_ADDR'] . (string)microtime(true));\n            } else if (substr($name, 0, 5) !== 'temp_') {\n                $name = 'temp_' . $name;\n            }\n            register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmpLinkPath . DIRECTORY_SEPARATOR . 'temp_*', elFinder::$tmpLinkLifeTime);\n            return array(\n                'path' => $path = $this->tmpLinkPath . DIRECTORY_SEPARATOR . $name,\n                'url' => $this->tmpLinkUrl . '/' . rawurlencode($name)\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Get URL of substitute image by request args `substitute` or 4th argument $maxSize\n     *\n     * @param string   $target  Target hash\n     * @param array    $srcSize Size info array [width, height]\n     * @param resource $srcfp   Source file file pointer\n     * @param integer  $maxSize Maximum pixel of substitute image\n     *\n     * @return boolean\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getSubstituteImgLink($target, $srcSize, $srcfp = null, $maxSize = null)\n    {\n        $url = false;\n        $file = $this->file($target);\n        $force = !in_array($file['mime'], array('image/jpeg', 'image/png', 'image/gif'));\n        if (!$maxSize) {\n            $args = elFinder::$currentArgs;\n            if (!empty($args['substitute'])) {\n                $maxSize = $args['substitute'];\n            }\n        }\n        if ($maxSize && $srcSize[0] && $srcSize[1]) {\n            if ($this->getOption('substituteImg')) {\n                $maxSize = intval($maxSize);\n                $zoom = min(($maxSize / $srcSize[0]), ($maxSize / $srcSize[1]));\n                if ($force || $zoom < 1) {\n                    $width = round($srcSize[0] * $zoom);\n                    $height = round($srcSize[1] * $zoom);\n                    $jpgQuality = 50;\n                    $preserveExif = false;\n                    $unenlarge = true;\n                    $checkAnimated = true;\n                    $destformat = $file['mime'] === 'image/jpeg'? null : 'png';\n                    if (!$srcfp) {\n                        elFinder::checkAborted();\n                        $srcfp = $this->open($target);\n                    }\n                    if ($srcfp && ($tempLink = $this->getTempLinkInfo())) {\n                        elFinder::checkAborted();\n                        $dest = fopen($tempLink['path'], 'wb');\n                        if ($dest && stream_copy_to_stream($srcfp, $dest)) {\n                            fclose($dest);\n                            if ($this->imageUtil('resize', $tempLink['path'], compact('width', 'height', 'jpgQuality', 'preserveExif', 'unenlarge', 'checkAnimated', 'destformat'))) {\n                                $url = $tempLink['url'];\n                                // set expire to 1 min left\n                                touch($tempLink['path'], time() - elFinder::$tmpLinkLifeTime + 60);\n                            } else {\n                                unlink($tempLink['path']);\n                            }\n                        }\n                        $this->close($srcfp, $target);\n                    }\n                }\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Return temp path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getTempPath()\n    {\n        $tempPath = null;\n        if (isset($this->tmpPath) && $this->tmpPath && is_writable($this->tmpPath)) {\n            $tempPath = $this->tmpPath;\n        } else if (isset($this->tmp) && $this->tmp && is_writable($this->tmp)) {\n            $tempPath = $this->tmp;\n        } else if (elFinder::getStaticVar('commonTempPath') && is_writable(elFinder::getStaticVar('commonTempPath'))) {\n            $tempPath = elFinder::getStaticVar('commonTempPath');\n        } else if (function_exists('sys_get_temp_dir')) {\n            $tempPath = sys_get_temp_dir();\n        } else if ($this->tmbPathWritable) {\n            $tempPath = $this->tmbPath;\n        }\n        if ($tempPath && DIRECTORY_SEPARATOR !== '/') {\n            $tempPath = str_replace('/', DIRECTORY_SEPARATOR, $tempPath);\n        }\n        return $tempPath;\n    }\n\n    /**\n     * (Make &) Get upload taget dirctory hash\n     *\n     * @param string $baseTargetHash\n     * @param string $path\n     * @param array  $result\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getUploadTaget($baseTargetHash, $path, & $result)\n    {\n        $base = $this->decode($baseTargetHash);\n        $targetHash = $baseTargetHash;\n        $path = ltrim($path, $this->separator);\n        $dirs = explode($this->separator, $path);\n        array_pop($dirs);\n        foreach ($dirs as $dir) {\n            $targetPath = $this->joinPathCE($base, $dir);\n            if (!$_realpath = $this->realpath($this->encode($targetPath))) {\n                if ($stat = $this->mkdir($targetHash, $dir)) {\n                    $result['added'][] = $stat;\n                    $targetHash = $stat['hash'];\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            } else {\n                $targetHash = $this->encode($_realpath);\n                if ($this->dir($targetHash)) {\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            }\n        }\n        return $targetHash;\n    }\n\n    /**\n     * Return this uploadMaxSize value\n     *\n     * @return integer\n     * @author Naoki Sawada\n     */\n    public function getUploadMaxSize()\n    {\n        return $this->uploadMaxSize;\n    }\n\n    public function setUploadOverwrite($var)\n    {\n        $this->uploadOverwrite = (bool)$var;\n    }\n\n    /**\n     * Image file utility\n     *\n     * @param string $mode    'resize', 'rotate', 'propresize', 'crop', 'fitsquare'\n     * @param string $src     Image file local path\n     * @param array  $options excute options\n     *\n     * @return bool\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function imageUtil($mode, $src, $options = array())\n    {\n        if (!isset($options['jpgQuality'])) {\n            $options['jpgQuality'] = intval($this->options['jpgQuality']);\n        }\n        if (!isset($options['bgcolor'])) {\n            $options['bgcolor'] = '#ffffff';\n        }\n        if (!isset($options['bgColorFb'])) {\n            $options['bgColorFb'] = $this->options['bgColorFb'];\n        }\n        $destformat = !empty($options['destformat'])? $options['destformat'] : null;\n\n        // check 'width' ,'height'\n        if (in_array($mode, array('resize', 'propresize', 'crop', 'fitsquare'))) {\n            if (empty($options['width']) || empty($options['height'])) {\n                return false;\n            }\n        }\n\n        if (!empty($options['checkAnimated'])) {\n            if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n                if (elFinder::isAnimationGif($src)) {\n                    return false;\n                }\n            }\n            if (elFinder::isAnimationPng($src)) {\n                return false;\n            }\n        }\n\n        switch ($mode) {\n            case 'rotate':\n                if (empty($options['degree'])) {\n                    return true;\n                }\n                return (bool)$this->imgRotate($src, $options['degree'], $options['bgColorFb'], $destformat, $options['jpgQuality']);\n\n            case 'resize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], false, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'propresize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], true, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'crop':\n                if (isset($options['x']) && isset($options['y'])) {\n                    return (bool)$this->imgCrop($src, $options['width'], $options['height'], $options['x'], $options['y'], $destformat, $options['jpgQuality']);\n                }\n                break;\n\n            case 'fitsquare':\n                return (bool)$this->imgSquareFit($src, $options['width'], $options['height'], 'center', 'middle', $options['bgcolor'], $destformat, $options['jpgQuality']);\n\n        }\n        return false;\n    }\n\n    /**\n     * Convert Video To Image by ffmpeg\n     *\n     * @param  string $file video source file path\n     * @param  array  $stat file stat array\n     * @param  object $self volume driver object\n     * @param  int    $ss   start seconds\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function ffmpegToImg($file, $stat, $self, $ss = null)\n    {\n        $name = basename($file);\n        $path = dirname($file);\n        $tmp = $path . DIRECTORY_SEPARATOR . md5($name);\n        // register auto delete on shutdown\n        $GLOBALS['elFinderTempFiles'][$tmp] = true;\n        if (rename($file, $tmp)) {\n            if ($ss === null) {\n                // specific start time by file name (xxx^[sec].[extention] - video^3.mp4)\n                if (preg_match('/\\^(\\d+(?:\\.\\d+)?)\\.[^.]+$/', $stat['name'], $_m)) {\n                    $ss = $_m[1];\n                } else {\n                    $ss = $this->options['tmbVideoConvSec'];\n                }\n            }\n            $cmd = sprintf(ELFINDER_FFMPEG_PATH . ' -i %s -ss 00:00:%.3f -vframes 1 -f image2 -- %s', escapeshellarg($tmp), $ss, escapeshellarg($file));\n            $r = ($this->procExec($cmd) === 0);\n            clearstatcache();\n            if ($r && $ss > 0 && !file_exists($file)) {\n                // Retry by half of $ss\n                $ss = max(intval($ss / 2), 0);\n                rename($tmp, $file);\n                $r = $this->ffmpegToImg($file, $stat, $self, $ss);\n            } else {\n                unlink($tmp);\n            }\n            return $r;\n        }\n        return false;\n    }\n\n    /**\n     * Creates a temporary file and return file pointer\n     *\n     * @return resource|boolean\n     */\n    public function tmpfile()\n    {\n        if ($tmp = $this->getTempFile()) {\n            return fopen($tmp, 'wb');\n        }\n        return false;\n    }\n\n    /**\n     * Save error message\n     *\n     * @param  array  error\n     *\n     * @return boolean false\n     * @author Naoki Sawada\n     **/\n    protected function setError()\n    {\n        $this->error = array();\n        $this->addError(func_get_args());\n        return false;\n    }\n\n    /**\n     * Add error message\n     *\n     * @param  array  error\n     *\n     * @return false\n     * @author Dmitry(dio) Levashov\n     **/\n    protected function addError()\n    {\n        foreach (func_get_args() as $err) {\n            if (is_array($err)) {\n                foreach($err as $er) {\n                    $this->addError($er);\n                }\n            } else {\n                $this->error[] = (string)$err;\n            }\n        }\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /***************** server encoding support *******************/\n\n    /**\n     * Return parent directory path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function dirnameCE($path)\n    {\n        $dirname = (!$this->encoding) ? $this->_dirname($path) : $this->convEncOut($this->_dirname($this->convEncIn($path)));\n        // check to infinite loop prevention\n        return ($dirname != $path) ? $dirname : '';\n    }\n\n    /**\n     * Return file name (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function basenameCE($path)\n    {\n        return (!$this->encoding) ? $this->_basename($path) : $this->convEncOut($this->_basename($this->convEncIn($path)));\n    }\n\n    /**\n     * Join dir name and file name and return full path. (with convert encoding)\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function joinPathCE($dir, $name)\n    {\n        return (!$this->encoding) ? $this->_joinPath($dir, $name) : $this->convEncOut($this->_joinPath($this->convEncIn($dir), $this->convEncIn($name)));\n    }\n\n    /**\n     * Return normalized path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function normpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_normpath($path) : $this->convEncOut($this->_normpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file path related to root dir (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function relpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_relpath($path) : $this->convEncOut($this->_relpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Convert path related to root dir into real path (with convert encoding)\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function abspathCE($path)\n    {\n        return (!$this->encoding) ? $this->_abspath($path) : $this->convEncOut($this->_abspath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return true if $path is children of $parent (with convert encoding)\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function inpathCE($path, $parent)\n    {\n        return (!$this->encoding) ? $this->_inpath($path, $parent) : $this->convEncOut($this->_inpath($this->convEncIn($path), $this->convEncIn($parent)));\n    }\n\n    /**\n     * Open file and return file pointer (with convert encoding)\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Naoki Sawada\n     */\n    protected function fopenCE($path, $mode = 'rb')\n    {\n        // check extra option for network stream pointer\n        if (func_num_args() > 2) {\n            $opts = func_get_arg(2);\n        } else {\n            $opts = array();\n        }\n        return (!$this->encoding) ? $this->_fopen($path, $mode, $opts) : $this->convEncOut($this->_fopen($this->convEncIn($path), $mode, $opts));\n    }\n\n    /**\n     * Close opened file (with convert encoding)\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function fcloseCE($fp, $path = '')\n    {\n        return (!$this->encoding) ? $this->_fclose($fp, $path) : $this->convEncOut($this->_fclose($fp, $this->convEncIn($path)));\n    }\n\n    /**\n     * Create new file and write into it from file pointer. (with convert encoding)\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Naoki Sawada\n     **/\n    protected function saveCE($fp, $dir, $name, $stat)\n    {\n        $res = (!$this->encoding) ? $this->_save($fp, $dir, $name, $stat) : $this->convEncOut($this->_save($fp, $this->convEncIn($dir), $this->convEncIn($name), $this->convEncIn($stat)));\n        if ($res !== false) {\n            $this->clearstatcache();\n        }\n        return $res;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function subdirsCE($path)\n    {\n        if ($this->sessionCaching['subdirs']) {\n            if (isset($this->sessionCache['subdirs'][$path]) && !$this->isMyReload()) {\n                return $this->sessionCache['subdirs'][$path];\n            }\n        }\n        $hasdir = (bool)((!$this->encoding) ? $this->_subdirs($path) : $this->convEncOut($this->_subdirs($this->convEncIn($path))));\n        $this->updateSubdirsCache($path, $hasdir);\n        return $hasdir;\n    }\n\n    /**\n     * Return files list in directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function scandirCE($path)\n    {\n        return (!$this->encoding) ? $this->_scandir($path) : $this->convEncOut($this->_scandir($this->convEncIn($path)));\n    }\n\n    /**\n     * Create symlink (with convert encoding)\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function symlinkCE($source, $targetDir, $name)\n    {\n        return (!$this->encoding) ? $this->_symlink($source, $targetDir, $name) : $this->convEncOut($this->_symlink($this->convEncIn($source), $this->convEncIn($targetDir), $this->convEncIn($name)));\n    }\n\n    /***************** paths *******************/\n\n    /**\n     * Encode path into hash\n     *\n     * @param  string  file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function encode($path)\n    {\n        if ($path !== '') {\n\n            // cut ROOT from $path for security reason, even if hacker decodes the path he will not know the root\n            $p = $this->relpathCE($path);\n            // if reqesting root dir $path will be empty, then assign '/' as we cannot leave it blank for crypt\n            if ($p === '') {\n                $p = $this->separator;\n            }\n            // change separator\n            if ($this->separatorForHash) {\n                $p = str_replace($this->separator, $this->separatorForHash, $p);\n            }\n            // TODO crypt path and return hash\n            $hash = $this->crypt($p);\n            // hash is used as id in HTML that means it must contain vaild chars\n            // make base64 html safe and append prefix in begining\n            $hash = strtr(base64_encode($hash), '+/=', '-_.');\n            // remove dots '.' at the end, before it was '=' in base64\n            $hash = rtrim($hash, '.');\n            // append volume id to make hash unique\n            return $this->id . $hash;\n        }\n        //TODO: Add return statement here\n    }\n\n    /**\n     * Decode path from hash\n     *\n     * @param  string  file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function decode($hash)\n    {\n        if (strpos($hash, $this->id) === 0) {\n            // cut volume id after it was prepended in encode\n            $h = substr($hash, strlen($this->id));\n            // replace HTML safe base64 to normal\n            $h = base64_decode(strtr($h, '-_.', '+/='));\n            // TODO uncrypt hash and return path\n            $path = $this->uncrypt($h);\n            // change separator\n            if ($this->separatorForHash) {\n                $path = str_replace($this->separatorForHash, $this->separator, $path);\n            }\n            // append ROOT to path after it was cut in encode\n            return $this->abspathCE($path);//$this->root.($path === $this->separator ? '' : $this->separator.$path);\n        }\n        return '';\n    }\n\n    /**\n     * Return crypted path\n     * Not implemented\n     *\n     * @param  string  path\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function crypt($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Return uncrypted path\n     * Not implemented\n     *\n     * @param  mixed  hash\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function uncrypt($hash)\n    {\n        return $hash;\n    }\n\n    /**\n     * Validate file name based on $this->options['acceptedName'] regexp or function\n     *\n     * @param  string $name file name\n     * @param  bool   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function nameAccepted($name, $isDir = false)\n    {\n        if (json_encode($name) === false) {\n            return false;\n        }\n        $nameValidator = $isDir ? $this->dirnameValidator : $this->nameValidator;\n        if ($nameValidator) {\n            if (is_callable($nameValidator)) {\n                $res = call_user_func($nameValidator, $name);\n                return $res;\n            }\n            if (preg_match($nameValidator, '') !== false) {\n                return preg_match($nameValidator, $name);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return session rootstat cache key\n     *\n     * @return string\n     */\n    protected function getRootstatCachekey()\n    {\n        return md5($this->root . (isset($this->options['alias']) ? $this->options['alias'] : ''));\n    }\n\n    /**\n     * Return new unique name based on file name and suffix\n     *\n     * @param         $dir\n     * @param         $name\n     * @param  string $suffix suffix append to name\n     * @param bool    $checkNum\n     * @param int     $start\n     *\n     * @return string\n     * @internal param string $path file path\n     * @author   Dmitry (dio) Levashov\n     */\n    public function uniqueName($dir, $name, $suffix = ' copy', $checkNum = true, $start = 1)\n    {\n        static $lasts = null;\n\n        if ($lasts === null) {\n            $lasts = array();\n        }\n\n        $ext = '';\n\n        $splits = elFinder::splitFileExtention($name);\n        if ($splits[1]) {\n            $ext = '.' . $splits[1];\n            $name = $splits[0];\n        }\n\n        if ($checkNum && preg_match('/(' . preg_quote($suffix, '/') . ')(\\d*)$/i', $name, $m)) {\n            $i = (int)$m[2];\n            $name = substr($name, 0, strlen($name) - strlen($m[2]));\n        } else {\n            $i = $start;\n            $name .= $suffix;\n        }\n        $max = $i + 100000;\n\n        if (isset($lasts[$name])) {\n            $i = max($i, $lasts[$name]);\n        }\n\n        while ($i <= $max) {\n            $n = $name . ($i > 0 ? sprintf($this->options['uniqueNumFormat'], $i) : '') . $ext;\n\n            if (!$this->isNameExists($this->joinPathCE($dir, $n))) {\n                $this->clearcache();\n                $lasts[$name] = ++$i;\n                return $n;\n            }\n            $i++;\n        }\n        return $name . md5($dir) . $ext;\n    }\n\n    /**\n     * Converts character encoding from UTF-8 to server's one\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is false\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncIn($var = null, $restoreLocale = false, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, 'UTF-8', $this->encoding, $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding from server's one to UTF-8\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is true\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncOut($var = null, $restoreLocale = true, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, $this->encoding, 'UTF-8', $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding (base function)\n     *\n     * @param  mixed  $var     target string or array var\n     * @param  string $from    from character encoding\n     * @param  string $to      to character encoding\n     * @param  string $locale  local locale\n     * @param         $restoreLocale\n     * @param  string $unknown replaces character for unknown\n     *\n     * @return mixed\n     */\n    protected function convEnc($var, $from, $to, $locale, $restoreLocale, $unknown = '_')\n    {\n        if (strtoupper($from) !== strtoupper($to)) {\n            if ($locale) {\n                setlocale(LC_ALL, $locale);\n            }\n            if (is_array($var)) {\n                $_ret = array();\n                foreach ($var as $_k => $_v) {\n                    $_ret[$_k] = $this->convEnc($_v, $from, $to, '', false, $unknown = '_');\n                }\n                $var = $_ret;\n            } else {\n                $_var = false;\n                if (is_string($var)) {\n                    $_var = $var;\n                    $errlev = error_reporting();\n                    error_reporting($errlev ^ E_NOTICE);\n                    if (false !== ($_var = iconv($from, $to . '//TRANSLIT', $_var))) {\n                        $_var = str_replace('?', $unknown, $_var);\n                    }\n                    error_reporting($errlev);\n                }\n                if ($_var !== false) {\n                    $var = $_var;\n                }\n            }\n            if ($restoreLocale) {\n                setlocale(LC_ALL, elFinder::$locale);\n            }\n        }\n        return $var;\n    }\n\n    /**\n     * Normalize MIME-Type by options['mimeMap']\n     *\n     * @param      string $type MIME-Type\n     * @param      string $name Filename\n     * @param      string $ext  File extention without first dot (optional)\n     *\n     * @return     string  Normalized MIME-Type\n     */\n    public function mimeTypeNormalize($type, $name, $ext = '')\n    {\n        if ($ext === '') {\n            $ext = (false === $pos = strrpos($name, '.')) ? '' : substr($name, $pos + 1);\n        }\n        $_checkKey = strtolower($ext . ':' . $type);\n        if ($type === '') {\n            $_keylen = strlen($_checkKey);\n            foreach ($this->options['mimeMap'] as $_key => $_type) {\n                if (substr($_key, 0, $_keylen) === $_checkKey) {\n                    $type = $_type;\n                    break;\n                }\n            }\n        } else if (isset($this->options['mimeMap'][$_checkKey])) {\n            $type = $this->options['mimeMap'][$_checkKey];\n        } else {\n            $_checkKey = strtolower($ext . ':*');\n            if (isset($this->options['mimeMap'][$_checkKey])) {\n                $type = $this->options['mimeMap'][$_checkKey];\n            } else {\n                $_checkKey = strtolower('*:' . $type);\n                if (isset($this->options['mimeMap'][$_checkKey])) {\n                    $type = $this->options['mimeMap'][$_checkKey];\n                }\n            }\n        }\n        return $type;\n    }\n\n    /*********************** util mainly for inheritance class *********************/\n\n    /**\n     * Get temporary filename. Tempfile will be removed when after script execution finishes or exit() is called.\n     * When needing the unique file to a path, give $path to parameter.\n     *\n     * @param  string $path for get unique file to a path\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     */\n    protected function getTempFile($path = '')\n    {\n        static $cache = array();\n\n        $key = '';\n        if ($path !== '') {\n            $key = $this->id . '#' . $path;\n            if (isset($cache[$key])) {\n                return $cache[$key];\n            }\n        }\n\n        if ($tmpdir = $this->getTempPath()) {\n            $name = tempnam($tmpdir, 'ELF');\n            if ($key) {\n                $cache[$key] = $name;\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$name] = true;\n            return $name;\n        }\n\n        return false;\n    }\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path path need convert encoding to server encoding\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        if ($wfp = $this->tmpfile()) {\n            if ($fp = $this->_fopen($path)) {\n                while (!feof($fp)) {\n                    fwrite($wfp, fread($fp, 8192));\n                }\n                $info = stream_get_meta_data($wfp);\n                fclose($wfp);\n                if ($info && !empty($info['uri'])) {\n                    return $info['uri'];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get image size array with `dimensions`\n     *\n     * @param string $path path need convert encoding to server encoding\n     * @param string $mime file mime type\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getImageSize($path, $mime = '')\n    {\n        $size = false;\n        if ($mime === '' || strtolower(substr($mime, 0, 5)) === 'image') {\n            if ($work = $this->getWorkFile($path)) {\n                if ($size = getimagesize($work)) {\n                    $size['dimensions'] = $size[0] . 'x' . $size[1];\n                    $srcfp = fopen($work, 'rb');\n                    $cArgs = elFinder::$currentArgs;\n                    if (!empty($cArgs['target']) && $subImgLink = $this->getSubstituteImgLink($cArgs['target'], $size, $srcfp)) {\n                        $size['url'] = $subImgLink;\n                    }\n                }\n            }\n            is_file($work) && unlink($work);\n        }\n        return $size;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        foreach ($this->_scandir($localpath) as $p) {\n            elFinder::checkAborted();\n            $stat = $this->stat($this->convEncOut($p));\n            $this->convEncIn();\n            ($stat['mime'] === 'directory') ? $this->delTree($p) : $this->_unlink($p);\n        }\n        $res = $this->_rmdir($localpath);\n        $res && $this->clearstatcache();\n        return $res;\n    }\n\n    /**\n     * Copy items to a new temporary directory on the local server\n     *\n     * @param  array  $hashes  target hashes\n     * @param  string $dir     destination directory (for recurcive)\n     * @param  string $canLink it can use link() (for recurcive)\n     *\n     * @return string|false    saved path name\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function getItemsInHand($hashes, $dir = null, $canLink = null)\n    {\n        static $banChrs = null;\n        static $totalSize = 0;\n\n        if  (is_null($banChrs)) {\n            $banChrs = DIRECTORY_SEPARATOR !== '/'? array('\\\\', '/', ':', '*', '?', '\"', '<', '>', '|') : array('\\\\', '/');\n        }\n\n        if (is_null($dir)) {\n            $totalSize = 0;\n            if (!$tmpDir = $this->getTempPath()) {\n                return false;\n            }\n            $dir = tempnam($tmpDir, 'elf');\n            if (!unlink($dir) || !mkdir($dir, 0700, true)) {\n                return false;\n            }\n            register_shutdown_function(array($this, 'rmdirRecursive'), $dir);\n        }\n        if (is_null($canLink)) {\n            $canLink = ($this instanceof elFinderVolumeLocalFileSystem);\n        }\n        elFinder::checkAborted();\n        $res = true;\n        $files = array();\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                continue;\n            }\n            if (!$file['read']) {\n                continue;\n            }\n\n            $name = $file['name'];\n            // remove ctrl characters\n            $name = preg_replace('/[[:cntrl:]]+/', '', $name);\n            // replace ban characters\n            $name = str_replace($banChrs, '_', $name);\n\n            // for call from search results\n            if (isset($files[$name])) {\n                $name = preg_replace('/^(.*?)(\\..*)?$/', '$1_' . $files[$name]++ . '$2', $name);\n            } else {\n                $files[$name] = 1;\n            }\n            $target = $dir . DIRECTORY_SEPARATOR . $name;\n\n            if ($file['mime'] === 'directory') {\n                $chashes = array();\n                $_files = $this->scandir($hash);\n                foreach ($_files as $_file) {\n                    if ($file['read']) {\n                        $chashes[] = $_file['hash'];\n                    }\n                }\n                if (($res = mkdir($target, 0700, true)) && $chashes) {\n                    $res = $this->getItemsInHand($chashes, $target, $canLink);\n                }\n                if (!$res) {\n                    break;\n                }\n                !empty($file['ts']) && touch($target, $file['ts']);\n            } else {\n                $path = $this->decode($hash);\n                if (!$canLink || !($canLink = $this->localFileSystemSymlink($path, $target))) {\n                    if (file_exists($target)) {\n                        unlink($target);\n                    }\n                    if ($fp = $this->fopenCE($path)) {\n                        if ($tfp = fopen($target, 'wb')) {\n                            $totalSize += stream_copy_to_stream($fp, $tfp);\n                            fclose($tfp);\n                        }\n                        !empty($file['ts']) && touch($target, $file['ts']);\n                        $this->fcloseCE($fp, $path);\n                    }\n                } else {\n                    $totalSize += filesize($path);\n                }\n                if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $totalSize) {\n                    $res = $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n                }\n            }\n        }\n        return $res ? $dir : false;\n    }\n\n    /*********************** file stat *********************/\n\n    /**\n     * Check file attribute\n     *\n     * @param  string $path  file path\n     * @param  string $name  attribute name (read|write|locked|hidden)\n     * @param  bool   $val   attribute value returned by file system\n     * @param  bool   $isDir path is directory (true: directory, false: file)\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function attr($path, $name, $val = null, $isDir = null)\n    {\n        if (!isset($this->defaults[$name])) {\n            return false;\n        }\n\n        $relpath = $this->relpathCE($path);\n        if ($this->separator !== '/') {\n            $relpath = str_replace($this->separator, '/', $relpath);\n        }\n        $relpath = '/' . $relpath;\n\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, $name, $path, $this->options['accessControlData'], $this, $isDir, $relpath);\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        foreach ($this->attributes as $attrs) {\n            if (isset($attrs[$name]) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $relpath)) {\n                $perm = $attrs[$name];\n                break;\n            }\n        }\n\n        return $perm === null ? (is_null($val) ? $this->defaults[$name] : $val) : !!$perm;\n    }\n\n    /**\n     * Return true if file with given name can be created in given folder.\n     *\n     * @param string $dir  parent dir path\n     * @param string $name new file name\n     * @param null   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function allowCreate($dir, $name, $isDir = null)\n    {\n        return $this->attr($this->joinPathCE($dir, $name), 'write', true, $isDir);\n    }\n\n    /**\n     * Return true if file MIME type can save with check uploadOrder config.\n     *\n     * @param string $mime\n     *\n     * @return boolean\n     */\n    protected function allowPutMime($mime)\n    {\n        // logic based on http://httpd.apache.org/docs/2.2/mod/mod_authz_host.html#order\n        $allow = $this->mimeAccepted($mime, $this->uploadAllow, null);\n        $deny = $this->mimeAccepted($mime, $this->uploadDeny, null);\n        if (strtolower($this->uploadOrder[0]) == 'allow') { // array('allow', 'deny'), default is to 'deny'\n            $res = false; // default is deny\n            if (!$deny && ($allow === true)) { // match only allow\n                $res = true;\n            }// else (both match | no match | match only deny) { deny }\n        } else { // array('deny', 'allow'), default is to 'allow' - this is the default rule\n            $res = true; // default is allow\n            if (($deny === true) && !$allow) { // match only deny\n                $res = false;\n            } // else (both match | no match | match only allow) { allow }\n        }\n        return $res;\n    }\n\n    /**\n     * Return fileinfo\n     *\n     * @param  string $path file cache\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function stat($path)\n    {\n        if ($path === false || is_null($path)) {\n            return false;\n        }\n        $is_root = ($path == $this->root);\n        if ($is_root) {\n            $rootKey = $this->getRootstatCachekey();\n            if ($this->sessionCaching['rootstat'] && !isset($this->sessionCache['rootstat'])) {\n                $this->sessionCache['rootstat'] = array();\n            }\n            if (!isset($this->cache[$path]) && !$this->isMyReload()) {\n                // need $path as key for netmount/netunmount\n                if ($this->sessionCaching['rootstat'] && isset($this->sessionCache['rootstat'][$rootKey])) {\n                    if ($ret = $this->sessionCache['rootstat'][$rootKey]) {\n                        if ($this->options['rootRev'] === $ret['rootRev']) {\n                            if (isset($this->options['phash'])) {\n                                $ret['isroot'] = 1;\n                                $ret['phash'] = $this->options['phash'];\n                            }\n                            return $ret;\n                        }\n                    }\n                }\n            }\n        }\n        $rootSessCache = false;\n        if (isset($this->cache[$path])) {\n            $ret = $this->cache[$path];\n        } else {\n            if ($is_root && !empty($this->options['rapidRootStat']) && is_array($this->options['rapidRootStat']) && !$this->needOnline) {\n                $ret = $this->updateCache($path, $this->options['rapidRootStat'], true);\n            } else {\n                $ret = $this->updateCache($path, $this->convEncOut($this->_stat($this->convEncIn($path))), true);\n                if ($is_root && !empty($rootKey) && $this->sessionCaching['rootstat']) {\n                    $rootSessCache = true;\n                }\n            }\n        } \n        if ($is_root) {\n            if ($ret) {\n                $this->rootModified = false;\n                if ($rootSessCache) {\n                    $this->sessionCache['rootstat'][$rootKey] = $ret;\n                }\n                if (isset($this->options['phash'])) {\n                    $ret['isroot'] = 1;\n                    $ret['phash'] = $this->options['phash'];\n                }\n            } else if (!empty($rootKey) && $this->sessionCaching['rootstat']) {\n                unset($this->sessionCache['rootstat'][$rootKey]);\n            }\n        }\n        return $ret;\n    }\n\n    /**\n     * Get root stat extra key values\n     *\n     * @return array stat extras\n     * @author Naoki Sawada\n     */\n    protected function getRootStatExtra()\n    {\n        $stat = array();\n        if ($this->rootName) {\n            $stat['name'] = $this->rootName;\n        }\n        $stat['rootRev'] = $this->options['rootRev'];\n        $stat['options'] = $this->options(null);\n        return $stat;\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array\n     */\n    protected function isNameExists($path)\n    {\n        return $this->stat($path);\n    }\n\n    /**\n     * Put file stat in cache and return it\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function updateCache($path, $stat)\n    {\n        if (empty($stat) || !is_array($stat)) {\n            return $this->cache[$path] = array();\n        }\n\n        if (func_num_args() > 2) {\n            $fromStat = func_get_arg(2);\n        } else {\n            $fromStat = false;\n        }\n\n        $stat['hash'] = $this->encode($path);\n\n        $root = $path == $this->root;\n        $parent = '';\n\n        if ($root) {\n            $stat = array_merge($stat, $this->getRootStatExtra());\n        } else {\n            if (!isset($stat['name']) || $stat['name'] === '') {\n                $stat['name'] = $this->basenameCE($path);\n            }\n            if (empty($stat['phash'])) {\n                $parent = $this->dirnameCE($path);\n                $stat['phash'] = $this->encode($parent);\n            } else {\n                $parent = $this->decode($stat['phash']);\n            }\n        }\n\n        // name check\n        if (isset($stat['name']) && !$jeName = json_encode($stat['name'])) {\n            return $this->cache[$path] = array();\n        }\n        // fix name if required\n        if ($this->options['utf8fix'] && $this->options['utf8patterns'] && $this->options['utf8replace']) {\n            $stat['name'] = json_decode(str_replace($this->options['utf8patterns'], $this->options['utf8replace'], $jeName));\n        }\n\n        if (!isset($stat['size'])) {\n            $stat['size'] = 'unknown';\n        }\n\n        $mime = isset($stat['mime']) ? $stat['mime'] : '';\n        if ($isDir = ($mime === 'directory')) {\n            $stat['volumeid'] = $this->id;\n        } else {\n            if (empty($stat['mime']) || $stat['size'] == 0) {\n                $stat['mime'] = $this->mimetype($stat['name'], true, $stat['size'], $mime);\n            } else {\n                $stat['mime'] = $this->mimeTypeNormalize($stat['mime'], $stat['name']);\n            }\n        }\n\n        $stat['read'] = intval($this->attr($path, 'read', isset($stat['read']) ? !!$stat['read'] : null, $isDir));\n        $stat['write'] = intval($this->attr($path, 'write', isset($stat['write']) ? !!$stat['write'] : null, $isDir));\n        if ($root) {\n            $stat['locked'] = 1;\n            if ($this->options['type'] !== '') {\n                $stat['type'] = $this->options['type'];\n            }\n        } else {\n            // lock when parent directory is not writable\n            if (!isset($stat['locked'])) {\n                $pstat = $this->stat($parent);\n                if (isset($pstat['write']) && !$pstat['write']) {\n                    $stat['locked'] = true;\n                }\n            }\n            if ($this->attr($path, 'locked', isset($stat['locked']) ? !!$stat['locked'] : null, $isDir)) {\n                $stat['locked'] = 1;\n            } else {\n                unset($stat['locked']);\n            }\n        }\n\n        if ($root) {\n            unset($stat['hidden']);\n        } elseif ($this->attr($path, 'hidden', isset($stat['hidden']) ? !!$stat['hidden'] : null, $isDir)\n            || !$this->mimeAccepted($stat['mime'])) {\n            $stat['hidden'] = 1;\n        } else {\n            unset($stat['hidden']);\n        }\n\n        if ($stat['read'] && empty($stat['hidden'])) {\n\n            if ($isDir) {\n                // caching parent's subdirs\n                if ($parent) {\n                    $this->updateSubdirsCache($parent, true);\n                }\n                // for dir - check for subdirs\n                if ($this->options['checkSubfolders']) {\n                    if (!isset($stat['dirs']) && intval($this->options['checkSubfolders']) === -1) {\n                        $stat['dirs'] = -1;\n                    }\n                    if (isset($stat['dirs'])) {\n                        if ($stat['dirs']) {\n                            if ($stat['dirs'] == -1) {\n                                $stat['dirs'] = ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) ? (int)$this->sessionCache['subdirs'][$path] : -1;\n                            } else {\n                                $stat['dirs'] = 1;\n                            }\n                        } else {\n                            unset($stat['dirs']);\n                        }\n                    } elseif (!empty($stat['alias']) && !empty($stat['target'])) {\n                        $stat['dirs'] = isset($this->cache[$stat['target']])\n                            ? intval(isset($this->cache[$stat['target']]['dirs']))\n                            : $this->subdirsCE($stat['target']);\n\n                    } elseif ($this->subdirsCE($path)) {\n                        $stat['dirs'] = 1;\n                    }\n                } else {\n                    $stat['dirs'] = 1;\n                }\n                if ($this->options['dirUrlOwn'] === true) {\n                    // Set `null` to use the client option `commandsOptions.info.nullUrlDirLinkSelf = true`\n                    $stat['url'] = null;\n                } else if ($this->options['dirUrlOwn'] === 'hide') {\n                    // to hide link in info dialog of the elFinder client\n                    $stat['url'] = '';\n                }\n            } else {\n                // for files - check for thumbnails\n                $p = isset($stat['target']) ? $stat['target'] : $path;\n                if ($this->tmbURL && !isset($stat['tmb']) && $this->canCreateTmb($p, $stat)) {\n                    $tmb = $this->gettmb($p, $stat);\n                    $stat['tmb'] = $tmb ? $tmb : 1;\n                }\n\n            }\n            if (!isset($stat['url']) && $this->URL && $this->encoding) {\n                $_path = str_replace($this->separator, '/', substr($path, strlen($this->root) + 1));\n                $stat['url'] = rtrim($this->URL, '/') . '/' . str_replace('%2F', '/', rawurlencode((substr(PHP_OS, 0, 3) === 'WIN') ? $_path : $this->convEncIn($_path, true)));\n            }\n        } else {\n            if ($isDir) {\n                unset($stat['dirs']);\n            }\n        }\n\n        if (!empty($stat['alias']) && !empty($stat['target'])) {\n            $stat['thash'] = $this->encode($stat['target']);\n            //$this->cache[$stat['target']] = $stat;\n            unset($stat['target']);\n        }\n\n        $this->cache[$path] = $stat;\n\n        if (!$fromStat && $root && $this->sessionCaching['rootstat']) {\n            // to update session cache\n            $this->stat($path);\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat for folder content and put in cache\n     *\n     * @param  string $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        foreach ($this->scandirCE($path) as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        $this->updateSubdirsCache($path, $hasDir);\n    }\n\n    /**\n     * Clean cache\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function clearcache()\n    {\n        $this->cache = $this->dirsCache = array();\n    }\n\n    /**\n     * Return file mimetype\n     *\n     * @param  string      $path file path\n     * @param  string|bool $name\n     * @param  integer     $size\n     * @param  string      $mime was notified from the volume driver\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     */\n    protected function mimetype($path, $name = '', $size = null, $mime = null)\n    {\n        $type = '';\n        $nameCheck = false;\n\n        if ($name === '') {\n            $name = $path;\n        } else if ($name === true) {\n            $name = $path;\n            $nameCheck = true;\n        }\n        if (!$this instanceof elFinderVolumeLocalFileSystem) {\n            $nameCheck = true;\n        }\n        $ext = (false === $pos = strrpos($name, '.')) ? '' : strtolower(substr($name, $pos + 1));\n        if (!$nameCheck && $size === null) {\n            $size = file_exists($path) ? filesize($path) : -1;\n        }\n        if (!$nameCheck && is_readable($path) && $size > 0) {\n            // detecting by contents\n            if ($this->mimeDetect === 'finfo') {\n                $type = finfo_file($this->finfo, $path);\n            } else if ($this->mimeDetect === 'mime_content_type') {\n                $type = mime_content_type($path);\n            }\n            if ($type) {\n                $type = explode(';', $type);\n                $type = trim($type[0]);\n                if ($ext && preg_match('~^application/(?:octet-stream|(?:x-)?zip|xml)$~', $type)) {\n                    // load default MIME table file \"mime.types\"\n                    if (!elFinderVolumeDriver::$mimetypesLoaded) {\n                        elFinderVolumeDriver::loadMimeTypes();\n                    }\n                    if (isset(elFinderVolumeDriver::$mimetypes[$ext])) {\n                        $type = elFinderVolumeDriver::$mimetypes[$ext];\n                    }\n                } else if ($ext === 'js' && preg_match('~^text/~', $type)) {\n                    $type = 'text/javascript';\n                }\n            }\n        }\n        if (!$type) {\n            // detecting by filename\n            $type = elFinderVolumeDriver::mimetypeInternalDetect($name);\n            if ($type === 'unknown') {\n                if ($mime) {\n                    $type = $mime;\n                } else {\n                    $type = ($size == 0) ? 'text/plain' : $this->options['mimeTypeUnknown'];\n                }\n            }\n        }\n\n        // mime type normalization\n        $type = $this->mimeTypeNormalize($type, $name, $ext);\n\n        return $type;\n    }\n\n    /**\n     * Load file of mime.types\n     *\n     * @param string $mimeTypesFile The mime types file\n     */\n    static protected function loadMimeTypes($mimeTypesFile = '')\n    {\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::$mimetypesLoaded = true;\n            $file = false;\n            if (!empty($mimeTypesFile) && file_exists($mimeTypesFile)) {\n                $file = $mimeTypesFile;\n            } elseif (elFinder::$defaultMimefile && file_exists(elFinder::$defaultMimefile)) {\n                $file = elFinder::$defaultMimefile;\n            } elseif (file_exists(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types';\n            } elseif (file_exists(dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types';\n            }\n\n            if ($file && file_exists($file)) {\n                $mimecf = file($file);\n\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size; $i++) {\n                            if (!isset(self::$mimetypes[$mime[$i]])) {\n                                self::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Detect file mimetype using \"internal\" method or Loading mime.types with $path = ''\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    static protected function mimetypeInternalDetect($path = '')\n    {\n        // load default MIME table file \"mime.types\"\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        $ext = '';\n        if ($path) {\n            $pinfo = pathinfo($path);\n            $ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';\n        }\n        return ($ext && isset(elFinderVolumeDriver::$mimetypes[$ext])) ? elFinderVolumeDriver::$mimetypes[$ext] : 'unknown';\n    }\n\n    /**\n     * Return file/total directory size infomation\n     *\n     * @param  string $path file path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function countSize($path)\n    {\n\n        elFinder::checkAborted();\n\n        $result = array('size' => 0, 'files' => 0, 'dirs' => 0);\n        $stat = $this->stat($path);\n\n        if (empty($stat) || !$stat['read'] || !empty($stat['hidden'])) {\n            $result['size'] = 'unknown';\n            return $result;\n        }\n\n        if ($stat['mime'] !== 'directory') {\n            $result['size'] = intval($stat['size']);\n            $result['files'] = 1;\n            return $result;\n        }\n\n        $result['dirs'] = 1;\n        $subdirs = $this->options['checkSubfolders'];\n        $this->options['checkSubfolders'] = true;\n        foreach ($this->getScandir($path) as $stat) {\n            if ($isDir = ($stat['mime'] === 'directory' && $stat['read'])) {\n                ++$result['dirs'];\n            } else {\n                ++$result['files'];\n            }\n            $res = $isDir\n                ? $this->countSize($this->decode($stat['hash']))\n                : (isset($stat['size']) ? array('size' => intval($stat['size'])) : array());\n            if (!empty($res['size']) && is_numeric($res['size'])) {\n                $result['size'] += $res['size'];\n            }\n            if (!empty($res['files']) && is_numeric($res['files'])) {\n                $result['files'] += $res['files'];\n            }\n            if (!empty($res['dirs']) && is_numeric($res['dirs'])) {\n                $result['dirs'] += $res['dirs'];\n                --$result['dirs'];\n            }\n        }\n        $this->options['checkSubfolders'] = $subdirs;\n        return $result;\n    }\n\n    /**\n     * Return true if all mimes is directory or files\n     *\n     * @param  string $mime1 mimetype\n     * @param  string $mime2 mimetype\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function isSameType($mime1, $mime2)\n    {\n        return ($mime1 == 'directory' && $mime1 == $mime2) || ($mime1 != 'directory' && $mime2 != 'directory');\n    }\n\n    /**\n     * If file has required attr == $val - return file path,\n     * If dir has child with has required attr == $val - return child path\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function closestByAttr($path, $attr, $val)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return false;\n        }\n\n        $v = isset($stat[$attr]) ? $stat[$attr] : false;\n\n        if ($v == $val) {\n            return $path;\n        }\n\n        return $stat['mime'] == 'directory'\n            ? $this->childsByAttr($path, $attr, $val)\n            : false;\n    }\n\n    /**\n     * Return first found children with required attr == $val\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function childsByAttr($path, $attr, $val)\n    {\n        foreach ($this->scandirCE($path) as $p) {\n            if (($_p = $this->closestByAttr($p, $attr, $val)) != false) {\n                return $_p;\n            }\n        }\n        return false;\n    }\n\n    protected function isMyReload($target = '', $ARGtarget = '')\n    {\n        if ($this->rootModified || (!empty($this->ARGS['cmd']) && $this->ARGS['cmd'] === 'parents')) {\n            return true;\n        }\n        if (!empty($this->ARGS['reload'])) {\n            if ($ARGtarget === '') {\n                $ARGtarget = isset($this->ARGS['target']) ? $this->ARGS['target']\n                    : ((isset($this->ARGS['targets']) && is_array($this->ARGS['targets']) && count($this->ARGS['targets']) === 1) ?\n                        $this->ARGS['targets'][0] : '');\n            }\n            if ($ARGtarget !== '') {\n                $ARGtarget = strval($ARGtarget);\n                if ($target === '') {\n                    return (strpos($ARGtarget, $this->id) === 0);\n                } else {\n                    $target = strval($target);\n                    return ($target === $ARGtarget);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Update subdirs cache data\n     *\n     * @param string $path\n     * @param bool   $subdirs\n     *\n     * @return void\n     */\n    protected function updateSubdirsCache($path, $subdirs)\n    {\n        if (isset($this->cache[$path])) {\n            if ($subdirs) {\n                $this->cache[$path]['dirs'] = 1;\n            } else {\n                unset($this->cache[$path]['dirs']);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            $this->sessionCache['subdirs'][$path] = $subdirs;\n        }\n        if ($this->sessionCaching['rootstat'] && $path == $this->root) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n    }\n\n    /*****************  get content *******************/\n\n    /**\n     * Return required dir's files info.\n     * If onlyMimes is set - return only dirs and files of required mimes\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function getScandir($path)\n    {\n        $files = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                $files[] = $stat;\n            }\n        }\n\n        return $files;\n    }\n\n\n    /**\n     * Return subdirs tree\n     *\n     * @param  string $path parent dir path\n     * @param  int    $deep tree deep\n     * @param string  $exclude\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function gettree($path, $deep, $exclude = '')\n    {\n        $dirs = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            $stat = $this->stat($p);\n\n            if ($stat && empty($stat['hidden']) && $p != $exclude && $stat['mime'] == 'directory') {\n                $dirs[] = $stat;\n                if ($deep > 0 && !empty($stat['dirs'])) {\n                    $dirs = array_merge($dirs, $this->gettree($p, $deep - 1));\n                }\n            }\n        }\n\n        return $dirs;\n    }\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        $result = array();\n        $matchMethod = empty($this->doSearchCurrentQuery['matchMethod']) ? 'searchMatchName' : $this->doSearchCurrentQuery['matchMethod'];\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n\n        foreach ($this->scandirCE($path) as $p) {\n            elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n            if ($timeout && ($this->error || $timeout < time())) {\n                !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n                break;\n            }\n\n\n            $stat = $this->stat($p);\n\n            if (!$stat) { // invalid links\n                continue;\n            }\n\n            if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                continue;\n            }\n\n            $name = $stat['name'];\n\n            if ($this->doSearchCurrentQuery['excludes']) {\n                foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                    if ($this->stripos($name, $exclude) !== false) {\n                        continue 2;\n                    }\n                }\n            }\n\n            if ((!$mimes || $stat['mime'] !== 'directory') && $this->$matchMethod($name, $q, $p) !== false) {\n                $stat['path'] = $this->path($stat['hash']);\n                if ($this->URL && !isset($stat['url'])) {\n                    $path = str_replace($this->separator, '/', substr($p, strlen($this->root) + 1));\n                    if ($this->encoding) {\n                        $path = str_replace('%2F', '/', rawurlencode($this->convEncIn($path, true)));\n                    } else {\n                        $path = str_replace('%2F', '/', rawurlencode($path));\n                    }\n                    $stat['url'] = $this->URL . $path;\n                }\n\n                $result[] = $stat;\n            }\n            if ($stat['mime'] == 'directory' && $stat['read'] && !isset($stat['alias'])) {\n                if (!$this->options['searchExDirReg'] || !preg_match($this->options['searchExDirReg'], $p)) {\n                    $result = array_merge($result, $this->doSearch($p, $q, $mimes));\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**********************  manuipulations  ******************/\n\n    /**\n     * Copy file/recursive copy dir only in current volume.\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name (optionaly)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copy($src, $dst, $name)\n    {\n\n        elFinder::checkAborted();\n\n        $srcStat = $this->stat($src);\n\n        if (!empty($srcStat['thash'])) {\n            $target = $this->decode($srcStat['thash']);\n            if (!$this->inpathCE($target, $this->root)) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']), elFinder::ERROR_MKOUTLINK);\n            }\n            $stat = $this->stat($target);\n            $this->clearcache();\n            return $stat && $this->symlinkCE($target, $dst, $name)\n                ? $this->joinPathCE($dst, $name)\n                : $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n        }\n\n        if ($srcStat['mime'] === 'directory') {\n            $testStat = $this->isNameExists($this->joinPathCE($dst, $name));\n            $this->clearcache();\n\n            if (($testStat && $testStat['mime'] !== 'directory') || (!$testStat && !$testStat = $this->mkdir($this->encode($dst), $name))) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n            }\n\n            $dst = $this->decode($testStat['hash']);\n\n            // start time\n            $stime = microtime(true);\n            foreach ($this->getScandir($src) as $stat) {\n                if (empty($stat['hidden'])) {\n                    // current time\n                    $ctime = microtime(true);\n                    if (($ctime - $stime) > 2) {\n                        $stime = $ctime;\n                        elFinder::checkAborted();\n                    }\n                    $name = $stat['name'];\n                    $_src = $this->decode($stat['hash']);\n                    if (!$this->copy($_src, $dst, $name)) {\n                        $this->remove($dst, true); // fall back\n                        return $this->setError($this->error, elFinder::ERROR_COPY, $this->_path($src));\n                    }\n                }\n            }\n\n            $this->added[] = $testStat;\n\n            return $dst;\n        }\n\n        if ($this->options['copyJoin']) {\n            $test = $this->joinPathCE($dst, $name);\n            if ($this->isNameExists($test)) {\n                $this->remove($test);\n            }\n        }\n        if ($res = $this->convEncOut($this->_copy($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->clearstatcache();\n            $this->added[] = $this->stat($path);\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n    }\n\n    /**\n     * Move file\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function move($src, $dst, $name)\n    {\n        $stat = $this->stat($src);\n        $stat['realpath'] = $src;\n        $this->rmTmb($stat); // can not do rmTmb() after _move()\n        $this->clearcache();\n\n        if ($res = $this->convEncOut($this->_move($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            if ($stat['mime'] === 'directory') {\n                $this->updateSubdirsCache($dst, true);\n            }\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->added[] = $this->stat($path);\n            $this->removed[] = $stat;\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_MOVE, $this->path($stat['hash']));\n    }\n\n    /**\n     * Copy file from another volume.\n     * Return new file path or false.\n     *\n     * @param  Object $volume      source volume\n     * @param  string $src         source file hash\n     * @param  string $destination destination dir path\n     * @param  string $name        file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copyFrom($volume, $src, $destination, $name)\n    {\n\n        elFinder::checkAborted();\n\n        if (($source = $volume->file($src)) == false) {\n            return $this->addError(elFinder::ERROR_COPY, '#' . $src, $volume->error());\n        }\n\n        $srcIsDir = ($source['mime'] === 'directory');\n\n        $errpath = $volume->path($source['hash']);\n\n        $errors = array();\n        try {\n            $thash = $this->encode($destination);\n            elFinder::$instance->trigger('paste.copyfrom', array(&$thash, &$name, '', elFinder::$instance, $this), $errors);\n        } catch (elFinderTriggerException $e) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $errors);\n        }\n\n        if (!$this->nameAccepted($name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $srcIsDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$this->allowCreate($destination, $name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$source['read']) {\n            return $this->addError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($srcIsDir) {\n            $test = $this->isNameExists($this->joinPathCE($destination, $name));\n            $this->clearcache();\n\n            if (($test && $test['mime'] != 'directory') || (!$test && !$test = $this->mkdir($this->encode($destination), $name))) {\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n\n            //$path = $this->joinPathCE($destination, $name);\n            $path = $this->decode($test['hash']);\n\n            foreach ($volume->scandir($src) as $entr) {\n                $this->copyFrom($volume, $entr['hash'], $path, $entr['name']);\n            }\n\n            $this->added[] = $test;\n        } else {\n            // size check\n            if (!isset($source['size']) || $source['size'] > $this->uploadMaxSize) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n            }\n\n            // MIME check\n            $mimeByName = $this->mimetype($source['name'], true);\n            if ($source['mime'] === $mimeByName) {\n                $mimeByName = '';\n            }\n            if (!$this->allowPutMime($source['mime']) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n                return $this->addError(elFinder::ERROR_UPLOAD_FILE_MIME, $errpath);\n            }\n\n            if (strpos($source['mime'], 'image') === 0 && ($dim = $volume->dimensions($src))) {\n                if (is_array($dim)) {\n                    $dim = isset($dim['dim']) ? $dim['dim'] : null;\n                }\n                if ($dim) {\n                    $s = explode('x', $dim);\n                    $source['width'] = $s[0];\n                    $source['height'] = $s[1];\n                }\n            }\n\n            if (($fp = $volume->open($src)) == false\n                || ($path = $this->saveCE($fp, $destination, $name, $source)) == false) {\n                $fp && $volume->close($fp, $src);\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n            $volume->close($fp, $src);\n\n            $this->added[] = $this->stat($path);;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove file/ recursive remove dir\n     *\n     * @param  string $path  file path\n     * @param  bool   $force try to remove even if file locked\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function remove($path, $force = false)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return $this->setError(elFinder::ERROR_RM, $path, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $stat['realpath'] = $path;\n        $this->rmTmb($stat);\n        $this->clearcache();\n\n        if (!$force && !empty($stat['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n        }\n\n        if ($stat['mime'] == 'directory' && empty($stat['thash'])) {\n            $ret = $this->delTree($this->convEncIn($path));\n            $this->convEncOut();\n            if (!$ret) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        } else {\n            if ($this->convEncOut(!$this->_unlink($this->convEncIn($path)))) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n            $this->clearstatcache();\n        }\n\n        $this->removed[] = $stat;\n        return true;\n    }\n\n\n    /************************* thumbnails **************************/\n\n    /**\n     * Return thumbnail file name for required file\n     *\n     * @param  array $stat file stat\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tmbname($stat)\n    {\n        $name = $stat['hash'] . (isset($stat['ts']) ? $stat['ts'] : '') . '.png';\n        if (strlen($name) > 255) {\n            $name = $this->id . md5($stat['hash']) . $stat['ts'] . '.png';\n        }\n        return $name;\n    }\n\n    /**\n     * Return thumnbnail name if exists\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettmb($path, $stat)\n    {\n        if ($this->tmbURL && $this->tmbPath) {\n            // file itself thumnbnail\n            if (strpos($path, $this->tmbPath) === 0) {\n                return basename($path);\n            }\n\n            $name = $this->tmbname($stat);\n            $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n            if (file_exists($tmb)) {\n                if ($this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                    touch($tmb);\n                }\n                return $name;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if thumnbnail for required file can be created\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     * @param  bool   $checkTmbPath\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canCreateTmb($path, $stat, $checkTmbPath = true)\n    {\n        static $gdMimes = null;\n        static $imgmgPS = null;\n        if ($gdMimes === null) {\n            $_mimes = array('image/jpeg', 'image/png', 'image/gif', 'image/x-ms-bmp');\n            if (function_exists('imagecreatefromwebp')) {\n                $_mimes[] = 'image/webp';\n            }\n            $gdMimes = array_flip($_mimes);\n            $imgmgPS = array_flip(array('application/postscript', 'application/pdf'));\n        }\n        if ((!$checkTmbPath || $this->tmbPathWritable)\n            && (!$this->tmbPath || strpos($path, $this->tmbPath) === false) // do not create thumnbnail for thumnbnail\n        ) {\n            $mime = strtolower($stat['mime']);\n            list($type) = explode('/', $mime);\n            if (!empty($this->imgConverter)) {\n                if (isset($this->imgConverter[$mime])) {\n                    return true;\n                }\n                if (isset($this->imgConverter[$type])) {\n                    return true;\n                }\n            }\n            return $this->imgLib\n                && (\n                    ($type === 'image' && ($this->imgLib === 'gd' ? isset($gdMimes[$stat['mime']]) : true))\n                    ||\n                    (ELFINDER_IMAGEMAGICK_PS && isset($imgmgPS[$stat['mime']]) && $this->imgLib !== 'gd')\n                );\n        }\n        return false;\n    }\n\n    /**\n     * Return true if required file can be resized.\n     * By default - the same as canCreateTmb\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canResize($path, $stat)\n    {\n        return $this->canCreateTmb($path, $stat, false);\n    }\n\n    /**\n     * Create thumnbnail and return it's URL on success\n     *\n     * @param  string $path file path\n     * @param         $stat\n     *\n     * @return false|string\n     * @internal param string $mime file mime type\n     * @throws elFinderAbortException\n     * @throws ImagickException\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function createTmb($path, $stat)\n    {\n        if (!$stat || !$this->canCreateTmb($path, $stat)) {\n            return false;\n        }\n\n        $name = $this->tmbname($stat);\n        $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n\n        $maxlength = -1;\n        $imgConverter = null;\n\n        // check imgConverter\n        $mime = strtolower($stat['mime']);\n        list($type) = explode('/', $mime);\n        if (isset($this->imgConverter[$mime])) {\n            $imgConverter = $this->imgConverter[$mime]['func'];\n            if (!empty($this->imgConverter[$mime]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$mime]['maxlen']);\n            }\n        } else if (isset($this->imgConverter[$type])) {\n            $imgConverter = $this->imgConverter[$type]['func'];\n            if (!empty($this->imgConverter[$type]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$type]['maxlen']);\n            }\n        }\n        if ($imgConverter && !is_callable($imgConverter)) {\n            return false;\n        }\n\n        // copy image into tmbPath so some drivers does not store files on local fs\n        if (($src = $this->fopenCE($path, 'rb')) == false) {\n            return false;\n        }\n\n        if (($trg = fopen($tmb, 'wb')) == false) {\n            $this->fcloseCE($src, $path);\n            return false;\n        }\n\n        stream_copy_to_stream($src, $trg, $maxlength);\n\n        $this->fcloseCE($src, $path);\n        fclose($trg);\n\n        // call imgConverter\n        if ($imgConverter) {\n            if (!call_user_func_array($imgConverter, array($tmb, $stat, $this))) {\n                file_exists($tmb) && unlink($tmb);\n                return false;\n            }\n        }\n\n        $result = false;\n\n        $tmbSize = $this->tmbSize;\n\n        if ($this->imgLib === 'imagick') {\n            try {\n                $imagickTest = new imagick($tmb . '[0]');\n                $imagickTest->clear();\n                $imagickTest = true;\n            } catch (Exception $e) {\n                $imagickTest = false;\n            }\n        }\n\n        if (($this->imgLib === 'imagick' && !$imagickTest) || ($s = getimagesize($tmb)) === false) {\n            if ($this->imgLib === 'imagick') {\n                $bgcolor = $this->options['tmbBgColor'];\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                try {\n                    $imagick = new imagick();\n                    $imagick->setBackgroundColor(new ImagickPixel($bgcolor));\n                    $imagick->readImage($this->getExtentionByMime($stat['mime'], ':') . $tmb . '[0]');\n                    try {\n                        $imagick->trimImage(0);\n                    } catch (Exception $e) {\n                    }\n                    $imagick->setImageFormat('png');\n                    $imagick->writeImage($tmb);\n                    $imagick->clear();\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                } catch (Exception $e) {\n                }\n            } else if ($this->imgLib === 'convert') {\n                $convParams = $this->imageMagickConvertPrepare($tmb, 'png', 100, array(), $stat['mime']);\n                $cmd = sprintf('%s -colorspace sRGB -trim -- %s %s', ELFINDER_CONVERT_PATH, $convParams['quotedPath'], $convParams['quotedDstPath']);\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                }\n            }\n            if (!$result) {\n                // fallback imgLib to GD\n                if (function_exists('gd_info') && ($s = getimagesize($tmb))) {\n                    $this->imgLib = 'gd';\n                } else {\n                    file_exists($tmb) && unlink($tmb);\n                    return false;\n                }\n            }\n        }\n\n        /* If image smaller or equal thumbnail size - just fitting to thumbnail square */\n        if ($s[0] <= $tmbSize && $s[1] <= $tmbSize) {\n            $result = $this->imgSquareFit($tmb, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n        } else {\n\n            if ($this->options['tmbCrop']) {\n\n                $result = $tmb;\n                /* Resize and crop if image bigger than thumbnail */\n                if (!(($s[0] > $tmbSize && $s[1] <= $tmbSize) || ($s[0] <= $tmbSize && $s[1] > $tmbSize)) || ($s[0] > $tmbSize && $s[1] > $tmbSize)) {\n                    $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, false, 'png');\n                }\n\n                if ($result && ($s = getimagesize($tmb)) != false) {\n                    $x = $s[0] > $tmbSize ? intval(($s[0] - $tmbSize) / 2) : 0;\n                    $y = $s[1] > $tmbSize ? intval(($s[1] - $tmbSize) / 2) : 0;\n                    $result = $this->imgCrop($result, $tmbSize, $tmbSize, $x, $y, 'png');\n                } else {\n                    $result = false;\n                }\n\n            } else {\n                $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, true, 'png');\n            }\n\n            if ($result) {\n                if ($s = getimagesize($tmb)) {\n                    if ($s[0] !== $tmbSize || $s[1] !== $tmbSize) {\n                        $result = $this->imgSquareFit($result, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n                    }\n                }\n            }\n        }\n\n        if (!$result) {\n            unlink($tmb);\n            return false;\n        }\n\n        return $name;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $path               image file\n     * @param  int    $width              new width\n     * @param  int    $height             new height\n     * @param  bool   $keepProportions    crop image\n     * @param  bool   $resizeByBiggerSide resize image based on bigger side if true\n     * @param  string $destformat         image destination format\n     * @param  int    $jpgQuality         JEPG quality (1-100)\n     * @param  array  $options            Other extra options\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgResize($path, $width, $height, $keepProportions = false, $resizeByBiggerSide = true, $destformat = null, $jpgQuality = null, $options = array())\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        list($orig_w, $orig_h) = array($s[0], $s[1]);\n        list($size_w, $size_h) = array($width, $height);\n\n        if (empty($options['unenlarge']) || $orig_w > $size_w || $orig_h > $size_h) {\n            if ($keepProportions == true) {\n                /* Resizing by biggest side */\n                if ($resizeByBiggerSide) {\n                    if ($orig_w > $orig_h) {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    } else {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    }\n                } else {\n                    if ($orig_w > $orig_h) {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    } else {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    }\n                }\n            }\n        } else {\n            $size_w = $orig_w;\n            $size_h = $orig_h;\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                // Imagick::FILTER_BOX faster than FILTER_LANCZOS so use for createTmb\n                // resize bench: http://app-mgng.rhcloud.com/9\n                // resize sample: http://www.dylanbeattie.net/magick/filters/result.html\n                $filter = ($destformat === 'png' /* createTmb */) ? Imagick::FILTER_BOX : Imagick::FILTER_LANCZOS;\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->resizeImage($size_w, $size_h, $filter, 1);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                        $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                        $img->setImageCompressionQuality($jpgQuality);\n                        if (isset($options['preserveExif']) && !$options['preserveExif']) {\n                            try {\n                                $orientation = $img->getImageOrientation();\n                            } catch (ImagickException $e) {\n                                $orientation = 0;\n                            }\n                            $img->stripImage();\n                            if ($orientation) {\n                                $img->setImageOrientation($orientation);\n                            }\n                        }\n                        if ($this->options['jpgProgressive']) {\n                            $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                        }\n                    }\n                    $img->resizeImage($size_w, $size_h, $filter, true);\n                    if ($destformat) {\n                        $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                    } else {\n                        $result = $img->writeImage($path);\n                    }\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $filter = ($destformat === 'png' /* createTmb */) ? '-filter Box' : '-filter Lanczos';\n                $strip = (isset($options['preserveExif']) && !$options['preserveExif']) ? ' -strip' : '';\n                $cmd = sprintf('%s %s%s%s%s%s %s -geometry %dx%d! %s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $strip, $interlace, $filter, $size_w, $size_h, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($size_w, $size_h)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($size_w, $size_h))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    if (!imagecopyresampled($tmp, $img, 0, 0, 0, 0, $size_w, $size_h, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Crop image\n     *\n     * @param  string $path       image file\n     * @param  int    $width      crop width\n     * @param  int    $height     crop height\n     * @param  bool   $x          crop left offset\n     * @param  bool   $y          crop top offset\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgCrop($path, $width, $height, $x, $y, $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->setImagePage($s[0], $s[1], 0, 0);\n                        $img->cropImage($width, $height, $x, $y);\n                        $img->setImagePage($width, $height, 0, 0);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->setImagePage($s[0], $s[1], 0, 0);\n                    $img->cropImage($width, $height, $x, $y);\n                    $img->setImagePage($width, $height, 0, 0);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $cmd = sprintf('%s %s%s%s%s -crop %dx%d+%d+%d%s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $interlace, $width, $height, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    $size_w = $width;\n                    $size_h = $height;\n\n                    if ($s[0] < $width || $s[1] < $height) {\n                        $size_w = $s[0];\n                        $size_h = $s[1];\n                    }\n\n                    if (!imagecopy($tmp, $img, 0, 0, $x, $y, $size_w, $size_h)) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Put image to square\n     *\n     * @param  string    $path       image file\n     * @param  int       $width      square width\n     * @param  int       $height     square height\n     * @param int|string $align      reserved\n     * @param int|string $valign     reserved\n     * @param  string    $bgcolor    square background color in #rrggbb format\n     * @param  string    $destformat image destination format\n     * @param  int       $jpgQuality JEPG quality (1-100)\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgSquareFit($path, $width, $height, $align = 'center', $valign = 'middle', $bgcolor = '#0000ff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        /* Coordinates for image over square aligning */\n        $y = ceil(abs($height - $s[1]) / 2);\n        $x = ceil(abs($width - $s[0]) / 2);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img1 = new Imagick();\n                    $img1->setFormat('gif');\n                    $img = $img->coalesceImages();\n                    do {\n                        $gif = new Imagick();\n                        $gif->newImage($width, $height, new ImagickPixel($bgcolor));\n                        $gif->setImageColorspace($img->getImageColorspace());\n                        $gif->setImageFormat('gif');\n                        $gif->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                        $gif->setImageDelay($img->getImageDelay());\n                        $gif->setImageIterations($img->getImageIterations());\n                        $img1->addImage($gif);\n                        $gif->clear();\n                    } while ($img->nextImage());\n                    $img1->optimizeImageLayers();\n                    $result = $img1->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img1 = new Imagick();\n                    $img1->newImage($width, $height, new ImagickPixel($bgcolor));\n                    $img1->setImageColorspace($img->getImageColorspace());\n                    $img1->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                    $result = $this->imagickImage($img1, $path, $destformat, $jpgQuality);\n                }\n\n                $img1->clear();\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s -size %dx%d \"xc:%s\" png:- | convert%s%s%s png:-  %s -geometry +%d+%d -compose over -composite%s %s', ELFINDER_CONVERT_PATH, $width, $height, $bgcolor, $coalesce, $jpgQuality, $interlace, $quotedPath, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp, $bgcolor);\n                    if ($bgcolor === 'transparent' && ($destformat === 'png' || $s[2] === IMAGETYPE_PNG)) {\n                        $bgNum = imagecolorallocatealpha($tmp, 255, 255, 255, 127);\n                        imagefill($tmp, 0, 0, $bgNum);\n                    }\n\n                    if (!imagecopy($tmp, $img, $x, $y, 0, 0, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rotate image\n     *\n     * @param  string $path       image file\n     * @param  int    $degree     rotete degrees\n     * @param  string $bgcolor    square background color in #rrggbb format\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    protected function imgRotate($path, $degree, $bgcolor = '#ffffff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false || $degree % 360 === 0) {\n            return false;\n        }\n\n        $result = false;\n\n        // try lossless rotate\n        if ($degree % 90 === 0 && in_array($s[2], array(IMAGETYPE_JPEG, IMAGETYPE_JPEG2000))) {\n            $count = ($degree / 90) % 4;\n            $exiftran = array(\n                1 => '-9',\n                2 => '-1',\n                3 => '-2'\n            );\n            $jpegtran = array(\n                1 => '90',\n                2 => '180',\n                3 => '270'\n            );\n            $quotedPath = escapeshellarg($path);\n            $cmds = array();\n            if ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0) {\n                $cmds[] = ELFINDER_EXIFTRAN_PATH . ' -i ' . $exiftran[$count] . ' -- ' . $quotedPath;\n            }\n            if ($this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0) {\n                $cmds[] = ELFINDER_JPEGTRAN_PATH . ' -rotate ' . $jpegtran[$count] . ' -copy all -outfile ' . $quotedPath . ' -- ' . $quotedPath;\n            }\n            foreach ($cmds as $cmd) {\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                    break;\n                }\n            }\n            if ($result) {\n                return $path;\n            }\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                if ($img->getNumberImages() > 1) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s%s%s%s -background \"%s\" -rotate %d%s -- %s %s', ELFINDER_CONVERT_PATH, $coalesce, $jpgQuality, $interlace, $bgcolor, $degree, $deconstruct, $quotedPath, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, $s));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                $degree = 360 - $degree;\n\n                $bgNum = -1;\n                $bgIdx = false;\n                if ($s[2] === IMAGETYPE_GIF) {\n                    $bgIdx = imagecolortransparent($img);\n                    if ($bgIdx !== -1) {\n                        $c = imagecolorsforindex($img, $bgIdx);\n                        $w = imagesx($img);\n                        $h = imagesy($img);\n                        $newImg = imagecreatetruecolor($w, $h);\n                        imagepalettecopy($newImg, $img);\n                        $bgNum = imagecolorallocate($newImg, $c['red'], $c['green'], $c['blue']);\n                        imagefill($newImg, 0, 0, $bgNum);\n                        imagecolortransparent($newImg, $bgNum);\n                        imagecopy($newImg, $img, 0, 0, 0, 0, $w, $h);\n                        imagedestroy($img);\n                        $img = $newImg;\n                        $newImg = null;\n                    }\n                } else if ($s[2] === IMAGETYPE_PNG) {\n                    $bgNum = imagecolorallocatealpha($img, 255, 255, 255, 127);\n                }\n                if ($bgNum === -1) {\n                    list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n                    $bgNum = imagecolorallocate($img, $r, $g, $b);\n                }\n\n                $tmp = imageRotate($img, $degree, $bgNum);\n                if ($bgIdx !== -1) {\n                    imagecolortransparent($tmp, $bgNum);\n                }\n\n                $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                imageDestroy($img);\n                imageDestroy($tmp);\n\n                return $result ? $path : false;\n\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    protected function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n        return elFinder::procExec($command, $output, $return_var, $error_output);\n    }\n\n    /**\n     * Remove thumbnail, also remove recursively if stat is directory\n     *\n     * @param  array $stat file stat\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     * @author Troex Nevelin\n     */\n    protected function rmTmb($stat)\n    {\n        if ($this->tmbPathWritable) {\n            if ($stat['mime'] === 'directory') {\n                foreach ($this->scandirCE($this->decode($stat['hash'])) as $p) {\n                    elFinder::extendTimeLimit(30);\n                    $name = $this->basenameCE($p);\n                    $name != '.' && $name != '..' && $this->rmTmb($this->stat($p));\n                }\n            } else if (!empty($stat['tmb']) && $stat['tmb'] != \"1\") {\n                $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . rawurldecode($stat['tmb']);\n                file_exists($tmb) && unlink($tmb);\n                clearstatcache();\n            }\n        }\n    }\n\n    /**\n     * Create an gd image according to the specified mime type\n     *\n     * @param string $path image file\n     * @param string $mime\n     *\n     * @return resource|false GD image resource identifier\n     */\n    protected function gdImageCreate($path, $mime)\n    {\n        switch ($mime) {\n            case 'image/jpeg':\n                return imagecreatefromjpeg($path);\n\n            case 'image/png':\n                return imagecreatefrompng($path);\n\n            case 'image/gif':\n                return imagecreatefromgif($path);\n\n            case 'image/x-ms-bmp':\n                if (!function_exists('imagecreatefrombmp')) {\n                    include_once dirname(__FILE__) . '/libs/GdBmp.php';\n                }\n                return imagecreatefrombmp($path);\n\n            case 'image/xbm':\n                return imagecreatefromxbm($path);\n\n            case 'image/xpm':\n                return imagecreatefromxpm($path);\n\n            case 'image/webp':\n                return imagecreatefromwebp($path);\n        }\n        return false;\n    }\n\n    /**\n     * Output gd image to file\n     *\n     * @param resource $image      gd image resource\n     * @param string   $filename   The path to save the file to.\n     * @param string   $destformat The Image type to use for $filename\n     * @param string   $mime       The original image mime type\n     * @param int      $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function gdImage($image, $filename, $destformat, $mime, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n        if ($destformat) {\n            switch ($destformat) {\n                case 'jpg':\n                    $mime = 'image/jpeg';\n                    break;\n                case 'gif':\n                    $mime = 'image/gif';\n                    break;\n                case 'png':\n                default:\n                    $mime = 'image/png';\n                    break;\n            }\n        }\n        switch ($mime) {\n            case 'image/gif':\n                return imagegif($image, $filename);\n            case 'image/jpeg':\n                if ($this->options['jpgProgressive']) {\n                    imageinterlace($image, true);\n                }\n                return imagejpeg($image, $filename, $jpgQuality);\n            case 'image/wbmp':\n                return imagewbmp($image, $filename);\n            case 'image/png':\n            default:\n                return imagepng($image, $filename);\n        }\n    }\n\n    /**\n     * Output imagick image to file\n     *\n     * @param imagick $img        imagick image resource\n     * @param string  $filename   The path to save the file to.\n     * @param string  $destformat The Image type to use for $filename\n     * @param int     $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function imagickImage($img, $filename, $destformat, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        try {\n            if ($destformat) {\n                if ($destformat === 'gif') {\n                    $img->setImageFormat('gif');\n                } else if ($destformat === 'png') {\n                    $img->setImageFormat('png');\n                } else if ($destformat === 'jpg') {\n                    $img->setImageFormat('jpeg');\n                }\n            }\n            if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                $img->setImageCompressionQuality($jpgQuality);\n                if ($this->options['jpgProgressive']) {\n                    $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                }\n                try {\n                    $orientation = $img->getImageOrientation();\n                } catch (ImagickException $e) {\n                    $orientation = 0;\n                }\n                $img->stripImage();\n                if ($orientation) {\n                    $img->setImageOrientation($orientation);\n                }\n            }\n            $result = $img->writeImage($filename);\n        } catch (Exception $e) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Assign the proper background to a gd image\n     *\n     * @param resource $image   gd image resource\n     * @param string   $bgcolor background color in #rrggbb format\n     */\n    protected function gdImageBackground($image, $bgcolor)\n    {\n\n        if ($bgcolor === 'transparent') {\n            imagealphablending($image, false);\n            imagesavealpha($image, true);\n        } else {\n            list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n            $bgcolor1 = imagecolorallocate($image, $r, $g, $b);\n            imagefill($image, 0, 0, $bgcolor1);\n        }\n    }\n\n    /**\n     * Prepare variables for exec convert of ImageMagick\n     *\n     * @param  string $path\n     * @param  string $destformat\n     * @param  int    $jpgQuality\n     * @param  array  $imageSize\n     * @param null    $mime\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function imageMagickConvertPrepare($path, $destformat, $jpgQuality, $imageSize = null, $mime = null)\n    {\n        if (is_null($imageSize)) {\n            $imageSize = getimagesize($path);\n        }\n        if (is_null($mime)) {\n            $mime = $this->mimetype($path);\n        }\n        $srcType = $this->getExtentionByMime($mime, ':');\n        $ani = false;\n        if (preg_match('/^(?:gif|png|ico)/', $srcType)) {\n            $cmd = ELFINDER_IDENTIFY_PATH . ' -- ' . escapeshellarg($srcType . $path);\n            if ($this->procExec($cmd, $o) === 0) {\n                $ani = preg_split('/(?:\\r\\n|\\n|\\r)/', trim($o));\n                if (count($ani) < 2) {\n                    $ani = false;\n                }\n            }\n        }\n        $coalesce = $index = $interlace = '';\n        $deconstruct = ' +repage';\n        if ($ani && $destformat !== 'png'/* not createTmb */) {\n            if (is_null($destformat)) {\n                $coalesce = ' -coalesce -repage 0x0';\n                $deconstruct = ' +repage -deconstruct -layers optimize';\n            } else if ($imageSize) {\n                if ($srcType === 'ico:') {\n                    $index = '[0]';\n                    foreach ($ani as $_i => $_info) {\n                        if (preg_match('/ (\\d+)x(\\d+) /', $_info, $m)) {\n                            if ($m[1] == $imageSize[0] && $m[2] == $imageSize[1]) {\n                                $index = '[' . $_i . ']';\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            $index = '[0]';\n        }\n        if ($imageSize && ($imageSize[2] === IMAGETYPE_JPEG || $imageSize[2] === IMAGETYPE_JPEG2000)) {\n            $jpgQuality = ' -quality ' . $jpgQuality;\n            if ($this->options['jpgProgressive']) {\n                $interlace = ' -interlace Plane';\n            }\n        } else {\n            $jpgQuality = '';\n        }\n        $quotedPath = escapeshellarg($srcType . $path . $index);\n        $quotedDstPath = escapeshellarg(($destformat ? ($destformat . ':') : $srcType) . $path);\n        return compact('ani', 'index', 'coalesce', 'deconstruct', 'jpgQuality', 'quotedPath', 'quotedDstPath', 'interlace');\n    }\n\n    /*********************** misc *************************/\n\n    /**\n     * Find position of first occurrence of string in a string with multibyte support\n     *\n     * @param  string $haystack The string being checked.\n     * @param  string $needle   The string to find in haystack.\n     * @param  int    $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return int|bool\n     * @author Alexey Sukhotin\n     **/\n    protected function stripos($haystack, $needle, $offset = 0)\n    {\n        if (function_exists('mb_stripos')) {\n            return mb_stripos($haystack, $needle, $offset, 'UTF-8');\n        } else if (function_exists('mb_strtolower') && function_exists('mb_strpos')) {\n            return mb_strpos(mb_strtolower($haystack, 'UTF-8'), mb_strtolower($needle, 'UTF-8'), $offset);\n        }\n        return stripos($haystack, $needle, $offset);\n    }\n\n    /**\n     * Default serach match method (name match)\n     *\n     * @param  String $name  Item name\n     * @param  String $query Query word\n     * @param  String $path  Item path\n     *\n     * @return bool @return bool\n     */\n    protected function searchMatchName($name, $query, $path)\n    {\n        return $this->stripos($name, $query) !== false;\n    }\n\n    /**\n     * Get server side available archivers\n     *\n     * @param bool $use_cache\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function getArchivers($use_cache = true)\n    {\n        $sessionKey = 'archivers';\n        if ($use_cache) {\n            if (isset($this->options['archivers']) && is_array($this->options['archivers']) && $this->options['archivers']) {\n                $cache = $this->options['archivers'];\n            } else {\n                $cache = elFinder::$archivers;\n            }\n            if ($cache) {\n                return $cache;\n            } else {\n                if ($cache = $this->session->get($sessionKey, array())) {\n                    return elFinder::$archivers = $cache;\n                }\n            }\n        }\n\n        $arcs = array(\n            'create' => array(),\n            'extract' => array()\n        );\n\n        if ($this->procExec('') === 0) {\n\n            $this->procExec(ELFINDER_TAR_PATH . ' --version', $o, $ctar);\n\n            if ($ctar == 0) {\n                $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-chf', 'ext' => 'tar');\n                $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xf', 'ext' => 'tar', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                unset($o);\n                $this->procExec(ELFINDER_GZIP_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-czhf', 'ext' => 'tgz');\n                    $arcs['extract']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xzf', 'ext' => 'tgz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_BZIP2_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cjhf', 'ext' => 'tbz');\n                    $arcs['extract']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xjf', 'ext' => 'tbz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_XZ_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cJhf', 'ext' => 'xz');\n                    $arcs['extract']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xJf', 'ext' => 'xz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n            }\n            unset($o);\n            $this->procExec(ELFINDER_ZIP_PATH . ' -h', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/zip'] = array('cmd' => ELFINDER_ZIP_PATH, 'argc' => '-r9 -q', 'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNZIP_PATH . ' --help', $o, $c);\n            if ($c == 0) {\n                $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_UNZIP_PATH, 'argc' => '-q', 'ext' => 'zip', 'toSpec' => '-d ', 'getsize' => array('argc' => '-Z -t', 'regex' => '/^.+?,\\s?([0-9]+).+$/', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_RAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['create']['application/x-rar'] = array('cmd' => ELFINDER_RAR_PATH, 'argc' => 'a -inul' . (defined('ELFINDER_RAR_MA4') && ELFINDER_RAR_MA4? ' -ma4' : ''), 'ext' => 'rar');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNRAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_UNRAR_PATH, 'argc' => 'x -y', 'ext' => 'rar', 'toSpec' => '', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)(?:(?:[^\\r\\n0-9]+[0-9]+[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+)|(?:[^\\r\\n0-9]+([0-9]+)[^\\r\\n0-9]+[0-9]+[^\\r\\n]*))$/s', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_7Z_PATH, $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a', 'ext' => '7z');\n                $arcs['extract']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -y', 'ext' => '7z', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n\n                if (empty($arcs['create']['application/zip'])) {\n                    $arcs['create']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -tzip', 'ext' => 'zip');\n                }\n                if (empty($arcs['extract']['application/zip'])) {\n                    $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -tzip -y', 'ext' => 'zip', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (empty($arcs['create']['application/x-tar'])) {\n                    $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -ttar', 'ext' => 'tar');\n                }\n                if (empty($arcs['extract']['application/x-tar'])) {\n                    $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -ttar -y', 'ext' => 'tar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (substr(PHP_OS, 0, 3) === 'WIN' && empty($arcs['extract']['application/x-rar'])) {\n                    $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -trar -y', 'ext' => 'rar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n            }\n\n        }\n\n        // Use PHP ZipArchive Class\n        if (class_exists('ZipArchive', false)) {\n            if (empty($arcs['create']['application/zip'])) {\n                $arcs['create']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveZip'), 'ext' => 'zip');\n            }\n            if (empty($arcs['extract']['application/zip'])) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveUnzip'), 'ext' => 'zip');\n            }\n        }\n\n        $this->session->set($sessionKey, $arcs);\n        return elFinder::$archivers = $arcs;\n    }\n\n    /**\n     * Resolve relative / (Unix-like)absolute path\n     *\n     * @param string $path target path\n     * @param string $base base path\n     *\n     * @return string\n     */\n    protected function getFullPath($path, $base)\n    {\n        $separator = $this->separator;\n        $systemroot = $this->systemRoot;\n        $base = (string)$base;\n\n        if ($base[0] === $separator && substr($base, 0, strlen($systemroot)) !== $systemroot) {\n            $base = $systemroot . substr($base, 1);\n        }\n        if ($base !== $systemroot) {\n            $base = rtrim($base, $separator);\n        }\n\n        // 'Here'\n        if ($path === '' || $path === '.' . $separator) return $base;\n\n        $sepquoted = preg_quote($separator, '#');\n\n        if (substr($path, 0, 3) === '..' . $separator) {\n            $path = $base . $separator . $path;\n        }\n        // normalize `/../`\n        $normreg = '#(' . $sepquoted . ')[^' . $sepquoted . ']+' . $sepquoted . '\\.\\.' . $sepquoted . '#'; // '#(/)[^\\/]+/\\.\\./#'\n        while (preg_match($normreg, $path)) {\n            $path = preg_replace($normreg, '$1', $path, 1);\n        }\n        if ($path !== $systemroot) {\n            $path = rtrim($path, $separator);\n        }\n\n        // Absolute path\n        if ($path[0] === $separator || strpos($path, $systemroot) === 0) {\n            return $path;\n        }\n\n        $preg_separator = '#' . $sepquoted . '#';\n\n        // Relative path from 'Here'\n        if (substr($path, 0, 2) === '.' . $separator || $path[0] !== '.') {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            if ($arrn[0] !== '.') {\n                array_unshift($arrn, '.');\n            }\n            $arrn[0] = rtrim($base, $separator);\n            return join($separator, $arrn);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function rmdirRecursive($dir)\n    {\n        return self::localRmdirRecursive($dir);\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function makeArchive($dir, $files, $name, $arc)\n    {\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            }\n        } else {\n            $cwd = getcwd();\n            if (chdir($dir)) {\n                foreach ($files as $i => $file) {\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                }\n                $files = array_map('escapeshellarg', $files);\n\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($name) . ' ' . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            } else {\n                return false;\n            }\n        }\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    }\n\n    /**\n     * Unpack archive\n     *\n     * @param  string      $path archive path\n     * @param  array       $arc  archiver command and arguments (same as in $this->archivers)\n     * @param  bool|string $mode bool: remove archive ( unlink($path) ) | string: extract to directory\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function unpackArchive($path, $arc, $mode = true)\n    {\n        if (is_string($mode)) {\n            $dir = $mode;\n            $chdir = null;\n            $remove = false;\n        } else {\n            $dir = dirname($path);\n            $chdir = $dir;\n            $remove = $mode;\n        }\n        $dir = realpath($dir);\n        $path = realpath($path);\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($path, $dir));\n            }\n        } else {\n            $cwd = getcwd();\n            if (!$chdir || chdir($dir)) {\n                if (!empty($arc['getsize'])) {\n                    // Check total file size after extraction\n                    $getsize = $arc['getsize'];\n                    if (is_array($getsize) && !empty($getsize['regex']) && !empty($getsize['replace'])) {\n                        $cmd = $arc['cmd'] . ' ' . $getsize['argc'] . ' ' . escapeshellarg($path) . (!empty($getsize['toSpec'])? (' ' . $getsize['toSpec']): '');\n                        $this->procExec($cmd, $o, $c);\n                        if ($o) {\n                            $size = preg_replace($getsize['regex'], $getsize['replace'], trim($o));\n                            $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                            if (!empty($this->options['maxArcFilesSize'])) {\n                                if ($comp($size, (string)$this->options['maxArcFilesSize']) > 0) {\n                                    throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                                }\n                            }\n                        }\n                        unset($o, $c);\n                    }\n                }\n                if ($chdir) {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg(basename($path));\n                } else {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($path) . ' ' . $arc['toSpec'] . escapeshellarg($dir);\n                }\n                $this->procExec($cmd, $o, $c);\n                $chdir && chdir($cwd);\n            }\n        }\n        $remove && unlink($path);\n    }\n\n    /**\n     * Check and filter the extracted items\n     *\n     * @param  string $path   target local path\n     * @param  array  $checks types to check default: ['symlink', 'name', 'writable', 'mime']\n     *\n     * @return array  ['symlinks' => [], 'names' => [], 'writables' => [], 'mimes' => [], 'rmNames' => [], 'totalSize' => 0]\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function checkExtractItems($path, $checks = null)\n    {\n        if (is_null($checks) || !is_array($checks)) {\n            $checks = array('symlink', 'name', 'writable', 'mime');\n        }\n        $chkSymlink = in_array('symlink', $checks);\n        $chkName = in_array('name', $checks);\n        $chkWritable = in_array('writable', $checks);\n        $chkMime = in_array('mime', $checks);\n\n        $res = array(\n            'symlinks' => array(),\n            'names' => array(),\n            'writables' => array(),\n            'mimes' => array(),\n            'rmNames' => array(),\n            'totalSize' => 0\n        );\n\n        if (is_dir($path)) {\n            $files = self::localScandir($path);\n        } else {\n            $files = array(basename($path));\n            $path = dirname($path);\n        }\n\n        foreach ($files as $name) {\n            $p = $path . DIRECTORY_SEPARATOR . $name;\n            $utf8Name = elFinder::$instance->utf8Encode($name);\n            if ($name !== $utf8Name) {\n                $fsSame = false;\n                if ($this->encoding) {\n                    // test as fs encoding\n                    $_utf8 = @iconv($this->encoding, 'utf-8//IGNORE', $name);\n                    if (@iconv('utf-8', $this->encoding.'//IGNORE', $_utf8) === $name) {\n                        $fsSame = true;\n                        $utf8Name = $_utf8;\n                    } else {\n                        $_name = $this->convEncIn($utf8Name, true);\n                    }\n                } else {\n                    $_name = $utf8Name;\n                }\n                if (!$fsSame && rename($p, $path . DIRECTORY_SEPARATOR . $_name)) {\n                    $name = $_name;\n                    $p = $path . DIRECTORY_SEPARATOR . $name;\n                }\n            }\n            if (!is_readable($p)) {\n                // Perhaps a symbolic link to open_basedir restricted location\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkSymlink && is_link($p)) {\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            $isDir = is_dir($p);\n            if ($chkName && !$this->nameAccepted($name, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['names'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkWritable && !$this->attr($p, 'write', null, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['writables'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($isDir) {\n                $cRes = $this->checkExtractItems($p, $checks);\n                foreach ($cRes as $k => $v) {\n                    if (is_array($v)) {\n                        $res[$k] = array_merge($res[$k], $cRes[$k]);\n                    } else {\n                        $res[$k] += $cRes[$k];\n                    }\n                }\n            } else {\n                if ($chkMime && ($mimeByName = elFinderVolumeDriver::mimetypeInternalDetect($name)) && !$this->allowPutMime($mimeByName)) {\n                    self::localRmdirRecursive($p);\n                    $res['mimes'][] = $p;\n                    $res['rmNames'][] = $utf8Name;\n                    continue;\n                }\n                $res['totalSize'] += (int)sprintf('%u', filesize($p));\n            }\n        }\n        $res['rmNames'] = array_unique($res['rmNames']);\n\n        return $res;\n    }\n\n    /**\n     * Return files of target directory that is dotfiles excludes.\n     *\n     * @param  string $dir target directory path\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localScandir($dir)\n    {\n        // PHP function scandir() is not work well in specific environment. I dont know why.\n        // ref. https://github.com/Studio-42/elFinder/issues/1248\n        $files = array();\n        if ($dh = opendir($dir)) {\n            while (false !== ($file = readdir($dh))) {\n                if ($file !== '.' && $file !== '..') {\n                    $files[] = $file;\n                }\n            }\n            closedir($dh);\n        } else {\n            throw new Exception('Can not open local directory.');\n        }\n        return $files;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected static function localRmdirRecursive($dir)\n    {\n        // try system command\n        if (is_callable('exec')) {\n            $o = '';\n            $r = 1;\n            if (substr(PHP_OS, 0, 3) === 'WIN') {\n                if (!is_link($dir) && is_dir($dir)) {\n                    exec('rd /S /Q ' . escapeshellarg($dir), $o, $r);\n                } else {\n                    exec('del /F /Q ' . escapeshellarg($dir), $o, $r);\n                }\n            } else {\n                exec('rm -rf ' . escapeshellarg($dir), $o, $r);\n            }\n            if ($r === 0) {\n                return true;\n            }\n        }\n        if (!is_link($dir) && is_dir($dir)) {\n            chmod($dir, 0777);\n            if ($handle = opendir($dir)) {\n                while (false !== ($file = readdir($handle))) {\n                    if ($file === '.' || $file === '..') {\n                        continue;\n                    }\n                    elFinder::extendTimeLimit(30);\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (!is_link($dir) && is_dir($path)) {\n                        self::localRmdirRecursive($path);\n                    } else {\n                        chmod($path, 0666);\n                        unlink($path);\n                    }\n                }\n                closedir($handle);\n            }\n            return rmdir($dir);\n        } else {\n            chmod($dir, 0666);\n            return unlink($dir);\n        }\n    }\n\n    /**\n     * Move item recursive on local file system\n     *\n     * @param string $src\n     * @param string $target\n     * @param bool   $overWrite\n     * @param bool   $copyJoin\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localMoveRecursive($src, $target, $overWrite = true, $copyJoin = true)\n    {\n        $res = false;\n        if (!file_exists($target)) {\n            return rename($src, $target);\n        }\n        if (!$copyJoin || !is_dir($target)) {\n            if ($overWrite) {\n                if (is_dir($target)) {\n                    $del = self::localRmdirRecursive($target);\n                } else {\n                    $del = unlink($target);\n                }\n                if ($del) {\n                    return rename($src, $target);\n                }\n            }\n        } else {\n            foreach (self::localScandir($src) as $item) {\n                $res |= self::localMoveRecursive($src . DIRECTORY_SEPARATOR . $item, $target . DIRECTORY_SEPARATOR . $item, $overWrite, $copyJoin);\n            }\n        }\n        return (bool)$res;\n    }\n\n    /**\n     * Create Zip archive using PHP class ZipArchive\n     *\n     * @param  string        $dir     target dir\n     * @param  array         $files   files names list\n     * @param  string|object $zipPath Zip archive name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveZip($dir, $files, $zipPath)\n    {\n        try {\n            if ($start = is_string($zipPath)) {\n                $zip = new ZipArchive();\n                if ($zip->open($dir . DIRECTORY_SEPARATOR . $zipPath, ZipArchive::CREATE) !== true) {\n                    $zip = false;\n                }\n            } else {\n                $zip = $zipPath;\n            }\n            if ($zip) {\n                foreach ($files as $file) {\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (is_dir($path)) {\n                        $zip->addEmptyDir($file);\n                        $_files = array();\n                        if ($handle = opendir($path)) {\n                            while (false !== ($entry = readdir($handle))) {\n                                if ($entry !== \".\" && $entry !== \"..\") {\n                                    $_files[] = $file . DIRECTORY_SEPARATOR . $entry;\n                                }\n                            }\n                            closedir($handle);\n                        }\n                        if ($_files) {\n                            self::zipArchiveZip($dir, $_files, $zip);\n                        }\n                    } else {\n                        $zip->addFile($path, $file);\n                    }\n                }\n                $start && $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Unpack Zip archive using PHP class ZipArchive\n     *\n     * @param  string $zipPath Zip archive name\n     * @param  string $toDir   Extract to path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveUnzip($zipPath, $toDir)\n    {\n        try {\n            $zip = new ZipArchive();\n            if ($zip->open($zipPath) === true) {\n                // Check total file size after extraction\n                $num = $zip->numFiles;\n                $size = 0;\n                $maxSize = empty(self::$maxArcFilesSize)? '' : (string)self::$maxArcFilesSize;\n                $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                for ($i = 0; $i < $num; $i++) {\n                    $stat = $zip->statIndex($i);\n                    $size += $stat['size'];\n                    if (strpos((string)$size, 'E') !== false) {\n                        // Cannot handle values exceeding PHP_INT_MAX\n                        throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                    }\n                    if (!$maxSize) {\n                        if ($comp($size, $maxSize) > 0) {\n                            throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                        }\n                    }\n                }\n                // do extract\n                $zip->extractTo($toDir);\n                $zip->close();\n            }\n        } catch (Exception $e) {\n            throw $e;\n        }\n        return true;\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected static function localFindSymlinks($path)\n    {\n        if (is_link($path)) {\n            return true;\n        }\n\n        if (is_dir($path)) {\n            foreach (self::localScandir($path) as $name) {\n                $p = $path . DIRECTORY_SEPARATOR . $name;\n                if (is_link($p)) {\n                    return true;\n                }\n                if (is_dir($p) && self::localFindSymlinks($p)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**==================================* abstract methods *====================================**/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dirname($path);\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _basename($path);\n\n    /**\n     * Join dir name and file name and return full path.\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _joinPath($dir, $name);\n\n    /**\n     * Return normalized path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _normpath($path);\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _relpath($path);\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _abspath($path);\n\n    /**\n     * Return fake path started from root dir.\n     * Required to show path on client side.\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _path($path);\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _inpath($path, $parent);\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _stat($path);\n\n\n    /***************** file stat ********************/\n\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _subdirs($path);\n\n    /**\n     * Return object width and height\n     * Ususaly used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dimensions($path, $mime);\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Return files list in directory\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _scandir($path);\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param  string $mode open mode\n     *\n     * @return resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fopen($path, $mode = \"rb\");\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fclose($fp, $path = '');\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkdir($path, $name);\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkfile($path, $name);\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _symlink($source, $targetDir, $name);\n\n    /**\n     * Copy file into another file (only inside one volume)\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _copy($source, $targetDir, $name);\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _move($source, $targetDir, $name);\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _unlink($path);\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _rmdir($path);\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _save($fp, $dir, $name, $stat);\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _getContents($path);\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _filePutContents($path, $content);\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path file path\n     * @param  array  $arc  archiver options\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _extract($path, $arc);\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _archive($dir, $files, $name, $arc);\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _checkArchivers();\n\n    /**\n     * Change file mode (chmod)\n     *\n     * @param  string $path file path\n     * @param  string $mode octal string such as '0755'\n     *\n     * @return bool\n     * @author David Bartle,\n     **/\n    abstract protected function _chmod($path, $mode);\n\n\n} // END class\n", "<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['quarantine'] = '.quarantine'; // quarantine folder name - required to check archive (must be hidden)\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['quarantine'] = $this->options['quarantine'];\n                $this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        }\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        return rtrim($dir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $name;\n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n\n", "<?php\n\n/**\n * Simple elFinder driver for SFTP using phpseclib 1\n *\n * @author Dmitry (dio) Levashov\n * @author Cem (discofever), sitecode\n * @reference http://phpseclib.sourceforge.net/sftp/2.0/examples.html\n **/\nclass elFinderVolumeSFTPphpseclib extends elFinderVolumeFTP {\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     * @author Cem (DiscoFever)\n     */\n    public function __construct()\n    {\n        $opts = array(\n            'host' => 'localhost',\n            'user' => '',\n            'pass' => '',\n            'port' => 22,\n            'path' => '/',\n            'timeout' => 20,\n            'owner' => true,\n            'tmbPath' => '',\n            'tmpPath' => '',\n            'separator' => '/',\n            'phpseclibDir' => '../phpseclib/',\n            'connectCallback' => null, //provide your own already instantiated phpseclib $Sftp object returned by this callback\n                                       //'connectCallback'=> function($options) {\n                                       //     //load and instantiate phpseclib $sftp\n                                       //     return $sftp;\n                                       // },\n            'checkSubfolders' => -1,\n            'dirMode' => 0755,\n            'fileMode' => 0644,\n            'rootCssClass' => 'elfinder-navbar-root-ftp',\n        );\n        $this->options = array_merge($this->options, $opts);\n        $this->options['mimeDetect'] = 'internal';\n    }\n\n    /**\n     * Prepare\n     * Call from elFinder::netmout() before volume->mount()\n     *\n     * @param $options\n     *\n     * @return array volume root options\n     * @author Naoki Sawada\n     */\n    public function netmountPrepare($options)\n    {\n        $options['statOwner'] = true;\n        $options['allowChmodReadOnly'] = true;\n        $options['acceptedName'] = '#^[^/\\\\?*:|\"<>]*[^./\\\\?*:|\"<>]$#';\n        return $options;\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare SFTP connection\n     * Connect to remote server and check if credentials are correct, if so, store the connection\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     * @author Cem (DiscoFever)\n     **/\n    protected function init()\n    {\n        if (!$this->options['connectCallback']) {\n            if (!$this->options['host']\n                || !$this->options['port']) {\n                return $this->setError('Required options undefined.');\n            }\n\n            if (!$this->options['path']) {\n                $this->options['path'] = '/';\n            }\n\n            // make net mount key\n            $this->netMountKey = md5(join('-', array('sftpphpseclib', $this->options['host'], $this->options['port'], $this->options['path'], $this->options['user'])));\n\n            set_include_path(get_include_path() . PATH_SEPARATOR . getcwd().'/'.$this->options['phpseclibDir']);\n            include_once('Net/SFTP.php');\n\n            if (!class_exists('Net_SFTP')) {\n                return $this->setError('SFTP extension not loaded. Install phpseclib version 1: http://phpseclib.sourceforge.net/ Set option \"phpseclibDir\" accordingly.');\n            }\n\n            // remove protocol from host\n            $scheme = parse_url($this->options['host'], PHP_URL_SCHEME);\n\n            if ($scheme) {\n                $this->options['host'] = substr($this->options['host'], strlen($scheme) + 3);\n            }\n        } else {\n            // make net mount key\n            $this->netMountKey = md5(join('-', array('sftpphpseclib', $this->options['path'])));\n        }\n\n        // normalize root path\n        $this->root = $this->options['path'] = $this->_normpath($this->options['path']);\n\n        if (empty($this->options['alias'])) {\n            $this->options['alias'] = $this->options['user'] . '@' . $this->options['host'];\n            if (!empty($this->options['netkey'])) {\n                elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $this->options['alias']);\n            }\n        }\n\n        $this->rootName = $this->options['alias'];\n        $this->options['separator'] = '/';\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n\n        return $this->needOnline? $this->connect() : true;\n\n    }\n\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        parent::configure();\n\n        if (!$this->tmp) {\n            $this->disabled[] = 'mkfile';\n            $this->disabled[] = 'paste';\n            $this->disabled[] = 'upload';\n            $this->disabled[] = 'edit';\n            //$this->disabled[] = 'archive';\n            //$this->disabled[] = 'extract';\n        }\n\n        $this->disabled[] = 'archive';\n        $this->disabled[] = 'extract';\n    }\n\n    /**\n     * Connect to sftp server\n     *\n     * @return bool\n     * @author sitecode\n     **/\n    protected function connect()\n    {\n        //use ca\n        if ($this->options['connectCallback']) {\n            $this->connect = $this->options['connectCallback']($this->options);\n            if (!$this->connect || !$this->connect->isConnected()) {\n                return $this->setError('Unable to connect successfully');\n            }\n\n            return true;\n        }\n\n        try{\n            $host = $this->options['host'] . ($this->options['port'] != 22 ? ':' . $this->options['port'] : '');\n            $this->connect = new Net_SFTP($host);\n            //TODO check fingerprint before login, fail if no match to last time\n            if (!$this->connect->login($this->options['user'], $this->options['pass'])) {\n                return $this->setError('Unable to connect to SFTP server ' . $host);\n            }\n        } catch (Exception $e) {\n            return $this->setError('Error while connecting to SFTP server '  . $host . ': ' . $e->getMessage());\n        }\n\n        if (!$this->connect->chdir($this->root)\n            /*|| $this->root != $this->connect->pwd()*/) {\n            //$this->umount();\n            return $this->setError('Unable to open root folder.');\n        }\n\n        return true;\n    }\n\n    /**\n     * Call rawlist\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    protected function ftpRawList($path)\n    {\n        return $this->connect->rawlist($path ?: '.') ?: [];\n/*\n        $raw = $this->connect->rawlist($path ?: '.') ?: [];\n        $raw = array_map(function($key, $value) {\n            $value['name'] = $key;\n            return $value;\n        }, array_keys($raw), $raw);\n        return $raw;\n*/\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /**\n     * Close opened connection\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n        $this->connect && $this->connect->disconnect();\n    }\n\n\n    /**\n     * Parse line from rawlist() output and return file stat (array)\n     *\n     * @param  string $raw line from rawlist() output\n     * @param         $base\n     * @param bool    $nameOnly\n     *\n     * @return array\n     * @author Dmitry Levashov\n     */\n    protected function parseRaw($raw, $base, $nameOnly = false)\n    {\n        $info = $raw;\n        $stat = array();\n\n        if ($info['filename'] == '.' || $info['filename'] == '..') {\n            return false;\n        }\n\n        $name = $info['filename'];\n\n        if (preg_match('|(.+)\\-\\>(.+)|', $name, $m)) {\n            $name = trim($m[1]);\n            // check recursive processing\n            if ($this->cacheDirTarget && $this->_joinPath($base, $name) !== $this->cacheDirTarget) {\n                return array();\n            }\n            if (!$nameOnly) {\n                $target = trim($m[2]);\n                if (substr($target, 0, 1) !== $this->separator) {\n                    $target = $this->getFullPath($target, $base);\n                }\n                $target = $this->_normpath($target);\n                $stat['name'] = $name;\n                $stat['target'] = $target;\n                return $stat;\n            }\n        }\n\n        if ($nameOnly) {\n            return array('name' => $name);\n        }\n\n        $stat['ts'] = $info['mtime'];\n\n        if ($this->options['statOwner']) {\n            $stat['owner'] = $info['uid'];\n            $stat['group'] = $info['gid'];\n            $stat['perm'] = $info['permissions'];\n            $stat['isowner'] = isset($stat['owner']) ? ($this->options['owner'] ? true : ($stat['owner'] == $this->options['user'])) : true;\n        }\n\n        $owner_computed = isset($stat['isowner']) ? $stat['isowner'] : $this->options['owner'];\n        $perm = $this->parsePermissions($info['permissions'], $owner_computed);\n        $stat['name'] = $name;\n        $stat['mime'] = $info['type'] == NET_SFTP_TYPE_DIRECTORY ? 'directory' : $this->mimetype($stat['name'], true);\n        $stat['size'] = $stat['mime'] == 'directory' ? 0 : $info['size'];\n        $stat['read'] = $perm['read'];\n        $stat['write'] = $perm['write'];\n\n        return $stat;\n    }\n\n    /**\n     * Parse permissions string. Return array(read => true/false, write => true/false)\n     *\n     * @param  int $perm\n     *                                             The isowner parameter is computed by the caller.\n     *                                             If the owner parameter in the options is true, the user is the actual owner of all objects even if the user used in the ftp Login\n     *                                             is different from the file owner id.\n     *                                             If the owner parameter is false to understand if the user is the file owner we compare the ftp user with the file owner id.\n     * @param Boolean $isowner                     . Tell if the current user is the owner of the object.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     * @author sitecode\n     */\n    protected function parsePermissions($permissions, $isowner = true)\n    {\n        $permissions = decoct($permissions);\n        $perm = $isowner ? decbin($permissions[-3]) : decbin($permissions[-1]);\n\n        return array(\n            'read' => $perm[-3],\n            'write' => $perm[-2]\n        );\n    }\n\n    /**\n     * Cache dir contents\n     *\n     * @param  string $path dir path\n     *\n     * @return void\n     * @author Dmitry Levashov, sitecode\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        $list = array();\n        $encPath = $this->convEncIn($path);\n        foreach ($this->ftpRawList($encPath) as $raw) {\n            if (($stat = $this->parseRaw($raw, $encPath))) {\n                $list[] = $stat;\n            }\n        }\n        $list = $this->convEncOut($list);\n        $prefix = ($path === $this->separator) ? $this->separator : $path . $this->separator;\n        $targets = array();\n        foreach ($list as $stat) {\n            $p = $prefix . $stat['name'];\n            if (isset($stat['target'])) {\n                // stat later\n                $targets[$stat['name']] = $stat['target'];\n            } else {\n                $stat = $this->updateCache($p, $stat);\n                if (empty($stat['hidden'])) {\n                    if (!$hasDir && $stat['mime'] === 'directory') {\n                        $hasDir = true;\n                    }\n                    $this->dirsCache[$path][] = $p;\n                }\n            }\n        }\n        // stat link targets\n        foreach ($targets as $name => $target) {\n            $stat = array();\n            $stat['name'] = $name;\n            $p = $prefix . $name;\n            $cacheDirTarget = $this->cacheDirTarget;\n            $this->cacheDirTarget = $this->convEncIn($target, true);\n            if ($tstat = $this->stat($target)) {\n                $stat['size'] = $tstat['size'];\n                $stat['alias'] = $target;\n                $stat['thash'] = $tstat['hash'];\n                $stat['mime'] = $tstat['mime'];\n                $stat['read'] = $tstat['read'];\n                $stat['write'] = $tstat['write'];\n\n                if (isset($tstat['ts'])) {\n                    $stat['ts'] = $tstat['ts'];\n                }\n                if (isset($tstat['owner'])) {\n                    $stat['owner'] = $tstat['owner'];\n                }\n                if (isset($tstat['group'])) {\n                    $stat['group'] = $tstat['group'];\n                }\n                if (isset($tstat['perm'])) {\n                    $stat['perm'] = $tstat['perm'];\n                }\n                if (isset($tstat['isowner'])) {\n                    $stat['isowner'] = $tstat['isowner'];\n                }\n            } else {\n\n                $stat['mime'] = 'symlink-broken';\n                $stat['read'] = false;\n                $stat['write'] = false;\n                $stat['size'] = 0;\n\n            }\n            $this->cacheDirTarget = $cacheDirTarget;\n            $stat = $this->updateCache($p, $stat);\n            if (empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        if (isset($this->sessionCache['subdirs'])) {\n            $this->sessionCache['subdirs'][$path] = $hasDir;\n        }\n    }\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $outPath = $this->convEncOut($path);\n        if (isset($this->cache[$outPath])) {\n            return $this->convEncIn($this->cache[$outPath]);\n        } else {\n            $this->convEncIn();\n        }\n        if ($path === $this->root) {\n            $res = array(\n                'name' => $this->root,\n                'mime' => 'directory',\n                'dirs' => -1\n            );\n            if ($this->needOnline && (($this->ARGS['cmd'] === 'open' && $this->ARGS['target'] === $this->encode($this->root)) || $this->isMyReload())) {\n                $check = array(\n                    'ts' => true,\n                    'dirs' => true,\n                );\n                $ts = 0;\n                foreach ($this->ftpRawList($path) as $str) {\n                    $info = preg_split('/\\s+/', $str, 9);\n                    if ($info[8] === '.') {\n                        $info[8] = 'root';\n                        if ($stat = $this->parseRaw(join(' ', $info), $path)) {\n                            unset($stat['name']);\n                            $res = array_merge($res, $stat);\n                            if ($res['ts']) {\n                                $ts = 0;\n                                unset($check['ts']);\n                            }\n                        }\n                    }\n                    if ($check && ($stat = $this->parseRaw($str, $path))) {\n                        if (isset($stat['ts']) && !empty($stat['ts'])) {\n                            $ts = max($ts, $stat['ts']);\n                        }\n                        if (isset($stat['dirs']) && $stat['mime'] === 'directory') {\n                            $res['dirs'] = 1;\n                            unset($stat['dirs']);\n                        }\n                        if (!$check) {\n                            break;\n                        }\n                    }\n                }\n                if ($ts) {\n                    $res['ts'] = $ts;\n                }\n                $this->cache[$outPath] = $res;\n            }\n            return $res;\n        }\n\n        $pPath = $this->_dirname($path);\n        if ($this->_inPath($pPath, $this->root)) {\n            $outPPpath = $this->convEncOut($pPath);\n            if (!isset($this->dirsCache[$outPPpath])) {\n                $parentSubdirs = null;\n                if (isset($this->sessionCache['subdirs']) && isset($this->sessionCache['subdirs'][$outPPpath])) {\n                    $parentSubdirs = $this->sessionCache['subdirs'][$outPPpath];\n                }\n                $this->cacheDir($outPPpath);\n                if ($parentSubdirs) {\n                    $this->sessionCache['subdirs'][$outPPpath] = $parentSubdirs;\n                }\n            }\n        }\n\n        $stat = $this->convEncIn(isset($this->cache[$outPath]) ? $this->cache[$outPath] : array());\n        if (!$this->mounted) {\n            // dispose incomplete cache made by calling `stat` by 'startPath' option\n            $this->cache = array();\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov, sitecode\n     **/\n    protected function _subdirs($path)\n    {\n        foreach ($this->ftpRawList($path) as $info) {\n            $name = $info['filename'];\n            if ($name && $name !== '.' && $name !== '..' && $info['type'] == NET_SFTP_TYPE_DIRECTORY) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @throws elFinderAbortException\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        if ($this->tmp) {\n            $local = $this->getTempFile($path);\n            $this->connect->get($path, $local);\n            return @fopen($local, $mode);\n        }\n\n        return false;\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        is_resource($fp) && fclose($fp);\n        if ($path) {\n            unlink($this->getTempFile($path));\n        }\n    }\n\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n        if ($this->connect->mkdir($path) === false) {\n            return false;\n        }\n\n        $this->options['dirMode'] && $this->connect->chmod($this->options['dirMode'], $path);\n        return $path;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author sitecode\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n        return $this->connect->put($path, '') ? $path : false;\n/*\n        if ($this->tmp) {\n            $path = $this->_joinPath($path, $name);\n            $local = $this->getTempFile();\n            $res = touch($local) && $this->connect->put($path, $local, NET_SFTP_LOCAL_FILE);\n            unlink($local);\n            return $res ? $path : false;\n        }\n\n        return false;\n */\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov, sitecode\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $res = false;\n\n        $target = $this->_joinPath($targetDir, $name);\n        if ($this->tmp) {\n            $local = $this->getTempFile();\n\n            if ($this->connect->get($source, $local)\n                && $this->connect->put($target, $local, NET_SFTP_LOCAL_FILE)) {\n                $res = true;\n            }\n            unlink($local);\n        } else {\n            //not memory efficient\n            $res = $this->_filePutContents($target, $this->_getContents($source));\n        }\n\n        return $res;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $target = $this->_joinPath($targetDir, $name);\n        return $this->connect->rename($source, $target) ? $target : false;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return $this->connect->delete($path, false);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return $this->connect->delete($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        //TODO optionally encrypt $fp before uploading if mime is not already encrypted type\n        $path = $this->_joinPath($dir, $name);\n        return $this->connect->put($path, $fp)\n            ? $path\n            : false;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _getContents($path)\n    {\n        return $this->connect->get($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return $this->connect->put($path, $content);\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return $this->connect->chmod($modeOct, $path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return true\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n        return false; //TODO\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return false; //TODO\n    }\n\n    /**\n     * Gets an array of absolute remote SFTP paths of files and\n     * folders in $remote_directory omitting symbolic links.\n     *\n     * @param $remote_directory string remote SFTP path to scan for file and folders recursively\n     * @param $targets          array  Array of target item. `null` is to get all of items\n     *\n     * @return array of elements each of which is an array of two elements:\n     * <ul>\n     * <li>$item['path'] - absolute remote SFTP path</li>\n     * <li>$item['type'] - either 'f' for file or 'd' for directory</li>\n     * </ul>\n     */\n    protected function ftp_scan_dir($remote_directory, $targets = null)\n    {\n        $buff = $this->ftpRawList($remote_directory);\n        $items = array();\n        if ($targets && is_array($targets)) {\n            $targets = array_flip($targets);\n        } else {\n            $targets = false;\n        }\n        foreach ($buff as $info) {\n            $name = $info['filename'];\n            if ($name !== '.' && $name !== '..' && (!$targets || isset($targets[$name]))) {\n                switch ($info['type']) {\n                    case NET_SFTP_TYPE_SYMLINK : //omit symbolic links\n                    case NET_SFTP_TYPE_DIRECTORY :\n                        $remote_file_path = $this->_joinPath($remote_directory, $name);\n                        $item = array();\n                        $item['path'] = $remote_file_path;\n                        $item['type'] = 'd'; // normal file\n                        $items[] = $item;\n                        $items = array_merge($items, $this->ftp_scan_dir($remote_file_path));\n                        break;\n                    default:\n                        $remote_file_path = $this->_joinPath($remote_directory, $name);\n                        $item = array();\n                        $item['path'] = $remote_file_path;\n                        $item['type'] = 'f'; // normal file\n                        $items[] = $item;\n                }\n            }\n        }\n        return $items;\n    }\n\n} // END class\n"], "fixing_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author  Dmitry (dio) Levashov\n * @author  Troex Nevelin\n * @author  Alexey Sukhotin\n **/\nclass elFinder\n{\n\n    /**\n     * API version number\n     *\n     * @var float\n     **/\n    protected static $ApiVersion = 2.1;\n\n    /**\n     * API version number\n     *\n     * @deprecated\n     * @var string\n     **/\n    protected $version;\n\n    /**\n     * API revision that this connector supports all functions\n     *\n     * @var integer\n     */\n    protected static $ApiRevision = 58;\n\n    /**\n     * Storages (root dirs)\n     *\n     * @var array\n     **/\n    protected $volumes = array();\n\n    /**\n     * elFinder instance\n     *\n     * @var object\n     */\n    public static $instance = null;\n\n    /**\n     * Current request args\n     *\n     * @var array\n     */\n    public static $currentArgs = array();\n\n    /**\n     * Network mount drivers\n     *\n     * @var array\n     */\n    public static $netDrivers = array();\n\n    /**\n     * elFinder global locale\n     *\n     * @var string\n     */\n    public static $locale = '';\n\n    /**\n     * elFinderVolumeDriver default mime.type file path\n     *\n     * @var string\n     */\n    public static $defaultMimefile = '';\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkUrl = '';\n\n    /**\n     * Temporary content URL lifetime (seconds)\n     *\n     * @var integer\n     */\n    public static $tmpLinkLifeTime = 3600;\n\n    /**\n     * MIME type list handled as a text file\n     *\n     * @var array\n     */\n    public static $textMimes = array(\n        'application/dash+xml',\n        'application/docbook+xml',\n        'application/javascript',\n        'application/json',\n        'application/plt',\n        'application/sat',\n        'application/sql',\n        'application/step',\n        'application/vnd.hp-hpgl',\n        'application/x-awk',\n        'application/x-config',\n        'application/x-csh',\n        'application/x-empty',\n        'application/x-mpegurl',\n        'application/x-perl',\n        'application/x-php',\n        'application/x-web-config',\n        'application/xhtml+xml',\n        'application/xml',\n        'audio/x-mp3-playlist',\n        'image/cgm',\n        'image/svg+xml',\n        'image/vnd.dxf',\n        'model/iges'\n    );\n\n    /**\n     * Maximum memory size to be extended during GD processing\n     * (0: not expanded, -1: unlimited or memory size notation)\n     *\n     * @var integer|string\n     */\n    public static $memoryLimitGD = 0;\n\n    /**\n     * Path of current request flag file for abort check\n     *\n     * @var string\n     */\n    protected static $abortCheckFile = null;\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * elFinder global sessionCacheKey\n     *\n     * @deprecated\n     * @var string\n     */\n    public static $sessionCacheKey = '';\n\n    /**\n     * Is session closed\n     *\n     * @deprecated\n     * @var bool\n     */\n    private static $sessionClosed = false;\n\n    /**\n     * elFinder base64encodeSessionData\n     * elFinder save session data as `UTF-8`\n     * If the session storage mechanism of the system does not allow `UTF-8`\n     * And it must be `true` option 'base64encodeSessionData' of elFinder\n     * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n     * it make vulnerable to the object injection attack, so use it carefully.\n     * see https://github.com/Studio-42/elFinder/issues/2345\n     *\n     * @var bool\n     */\n    protected static $base64encodeSessionData = false;\n\n    /**\n     * elFinder common tempraly path\n     *\n     * @var string\n     * @default \"./.tmp\" or sys_get_temp_dir()\n     **/\n    protected static $commonTempPath = '';\n\n    /**\n     * Callable function for URL upload filter\n     * The first argument is a URL and the second argument is an instance of the elFinder class\n     * A filter should be return true (to allow) / false (to disallow)\n     *\n     * @var callable\n     * @default null\n     */\n    protected $urlUploadFilter = null;\n\n    /**\n     * Connection flag files path that connection check of current request\n     *\n     * @var string\n     * @default value of $commonTempPath\n     */\n    protected static $connectionFlagsPath = '';\n\n    /**\n     * Additional volume root options for network mounting volume\n     *\n     * @var array\n     */\n    protected $optionsNetVolumes = array();\n\n    /**\n     * Session key of net mount volumes\n     *\n     * @deprecated\n     * @var string\n     */\n    protected $netVolumesSessionKey = '';\n\n    /**\n     * Mounted volumes count\n     * Required to create unique volume id\n     *\n     * @var int\n     **/\n    public static $volumesCnt = 1;\n\n    /**\n     * Default root (storage)\n     *\n     * @var elFinderVolumeDriver\n     **/\n    protected $default = null;\n\n    /**\n     * Commands and required arguments list\n     *\n     * @var array\n     **/\n    protected $commands = array(\n        'abort' => array('id' => true),\n        'archive' => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n        'callback' => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n        'chmod' => array('targets' => true, 'mode' => true),\n        'dim' => array('target' => true, 'substitute' => false),\n        'duplicate' => array('targets' => true, 'suffix' => false),\n        'editor' => array('name' => true, 'method' => true, 'args' => false),\n        'extract' => array('target' => true, 'mimes' => false, 'makedir' => false),\n        'file' => array('target' => true, 'download' => false, 'cpath' => false, 'onetime' => false),\n        'get' => array('target' => true, 'conv' => false),\n        'info' => array('targets' => true, 'compare' => false),\n        'ls' => array('target' => true, 'mimes' => false, 'intersect' => false),\n        'mkdir' => array('target' => true, 'name' => false, 'dirs' => false),\n        'mkfile' => array('target' => true, 'name' => true, 'mimes' => false),\n        'netmount' => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n        'open' => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n        'parents' => array('target' => true, 'until' => false),\n        'paste' => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n        'put' => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n        'rename' => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n        'resize' => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n        'rm' => array('targets' => true),\n        'search' => array('q' => true, 'mimes' => false, 'target' => false, 'type' => false),\n        'size' => array('targets' => true),\n        'subdirs' => array('targets' => true),\n        'tmb' => array('targets' => true),\n        'tree' => array('target' => true),\n        'upload' => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false, 'contentSaveId' => false),\n        'url' => array('target' => true, 'options' => false),\n        'zipdl' => array('targets' => true, 'download' => false)\n    );\n\n    /**\n     * Plugins instance\n     *\n     * @var array\n     **/\n    protected $plugins = array();\n\n    /**\n     * Commands listeners\n     *\n     * @var array\n     **/\n    protected $listeners = array();\n\n    /**\n     * script work time for debug\n     *\n     * @var string\n     **/\n    protected $time = 0;\n    /**\n     * Is elFinder init correctly?\n     *\n     * @var bool\n     **/\n    protected $loaded = false;\n    /**\n     * Send debug to client?\n     *\n     * @var string\n     **/\n    protected $debug = false;\n\n    /**\n     * Call `session_write_close()` before exec command?\n     *\n     * @var bool\n     */\n    protected $sessionCloseEarlier = true;\n\n    /**\n     * SESSION use commands @see __construct()\n     *\n     * @var array\n     */\n    protected $sessionUseCmds = array();\n\n    /**\n     * session expires timeout\n     *\n     * @var int\n     **/\n    protected $timeout = 0;\n\n    /**\n     * Temp dir path for Upload\n     *\n     * @var string\n     */\n    protected $uploadTempPath = '';\n\n    /**\n     * Max allowed archive files size (0 - no limit)\n     *\n     * @var integer\n     */\n    protected $maxArcFilesSize = 0;\n\n    /**\n     * undocumented class variable\n     *\n     * @var string\n     **/\n    protected $uploadDebug = '';\n\n    /**\n     * Max allowed numbar of targets (0 - no limit)\n     *\n     * @var integer\n     */\n    public $maxTargets = 1000;\n\n    /**\n     * Errors from PHP\n     *\n     * @var array\n     **/\n    public static $phpErrors = array();\n\n    /**\n     * Errors from not mounted volumes\n     *\n     * @var array\n     **/\n    public $mountErrors = array();\n\n\n    /**\n     * Archivers cache\n     *\n     * @var array\n     */\n    public static $archivers = array();\n\n    /**\n     * URL for callback output window for CORS\n     * redirect to this URL when callback output\n     *\n     * @var string URL\n     */\n    protected $callbackWindowURL = '';\n\n    /**\n     * hash of items to unlock on command completion\n     *\n     * @var array hashes\n     */\n    protected $autoUnlocks = array();\n\n    /**\n     * Item locking expiration (seconds)\n     * Default: 3600 secs\n     *\n     * @var integer\n     */\n    protected $itemLockExpire = 3600;\n\n    /**\n     * Additional request querys\n     *\n     * @var array|null\n     */\n    protected $customData = null;\n\n    /**\n     * Ids to remove of session var \"urlContentSaveIds\" for contents uploading by URL\n     *\n     * @var array\n     */\n    protected $removeContentSaveIds = array();\n\n    /**\n     * LAN class allowed when uploading via URL\n     * \n     * Array keys are 'local', 'private_a', 'private_b', 'private_c' and 'link'\n     * \n     * local:     127.0.0.0/8\n     * private_a: 10.0.0.0/8\n     * private_b: 172.16.0.0/12\n     * private_c: 192.168.0.0/16\n     * link:      169.254.0.0/16\n     *\n     * @var        array\n     */\n    protected $uploadAllowedLanIpClasses = array();\n\n    /**\n     * Flag of throw Error on exec()\n     *\n     * @var boolean\n     */\n    protected $throwErrorOnExec = false;\n\n    /**\n     * Default params of toastParams\n     *\n     * @var        array\n     */\n    protected $toastParamsDefault = array(\n        'mode'   => 'warning',\n        'prefix' => ''\n    );\n\n    /**\n     * Toast params of runtime notification\n     *\n     * @var        array\n     */\n    private $toastParams = array();\n\n    /**\n     * Toast messages of runtime notification\n     *\n     * @var        array\n     */\n    private $toastMessages = array();\n\n    /**\n     * Optional UTF-8 encoder\n     *\n     * @var        callable || null\n     */\n    private $utf8Encoder = null;\n\n    /**\n     * Seekable URL file pointer ids -  for getStreamByUrl()\n     *\n     * @var        array\n     */\n    private static $seekableUrlFps = array();\n\n    // Errors messages\n    const ERROR_ACCESS_DENIED = 'errAccess';\n    const ERROR_ARC_MAXSIZE = 'errArcMaxSize';\n    const ERROR_ARC_SYMLINKS = 'errArcSymlinks';\n    const ERROR_ARCHIVE = 'errArchive';\n    const ERROR_ARCHIVE_EXEC = 'errArchiveExec';\n    const ERROR_ARCHIVE_TYPE = 'errArcType';\n    const ERROR_CONF = 'errConf';\n    const ERROR_CONF_NO_JSON = 'errJSON';\n    const ERROR_CONF_NO_VOL = 'errNoVolumes';\n    const ERROR_CONV_UTF8 = 'errConvUTF8';\n    const ERROR_COPY = 'errCopy';\n    const ERROR_COPY_FROM = 'errCopyFrom';\n    const ERROR_COPY_ITSELF = 'errCopyInItself';\n    const ERROR_COPY_TO = 'errCopyTo';\n    const ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n    const ERROR_DIR_NOT_FOUND = 'errFolderNotFound';\n    const ERROR_EXISTS = 'errExists';        // 'File named \"$1\" already exists.'\n    const ERROR_EXTRACT = 'errExtract';\n    const ERROR_EXTRACT_EXEC = 'errExtractExec';\n    const ERROR_FILE_NOT_FOUND = 'errFileNotFound';     // 'File not found.'\n    const ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n    const ERROR_FTP_MKDIR = 'errFtpMkdir';\n    const ERROR_FTP_UPLOAD_FILE = 'errFtpUploadFile';\n    const ERROR_INV_PARAMS = 'errCmdParams';\n    const ERROR_INVALID_DIRNAME = 'errInvDirname';    // 'Invalid folder name.'\n    const ERROR_INVALID_NAME = 'errInvName';       // 'Invalid file name.'\n    const ERROR_LOCKED = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n    const ERROR_MAX_TARGTES = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n    const ERROR_MKDIR = 'errMkdir';\n    const ERROR_MKFILE = 'errMkfile';\n    const ERROR_MKOUTLINK = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n    const ERROR_MOVE = 'errMove';\n    const ERROR_NETMOUNT = 'errNetMount';\n    const ERROR_NETMOUNT_FAILED = 'errNetMountFailed';\n    const ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n    const ERROR_NETUNMOUNT = 'errNetUnMount';\n    const ERROR_NOT_ARCHIVE = 'errNoArchive';\n    const ERROR_NOT_DIR = 'errNotFolder';\n    const ERROR_NOT_FILE = 'errNotFile';\n    const ERROR_NOT_REPLACE = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n    const ERROR_NOT_UTF8_CONTENT = 'errNotUTF8Content';\n    const ERROR_OPEN = 'errOpen';\n    const ERROR_PERM_DENIED = 'errPerm';\n    const ERROR_REAUTH_REQUIRE = 'errReauthRequire';  // 'Re-authorization is required.'\n    const ERROR_RENAME = 'errRename';\n    const ERROR_REPLACE = 'errReplace';          // 'Unable to replace \"$1\".'\n    const ERROR_RESIZE = 'errResize';\n    const ERROR_RESIZESIZE = 'errResizeSize';\n    const ERROR_RM = 'errRm';               // 'Unable to remove \"$1\".'\n    const ERROR_RM_SRC = 'errRmSrc';            // 'Unable remove source file(s)'\n    const ERROR_SAVE = 'errSave';\n    const ERROR_SEARCH_TIMEOUT = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n    const ERROR_SESSION_EXPIRES = 'errSessionExpires';\n    const ERROR_TRGDIR_NOT_FOUND = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n    const ERROR_UNKNOWN = 'errUnknown';\n    const ERROR_UNKNOWN_CMD = 'errUnknownCmd';\n    const ERROR_UNSUPPORT_TYPE = 'errUsupportType';\n    const ERROR_UPLOAD = 'errUpload';           // 'Upload error.'\n    const ERROR_UPLOAD_FILE = 'errUploadFile';       // 'Unable to upload \"$1\".'\n    const ERROR_UPLOAD_FILE_MIME = 'errUploadMime';       // 'File type not allowed.'\n    const ERROR_UPLOAD_FILE_SIZE = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n    const ERROR_UPLOAD_NO_FILES = 'errUploadNoFiles';    // 'No files found for upload.'\n    const ERROR_UPLOAD_TEMP = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n    const ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n    const ERROR_UPLOAD_TRANSFER = 'errUploadTransfer';   // '\"$1\" transfer error.'\n    const ERROR_MAX_MKDIRS = 'errMaxMkdirs'; // 'You can create up to $1 folders at one time.'\n\n    /**\n     * Constructor\n     *\n     * @param  array  elFinder and roots configurations\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct($opts)\n    {\n        // set default_charset\n        if (version_compare(PHP_VERSION, '5.6', '>=')) {\n            if (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('iconv.internal_encoding', '');\n            }\n            if (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('mbstring.internal_encoding', '');\n            }\n            if (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('internal_encoding', '');\n            }\n        } else {\n            if (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n                iconv_set_encoding('internal_encoding', 'UTF-8');\n            }\n            if (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n                mb_internal_encoding('UTF-8');\n            }\n        }\n        ini_set('default_charset', 'UTF-8');\n\n        // define accept constant of server commands path\n        !defined('ELFINDER_TAR_PATH') && define('ELFINDER_TAR_PATH', 'tar');\n        !defined('ELFINDER_GZIP_PATH') && define('ELFINDER_GZIP_PATH', 'gzip');\n        !defined('ELFINDER_BZIP2_PATH') && define('ELFINDER_BZIP2_PATH', 'bzip2');\n        !defined('ELFINDER_XZ_PATH') && define('ELFINDER_XZ_PATH', 'xz');\n        !defined('ELFINDER_ZIP_PATH') && define('ELFINDER_ZIP_PATH', 'zip');\n        !defined('ELFINDER_UNZIP_PATH') && define('ELFINDER_UNZIP_PATH', 'unzip');\n        !defined('ELFINDER_RAR_PATH') && define('ELFINDER_RAR_PATH', 'rar');\n        // Create archive in RAR4 format even when using RAR5 library (true or false)\n        !defined('ELFINDER_RAR_MA4') && define('ELFINDER_RAR_MA4', false);\n        !defined('ELFINDER_UNRAR_PATH') && define('ELFINDER_UNRAR_PATH', 'unrar');\n        !defined('ELFINDER_7Z_PATH') && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN') ? '7z' : '7za');\n        !defined('ELFINDER_CONVERT_PATH') && define('ELFINDER_CONVERT_PATH', 'convert');\n        !defined('ELFINDER_IDENTIFY_PATH') && define('ELFINDER_IDENTIFY_PATH', 'identify');\n        !defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n        !defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n        !defined('ELFINDER_FFMPEG_PATH') && define('ELFINDER_FFMPEG_PATH', 'ffmpeg');\n\n        !defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n        // enable(true)/disable(false) handling postscript on ImageMagick\n        // Should be `false` as long as there is a Ghostscript vulnerability\n        // see https://artifex.com/news/ghostscript-security-resolved/\n        !defined('ELFINDER_IMAGEMAGICK_PS') && define('ELFINDER_IMAGEMAGICK_PS', false);\n\n        // for backward compat\n        $this->version = (string)self::$ApiVersion;\n\n        // set error handler of WARNING, NOTICE\n        $errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n        if (defined('E_DEPRECATED')) {\n            $errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n        }\n        set_error_handler('elFinder::phpErrorHandler', $errLevel);\n\n        // Associative array of file pointers to close at the end of script: ['temp file pointer' => true]\n        $GLOBALS['elFinderTempFps'] = array();\n        // Associative array of files to delete at the end of script: ['temp file path' => true]\n        $GLOBALS['elFinderTempFiles'] = array();\n        // regist Shutdown function\n        register_shutdown_function(array('elFinder', 'onShutdown'));\n\n        // convert PATH_INFO to GET query\n        if (!empty($_SERVER['PATH_INFO'])) {\n            $_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n            if (!isset($_GET['cmd'])) {\n                $_cmd = $_ps[0];\n                if (isset($this->commands[$_cmd])) {\n                    $_GET['cmd'] = $_cmd;\n                    $_i = 1;\n                    foreach (array_keys($this->commands[$_cmd]) as $_k) {\n                        if (isset($_ps[$_i])) {\n                            if (!isset($_GET[$_k])) {\n                                $_GET[$_k] = $_ps[$_i++];\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // set elFinder instance\n        elFinder::$instance = $this;\n\n        // setup debug mode\n        $this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n        if ($this->debug) {\n            error_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL') ? ELFINDER_DEBUG_ERRORLEVEL : -1);\n            ini_set('display_errors', '1');\n            // clear output buffer and stop output filters\n            while (ob_get_level() && ob_end_clean()) {\n            }\n        }\n\n        if (!interface_exists('elFinderSessionInterface')) {\n            include_once dirname(__FILE__) . '/elFinderSessionInterface.php';\n        }\n\n        // session handler\n        if (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n            $this->session = $opts['session'];\n        } else {\n            $sessionOpts = array(\n                'base64encode' => !empty($opts['base64encodeSessionData']),\n                'keys' => array(\n                    'default' => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n                    'netvolume' => !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n                )\n            );\n            if (!class_exists('elFinderSession')) {\n                include_once dirname(__FILE__) . '/elFinderSession.php';\n            }\n            $this->session = new elFinderSession($sessionOpts);\n        }\n        // try session start | restart\n        $this->session->start();\n\n        // 'netmount' added to handle requests synchronously on unmount\n        $sessionUseCmds = array('netmount');\n        if (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n            $sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n        }\n\n        // set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n        if (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n            self::$volumesCnt = $volumesCntStart;\n        }\n\n        $this->time = $this->utime();\n        $this->sessionCloseEarlier = isset($opts['sessionCloseEarlier']) ? (bool)$opts['sessionCloseEarlier'] : true;\n        $this->sessionUseCmds = array_flip($sessionUseCmds);\n        $this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n        $this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n        $this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n        $this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n        elFinder::$commonTempPath = (isset($opts['commonTempPath']) ? realpath($opts['commonTempPath']) : dirname(__FILE__) . '/.tmp');\n        if (!is_writable(elFinder::$commonTempPath)) {\n            elFinder::$commonTempPath = sys_get_temp_dir();\n            if (!is_writable(elFinder::$commonTempPath)) {\n                elFinder::$commonTempPath = '';\n            }\n        }\n        if (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'] = realpath($opts['connectionFlagsPath']))) {\n            elFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n        } else {\n            elFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n        }\n\n        if (!empty($opts['tmpLinkPath'])) {\n            elFinder::$tmpLinkPath = realpath($opts['tmpLinkPath']);\n        }\n        if (!empty($opts['tmpLinkUrl'])) {\n            elFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n        }\n        if (!empty($opts['tmpLinkLifeTime'])) {\n            elFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n        }\n        if (!empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n            elfinder::$textMimes = $opts['textMimes'];\n        }\n        if (!empty($opts['urlUploadFilter'])) {\n            $this->urlUploadFilter = $opts['urlUploadFilter'];\n        }\n        $this->maxArcFilesSize = isset($opts['maxArcFilesSize']) ? intval($opts['maxArcFilesSize']) : 0;\n        $this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes'])) ? $opts['optionsNetVolumes'] : array();\n        if (isset($opts['itemLockExpire'])) {\n            $this->itemLockExpire = intval($opts['itemLockExpire']);\n        }\n\n        if (!empty($opts['uploadAllowedLanIpClasses'])) {\n            $this->uploadAllowedLanIpClasses = array_flip($opts['uploadAllowedLanIpClasses']);\n        }\n\n        // deprecated settings\n        $this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n        self::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\n        // check session cache\n        $_optsMD5 = md5(json_encode($opts['roots']));\n        if ($this->session->get('_optsMD5') !== $_optsMD5) {\n            $this->session->set('_optsMD5', $_optsMD5);\n        }\n\n        // setlocale and global locale regists to elFinder::locale\n        self::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN' ? 'C' : 'en_US.UTF-8');\n        if (false === setlocale(LC_ALL, self::$locale)) {\n            self::$locale = setlocale(LC_ALL, '0');\n        }\n\n        // set defaultMimefile\n        elFinder::$defaultMimefile = isset($opts['defaultMimefile']) ? $opts['defaultMimefile'] : '';\n\n        // set memoryLimitGD\n        elFinder::$memoryLimitGD = isset($opts['memoryLimitGD']) ? $opts['memoryLimitGD'] : 0;\n\n        // set flag of throwErrorOnExec\n        // `true` need `try{}` block for `$connector->run();`\n        $this->throwErrorOnExec = !empty($opts['throwErrorOnExec']);\n\n        // set archivers\n        elFinder::$archivers = isset($opts['archivers']) && is_array($opts['archivers']) ? $opts['archivers'] : array();\n\n        // set utf8Encoder\n        if (isset($opts['utf8Encoder']) && is_callable($opts['utf8Encoder'])) {\n            $this->utf8Encoder = $opts['utf8Encoder'];\n        }\n\n        // bind events listeners\n        if (!empty($opts['bind']) && is_array($opts['bind'])) {\n            $_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n            $_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n            foreach ($opts['bind'] as $cmd => $handlers) {\n                $doRegist = (strpos($cmd, '*') !== false);\n                if (!$doRegist) {\n                    $doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n                }\n                if ($doRegist) {\n                    // for backward compatibility\n                    if (!is_array($handlers)) {\n                        $handlers = array($handlers);\n                    } else {\n                        if (count($handlers) === 2 && is_callable($handlers)) {\n                            $handlers = array($handlers);\n                        }\n                    }\n                    foreach ($handlers as $handler) {\n                        if ($handler) {\n                            if (is_string($handler) && strpos($handler, '.')) {\n                                list($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n                                if (strcasecmp($_domain, 'plugin') === 0) {\n                                    if ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name]) ? $opts['plugin'][$_name] : array())\n                                        and method_exists($plugin, $_method)) {\n                                        $this->bind($cmd, array($plugin, $_method));\n                                    }\n                                }\n                            } else {\n                                $this->bind($cmd, $handler);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isset($opts['roots']) || !is_array($opts['roots'])) {\n            $opts['roots'] = array();\n        }\n\n        // try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n        if (empty(elFinder::$netDrivers['ziparchive'])) {\n            elFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n        }\n\n        // check for net volumes stored in session\n        $netVolumes = $this->getNetVolumes();\n        foreach ($netVolumes as $key => $root) {\n            if (!isset($root['id'])) {\n                // given fixed unique id\n                if (!$root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                    $this->mountErrors[] = 'Netmount Driver \"' . $root['driver'] . '\" : Could\\'t given volume id.';\n                    continue;\n                }\n            }\n            $root['_isNetVolume'] = true;\n            $opts['roots'][$key] = $root;\n        }\n\n        // \"mount\" volumes\n        foreach ($opts['roots'] as $i => $o) {\n            $class = 'elFinderVolume' . (isset($o['driver']) ? $o['driver'] : '');\n\n            if (class_exists($class)) {\n                /* @var elFinderVolumeDriver $volume */\n                $volume = new $class();\n\n                try {\n                    if ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n                        $o['maxArcFilesSize'] = $this->maxArcFilesSize;\n                    }\n                    // pass session handler\n                    $volume->setSession($this->session);\n                    if (!$this->default) {\n                        $volume->setNeedOnline(true);\n                    }\n                    if ($volume->mount($o)) {\n                        // unique volume id (ends on \"_\") - used as prefix to files hash\n                        $id = $volume->id();\n\n                        $this->volumes[$id] = $volume;\n                        if ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n                            $this->default = $volume;\n                        }\n                    } else {\n                        if (!empty($o['_isNetVolume'])) {\n                            $this->removeNetVolume($i, $volume);\n                        }\n                        $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . implode(' ', $volume->error());\n                    }\n                } catch (Exception $e) {\n                    if (!empty($o['_isNetVolume'])) {\n                        $this->removeNetVolume($i, $volume);\n                    }\n                    $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . $e->getMessage();\n                }\n            } else {\n                if (!empty($o['_isNetVolume'])) {\n                    $this->removeNetVolume($i, $volume);\n                }\n                $this->mountErrors[] = 'Driver \"' . $class . '\" does not exist';\n            }\n        }\n\n        // if at least one readable volume - ii desu >_<\n        $this->loaded = !empty($this->default);\n\n        // restore error handler for now\n        restore_error_handler();\n    }\n\n    /**\n     * Return elFinder session wrapper instance\n     *\n     * @return  elFinderSessionInterface\n     **/\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Return true if fm init correctly\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function loaded()\n    {\n        return $this->loaded;\n    }\n\n    /**\n     * Return version (api) number\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function version()\n    {\n        return self::$ApiVersion;\n    }\n\n    /**\n     * Return revision (api) number\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function revision()\n    {\n        return self::$ApiRevision;\n    }\n\n    /**\n     * Add handler to elFinder command\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function bind($cmd, $handler)\n    {\n        $allCmds = array_keys($this->commands);\n        $cmds = array();\n        foreach (explode(' ', $cmd) as $_cmd) {\n            if ($_cmd !== '') {\n                if ($all = strpos($_cmd, '*') !== false) {\n                    list(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n                    if ($sub) {\n                        $sub = str_replace('\\'', '\\\\\\'', $sub);\n                        $subs = array_fill(0, count($allCmds), $sub);\n                        $cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n                    } else {\n                        $cmds = array_merge($cmds, $allCmds);\n                    }\n                } else {\n                    $cmds[] = $_cmd;\n                }\n            }\n        }\n        $cmds = array_unique($cmds);\n\n        foreach ($cmds as $cmd) {\n            if (!isset($this->listeners[$cmd])) {\n                $this->listeners[$cmd] = array();\n            }\n\n            if (is_callable($handler)) {\n                $this->listeners[$cmd][] = $handler;\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Remove event (command exec) handler\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function unbind($cmd, $handler)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $i => $h) {\n                if ($h === $handler) {\n                    unset($this->listeners[$cmd][$i]);\n                    return $this;\n                }\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Trigger binded functions\n     *\n     * @param      string  $cmd     binded command name\n     * @param      array   $vars    variables to pass to listeners\n     * @param      array   $errors  array into which the error is written\n     */\n    public function trigger($cmd, $vars, &$errors)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                $_res = call_user_func_array($handler, $vars);\n                if ($_res && is_array($_res)) {\n                    $_err = !empty($_res['error'])? $_res['error'] : (!empty($_res['warning'])? $_res['warning'] : null);\n                    if ($_err) {\n                        if (is_array($_err)) {\n                            $errors = array_merge($errors, $_err);\n                        } else {\n                            $errors[] = (string)$_err;\n                        }\n                        if ($_res['error']) {\n                            throw new elFinderTriggerException();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Return true if command exists\n     *\n     * @param  string  command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandExists($cmd)\n    {\n        return $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n    }\n\n    /**\n     * Return root - file's owner (public func of volume())\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver\n     * @author Naoki Sawada\n     */\n    public function getVolume($hash)\n    {\n        return $this->volume($hash);\n    }\n\n    /**\n     * Return command required arguments info\n     *\n     * @param  string  command name\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandArgsList($cmd)\n    {\n        if ($this->commandExists($cmd)) {\n            $list = $this->commands[$cmd];\n            $list['reqid'] = false;\n        } else {\n            $list = array();\n        }\n        return $list;\n    }\n\n    private function session_expires()\n    {\n\n        if (!$last = $this->session->get(':LAST_ACTIVITY')) {\n            $this->session->set(':LAST_ACTIVITY', time());\n            return false;\n        }\n\n        if (($this->timeout > 0) && (time() - $last > $this->timeout)) {\n            return true;\n        }\n\n        $this->session->set(':LAST_ACTIVITY', time());\n        return false;\n    }\n\n    /**\n     * Exec command and return result\n     *\n     * @param  string $cmd  command name\n     * @param  array  $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException|Exception\n     * @author Dmitry (dio) Levashov\n     **/\n    public function exec($cmd, $args)\n    {\n        // set error handler of WARNING, NOTICE\n        set_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\n        // set current request args\n        self::$currentArgs = $args;\n\n        if (!$this->loaded) {\n            return array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n        }\n\n        if ($this->session_expires()) {\n            return array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n        }\n\n        if (!$this->commandExists($cmd)) {\n            return array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n        }\n\n        // check request id\n        $args['reqid'] = preg_replace('[^0-9a-fA-F]', '', !empty($args['reqid']) ? $args['reqid'] : (!empty($_SERVER['HTTP_X_ELFINDERREQID']) ? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\n        // to abort this request\n        if ($cmd === 'abort') {\n            $this->abort($args);\n            return array('error' => 0);\n        }\n\n        // make flag file and set self::$abortCheckFile\n        if ($args['reqid']) {\n            $this->abort(array('makeFile' => $args['reqid']));\n        }\n\n        if (!empty($args['mimes']) && is_array($args['mimes'])) {\n            foreach ($this->volumes as $id => $v) {\n                $this->volumes[$id]->setMimesFilter($args['mimes']);\n            }\n        }\n\n        // regist shutdown function as fallback\n        register_shutdown_function(array($this, 'itemAutoUnlock'));\n\n        // detect destination dirHash and volume\n        $dstVolume = false;\n        $dst = !empty($args['target']) ? $args['target'] : (!empty($args['dst']) ? $args['dst'] : '');\n        if ($dst) {\n            $dstVolume = $this->volume($dst);\n        } else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n            $dst = $args['targets'][0];\n            $dstVolume = $this->volume($dst);\n            if ($dstVolume && ($_stat = $dstVolume->file($dst)) && !empty($_stat['phash'])) {\n                $dst = $_stat['phash'];\n            } else {\n                $dst = '';\n            }\n        } else if ($cmd === 'open') {\n            // for initial open without args `target`\n            $dstVolume = $this->default;\n            $dst = $dstVolume->defaultPath();\n        }\n\n        $result = null;\n\n        // call pre handlers for this command\n        $args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd]) ? false : $this->sessionCloseEarlier;\n        if (!empty($this->listeners[$cmd . '.pre'])) {\n            foreach ($this->listeners[$cmd . '.pre'] as $handler) {\n                $_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n                if (is_array($_res)) {\n                    if (!empty($_res['preventexec'])) {\n                        $result = array('error' => true);\n                        if ($cmd === 'upload' && !empty($args['node'])) {\n                            $result['callback'] = array(\n                                'node' => $args['node'],\n                                'bind' => $cmd\n                            );\n                        }\n                        if (!empty($_res['results']) && is_array($_res['results'])) {\n                            $result = array_merge($result, $_res['results']);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        // unlock session data for multiple access\n        if ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n            $this->session->close();\n            // deprecated property\n            elFinder::$sessionClosed = true;\n        }\n\n        if (substr(PHP_OS, 0, 3) === 'WIN') {\n            // set time out\n            elFinder::extendTimeLimit(300);\n        }\n\n        if (!is_array($result)) {\n            try {\n                $result = $this->$cmd($args);\n            } catch (elFinderAbortException $e) {\n                throw $e;\n            } catch (Exception $e) {\n                $result = array(\n                    'error' => htmlspecialchars($e->getMessage()),\n                    'sync' => true\n                );\n                if ($this->throwErrorOnExec) {\n                    throw $e;\n                }\n            }\n        }\n\n        // check change dstDir\n        $changeDst = false;\n        if ($dst && $dstVolume && (!empty($result['added']) || !empty($result['removed']))) {\n            $changeDst = true;\n        }\n\n        foreach ($this->volumes as $volume) {\n            $removed = $volume->removed();\n            if (!empty($removed)) {\n                if (!isset($result['removed'])) {\n                    $result['removed'] = array();\n                }\n                $result['removed'] = array_merge($result['removed'], $removed);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $added = $volume->added();\n            if (!empty($added)) {\n                if (!isset($result['added'])) {\n                    $result['added'] = array();\n                }\n                $result['added'] = array_merge($result['added'], $added);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $volume->resetResultStat();\n        }\n\n        // dstDir is changed\n        if ($changeDst) {\n            if ($dstDir = $dstVolume->dir($dst)) {\n                if (!isset($result['changed'])) {\n                    $result['changed'] = array();\n                }\n                $result['changed'][] = $dstDir;\n            }\n        }\n\n        // call handlers for this command\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                if (call_user_func_array($handler, array($cmd, &$result, $args, $this, $dstVolume))) {\n                    // handler return true to force sync client after command completed\n                    $result['sync'] = true;\n                }\n            }\n        }\n\n        // replace removed files info with removed files hashes\n        if (!empty($result['removed'])) {\n            $removed = array();\n            foreach ($result['removed'] as $file) {\n                $removed[] = $file['hash'];\n            }\n            $result['removed'] = array_unique($removed);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['added'])) {\n            $result['added'] = $this->filter($result['added']);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['changed'])) {\n            $result['changed'] = $this->filter($result['changed']);\n        }\n        // add toasts\n        if ($this->toastMessages) {\n            $result['toasts'] = array_merge(((isset($result['toasts']) && is_array($result['toasts']))? $result['toasts'] : array()), $this->toastMessages);\n        }\n\n        if ($this->debug || !empty($args['debug'])) {\n            $result['debug'] = array(\n                'connector' => 'php',\n                'phpver' => PHP_VERSION,\n                'time' => $this->utime() - $this->time,\n                'memory' => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage() / 1024) . 'Kb / ' : '') . ceil(memory_get_usage() / 1024) . 'Kb / ' . ini_get('memory_limit'),\n                'upload' => $this->uploadDebug,\n                'volumes' => array(),\n                'mountErrors' => $this->mountErrors\n            );\n\n            foreach ($this->volumes as $id => $volume) {\n                $result['debug']['volumes'][] = $volume->debug();\n            }\n        }\n\n        // remove sesstion var 'urlContentSaveIds'\n        if ($this->removeContentSaveIds) {\n            $urlContentSaveIds = $this->session->get('urlContentSaveIds', array());\n            foreach (array_keys($this->removeContentSaveIds) as $contentSaveId) {\n                if (isset($urlContentSaveIds[$contentSaveId])) {\n                    unset($urlContentSaveIds[$contentSaveId]);\n                }\n            }\n            if ($urlContentSaveIds) {\n                $this->session->set('urlContentSaveIds', $urlContentSaveIds);\n            } else {\n                $this->session->remove('urlContentSaveIds');\n            }\n        }\n\n        foreach ($this->volumes as $volume) {\n            $volume->saveSessionCache();\n            $volume->umount();\n        }\n\n        // unlock locked items\n        $this->itemAutoUnlock();\n\n        // custom data\n        if ($this->customData !== null) {\n            $result['customData'] = $this->customData ? json_encode($this->customData) : '';\n        }\n\n        if (!empty($result['debug'])) {\n            $result['debug']['backendErrors'] = elFinder::$phpErrors;\n        }\n        elFinder::$phpErrors = array();\n        restore_error_handler();\n\n        if (!empty($result['callback'])) {\n            $result['callback']['json'] = json_encode($result);\n            $this->callback($result['callback']);\n            return array();\n        } else {\n            return $result;\n        }\n    }\n\n    /**\n     * Return file real path\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        if (($volume = $this->volume($hash)) == false) {\n            return false;\n        }\n        return $volume->realpath($hash);\n    }\n\n    /**\n     * Sets custom data(s).\n     *\n     * @param  string|array $key The key or data array\n     * @param  mixed        $val The value\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function setCustomData($key, $val = null)\n    {\n        if (is_array($key)) {\n            foreach ($key as $k => $v) {\n                $this->customData[$k] = $v;\n            }\n        } else {\n            $this->customData[$key] = $val;\n        }\n        return $this;\n    }\n\n    /**\n     * Removes a custom data.\n     *\n     * @param  string $key The key\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function removeCustomData($key)\n    {\n        $this->customData[$key] = null;\n        return $this;\n    }\n\n    /**\n     * Update sesstion value of a NetVolume option\n     *\n     * @param string $netKey\n     * @param string $optionKey\n     * @param mixed  $val\n     *\n     * @return bool\n     */\n    public function updateNetVolumeOption($netKey, $optionKey, $val)\n    {\n        $netVolumes = $this->getNetVolumes();\n        if (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n            $netVolumes[$netKey][$optionKey] = $val;\n            $this->saveNetVolumes($netVolumes);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * remove of session var \"urlContentSaveIds\"\n     *\n     * @param string $id\n     */\n    public function removeUrlContentSaveId($id)\n    {\n        $this->removeContentSaveIds[$id] = true;\n    }\n\n    /**\n     * Return network volumes config.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function getNetVolumes()\n    {\n        if ($data = $this->session->get('netvolume', array())) {\n            return $data;\n        }\n        return array();\n    }\n\n    /**\n     * Save network volumes config.\n     *\n     * @param  array $volumes volumes config\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function saveNetVolumes($volumes)\n    {\n        $this->session->set('netvolume', $volumes);\n    }\n\n    /**\n     * Remove netmount volume\n     *\n     * @param string $key    netvolume key\n     * @param object $volume volume driver instance\n     *\n     * @return bool\n     */\n    protected function removeNetVolume($key, $volume)\n    {\n        $netVolumes = $this->getNetVolumes();\n        $res = true;\n        if (is_object($volume) && method_exists($volume, 'netunmount')) {\n            $res = $volume->netunmount($netVolumes, $key);\n            $volume->clearSessionCache();\n        }\n        if ($res) {\n            if (is_string($key) && isset($netVolumes[$key])) {\n                unset($netVolumes[$key]);\n                $this->saveNetVolumes($netVolumes);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get plugin instance & set to $this->plugins\n     *\n     * @param  string $name Plugin name (dirctory name)\n     * @param  array  $opts Plugin options (optional)\n     *\n     * @return object | bool Plugin object instance Or false\n     * @author Naoki Sawada\n     */\n    protected function getPluginInstance($name, $opts = array())\n    {\n        $key = strtolower($name);\n        if (!isset($this->plugins[$key])) {\n            $class = 'elFinderPlugin' . $name;\n            // to try auto load\n            if (!class_exists($class)) {\n                $p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n                if (is_file($p_file)) {\n                    include_once $p_file;\n                }\n            }\n            if (class_exists($class, false)) {\n                $this->plugins[$key] = new $class($opts);\n            } else {\n                $this->plugins[$key] = false;\n            }\n        }\n        return $this->plugins[$key];\n    }\n\n    /***************************************************************************/\n    /*                                 commands                                */\n    /***************************************************************************/\n\n    /**\n     * Normalize error messages\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        $errors = array();\n\n        foreach (func_get_args() as $msg) {\n            if (is_array($msg)) {\n                $errors = array_merge($errors, $msg);\n            } else {\n                $errors[] = $msg;\n            }\n        }\n\n        return count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n    }\n\n    /**\n     * @param $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function netmount($args)\n    {\n        $options = array();\n        $protocol = $args['protocol'];\n        $toast = '';\n\n        if ($protocol === 'netunmount') {\n            if (!empty($args['user']) && $volume = $this->volume($args['user'])) {\n                if ($this->removeNetVolume($args['host'], $volume)) {\n                    return array('removed' => array(array('hash' => $volume->root())));\n                }\n            }\n            return array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n        }\n\n        $driver = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n        $class = 'elFinderVolume' . $driver;\n\n        if (!class_exists($class)) {\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n        }\n\n        if (!$args['path']) {\n            $args['path'] = '/';\n        }\n\n        foreach ($args as $k => $v) {\n            if ($k != 'options' && $k != 'protocol' && $v) {\n                $options[$k] = $v;\n            }\n        }\n\n        if (is_array($args['options'])) {\n            foreach ($args['options'] as $key => $value) {\n                $options[$key] = $value;\n            }\n        }\n\n        /* @var elFinderVolumeDriver $volume */\n        $volume = new $class();\n\n        // pass session handler\n        $volume->setSession($this->session);\n\n        $volume->setNeedOnline(true);\n\n        if (is_callable(array($volume, 'netmountPrepare'))) {\n            $options = $volume->netmountPrepare($options);\n            if (isset($options['exit'])) {\n                if ($options['exit'] === 'callback') {\n                    $this->callback($options['out']);\n                }\n                return $options;\n            }\n            if (!empty($options['toast'])) {\n                $toast = $options['toast'];\n                unset($options['toast']);\n            }\n        }\n\n        $netVolumes = $this->getNetVolumes();\n\n        if (!isset($options['id'])) {\n            // given fixed unique id\n            if (!$options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n            }\n        }\n\n        // load additional volume root options\n        if (!empty($this->optionsNetVolumes['*'])) {\n            $options = array_merge($this->optionsNetVolumes['*'], $options);\n        }\n        if (!empty($this->optionsNetVolumes[$protocol])) {\n            $options = array_merge($this->optionsNetVolumes[$protocol], $options);\n        }\n\n        if (!$key = $volume->netMountKey) {\n            $key = md5($protocol . '-' . serialize($options));\n        }\n        $options['netkey'] = $key;\n\n        if (!isset($netVolumes[$key]) && $volume->mount($options)) {\n            // call post-process function of netmount\n            if (is_callable(array($volume, 'postNetmount'))) {\n                $volume->postNetmount($options);\n            }\n            $options['driver'] = $driver;\n            $netVolumes[$key] = $options;\n            $this->saveNetVolumes($netVolumes);\n            $rootstat = $volume->file($volume->root());\n            $res = array('added' => array($rootstat));\n            if ($toast) {\n                $res['toast'] = $toast;\n            }\n            return $res;\n        } else {\n            $this->removeNetVolume(null, $volume);\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n        }\n    }\n\n    /**\n     * \"Open\" directory\n     * Return array with following elements\n     *  - cwd          - opened dir info\n     *  - files        - opened dir content [and dirs tree if $args[tree]]\n     *  - api          - api version (if $args[init])\n     *  - uplMaxSize   - if $args[init]\n     *  - error        - on failed\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function open($args)\n    {\n        $target = $args['target'];\n        $init = !empty($args['init']);\n        $tree = !empty($args['tree']);\n        $volume = $this->volume($target);\n        $cwd = $volume ? $volume->dir($target) : false;\n        $hash = $init ? 'default folder' : '#' . $target;\n        $compare = '';\n\n        // on init request we can get invalid dir hash -\n        // dir which can not be opened now, but remembered by client,\n        // so open default dir\n        if ((!$cwd || !$cwd['read']) && $init) {\n            $volume = $this->default;\n            $target = $volume->defaultPath();\n            $cwd = $volume->dir($target);\n        }\n\n        if (!$cwd) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n        }\n        if (!$cwd['read']) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n        }\n\n        $files = array();\n\n        // get current working directory files list\n        if (($ls = $volume->scandir($cwd['hash'])) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n        }\n\n        if (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n            $cwd = $volume->dir($target);\n        }\n\n        // get other volume root\n        if ($tree) {\n            foreach ($this->volumes as $id => $v) {\n                $files[] = $v->file($v->root());\n            }\n        }\n\n        // long polling mode\n        if ($args['compare']) {\n            $sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n            $standby = (int)$volume->getOption('plStandby');\n            if ($standby > 0 && $sleep > $standby) {\n                $standby = $sleep;\n            }\n            $limit = max(0, floor($standby / $sleep)) + 1;\n            do {\n                elFinder::extendTimeLimit(30 + $sleep);\n                $_mtime = 0;\n                foreach ($ls as $_f) {\n                    if (isset($_f['ts'])) {\n                        $_mtime = max($_mtime, $_f['ts']);\n                    }\n                }\n                $compare = strval(count($ls)) . ':' . strval($_mtime);\n                if ($compare !== $args['compare']) {\n                    break;\n                }\n                if (--$limit) {\n                    sleep($sleep);\n                    $volume->clearstatcache();\n                    if (($ls = $volume->scandir($cwd['hash'])) === false) {\n                        break;\n                    }\n                }\n            } while ($limit);\n            if ($ls === false) {\n                return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n            }\n        }\n\n        if ($ls) {\n            if ($files) {\n                $files = array_merge($files, $ls);\n            } else {\n                $files = $ls;\n            }\n        }\n\n        $result = array(\n            'cwd' => $cwd,\n            'options' => $volume->options($cwd['hash']),\n            'files' => $files\n        );\n\n        if ($compare) {\n            $result['cwd']['compare'] = $compare;\n        }\n\n        if (!empty($args['init'])) {\n            $result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n            $result['uplMaxSize'] = ini_get('upload_max_filesize');\n            $result['uplMaxFile'] = ini_get('max_file_uploads');\n            $result['netDrivers'] = array_keys(self::$netDrivers);\n            $result['maxTargets'] = $this->maxTargets;\n            if ($volume) {\n                $result['cwd']['root'] = $volume->root();\n            }\n            if (elfinder::$textMimes) {\n                $result['textMimes'] = elfinder::$textMimes;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function ls($args)\n    {\n        $target = $args['target'];\n        $intersect = isset($args['intersect']) ? $args['intersect'] : array();\n\n        if (($volume = $this->volume($target)) == false\n            || ($list = $volume->ls($target, $intersect)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n        return array('list' => $list);\n    }\n\n    /**\n     * Return subdirs for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tree($args)\n    {\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->tree($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return parents dir for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function parents($args)\n    {\n        $target = $args['target'];\n        $until = $args['until'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->parents($target, false, $until)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return new created thumbnails list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function tmb($args)\n    {\n\n        $result = array('images' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) != false\n                && (($tmb = $volume->tmb($target)) != false)) {\n                $result['images'][$target] = $tmb;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Download files/folders as an archive file\n     * 1st: Return srrsy contains download archive file info\n     * 2nd: Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function zipdl($args)\n    {\n        $targets = $args['targets'];\n        $download = !empty($args['download']);\n        $h404 = 'HTTP/1.x 404 Not Found';\n        $CriOS = isset($_SERVER['HTTP_USER_AGENT'])? (strpos($_SERVER['HTTP_USER_AGENT'], 'CriOS') !== false) : false;\n\n        if (!$download) {\n            //1st: Return array contains download archive file info\n            $error = array(self::ERROR_ARCHIVE);\n            if (($volume = $this->volume($targets[0])) !== false) {\n                if ($dlres = $volume->zipdl($targets)) {\n                    $path = $dlres['path'];\n                    register_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n                    if (count($targets) === 1) {\n                        $name = basename($volume->path($targets[0]));\n                    } else {\n                        $name = $dlres['prefix'] . '_Files';\n                    }\n                    $name .= '.' . $dlres['ext'];\n                    $uniqid = uniqid();\n                    $this->session->set('zipdl' . $uniqid, basename($path));\n                    $result = array(\n                        'zipdl' => array(\n                            'file' => $CriOS? basename($path) : $uniqid,\n                            'name' => $name,\n                            'mime' => $dlres['mime']\n                        )\n                    );\n                    return $result;\n                }\n                $error = array_merge($error, $volume->error());\n            }\n            return array('error' => $error);\n        } else {\n            // 2nd: Return array contains opened file session key, root itself and required headers\n\n            // Detect Chrome on iOS\n            // It has access twice on downloading\n            $CriOSinit = false;\n            if ($CriOS) {\n                $accept = isset($_SERVER['HTTP_ACCEPT'])? $_SERVER['HTTP_ACCEPT'] : '';\n                if ($accept && $accept !== '*' && $accept !== '*/*') {\n                    $CriOSinit = true;\n                }\n            }\n            // data check\n            if (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false || !($file = $CriOS? $targets[1] : $this->session->get('zipdl' . $targets[1]))) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $path = $volume->getTempPath() . DIRECTORY_SEPARATOR . basename($file);\n            // remove session data of \"zipdl...\"\n            $this->session->remove('zipdl' . $targets[1]);\n            if (!$CriOSinit) {\n                // register auto delete on shutdown\n                $GLOBALS['elFinderTempFiles'][$path] = true;\n            }\n            if ($volume->commandDisabled('zipdl')) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            if (!is_readable($path) || !is_writable($path)) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            // for HTTP headers\n            $name = $targets[2];\n            $mime = $targets[3];\n\n            $filenameEncoded = rawurlencode($name);\n            if (strpos($filenameEncoded, '%') === false) { // ASCII only\n                $filename = 'filename=\"' . $name . '\"';\n            } else {\n                $ua = $_SERVER['HTTP_USER_AGENT'];\n                if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename=\"' . $filenameEncoded . '\"';\n                } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                    $filename = 'filename=\"' . str_replace('\"', '', $name) . '\"';\n                } else { // RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n                }\n            }\n\n            $fp = fopen($path, 'rb');\n            $file = fstat($fp);\n            $result = array(\n                'pointer' => $fp,\n                'header' => array(\n                    'Content-Type: ' . $mime,\n                    'Content-Disposition: attachment; ' . $filename,\n                    'Content-Transfer-Encoding: binary',\n                    'Content-Length: ' . $file['size'],\n                    'Accept-Ranges: none',\n                    'Connection: close'\n                )\n            );\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n            return $result;\n        }\n    }\n\n    /**\n     * Required to output file in browser when volume URL is not set\n     * Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function file($args)\n    {\n        $target = $args['target'];\n        $download = !empty($args['download']);\n        $onetime = !empty($args['onetime']);\n        //$h304     = 'HTTP/1.1 304 Not Modified';\n        $h403 = 'HTTP/1.0 403 Access Denied';\n        $a403 = array('error' => 'Access Denied', 'header' => $h403, 'raw' => true);\n        $h404 = 'HTTP/1.0 404 Not Found';\n        $a404 = array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\n        if ($onetime) {\n            $volume = null;\n            $tmpdir = elFinder::$commonTempPath;\n            if (!$tmpdir || !is_file($tmpf = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $target)) {\n                return $a404;\n            }\n            $GLOBALS['elFinderTempFiles'][$tmpf] = true;\n            if ($file = json_decode(file_get_contents($tmpf), true)) {\n                $src = base64_decode($file['file']);\n                if (!is_file($src) || !($fp = fopen($src, 'rb'))) {\n                    return $a404;\n                }\n                if (strpos($src, $tmpdir) === 0) {\n                    $GLOBALS['elFinderTempFiles'][$src] = true;\n                }\n                unset($file['file']);\n                $file['read'] = true;\n                $file['size'] = filesize($src);\n            } else {\n                return $a404;\n            }\n        } else {\n            if (($volume = $this->volume($target)) == false) {\n                return $a404;\n            }\n\n            if ($volume->commandDisabled('file')) {\n                return $a403;\n            }\n\n            if (($file = $volume->file($target)) == false) {\n                return $a404;\n            }\n\n            if (!$file['read']) {\n                return $a404;\n            }\n\n            $opts = array();\n            if (!empty($_SERVER['HTTP_RANGE'])) {\n                $opts['httpheaders'] = array('Range: ' . $_SERVER['HTTP_RANGE']);\n            }\n            if (($fp = $volume->open($target, $opts)) == false) {\n                return $a404;\n            }\n        }\n\n        // check aborted by user\n        elFinder::checkAborted();\n\n        // allow change MIME type by 'file.pre' callback functions\n        $mime = isset($args['mime']) ? $args['mime'] : $file['mime'];\n        if ($download || $onetime) {\n            $disp = 'attachment';\n        } else {\n            $dispInlineRegex = $volume->getOption('dispInlineRegex');\n            $inlineRegex = false;\n            if ($dispInlineRegex) {\n                $inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n                try {\n                    preg_match($inlineRegex, '');\n                } catch (Exception $e) {\n                    $inlineRegex = false;\n                }\n            }\n            if (!$inlineRegex) {\n                $inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n            }\n            $disp = preg_match($inlineRegex, $mime) ? 'inline' : 'attachment';\n        }\n\n        $filenameEncoded = rawurlencode($file['name']);\n        if (strpos($filenameEncoded, '%') === false) { // ASCII only\n            $filename = 'filename=\"' . $file['name'] . '\"';\n        } else {\n            $ua = isset($_SERVER['HTTP_USER_AGENT'])? $_SERVER['HTTP_USER_AGENT'] : '';\n            if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename=\"' . $filenameEncoded . '\"';\n            } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                $filename = 'filename=\"' . str_replace('\"', '', $file['name']) . '\"';\n            } else { // RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n            }\n        }\n\n        if ($args['cpath'] && $args['reqid']) {\n            setcookie('elfdl' . $args['reqid'], '1', 0, $args['cpath']);\n        }\n\n        $result = array(\n            'volume' => $volume,\n            'pointer' => $fp,\n            'info' => $file,\n            'header' => array(\n                'Content-Type: ' . $mime,\n                'Content-Disposition: ' . $disp . '; ' . $filename,\n                'Content-Transfer-Encoding: binary',\n                'Content-Length: ' . $file['size'],\n                'Last-Modified: ' . gmdate('D, d M Y H:i:s T', $file['ts']),\n                'Connection: close'\n            )\n        );\n\n        if (!$onetime) {\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n\n            // check 'xsendfile'\n            $xsendfile = $volume->getOption('xsendfile');\n            $path = null;\n            if ($xsendfile) {\n                $info = stream_get_meta_data($fp);\n                if ($path = empty($info['uri']) ? null : $info['uri']) {\n                    $basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n                    if ($basePath) {\n                        $root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n                        if (strpos($path, $root) === 0) {\n                            $path = $basePath . substr($path, strlen($root));\n                        } else {\n                            $path = null;\n                        }\n                    }\n                }\n            }\n            if ($path) {\n                $result['header'][] = $xsendfile . ': ' . $path;\n                $result['info']['xsendfile'] = $xsendfile;\n            }\n        }\n\n        // add \"Content-Location\" if file has url data\n        if (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n            $result['header'][] = 'Content-Location: ' . $file['url'];\n        }\n        return $result;\n    }\n\n    /**\n     * Count total files size\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function size($args)\n    {\n        $size = 0;\n        $files = 0;\n        $dirs = 0;\n        $itemCount = true;\n        $sizes = array();\n\n        foreach ($args['targets'] as $target) {\n            elFinder::checkAborted();\n            if (($volume = $this->volume($target)) == false\n                || ($file = $volume->file($target)) == false\n                || !$file['read']) {\n                return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n            }\n\n            $volRes = $volume->size($target);\n            if (is_array($volRes)) {\n                $sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n                if (!empty($volRes['size'])) {\n                    $sizeInfo['size'] = $volRes['size'];\n                    $size += $volRes['size'];\n                }\n                if (!empty($volRes['files'])) {\n                    $sizeInfo['fileCnt'] = $volRes['files'];\n                }\n                if (!empty($volRes['dirs'])) {\n                    $sizeInfo['dirCnt'] = $volRes['dirs'];\n                }\n                if ($itemCount) {\n                    $files += $sizeInfo['fileCnt'];\n                    $dirs += $sizeInfo['dirCnt'];\n                }\n                $sizes[$target] = $sizeInfo;\n            } else if (is_numeric($volRes)) {\n                $size += $volRes;\n                $files = $dirs = 'unknown';\n                $itemCount = false;\n            }\n        }\n        return array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n    }\n\n    /**\n     * Create directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkdir($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $dirs = $args['dirs'];\n        if ($name === '' && !$dirs) {\n            return array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n        }\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n        if ($dirs) {\n            $maxDirs = $volume->getOption('uploadMaxMkdirs');\n            if ($maxDirs && $maxDirs < count($dirs)) {\n                return array('error' => $this->error(self::ERROR_MAX_MKDIRS, $maxDirs));\n            }\n            sort($dirs);\n            $reset = null;\n            $mkdirs = array();\n            foreach ($dirs as $dir) {\n                $tgt =& $mkdirs;\n                $_names = explode('/', trim($dir, '/'));\n                foreach ($_names as $_key => $_name) {\n                    if (!isset($tgt[$_name])) {\n                        $tgt[$_name] = array();\n                    }\n                    $tgt =& $tgt[$_name];\n                }\n                $tgt =& $reset;\n            }\n            $res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n            $ret = array(\n                'added' => $res['stats'],\n                'hashes' => $res['hashes']\n            );\n            if ($res['error']) {\n                $ret['warning'] = $this->error(self::ERROR_MKDIR, $res['error'][0], $volume->error());\n            }\n            return $ret;\n        } else {\n            return ($dir = $volume->mkdir($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n                : array('added' => array($dir));\n        }\n    }\n\n    /**\n     * Create empty file\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkfile($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n\n        return ($file = $volume->mkfile($target, $args['name'])) == false\n            ? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n            : array('added' => array($file));\n    }\n\n    /**\n     * Rename file, Accept multiple items >= API 2.1031\n     *\n     * @param  array $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function rename($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $query = (!empty($args['q']) && strpos($args['q'], '*') !== false) ? $args['q'] : '';\n        $targets = !empty($args['targets'])? $args['targets'] : false;\n        $rms = array();\n        $notfounds = array();\n        $locked = array();\n        $errs = array();\n        $files = array();\n        $removed = array();\n        $res = array();\n        $type = 'normal';\n\n        if (!($volume = $this->volume($target))) {\n            return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($targets) {\n            array_unshift($targets, $target);\n            foreach ($targets as $h) {\n                if ($rm = $volume->file($h)) {\n                    if ($this->itemLocked($h)) {\n                        $locked[] = $rm['name'];\n                    } else {\n                        $rm['realpath'] = $volume->realpath($h);\n                        $rms[] = $rm;\n                    }\n                } else {\n                    $notfounds[] = '#' . $h;\n                }\n            }\n            if (!$rms) {\n                $res['error'] = array();\n                if ($notfounds) {\n                    $res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n                }\n                if ($locked) {\n                    array_push($res['error'], self::ERROR_LOCKED, join(', ', $locked));\n                }\n                return $res;\n            }\n\n            $res['warning'] = array();\n            if ($notfounds) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n            }\n            if ($locked) {\n                array_push($res['warning'], self::ERROR_LOCKED, join(', ', $locked));\n            }\n\n            if ($query) {\n                // batch rename\n                $splits = elFinder::splitFileExtention($query);\n                if ($splits[1] && $splits[0] === '*') {\n                    $type = 'extention';\n                    $name = $splits[1];\n                } else if (strlen($splits[0]) > 1) {\n                    if (substr($splits[0], -1) === '*') {\n                        $type = 'prefix';\n                        $name = substr($splits[0], 0, strlen($splits[0]) - 1);\n                    } else if (substr($splits[0], 0, 1) === '*') {\n                        $type = 'suffix';\n                        $name = substr($splits[0], 1);\n                    }\n                }\n                if ($type !== 'normal') {\n                    if (!empty($this->listeners['rename.pre'])) {\n                        $_args = array('name' => $name);\n                        foreach ($this->listeners['rename.pre'] as $handler) {\n                            $_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n                            if (!empty($_res['preventexec'])) {\n                                break;\n                            }\n                        }\n                        $name = $_args['name'];\n                    }\n                }\n            }\n            foreach ($rms as $rm) {\n                if ($type === 'normal') {\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n                } else {\n                    $rname = $name;\n                    if ($type === 'extention') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . '.' . $name;\n                    } else if ($type === 'prefix') {\n                        $rname = $name . $rm['name'];\n                    } else if ($type === 'suffix') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . $name . ($splits[1] ? ('.' . $splits[1]) : '');\n                    }\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n                }\n                if ($file = $volume->rename($rm['hash'], $rname)) {\n                    $files[] = $file;\n                    $removed[] = $rm;\n                } else {\n                    $errs[] = $rm['name'];\n                }\n            }\n\n            if (!$files) {\n                $res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n                if (!$res['warning']) {\n                    unset($res['warning']);\n                }\n                return $res;\n            }\n            if ($errs) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n            }\n            if (!$res['warning']) {\n                unset($res['warning']);\n            }\n            $res['added'] = $files;\n            $res['removed'] = $removed;\n            return $res;\n        } else {\n            if (!($rm = $volume->file($target))) {\n                return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n            }\n            if ($this->itemLocked($target)) {\n                return array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n            }\n            $rm['realpath'] = $volume->realpath($target);\n\n            $file = $volume->rename($target, $name);\n            if ($file === false) {\n                return array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()));\n            } else {\n                if ($file['hash'] !== $rm['hash']) {\n                    return array('added' => array($file), 'removed' => array($rm));\n                } else {\n                    return array('changed' => array($file));\n                }\n            }\n        }\n    }\n\n    /**\n     * Duplicate file - create copy with \"copy %d\" suffix\n     *\n     * @param array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function duplicate($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array();\n        $suffix = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\n        $this->itemLock($targets);\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false\n                || ($src = $volume->file($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_COPY, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if (($file = $volume->duplicate($target, $suffix)) == false) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Remove dirs/files\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function rm($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array('removed' => array());\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_RM, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if ($this->itemLocked($target)) {\n                $rm = $volume->file($target);\n                $result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n                break;\n            }\n\n            if (!$volume->rm($target)) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry Naoki Sawada\n     **/\n    protected function subdirs($args)\n    {\n\n        $result = array('subdirs' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            if (($volume = $this->volume($target)) !== false) {\n                $result['subdirs'][$target] = $volume->subdirs($target) ? 1 : 0;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Gateway for custom contents editor\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function editor($args = array())\n    {\n        /* @var elFinderEditor $editor */\n        $name = $args['name'];\n        if (is_array($name)) {\n            $res = array();\n            foreach ($name as $c) {\n                $class = 'elFinderEditor' . $c;\n                if (class_exists($class)) {\n                    $editor = new $class($this, $args['args']);\n                    $res[$c] = $editor->enabled();\n                } else {\n                    $res[$c] = 0;\n                }\n            }\n            return $res;\n        } else {\n            $class = 'elFinderEditor' . $name;\n            $method = '';\n            if (class_exists($class)) {\n                $editor = new $class($this, $args['args']);\n                $method = $args['method'];\n                if ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n                    return $editor->$method();\n                }\n            }\n            return array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.' . $name . '.' . $method));\n        }\n    }\n\n    /**\n     * Abort current request and make flag file to running check\n     *\n     * @param array $args\n     *\n     * @return void\n     */\n    protected function abort($args = array())\n    {\n        if (!elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n            return;\n        }\n        $flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n        if (!empty($args['makeFile'])) {\n            self::$abortCheckFile = sprintf($flagFile, self::filenameDecontaminate($args['makeFile']));\n            touch(self::$abortCheckFile);\n            $GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n            return;\n        }\n\n        $file = !empty($args['id']) ? sprintf($flagFile, self::filenameDecontaminate($args['id'])) : self::$abortCheckFile;\n        $file && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Validate an URL to prevent SSRF attacks.\n     *\n     * To prevent any risk of DNS rebinding, always use the IP address resolved by\n     * this method, as returned in the array entry `ip`.\n     *\n     * @param string $url\n     *\n     * @return false|array\n     */\n    protected function validate_address($url)\n    {\n        $info = parse_url($url);\n        $host = trim(strtolower($info['host']), '.');\n        // do not support IPv6 address\n        if (preg_match('/^\\[.*\\]$/', $host)) {\n            return false;\n        }\n        // do not support non dot host\n        if (strpos($host, '.') === false) {\n            return false;\n        }\n        // do not support URL-encoded host\n        if (strpos($host, '%') !== false) {\n            return false;\n        }\n        // disallow including \"localhost\" and \"localdomain\"\n        if (preg_match('/\\b(?:localhost|localdomain)\\b/', $host)) {\n            return false;\n        }\n        // check IPv4 local loopback, private network and link local\n        $ip = gethostbyname($host);\n        if (preg_match('/^0x[0-9a-f]+|[0-9]+(?:\\.(?:0x[0-9a-f]+|[0-9]+)){1,3}$/', $ip, $m)) {\n            $long = (int)sprintf('%u', ip2long($ip));\n            if (!$long) {\n                return false;\n            }\n            $local = (int)sprintf('%u', ip2long('127.255.255.255')) >> 24;\n            $prv1  = (int)sprintf('%u', ip2long('10.255.255.255')) >> 24;\n            $prv2  = (int)sprintf('%u', ip2long('172.31.255.255')) >> 20;\n            $prv3  = (int)sprintf('%u', ip2long('192.168.255.255')) >> 16;\n            $link  = (int)sprintf('%u', ip2long('169.254.255.255')) >> 16;\n\n            if (!isset($this->uploadAllowedLanIpClasses['local']) && $long >> 24 === $local) {\n                return false;\n            }\n            if (!isset($this->uploadAllowedLanIpClasses['private_a']) && $long >> 24 === $prv1) {\n                return false;\n            }\n            if (!isset($this->uploadAllowedLanIpClasses['private_b']) && $long >> 20 === $prv2) {\n                return false;\n            }\n            if (!isset($this->uploadAllowedLanIpClasses['private_c']) && $long >> 16 === $prv3) {\n                return false;\n            }\n            if (!isset($this->uploadAllowedLanIpClasses['link']) && $long >> 16 === $link) {\n                return false;\n            }\n            $info['ip'] = long2ip($long);\n            if (!isset($info['port'])) {\n                $info['port'] = $info['scheme'] === 'https' ? 443 : 80;\n            }\n            if (!isset($info['path'])) {\n                $info['path'] = '/';\n            }\n            return $info;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Get remote contents\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $fp\n     *\n     * @return string, resource or bool(false)\n     * @retval  string contents\n     * @retval  resource conttents\n     * @rettval false  error\n     * @author  Naoki Sawada\n     **/\n    protected function get_remote_contents(&$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null)\n    {\n        if (preg_match('~^(?:ht|f)tps?://[-_.!\\~*\\'()a-z0-9;/?:\\@&=+\\$,%#\\*\\[\\]]+~i', $url)) {\n            $info = $this->validate_address($url);\n            if ($info === false) {\n                return false;\n            }\n            // dose not support 'user' and 'pass' for security reasons\n            $url = $info['scheme'].'://'.$info['host'].(!empty($info['port'])? (':'.$info['port']) : '').$info['path'].(!empty($info['query'])? ('?'.$info['query']) : '').(!empty($info['fragment'])? ('#'.$info['fragment']) : '');\n            // check by URL upload filter\n            if ($this->urlUploadFilter && is_callable($this->urlUploadFilter)) {\n                if (!call_user_func_array($this->urlUploadFilter, array($url, $this))) {\n                    return false;\n                }\n            }\n            $method = (function_exists('curl_exec')) ? 'curl_get_contents' : 'fsock_get_contents';\n            return $this->$method($url, $timeout, $redirect_max, $ua, $fp, $info);\n        }\n        return false;\n    }\n\n    /**\n     * Get remote contents with cURL\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @author Naoki Sawada\n     **/\n    protected function curl_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp, $info)\n    {\n        if ($redirect_max == 0) {\n            return false;\n        }\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        if ($outfp) {\n            curl_setopt($ch, CURLOPT_FILE, $outfp);\n        } else {\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n        }\n        curl_setopt($ch, CURLOPT_LOW_SPEED_LIMIT, 1);\n        curl_setopt($ch, CURLOPT_LOW_SPEED_TIME, $timeout);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false);\n        curl_setopt($ch, CURLOPT_USERAGENT, $ua);\n        curl_setopt($ch, CURLOPT_RESOLVE, [$info['host'] . ':' . $info['port'] . ':' . $info['ip']]);\n        $result = curl_exec($ch);\n        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if ($http_code == 301 || $http_code == 302) {\n            $new_url = curl_getinfo($ch, CURLINFO_REDIRECT_URL);\n            $info = $this->validate_address($new_url);\n            if ($info === false) {\n                return false;\n            }\n            return $this->curl_get_contents($new_url, $timeout, $redirect_max - 1, $ua, $outfp, $info);\n        }\n        curl_close($ch);\n        return $outfp ? $outfp : $result;\n    }\n\n    /**\n     * Get remote contents with fsockopen()\n     *\n     * @param  string   $url          url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function fsock_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp, $info)\n    {\n        $connect_timeout = 3;\n        $connect_try = 3;\n        $method = 'GET';\n        $readsize = 4096;\n        $ssl = '';\n\n        $getSize = null;\n        $headers = '';\n\n        $arr = $info;\n        if ($arr['scheme'] === 'https') {\n            $ssl = 'ssl://';\n        }\n\n        // query\n        $arr['query'] = isset($arr['query']) ? '?' . $arr['query'] : '';\n\n        $url_base = $arr['scheme'] . '://' . $info['host'] . ':' . $info['port'];\n        $url_path = isset($arr['path']) ? $arr['path'] : '/';\n        $uri = $url_path . $arr['query'];\n\n        $query = $method . ' ' . $uri . \" HTTP/1.0\\r\\n\";\n        $query .= \"Host: \" . $arr['host'] . \"\\r\\n\";\n        $query .= \"Accept: */*\\r\\n\";\n        $query .= \"Connection: close\\r\\n\";\n        if (!empty($ua)) $query .= \"User-Agent: \" . $ua . \"\\r\\n\";\n        if (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\n        $query .= $headers;\n\n        $query .= \"\\r\\n\";\n\n        $fp = $connect_try_count = 0;\n        while (!$fp && $connect_try_count < $connect_try) {\n\n            $errno = 0;\n            $errstr = \"\";\n            $fp = fsockopen(\n                $ssl . $arr['host'],\n                $arr['port'],\n                $errno, $errstr, $connect_timeout);\n            if ($fp) break;\n            $connect_try_count++;\n            if (connection_aborted()) {\n                throw new elFinderAbortException();\n            }\n            sleep(1); // wait 1sec\n        }\n\n        if (!$fp) {\n            return false;\n        }\n\n        $fwrite = 0;\n        for ($written = 0; $written < strlen($query); $written += $fwrite) {\n            $fwrite = fwrite($fp, substr($query, $written));\n            if (!$fwrite) {\n                break;\n            }\n        }\n\n        if ($timeout) {\n            socket_set_timeout($fp, $timeout);\n        }\n\n        $_response = '';\n        $header = '';\n        while ($_response !== \"\\r\\n\") {\n            $_response = fgets($fp, $readsize);\n            $header .= $_response;\n        };\n\n        $rccd = array_pad(explode(' ', $header, 2), 2, ''); // array('HTTP/1.1','200')\n        $rc = (int)$rccd[1];\n\n        $ret = false;\n        // Redirect\n        switch ($rc) {\n            case 307: // Temporary Redirect\n            case 303: // See Other\n            case 302: // Moved Temporarily\n            case 301: // Moved Permanently\n                $matches = array();\n                if (preg_match('/^Location: (.+?)(#.+)?$/im', $header, $matches) && --$redirect_max > 0) {\n                    $_url = $url;\n                    $url = trim($matches[1]);\n                    if (!preg_match('/^https?:\\//', $url)) { // no scheme\n                        if ($url[0] != '/') { // Relative path\n                            // to Absolute path\n                            $url = substr($url_path, 0, strrpos($url_path, '/')) . '/' . $url;\n                        }\n                        // add sheme,host\n                        $url = $url_base . $url;\n                    }\n                    if ($_url === $url) {\n                        sleep(1);\n                    }\n                    fclose($fp);\n                    $info = $this->validate_address($url);\n                    if ($info === false) {\n                        return false;\n                    }\n                    return $this->fsock_get_contents($url, $timeout, $redirect_max, $ua, $outfp, $info);\n                }\n                break;\n            case 200:\n                $ret = true;\n        }\n        if (!$ret) {\n            fclose($fp);\n            return false;\n        }\n\n        $body = '';\n        if (!$outfp) {\n            $outfp = fopen('php://temp', 'rwb');\n            $body = true;\n        }\n        while (fwrite($outfp, fread($fp, $readsize))) {\n            if ($timeout) {\n                $_status = socket_get_status($fp);\n                if ($_status['timed_out']) {\n                    fclose($outfp);\n                    fclose($fp);\n                    return false; // Request Time-out\n                }\n            }\n        }\n        if ($body) {\n            rewind($outfp);\n            $body = stream_get_contents($outfp);\n            fclose($outfp);\n            $outfp = null;\n        }\n\n        fclose($fp);\n\n        return $outfp ? $outfp : $body; // Data\n    }\n\n    /**\n     * Parse Data URI scheme\n     *\n     * @param  string $str\n     * @param  array  $extTable\n     * @param  array  $args\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function parse_data_scheme($str, $extTable, $args = null)\n    {\n        $data = $name = $mime = '';\n        // Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n        if ($fp = fopen('data://' . substr($str, 5), 'rb')) {\n            if ($data = stream_get_contents($fp)) {\n                $meta = stream_get_meta_data($fp);\n                $mime = $meta['mediatype'];\n            }\n            fclose($fp);\n        } else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n            $data = base64_decode(substr($str, strlen($m[0])));\n            if ($m[1]) {\n                $mime = $m[1];\n            }\n        }\n        if ($data) {\n            $ext = ($mime && isset($extTable[$mime])) ? '.' . $extTable[$mime] : '';\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (is_array($args['name']) && isset($args['name'][0])) {\n                $name = $args['name'][0];\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n            } else {\n                $name = substr(md5($data), 0, 8);\n            }\n            $name .= $ext;\n        } else {\n            $data = $name = '';\n        }\n        return array($data, $name);\n    }\n\n    /**\n     * Detect file MIME Type by local path\n     *\n     * @param  string $path Local path\n     *\n     * @return string file MIME Type\n     * @author Naoki Sawada\n     */\n    protected function detectMimeType($path)\n    {\n        static $type, $finfo;\n        if (!$type) {\n            if (class_exists('finfo', false)) {\n                $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n            } else {\n                $tmpFileInfo = false;\n            }\n            $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n            if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $type = 'finfo';\n                $finfo = finfo_open(FILEINFO_MIME);\n            } elseif (function_exists('mime_content_type')\n                && ($_ctypes = explode(';', mime_content_type(__FILE__)))\n                && preg_match($regexp, array_shift($_ctypes))) {\n                $type = 'mime_content_type';\n            } elseif (function_exists('getimagesize')) {\n                $type = 'getimagesize';\n            } else {\n                $type = 'none';\n            }\n        }\n\n        $mime = '';\n        if ($type === 'finfo') {\n            $mime = finfo_file($finfo, $path);\n        } elseif ($type === 'mime_content_type') {\n            $mime = mime_content_type($path);\n        } elseif ($type === 'getimagesize') {\n            if ($img = getimagesize($path)) {\n                $mime = $img['mime'];\n            }\n        }\n\n        if ($mime) {\n            $mime = explode(';', $mime);\n            $mime = trim($mime[0]);\n\n            if (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n                // finfo return this mime for empty files\n                $mime = 'text/plain';\n            } elseif ($mime == 'application/x-zip') {\n                // http://elrte.org/redmine/issues/163\n                $mime = 'application/zip';\n            }\n        }\n\n        return $mime ? $mime : 'unknown';\n    }\n\n    /**\n     * Detect file type extension by local path\n     *\n     * @param  object $volume elFinderVolumeDriver instance\n     * @param  string $path   Local path\n     * @param  string $name   Filename to save\n     *\n     * @return string file type extension with dot\n     * @author Naoki Sawada\n     */\n    protected function detectFileExtension($volume, $path, $name)\n    {\n        $mime = $this->detectMimeType($path);\n        if ($mime === 'unknown') {\n            $mime = 'application/octet-stream';\n        }\n        $ext = $volume->getExtentionByMime($volume->mimeTypeNormalize($mime, $name));\n        return $ext ? ('.' . $ext) : '';\n    }\n\n    /**\n     * Get temporary directory path\n     *\n     * @param  string $volumeTempPath\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    private function getTempDir($volumeTempPath = null)\n    {\n        $testDirs = array();\n        if ($this->uploadTempPath) {\n            $testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n        }\n        if ($volumeTempPath) {\n            $testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n        }\n        if (elFinder::$commonTempPath) {\n            $testDirs[] = elFinder::$commonTempPath;\n        }\n        $tempDir = '';\n        foreach ($testDirs as $testDir) {\n            if (!$testDir || !is_dir($testDir)) continue;\n            if (is_writable($testDir)) {\n                $tempDir = $testDir;\n                $gc = time() - 3600;\n                foreach (glob($tempDir . DIRECTORY_SEPARATOR . 'ELF*') as $cf) {\n                    if (filemtime($cf) < $gc) {\n                        unlink($cf);\n                    }\n                }\n                break;\n            }\n        }\n        return $tempDir;\n    }\n\n    /**\n     * chmod\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author David Bartle\n     */\n    protected function chmod($args)\n    {\n        $targets = $args['targets'];\n        $mode = intval((string)$args['mode'], 8);\n\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        $result = array();\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            $result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n            return $result;\n        }\n\n        $this->itemLock($targets);\n\n        $files = array();\n        $errors = array();\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            $file = $volume->chmod($target, $mode);\n            if ($file) {\n                $files = array_merge($files, is_array($file) ? $file : array($file));\n            } else {\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        if ($files) {\n            $result['changed'] = $files;\n            if ($errors) {\n                $result['warning'] = $this->error($errors);\n            }\n        } else {\n            $result['error'] = $this->error($errors);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check chunked upload files\n     *\n     * @param string $tmpname uploaded temporary file path\n     * @param string $chunk   uploaded chunk file name\n     * @param string $cid     uploaded chunked file id\n     * @param string $tempDir temporary dirctroy path\n     * @param null   $volume\n     *\n     * @return array|null\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    private function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null)\n    {\n        /* @var elFinderVolumeDriver $volume */\n        if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n            $fname = $m[1];\n            $encname = md5($cid . '_' . $fname);\n            $base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n            $clast = intval($m[3]);\n            if (is_null($tmpname)) {\n                ignore_user_abort(true);\n                // chunked file upload fail\n                foreach (glob($base . '*') as $cf) {\n                    unlink($cf);\n                }\n                ignore_user_abort(false);\n                return null;\n            }\n\n            $range = isset($_POST['range']) ? trim($_POST['range']) : '';\n            if ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n                $start = $ranges[1];\n                $len = $ranges[2];\n                $size = $ranges[3];\n                $tmp = $base . '.part';\n                $csize = filesize($tmpname);\n\n                $tmpExists = is_file($tmp);\n                if (!$tmpExists) {\n                    // check upload max size\n                    $uploadMaxSize = $volume ? $volume->getUploadMaxSize() : 0;\n                    if ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n                        return array(self::ERROR_UPLOAD_FILE_SIZE, false);\n                    }\n                    // make temp file\n                    $ok = false;\n                    if ($fp = fopen($tmp, 'wb')) {\n                        flock($fp, LOCK_EX);\n                        $ok = ftruncate($fp, $size);\n                        flock($fp, LOCK_UN);\n                        fclose($fp);\n                        touch($base);\n                    }\n                    if (!$ok) {\n                        unlink($tmp);\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                } else {\n                    // wait until makeing temp file (for anothor session)\n                    $cnt = 1200; // Time limit 120 sec\n                    while (!is_file($base) && --$cnt) {\n                        usleep(100000); // wait 100ms\n                    }\n                    if (!$cnt) {\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                }\n\n                // check size info\n                if ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write chunk data\n                $src = fopen($tmpname, 'rb');\n                $fp = fopen($tmp, 'cb');\n                fseek($fp, $start);\n                $writelen = stream_copy_to_stream($src, $fp, $len);\n                fclose($fp);\n                fclose($src);\n\n                try {\n                    // to check connection is aborted\n                    elFinder::checkAborted();\n                } catch (elFinderAbortException $e) {\n                    unlink($tmpname);\n                    is_file($tmp) && unlink($tmp);\n                    is_file($base) && unlink($base);\n                    throw $e;\n                }\n\n                if ($writelen != $len) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write counts\n                file_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\n                if (filesize($base) >= $clast + 1) {\n                    // Completion\n                    unlink($base);\n                    return array($tmp, $fname);\n                }\n            } else {\n                // old way\n                $part = $base . $m[2];\n                if (move_uploaded_file($tmpname, $part)) {\n                    chmod($part, 0600);\n                    if ($clast < count(glob($base . '*'))) {\n                        $parts = array();\n                        for ($i = 0; $i <= $clast; $i++) {\n                            $name = $base . '.' . $i . '_' . $clast;\n                            if (is_readable($name)) {\n                                $parts[] = $name;\n                            } else {\n                                $parts = null;\n                                break;\n                            }\n                        }\n                        if ($parts) {\n                            if (!is_file($base)) {\n                                touch($base);\n                                if ($resfile = tempnam($tempDir, 'ELF')) {\n                                    $target = fopen($resfile, 'wb');\n                                    foreach ($parts as $f) {\n                                        $fp = fopen($f, 'rb');\n                                        while (!feof($fp)) {\n                                            fwrite($target, fread($fp, 8192));\n                                        }\n                                        fclose($fp);\n                                        unlink($f);\n                                    }\n                                    fclose($target);\n                                    unlink($base);\n                                    return array($resfile, $fname);\n                                }\n                                unlink($base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return array('', '');\n    }\n\n    /**\n     * Save uploaded files\n     *\n     * @param  array\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function upload($args)\n    {\n        $ngReg = '/[\\/\\\\?*:|\"<>]/';\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $files = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n        $header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n        $result = array_merge(array('added' => array()), $header);\n        $paths = $args['upload_path'] ? $args['upload_path'] : array();\n        $chunk = $args['chunk'] ? $args['chunk'] : '';\n        $cid = $args['cid'] ? (int)$args['cid'] : '';\n        $mtimes = $args['mtime'] ? $args['mtime'] : array();\n        $tmpfname = '';\n\n        if (!$volume) {\n            return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target)), $header);\n        }\n\n        // check $chunk\n        if (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n            return array('error' => $this->error(self::ERROR_UPLOAD));\n        }\n\n        if ($args['overwrite'] !== '') {\n            $volume->setUploadOverwrite($args['overwrite']);\n        }\n\n        $renames = $hashes = array();\n        $suffix = '~';\n        if ($args['renames'] && is_array($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match($ngReg, $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if ($args['hashes'] && is_array($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        $this->itemLock($target);\n\n        // file extentions table by MIME\n        $extTable = array_flip(array_unique($volume->getMimeTable()));\n\n        if (empty($files)) {\n            if (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n                $names = array();\n                foreach ($args['upload'] as $i => $url) {\n                    // check chunked file upload commit\n                    if ($chunk) {\n                        if ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n                            $this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n                            if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n                                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TEMP);\n                            }\n                            return $result;\n                        } else {\n                            $tmpfname = $tempDir . '/' . $chunk;\n                            $files['tmp_name'][$i] = $tmpfname;\n                            $files['name'][$i] = $url;\n                            $files['error'][$i] = 0;\n                            $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                            break;\n                        }\n                    }\n\n                    $tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url . microtime(true));\n                    $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\n                    $_name = '';\n                    // check is data:\n                    if (substr($url, 0, 5) === 'data:') {\n                        list($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n                    } else {\n                        $fp = fopen($tmpfname, 'wb');\n                        if ($data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp)) {\n                            // to check connection is aborted\n                            try {\n                                elFinder::checkAborted();\n                            } catch(elFinderAbortException $e) {\n                                fclose($fp);\n                                throw $e;\n                            }\n                            $_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n                            // Check `Content-Disposition` response header\n                            if (($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n                                if (preg_match('/filename\\*=(?:([a-zA-Z0-9_-]+?)\\'\\')\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[2]);\n                                    if ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n                                        $_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n                                    }\n                                } else if (preg_match('/filename=\"?([ a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[1]);\n                                }\n                            }\n                        } else {\n                            fclose($fp);\n                        }\n                    }\n                    if ($data) {\n                        if (isset($args['name'][$i])) {\n                            $_name = $args['name'][$i];\n                        }\n                        if ($_name) {\n                            $_ext = '';\n                            if (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n                                $_ext = $_match[1];\n                            }\n                            if ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n                                $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                                $_name = preg_replace($ngReg, '_', $_name);\n                                list($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n                                if ($_b === '') {\n                                    if ($_ext) {\n                                        rename($tmpfname, $tmpfname . $_ext);\n                                        $tmpfname = $tmpfname . $_ext;\n                                    }\n                                    $_b = $this->detectFileExtension($volume, $tmpfname, $_name);\n                                    $_name = $_a . $_b;\n                                } else {\n                                    $_b = '.' . $_b;\n                                }\n                                if (isset($names[$_name])) {\n                                    $_name = $_a . '_' . $names[$_name]++ . $_b;\n                                } else {\n                                    $names[$_name] = 1;\n                                }\n                                $files['tmp_name'][$i] = $tmpfname;\n                                $files['name'][$i] = $_name;\n                                $files['error'][$i] = 0;\n                                // set to auto rename\n                                $volume->setUploadOverwrite(false);\n                            } else {\n                                unlink($tmpfname);\n                            }\n                        }\n                    }\n                }\n            }\n            if (empty($files)) {\n                return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n            }\n        }\n\n        $addedDirs = array();\n        $errors = array();\n        foreach ($files['name'] as $i => $name) {\n            if (($error = $files['error'][$i]) > 0) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER, $error);\n                $this->uploadDebug = 'Upload error code: ' . $error;\n                break;\n            }\n\n            $tmpname = $files['tmp_name'][$i];\n            $thash = ($paths && isset($paths[$i])) ? $paths[$i] : $target;\n            $mtime = isset($mtimes[$i]) ? $mtimes[$i] : 0;\n            if ($name === 'blob') {\n                if ($chunk) {\n                    if ($tempDir = $this->getTempDir($volume->getTempPath())) {\n                        list($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n                        if ($tmpname) {\n                            if ($name === false) {\n                                preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n                                $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n                                $result['_chunkfailure'] = true;\n                                $this->uploadDebug = 'Upload error: ' . $tmpname;\n                            } else if ($name) {\n                                $result['_chunkmerged'] = basename($tmpname);\n                                $result['_name'] = $name;\n                                $result['_mtime'] = $mtime;\n                            }\n                        }\n                    } else {\n                        $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TEMP);\n                        $this->uploadDebug = 'Upload error: unable open tmp file';\n                    }\n                    return $result;\n                } else {\n                    // for form clipboard with Google Chrome or Opera\n                    $name = 'image.png';\n                }\n            }\n\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n                $type = $files['type'][$i];\n                $name = $args['name'][$i];\n                $ext = isset($extTable[$type]) ? '.' . $extTable[$type] : '';\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n                $name .= $ext;\n            }\n\n            // do hook function 'upload.presave'\n            try {\n                $this->trigger('upload.presave', array(&$thash, &$name, $tmpname, $this, $volume), $errors);\n            } catch (elFinderTriggerException $e) {\n                if (!is_uploaded_file($tmpname) && unlink($tmpname) && $tmpfname) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                }\n                continue;\n            }\n\n            clearstatcache();\n            if ($mtime && is_file($tmpname)) {\n                // for keep timestamp option in the LocalFileSystem volume\n                touch($tmpname, $mtime);\n            }\n\n            $fp = null;\n            if (!is_file($tmpname) || ($fp = fopen($tmpname, 'rb')) === false) {\n                $errors = array_merge($errors, array(self::ERROR_UPLOAD_FILE, $name, ($fp === false? self::ERROR_UPLOAD_TEMP : self::ERROR_UPLOAD_TRANSFER)));\n                $this->uploadDebug = 'Upload error: unable open tmp file';\n                if (!is_uploaded_file($tmpname)) {\n                    if (unlink($tmpname) && $tmpfname) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                    continue;\n                }\n                break;\n            }\n            $rnres = array();\n            if ($thash !== '' && $thash !== $target) {\n                if ($dir = $volume->dir($thash)) {\n                    $_target = $thash;\n                    if (!isset($addedDirs[$thash])) {\n                        $addedDirs[$thash] = true;\n                        $result['added'][] = $dir;\n                        // to support multi-level directory creation\n                        $_phash = isset($dir['phash']) ? $dir['phash'] : null;\n                        while ($_phash && !isset($addedDirs[$_phash]) && $_phash !== $target) {\n                            if ($_dir = $volume->dir($_phash)) {\n                                $addedDirs[$_phash] = true;\n                                $result['added'][] = $_dir;\n                                $_phash = isset($_dir['phash']) ? $_dir['phash'] : null;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    $result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@' . $thash);\n                    break;\n                }\n            } else {\n                $_target = $target;\n                // file rename for backup\n                if (isset($renames[$name])) {\n                    $dir = $volume->realpath($_target);\n                    if (isset($hashes[$name])) {\n                        $hash = $hashes[$name];\n                    } else {\n                        $hash = $volume->getHash($dir, $name);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = $rnres['error'];\n                        if (!is_array($rnres['error'])) {\n                            $errors = array_push($errors, $rnres['error']);\n                        } else {\n                            $errors = array_merge($errors, $rnres['error']);\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (!$_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, ($_target === $target) ? $hashes : array())) === false) {\n                $errors = array_merge($errors, $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error()));\n                fclose($fp);\n                if (!is_uploaded_file($tmpname) && unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n                continue;\n            }\n\n            is_resource($fp) && fclose($fp);\n            if (!is_uploaded_file($tmpname)) {\n                clearstatcache();\n                if (!is_file($tmpname) || unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n            }\n            $result['added'][] = $file;\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n\n        if ($GLOBALS['elFinderTempFiles']) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n                is_file($_temp) && is_writable($_temp) && unlink($_temp);\n            }\n        }\n        $result['removed'] = $volume->removed();\n\n        if (!empty($args['node'])) {\n            $result['callback'] = array(\n                'node' => $args['node'],\n                'bind' => 'upload'\n            );\n        }\n        return $result;\n    }\n\n    /**\n     * Copy/move files into new destination\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function paste($args)\n    {\n        $dst = $args['dst'];\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $cut = !empty($args['cut']);\n        $error = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n        $result = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\n        if (($dstVolume = $this->volume($dst)) == false) {\n            return array('error' => $this->error($error, '#' . $targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#' . $dst));\n        }\n\n        $this->itemLock($dst);\n\n        $hashes = $renames = array();\n        $suffix = '~';\n        if (!empty($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if (!empty($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($srcVolume = $this->volume($target)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n                continue;\n            }\n\n            $rnres = array();\n            if ($renames) {\n                $file = $srcVolume->file($target);\n                if (isset($renames[$file['name']])) {\n                    $dir = $dstVolume->realpath($dst);\n                    $dstName = $file['name'];\n                    if ($srcVolume !== $dstVolume) {\n                        $errors = array();\n                        try {\n                            $this->trigger('paste.copyfrom', array(&$dst, &$dstName, '', $this, $dstVolume), $errors);\n                        } catch (elFinderTriggerException $e) {\n                            $result['warning'] = array_merge($result['warning'], $errors);\n                            continue;\n                        }\n                    }\n                    if (isset($hashes[$file['name']])) {\n                        $hash = $hashes[$file['name']];\n                    } else {\n                        $hash = $dstVolume->getHash($dir, $dstName);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $dstName, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = array_merge($result['warning'], $rnres['error']);\n                        continue;\n                    }\n                }\n            }\n\n            if ($cut && $this->itemLocked($target)) {\n                $rm = $srcVolume->file($target);\n                $result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n                continue;\n            }\n\n            if (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n                continue;\n            }\n\n            if ($error = $dstVolume->error()) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error));\n            }\n\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n        if (count($result['warning']) < 1) {\n            unset($result['warning']);\n        } else {\n            $result['sync'] = true;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return file content\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function get($args)\n    {\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $enc = false;\n\n        if (!$volume || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($volume->commandDisabled('get')) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_ACCESS_DENIED));\n        }\n\n        if (($content = $volume->getContents($target)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n        }\n\n        $mime = isset($file['mime']) ? $file['mime'] : '';\n        if ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n            $enc = '';\n            if ($content !== '') {\n                if (!$args['conv'] || $args['conv'] == '1') {\n                    // detect encoding\n                    if (function_exists('mb_detect_encoding')) {\n                        if ($enc = mb_detect_encoding($content, mb_detect_order(), true)) {\n                            $encu = strtoupper($enc);\n                            if ($encu === 'UTF-8' || $encu === 'ASCII') {\n                                $enc = '';\n                            }\n                        } else {\n                            $enc = 'unknown';\n                        }\n                    } else if (!preg_match('//u', $content)) {\n                        $enc = 'unknown';\n                    }\n                    if ($enc === 'unknown') {\n                        $enc = $volume->getOption('encoding');\n                        if (!$enc || strtoupper($enc) === 'UTF-8') {\n                            $enc = 'unknown';\n                        }\n                    }\n                    // call callbacks 'get.detectencoding'\n                    if (!empty($this->listeners['get.detectencoding'])) {\n                        foreach ($this->listeners['get.detectencoding'] as $handler) {\n                            call_user_func_array($handler, array('get', &$enc, array_merge($args, array('content' => $content)), $this, $volume));\n                        }\n                    }\n                    if ($enc && $enc !== 'unknown') {\n                        $errlev = error_reporting();\n                        error_reporting($errlev ^ E_NOTICE);\n                        $utf8 = iconv($enc, 'UTF-8', $content);\n                        if ($utf8 === false && function_exists('mb_convert_encoding')) {\n                            error_reporting($errlev ^ E_WARNING);\n                            $utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n                            if (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n                                $enc = 'unknown';\n                            }\n                        } else {\n                            if ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n                                $enc = 'unknown';\n                            }\n                        }\n                        error_reporting($errlev);\n                        if ($enc !== 'unknown') {\n                            $content = $utf8;\n                        }\n                    }\n                    if ($enc) {\n                        if ($args['conv'] == '1') {\n                            $args['conv'] = '';\n                            if ($enc === 'unknown') {\n                                $content = false;\n                            }\n                        } else if ($enc === 'unknown') {\n                            return array('doconv' => $enc);\n                        }\n                    }\n                    if ($args['conv'] == '1') {\n                        $args['conv'] = '';\n                    }\n                }\n                if ($args['conv']) {\n                    $enc = $args['conv'];\n                    if (strtoupper($enc) !== 'UTF-8') {\n                        $_content = $content;\n                        $errlev = error_reporting();\n                        $this->setToastErrorHandler(array(\n                            'prefix' => 'Notice: '\n                        ));\n                        error_reporting($errlev | E_NOTICE | E_WARNING);\n                        $content = iconv($enc, 'UTF-8//TRANSLIT', $content);\n                        if ($content === false && function_exists('mb_convert_encoding')) {\n                            $content = mb_convert_encoding($_content, 'UTF-8', $enc);\n                        }\n                        error_reporting($errlev);\n                        $this->setToastErrorHandler(false);\n                    } else {\n                        $enc = '';\n                    }\n                }\n            }\n        } else {\n            $content = 'data:' . ($mime ? $mime : 'application/octet-stream') . ';base64,' . base64_encode($content);\n        }\n\n        if ($enc !== false) {\n            $json = false;\n            if ($content !== false) {\n                $json = json_encode($content);\n            }\n            if ($content === false || $json === false || strlen($json) < strlen($content)) {\n                return array('doconv' => 'unknown');\n            }\n        }\n\n        $res = array(\n            'header' => array(\n                'Content-Type: application/json'\n            ),\n            'content' => $content\n        );\n\n        // add cache control headers\n        if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n            $res['header'] = array_merge($res['header'], $cacheHeaders);\n        }\n\n        if ($enc) {\n            $res['encoding'] = $enc;\n        }\n        return $res;\n    }\n\n    /**\n     * Save content into text file\n     *\n     * @param $args\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function put($args)\n    {\n        $target = $args['target'];\n        $encoding = isset($args['encoding']) ? $args['encoding'] : '';\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $this->itemLock($target);\n\n        if ($encoding === 'scheme') {\n            if (preg_match('~^https?://~i', $args['content'])) {\n                /** @var resource $fp */\n                $fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n                if (!$fp) {\n                    return array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n                }\n                $fmeta = stream_get_meta_data($fp);\n                $mime = $this->detectMimeType($fmeta['uri']);\n                if ($mime === 'unknown') {\n                    $mime = 'application/octet-stream';\n                }\n                $mime = $volume->mimeTypeNormalize($mime, $file['name']);\n                $args['content'] = 'data:' . $mime . ';base64,' . base64_encode(file_get_contents($fmeta['uri']));\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        } else if ($encoding === 'hash') {\n            $_hash = $args['content'];\n            if ($_src = $this->getVolume($_hash)) {\n                if ($_file = $_src->file($_hash)) {\n                    if ($_data = $_src->getContents($_hash)) {\n                        $args['content'] = 'data:' . $file['mime'] . ';base64,' . base64_encode($_data);\n                    }\n                }\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        }\n        if ($encoding) {\n            $content = iconv('UTF-8', $encoding, $args['content']);\n            if ($content === false && function_exists('mb_detect_encoding')) {\n                $content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n            }\n            if ($content !== false) {\n                $args['content'] = $content;\n            }\n        }\n        if (($file = $volume->putContents($target, $args['content'])) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n        }\n\n        return array('changed' => array($file));\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    protected function extract($args)\n    {\n        $target = $args['target'];\n        $makedir = isset($args['makedir']) ? (bool)$args['makedir'] : null;\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_EXTRACT, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $res = array();\n        if ($file = $volume->extract($target, $makedir)) {\n            $res['added'] = isset($file['read']) ? array($file) : $file;\n            if ($err = $volume->error()) {\n                $res['warning'] = $err;\n            }\n        } else {\n            $res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n        }\n        return $res;\n    }\n\n    /**\n     * Create archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function archive($args)\n    {\n        $targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n        $name = isset($args['name']) ? $args['name'] : '';\n\n        $targets = array_filter($targets, array($this, 'volume'));\n        if (!$targets || ($volume = $this->volume($targets[0])) === false) {\n            return $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n        }\n\n        foreach ($targets as $target) {\n            $this->itemLock($target);\n        }\n\n        return ($file = $volume->archive($targets, $args['type'], $name))\n            ? array('added' => array($file))\n            : array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function search($args)\n    {\n        $q = trim($args['q']);\n        $mimes = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n        $target = !empty($args['target']) ? $args['target'] : null;\n        $type = !empty($args['type']) ? $args['type'] : null;\n        $result = array();\n        $errors = array();\n\n        if ($target) {\n            if ($volume = $this->volume($target)) {\n                $result = $volume->search($q, $mimes, $target, $type);\n                $errors = array_merge($errors, $volume->error());\n            }\n        } else {\n            foreach ($this->volumes as $volume) {\n                $result = array_merge($result, $volume->search($q, $mimes, null, $type));\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        $result = array('files' => $result);\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n        return $result;\n    }\n\n    /**\n     * Return file info (used by client \"places\" ui)\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function info($args)\n    {\n        $files = array();\n        $compare = null;\n        // long polling mode\n        if ($args['compare'] && count($args['targets']) === 1) {\n            $compare = intval($args['compare']);\n            $hash = $args['targets'][0];\n            if ($volume = $this->volume($hash)) {\n                $standby = (int)$volume->getOption('plStandby');\n                $_compare = false;\n                if (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n                    $_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n                }\n                if ($_compare !== false) {\n                    $compare = $_compare;\n                } else {\n                    $sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n                    $limit = max(1, $standby / $sleep) + 1;\n                    do {\n                        elFinder::extendTimeLimit(30 + $sleep);\n                        $volume->clearstatcache();\n                        if (($info = $volume->file($hash)) != false) {\n                            if ($info['ts'] != $compare) {\n                                $compare = $info['ts'];\n                                break;\n                            }\n                        } else {\n                            $compare = 0;\n                            break;\n                        }\n                        if (--$limit) {\n                            sleep($sleep);\n                        }\n                    } while ($limit);\n                }\n            }\n        } else {\n            foreach ($args['targets'] as $hash) {\n                elFinder::checkAborted();\n                if (($volume = $this->volume($hash)) != false\n                    && ($info = $volume->file($hash)) != false) {\n                    $info['path'] = $volume->path($hash);\n                    $files[] = $info;\n                }\n            }\n        }\n\n        $result = array('files' => $files);\n        if (!is_null($compare)) {\n            $result['compare'] = strval($compare);\n        }\n        return $result;\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function dim($args)\n    {\n        $res = array();\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) != false) {\n            if ($dim = $volume->dimensions($target, $args)) {\n                if (is_array($dim) && isset($dim['dim'])) {\n                    $res = $dim;\n                } else {\n                    $res = array('dim' => $dim);\n                    if ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n                        $res['url'] = $subImgLink;\n                    }\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function resize($args)\n    {\n        $target = $args['target'];\n        $width = (int)$args['width'];\n        $height = (int)$args['height'];\n        $x = (int)$args['x'];\n        $y = (int)$args['y'];\n        $mode = $args['mode'];\n        $bg = $args['bg'];\n        $degree = (int)$args['degree'];\n        $quality = (int)$args['quality'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_RESIZE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n            return array('error' => $this->error(self::ERROR_RESIZESIZE));\n        }\n        return ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n            ? (!empty($file['losslessRotate']) ? $file : array('changed' => array($file)))\n            : array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n    }\n\n    /**\n     * Return content URL\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function url($args)\n    {\n        $target = $args['target'];\n        $options = isset($args['options']) ? $args['options'] : array();\n        if (($volume = $this->volume($target)) != false) {\n            if (!$volume->commandDisabled('url')) {\n                $url = $volume->getContentUrl($target, $options);\n                return $url ? array('url' => $url) : array();\n            }\n        }\n        return array();\n    }\n\n    /**\n     * Output callback result with JavaScript that control elFinder\n     * or HTTP redirect to callbackWindowURL\n     *\n     * @param  array  command arguments\n     *\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function callback($args)\n    {\n        $checkReg = '/[^a-zA-Z0-9;._-]/';\n        $node = (isset($args['node']) && !preg_match($checkReg, $args['node'])) ? $args['node'] : '';\n        $json = (isset($args['json']) && json_decode($args['json'])) ? $args['json'] : '{}';\n        $bind = (isset($args['bind']) && !preg_match($checkReg, $args['bind'])) ? $args['bind'] : '';\n        $done = (!empty($args['done']));\n\n        while (ob_get_level()) {\n            if (!ob_end_clean()) {\n                break;\n            }\n        }\n\n        if ($done || !$this->callbackWindowURL) {\n            $script = '';\n            if ($node) {\n                if ($bind) {\n                    $trigger = 'elf.trigger(\\'' . $bind . '\\', data);';\n                    $triggerdone = 'elf.trigger(\\'' . $bind . 'done\\');';\n                    $triggerfail = 'elf.trigger(\\'' . $bind . 'fail\\', data);';\n                } else {\n                    $trigger = $triggerdone = $triggerfail = '';\n                }\n                $origin = isset($_SERVER['HTTP_ORIGIN'])? str_replace('\\'', '\\\\\\'', $_SERVER['HTTP_ORIGIN']) : '*';\n                $script .= '\nvar go = function() {\n    var w = window.opener || window.parent || window,\n        close = function(){\n            window.open(\"about:blank\",\"_self\").close();\n            return false;\n        };\n    try {\n        var elf = w.document.getElementById(\\'' . $node . '\\').elfinder;\n        if (elf) {\n            var data = ' . $json . ';\n            if (data.error) {\n                ' . $triggerfail . '\n                elf.error(data.error);\n            } else {\n                data.warning && elf.error(data.warning);\n                data.removed && data.removed.length && elf.remove(data);\n                data.added   && data.added.length   && elf.add(data);\n                data.changed && data.changed.length && elf.change(data);\n                ' . $trigger . '\n                ' . $triggerdone . '\n                data.sync && elf.sync();\n            }\n        }\n    } catch(e) {\n        // for CORS\n        w.postMessage && w.postMessage(JSON.stringify({bind:\\'' . $bind . '\\',data:' . $json . '}), \\'' . $origin . '\\');\n    }\n    close();\n    setTimeout(function() {\n        var msg = document.getElementById(\\'msg\\');\n        msg.style.display = \\'inline\\';\n        msg.onclick = close;\n    }, 100);\n};\n';\n            }\n\n            $out = '<!DOCTYPE html><html lang=\"en\"><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=2\"><script>' . $script . '</script></head><body><h2 id=\"msg\" style=\"display:none;\"><a href=\"#\">Please close this tab.</a></h2><script>go();</script></body></html>';\n\n            header('Content-Type: text/html; charset=utf-8');\n            header('Content-Length: ' . strlen($out));\n            header('Cache-Control: private');\n            header('Pragma: no-cache');\n\n            echo $out;\n\n        } else {\n            $url = $this->callbackWindowURL;\n            $url .= ((strpos($url, '?') === false) ? '?' : '&')\n                . '&node=' . rawurlencode($node)\n                . (($json !== '{}') ? ('&json=' . rawurlencode($json)) : '')\n                . ($bind ? ('&bind=' . rawurlencode($bind)) : '')\n                . '&done=1';\n\n            header('Location: ' . $url);\n\n        }\n        throw new elFinderAbortException();\n    }\n\n    /**\n     * Error handler for send toast message to client side\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    protected function toastErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        $proc = false;\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n        $toast = array();\n        $toast['mode'] = $this->toastParams['mode'];\n        $toast['msg'] = $this->toastParams['prefix'] . $errstr;\n        $this->toastMessages[] = $toast;\n        return true;\n    }\n\n    /**\n     * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    public static function phpErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        static $base = null;\n\n        $proc = false;\n\n        if (is_null($base)) {\n            $base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n        }\n\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n\n        $errfile = str_replace($base, '', $errfile);\n\n        switch ($errno) {\n            case E_WARNING:\n            case E_USER_WARNING:\n                elFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_NOTICE:\n            case E_USER_NOTICE:\n                elFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_STRICT:\n                elFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_RECOVERABLE_ERROR:\n                elFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n        }\n\n        if (defined('E_DEPRECATED')) {\n            switch ($errno) {\n                case E_DEPRECATED:\n                case E_USER_DEPRECATED:\n                    elFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n                    $proc = true;\n                    break;\n            }\n        }\n\n        return $proc;\n    }\n\n    /***************************************************************************/\n    /*                                   utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return root - file's owner\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver|boolean (false)\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function volume($hash)\n    {\n        foreach ($this->volumes as $id => $v) {\n            if (strpos('' . $hash, $id) === 0) {\n                return $this->volumes[$id];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return files info array\n     *\n     * @param  array $data one file info or files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function toArray($data)\n    {\n        return isset($data['hash']) || !is_array($data) ? array($data) : $data;\n    }\n\n    /**\n     * Return fils hashes list\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function hashes($files)\n    {\n        $ret = array();\n        foreach ($files as $file) {\n            $ret[] = $file['hash'];\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove from files list hidden files and files with required mime types\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function filter($files)\n    {\n        $exists = array();\n        foreach ($files as $i => $file) {\n            if (isset($file['hash'])) {\n                if (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n                    unset($files[$i]);\n                }\n                $exists[$file['hash']] = true;\n            }\n        }\n        return array_values($files);\n    }\n\n    protected function utime()\n    {\n        $time = explode(\" \", microtime());\n        return (double)$time[1] + (double)$time[0];\n    }\n\n    /**\n     * Return Network mount volume unique ID\n     *\n     * @param  array  $netVolumes Saved netvolumes array\n     * @param  string $prefix     Id prefix\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     **/\n    protected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm')\n    {\n        if (is_null($netVolumes)) {\n            $netVolumes = $this->getNetVolumes();\n        }\n        $ids = array();\n        foreach ($netVolumes as $vOps) {\n            if (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n                $ids[$vOps['id']] = true;\n            }\n        }\n        if (!$ids) {\n            $id = $prefix . '1';\n        } else {\n            $i = 0;\n            while (isset($ids[$prefix . ++$i]) && $i < 10000) ;\n            $id = $prefix . $i;\n            if (isset($ids[$id])) {\n                $id = false;\n            }\n        }\n        return $id;\n    }\n\n    /**\n     * Is item locked?\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemLocked($hash)\n    {\n        if (!elFinder::$commonTempPath) {\n            return false;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . self::filenameDecontaminate($hash) . '.lock';\n        if (file_exists($lock)) {\n            if (filemtime($lock) + $this->itemLockExpire < time()) {\n                unlink($lock);\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Do lock target item\n     *\n     * @param array|string $hashes\n     * @param boolean      $autoUnlock\n     *\n     * @return void\n     */\n    protected function itemLock($hashes, $autoUnlock = true)\n    {\n        if (!elFinder::$commonTempPath) {\n            return;\n        }\n        if (!is_array($hashes)) {\n            $hashes = array($hashes);\n        }\n        foreach ($hashes as $hash) {\n            $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . self::filenameDecontaminate($hash) . '.lock';\n            if ($this->itemLocked($hash)) {\n                $cnt = file_get_contents($lock) + 1;\n            } else {\n                $cnt = 1;\n            }\n            if (file_put_contents($lock, $cnt, LOCK_EX)) {\n                if ($autoUnlock) {\n                    $this->autoUnlocks[] = $hash;\n                }\n            }\n        }\n    }\n\n    /**\n     * Do unlock target item\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemUnlock($hash)\n    {\n        if (!$this->itemLocked($hash)) {\n            return true;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        $cnt = file_get_contents($lock);\n        if (--$cnt < 1) {\n            unlink($lock);\n            return true;\n        } else {\n            file_put_contents($lock, $cnt, LOCK_EX);\n            return false;\n        }\n    }\n\n    /**\n     * unlock locked items on command completion\n     *\n     * @return void\n     */\n    public function itemAutoUnlock()\n    {\n        if ($this->autoUnlocks) {\n            foreach ($this->autoUnlocks as $hash) {\n                $this->itemUnlock($hash);\n            }\n            $this->autoUnlocks = array();\n        }\n    }\n\n    /**\n     * Ensure directories recursively\n     *\n     * @param  object $volume Volume object\n     * @param  string $target Target hash\n     * @param  array  $dirs   Array of directory tree to ensure\n     * @param  string $path   Relative path form target hash\n     *\n     * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n     * @author Naoki Sawada\n     **/\n    protected function ensureDirsRecursively($volume, $target, $dirs, $path = '')\n    {\n        $res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n        foreach ($dirs as $name => $sub) {\n            $name = (string)$name;\n            $dir = $newDir = null;\n            if ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n                $_path = $path . '/' . $name;\n                if ($newDir) {\n                    $res['makes'][] = $newDir['hash'];\n                    $dir = $newDir;\n                }\n                $res['stats'][] = $dir;\n                $res['hashes'][$_path] = $dir['hash'];\n                if (count($sub)) {\n                    $res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n                }\n            } else {\n                $res['error'][] = $name;\n            }\n        }\n        return $res;\n    }\n\n    /**\n     * Sets the toast error handler.\n     *\n     * @param array $opts The options\n     */\n    public function setToastErrorHandler($opts)\n    {\n        $this->toastParams = $this->toastParamsDefault;\n        if (!$opts) {\n            restore_error_handler();\n        } else {\n            $this->toastParams = array_merge($this->toastParams, $opts);\n            set_error_handler(array($this, 'toastErrorHandler'));\n        }\n    }\n\n    /**\n     * String encode convert to UTF-8\n     *\n     * @param      string  $str  Input string\n     *\n     * @return     string  UTF-8 string\n     */\n    public function utf8Encode($str)\n    {\n        static $mbencode = null;\n        $str = (string) $str;\n        if (@iconv('utf-8', 'utf-8//IGNORE', $str) === $str) {\n            return $str;\n        }\n\n        if ($this->utf8Encoder) {\n            return $this->utf8Encoder($str);\n        }\n\n        if ($mbencode === null) {\n            $mbencode = function_exists('mb_convert_encoding') && function_exists('mb_detect_encoding');\n        }\n\n        if ($mbencode) {\n            if ($enc = mb_detect_encoding($str, mb_detect_order(), true)) {\n                $_str = mb_convert_encoding($str, 'UTF-8', $enc);\n                if (@iconv('utf-8', 'utf-8//IGNORE', $_str) === $_str) {\n                    return $_str;\n                }\n            }\n        }\n        return utf8_encode($str);\n    }\n\n    /***************************************************************************/\n    /*                           static  utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return full version of API that this connector supports all functions\n     *\n     * @return string\n     */\n    public static function getApiFullVersion()\n    {\n        return (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n    }\n\n    /**\n     * Return self::$commonTempPath\n     *\n     * @return     string  The common temporary path.\n     */\n    public static function getCommonTempPath()\n    {\n        return self::$commonTempPath;\n    }\n\n    /**\n     * Return Is Animation Gif\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationGif($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_GIF:\n                break;\n            default:\n                return false;\n        }\n\n        $imgcnt = 0;\n        $fp = fopen($path, 'rb');\n        fread($fp, 4);\n        $c = fread($fp, 1);\n        if (ord($c) != 0x39) {  // GIF89a\n            return false;\n        }\n\n        while (!feof($fp)) {\n            do {\n                $c = fread($fp, 1);\n            } while (ord($c) != 0x21 && !feof($fp));\n\n            if (feof($fp)) {\n                break;\n            }\n\n            $c2 = fread($fp, 2);\n            if (bin2hex($c2) == \"f904\") {\n                $imgcnt++;\n                if ($imgcnt === 2) {\n                    break;\n                }\n            }\n\n            if (feof($fp)) {\n                break;\n            }\n        }\n\n        if ($imgcnt > 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Return Is Animation Png\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationPng($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_PNG:\n                break;\n            default:\n                return false;\n        }\n\n        $fp = fopen($path, 'rb');\n        $img_bytes = fread($fp, 1024);\n        fclose($fp);\n        if ($img_bytes) {\n            if (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return Is seekable stream resource\n     *\n     * @param resource $resource\n     *\n     * @return bool\n     */\n    public static function isSeekableStream($resource)\n    {\n        $metadata = stream_get_meta_data($resource);\n        return $metadata['seekable'];\n    }\n\n    /**\n     * Rewind stream resource\n     *\n     * @param resource $resource\n     *\n     * @return void\n     */\n    public static function rewind($resource)\n    {\n        self::isSeekableStream($resource) && rewind($resource);\n    }\n\n    /**\n     * Determines whether the specified resource is seekable url.\n     *\n     * @param      <type>   $resource  The resource\n     *\n     * @return     boolean  True if the specified resource is seekable url, False otherwise.\n     */\n    public static function isSeekableUrl($resource)\n    {\n        $id = (int)$resource;\n        if (isset(elFinder::$seekableUrlFps[$id])) {\n            return elFinder::$seekableUrlFps[$id];\n        }\n        return null;\n    }\n\n    /**\n     * serialize and base64_encode of session data (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var target variable\n     *\n     * @author Naoki Sawada\n     * @return mixed|string\n     */\n    public static function sessionDataEncode($var)\n    {\n        if (self::$base64encodeSessionData) {\n            $var = base64_encode(serialize($var));\n        }\n        return $var;\n    }\n\n    /**\n     * base64_decode and unserialize of session data  (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var     target variable\n     * @param  bool  $checkIs data type for check (array|string|object|int)\n     *\n     * @author Naoki Sawada\n     * @return bool|mixed\n     */\n    public static function sessionDataDecode(&$var, $checkIs = null)\n    {\n        if (self::$base64encodeSessionData) {\n            $data = unserialize(base64_decode($var));\n        } else {\n            $data = $var;\n        }\n        $chk = true;\n        if ($checkIs) {\n            switch ($checkIs) {\n                case 'array':\n                    $chk = is_array($data);\n                    break;\n                case 'string':\n                    $chk = is_string($data);\n                    break;\n                case 'object':\n                    $chk = is_object($data);\n                    break;\n                case 'int':\n                    $chk = is_int($data);\n                    break;\n            }\n        }\n        if (!$chk) {\n            unset($var);\n            return false;\n        }\n        return $data;\n    }\n\n    /**\n     * Call session_write_close() if session is restarted\n     *\n     * @deprecated\n     * @return void\n     */\n    public static function sessionWrite()\n    {\n        if (session_id()) {\n            session_write_close();\n        }\n    }\n\n    /**\n     * Return elFinder static variable\n     *\n     * @param $key\n     *\n     * @return mixed|null\n     */\n    public static function getStaticVar($key)\n    {\n        return isset(elFinder::$$key) ? elFinder::$$key : null;\n    }\n\n    /**\n     * Extend PHP execution time limit and also check connection is aborted\n     *\n     * @param Int $time\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function extendTimeLimit($time = null)\n    {\n        static $defLimit = null;\n        if (!self::aborted()) {\n            if (is_null($defLimit)) {\n                $defLimit = ini_get('max_execution_time');\n            }\n            if ($defLimit != 0) {\n                $time = is_null($time) ? $defLimit : max($defLimit, $time);\n                set_time_limit($time);\n            }\n        } else {\n            throw new elFinderAbortException();\n        }\n    }\n\n    /**\n     * Check connection is aborted\n     * Script stop immediately if connection aborted\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function checkAborted()\n    {\n        elFinder::extendTimeLimit();\n    }\n\n    /**\n     * Return bytes from php.ini value\n     *\n     * @param string $iniName\n     * @param string $val\n     *\n     * @return number\n     */\n    public static function getIniBytes($iniName = '', $val = '')\n    {\n        if ($iniName !== '') {\n            $val = ini_get($iniName);\n            if ($val === false) {\n                return 0;\n            }\n        }\n        $val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n        $last = strtolower($val[strlen($val) - 1]);\n        $val = sprintf('%u', $val);\n        switch ($last) {\n            case 'y':\n                $val = elFinder::xKilobyte($val);\n            case 'z':\n                $val = elFinder::xKilobyte($val);\n            case 'e':\n                $val = elFinder::xKilobyte($val);\n            case 'p':\n                $val = elFinder::xKilobyte($val);\n            case 't':\n                $val = elFinder::xKilobyte($val);\n            case 'g':\n                $val = elFinder::xKilobyte($val);\n            case 'm':\n                $val = elFinder::xKilobyte($val);\n            case 'k':\n                $val = elFinder::xKilobyte($val);\n        }\n        return $val;\n    }\n\n    /**\n     * Return X 1KByte\n     *\n     * @param      integer|string  $val    The value\n     *\n     * @return     number\n     */\n    public static function xKilobyte($val)\n    {\n        if (strpos((string)$val * 1024, 'E') !== false) {\n            if (strpos((string)$val * 1.024, 'E') === false) {\n                $val *= 1.024;\n            }\n            $val .= '000';\n        } else {\n            $val *= 1024;\n        }\n        return $val;\n    }\n\n    /**\n     * Get script url.\n     *\n     * @return string full URL\n     * @author Naoki Sawada\n     */\n    public static function getConnectorUrl()\n    {\n        if (defined('ELFINDER_CONNECTOR_URL')) {\n            return ELFINDER_CONNECTOR_URL;\n        }\n\n        $https = (!empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n        $url = ($https ? 'https://' : 'http://')\n            . $_SERVER['SERVER_NAME']                                              // host\n            . ((empty($_SERVER['SERVER_PORT']) || (!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n            . $_SERVER['REQUEST_URI'];                                             // path & query\n        list($url) = explode('?', $url);\n\n        return $url;\n    }\n\n    /**\n     * Get stream resource pointer by URL\n     *\n     * @param array $data array('target'=>'URL', 'headers' => array())\n     * @param int   $redirectLimit\n     *\n     * @return resource|boolean\n     * @author Naoki Sawada\n     */\n    public static function getStreamByUrl($data, $redirectLimit = 5)\n    {\n        if (isset($data['target'])) {\n            $data = array(\n                'cnt' => 0,\n                'url' => $data['target'],\n                'headers' => isset($data['headers']) ? $data['headers'] : array(),\n                'postData' => isset($data['postData']) ? $data['postData'] : array(),\n                'cookies' => array(),\n            );\n        }\n        if ($data['cnt'] > $redirectLimit) {\n            return false;\n        }\n        $dlurl = $data['url'];\n        $data['url'] = '';\n        $headers = $data['headers'];\n\n        if ($dlurl) {\n            $url = parse_url($dlurl);\n            $ports = array(\n                'http' => '80',\n                'https' => '443',\n                'ftp' => '21'\n            );\n            $url['scheme'] = strtolower($url['scheme']);\n            if (!isset($url['port']) && isset($ports[$url['scheme']])) {\n                $url['port'] = $ports[$url['scheme']];\n            }\n            if (!isset($url['port'])) {\n                return false;\n            }\n            $cookies = array();\n            if ($data['cookies']) {\n                foreach ($data['cookies'] as $d => $c) {\n                    if (strpos($url['host'], $d) !== false) {\n                        $cookies[] = $c;\n                    }\n                }\n            }\n\n            $transport = ($url['scheme'] === 'https') ? 'ssl' : 'tcp';\n            $query = isset($url['query']) ? '?' . $url['query'] : '';\n            if (!($stream = stream_socket_client($transport . '://' . $url['host'] . ':' . $url['port']))) {\n                return false;\n            }\n\n            $body = '';\n            if (!empty($data['postData'])) {\n                $method = 'POST';\n                if (is_array($data['postData'])) {\n                    $body = http_build_query($data['postData']);\n                } else {\n                    $body = $data['postData'];\n                }\n            } else {\n                $method = 'GET';\n            }\n\n            $sends = array();\n            $sends[] = \"$method {$url['path']}{$query} HTTP/1.1\";\n            $sends[] = \"Host: {$url['host']}\";\n            foreach ($headers as $header) {\n                $sends[] = trim($header, \"\\r\\n\");\n            }\n            $sends[] = 'Connection: Close';\n            if ($cookies) {\n                $sends[] = 'Cookie: ' . implode('; ', $cookies);\n            }\n            if ($method === 'POST') {\n                $sends[] = 'Content-Type: application/x-www-form-urlencoded';\n                $sends[] = 'Content-Length: ' . strlen($body);\n            }\n            $sends[] = \"\\r\\n\" . $body;\n\n            stream_set_timeout($stream, 300);\n            fputs($stream, join(\"\\r\\n\", $sends) . \"\\r\\n\");\n\n            while (($res = trim(fgets($stream))) !== '') {\n                // find redirect\n                if (preg_match('/^Location: (.+)$/i', $res, $m)) {\n                    $data['url'] = $m[1];\n                }\n                // fetch cookie\n                if (strpos($res, 'Set-Cookie:') === 0) {\n                    $domain = $url['host'];\n                    if (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n                        if (!empty($c1[2])) {\n                            $domain = trim($c1[2]);\n                        }\n                        if (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n                            $data['cookies'][$domain] = $c2[1];\n                        }\n                    }\n                }\n                // is seekable url\n                if (preg_match('/^(Accept-Ranges|Content-Range): bytes/i', $res)) {\n                    elFinder::$seekableUrlFps[(int)$stream] = true;\n                }\n            }\n            if ($data['url']) {\n                ++$data['cnt'];\n                fclose($stream);\n\n                return self::getStreamByUrl($data, $redirectLimit);\n            }\n\n            return $stream;\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the fetch cookie file for curl.\n     *\n     * @return string  The fetch cookie file.\n     */\n    public function getFetchCookieFile()\n    {\n        $file = '';\n        if ($tmpDir = $this->getTempDir()) {\n            $file = $tmpDir . '/.elFinderAnonymousCookie';\n        }\n        return $file;\n    }\n\n    /**\n     * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n     *\n     * @param resource $curl\n     * @param array    $options\n     * @param array    $headers\n     * @param array    $postData\n     *\n     * @throws \\Exception\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public static function curlExec($curl, $options = array(), $headers = array(), $postData = array())\n    {\n        $followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'));\n        if ($followLocation) {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($options) {\n            curl_setopt_array($curl, $options);\n        }\n\n        if ($headers) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($curl);\n\n        if (!$followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n            if ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers, 'postData' => $postData))) {\n                $result = stream_get_contents($stream);\n            }\n        }\n\n        if ($result === false) {\n            if (curl_errno($curl)) {\n                throw new \\Exception('curl_exec() failed: ' . curl_error($curl));\n            } else {\n                throw new \\Exception('curl_exec(): empty response');\n            }\n        }\n\n        curl_close($curl);\n\n        return $result;\n    }\n\n    /**\n     * Return bool that current request was aborted by client side\n     *\n     * @return boolean\n     */\n    public static function aborted()\n    {\n        if ($file = self::$abortCheckFile) {\n            (version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n            if (!is_file($file)) {\n                // GC (expire 12h)\n                list($ptn) = explode('elfreq', $file);\n                self::GlobGC($ptn . 'elfreq*', 43200);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return array [\"name without extention\", \"extention\"] by filename\n     *\n     * @param string $name\n     *\n     * @return array\n     */\n    public static function splitFileExtention($name)\n    {\n        if (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,10})$/i', $name, $m)) {\n            return array((string)$m[1], $m[2]);\n        } else {\n            return array($name, '');\n        }\n    }\n\n    /**\n     * Gets the memory size by imageinfo.\n     *\n     * @param      array $imgInfo array that result of getimagesize()\n     *\n     * @return     integer  The memory size by imageinfo.\n     */\n    public static function getMemorySizeByImageInfo($imgInfo)\n    {\n        $width = $imgInfo[0];\n        $height = $imgInfo[1];\n        $bits = isset($imgInfo['bits']) ? $imgInfo['bits'] : 24;\n        $channels = isset($imgInfo['channels']) ? $imgInfo['channels'] : 3;\n        return round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n    }\n\n    /**\n     * Auto expand memory for GD processing\n     *\n     * @param      array $imgInfos The image infos\n     */\n    public static function expandMemoryForGD($imgInfos)\n    {\n        if (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n            if (!is_array($imgInfos[0])) {\n                $imgInfos = array($imgInfos);\n            }\n            $limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n            $memLimit = self::getIniBytes('memory_limit');\n            $needs = 0;\n            foreach ($imgInfos as $info) {\n                $needs += self::getMemorySizeByImageInfo($info);\n            }\n            $needs += memory_get_usage();\n            if ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n                ini_set('memory_limit', $needs);\n            }\n        }\n    }\n\n    /**\n     * Decontaminate of filename\n     *\n     * @param      String  $name   The name\n     *\n     * @return     String  Decontaminated filename\n     */\n    public static function filenameDecontaminate($name)\n    {\n        // Directory traversal defense\n        if (DIRECTORY_SEPARATOR === '\\\\') {\n            $name = str_replace('\\\\', '/', $name);\n        }\n        $parts = explode('/', trim($name, '/'));\n        $name = array_pop($parts); \n        return $name;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     * @param  null   $cwd          cwd\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    public static function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n\n        static $allowed = null;\n\n        if ($allowed === null) {\n            if ($allowed = function_exists('proc_open')) {\n                if ($disabled = ini_get('disable_functions')) {\n                    $funcs = array_map('trim', explode(',', $disabled));\n                    $allowed = !in_array('proc_open', $funcs);\n                }\n            }\n        }\n\n        if (!$allowed) {\n            $return_var = -1;\n            return $return_var;\n        }\n\n        if (!$command) {\n            $return_var = 0;\n            return $return_var;\n        }\n\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),  // stdin\n            1 => array(\"pipe\", \"w\"),  // stdout\n            2 => array(\"pipe\", \"w\")   // stderr\n        );\n\n        $process = proc_open($command, $descriptorspec, $pipes, $cwd, null);\n\n        if (is_resource($process)) {\n            stream_set_blocking($pipes[1], 0);\n            stream_set_blocking($pipes[2], 0);\n\n            fclose($pipes[0]);\n\n            $tmpout = '';\n            $tmperr = '';\n            while (feof($pipes[1]) === false || feof($pipes[2]) === false) {\n                elFinder::extendTimeLimit();\n                $read = array($pipes[1], $pipes[2]);\n                $write = null;\n                $except = null;\n                $ret = stream_select($read, $write, $except, 1);\n                if ($ret === false) {\n                    // error\n                    break;\n                } else if ($ret === 0) {\n                    // timeout\n                    continue;\n                } else {\n                    foreach ($read as $sock) {\n                        if ($sock === $pipes[1]) {\n                            $tmpout .= fread($sock, 4096);\n                        } else if ($sock === $pipes[2]) {\n                            $tmperr .= fread($sock, 4096);\n                        }\n                    }\n                }\n            }\n\n            fclose($pipes[1]);\n            fclose($pipes[2]);\n\n            $output = $tmpout;\n            $error_output = $tmperr;\n            $return_var = proc_close($process);\n\n        } else {\n            $return_var = -1;\n        }\n\n        return $return_var;\n\n    }\n\n    /***************************************************************************/\n    /*                                 callbacks                               */\n    /***************************************************************************/\n\n    /**\n     * Get command name of binded \"commandName.subName\"\n     *\n     * @param string $cmd\n     *\n     * @return string\n     */\n    protected static function getCmdOfBind($cmd)\n    {\n        list($ret) = explode('.', $cmd);\n        return trim($ret);\n    }\n\n    /**\n     * Add subName to commandName\n     *\n     * @param string $cmd\n     * @param string $sub\n     *\n     * @return string\n     */\n    protected static function addSubToBindName($cmd, $sub)\n    {\n        return $cmd . '.' . trim($sub);\n    }\n\n    /**\n     * Remove a file if connection is disconnected\n     *\n     * @param string $file\n     */\n    public static function rmFileInDisconnected($file)\n    {\n        (connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Call back function on shutdown\n     *  - delete files in $GLOBALS['elFinderTempFiles']\n     */\n    public static function onShutdown()\n    {\n        self::$abortCheckFile = null;\n        if (!empty($GLOBALS['elFinderTempFps'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFps']) as $fp) {\n                is_resource($fp) && fclose($fp);\n            }\n        }\n        if (!empty($GLOBALS['elFinderTempFiles'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $f) {\n                is_file($f) && is_writable($f) && unlink($f);\n            }\n        }\n    }\n\n    /**\n     * Garbage collection with glob\n     *\n     * @param string  $pattern\n     * @param integer $time\n     */\n    public static function GlobGC($pattern, $time)\n    {\n        $now = time();\n        foreach (glob($pattern) as $file) {\n            (filemtime($file) < ($now - $time)) && unlink($file);\n        }\n    }\n\n} // END class\n\n/**\n * Custom exception class for aborting request\n */\nclass elFinderAbortException extends Exception\n{\n}\n\nclass elFinderTriggerException extends Exception\n{\n}\n", "<?php\n\n/**\n * Base class for elFinder volume.\n * Provide 2 layers:\n *  1. Public API (commands)\n *  2. abstract fs API\n * All abstract methods begin with \"_\"\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n * @method netmountPrepare(array $options)\n * @method postNetmount(array $options)\n */\nabstract class elFinderVolumeDriver\n{\n\n    /**\n     * Net mount key\n     *\n     * @var string\n     **/\n    public $netMountKey = '';\n\n    /**\n     * Request args\n     * $_POST or $_GET values\n     *\n     * @var array\n     */\n    protected $ARGS = array();\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'a';\n\n    /**\n     * Volume id - used as prefix for files hashes\n     *\n     * @var string\n     **/\n    protected $id = '';\n\n    /**\n     * Flag - volume \"mounted\" and available\n     *\n     * @var bool\n     **/\n    protected $mounted = false;\n\n    /**\n     * Root directory path\n     *\n     * @var string\n     **/\n    protected $root = '';\n\n    /**\n     * Root basename | alias\n     *\n     * @var string\n     **/\n    protected $rootName = '';\n\n    /**\n     * Default directory to open\n     *\n     * @var string\n     **/\n    protected $startPath = '';\n\n    /**\n     * Base URL\n     *\n     * @var string\n     **/\n    protected $URL = '';\n\n    /**\n     * Path to temporary directory\n     *\n     * @var string\n     */\n    protected $tmp;\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector Path/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector URL/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkUrl = '';\n\n    /**\n     * Thumbnails dir path\n     *\n     * @var string\n     **/\n    protected $tmbPath = '';\n\n    /**\n     * Is thumbnails dir writable\n     *\n     * @var bool\n     **/\n    protected $tmbPathWritable = false;\n\n    /**\n     * Thumbnails base URL\n     *\n     * @var string\n     **/\n    protected $tmbURL = '';\n\n    /**\n     * Thumbnails size in px\n     *\n     * @var int\n     **/\n    protected $tmbSize = 48;\n\n    /**\n     * Image manipulation lib name\n     * auto|imagick|gd|convert\n     *\n     * @var string\n     **/\n    protected $imgLib = 'auto';\n\n    /**\n     * Video to Image converter\n     *\n     * @var array\n     */\n    protected $imgConverter = array();\n\n    /**\n     * Library to crypt files name\n     *\n     * @var string\n     **/\n    protected $cryptLib = '';\n\n    /**\n     * Archivers config\n     *\n     * @var array\n     **/\n    protected $archivers = array(\n        'create' => array(),\n        'extract' => array()\n    );\n\n    /**\n     * Static var of $this->options['maxArcFilesSize']\n     * \n     * @var int|string\n     */\n    protected static $maxArcFilesSize;\n\n    /**\n     * Server character encoding\n     *\n     * @var string or null\n     **/\n    protected $encoding = null;\n\n    /**\n     * How many subdirs levels return for tree\n     *\n     * @var int\n     **/\n    protected $treeDeep = 1;\n\n    /**\n     * Errors from last failed action\n     *\n     * @var array\n     **/\n    protected $error = array();\n\n    /**\n     * Today 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $today = 0;\n\n    /**\n     * Yesterday 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $yesterday = 0;\n\n    /**\n     * Force make dirctory on extract\n     *\n     * @var int\n     **/\n    protected $extractToNewdir = 'auto';\n\n    /**\n     * Object configuration\n     *\n     * @var array\n     **/\n    protected $options = array(\n        // Driver ID (Prefix of volume ID), Normally, the value specified for each volume driver is used.\n        'driverId' => '',\n        // Id (Suffix of volume ID), Normally, the number incremented according to the specified number of volumes is used.\n        'id' => '',\n        // revision id of root directory that uses for caching control of root stat\n        'rootRev' => '',\n        // driver type it uses volume root's CSS class name. e.g. 'group' -> Adds 'elfinder-group' to CSS class name.\n        'type' => '',\n        // root directory path\n        'path' => '',\n        // Folder hash value on elFinder to be the parent of this volume\n        'phash' => '',\n        // Folder hash value on elFinder to trash bin of this volume, it require 'copyJoin' to true\n        'trashHash' => '',\n        // open this path on initial request instead of root path\n        'startPath' => '',\n        // how many subdirs levels return per request\n        'treeDeep' => 1,\n        // root url, not set to URL via the connector. If you want to hide the file URL, do not set this value. (replacement for old \"fileURL\" option)\n        'URL' => '',\n        // enable onetime URL to a file - (true, false, 'auto' (true if a temporary directory is available) or callable (A function that return onetime URL))\n        'onetimeUrl' => 'auto',\n        // directory link url to own manager url with folder hash (`true`, `false`, `'hide'`(No show) or default `'auto'`: URL is empty then `true` else `false`)\n        'dirUrlOwn' => 'auto',\n        // directory separator. required by client to show paths correctly\n        'separator' => DIRECTORY_SEPARATOR,\n        // Use '/' as directory separator when the path hash encode/decode on the Windows server too\n        'winHashFix' => false,\n        // Server character encoding (default is '': UTF-8)\n        'encoding' => '',\n        // for convert character encoding (default is '': Not change locale)\n        'locale' => '',\n        // URL of volume icon image\n        'icon' => '',\n        // CSS Class of volume root in tree\n        'rootCssClass' => '',\n        // Items to disable session caching\n        'noSessionCache' => array(),\n        // enable i18n folder name that convert name to elFinderInstance.messages['folder_'+name]\n        'i18nFolderName' => false,\n        // Search timeout (sec)\n        'searchTimeout' => 30,\n        // Search exclusion directory regex pattern (require demiliter e.g. '#/path/to/exclude_directory#i')\n        'searchExDirReg' => '',\n        // library to crypt/uncrypt files names (not implemented)\n        'cryptLib' => '',\n        // how to detect files mimetypes. (auto/internal/finfo/mime_content_type)\n        'mimeDetect' => 'auto',\n        // mime.types file path (for mimeDetect==internal)\n        'mimefile' => '',\n        // Static extension/MIME of general server side scripts to security issues\n        'staticMineMap' => array(\n            'php:*' => 'text/x-php',\n            'pht:*' => 'text/x-php',\n            'php3:*' => 'text/x-php',\n            'php4:*' => 'text/x-php',\n            'php5:*' => 'text/x-php',\n            'php7:*' => 'text/x-php',\n            'phtml:*' => 'text/x-php',\n            'phar:*' => 'text/x-php',\n            'cgi:*' => 'text/x-httpd-cgi',\n            'pl:*' => 'text/x-perl',\n            'asp:*' => 'text/x-asap',\n            'aspx:*' => 'text/x-asap',\n            'py:*' => 'text/x-python',\n            'rb:*' => 'text/x-ruby',\n            'jsp:*' => 'text/x-jsp'\n        ),\n        // mime type normalize map : Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'mimeMap' => array(\n            'md:application/x-genesis-rom' => 'text/x-markdown',\n            'md:text/plain' => 'text/x-markdown',\n            'markdown:text/plain' => 'text/x-markdown',\n            'css:text/x-asm' => 'text/css',\n            'css:text/plain' => 'text/css',\n            'csv:text/plain' => 'text/csv',\n            'java:text/x-c' => 'text/x-java-source',\n            'json:text/plain' => 'application/json',\n            'sql:text/plain' => 'text/x-sql',\n            'rtf:text/rtf' => 'application/rtf',\n            'rtfd:text/rtfd' => 'application/rtfd',\n            'ico:image/vnd.microsoft.icon' => 'image/x-icon',\n            'svg:text/plain' => 'image/svg+xml',\n            'pxd:application/octet-stream' => 'image/x-pixlr-data',\n            'dng:image/tiff' => 'image/x-adobe-dng',\n            'sketch:application/zip' => 'image/x-sketch',\n            'sketch:application/octet-stream' => 'image/x-sketch',\n            'xcf:application/octet-stream' => 'image/x-xcf',\n            'amr:application/octet-stream' => 'audio/amr',\n            'm4a:video/mp4' => 'audio/mp4',\n            'oga:application/ogg' => 'audio/ogg',\n            'ogv:application/ogg' => 'video/ogg',\n            'zip:application/x-zip' => 'application/zip',\n            'm3u8:text/plain' => 'application/x-mpegURL',\n            'mpd:text/plain' => 'application/dash+xml',\n            'mpd:application/xml' => 'application/dash+xml',\n            '*:application/x-dosexec' => 'application/x-executable',\n            'doc:application/vnd.ms-office' => 'application/msword',\n            'xls:application/vnd.ms-office' => 'application/vnd.ms-excel',\n            'ppt:application/vnd.ms-office' => 'application/vnd.ms-powerpoint',\n            'yml:text/plain' => 'text/x-yaml',\n            'ai:application/pdf' => 'application/postscript',\n            'cgm:text/plain' => 'image/cgm',\n            'dxf:text/plain' => 'image/vnd.dxf',\n            'dds:application/octet-stream' => 'image/vnd-ms.dds',\n            'hpgl:text/plain' => 'application/vnd.hp-hpgl',\n            'igs:text/plain' => 'model/iges',\n            'iges:text/plain' => 'model/iges',\n            'plt:application/octet-stream' => 'application/plt',\n            'plt:text/plain' => 'application/plt',\n            'sat:text/plain' => 'application/sat',\n            'step:text/plain' => 'application/step',\n            'stp:text/plain' => 'application/step'\n        ),\n        // An option to add MimeMap to the `mimeMap` option\n        // Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'additionalMimeMap' => array(),\n        // MIME-Type of filetype detected as unknown\n        'mimeTypeUnknown' => 'application/octet-stream',\n        // MIME regex of send HTTP header \"Content-Disposition: inline\" or allow preview in quicklook\n        // '.' is allow inline of all of MIME types\n        // '$^' is not allow inline of all of MIME types\n        'dispInlineRegex' => '^(?:(?:video|audio)|image/(?!.+\\+xml)|application/(?:ogg|x-mpegURL|dash\\+xml)|(?:text/plain|application/pdf)$)',\n        // temporary content URL's base path\n        'tmpLinkPath' => '',\n        // temporary content URL's base URL\n        'tmpLinkUrl' => '',\n        // directory for thumbnails\n        'tmbPath' => '.tmb',\n        // mode to create thumbnails dir\n        'tmbPathMode' => 0777,\n        // thumbnails dir URL. Set it if store thumbnails outside root directory\n        'tmbURL' => '',\n        // thumbnails size (px)\n        'tmbSize' => 48,\n        // thumbnails crop (true - crop, false - scale image to fit thumbnail size)\n        'tmbCrop' => true,\n        // thumbnail URL require custom data as the GET query\n        'tmbReqCustomData' => false,\n        // thumbnails background color (hex #rrggbb or 'transparent')\n        'tmbBgColor' => 'transparent',\n        // image rotate fallback background color (hex #rrggbb)\n        'bgColorFb' => '#ffffff',\n        // image manipulations library (imagick|gd|convert|auto|none, none - Does not check the image library at all.)\n        'imgLib' => 'auto',\n        // Fallback self image to thumbnail (nothing imgLib)\n        'tmbFbSelf' => true,\n        // Video to Image converters ['TYPE or MIME' => ['func' => function($file){ /* Converts $file to Image */ return true; }, 'maxlen' => (int)TransferLength]]\n        'imgConverter' => array(),\n        // Max length of transfer to image converter\n        'tmbVideoConvLen' => 10000000,\n        // Captre point seccond\n        'tmbVideoConvSec' => 6,\n        // Life time (hour) for thumbnail garbage collection (\"0\" means no GC)\n        'tmbGcMaxlifeHour' => 0,\n        // Percentage of garbage collection executed for thumbnail creation command (\"1\" means \"1%\")\n        'tmbGcPercentage' => 1,\n        // Resource path of fallback icon images defailt: php/resouces\n        'resourcePath' => '',\n        // Jpeg image saveing quality\n        'jpgQuality' => 100,\n        // Save as progressive JPEG on image editing\n        'jpgProgressive' => true,\n        // enable to get substitute image with command `dim`\n        'substituteImg' => true,\n        // on paste file -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'copyOverwrite' => true,\n        // if true - join new and old directories content on paste\n        'copyJoin' => true,\n        // on upload -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'uploadOverwrite' => true,\n        // mimetypes allowed to upload\n        'uploadAllow' => array(),\n        // mimetypes not allowed to upload\n        'uploadDeny' => array(),\n        // order to process uploadAllow and uploadDeny options\n        'uploadOrder' => array('deny', 'allow'),\n        // maximum upload file size. NOTE - this is size for every uploaded files\n        'uploadMaxSize' => 0,\n        // Maximum number of folders that can be created at one time. (0: unlimited)\n        'uploadMaxMkdirs' => 0,\n        // maximum number of chunked upload connection. `-1` to disable chunked upload\n        'uploadMaxConn' => 3,\n        // maximum get file size. NOTE - Maximum value is 50% of PHP memory_limit\n        'getMaxSize' => 0,\n        // files dates format\n        'dateFormat' => 'j M Y H:i',\n        // files time format\n        'timeFormat' => 'H:i',\n        // if true - every folder will be check for children folders, -1 - every folder will be check asynchronously, false -  all folders will be marked as having subfolders\n        'checkSubfolders' => true, // true, false or -1\n        // allow to copy from this volume to other ones?\n        'copyFrom' => true,\n        // allow to copy from other volumes to this one?\n        'copyTo' => true,\n        // cmd duplicate suffix format e.g. '_%s_' to without spaces\n        'duplicateSuffix' => ' %s ',\n        // unique name numbar format e.g. '(%d)' to (1), (2)...\n        'uniqueNumFormat' => '%d',\n        // list of commands disabled on this root\n        'disabled' => array(),\n        // enable file owner, group & mode info, `false` to inactivate \"chmod\" command.\n        'statOwner' => false,\n        // allow exec chmod of read-only files\n        'allowChmodReadOnly' => false,\n        // regexp or function name to validate new file name\n        'acceptedName' => '/^[^\\.].*/', // Notice: overwritten it in some volume drivers contractor\n        // regexp or function name to validate new directory name\n        'acceptedDirname' => '', // used `acceptedName` if empty value\n        // function/class method to control files permissions\n        'accessControl' => null,\n        // some data required by access control\n        'accessControlData' => null,\n        // root stat that return without asking the system when mounted and not the current volume. Query to the system with false. array|false\n        'rapidRootStat' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false,\n            'size' => 0,  // Unknown\n            'ts' => 0,    // Unknown\n            'dirs' => -1, // Check on demand for subdirectories\n            'mime' => 'directory'\n        ),\n        // default permissions.\n        'defaults' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false\n        ),\n        // files attributes\n        'attributes' => array(),\n        // max allowed archive files size (0 - no limit)\n        'maxArcFilesSize' => '2G',\n        // Allowed archive's mimetypes to create. Leave empty for all available types.\n        'archiveMimes' => array(),\n        // Manual config for archivers. See example below. Leave empty for auto detect\n        'archivers' => array(),\n        // Use Archive function for remote volume\n        'useRemoteArchive' => false,\n        // plugin settings\n        'plugin' => array(),\n        // Is support parent directory time stamp update on add|remove|rename item\n        // Default `null` is auto detection that is LocalFileSystem, FTP or Dropbox are `true`\n        'syncChkAsTs' => null,\n        // Long pooling sync checker function for syncChkAsTs is true\n        // Calls with args (TARGET DIRCTORY PATH, STAND-BY(sec), OLD TIMESTAMP, VOLUME DRIVER INSTANCE, ELFINDER INSTANCE)\n        // This function must return the following values. Changed: New Timestamp or Same: Old Timestamp or Error: false\n        // Default `null` is try use elFinderVolumeLocalFileSystem::localFileSystemInotify() on LocalFileSystem driver\n        // another driver use elFinder stat() checker\n        'syncCheckFunc' => null,\n        // Long polling sync stand-by time (sec)\n        'plStandby' => 30,\n        // Sleep time (sec) for elFinder stat() checker (syncChkAsTs is true)\n        'tsPlSleep' => 10,\n        // Sleep time (sec) for elFinder ls() checker (syncChkAsTs is false)\n        'lsPlSleep' => 30,\n        // Client side sync interval minimum (ms)\n        // Default `null` is auto set to ('tsPlSleep' or 'lsPlSleep') * 1000\n        // `0` to disable auto sync\n        'syncMinMs' => null,\n        // required to fix bug on macos\n        // However, we recommend to use the Normalizer plugin instead this option\n        'utf8fix' => false,\n        //                           \u0439                 \u0451              \u0419               \u0401              \u00d8         \u00c5\n        'utf8patterns' => array(\"\\u0438\\u0306\", \"\\u0435\\u0308\", \"\\u0418\\u0306\", \"\\u0415\\u0308\", \"\\u00d8A\", \"\\u030a\"),\n        'utf8replace' => array(\"\\u0439\", \"\\u0451\", \"\\u0419\", \"\\u0401\", \"\\u00d8\", \"\\u00c5\"),\n        // cache control HTTP headers for commands `file` and  `get`\n        'cacheHeaders' => array(\n            'Cache-Control: max-age=3600',\n            'Expires:',\n            'Pragma:'\n        ),\n        // Header to use to accelerate sending local files to clients (e.g. 'X-Sendfile', 'X-Accel-Redirect')\n        'xsendfile' => '',\n        // Root path to xsendfile target. Probably, this is required for 'X-Accel-Redirect' on Nginx.\n        'xsendfilePath' => ''\n    );\n\n    /**\n     * Defaults permissions\n     *\n     * @var array\n     **/\n    protected $defaults = array(\n        'read' => true,\n        'write' => true,\n        'locked' => false,\n        'hidden' => false\n    );\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $attributes = array();\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $access = null;\n\n    /**\n     * Mime types allowed to upload\n     *\n     * @var array\n     **/\n    protected $uploadAllow = array();\n\n    /**\n     * Mime types denied to upload\n     *\n     * @var array\n     **/\n    protected $uploadDeny = array();\n\n    /**\n     * Order to validate uploadAllow and uploadDeny\n     *\n     * @var array\n     **/\n    protected $uploadOrder = array();\n\n    /**\n     * Maximum allowed upload file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $uploadMaxSize = 0;\n\n    /**\n     * Run time setting of overwrite items on upload\n     *\n     * @var string\n     */\n    protected $uploadOverwrite = true;\n\n    /**\n     * Maximum allowed get file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $getMaxSize = -1;\n\n    /**\n     * Mimetype detect method\n     *\n     * @var string\n     **/\n    protected $mimeDetect = 'auto';\n\n    /**\n     * Flag - mimetypes from externail file was loaded\n     *\n     * @var bool\n     **/\n    private static $mimetypesLoaded = false;\n\n    /**\n     * Finfo resource for mimeDetect == 'finfo'\n     *\n     * @var resource\n     **/\n    protected $finfo = null;\n\n    /**\n     * List of disabled client's commands\n     *\n     * @var array\n     **/\n    protected $disabled = array();\n\n    /**\n     * overwrite extensions/mimetypes to mime.types\n     *\n     * @var array\n     **/\n    protected static $mimetypes = array(\n        // applications\n        'exe' => 'application/x-executable',\n        'jar' => 'application/x-jar',\n        // archives\n        'gz' => 'application/x-gzip',\n        'tgz' => 'application/x-gzip',\n        'tbz' => 'application/x-bzip2',\n        'rar' => 'application/x-rar',\n        // texts\n        'php' => 'text/x-php',\n        'js' => 'text/javascript',\n        'rtfd' => 'application/rtfd',\n        'py' => 'text/x-python',\n        'rb' => 'text/x-ruby',\n        'sh' => 'text/x-shellscript',\n        'pl' => 'text/x-perl',\n        'xml' => 'text/xml',\n        'c' => 'text/x-csrc',\n        'h' => 'text/x-chdr',\n        'cpp' => 'text/x-c++src',\n        'hh' => 'text/x-c++hdr',\n        'md' => 'text/x-markdown',\n        'markdown' => 'text/x-markdown',\n        'yml' => 'text/x-yaml',\n        // images\n        'bmp' => 'image/x-ms-bmp',\n        'tga' => 'image/x-targa',\n        'xbm' => 'image/xbm',\n        'pxm' => 'image/pxm',\n        //audio\n        'wav' => 'audio/wav',\n        // video\n        'dv' => 'video/x-dv',\n        'wm' => 'video/x-ms-wmv',\n        'ogm' => 'video/ogg',\n        'm2ts' => 'video/MP2T',\n        'mts' => 'video/MP2T',\n        'ts' => 'video/MP2T',\n        'm3u8' => 'application/x-mpegURL',\n        'mpd' => 'application/dash+xml'\n    );\n\n    /**\n     * Directory separator - required by client\n     *\n     * @var string\n     **/\n    protected $separator = DIRECTORY_SEPARATOR;\n\n    /**\n     * Directory separator for decode/encode hash\n     *\n     * @var string\n     **/\n    protected $separatorForHash = '';\n\n    /**\n     * System Root path (Unix like: '/', Windows: '\\', 'C:\\' or 'D:\\'...)\n     *\n     * @var string\n     **/\n    protected $systemRoot = DIRECTORY_SEPARATOR;\n\n    /**\n     * Mimetypes allowed to display\n     *\n     * @var array\n     **/\n    protected $onlyMimes = array();\n\n    /**\n     * Store files moved or overwrited files info\n     *\n     * @var array\n     **/\n    protected $removed = array();\n\n    /**\n     * Store files added files info\n     *\n     * @var array\n     **/\n    protected $added = array();\n\n    /**\n     * Cache storage\n     *\n     * @var array\n     **/\n    protected $cache = array();\n\n    /**\n     * Cache by folders\n     *\n     * @var array\n     **/\n    protected $dirsCache = array();\n\n    /**\n     * You should use `$this->sessionCache['subdirs']` instead\n     *\n     * @var array\n     * @deprecated\n     */\n    protected $subdirsCache = array();\n\n    /**\n     * This volume session cache\n     *\n     * @var array\n     */\n    protected $sessionCache;\n\n    /**\n     * Session caching item list\n     *\n     * @var array\n     */\n    protected $sessionCaching = array('rootstat' => true, 'subdirs' => true);\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * Search start time\n     *\n     * @var int\n     */\n    protected $searchStart;\n\n    /**\n     * Current query word on doSearch\n     *\n     * @var array\n     **/\n    protected $doSearchCurrentQuery = array();\n\n    /**\n     * Is root modified (for clear root stat cache)\n     *\n     * @var bool\n     */\n    protected $rootModified = false;\n\n    /**\n     * Is disable of command `url`\n     *\n     * @var string\n     */\n    protected $disabledGetUrl = false;\n\n    /**\n     * Accepted filename validator\n     *\n     * @var string | callable\n     */\n    protected $nameValidator;\n\n    /**\n     * Accepted dirname validator\n     *\n     * @var string | callable\n     */\n    protected $dirnameValidator;\n\n    /**\n     * This request require online state\n     *\n     * @var boolean\n     */\n    protected $needOnline;\n\n    /*********************************************************************/\n    /*                            INITIALIZATION                         */\n    /*********************************************************************/\n\n    /**\n     * Sets the need online.\n     *\n     * @param  boolean  $state  The state\n     */\n    public function setNeedOnline($state = null)\n    {\n        if ($state !== null) {\n            $this->needOnline = (bool)$state;\n            return;\n        }\n\n        $need = false;\n        $arg = $this->ARGS;\n        $id = $this->id;\n\n        $target = !empty($arg['target'])? $arg['target'] : (!empty($arg['dst'])? $arg['dst'] : '');\n        $targets = !empty($arg['targets'])? $arg['targets'] : array();\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        if ($target && strpos($target, $id) === 0) {\n            $need = true;\n        } else if ($targets) {\n            foreach($targets as $t) {\n                if ($t && strpos($t, $id) === 0) {\n                    $need = true;\n                    break;\n                }\n            }\n        }\n\n        $this->needOnline = $need;\n    }\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function init()\n    {\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     * By default set thumbnails path and image manipulation library.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        // set thumbnails path\n        $path = $this->options['tmbPath'];\n        if ($path) {\n            if (!file_exists($path)) {\n                if (mkdir($path)) {\n                    chmod($path, $this->options['tmbPathMode']);\n                } else {\n                    $path = '';\n                }\n            }\n\n            if (is_dir($path) && is_readable($path)) {\n                $this->tmbPath = $path;\n                $this->tmbPathWritable = is_writable($path);\n            }\n        }\n        // set resouce path\n        if (!is_dir($this->options['resourcePath'])) {\n            $this->options['resourcePath'] = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'resources';\n        }\n\n        // set image manipulation library\n        $type = preg_match('/^(imagick|gd|convert|auto|none)$/i', $this->options['imgLib'])\n            ? strtolower($this->options['imgLib'])\n            : 'auto';\n\n        if ($type === 'none') {\n            $this->imgLib = '';\n        } else {\n            if (($type === 'imagick' || $type === 'auto') && extension_loaded('imagick')) {\n                $this->imgLib = 'imagick';\n            } else if (($type === 'gd' || $type === 'auto') && function_exists('gd_info')) {\n                $this->imgLib = 'gd';\n            } else {\n                $convertCache = 'imgLibConvert';\n                if (($convertCmd = $this->session->get($convertCache, false)) !== false) {\n                    $this->imgLib = $convertCmd;\n                } else {\n                    $this->imgLib = ($this->procExec(ELFINDER_CONVERT_PATH . ' -version') === 0) ? 'convert' : '';\n                    $this->session->set($convertCache, $this->imgLib);\n                }\n            }\n            if ($type !== 'auto' && $this->imgLib === '') {\n                // fallback\n                $this->imgLib = extension_loaded('imagick') ? 'imagick' : (function_exists('gd_info') ? 'gd' : '');\n            }\n        }\n\n        // check video to img converter\n        if (!empty($this->options['imgConverter']) && is_array($this->options['imgConverter'])) {\n            foreach ($this->options['imgConverter'] as $_type => $_converter) {\n                if (isset($_converter['func'])) {\n                    $this->imgConverter[strtolower($_type)] = $_converter;\n                }\n            }\n        }\n        if (!isset($this->imgConverter['video'])) {\n            $videoLibCache = 'videoLib';\n            if (($videoLibCmd = $this->session->get($videoLibCache, false)) === false) {\n                $videoLibCmd = ($this->procExec(ELFINDER_FFMPEG_PATH . ' -version') === 0) ? 'ffmpeg' : '';\n                $this->session->set($videoLibCache, $videoLibCmd);\n            }\n            if ($videoLibCmd) {\n                $this->imgConverter['video'] = array(\n                    'func' => array($this, $videoLibCmd . 'ToImg'),\n                    'maxlen' => $this->options['tmbVideoConvLen']\n                );\n            }\n        }\n\n        // check onetimeUrl\n        if (strtolower($this->options['onetimeUrl']) === 'auto') {\n            $this->options['onetimeUrl'] = elFinder::getStaticVar('commonTempPath')? true : false;\n        }\n\n        // check archivers\n        if (empty($this->archivers['create'])) {\n            $this->disabled[] = 'archive';\n        }\n        if (empty($this->archivers['extract'])) {\n            $this->disabled[] = 'extract';\n        }\n        $_arc = $this->getArchivers();\n        if (empty($_arc['create'])) {\n            $this->disabled[] = 'zipdl';\n        }\n\n        if ($this->options['maxArcFilesSize']) {\n            $this->options['maxArcFilesSize'] = elFinder::getIniBytes('', $this->options['maxArcFilesSize']);\n        }\n        self::$maxArcFilesSize = $this->options['maxArcFilesSize'];\n\n        // check 'statOwner' for command `chmod`\n        if (empty($this->options['statOwner'])) {\n            $this->disabled[] = 'chmod';\n        }\n\n        // check 'mimeMap'\n        if (!is_array($this->options['mimeMap'])) {\n            $this->options['mimeMap'] = array();\n        }\n        if (is_array($this->options['staticMineMap']) && $this->options['staticMineMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['staticMineMap']);\n        }\n        if (is_array($this->options['additionalMimeMap']) && $this->options['additionalMimeMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['additionalMimeMap']);\n        }\n\n        // check 'url' in disabled commands\n        if (in_array('url', $this->disabled)) {\n            $this->disabledGetUrl = true;\n        }\n\n        // set run time setting uploadOverwrite\n        $this->uploadOverwrite = $this->options['uploadOverwrite'];\n    }\n\n    /**\n     * @deprecated\n     */\n    protected function sessionRestart()\n    {\n        $this->sessionCache = $this->session->start()->get($this->id, array());\n        return true;\n    }\n\n    /*********************************************************************/\n    /*                              PUBLIC API                           */\n    /*********************************************************************/\n\n    /**\n     * Return driver id. Used as a part of volume id.\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function driverId()\n    {\n        return $this->driverId;\n    }\n\n    /**\n     * Return volume id\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function id()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Assign elFinder session wrapper object\n     *\n     * @param  $session  elFinderSessionInterface\n     */\n    public function setSession($session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Get elFinder sesson wrapper object\n     *\n     * @return object  The session object\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Save session cache data\n     * Calls this function before umount this volume on elFinder::exec()\n     *\n     * @return void\n     */\n    public function saveSessionCache()\n    {\n        $this->session->set($this->id, $this->sessionCache);\n    }\n\n    /**\n     * Return debug info for client\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function debug()\n    {\n        return array(\n            'id' => $this->id(),\n            'name' => strtolower(substr(get_class($this), strlen('elfinderdriver'))),\n            'mimeDetect' => $this->mimeDetect,\n            'imgLib' => $this->imgLib\n        );\n    }\n\n    /**\n     * chmod a file or folder\n     *\n     * @param  string $hash file or folder hash to chmod\n     * @param  string $mode octal string representing new permissions\n     *\n     * @return array|false\n     * @author David Bartle\n     **/\n    public function chmod($hash, $mode)\n    {\n        if ($this->commandDisabled('chmod')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$this->options['allowChmodReadOnly']) {\n            if (!$this->attr($this->decode($hash), 'write', null, ($file['mime'] === 'directory'))) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $write = $file['write'];\n\n        if ($this->convEncOut(!$this->_chmod($this->convEncIn($path), $mode))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n        }\n\n        $this->clearstatcache();\n        if ($path == $this->root) {\n            $this->rootModified = true;\n        }\n\n        if ($file = $this->stat($path)) {\n            $files = array($file);\n            if ($file['mime'] === 'directory' && $write !== $file['write']) {\n                foreach ($this->getScandir($path) as $stat) {\n                    if ($this->mimeAccepted($stat['mime'])) {\n                        $files[] = $stat;\n                    }\n                }\n            }\n            return $files;\n        } else {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n    }\n\n    /**\n     * stat a file or folder for elFinder cmd exec\n     *\n     * @param  string $hash file or folder hash to chmod\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function fstat($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path);\n    }\n\n    /**\n     * Clear PHP stat cache & all of inner stat caches\n     */\n    public function clearstatcache()\n    {\n        clearstatcache();\n        $this->clearcache();\n    }\n\n    /**\n     * Clear inner stat caches for target hash\n     *\n     * @param string $hash\n     */\n    public function clearcaches($hash = null)\n    {\n        if ($hash === null) {\n            $this->clearcache();\n        } else {\n            $path = $this->decode($hash);\n            unset($this->cache[$path], $this->dirsCache[$path]);\n        }\n    }\n\n    /**\n     * \"Mount\" volume.\n     * Return true if volume available for read or write,\n     * false - otherwise\n     *\n     * @param array $opts\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    public function mount(array $opts)\n    {\n        $this->options = array_merge($this->options, $opts);\n\n        if (!isset($this->options['path']) || $this->options['path'] === '') {\n            return $this->setError('Path undefined.');\n        }\n\n        if (!$this->session) {\n            return $this->setError('Session wrapper dose not set. Need to `$volume->setSession(elFinderSessionInterface);` before mount.');\n        }\n        if (!($this->session instanceof elFinderSessionInterface)) {\n            return $this->setError('Session wrapper instance must be \"elFinderSessionInterface\".');\n        }\n\n        // set driverId\n        if (!empty($this->options['driverId'])) {\n            $this->driverId = $this->options['driverId'];\n        }\n\n        $this->id = $this->driverId . (!empty($this->options['id']) ? $this->options['id'] : elFinder::$volumesCnt++) . '_';\n        $this->root = $this->normpathCE($this->options['path']);\n        $this->separator = isset($this->options['separator']) ? $this->options['separator'] : DIRECTORY_SEPARATOR;\n        if (!empty($this->options['winHashFix'])) {\n            $this->separatorForHash = ($this->separator !== '/') ? '/' : '';\n        }\n        $this->systemRoot = isset($this->options['systemRoot']) ? $this->options['systemRoot'] : $this->separator;\n\n        // set ARGS\n        $this->ARGS = $_SERVER['REQUEST_METHOD'] === 'POST' ? $_POST : $_GET;\n\n        $argInit = !empty($this->ARGS['init']);\n\n        // set $this->needOnline\n        if (!is_bool($this->needOnline)) {\n            $this->setNeedOnline();\n        }\n\n        // session cache\n        if ($argInit) {\n            $this->session->set($this->id, array());\n        }\n        $this->sessionCache = $this->session->get($this->id, array());\n\n        // default file attribute\n        $this->defaults = array(\n            'read' => isset($this->options['defaults']['read']) ? !!$this->options['defaults']['read'] : true,\n            'write' => isset($this->options['defaults']['write']) ? !!$this->options['defaults']['write'] : true,\n            'locked' => isset($this->options['defaults']['locked']) ? !!$this->options['defaults']['locked'] : false,\n            'hidden' => isset($this->options['defaults']['hidden']) ? !!$this->options['defaults']['hidden'] : false\n        );\n\n        // root attributes\n        $this->attributes[] = array(\n            'pattern' => '~^' . preg_quote($this->separator) . '$~',\n            'locked' => true,\n            'hidden' => false\n        );\n        // set files attributes\n        if (!empty($this->options['attributes']) && is_array($this->options['attributes'])) {\n\n            foreach ($this->options['attributes'] as $a) {\n                // attributes must contain pattern and at least one rule\n                if (!empty($a['pattern']) || (is_array($a) && count($a) > 1)) {\n                    $this->attributes[] = $a;\n                }\n            }\n        }\n\n        if (!empty($this->options['accessControl']) && is_callable($this->options['accessControl'])) {\n            $this->access = $this->options['accessControl'];\n        }\n\n        $this->today = mktime(0, 0, 0, date('m'), date('d'), date('Y'));\n        $this->yesterday = $this->today - 86400;\n\n        if (!$this->init()) {\n            return false;\n        }\n\n        // set server encoding\n        if (!empty($this->options['encoding']) && strtoupper($this->options['encoding']) !== 'UTF-8') {\n            $this->encoding = $this->options['encoding'];\n        } else {\n            $this->encoding = null;\n        }\n\n        // check some options is arrays\n        $this->uploadAllow = isset($this->options['uploadAllow']) && is_array($this->options['uploadAllow'])\n            ? $this->options['uploadAllow']\n            : array();\n\n        $this->uploadDeny = isset($this->options['uploadDeny']) && is_array($this->options['uploadDeny'])\n            ? $this->options['uploadDeny']\n            : array();\n\n        $this->options['uiCmdMap'] = (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))\n            ? $this->options['uiCmdMap']\n            : array();\n\n        if (is_string($this->options['uploadOrder'])) { // telephat_mode on, compatibility with 1.x\n            $parts = explode(',', isset($this->options['uploadOrder']) ? $this->options['uploadOrder'] : 'deny,allow');\n            $this->uploadOrder = array(trim($parts[0]), trim($parts[1]));\n        } else { // telephat_mode off\n            $this->uploadOrder = !empty($this->options['uploadOrder']) ? $this->options['uploadOrder'] : array('deny', 'allow');\n        }\n\n        if (!empty($this->options['uploadMaxSize'])) {\n            $this->uploadMaxSize = elFinder::getIniBytes('', $this->options['uploadMaxSize']);\n        }\n        // Set maximum to PHP_INT_MAX\n        if (!defined('PHP_INT_MAX')) {\n            define('PHP_INT_MAX', 2147483647);\n        }\n        if ($this->uploadMaxSize < 1 || $this->uploadMaxSize > PHP_INT_MAX) {\n            $this->uploadMaxSize = PHP_INT_MAX;\n        }\n\n        // Set to get maximum size to 50% of memory_limit\n        $memLimit = elFinder::getIniBytes('memory_limit') / 2;\n        if ($memLimit > 0) {\n            $this->getMaxSize = empty($this->options['getMaxSize']) ? $memLimit : min($memLimit, elFinder::getIniBytes('', $this->options['getMaxSize']));\n        } else {\n            $this->getMaxSize = -1;\n        }\n\n        $this->disabled = isset($this->options['disabled']) && is_array($this->options['disabled'])\n            ? array_values(array_diff($this->options['disabled'], array('open'))) // 'open' is required\n            : array();\n\n        $this->cryptLib = $this->options['cryptLib'];\n        $this->mimeDetect = $this->options['mimeDetect'];\n\n        // find available mimetype detect method\n        $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n        $auto_types = [];\n\n        if (class_exists('finfo', false)) {\n            $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n             if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $auto_types[] = 'finfo';\n            }\n        }\n        \n        if (function_exists('mime_content_type')) {\n            $_mimetypes = explode(';', mime_content_type(__FILE__));\n            if (preg_match($regexp, array_shift($_mimetypes))) {\n                $auto_types[] = 'mime_content_type';\n            }\n        }\n            \n        $auto_types[] = 'internal';\n\n        $type = strtolower($this->options['mimeDetect']);\n        if (!in_array($type, $auto_types)) {\n            $type = 'auto';\n        }\n\n        if ($type == 'auto') {\n            $type = array_shift($auto_types);\n        }\n\n        $this->mimeDetect = $type;\n\n        if ($this->mimeDetect == 'finfo') {\n            $this->finfo = finfo_open(FILEINFO_MIME);\n        } else if ($this->mimeDetect == 'internal' && !elFinderVolumeDriver::$mimetypesLoaded) {\n            // load mimes from external file for mimeDetect == 'internal'\n            // based on Alexey Sukhotin idea and patch: http://elrte.org/redmine/issues/163\n            // file must be in file directory or in parent one\n            elFinderVolumeDriver::loadMimeTypes(!empty($this->options['mimefile']) ? $this->options['mimefile'] : '');\n        }\n        $this->rootName = empty($this->options['alias']) ? $this->basenameCE($this->root) : $this->options['alias'];\n\n        // This get's triggered if $this->root == '/' and alias is empty.\n        // Maybe modify _basename instead?\n        if ($this->rootName === '') $this->rootName = $this->separator;\n\n        $this->_checkArchivers();\n\n        $root = $this->stat($this->root);\n\n        if (!$root) {\n            return $this->setError('Root folder does not exist.');\n        }\n        if (!$root['read'] && !$root['write']) {\n            return $this->setError('Root folder has not read and write permissions.');\n        }\n\n        if ($root['read']) {\n            if ($argInit) {\n                // check startPath - path to open by default instead of root\n                $startPath = $this->options['startPath'] ? $this->normpathCE($this->options['startPath']) : '';\n                if ($startPath) {\n                    $start = $this->stat($startPath);\n                    if (!empty($start)\n                        && $start['mime'] == 'directory'\n                        && $start['read']\n                        && empty($start['hidden'])\n                        && $this->inpathCE($startPath, $this->root)) {\n                        $this->startPath = $startPath;\n                        if (substr($this->startPath, -1, 1) == $this->options['separator']) {\n                            $this->startPath = substr($this->startPath, 0, -1);\n                        }\n                    }\n                }\n            }\n        } else {\n            $this->options['URL'] = '';\n            $this->options['tmbURL'] = '';\n            $this->options['tmbPath'] = '';\n            // read only volume\n            array_unshift($this->attributes, array(\n                'pattern' => '/.*/',\n                'read' => false\n            ));\n        }\n        $this->treeDeep = $this->options['treeDeep'] > 0 ? (int)$this->options['treeDeep'] : 1;\n        $this->tmbSize = $this->options['tmbSize'] > 0 ? (int)$this->options['tmbSize'] : 48;\n        $this->URL = $this->options['URL'];\n        if ($this->URL && preg_match(\"|[^/?&=]$|\", $this->URL)) {\n            $this->URL .= '/';\n        }\n\n        $dirUrlOwn = strtolower($this->options['dirUrlOwn']);\n        if ($dirUrlOwn === 'auto') {\n            $this->options['dirUrlOwn'] = $this->URL ? false : true;\n        } else if ($dirUrlOwn === 'hide') {\n            $this->options['dirUrlOwn'] = 'hide';\n        } else {\n            $this->options['dirUrlOwn'] = (bool)$this->options['dirUrlOwn'];\n        }\n\n        $this->tmbURL = !empty($this->options['tmbURL']) ? $this->options['tmbURL'] : '';\n        if ($this->tmbURL && $this->tmbURL !== 'self' && preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n            $this->tmbURL .= '/';\n        }\n\n        $this->nameValidator = !empty($this->options['acceptedName']) && (is_string($this->options['acceptedName']) || is_callable($this->options['acceptedName']))\n            ? $this->options['acceptedName']\n            : '';\n\n        $this->dirnameValidator = !empty($this->options['acceptedDirname']) && (is_callable($this->options['acceptedDirname']) || (is_string($this->options['acceptedDirname']) && preg_match($this->options['acceptedDirname'], '') !== false))\n            ? $this->options['acceptedDirname']\n            : $this->nameValidator;\n\n        // enabling archivers['create'] with options['useRemoteArchive']\n        if ($this->options['useRemoteArchive'] && empty($this->archivers['create']) && $this->getTempPath()) {\n            $_archivers = $this->getArchivers();\n            $this->archivers['create'] = $_archivers['create'];\n        }\n\n        // manual control archive types to create\n        if (!empty($this->options['archiveMimes']) && is_array($this->options['archiveMimes'])) {\n            foreach ($this->archivers['create'] as $mime => $v) {\n                if (!in_array($mime, $this->options['archiveMimes'])) {\n                    unset($this->archivers['create'][$mime]);\n                }\n            }\n        }\n\n        // manualy add archivers\n        if (!empty($this->options['archivers']['create']) && is_array($this->options['archivers']['create'])) {\n            foreach ($this->options['archivers']['create'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['create'][$mime])) {\n                    $this->archivers['create'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['archivers']['extract']) && is_array($this->options['archivers']['extract'])) {\n            foreach ($this->options['archivers']['extract'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['extract'][$mime])) {\n                    $this->archivers['extract'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['noSessionCache']) && is_array($this->options['noSessionCache'])) {\n            foreach ($this->options['noSessionCache'] as $_key) {\n                $this->sessionCaching[$_key] = false;\n                unset($this->sessionCache[$_key]);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            if (!isset($this->sessionCache['subdirs'])) {\n                $this->sessionCache['subdirs'] = array();\n            }\n        }\n\n\n        $this->configure();\n\n        // Normalize disabled (array_merge`for type array of JSON)\n        $this->disabled = array_values(array_unique($this->disabled));\n\n        // fix sync interval\n        if ($this->options['syncMinMs'] !== 0) {\n            $this->options['syncMinMs'] = max($this->options[$this->options['syncChkAsTs'] ? 'tsPlSleep' : 'lsPlSleep'] * 1000, intval($this->options['syncMinMs']));\n        }\n\n        // ` copyJoin` is required for the trash function\n        if ($this->options['trashHash'] && empty($this->options['copyJoin'])) {\n            $this->options['trashHash'] = '';\n        }\n\n        // set tmpLinkPath\n        if (elFinder::$tmpLinkPath && !$this->options['tmpLinkPath']) {\n            if (is_writeable(elFinder::$tmpLinkPath)) {\n                $this->options['tmpLinkPath'] = elFinder::$tmpLinkPath;\n            } else {\n                elFinder::$tmpLinkPath = '';\n            }\n        }\n        if ($this->options['tmpLinkPath'] && is_writable($this->options['tmpLinkPath'])) {\n            $this->tmpLinkPath = realpath($this->options['tmpLinkPath']);\n        } else if (!$this->tmpLinkPath && $this->tmbURL && $this->tmbPath) {\n            $this->tmpLinkPath = $this->tmbPath;\n            $this->options['tmpLinkUrl'] = $this->tmbURL;\n        } else if (!$this->options['URL'] && is_writable('../files/.tmb')) {\n            $this->tmpLinkPath = realpath('../files/.tmb');\n            $this->options['tmpLinkUrl'] = '';\n            if (!elFinder::$tmpLinkPath) {\n                elFinder::$tmpLinkPath = $this->tmpLinkPath;\n                elFinder::$tmpLinkUrl = '';\n            }\n        }\n\n        // set tmpLinkUrl\n        if (elFinder::$tmpLinkUrl && !$this->options['tmpLinkUrl']) {\n            $this->options['tmpLinkUrl'] = elFinder::$tmpLinkUrl;\n        }\n        if ($this->options['tmpLinkUrl']) {\n            $this->tmpLinkUrl = $this->options['tmpLinkUrl'];\n        }\n        if ($this->tmpLinkPath && !$this->tmpLinkUrl) {\n            $cur = realpath('./');\n            $i = 0;\n            while ($cur !== $this->systemRoot && strpos($this->tmpLinkPath, $cur) !== 0) {\n                $i++;\n                $cur = dirname($cur);\n            }\n            list($req) = explode('?', $_SERVER['REQUEST_URI']);\n            $reqs = explode('/', dirname($req));\n            $uri = join('/', array_slice($reqs, 0, count($reqs) - 1)) . substr($this->tmpLinkPath, strlen($cur));\n            $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n            $this->tmpLinkUrl = ($https ? 'https://' : 'http://')\n                . $_SERVER['SERVER_NAME'] // host\n                . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n                . $uri;\n            if (!elFinder::$tmpLinkUrl) {\n                elFinder::$tmpLinkUrl = $this->tmpLinkUrl;\n            }\n        }\n\n        // remove last '/'\n        if ($this->tmpLinkPath) {\n            $this->tmpLinkPath = rtrim($this->tmpLinkPath, '/');\n        }\n        if ($this->tmpLinkUrl) {\n            $this->tmpLinkUrl = rtrim($this->tmpLinkUrl, '/');\n        }\n\n        // to update options cache\n        if (isset($this->sessionCache['rootstat'])) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n        $this->updateCache($this->root, $root);\n\n        return $this->mounted = true;\n    }\n\n    /**\n     * Some \"unmount\" stuffs - may be required by virtual fs\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n    }\n\n    /**\n     * Remove session cache of this volume\n     */\n    public function clearSessionCache()\n    {\n        $this->sessionCache = array();\n    }\n\n    /**\n     * Return error message from last failed action\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        return $this->error;\n    }\n\n    /**\n     * Return is uploadable that given file name\n     *\n     * @param  string $name file name\n     * @param  bool   $allowUnknown\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function isUploadableByName($name, $allowUnknown = false)\n    {\n        $mimeByName = $this->mimetype($name, true);\n        return (($allowUnknown && $mimeByName === 'unknown') || $this->allowPutMime($mimeByName));\n    }\n\n    /**\n     * Return Extention/MIME Table (elFinderVolumeDriver::$mimetypes)\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    public function getMimeTable()\n    {\n        // load mime.types\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        return elFinderVolumeDriver::$mimetypes;\n    }\n\n    /**\n     * Return file extention detected by MIME type\n     *\n     * @param  string $mime   MIME type\n     * @param  string $suffix Additional suffix\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getExtentionByMime($mime, $suffix = '')\n    {\n        static $extTable = null;\n\n        if (is_null($extTable)) {\n            $extTable = array_flip(array_unique($this->getMimeTable()));\n            foreach ($this->options['mimeMap'] as $pair => $_mime) {\n                list($ext) = explode(':', $pair);\n                if ($ext !== '*' && !isset($extTable[$_mime])) {\n                    $extTable[$_mime] = $ext;\n                }\n            }\n        }\n\n        if ($mime && isset($extTable[$mime])) {\n            return $suffix ? ($extTable[$mime] . $suffix) : $extTable[$mime];\n        }\n        return '';\n    }\n\n    /**\n     * Set mimetypes allowed to display to client\n     *\n     * @param  array $mimes\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function setMimesFilter($mimes)\n    {\n        if (is_array($mimes)) {\n            $this->onlyMimes = $mimes;\n        }\n    }\n\n    /**\n     * Return root folder hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function root()\n    {\n        return $this->encode($this->root);\n    }\n\n    /**\n     * Return root path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function getRootPath()\n    {\n        return $this->root;\n    }\n\n    /**\n     * Return target path hash\n     *\n     * @param  string $path\n     * @param  string $name\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getHash($path, $name = '')\n    {\n        if ($name !== '') {\n            $path = $this->joinPathCE($path, $name);\n        }\n        return $this->encode($path);\n    }\n\n    /**\n     * Return decoded path of target hash\n     * This method do not check the stat of target\n     * Use method `realpath()` to do check of the stat of target\n     *\n     * @param  string $hash\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getPath($hash)\n    {\n        return $this->decode($hash);\n    }\n\n    /**\n     * Return root or startPath hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function defaultPath()\n    {\n        return $this->encode($this->startPath ? $this->startPath : $this->root);\n    }\n\n    /**\n     * Return volume options required by client:\n     *\n     * @param $hash\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    public function options($hash)\n    {\n        $create = $createext = array();\n        if (isset($this->archivers['create']) && is_array($this->archivers['create'])) {\n            foreach ($this->archivers['create'] as $m => $v) {\n                $create[] = $m;\n                $createext[$m] = $v['ext'];\n            }\n        }\n        $opts = array(\n            'path' => $hash ? $this->path($hash) : '',\n            'url' => $this->URL,\n            'tmbUrl' => (!$this->imgLib && $this->options['tmbFbSelf']) ? 'self' : $this->tmbURL,\n            'disabled' => $this->disabled,\n            'separator' => $this->separator,\n            'copyOverwrite' => intval($this->options['copyOverwrite']),\n            'uploadOverwrite' => intval($this->options['uploadOverwrite']),\n            'uploadMaxSize' => intval($this->uploadMaxSize),\n            'uploadMaxConn' => intval($this->options['uploadMaxConn']),\n            'uploadMime' => array(\n                'firstOrder' => isset($this->uploadOrder[0]) ? $this->uploadOrder[0] : 'deny',\n                'allow' => $this->uploadAllow,\n                'deny' => $this->uploadDeny\n            ),\n            'dispInlineRegex' => $this->options['dispInlineRegex'],\n            'jpgQuality' => intval($this->options['jpgQuality']),\n            'archivers' => array(\n                'create' => $create,\n                'extract' => isset($this->archivers['extract']) && is_array($this->archivers['extract']) ? array_keys($this->archivers['extract']) : array(),\n                'createext' => $createext\n            ),\n            'uiCmdMap' => (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap'])) ? $this->options['uiCmdMap'] : array(),\n            'syncChkAsTs' => intval($this->options['syncChkAsTs']),\n            'syncMinMs' => intval($this->options['syncMinMs']),\n            'i18nFolderName' => intval($this->options['i18nFolderName']),\n            'tmbCrop' => intval($this->options['tmbCrop']),\n            'tmbReqCustomData' => (bool)$this->options['tmbReqCustomData'],\n            'substituteImg' => (bool)$this->options['substituteImg'],\n            'onetimeUrl' => (bool)$this->options['onetimeUrl'],\n        );\n        if (!empty($this->options['trashHash'])) {\n            $opts['trashHash'] = $this->options['trashHash'];\n        }\n        if ($hash === null) {\n            // call from getRootStatExtra()\n            if (!empty($this->options['icon'])) {\n                $opts['icon'] = $this->options['icon'];\n            }\n            if (!empty($this->options['rootCssClass'])) {\n                $opts['csscls'] = $this->options['rootCssClass'];\n            }\n            if (isset($this->options['netkey'])) {\n                $opts['netkey'] = $this->options['netkey'];\n            }\n        }\n        return $opts;\n    }\n\n    /**\n     * Get option value of this volume\n     *\n     * @param string $name target option name\n     *\n     * @return NULL|mixed   target option value\n     * @author Naoki Sawada\n     */\n    public function getOption($name)\n    {\n        return isset($this->options[$name]) ? $this->options[$name] : null;\n    }\n\n    /**\n     * Get plugin values of this options\n     *\n     * @param string $name Plugin name\n     *\n     * @return NULL|array   Plugin values\n     * @author Naoki Sawada\n     */\n    public function getOptionsPlugin($name = '')\n    {\n        if ($name) {\n            return isset($this->options['plugin'][$name]) ? $this->options['plugin'][$name] : array();\n        } else {\n            return $this->options['plugin'];\n        }\n    }\n\n    /**\n     * Return true if command disabled in options\n     *\n     * @param  string $cmd command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandDisabled($cmd)\n    {\n        return in_array($cmd, $this->disabled);\n    }\n\n    /**\n     * Return true if mime is required mimes list\n     *\n     * @param  string    $mime  mime type to check\n     * @param  array     $mimes allowed mime types list or not set to use client mimes list\n     * @param  bool|null $empty what to return on empty list\n     *\n     * @return bool|null\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function mimeAccepted($mime, $mimes = null, $empty = true)\n    {\n        $mimes = is_array($mimes) ? $mimes : $this->onlyMimes;\n        if (empty($mimes)) {\n            return $empty;\n        }\n        return $mime == 'directory'\n            || in_array('all', $mimes)\n            || in_array('All', $mimes)\n            || in_array($mime, $mimes)\n            || in_array(substr($mime, 0, strpos($mime, '/')), $mimes);\n    }\n\n    /**\n     * Return true if voume is readable.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function isReadable()\n    {\n        $stat = $this->stat($this->root);\n        return $stat['read'];\n    }\n\n    /**\n     * Return true if copy from this volume allowed\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function copyFromAllowed()\n    {\n        return !!$this->options['copyFrom'];\n    }\n\n    /**\n     * Return file path related to root with convert encoging\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function path($hash)\n    {\n        return $this->convEncOut($this->_path($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Return file real path if file exists\n     *\n     * @param  string $hash file hash\n     *\n     * @return string | false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path) ? $path : false;\n    }\n\n    /**\n     * Return list of moved/overwrited files\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function removed()\n    {\n        if ($this->removed) {\n            $unsetSubdir = isset($this->sessionCache['subdirs']) ? true : false;\n            foreach ($this->removed as $item) {\n                if ($item['mime'] === 'directory') {\n                    $path = $this->decode($item['hash']);\n                    if ($unsetSubdir) {\n                        unset($this->sessionCache['subdirs'][$path]);\n                    }\n                    if ($item['phash'] !== '') {\n                        $parent = $this->decode($item['phash']);\n                        unset($this->cache[$parent]);\n                        if ($this->root === $parent) {\n                            $this->sessionCache['rootstat'] = array();\n                        }\n                        if ($unsetSubdir) {\n                            unset($this->sessionCache['subdirs'][$parent]);\n                        }\n                    }\n                }\n            }\n            $this->removed = array_values($this->removed);\n        }\n        return $this->removed;\n    }\n\n    /**\n     * Return list of added files\n     *\n     * @deprecated\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function added()\n    {\n        return $this->added;\n    }\n\n    /**\n     * Clean removed files list\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function resetRemoved()\n    {\n        $this->resetResultStat();\n    }\n\n    /**\n     * Clean added/removed files list\n     *\n     * @return void\n     **/\n    public function resetResultStat()\n    {\n        $this->removed = array();\n        $this->added = array();\n    }\n\n    /**\n     * Return file/dir hash or first founded child hash with required attr == $val\n     *\n     * @param  string $hash file hash\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function closest($hash, $attr, $val)\n    {\n        return ($path = $this->closestByAttr($this->decode($hash), $attr, $val)) ? $this->encode($path) : false;\n    }\n\n    /**\n     * Return file info or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @internal param bool $realpath add realpath field to file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function file($hash)\n    {\n        $file = $this->stat($this->decode($hash));\n\n        return ($file) ? $file : $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n    }\n\n    /**\n     * Return folder info\n     *\n     * @param  string $hash folder hash\n     * @param bool    $resolveLink\n     *\n     * @return array|false\n     * @internal param bool $hidden return hidden file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function dir($hash, $resolveLink = false)\n    {\n        if (($dir = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_DIR_NOT_FOUND);\n        }\n\n        if ($resolveLink && !empty($dir['thash'])) {\n            $dir = $this->file($dir['thash']);\n        }\n\n        return $dir && $dir['mime'] == 'directory' && empty($dir['hidden'])\n            ? $dir\n            : $this->setError(elFinder::ERROR_NOT_DIR);\n    }\n\n    /**\n     * Return directory content or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function scandir($hash)\n    {\n        if (($dir = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $path = $this->decode($hash);\n        if ($res = $dir['read']\n            ? $this->getScandir($path)\n            : $this->setError(elFinder::ERROR_PERM_DENIED)) {\n\n            $dirs = null;\n            if ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) {\n                $dirs = $this->sessionCache['subdirs'][$path];\n            }\n            if ($dirs !== null || (isset($dir['dirs']) && $dir['dirs'] != 1)) {\n                $_dir = $dir;\n                if ($dirs || $this->subdirs($hash)) {\n                    $dir['dirs'] = 1;\n                } else {\n                    unset($dir['dirs']);\n                }\n                if ($dir !== $_dir) {\n                    $this->updateCache($path, $dir);\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  string $hash file hash\n     * @param null    $intersect\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     */\n    public function ls($hash, $intersect = null)\n    {\n        if (($dir = $this->dir($hash)) == false || !$dir['read']) {\n            return false;\n        }\n\n        $list = array();\n        $path = $this->decode($hash);\n\n        $check = array();\n        if ($intersect) {\n            $check = array_flip($intersect);\n        }\n\n        foreach ($this->getScandir($path) as $stat) {\n            if (empty($stat['hidden']) && (!$check || isset($check[$stat['name']])) && $this->mimeAccepted($stat['mime'])) {\n                $list[$stat['hash']] = $stat['name'];\n            }\n        }\n\n        return $list;\n    }\n\n    /**\n     * Return subfolders for required folder or false on error\n     *\n     * @param  string $hash    folder hash or empty string to get tree from root folder\n     * @param  int    $deep    subdir deep\n     * @param  string $exclude dir hash which subfolders must be exluded from result, required to not get stat twice on cwd subfolders\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tree($hash = '', $deep = 0, $exclude = '')\n    {\n        $path = $hash ? $this->decode($hash) : $this->root;\n\n        if (($dir = $this->stat($path)) == false || $dir['mime'] != 'directory') {\n            return false;\n        }\n\n        $dirs = $this->gettree($path, $deep > 0 ? $deep - 1 : $this->treeDeep - 1, $exclude ? $this->decode($exclude) : null);\n        array_unshift($dirs, $dir);\n        return $dirs;\n    }\n\n    /**\n     * Return part of dirs tree from required dir up to root dir\n     *\n     * @param  string    $hash   directory hash\n     * @param  bool|null $lineal only lineal parents\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function parents($hash, $lineal = false)\n    {\n        if (($current = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $args = func_get_args();\n        // checks 3rd param `$until` (elFinder >= 2.1.24)\n        $until = '';\n        if (isset($args[2])) {\n            $until = $args[2];\n        }\n\n        $path = $this->decode($hash);\n        $tree = array();\n\n        while ($path && $path != $this->root) {\n            elFinder::checkAborted();\n            $path = $this->dirnameCE($path);\n            if (!($stat = $this->stat($path)) || !empty($stat['hidden']) || !$stat['read']) {\n                return false;\n            }\n\n            array_unshift($tree, $stat);\n            if (!$lineal) {\n                foreach ($this->gettree($path, 0) as $dir) {\n                    elFinder::checkAborted();\n                    if (!isset($tree[$dir['hash']])) {\n                        $tree[$dir['hash']] = $dir;\n                    }\n                }\n            }\n\n            if ($until && $until === $this->encode($path)) {\n                break;\n            }\n        }\n\n        return $tree ? array_values($tree) : array($current);\n    }\n\n    /**\n     * Create thumbnail for required file and return its name or false on failed\n     *\n     * @param $hash\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function tmb($hash)\n    {\n        $path = $this->decode($hash);\n        $stat = $this->stat($path);\n\n        if (isset($stat['tmb'])) {\n            $res = $stat['tmb'] == \"1\" ? $this->createTmb($path, $stat) : $stat['tmb'];\n            if (!$res) {\n                list($type) = explode('/', $stat['mime']);\n                $fallback = $this->options['resourcePath'] . DIRECTORY_SEPARATOR . strtolower($type) . '.png';\n                if (is_file($fallback)) {\n                    $res = $this->tmbname($stat);\n                    if (!copy($fallback, $this->tmbPath . DIRECTORY_SEPARATOR . $res)) {\n                        $res = false;\n                    }\n                }\n            }\n            // tmb garbage collection\n            if ($res && $this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                $rand = mt_rand(1, 10000);\n                if ($rand <= $this->options['tmbGcPercentage'] * 100) {\n                    register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmbPath . DIRECTORY_SEPARATOR . '*.png', $this->options['tmbGcMaxlifeHour'] * 3600);\n                }\n            }\n            return $res;\n        }\n        return false;\n    }\n\n    /**\n     * Return file size / total directory size\n     *\n     * @param  string   file hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function size($hash)\n    {\n        return $this->countSize($this->decode($hash));\n    }\n\n    /**\n     * Open file for reading and return file pointer\n     *\n     * @param  string   file hash\n     *\n     * @return Resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function open($hash)\n    {\n        if (($file = $this->file($hash)) == false\n            || $file['mime'] == 'directory') {\n            return false;\n        }\n        // check extra option for network stream pointer\n        if (func_num_args() > 1) {\n            $opts = func_get_arg(1);\n        } else {\n            $opts = array();\n        }\n        return $this->fopenCE($this->decode($hash), 'rb', $opts);\n    }\n\n    /**\n     * Close file pointer\n     *\n     * @param  Resource $fp   file pointer\n     * @param  string   $hash file hash\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function close($fp, $hash)\n    {\n        $this->fcloseCE($fp, $this->decode($hash));\n    }\n\n    /**\n     * Create directory and return dir info\n     *\n     * @param  string $dsthash destination directory hash\n     * @param  string $name    directory name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkdir($dsthash, $name)\n    {\n        if ($this->commandDisabled('mkdir')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, true)) {\n            return $this->setError(elFinder::ERROR_INVALID_DIRNAME);\n        }\n\n        if (($dir = $this->dir($dsthash)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dsthash);\n        }\n\n        $path = $this->decode($dsthash);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, true)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $dst = $this->joinPathCE($path, $name);\n        $stat = $this->isNameExists($dst);\n        if (!empty($stat)) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n        $this->clearcache();\n\n        $mkpath = $this->convEncOut($this->_mkdir($this->convEncIn($path), $this->convEncIn($name)));\n        if ($mkpath) {\n            $this->clearstatcache();\n            $this->updateSubdirsCache($path, true);\n            $this->updateSubdirsCache($mkpath, false);\n        }\n\n        return $mkpath ? $this->stat($mkpath) : false;\n    }\n\n    /**\n     * Create empty file and return its info\n     *\n     * @param  string $dst  destination directory\n     * @param  string $name file name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkfile($dst, $name)\n    {\n        if ($this->commandDisabled('mkfile')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = $this->mimetype($name, true);\n        if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        $path = $this->decode($dst);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, false)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->isNameExists($this->joinPathCE($path, $name))) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($path = $this->convEncOut($this->_mkfile($this->convEncIn($path), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Rename file and return file info\n     *\n     * @param  string $hash file hash\n     * @param  string $name new file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rename($hash, $name)\n    {\n        if ($this->commandDisabled('rename')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($name === $file['name']) {\n            return $file;\n        }\n\n        if (!empty($this->options['netkey']) && !empty($file['isroot'])) {\n            // change alias of netmount root\n            $rootKey = $this->getRootstatCachekey();\n            // delete old cache data\n            if ($this->sessionCaching['rootstat']) {\n                unset($this->sessionCaching['rootstat'][$rootKey]);\n            }\n            if (elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $name)) {\n                $this->clearcache();\n                $this->rootName = $this->options['alias'] = $name;\n                return $this->stat($this->root);\n            } else {\n                return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, $name);\n            }\n        }\n\n        if (!empty($file['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $file['name']);\n        }\n\n        $isDir = ($file['mime'] === 'directory');\n\n        if (!$this->nameAccepted($name, $isDir)) {\n            return $this->setError($isDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$isDir) {\n            $mimeByName = $this->mimetype($name, true);\n            if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $stat = $this->isNameExists($this->joinPathCE($dir, $name));\n        if ($stat) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $this->rmTmb($file); // remove old name tmbs, we cannot do this after dir move\n\n\n        if ($path = $this->convEncOut($this->_move($this->convEncIn($path), $this->convEncIn($dir), $this->convEncIn($name)))) {\n            $this->clearcache();\n            return $this->stat($path);\n        }\n        return false;\n    }\n\n    /**\n     * Create file copy with suffix \"copy number\" and return its info\n     *\n     * @param  string $hash   file hash\n     * @param  string $suffix suffix to add to file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function duplicate($hash, $suffix = 'copy')\n    {\n        if ($this->commandDisabled('duplicate')) {\n            return $this->setError(elFinder::ERROR_COPY, '#' . $hash, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_COPY, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $name = $this->uniqueName($dir, $file['name'], sprintf($this->options['duplicateSuffix'], $suffix));\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        return ($path = $this->copy($path, $dir, $name)) == false\n            ? false\n            : $this->stat($path);\n    }\n\n    /**\n     * Save uploaded file.\n     * On success return array with new file stat and with removed file hash (if existed file was replaced)\n     *\n     * @param  Resource $fp      file pointer\n     * @param  string   $dst     destination folder hash\n     * @param           $name\n     * @param  string   $tmpname file tmp name - required to detect mime type\n     * @param  array    $hashes  exists files hash array with filename as key\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $src file name\n     * @author   Dmitry (dio) Levashov\n     */\n    public function upload($fp, $dst, $name, $tmpname, $hashes = array())\n    {\n        if ($this->commandDisabled('upload')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (empty($dir['write'])) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = '';\n        if ($this->mimeDetect === 'internal') {\n            $mime = $this->mimetype($tmpname, $name);\n        } else {\n            $mime = $this->mimetype($tmpname, $name);\n            $mimeByName = $this->mimetype($name, true);\n            if ($mime === 'unknown') {\n                $mime = $mimeByName;\n            }\n        }\n\n        if (!$this->allowPutMime($mime) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, '(' . $mime . ')');\n        }\n\n        $tmpsize = (int)sprintf('%u', filesize($tmpname));\n        if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        $dstpath = $this->decode($dst);\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $file = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($dstpath, $name);\n            $file = $this->isNameExists($test);\n        }\n\n        $this->clearcache();\n\n        if ($file && $file['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->uploadOverwrite) {\n                if (!$file['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                } elseif ($file['mime'] == 'directory') {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $name);\n                }\n                $this->remove($test);\n            } else {\n                $name = $this->uniqueName($dstpath, $name, '-', false);\n            }\n        }\n\n        $stat = array(\n            'mime' => $mime,\n            'width' => 0,\n            'height' => 0,\n            'size' => $tmpsize);\n\n        // $w = $h = 0;\n        if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) {\n            $stat['width'] = $s[0];\n            $stat['height'] = $s[1];\n        }\n        // $this->clearcache();\n        if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) {\n            return false;\n        }\n\n        $stat = $this->stat($path);\n        // Try get URL\n        if (empty($stat['url']) && ($url = $this->getContentUrl($stat['hash']))) {\n            $stat['url'] = $url;\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Paste files\n     *\n     * @param  Object $volume source volume\n     * @param         $src\n     * @param  string $dst    destination dir hash\n     * @param  bool   $rmSrc  remove source after copy?\n     * @param array   $hashes\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $source file hash\n     * @author   Dmitry (dio) Levashov\n     */\n    public function paste($volume, $src, $dst, $rmSrc = false, $hashes = array())\n    {\n        $err = $rmSrc ? elFinder::ERROR_MOVE : elFinder::ERROR_COPY;\n\n        if ($this->commandDisabled('paste')) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $volume->file($src, $rmSrc)) == false) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $name = $file['name'];\n        $errpath = $volume->path($file['hash']);\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError($err, $errpath, elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (!$dir['write'] || !$file['read']) {\n            return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        $destination = $this->decode($dst);\n\n        if (($test = $volume->closest($src, $rmSrc ? 'locked' : 'read', $rmSrc))) {\n            return $rmSrc\n                ? $this->setError($err, $errpath, elFinder::ERROR_LOCKED, $volume->path($test))\n                : $this->setError($err, $errpath, empty($file['thash']) ? elFinder::ERROR_PERM_DENIED : elFinder::ERROR_MKOUTLINK);\n        }\n\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $stat = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($destination, $name);\n            $stat = $this->isNameExists($test);\n        }\n        $this->clearcache();\n        $dstDirExists = false;\n        if ($stat && $stat['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->options['copyOverwrite']) {\n                // do not replace file with dir or dir with file\n                if (!$this->isSameType($file['mime'], $stat['mime'])) {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $this->path($stat['hash']));\n                }\n                // existed file is not writable\n                if (empty($stat['write'])) {\n                    return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n                }\n                if ($this->options['copyJoin']) {\n                    if (!empty($stat['locked'])) {\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                } else {\n                    // existed file locked or has locked child\n                    if (($locked = $this->closestByAttr($test, 'locked', true))) {\n                        $stat = $this->stat($locked);\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                }\n                // target is entity file of alias\n                if ($volume === $this && ((isset($file['target']) && $test == $file['target']) || $test == $this->decode($src))) {\n                    return $this->setError(elFinder::ERROR_REPLACE, $errpath);\n                }\n                // remove existed file\n                if (!$this->options['copyJoin'] || $stat['mime'] !== 'directory') {\n                    if (!$this->remove($test)) {\n                        return $this->setError(elFinder::ERROR_REPLACE, $this->path($stat['hash']));\n                    }\n                } else if ($stat['mime'] === 'directory') {\n                    $dstDirExists = true;\n                }\n            } else {\n                $name = $this->uniqueName($destination, $name, ' ', false);\n            }\n        }\n\n        // copy/move inside current volume\n        if ($volume === $this) { //  changing == operand to === fixes issue #1285 - Paul Canning 24/03/2016\n            $source = $this->decode($src);\n            // do not copy into itself\n            if ($this->inpathCE($destination, $source)) {\n                return $this->setError(elFinder::ERROR_COPY_ITSELF, $errpath);\n            }\n            $rmDir = false;\n            if ($rmSrc) {\n                if ($dstDirExists) {\n                    $rmDir = true;\n                    $method = 'copy';\n                } else {\n                    $method = 'move';\n                }\n            } else {\n                $method = 'copy';\n            }\n            $this->clearcache();\n            if ($res = ($path = $this->$method($source, $destination, $name)) ? $this->stat($path) : false) {\n                if ($rmDir) {\n                    $this->remove($source);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            // copy/move from another volume\n            if (!$this->options['copyTo'] || !$volume->copyFromAllowed()) {\n                return $this->setError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n            }\n\n            $this->error = array();\n            if (($path = $this->copyFrom($volume, $src, $destination, $name)) == false) {\n                return false;\n            }\n\n            if ($rmSrc && !$this->error()) {\n                if (!$volume->rm($src)) {\n                    if ($volume->file($src)) {\n                        $this->addError(elFinder::ERROR_RM_SRC);\n                    } else {\n                        $this->removed[] = $file;\n                    }\n                }\n            }\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Return path info array to archive of target items\n     *\n     * @param  array $hashes\n     *\n     * @return array|false\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    public function zipdl($hashes)\n    {\n        if ($this->commandDisabled('zipdl')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $archivers = $this->getArchivers();\n        $cmd = null;\n        if (!$archivers || empty($archivers['create'])) {\n            return false;\n        }\n        $archivers = $archivers['create'];\n        if (!$archivers) {\n            return false;\n        }\n        $file = $mime = '';\n        foreach (array('zip', 'tgz') as $ext) {\n            $mime = $this->mimetype('file.' . $ext, true);\n            if (isset($archivers[$mime])) {\n                $cmd = $archivers[$mime];\n                break;\n            }\n        }\n        if (!$cmd) {\n            $cmd = array_shift($archivers);\n            if (!empty($ext)) {\n                $mime = $this->mimetype('file.' . $ext, true);\n            }\n        }\n        $ext = $cmd['ext'];\n        $res = false;\n        $mixed = false;\n        $hashes = array_values($hashes);\n        $dirname = dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[0])));\n        $cnt = count($hashes);\n        if ($cnt > 1) {\n            for ($i = 1; $i < $cnt; $i++) {\n                if ($dirname !== dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[$i])))) {\n                    $mixed = true;\n                    break;\n                }\n            }\n        }\n        if ($mixed || $this->root == $this->dirnameCE($this->decode($hashes[0]))) {\n            $prefix = $this->rootName;\n        } else {\n            $prefix = basename($dirname);\n        }\n        if ($dir = $this->getItemsInHand($hashes)) {\n            $tmppre = (substr(PHP_OS, 0, 3) === 'WIN') ? 'zd-' : 'elfzdl-';\n            $pdir = dirname($dir);\n            // garbage collection (expire 2h)\n            register_shutdown_function(array('elFinder', 'GlobGC'), $pdir . DIRECTORY_SEPARATOR . $tmppre . '*', 7200);\n            $files = self::localScandir($dir);\n            if ($files && ($arc = tempnam($dir, $tmppre))) {\n                unlink($arc);\n                $arc = $arc . '.' . $ext;\n                $name = basename($arc);\n                if ($arc = $this->makeArchive($dir, $files, $name, $cmd)) {\n                    $file = tempnam($pdir, $tmppre);\n                    unlink($file);\n                    $res = rename($arc, $file);\n                    $this->rmdirRecursive($dir);\n                }\n            }\n        }\n        return $res ? array('path' => $file, 'ext' => $ext, 'mime' => $mime, 'prefix' => $prefix) : false;\n    }\n\n    /**\n     * Return file contents\n     *\n     * @param  string $hash file hash\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function getContents($hash)\n    {\n        $file = $this->file($hash);\n\n        if (!$file) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($file['mime'] == 'directory') {\n            return $this->setError(elFinder::ERROR_NOT_FILE);\n        }\n\n        if (!$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->getMaxSize > 0 && $file['size'] > $this->getMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        return $file['size'] ? $this->_getContents($this->convEncIn($this->decode($hash), true)) : '';\n    }\n\n    /**\n     * Put content in text file and return file info.\n     *\n     * @param  string $hash    file hash\n     * @param  string $content new file content\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function putContents($hash, $content)\n    {\n        if ($this->commandDisabled('edit')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        // check data cheme\n        if (preg_match('~^\\0data:(.+?/.+?);base64,~', $content, $m)) {\n            $dMime = $m[1];\n            if ($file['size'] > 0 && $dMime !== $file['mime']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $content = base64_decode(substr($content, strlen($m[0])));\n        }\n\n        // check MIME\n        $name = $this->basenameCE($path);\n        $mime = '';\n        $mimeByName = $this->mimetype($name, true);\n        if ($this->mimeDetect !== 'internal') {\n            if ($tp = $this->tmpfile()) {\n                fwrite($tp, $content);\n                $info = stream_get_meta_data($tp);\n                $filepath = $info['uri'];\n                $mime = $this->mimetype($filepath, $name);\n                fclose($tp);\n            }\n        }\n        if (!$this->allowPutMime($mimeByName) || ($mime && !$this->allowPutMime($mime))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($this->convEncOut($this->_filePutContents($this->convEncIn($path), $content))) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $hash archive hash\n     * @param null    $makedir\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    public function extract($hash, $makedir = null)\n    {\n        if ($this->commandDisabled('extract')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $archiver = isset($this->archivers['extract'][$file['mime']])\n            ? $this->archivers['extract'][$file['mime']]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_NOT_ARCHIVE);\n        }\n\n        $path = $this->decode($hash);\n        $parent = $this->stat($this->dirnameCE($path));\n\n        if (!$file['read'] || !$parent['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n        $this->clearcache();\n        $this->extractToNewdir = is_null($makedir) ? 'auto' : (bool)$makedir;\n\n        if ($path = $this->convEncOut($this->_extract($this->convEncIn($path), $archiver))) {\n            if (is_array($path)) {\n                foreach ($path as $_k => $_p) {\n                    $path[$_k] = $this->stat($_p);\n                }\n            } else {\n                $path = $this->stat($path);\n            }\n            return $path;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Add files to archive\n     *\n     * @param        $hashes\n     * @param        $mime\n     * @param string $name\n     *\n     * @return array|bool\n     * @throws Exception\n     */\n    public function archive($hashes, $mime, $name = '')\n    {\n        if ($this->commandDisabled('archive')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($name !== '' && !$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $archiver = isset($this->archivers['create'][$mime])\n            ? $this->archivers['create'][$mime]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_ARCHIVE_TYPE);\n        }\n\n        $files = array();\n        $useRemoteArchive = !empty($this->options['useRemoteArchive']);\n\n        $dir = '';\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                return $this->setError(elFinder::ERROR_FILE_NOT_FOUND, '#' . $hash);\n            }\n            if (!$file['read']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $path = $this->decode($hash);\n            if ($dir === '') {\n                $dir = $this->dirnameCE($path);\n                $stat = $this->stat($dir);\n                if (!$stat['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                }\n            }\n\n            $files[] = $useRemoteArchive ? $hash : $this->basenameCE($path);\n        }\n\n        if ($name === '') {\n            $name = count($files) == 1 ? $files[0] : 'Archive';\n        } else {\n            $name = str_replace(array('/', '\\\\'), '_', preg_replace('/\\.' . preg_quote($archiver['ext'], '/') . '$/i', '', $name));\n        }\n        $name .= '.' . $archiver['ext'];\n        $name = $this->uniqueName($dir, $name, '');\n        $this->clearcache();\n        if ($useRemoteArchive) {\n            return ($path = $this->remoteArchive($files, $name, $archiver)) ? $this->stat($path) : false;\n        } else {\n            return ($path = $this->convEncOut($this->_archive($this->convEncIn($dir), $this->convEncIn($files), $this->convEncIn($name), $archiver))) ? $this->stat($path) : false;\n        }\n    }\n\n    /**\n     * Create an archive from remote items\n     *\n     * @param      array  $hashes files hashes list\n     * @param      string $name   archive name\n     * @param      array  $arc    archiver options\n     *\n     * @return     string|boolean  path of created archive\n     * @throws     Exception\n     */\n    protected function remoteArchive($hashes, $name, $arc)\n    {\n        $resPath = false;\n        $file0 = $this->file($hashes[0]);\n        if ($file0 && ($dir = $this->getItemsInHand($hashes))) {\n            $files = self::localScandir($dir);\n            if ($files) {\n                if ($arc = $this->makeArchive($dir, $files, $name, $arc)) {\n                    if ($fp = fopen($arc, 'rb')) {\n                        $fstat = stat($arc);\n                        $stat = array(\n                            'size' => $fstat['size'],\n                            'ts' => $fstat['mtime'],\n                            'mime' => $this->mimetype($arc, $name)\n                        );\n                        $path = $this->decode($file0['phash']);\n                        $resPath = $this->saveCE($fp, $path, $name, $stat);\n                        fclose($fp);\n                    }\n                }\n            }\n            $this->rmdirRecursive($dir);\n        }\n        return $resPath;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $hash       image file\n     * @param  int    $width      new width\n     * @param  int    $height     new height\n     * @param  int    $x          X start poistion for crop\n     * @param  int    $y          Y start poistion for crop\n     * @param  string $mode       action how to mainpulate image\n     * @param  string $bg         background color\n     * @param  int    $degree     rotete degree\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    public function resize($hash, $width, $height, $x, $y, $mode = 'resize', $bg = '', $degree = 0, $jpgQuality = null)\n    {\n        if ($this->commandDisabled('resize')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($mode === 'rotate' && $degree == 0) {\n            return array('losslessRotate' => ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0 || $this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0));\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write'] || !$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        $work_path = $this->getWorkFile($this->encoding ? $this->convEncIn($path, true) : $path);\n\n        if (!$work_path || !is_writable($work_path)) {\n            if ($work_path && $path !== $work_path && is_file($work_path)) {\n                unlink($work_path);\n            }\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n            if (elFinder::isAnimationGif($work_path)) {\n                return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n            }\n        }\n\n        if (elFinder::isAnimationPng($work_path)) {\n            return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n        }\n\n        switch ($mode) {\n\n            case 'propresize':\n                $result = $this->imgResize($work_path, $width, $height, true, true, null, $jpgQuality);\n                break;\n\n            case 'crop':\n                $result = $this->imgCrop($work_path, $width, $height, $x, $y, null, $jpgQuality);\n                break;\n\n            case 'fitsquare':\n                $result = $this->imgSquareFit($work_path, $width, $height, 'center', 'middle', ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            case 'rotate':\n                $result = $this->imgRotate($work_path, $degree, ($bg ? $bg : $this->options['bgColorFb']), null, $jpgQuality);\n                break;\n\n            default:\n                $result = $this->imgResize($work_path, $width, $height, false, true, null, $jpgQuality);\n                break;\n        }\n\n        $ret = false;\n        if ($result) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $fstat = stat($work_path);\n            $imgsize = getimagesize($work_path);\n            if ($path !== $work_path) {\n                $file['size'] = $fstat['size'];\n                $file['ts'] = $fstat['mtime'];\n                if ($imgsize) {\n                    $file['width'] = $imgsize[0];\n                    $file['height'] = $imgsize[1];\n                }\n                if ($fp = fopen($work_path, 'rb')) {\n                    $ret = $this->saveCE($fp, $this->dirnameCE($path), $this->basenameCE($path), $file);\n                    fclose($fp);\n                }\n            } else {\n                $ret = true;\n            }\n            if ($ret) {\n                $this->clearcache();\n                $ret = $this->stat($path);\n                if ($imgsize) {\n                    $ret['width'] = $imgsize[0];\n                    $ret['height'] = $imgsize[1];\n                }\n            }\n        }\n        if ($path !== $work_path) {\n            is_file($work_path) && unlink($work_path);\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Remove file/dir\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rm($hash)\n    {\n        return $this->commandDisabled('rm')\n            ? $this->setError(elFinder::ERROR_PERM_DENIED)\n            : $this->remove($this->decode($hash));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  string $q search string\n     * @param  array  $mimes\n     * @param null    $hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function search($q, $mimes, $hash = null)\n    {\n        $res = array();\n        $matchMethod = null;\n        $args = func_get_args();\n        if (!empty($args[3])) {\n            $matchMethod = 'searchMatch' . $args[3];\n            if (!is_callable(array($this, $matchMethod))) {\n                return array();\n            }\n        }\n\n        $dir = null;\n        if ($hash) {\n            $dir = $this->decode($hash);\n            $stat = $this->stat($dir);\n            if (!$stat || $stat['mime'] !== 'directory' || !$stat['read']) {\n                $q = '';\n            }\n        }\n        if ($mimes && $this->onlyMimes) {\n            $mimes = array_intersect($mimes, $this->onlyMimes);\n            if (!$mimes) {\n                $q = '';\n            }\n        }\n        $this->searchStart = time();\n\n        $qs = preg_split('/\"([^\"]+)\"| +/', $q, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n        $query = $excludes = array();\n        foreach ($qs as $_q) {\n            $_q = trim($_q);\n            if ($_q !== '') {\n                if ($_q[0] === '-') {\n                    if (isset($_q[1])) {\n                        $excludes[] = substr($_q, 1);\n                    }\n                } else {\n                    $query[] = $_q;\n                }\n            }\n        }\n        if (!$query) {\n            $q = '';\n        } else {\n            $q = join(' ', $query);\n            $this->doSearchCurrentQuery = array(\n                'q' => $q,\n                'excludes' => $excludes,\n                'matchMethod' => $matchMethod\n            );\n        }\n\n        if ($q === '' || $this->commandDisabled('search')) {\n            return $res;\n        }\n\n        // valided regex $this->options['searchExDirReg']\n        if ($this->options['searchExDirReg']) {\n            if (false === preg_match($this->options['searchExDirReg'], '')) {\n                $this->options['searchExDirReg'] = '';\n            }\n        }\n\n        // check the leaf root too\n        if (!$mimes && (is_null($dir) || $dir == $this->root)) {\n            $rootStat = $this->stat($this->root);\n            if (!empty($rootStat['phash'])) {\n                if ($this->stripos($rootStat['name'], $q) !== false) {\n                    $res = array($rootStat);\n                }\n            }\n        }\n\n        return array_merge($res, $this->doSearch(is_null($dir) ? $this->root : $dir, $q, $mimes));\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dimensions($hash)\n    {\n        if (($file = $this->file($hash)) == false) {\n            return false;\n        }\n        // Throw additional parameters for some drivers\n        if (func_num_args() > 1) {\n            $args = func_get_arg(1);\n        } else {\n            $args = array();\n        }\n        return $this->convEncOut($this->_dimensions($this->convEncIn($this->decode($hash)), $file['mime'], $args));\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function subdirs($hash)\n    {\n        return (bool)$this->subdirsCE($this->decode($hash));\n    }\n\n    /**\n     * Return content URL (for netmout volume driver)\n     * If file.url == 1 requests from JavaScript client with XHR\n     *\n     * @param string $hash    file hash\n     * @param array  $options options array\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getContentUrl($hash, $options = array())\n    {\n        if (($file = $this->file($hash)) === false) {\n            return false;\n        }\n        if (!empty($options['onetime']) && $this->options['onetimeUrl']) {\n            if (is_callable($this->options['onetimeUrl'])) {\n                return call_user_func_array($this->options['onetimeUrl'], array($file, $options, $this));\n            } else {\n                $ret = false;\n                if ($tmpdir = elFinder::getStaticVar('commonTempPath')) {\n                    if ($source = $this->open($hash)) {\n                        if ($_dat = tempnam($tmpdir, 'ELF')) {\n                            $token = md5($_dat . session_id());\n                            $dat = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $token;\n                            if (rename($_dat, $dat)) {\n                                $info = stream_get_meta_data($source);\n                                if (!empty($info['uri'])) {\n                                    $tmp = $info['uri'];\n                                } else {\n                                    $tmp = tempnam($tmpdir, 'ELF');\n                                    if ($dest = fopen($tmp, 'wb')) {\n                                        if (!stream_copy_to_stream($source, $dest)) {\n                                            $tmp = false;\n                                        }\n                                        fclose($dest);\n                                    }\n                                }\n                                $this->close($source, $hash);\n                                if ($tmp) {\n                                    $info = array(\n                                        'file' => base64_encode($tmp),\n                                        'name' => $file['name'],\n                                        'mime' => $file['mime'],\n                                        'ts' => $file['ts']\n                                    );\n                                    if (file_put_contents($dat, json_encode($info))) {\n                                        $conUrl = elFinder::getConnectorUrl();\n                                        $ret = $conUrl . (strpos($conUrl, '?') !== false? '&' : '?') . 'cmd=file&onetime=1&target=' . $token;\n\n                                    }\n                                }\n                                if (!$ret) {\n                                    unlink($dat);\n                                }\n                            } else {\n                                unlink($_dat);\n                            }\n                        }\n                    }\n                }\n                return $ret;\n            }\n        }\n        if (empty($file['url']) && $this->URL) {\n            $path = str_replace($this->separator, '/', substr($this->decode($hash), strlen(rtrim($this->root, '/' . $this->separator)) + 1));\n            if ($this->encoding) {\n                $path = $this->convEncIn($path, true);\n            }\n            $path = str_replace('%2F', '/', rawurlencode($path));\n            return $this->URL . $path;\n        } else {\n            $ret = false;\n            if (!empty($file['url']) && $file['url'] != 1) {\n                return $file['url'];\n            } else if (!empty($options['temporary']) && ($tempInfo = $this->getTempLinkInfo('temp_' . md5($hash . session_id())))) {\n                if (is_readable($tempInfo['path'])) {\n                    touch($tempInfo['path']);\n                    $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                } else if ($source = $this->open($hash)) {\n                    if ($dest = fopen($tempInfo['path'], 'wb')) {\n                        if (stream_copy_to_stream($source, $dest)) {\n                            $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                        }\n                        fclose($dest);\n                    }\n                    $this->close($source, $hash);\n                }\n            }\n            return $ret;\n        }\n    }\n\n    /**\n     * Get temporary contents link infomation\n     *\n     * @param string $name\n     *\n     * @return boolean|array\n     * @author Naoki Sawada\n     */\n    public function getTempLinkInfo($name = null)\n    {\n        if ($this->tmpLinkPath) {\n            if (!$name) {\n                $name = 'temp_' . md5($_SERVER['REMOTE_ADDR'] . (string)microtime(true));\n            } else if (substr($name, 0, 5) !== 'temp_') {\n                $name = 'temp_' . $name;\n            }\n            register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmpLinkPath . DIRECTORY_SEPARATOR . 'temp_*', elFinder::$tmpLinkLifeTime);\n            return array(\n                'path' => $path = $this->tmpLinkPath . DIRECTORY_SEPARATOR . $name,\n                'url' => $this->tmpLinkUrl . '/' . rawurlencode($name)\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Get URL of substitute image by request args `substitute` or 4th argument $maxSize\n     *\n     * @param string   $target  Target hash\n     * @param array    $srcSize Size info array [width, height]\n     * @param resource $srcfp   Source file file pointer\n     * @param integer  $maxSize Maximum pixel of substitute image\n     *\n     * @return boolean\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getSubstituteImgLink($target, $srcSize, $srcfp = null, $maxSize = null)\n    {\n        $url = false;\n        $file = $this->file($target);\n        $force = !in_array($file['mime'], array('image/jpeg', 'image/png', 'image/gif'));\n        if (!$maxSize) {\n            $args = elFinder::$currentArgs;\n            if (!empty($args['substitute'])) {\n                $maxSize = $args['substitute'];\n            }\n        }\n        if ($maxSize && $srcSize[0] && $srcSize[1]) {\n            if ($this->getOption('substituteImg')) {\n                $maxSize = intval($maxSize);\n                $zoom = min(($maxSize / $srcSize[0]), ($maxSize / $srcSize[1]));\n                if ($force || $zoom < 1) {\n                    $width = round($srcSize[0] * $zoom);\n                    $height = round($srcSize[1] * $zoom);\n                    $jpgQuality = 50;\n                    $preserveExif = false;\n                    $unenlarge = true;\n                    $checkAnimated = true;\n                    $destformat = $file['mime'] === 'image/jpeg'? null : 'png';\n                    if (!$srcfp) {\n                        elFinder::checkAborted();\n                        $srcfp = $this->open($target);\n                    }\n                    if ($srcfp && ($tempLink = $this->getTempLinkInfo())) {\n                        elFinder::checkAborted();\n                        $dest = fopen($tempLink['path'], 'wb');\n                        if ($dest && stream_copy_to_stream($srcfp, $dest)) {\n                            fclose($dest);\n                            if ($this->imageUtil('resize', $tempLink['path'], compact('width', 'height', 'jpgQuality', 'preserveExif', 'unenlarge', 'checkAnimated', 'destformat'))) {\n                                $url = $tempLink['url'];\n                                // set expire to 1 min left\n                                touch($tempLink['path'], time() - elFinder::$tmpLinkLifeTime + 60);\n                            } else {\n                                unlink($tempLink['path']);\n                            }\n                        }\n                        $this->close($srcfp, $target);\n                    }\n                }\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Return temp path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getTempPath()\n    {\n        $tempPath = null;\n        if (isset($this->tmpPath) && $this->tmpPath && is_writable($this->tmpPath)) {\n            $tempPath = $this->tmpPath;\n        } else if (isset($this->tmp) && $this->tmp && is_writable($this->tmp)) {\n            $tempPath = $this->tmp;\n        } else if (elFinder::getStaticVar('commonTempPath') && is_writable(elFinder::getStaticVar('commonTempPath'))) {\n            $tempPath = elFinder::getStaticVar('commonTempPath');\n        } else if (function_exists('sys_get_temp_dir')) {\n            $tempPath = sys_get_temp_dir();\n        } else if ($this->tmbPathWritable) {\n            $tempPath = $this->tmbPath;\n        }\n        if ($tempPath && DIRECTORY_SEPARATOR !== '/') {\n            $tempPath = str_replace('/', DIRECTORY_SEPARATOR, $tempPath);\n        }\n        return $tempPath;\n    }\n\n    /**\n     * (Make &) Get upload taget dirctory hash\n     *\n     * @param string $baseTargetHash\n     * @param string $path\n     * @param array  $result\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getUploadTaget($baseTargetHash, $path, & $result)\n    {\n        $base = $this->decode($baseTargetHash);\n        $targetHash = $baseTargetHash;\n        $path = ltrim($path, $this->separator);\n        $dirs = explode($this->separator, $path);\n        array_pop($dirs);\n        foreach ($dirs as $dir) {\n            $targetPath = $this->joinPathCE($base, $dir);\n            if (!$_realpath = $this->realpath($this->encode($targetPath))) {\n                if ($stat = $this->mkdir($targetHash, $dir)) {\n                    $result['added'][] = $stat;\n                    $targetHash = $stat['hash'];\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            } else {\n                $targetHash = $this->encode($_realpath);\n                if ($this->dir($targetHash)) {\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            }\n        }\n        return $targetHash;\n    }\n\n    /**\n     * Return this uploadMaxSize value\n     *\n     * @return integer\n     * @author Naoki Sawada\n     */\n    public function getUploadMaxSize()\n    {\n        return $this->uploadMaxSize;\n    }\n\n    public function setUploadOverwrite($var)\n    {\n        $this->uploadOverwrite = (bool)$var;\n    }\n\n    /**\n     * Image file utility\n     *\n     * @param string $mode    'resize', 'rotate', 'propresize', 'crop', 'fitsquare'\n     * @param string $src     Image file local path\n     * @param array  $options excute options\n     *\n     * @return bool\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function imageUtil($mode, $src, $options = array())\n    {\n        if (!isset($options['jpgQuality'])) {\n            $options['jpgQuality'] = intval($this->options['jpgQuality']);\n        }\n        if (!isset($options['bgcolor'])) {\n            $options['bgcolor'] = '#ffffff';\n        }\n        if (!isset($options['bgColorFb'])) {\n            $options['bgColorFb'] = $this->options['bgColorFb'];\n        }\n        $destformat = !empty($options['destformat'])? $options['destformat'] : null;\n\n        // check 'width' ,'height'\n        if (in_array($mode, array('resize', 'propresize', 'crop', 'fitsquare'))) {\n            if (empty($options['width']) || empty($options['height'])) {\n                return false;\n            }\n        }\n\n        if (!empty($options['checkAnimated'])) {\n            if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n                if (elFinder::isAnimationGif($src)) {\n                    return false;\n                }\n            }\n            if (elFinder::isAnimationPng($src)) {\n                return false;\n            }\n        }\n\n        switch ($mode) {\n            case 'rotate':\n                if (empty($options['degree'])) {\n                    return true;\n                }\n                return (bool)$this->imgRotate($src, $options['degree'], $options['bgColorFb'], $destformat, $options['jpgQuality']);\n\n            case 'resize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], false, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'propresize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], true, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'crop':\n                if (isset($options['x']) && isset($options['y'])) {\n                    return (bool)$this->imgCrop($src, $options['width'], $options['height'], $options['x'], $options['y'], $destformat, $options['jpgQuality']);\n                }\n                break;\n\n            case 'fitsquare':\n                return (bool)$this->imgSquareFit($src, $options['width'], $options['height'], 'center', 'middle', $options['bgcolor'], $destformat, $options['jpgQuality']);\n\n        }\n        return false;\n    }\n\n    /**\n     * Convert Video To Image by ffmpeg\n     *\n     * @param  string $file video source file path\n     * @param  array  $stat file stat array\n     * @param  object $self volume driver object\n     * @param  int    $ss   start seconds\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function ffmpegToImg($file, $stat, $self, $ss = null)\n    {\n        $name = basename($file);\n        $path = dirname($file);\n        $tmp = $path . DIRECTORY_SEPARATOR . md5($name);\n        // register auto delete on shutdown\n        $GLOBALS['elFinderTempFiles'][$tmp] = true;\n        if (rename($file, $tmp)) {\n            if ($ss === null) {\n                // specific start time by file name (xxx^[sec].[extention] - video^3.mp4)\n                if (preg_match('/\\^(\\d+(?:\\.\\d+)?)\\.[^.]+$/', $stat['name'], $_m)) {\n                    $ss = $_m[1];\n                } else {\n                    $ss = $this->options['tmbVideoConvSec'];\n                }\n            }\n            $cmd = sprintf(ELFINDER_FFMPEG_PATH . ' -i %s -ss 00:00:%.3f -vframes 1 -f image2 -- %s', escapeshellarg($tmp), $ss, escapeshellarg($file));\n            $r = ($this->procExec($cmd) === 0);\n            clearstatcache();\n            if ($r && $ss > 0 && !file_exists($file)) {\n                // Retry by half of $ss\n                $ss = max(intval($ss / 2), 0);\n                rename($tmp, $file);\n                $r = $this->ffmpegToImg($file, $stat, $self, $ss);\n            } else {\n                unlink($tmp);\n            }\n            return $r;\n        }\n        return false;\n    }\n\n    /**\n     * Creates a temporary file and return file pointer\n     *\n     * @return resource|boolean\n     */\n    public function tmpfile()\n    {\n        if ($tmp = $this->getTempFile()) {\n            return fopen($tmp, 'wb');\n        }\n        return false;\n    }\n\n    /**\n     * Save error message\n     *\n     * @param  array  error\n     *\n     * @return boolean false\n     * @author Naoki Sawada\n     **/\n    protected function setError()\n    {\n        $this->error = array();\n        $this->addError(func_get_args());\n        return false;\n    }\n\n    /**\n     * Add error message\n     *\n     * @param  array  error\n     *\n     * @return false\n     * @author Dmitry(dio) Levashov\n     **/\n    protected function addError()\n    {\n        foreach (func_get_args() as $err) {\n            if (is_array($err)) {\n                foreach($err as $er) {\n                    $this->addError($er);\n                }\n            } else {\n                $this->error[] = (string)$err;\n            }\n        }\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /***************** server encoding support *******************/\n\n    /**\n     * Return parent directory path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function dirnameCE($path)\n    {\n        $dirname = (!$this->encoding) ? $this->_dirname($path) : $this->convEncOut($this->_dirname($this->convEncIn($path)));\n        // check to infinite loop prevention\n        return ($dirname != $path) ? $dirname : '';\n    }\n\n    /**\n     * Return file name (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function basenameCE($path)\n    {\n        return (!$this->encoding) ? $this->_basename($path) : $this->convEncOut($this->_basename($this->convEncIn($path)));\n    }\n\n    /**\n     * Join dir name and file name and return full path. (with convert encoding)\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function joinPathCE($dir, $name)\n    {\n        return (!$this->encoding) ? $this->_joinPath($dir, $name) : $this->convEncOut($this->_joinPath($this->convEncIn($dir), $this->convEncIn($name)));\n    }\n\n    /**\n     * Return normalized path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function normpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_normpath($path) : $this->convEncOut($this->_normpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file path related to root dir (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function relpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_relpath($path) : $this->convEncOut($this->_relpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Convert path related to root dir into real path (with convert encoding)\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function abspathCE($path)\n    {\n        return (!$this->encoding) ? $this->_abspath($path) : $this->convEncOut($this->_abspath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return true if $path is children of $parent (with convert encoding)\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function inpathCE($path, $parent)\n    {\n        return (!$this->encoding) ? $this->_inpath($path, $parent) : $this->convEncOut($this->_inpath($this->convEncIn($path), $this->convEncIn($parent)));\n    }\n\n    /**\n     * Open file and return file pointer (with convert encoding)\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Naoki Sawada\n     */\n    protected function fopenCE($path, $mode = 'rb')\n    {\n        // check extra option for network stream pointer\n        if (func_num_args() > 2) {\n            $opts = func_get_arg(2);\n        } else {\n            $opts = array();\n        }\n        return (!$this->encoding) ? $this->_fopen($path, $mode, $opts) : $this->convEncOut($this->_fopen($this->convEncIn($path), $mode, $opts));\n    }\n\n    /**\n     * Close opened file (with convert encoding)\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function fcloseCE($fp, $path = '')\n    {\n        return (!$this->encoding) ? $this->_fclose($fp, $path) : $this->convEncOut($this->_fclose($fp, $this->convEncIn($path)));\n    }\n\n    /**\n     * Create new file and write into it from file pointer. (with convert encoding)\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Naoki Sawada\n     **/\n    protected function saveCE($fp, $dir, $name, $stat)\n    {\n        $res = (!$this->encoding) ? $this->_save($fp, $dir, $name, $stat) : $this->convEncOut($this->_save($fp, $this->convEncIn($dir), $this->convEncIn($name), $this->convEncIn($stat)));\n        if ($res !== false) {\n            $this->clearstatcache();\n        }\n        return $res;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function subdirsCE($path)\n    {\n        if ($this->sessionCaching['subdirs']) {\n            if (isset($this->sessionCache['subdirs'][$path]) && !$this->isMyReload()) {\n                return $this->sessionCache['subdirs'][$path];\n            }\n        }\n        $hasdir = (bool)((!$this->encoding) ? $this->_subdirs($path) : $this->convEncOut($this->_subdirs($this->convEncIn($path))));\n        $this->updateSubdirsCache($path, $hasdir);\n        return $hasdir;\n    }\n\n    /**\n     * Return files list in directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function scandirCE($path)\n    {\n        return (!$this->encoding) ? $this->_scandir($path) : $this->convEncOut($this->_scandir($this->convEncIn($path)));\n    }\n\n    /**\n     * Create symlink (with convert encoding)\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function symlinkCE($source, $targetDir, $name)\n    {\n        return (!$this->encoding) ? $this->_symlink($source, $targetDir, $name) : $this->convEncOut($this->_symlink($this->convEncIn($source), $this->convEncIn($targetDir), $this->convEncIn($name)));\n    }\n\n    /***************** paths *******************/\n\n    /**\n     * Encode path into hash\n     *\n     * @param  string  file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function encode($path)\n    {\n        if ($path !== '') {\n\n            // cut ROOT from $path for security reason, even if hacker decodes the path he will not know the root\n            $p = $this->relpathCE($path);\n            // if reqesting root dir $path will be empty, then assign '/' as we cannot leave it blank for crypt\n            if ($p === '') {\n                $p = $this->separator;\n            }\n            // change separator\n            if ($this->separatorForHash) {\n                $p = str_replace($this->separator, $this->separatorForHash, $p);\n            }\n            // TODO crypt path and return hash\n            $hash = $this->crypt($p);\n            // hash is used as id in HTML that means it must contain vaild chars\n            // make base64 html safe and append prefix in begining\n            $hash = strtr(base64_encode($hash), '+/=', '-_.');\n            // remove dots '.' at the end, before it was '=' in base64\n            $hash = rtrim($hash, '.');\n            // append volume id to make hash unique\n            return $this->id . $hash;\n        }\n        //TODO: Add return statement here\n    }\n\n    /**\n     * Decode path from hash\n     *\n     * @param  string  file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function decode($hash)\n    {\n        if (strpos($hash, $this->id) === 0) {\n            // cut volume id after it was prepended in encode\n            $h = substr($hash, strlen($this->id));\n            // replace HTML safe base64 to normal\n            $h = base64_decode(strtr($h, '-_.', '+/='));\n            // TODO uncrypt hash and return path\n            $path = $this->uncrypt($h);\n            // change separator\n            if ($this->separatorForHash) {\n                $path = str_replace($this->separatorForHash, $this->separator, $path);\n            }\n            // append ROOT to path after it was cut in encode\n            return $this->abspathCE($path);//$this->root.($path === $this->separator ? '' : $this->separator.$path);\n        }\n        return '';\n    }\n\n    /**\n     * Return crypted path\n     * Not implemented\n     *\n     * @param  string  path\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function crypt($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Return uncrypted path\n     * Not implemented\n     *\n     * @param  mixed  hash\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function uncrypt($hash)\n    {\n        return $hash;\n    }\n\n    /**\n     * Validate file name based on $this->options['acceptedName'] regexp or function\n     *\n     * @param  string $name file name\n     * @param  bool   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function nameAccepted($name, $isDir = false)\n    {\n        if (json_encode($name) === false) {\n            return false;\n        }\n        $nameValidator = $isDir ? $this->dirnameValidator : $this->nameValidator;\n        if ($nameValidator) {\n            if (is_callable($nameValidator)) {\n                $res = call_user_func($nameValidator, $name);\n                return $res;\n            }\n            if (preg_match($nameValidator, '') !== false) {\n                return preg_match($nameValidator, $name);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return session rootstat cache key\n     *\n     * @return string\n     */\n    protected function getRootstatCachekey()\n    {\n        return md5($this->root . (isset($this->options['alias']) ? $this->options['alias'] : ''));\n    }\n\n    /**\n     * Return new unique name based on file name and suffix\n     *\n     * @param         $dir\n     * @param         $name\n     * @param  string $suffix suffix append to name\n     * @param bool    $checkNum\n     * @param int     $start\n     *\n     * @return string\n     * @internal param string $path file path\n     * @author   Dmitry (dio) Levashov\n     */\n    public function uniqueName($dir, $name, $suffix = ' copy', $checkNum = true, $start = 1)\n    {\n        static $lasts = null;\n\n        if ($lasts === null) {\n            $lasts = array();\n        }\n\n        $ext = '';\n\n        $splits = elFinder::splitFileExtention($name);\n        if ($splits[1]) {\n            $ext = '.' . $splits[1];\n            $name = $splits[0];\n        }\n\n        if ($checkNum && preg_match('/(' . preg_quote($suffix, '/') . ')(\\d*)$/i', $name, $m)) {\n            $i = (int)$m[2];\n            $name = substr($name, 0, strlen($name) - strlen($m[2]));\n        } else {\n            $i = $start;\n            $name .= $suffix;\n        }\n        $max = $i + 100000;\n\n        if (isset($lasts[$name])) {\n            $i = max($i, $lasts[$name]);\n        }\n\n        while ($i <= $max) {\n            $n = $name . ($i > 0 ? sprintf($this->options['uniqueNumFormat'], $i) : '') . $ext;\n\n            if (!$this->isNameExists($this->joinPathCE($dir, $n))) {\n                $this->clearcache();\n                $lasts[$name] = ++$i;\n                return $n;\n            }\n            $i++;\n        }\n        return $name . md5($dir) . $ext;\n    }\n\n    /**\n     * Converts character encoding from UTF-8 to server's one\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is false\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncIn($var = null, $restoreLocale = false, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, 'UTF-8', $this->encoding, $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding from server's one to UTF-8\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is true\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncOut($var = null, $restoreLocale = true, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, $this->encoding, 'UTF-8', $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding (base function)\n     *\n     * @param  mixed  $var     target string or array var\n     * @param  string $from    from character encoding\n     * @param  string $to      to character encoding\n     * @param  string $locale  local locale\n     * @param         $restoreLocale\n     * @param  string $unknown replaces character for unknown\n     *\n     * @return mixed\n     */\n    protected function convEnc($var, $from, $to, $locale, $restoreLocale, $unknown = '_')\n    {\n        if (strtoupper($from) !== strtoupper($to)) {\n            if ($locale) {\n                setlocale(LC_ALL, $locale);\n            }\n            if (is_array($var)) {\n                $_ret = array();\n                foreach ($var as $_k => $_v) {\n                    $_ret[$_k] = $this->convEnc($_v, $from, $to, '', false, $unknown = '_');\n                }\n                $var = $_ret;\n            } else {\n                $_var = false;\n                if (is_string($var)) {\n                    $_var = $var;\n                    $errlev = error_reporting();\n                    error_reporting($errlev ^ E_NOTICE);\n                    if (false !== ($_var = iconv($from, $to . '//TRANSLIT', $_var))) {\n                        $_var = str_replace('?', $unknown, $_var);\n                    }\n                    error_reporting($errlev);\n                }\n                if ($_var !== false) {\n                    $var = $_var;\n                }\n            }\n            if ($restoreLocale) {\n                setlocale(LC_ALL, elFinder::$locale);\n            }\n        }\n        return $var;\n    }\n\n    /**\n     * Normalize MIME-Type by options['mimeMap']\n     *\n     * @param      string $type MIME-Type\n     * @param      string $name Filename\n     * @param      string $ext  File extention without first dot (optional)\n     *\n     * @return     string  Normalized MIME-Type\n     */\n    public function mimeTypeNormalize($type, $name, $ext = '')\n    {\n        if ($ext === '') {\n            $ext = (false === $pos = strrpos($name, '.')) ? '' : substr($name, $pos + 1);\n        }\n        $_checkKey = strtolower($ext . ':' . $type);\n        if ($type === '') {\n            $_keylen = strlen($_checkKey);\n            foreach ($this->options['mimeMap'] as $_key => $_type) {\n                if (substr($_key, 0, $_keylen) === $_checkKey) {\n                    $type = $_type;\n                    break;\n                }\n            }\n        } else if (isset($this->options['mimeMap'][$_checkKey])) {\n            $type = $this->options['mimeMap'][$_checkKey];\n        } else {\n            $_checkKey = strtolower($ext . ':*');\n            if (isset($this->options['mimeMap'][$_checkKey])) {\n                $type = $this->options['mimeMap'][$_checkKey];\n            } else {\n                $_checkKey = strtolower('*:' . $type);\n                if (isset($this->options['mimeMap'][$_checkKey])) {\n                    $type = $this->options['mimeMap'][$_checkKey];\n                }\n            }\n        }\n        return $type;\n    }\n\n    /*********************** util mainly for inheritance class *********************/\n\n    /**\n     * Get temporary filename. Tempfile will be removed when after script execution finishes or exit() is called.\n     * When needing the unique file to a path, give $path to parameter.\n     *\n     * @param  string $path for get unique file to a path\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     */\n    protected function getTempFile($path = '')\n    {\n        static $cache = array();\n\n        $key = '';\n        if ($path !== '') {\n            $key = $this->id . '#' . $path;\n            if (isset($cache[$key])) {\n                return $cache[$key];\n            }\n        }\n\n        if ($tmpdir = $this->getTempPath()) {\n            $name = tempnam($tmpdir, 'ELF');\n            if ($key) {\n                $cache[$key] = $name;\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$name] = true;\n            return $name;\n        }\n\n        return false;\n    }\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path path need convert encoding to server encoding\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        if ($wfp = $this->tmpfile()) {\n            if ($fp = $this->_fopen($path)) {\n                while (!feof($fp)) {\n                    fwrite($wfp, fread($fp, 8192));\n                }\n                $info = stream_get_meta_data($wfp);\n                fclose($wfp);\n                if ($info && !empty($info['uri'])) {\n                    return $info['uri'];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get image size array with `dimensions`\n     *\n     * @param string $path path need convert encoding to server encoding\n     * @param string $mime file mime type\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getImageSize($path, $mime = '')\n    {\n        $size = false;\n        if ($mime === '' || strtolower(substr($mime, 0, 5)) === 'image') {\n            if ($work = $this->getWorkFile($path)) {\n                if ($size = getimagesize($work)) {\n                    $size['dimensions'] = $size[0] . 'x' . $size[1];\n                    $srcfp = fopen($work, 'rb');\n                    $cArgs = elFinder::$currentArgs;\n                    if (!empty($cArgs['target']) && $subImgLink = $this->getSubstituteImgLink($cArgs['target'], $size, $srcfp)) {\n                        $size['url'] = $subImgLink;\n                    }\n                }\n            }\n            is_file($work) && unlink($work);\n        }\n        return $size;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        foreach ($this->_scandir($localpath) as $p) {\n            elFinder::checkAborted();\n            $stat = $this->stat($this->convEncOut($p));\n            $this->convEncIn();\n            ($stat['mime'] === 'directory') ? $this->delTree($p) : $this->_unlink($p);\n        }\n        $res = $this->_rmdir($localpath);\n        $res && $this->clearstatcache();\n        return $res;\n    }\n\n    /**\n     * Copy items to a new temporary directory on the local server\n     *\n     * @param  array  $hashes  target hashes\n     * @param  string $dir     destination directory (for recurcive)\n     * @param  string $canLink it can use link() (for recurcive)\n     *\n     * @return string|false    saved path name\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function getItemsInHand($hashes, $dir = null, $canLink = null)\n    {\n        static $banChrs = null;\n        static $totalSize = 0;\n\n        if  (is_null($banChrs)) {\n            $banChrs = DIRECTORY_SEPARATOR !== '/'? array('\\\\', '/', ':', '*', '?', '\"', '<', '>', '|') : array('\\\\', '/');\n        }\n\n        if (is_null($dir)) {\n            $totalSize = 0;\n            if (!$tmpDir = $this->getTempPath()) {\n                return false;\n            }\n            $dir = tempnam($tmpDir, 'elf');\n            if (!unlink($dir) || !mkdir($dir, 0700, true)) {\n                return false;\n            }\n            register_shutdown_function(array($this, 'rmdirRecursive'), $dir);\n        }\n        if (is_null($canLink)) {\n            $canLink = ($this instanceof elFinderVolumeLocalFileSystem);\n        }\n        elFinder::checkAborted();\n        $res = true;\n        $files = array();\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                continue;\n            }\n            if (!$file['read']) {\n                continue;\n            }\n\n            $name = $file['name'];\n            // remove ctrl characters\n            $name = preg_replace('/[[:cntrl:]]+/', '', $name);\n            // replace ban characters\n            $name = str_replace($banChrs, '_', $name);\n\n            // for call from search results\n            if (isset($files[$name])) {\n                $name = preg_replace('/^(.*?)(\\..*)?$/', '$1_' . $files[$name]++ . '$2', $name);\n            } else {\n                $files[$name] = 1;\n            }\n            $target = $dir . DIRECTORY_SEPARATOR . $name;\n\n            if ($file['mime'] === 'directory') {\n                $chashes = array();\n                $_files = $this->scandir($hash);\n                foreach ($_files as $_file) {\n                    if ($file['read']) {\n                        $chashes[] = $_file['hash'];\n                    }\n                }\n                if (($res = mkdir($target, 0700, true)) && $chashes) {\n                    $res = $this->getItemsInHand($chashes, $target, $canLink);\n                }\n                if (!$res) {\n                    break;\n                }\n                !empty($file['ts']) && touch($target, $file['ts']);\n            } else {\n                $path = $this->decode($hash);\n                if (!$canLink || !($canLink = $this->localFileSystemSymlink($path, $target))) {\n                    if (file_exists($target)) {\n                        unlink($target);\n                    }\n                    if ($fp = $this->fopenCE($path)) {\n                        if ($tfp = fopen($target, 'wb')) {\n                            $totalSize += stream_copy_to_stream($fp, $tfp);\n                            fclose($tfp);\n                        }\n                        !empty($file['ts']) && touch($target, $file['ts']);\n                        $this->fcloseCE($fp, $path);\n                    }\n                } else {\n                    $totalSize += filesize($path);\n                }\n                if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $totalSize) {\n                    $res = $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n                }\n            }\n        }\n        return $res ? $dir : false;\n    }\n\n    /*********************** file stat *********************/\n\n    /**\n     * Check file attribute\n     *\n     * @param  string $path  file path\n     * @param  string $name  attribute name (read|write|locked|hidden)\n     * @param  bool   $val   attribute value returned by file system\n     * @param  bool   $isDir path is directory (true: directory, false: file)\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function attr($path, $name, $val = null, $isDir = null)\n    {\n        if (!isset($this->defaults[$name])) {\n            return false;\n        }\n\n        $relpath = $this->relpathCE($path);\n        if ($this->separator !== '/') {\n            $relpath = str_replace($this->separator, '/', $relpath);\n        }\n        $relpath = '/' . $relpath;\n\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, $name, $path, $this->options['accessControlData'], $this, $isDir, $relpath);\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        foreach ($this->attributes as $attrs) {\n            if (isset($attrs[$name]) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $relpath)) {\n                $perm = $attrs[$name];\n                break;\n            }\n        }\n\n        return $perm === null ? (is_null($val) ? $this->defaults[$name] : $val) : !!$perm;\n    }\n\n    /**\n     * Return true if file with given name can be created in given folder.\n     *\n     * @param string $dir  parent dir path\n     * @param string $name new file name\n     * @param null   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function allowCreate($dir, $name, $isDir = null)\n    {\n        return $this->attr($this->joinPathCE($dir, $name), 'write', true, $isDir);\n    }\n\n    /**\n     * Return true if file MIME type can save with check uploadOrder config.\n     *\n     * @param string $mime\n     *\n     * @return boolean\n     */\n    protected function allowPutMime($mime)\n    {\n        // logic based on http://httpd.apache.org/docs/2.2/mod/mod_authz_host.html#order\n        $allow = $this->mimeAccepted($mime, $this->uploadAllow, null);\n        $deny = $this->mimeAccepted($mime, $this->uploadDeny, null);\n        if (strtolower($this->uploadOrder[0]) == 'allow') { // array('allow', 'deny'), default is to 'deny'\n            $res = false; // default is deny\n            if (!$deny && ($allow === true)) { // match only allow\n                $res = true;\n            }// else (both match | no match | match only deny) { deny }\n        } else { // array('deny', 'allow'), default is to 'allow' - this is the default rule\n            $res = true; // default is allow\n            if (($deny === true) && !$allow) { // match only deny\n                $res = false;\n            } // else (both match | no match | match only allow) { allow }\n        }\n        return $res;\n    }\n\n    /**\n     * Return fileinfo\n     *\n     * @param  string $path file cache\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function stat($path)\n    {\n        if ($path === false || is_null($path)) {\n            return false;\n        }\n        $is_root = ($path == $this->root);\n        if ($is_root) {\n            $rootKey = $this->getRootstatCachekey();\n            if ($this->sessionCaching['rootstat'] && !isset($this->sessionCache['rootstat'])) {\n                $this->sessionCache['rootstat'] = array();\n            }\n            if (!isset($this->cache[$path]) && !$this->isMyReload()) {\n                // need $path as key for netmount/netunmount\n                if ($this->sessionCaching['rootstat'] && isset($this->sessionCache['rootstat'][$rootKey])) {\n                    if ($ret = $this->sessionCache['rootstat'][$rootKey]) {\n                        if ($this->options['rootRev'] === $ret['rootRev']) {\n                            if (isset($this->options['phash'])) {\n                                $ret['isroot'] = 1;\n                                $ret['phash'] = $this->options['phash'];\n                            }\n                            return $ret;\n                        }\n                    }\n                }\n            }\n        }\n        $rootSessCache = false;\n        if (isset($this->cache[$path])) {\n            $ret = $this->cache[$path];\n        } else {\n            if ($is_root && !empty($this->options['rapidRootStat']) && is_array($this->options['rapidRootStat']) && !$this->needOnline) {\n                $ret = $this->updateCache($path, $this->options['rapidRootStat'], true);\n            } else {\n                $ret = $this->updateCache($path, $this->convEncOut($this->_stat($this->convEncIn($path))), true);\n                if ($is_root && !empty($rootKey) && $this->sessionCaching['rootstat']) {\n                    $rootSessCache = true;\n                }\n            }\n        } \n        if ($is_root) {\n            if ($ret) {\n                $this->rootModified = false;\n                if ($rootSessCache) {\n                    $this->sessionCache['rootstat'][$rootKey] = $ret;\n                }\n                if (isset($this->options['phash'])) {\n                    $ret['isroot'] = 1;\n                    $ret['phash'] = $this->options['phash'];\n                }\n            } else if (!empty($rootKey) && $this->sessionCaching['rootstat']) {\n                unset($this->sessionCache['rootstat'][$rootKey]);\n            }\n        }\n        return $ret;\n    }\n\n    /**\n     * Get root stat extra key values\n     *\n     * @return array stat extras\n     * @author Naoki Sawada\n     */\n    protected function getRootStatExtra()\n    {\n        $stat = array();\n        if ($this->rootName) {\n            $stat['name'] = $this->rootName;\n        }\n        $stat['rootRev'] = $this->options['rootRev'];\n        $stat['options'] = $this->options(null);\n        return $stat;\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array\n     */\n    protected function isNameExists($path)\n    {\n        return $this->stat($path);\n    }\n\n    /**\n     * Put file stat in cache and return it\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function updateCache($path, $stat)\n    {\n        if (empty($stat) || !is_array($stat)) {\n            return $this->cache[$path] = array();\n        }\n\n        if (func_num_args() > 2) {\n            $fromStat = func_get_arg(2);\n        } else {\n            $fromStat = false;\n        }\n\n        $stat['hash'] = $this->encode($path);\n\n        $root = $path == $this->root;\n        $parent = '';\n\n        if ($root) {\n            $stat = array_merge($stat, $this->getRootStatExtra());\n        } else {\n            if (!isset($stat['name']) || $stat['name'] === '') {\n                $stat['name'] = $this->basenameCE($path);\n            }\n            if (empty($stat['phash'])) {\n                $parent = $this->dirnameCE($path);\n                $stat['phash'] = $this->encode($parent);\n            } else {\n                $parent = $this->decode($stat['phash']);\n            }\n        }\n\n        // name check\n        if (isset($stat['name']) && !$jeName = json_encode($stat['name'])) {\n            return $this->cache[$path] = array();\n        }\n        // fix name if required\n        if ($this->options['utf8fix'] && $this->options['utf8patterns'] && $this->options['utf8replace']) {\n            $stat['name'] = json_decode(str_replace($this->options['utf8patterns'], $this->options['utf8replace'], $jeName));\n        }\n\n        if (!isset($stat['size'])) {\n            $stat['size'] = 'unknown';\n        }\n\n        $mime = isset($stat['mime']) ? $stat['mime'] : '';\n        if ($isDir = ($mime === 'directory')) {\n            $stat['volumeid'] = $this->id;\n        } else {\n            if (empty($stat['mime']) || $stat['size'] == 0) {\n                $stat['mime'] = $this->mimetype($stat['name'], true, $stat['size'], $mime);\n            } else {\n                $stat['mime'] = $this->mimeTypeNormalize($stat['mime'], $stat['name']);\n            }\n        }\n\n        $stat['read'] = intval($this->attr($path, 'read', isset($stat['read']) ? !!$stat['read'] : null, $isDir));\n        $stat['write'] = intval($this->attr($path, 'write', isset($stat['write']) ? !!$stat['write'] : null, $isDir));\n        if ($root) {\n            $stat['locked'] = 1;\n            if ($this->options['type'] !== '') {\n                $stat['type'] = $this->options['type'];\n            }\n        } else {\n            // lock when parent directory is not writable\n            if (!isset($stat['locked'])) {\n                $pstat = $this->stat($parent);\n                if (isset($pstat['write']) && !$pstat['write']) {\n                    $stat['locked'] = true;\n                }\n            }\n            if ($this->attr($path, 'locked', isset($stat['locked']) ? !!$stat['locked'] : null, $isDir)) {\n                $stat['locked'] = 1;\n            } else {\n                unset($stat['locked']);\n            }\n        }\n\n        if ($root) {\n            unset($stat['hidden']);\n        } elseif ($this->attr($path, 'hidden', isset($stat['hidden']) ? !!$stat['hidden'] : null, $isDir)\n            || !$this->mimeAccepted($stat['mime'])) {\n            $stat['hidden'] = 1;\n        } else {\n            unset($stat['hidden']);\n        }\n\n        if ($stat['read'] && empty($stat['hidden'])) {\n\n            if ($isDir) {\n                // caching parent's subdirs\n                if ($parent) {\n                    $this->updateSubdirsCache($parent, true);\n                }\n                // for dir - check for subdirs\n                if ($this->options['checkSubfolders']) {\n                    if (!isset($stat['dirs']) && intval($this->options['checkSubfolders']) === -1) {\n                        $stat['dirs'] = -1;\n                    }\n                    if (isset($stat['dirs'])) {\n                        if ($stat['dirs']) {\n                            if ($stat['dirs'] == -1) {\n                                $stat['dirs'] = ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) ? (int)$this->sessionCache['subdirs'][$path] : -1;\n                            } else {\n                                $stat['dirs'] = 1;\n                            }\n                        } else {\n                            unset($stat['dirs']);\n                        }\n                    } elseif (!empty($stat['alias']) && !empty($stat['target'])) {\n                        $stat['dirs'] = isset($this->cache[$stat['target']])\n                            ? intval(isset($this->cache[$stat['target']]['dirs']))\n                            : $this->subdirsCE($stat['target']);\n\n                    } elseif ($this->subdirsCE($path)) {\n                        $stat['dirs'] = 1;\n                    }\n                } else {\n                    $stat['dirs'] = 1;\n                }\n                if ($this->options['dirUrlOwn'] === true) {\n                    // Set `null` to use the client option `commandsOptions.info.nullUrlDirLinkSelf = true`\n                    $stat['url'] = null;\n                } else if ($this->options['dirUrlOwn'] === 'hide') {\n                    // to hide link in info dialog of the elFinder client\n                    $stat['url'] = '';\n                }\n            } else {\n                // for files - check for thumbnails\n                $p = isset($stat['target']) ? $stat['target'] : $path;\n                if ($this->tmbURL && !isset($stat['tmb']) && $this->canCreateTmb($p, $stat)) {\n                    $tmb = $this->gettmb($p, $stat);\n                    $stat['tmb'] = $tmb ? $tmb : 1;\n                }\n\n            }\n            if (!isset($stat['url']) && $this->URL && $this->encoding) {\n                $_path = str_replace($this->separator, '/', substr($path, strlen($this->root) + 1));\n                $stat['url'] = rtrim($this->URL, '/') . '/' . str_replace('%2F', '/', rawurlencode((substr(PHP_OS, 0, 3) === 'WIN') ? $_path : $this->convEncIn($_path, true)));\n            }\n        } else {\n            if ($isDir) {\n                unset($stat['dirs']);\n            }\n        }\n\n        if (!empty($stat['alias']) && !empty($stat['target'])) {\n            $stat['thash'] = $this->encode($stat['target']);\n            //$this->cache[$stat['target']] = $stat;\n            unset($stat['target']);\n        }\n\n        $this->cache[$path] = $stat;\n\n        if (!$fromStat && $root && $this->sessionCaching['rootstat']) {\n            // to update session cache\n            $this->stat($path);\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat for folder content and put in cache\n     *\n     * @param  string $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        foreach ($this->scandirCE($path) as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        $this->updateSubdirsCache($path, $hasDir);\n    }\n\n    /**\n     * Clean cache\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function clearcache()\n    {\n        $this->cache = $this->dirsCache = array();\n    }\n\n    /**\n     * Return file mimetype\n     *\n     * @param  string      $path file path\n     * @param  string|bool $name\n     * @param  integer     $size\n     * @param  string      $mime was notified from the volume driver\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     */\n    protected function mimetype($path, $name = '', $size = null, $mime = null)\n    {\n        $type = '';\n        $nameCheck = false;\n\n        if ($name === '') {\n            $name = $path;\n        } else if ($name === true) {\n            $name = $path;\n            $nameCheck = true;\n        }\n        if (!$this instanceof elFinderVolumeLocalFileSystem) {\n            $nameCheck = true;\n        }\n        $ext = (false === $pos = strrpos($name, '.')) ? '' : strtolower(substr($name, $pos + 1));\n        if (!$nameCheck && $size === null) {\n            $size = file_exists($path) ? filesize($path) : -1;\n        }\n        if (!$nameCheck && is_readable($path) && $size > 0) {\n            // detecting by contents\n            if ($this->mimeDetect === 'finfo') {\n                $type = finfo_file($this->finfo, $path);\n            } else if ($this->mimeDetect === 'mime_content_type') {\n                $type = mime_content_type($path);\n            }\n            if ($type) {\n                $type = explode(';', $type);\n                $type = trim($type[0]);\n                if ($ext && preg_match('~^application/(?:octet-stream|(?:x-)?zip|xml)$~', $type)) {\n                    // load default MIME table file \"mime.types\"\n                    if (!elFinderVolumeDriver::$mimetypesLoaded) {\n                        elFinderVolumeDriver::loadMimeTypes();\n                    }\n                    if (isset(elFinderVolumeDriver::$mimetypes[$ext])) {\n                        $type = elFinderVolumeDriver::$mimetypes[$ext];\n                    }\n                } else if ($ext === 'js' && preg_match('~^text/~', $type)) {\n                    $type = 'text/javascript';\n                }\n            }\n        }\n        if (!$type) {\n            // detecting by filename\n            $type = elFinderVolumeDriver::mimetypeInternalDetect($name);\n            if ($type === 'unknown') {\n                if ($mime) {\n                    $type = $mime;\n                } else {\n                    $type = ($size == 0) ? 'text/plain' : $this->options['mimeTypeUnknown'];\n                }\n            }\n        }\n\n        // mime type normalization\n        $type = $this->mimeTypeNormalize($type, $name, $ext);\n\n        return $type;\n    }\n\n    /**\n     * Load file of mime.types\n     *\n     * @param string $mimeTypesFile The mime types file\n     */\n    static protected function loadMimeTypes($mimeTypesFile = '')\n    {\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::$mimetypesLoaded = true;\n            $file = false;\n            if (!empty($mimeTypesFile) && file_exists($mimeTypesFile)) {\n                $file = $mimeTypesFile;\n            } elseif (elFinder::$defaultMimefile && file_exists(elFinder::$defaultMimefile)) {\n                $file = elFinder::$defaultMimefile;\n            } elseif (file_exists(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types';\n            } elseif (file_exists(dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types';\n            }\n\n            if ($file && file_exists($file)) {\n                $mimecf = file($file);\n\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size; $i++) {\n                            if (!isset(self::$mimetypes[$mime[$i]])) {\n                                self::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Detect file mimetype using \"internal\" method or Loading mime.types with $path = ''\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    static protected function mimetypeInternalDetect($path = '')\n    {\n        // load default MIME table file \"mime.types\"\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        $ext = '';\n        if ($path) {\n            $pinfo = pathinfo($path);\n            $ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';\n        }\n        return ($ext && isset(elFinderVolumeDriver::$mimetypes[$ext])) ? elFinderVolumeDriver::$mimetypes[$ext] : 'unknown';\n    }\n\n    /**\n     * Return file/total directory size infomation\n     *\n     * @param  string $path file path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function countSize($path)\n    {\n\n        elFinder::checkAborted();\n\n        $result = array('size' => 0, 'files' => 0, 'dirs' => 0);\n        $stat = $this->stat($path);\n\n        if (empty($stat) || !$stat['read'] || !empty($stat['hidden'])) {\n            $result['size'] = 'unknown';\n            return $result;\n        }\n\n        if ($stat['mime'] !== 'directory') {\n            $result['size'] = intval($stat['size']);\n            $result['files'] = 1;\n            return $result;\n        }\n\n        $result['dirs'] = 1;\n        $subdirs = $this->options['checkSubfolders'];\n        $this->options['checkSubfolders'] = true;\n        foreach ($this->getScandir($path) as $stat) {\n            if ($isDir = ($stat['mime'] === 'directory' && $stat['read'])) {\n                ++$result['dirs'];\n            } else {\n                ++$result['files'];\n            }\n            $res = $isDir\n                ? $this->countSize($this->decode($stat['hash']))\n                : (isset($stat['size']) ? array('size' => intval($stat['size'])) : array());\n            if (!empty($res['size']) && is_numeric($res['size'])) {\n                $result['size'] += $res['size'];\n            }\n            if (!empty($res['files']) && is_numeric($res['files'])) {\n                $result['files'] += $res['files'];\n            }\n            if (!empty($res['dirs']) && is_numeric($res['dirs'])) {\n                $result['dirs'] += $res['dirs'];\n                --$result['dirs'];\n            }\n        }\n        $this->options['checkSubfolders'] = $subdirs;\n        return $result;\n    }\n\n    /**\n     * Return true if all mimes is directory or files\n     *\n     * @param  string $mime1 mimetype\n     * @param  string $mime2 mimetype\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function isSameType($mime1, $mime2)\n    {\n        return ($mime1 == 'directory' && $mime1 == $mime2) || ($mime1 != 'directory' && $mime2 != 'directory');\n    }\n\n    /**\n     * If file has required attr == $val - return file path,\n     * If dir has child with has required attr == $val - return child path\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function closestByAttr($path, $attr, $val)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return false;\n        }\n\n        $v = isset($stat[$attr]) ? $stat[$attr] : false;\n\n        if ($v == $val) {\n            return $path;\n        }\n\n        return $stat['mime'] == 'directory'\n            ? $this->childsByAttr($path, $attr, $val)\n            : false;\n    }\n\n    /**\n     * Return first found children with required attr == $val\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function childsByAttr($path, $attr, $val)\n    {\n        foreach ($this->scandirCE($path) as $p) {\n            if (($_p = $this->closestByAttr($p, $attr, $val)) != false) {\n                return $_p;\n            }\n        }\n        return false;\n    }\n\n    protected function isMyReload($target = '', $ARGtarget = '')\n    {\n        if ($this->rootModified || (!empty($this->ARGS['cmd']) && $this->ARGS['cmd'] === 'parents')) {\n            return true;\n        }\n        if (!empty($this->ARGS['reload'])) {\n            if ($ARGtarget === '') {\n                $ARGtarget = isset($this->ARGS['target']) ? $this->ARGS['target']\n                    : ((isset($this->ARGS['targets']) && is_array($this->ARGS['targets']) && count($this->ARGS['targets']) === 1) ?\n                        $this->ARGS['targets'][0] : '');\n            }\n            if ($ARGtarget !== '') {\n                $ARGtarget = strval($ARGtarget);\n                if ($target === '') {\n                    return (strpos($ARGtarget, $this->id) === 0);\n                } else {\n                    $target = strval($target);\n                    return ($target === $ARGtarget);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Update subdirs cache data\n     *\n     * @param string $path\n     * @param bool   $subdirs\n     *\n     * @return void\n     */\n    protected function updateSubdirsCache($path, $subdirs)\n    {\n        if (isset($this->cache[$path])) {\n            if ($subdirs) {\n                $this->cache[$path]['dirs'] = 1;\n            } else {\n                unset($this->cache[$path]['dirs']);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            $this->sessionCache['subdirs'][$path] = $subdirs;\n        }\n        if ($this->sessionCaching['rootstat'] && $path == $this->root) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n    }\n\n    /*****************  get content *******************/\n\n    /**\n     * Return required dir's files info.\n     * If onlyMimes is set - return only dirs and files of required mimes\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function getScandir($path)\n    {\n        $files = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                $files[] = $stat;\n            }\n        }\n\n        return $files;\n    }\n\n\n    /**\n     * Return subdirs tree\n     *\n     * @param  string $path parent dir path\n     * @param  int    $deep tree deep\n     * @param string  $exclude\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function gettree($path, $deep, $exclude = '')\n    {\n        $dirs = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            $stat = $this->stat($p);\n\n            if ($stat && empty($stat['hidden']) && $p != $exclude && $stat['mime'] == 'directory') {\n                $dirs[] = $stat;\n                if ($deep > 0 && !empty($stat['dirs'])) {\n                    $dirs = array_merge($dirs, $this->gettree($p, $deep - 1));\n                }\n            }\n        }\n\n        return $dirs;\n    }\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        $result = array();\n        $matchMethod = empty($this->doSearchCurrentQuery['matchMethod']) ? 'searchMatchName' : $this->doSearchCurrentQuery['matchMethod'];\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n\n        foreach ($this->scandirCE($path) as $p) {\n            elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n            if ($timeout && ($this->error || $timeout < time())) {\n                !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n                break;\n            }\n\n\n            $stat = $this->stat($p);\n\n            if (!$stat) { // invalid links\n                continue;\n            }\n\n            if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                continue;\n            }\n\n            $name = $stat['name'];\n\n            if ($this->doSearchCurrentQuery['excludes']) {\n                foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                    if ($this->stripos($name, $exclude) !== false) {\n                        continue 2;\n                    }\n                }\n            }\n\n            if ((!$mimes || $stat['mime'] !== 'directory') && $this->$matchMethod($name, $q, $p) !== false) {\n                $stat['path'] = $this->path($stat['hash']);\n                if ($this->URL && !isset($stat['url'])) {\n                    $path = str_replace($this->separator, '/', substr($p, strlen($this->root) + 1));\n                    if ($this->encoding) {\n                        $path = str_replace('%2F', '/', rawurlencode($this->convEncIn($path, true)));\n                    } else {\n                        $path = str_replace('%2F', '/', rawurlencode($path));\n                    }\n                    $stat['url'] = $this->URL . $path;\n                }\n\n                $result[] = $stat;\n            }\n            if ($stat['mime'] == 'directory' && $stat['read'] && !isset($stat['alias'])) {\n                if (!$this->options['searchExDirReg'] || !preg_match($this->options['searchExDirReg'], $p)) {\n                    $result = array_merge($result, $this->doSearch($p, $q, $mimes));\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**********************  manuipulations  ******************/\n\n    /**\n     * Copy file/recursive copy dir only in current volume.\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name (optionaly)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copy($src, $dst, $name)\n    {\n\n        elFinder::checkAborted();\n\n        $srcStat = $this->stat($src);\n\n        if (!empty($srcStat['thash'])) {\n            $target = $this->decode($srcStat['thash']);\n            if (!$this->inpathCE($target, $this->root)) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']), elFinder::ERROR_MKOUTLINK);\n            }\n            $stat = $this->stat($target);\n            $this->clearcache();\n            return $stat && $this->symlinkCE($target, $dst, $name)\n                ? $this->joinPathCE($dst, $name)\n                : $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n        }\n\n        if ($srcStat['mime'] === 'directory') {\n            $testStat = $this->isNameExists($this->joinPathCE($dst, $name));\n            $this->clearcache();\n\n            if (($testStat && $testStat['mime'] !== 'directory') || (!$testStat && !$testStat = $this->mkdir($this->encode($dst), $name))) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n            }\n\n            $dst = $this->decode($testStat['hash']);\n\n            // start time\n            $stime = microtime(true);\n            foreach ($this->getScandir($src) as $stat) {\n                if (empty($stat['hidden'])) {\n                    // current time\n                    $ctime = microtime(true);\n                    if (($ctime - $stime) > 2) {\n                        $stime = $ctime;\n                        elFinder::checkAborted();\n                    }\n                    $name = $stat['name'];\n                    $_src = $this->decode($stat['hash']);\n                    if (!$this->copy($_src, $dst, $name)) {\n                        $this->remove($dst, true); // fall back\n                        return $this->setError($this->error, elFinder::ERROR_COPY, $this->_path($src));\n                    }\n                }\n            }\n\n            $this->added[] = $testStat;\n\n            return $dst;\n        }\n\n        if ($this->options['copyJoin']) {\n            $test = $this->joinPathCE($dst, $name);\n            if ($this->isNameExists($test)) {\n                $this->remove($test);\n            }\n        }\n        if ($res = $this->convEncOut($this->_copy($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->clearstatcache();\n            $this->added[] = $this->stat($path);\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n    }\n\n    /**\n     * Move file\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function move($src, $dst, $name)\n    {\n        $stat = $this->stat($src);\n        $stat['realpath'] = $src;\n        $this->rmTmb($stat); // can not do rmTmb() after _move()\n        $this->clearcache();\n\n        if ($res = $this->convEncOut($this->_move($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            if ($stat['mime'] === 'directory') {\n                $this->updateSubdirsCache($dst, true);\n            }\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->added[] = $this->stat($path);\n            $this->removed[] = $stat;\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_MOVE, $this->path($stat['hash']));\n    }\n\n    /**\n     * Copy file from another volume.\n     * Return new file path or false.\n     *\n     * @param  Object $volume      source volume\n     * @param  string $src         source file hash\n     * @param  string $destination destination dir path\n     * @param  string $name        file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copyFrom($volume, $src, $destination, $name)\n    {\n\n        elFinder::checkAborted();\n\n        if (($source = $volume->file($src)) == false) {\n            return $this->addError(elFinder::ERROR_COPY, '#' . $src, $volume->error());\n        }\n\n        $srcIsDir = ($source['mime'] === 'directory');\n\n        $errpath = $volume->path($source['hash']);\n\n        $errors = array();\n        try {\n            $thash = $this->encode($destination);\n            elFinder::$instance->trigger('paste.copyfrom', array(&$thash, &$name, '', elFinder::$instance, $this), $errors);\n        } catch (elFinderTriggerException $e) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $errors);\n        }\n\n        if (!$this->nameAccepted($name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $srcIsDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$this->allowCreate($destination, $name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$source['read']) {\n            return $this->addError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($srcIsDir) {\n            $test = $this->isNameExists($this->joinPathCE($destination, $name));\n            $this->clearcache();\n\n            if (($test && $test['mime'] != 'directory') || (!$test && !$test = $this->mkdir($this->encode($destination), $name))) {\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n\n            //$path = $this->joinPathCE($destination, $name);\n            $path = $this->decode($test['hash']);\n\n            foreach ($volume->scandir($src) as $entr) {\n                $this->copyFrom($volume, $entr['hash'], $path, $entr['name']);\n            }\n\n            $this->added[] = $test;\n        } else {\n            // size check\n            if (!isset($source['size']) || $source['size'] > $this->uploadMaxSize) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n            }\n\n            // MIME check\n            $mimeByName = $this->mimetype($source['name'], true);\n            if ($source['mime'] === $mimeByName) {\n                $mimeByName = '';\n            }\n            if (!$this->allowPutMime($source['mime']) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n                return $this->addError(elFinder::ERROR_UPLOAD_FILE_MIME, $errpath);\n            }\n\n            if (strpos($source['mime'], 'image') === 0 && ($dim = $volume->dimensions($src))) {\n                if (is_array($dim)) {\n                    $dim = isset($dim['dim']) ? $dim['dim'] : null;\n                }\n                if ($dim) {\n                    $s = explode('x', $dim);\n                    $source['width'] = $s[0];\n                    $source['height'] = $s[1];\n                }\n            }\n\n            if (($fp = $volume->open($src)) == false\n                || ($path = $this->saveCE($fp, $destination, $name, $source)) == false) {\n                $fp && $volume->close($fp, $src);\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n            $volume->close($fp, $src);\n\n            $this->added[] = $this->stat($path);;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove file/ recursive remove dir\n     *\n     * @param  string $path  file path\n     * @param  bool   $force try to remove even if file locked\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function remove($path, $force = false)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return $this->setError(elFinder::ERROR_RM, $this->relpathCE($path), elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $stat['realpath'] = $path;\n        $this->rmTmb($stat);\n        $this->clearcache();\n\n        if (!$force && !empty($stat['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n        }\n\n        if ($stat['mime'] == 'directory' && empty($stat['thash'])) {\n            $ret = $this->delTree($this->convEncIn($path));\n            $this->convEncOut();\n            if (!$ret) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        } else {\n            if ($this->convEncOut(!$this->_unlink($this->convEncIn($path)))) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n            $this->clearstatcache();\n        }\n\n        $this->removed[] = $stat;\n        return true;\n    }\n\n\n    /************************* thumbnails **************************/\n\n    /**\n     * Return thumbnail file name for required file\n     *\n     * @param  array $stat file stat\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tmbname($stat)\n    {\n        $name = $stat['hash'] . (isset($stat['ts']) ? $stat['ts'] : '') . '.png';\n        if (strlen($name) > 255) {\n            $name = $this->id . md5($stat['hash']) . $stat['ts'] . '.png';\n        }\n        return $name;\n    }\n\n    /**\n     * Return thumnbnail name if exists\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettmb($path, $stat)\n    {\n        if ($this->tmbURL && $this->tmbPath) {\n            // file itself thumnbnail\n            if (strpos($path, $this->tmbPath) === 0) {\n                return basename($path);\n            }\n\n            $name = $this->tmbname($stat);\n            $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n            if (file_exists($tmb)) {\n                if ($this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                    touch($tmb);\n                }\n                return $name;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if thumnbnail for required file can be created\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     * @param  bool   $checkTmbPath\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canCreateTmb($path, $stat, $checkTmbPath = true)\n    {\n        static $gdMimes = null;\n        static $imgmgPS = null;\n        if ($gdMimes === null) {\n            $_mimes = array('image/jpeg', 'image/png', 'image/gif', 'image/x-ms-bmp');\n            if (function_exists('imagecreatefromwebp')) {\n                $_mimes[] = 'image/webp';\n            }\n            $gdMimes = array_flip($_mimes);\n            $imgmgPS = array_flip(array('application/postscript', 'application/pdf'));\n        }\n        if ((!$checkTmbPath || $this->tmbPathWritable)\n            && (!$this->tmbPath || strpos($path, $this->tmbPath) === false) // do not create thumnbnail for thumnbnail\n        ) {\n            $mime = strtolower($stat['mime']);\n            list($type) = explode('/', $mime);\n            if (!empty($this->imgConverter)) {\n                if (isset($this->imgConverter[$mime])) {\n                    return true;\n                }\n                if (isset($this->imgConverter[$type])) {\n                    return true;\n                }\n            }\n            return $this->imgLib\n                && (\n                    ($type === 'image' && ($this->imgLib === 'gd' ? isset($gdMimes[$stat['mime']]) : true))\n                    ||\n                    (ELFINDER_IMAGEMAGICK_PS && isset($imgmgPS[$stat['mime']]) && $this->imgLib !== 'gd')\n                );\n        }\n        return false;\n    }\n\n    /**\n     * Return true if required file can be resized.\n     * By default - the same as canCreateTmb\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canResize($path, $stat)\n    {\n        return $this->canCreateTmb($path, $stat, false);\n    }\n\n    /**\n     * Create thumnbnail and return it's URL on success\n     *\n     * @param  string $path file path\n     * @param         $stat\n     *\n     * @return false|string\n     * @internal param string $mime file mime type\n     * @throws elFinderAbortException\n     * @throws ImagickException\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function createTmb($path, $stat)\n    {\n        if (!$stat || !$this->canCreateTmb($path, $stat)) {\n            return false;\n        }\n\n        $name = $this->tmbname($stat);\n        $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n\n        $maxlength = -1;\n        $imgConverter = null;\n\n        // check imgConverter\n        $mime = strtolower($stat['mime']);\n        list($type) = explode('/', $mime);\n        if (isset($this->imgConverter[$mime])) {\n            $imgConverter = $this->imgConverter[$mime]['func'];\n            if (!empty($this->imgConverter[$mime]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$mime]['maxlen']);\n            }\n        } else if (isset($this->imgConverter[$type])) {\n            $imgConverter = $this->imgConverter[$type]['func'];\n            if (!empty($this->imgConverter[$type]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$type]['maxlen']);\n            }\n        }\n        if ($imgConverter && !is_callable($imgConverter)) {\n            return false;\n        }\n\n        // copy image into tmbPath so some drivers does not store files on local fs\n        if (($src = $this->fopenCE($path, 'rb')) == false) {\n            return false;\n        }\n\n        if (($trg = fopen($tmb, 'wb')) == false) {\n            $this->fcloseCE($src, $path);\n            return false;\n        }\n\n        stream_copy_to_stream($src, $trg, $maxlength);\n\n        $this->fcloseCE($src, $path);\n        fclose($trg);\n\n        // call imgConverter\n        if ($imgConverter) {\n            if (!call_user_func_array($imgConverter, array($tmb, $stat, $this))) {\n                file_exists($tmb) && unlink($tmb);\n                return false;\n            }\n        }\n\n        $result = false;\n\n        $tmbSize = $this->tmbSize;\n\n        if ($this->imgLib === 'imagick') {\n            try {\n                $imagickTest = new imagick($tmb . '[0]');\n                $imagickTest->clear();\n                $imagickTest = true;\n            } catch (Exception $e) {\n                $imagickTest = false;\n            }\n        }\n\n        if (($this->imgLib === 'imagick' && !$imagickTest) || ($s = getimagesize($tmb)) === false) {\n            if ($this->imgLib === 'imagick') {\n                $bgcolor = $this->options['tmbBgColor'];\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                try {\n                    $imagick = new imagick();\n                    $imagick->setBackgroundColor(new ImagickPixel($bgcolor));\n                    $imagick->readImage($this->getExtentionByMime($stat['mime'], ':') . $tmb . '[0]');\n                    try {\n                        $imagick->trimImage(0);\n                    } catch (Exception $e) {\n                    }\n                    $imagick->setImageFormat('png');\n                    $imagick->writeImage($tmb);\n                    $imagick->clear();\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                } catch (Exception $e) {\n                }\n            } else if ($this->imgLib === 'convert') {\n                $convParams = $this->imageMagickConvertPrepare($tmb, 'png', 100, array(), $stat['mime']);\n                $cmd = sprintf('%s -colorspace sRGB -trim -- %s %s', ELFINDER_CONVERT_PATH, $convParams['quotedPath'], $convParams['quotedDstPath']);\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                }\n            }\n            if (!$result) {\n                // fallback imgLib to GD\n                if (function_exists('gd_info') && ($s = getimagesize($tmb))) {\n                    $this->imgLib = 'gd';\n                } else {\n                    file_exists($tmb) && unlink($tmb);\n                    return false;\n                }\n            }\n        }\n\n        /* If image smaller or equal thumbnail size - just fitting to thumbnail square */\n        if ($s[0] <= $tmbSize && $s[1] <= $tmbSize) {\n            $result = $this->imgSquareFit($tmb, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n        } else {\n\n            if ($this->options['tmbCrop']) {\n\n                $result = $tmb;\n                /* Resize and crop if image bigger than thumbnail */\n                if (!(($s[0] > $tmbSize && $s[1] <= $tmbSize) || ($s[0] <= $tmbSize && $s[1] > $tmbSize)) || ($s[0] > $tmbSize && $s[1] > $tmbSize)) {\n                    $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, false, 'png');\n                }\n\n                if ($result && ($s = getimagesize($tmb)) != false) {\n                    $x = $s[0] > $tmbSize ? intval(($s[0] - $tmbSize) / 2) : 0;\n                    $y = $s[1] > $tmbSize ? intval(($s[1] - $tmbSize) / 2) : 0;\n                    $result = $this->imgCrop($result, $tmbSize, $tmbSize, $x, $y, 'png');\n                } else {\n                    $result = false;\n                }\n\n            } else {\n                $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, true, 'png');\n            }\n\n            if ($result) {\n                if ($s = getimagesize($tmb)) {\n                    if ($s[0] !== $tmbSize || $s[1] !== $tmbSize) {\n                        $result = $this->imgSquareFit($result, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n                    }\n                }\n            }\n        }\n\n        if (!$result) {\n            unlink($tmb);\n            return false;\n        }\n\n        return $name;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $path               image file\n     * @param  int    $width              new width\n     * @param  int    $height             new height\n     * @param  bool   $keepProportions    crop image\n     * @param  bool   $resizeByBiggerSide resize image based on bigger side if true\n     * @param  string $destformat         image destination format\n     * @param  int    $jpgQuality         JEPG quality (1-100)\n     * @param  array  $options            Other extra options\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgResize($path, $width, $height, $keepProportions = false, $resizeByBiggerSide = true, $destformat = null, $jpgQuality = null, $options = array())\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        list($orig_w, $orig_h) = array($s[0], $s[1]);\n        list($size_w, $size_h) = array($width, $height);\n\n        if (empty($options['unenlarge']) || $orig_w > $size_w || $orig_h > $size_h) {\n            if ($keepProportions == true) {\n                /* Resizing by biggest side */\n                if ($resizeByBiggerSide) {\n                    if ($orig_w > $orig_h) {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    } else {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    }\n                } else {\n                    if ($orig_w > $orig_h) {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    } else {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    }\n                }\n            }\n        } else {\n            $size_w = $orig_w;\n            $size_h = $orig_h;\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                // Imagick::FILTER_BOX faster than FILTER_LANCZOS so use for createTmb\n                // resize bench: http://app-mgng.rhcloud.com/9\n                // resize sample: http://www.dylanbeattie.net/magick/filters/result.html\n                $filter = ($destformat === 'png' /* createTmb */) ? Imagick::FILTER_BOX : Imagick::FILTER_LANCZOS;\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->resizeImage($size_w, $size_h, $filter, 1);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                        $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                        $img->setImageCompressionQuality($jpgQuality);\n                        if (isset($options['preserveExif']) && !$options['preserveExif']) {\n                            try {\n                                $orientation = $img->getImageOrientation();\n                            } catch (ImagickException $e) {\n                                $orientation = 0;\n                            }\n                            $img->stripImage();\n                            if ($orientation) {\n                                $img->setImageOrientation($orientation);\n                            }\n                        }\n                        if ($this->options['jpgProgressive']) {\n                            $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                        }\n                    }\n                    $img->resizeImage($size_w, $size_h, $filter, true);\n                    if ($destformat) {\n                        $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                    } else {\n                        $result = $img->writeImage($path);\n                    }\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $filter = ($destformat === 'png' /* createTmb */) ? '-filter Box' : '-filter Lanczos';\n                $strip = (isset($options['preserveExif']) && !$options['preserveExif']) ? ' -strip' : '';\n                $cmd = sprintf('%s %s%s%s%s%s %s -geometry %dx%d! %s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $strip, $interlace, $filter, $size_w, $size_h, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($size_w, $size_h)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($size_w, $size_h))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    if (!imagecopyresampled($tmp, $img, 0, 0, 0, 0, $size_w, $size_h, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Crop image\n     *\n     * @param  string $path       image file\n     * @param  int    $width      crop width\n     * @param  int    $height     crop height\n     * @param  bool   $x          crop left offset\n     * @param  bool   $y          crop top offset\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgCrop($path, $width, $height, $x, $y, $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->setImagePage($s[0], $s[1], 0, 0);\n                        $img->cropImage($width, $height, $x, $y);\n                        $img->setImagePage($width, $height, 0, 0);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->setImagePage($s[0], $s[1], 0, 0);\n                    $img->cropImage($width, $height, $x, $y);\n                    $img->setImagePage($width, $height, 0, 0);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $cmd = sprintf('%s %s%s%s%s -crop %dx%d+%d+%d%s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $interlace, $width, $height, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    $size_w = $width;\n                    $size_h = $height;\n\n                    if ($s[0] < $width || $s[1] < $height) {\n                        $size_w = $s[0];\n                        $size_h = $s[1];\n                    }\n\n                    if (!imagecopy($tmp, $img, 0, 0, $x, $y, $size_w, $size_h)) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Put image to square\n     *\n     * @param  string    $path       image file\n     * @param  int       $width      square width\n     * @param  int       $height     square height\n     * @param int|string $align      reserved\n     * @param int|string $valign     reserved\n     * @param  string    $bgcolor    square background color in #rrggbb format\n     * @param  string    $destformat image destination format\n     * @param  int       $jpgQuality JEPG quality (1-100)\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgSquareFit($path, $width, $height, $align = 'center', $valign = 'middle', $bgcolor = '#0000ff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        /* Coordinates for image over square aligning */\n        $y = ceil(abs($height - $s[1]) / 2);\n        $x = ceil(abs($width - $s[0]) / 2);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img1 = new Imagick();\n                    $img1->setFormat('gif');\n                    $img = $img->coalesceImages();\n                    do {\n                        $gif = new Imagick();\n                        $gif->newImage($width, $height, new ImagickPixel($bgcolor));\n                        $gif->setImageColorspace($img->getImageColorspace());\n                        $gif->setImageFormat('gif');\n                        $gif->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                        $gif->setImageDelay($img->getImageDelay());\n                        $gif->setImageIterations($img->getImageIterations());\n                        $img1->addImage($gif);\n                        $gif->clear();\n                    } while ($img->nextImage());\n                    $img1->optimizeImageLayers();\n                    $result = $img1->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img1 = new Imagick();\n                    $img1->newImage($width, $height, new ImagickPixel($bgcolor));\n                    $img1->setImageColorspace($img->getImageColorspace());\n                    $img1->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                    $result = $this->imagickImage($img1, $path, $destformat, $jpgQuality);\n                }\n\n                $img1->clear();\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s -size %dx%d \"xc:%s\" png:- | convert%s%s%s png:-  %s -geometry +%d+%d -compose over -composite%s %s', ELFINDER_CONVERT_PATH, $width, $height, $bgcolor, $coalesce, $jpgQuality, $interlace, $quotedPath, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp, $bgcolor);\n                    if ($bgcolor === 'transparent' && ($destformat === 'png' || $s[2] === IMAGETYPE_PNG)) {\n                        $bgNum = imagecolorallocatealpha($tmp, 255, 255, 255, 127);\n                        imagefill($tmp, 0, 0, $bgNum);\n                    }\n\n                    if (!imagecopy($tmp, $img, $x, $y, 0, 0, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rotate image\n     *\n     * @param  string $path       image file\n     * @param  int    $degree     rotete degrees\n     * @param  string $bgcolor    square background color in #rrggbb format\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    protected function imgRotate($path, $degree, $bgcolor = '#ffffff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false || $degree % 360 === 0) {\n            return false;\n        }\n\n        $result = false;\n\n        // try lossless rotate\n        if ($degree % 90 === 0 && in_array($s[2], array(IMAGETYPE_JPEG, IMAGETYPE_JPEG2000))) {\n            $count = ($degree / 90) % 4;\n            $exiftran = array(\n                1 => '-9',\n                2 => '-1',\n                3 => '-2'\n            );\n            $jpegtran = array(\n                1 => '90',\n                2 => '180',\n                3 => '270'\n            );\n            $quotedPath = escapeshellarg($path);\n            $cmds = array();\n            if ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0) {\n                $cmds[] = ELFINDER_EXIFTRAN_PATH . ' -i ' . $exiftran[$count] . ' -- ' . $quotedPath;\n            }\n            if ($this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0) {\n                $cmds[] = ELFINDER_JPEGTRAN_PATH . ' -rotate ' . $jpegtran[$count] . ' -copy all -outfile ' . $quotedPath . ' -- ' . $quotedPath;\n            }\n            foreach ($cmds as $cmd) {\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                    break;\n                }\n            }\n            if ($result) {\n                return $path;\n            }\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                if ($img->getNumberImages() > 1) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s%s%s%s -background \"%s\" -rotate %d%s -- %s %s', ELFINDER_CONVERT_PATH, $coalesce, $jpgQuality, $interlace, $bgcolor, $degree, $deconstruct, $quotedPath, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, $s));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                $degree = 360 - $degree;\n\n                $bgNum = -1;\n                $bgIdx = false;\n                if ($s[2] === IMAGETYPE_GIF) {\n                    $bgIdx = imagecolortransparent($img);\n                    if ($bgIdx !== -1) {\n                        $c = imagecolorsforindex($img, $bgIdx);\n                        $w = imagesx($img);\n                        $h = imagesy($img);\n                        $newImg = imagecreatetruecolor($w, $h);\n                        imagepalettecopy($newImg, $img);\n                        $bgNum = imagecolorallocate($newImg, $c['red'], $c['green'], $c['blue']);\n                        imagefill($newImg, 0, 0, $bgNum);\n                        imagecolortransparent($newImg, $bgNum);\n                        imagecopy($newImg, $img, 0, 0, 0, 0, $w, $h);\n                        imagedestroy($img);\n                        $img = $newImg;\n                        $newImg = null;\n                    }\n                } else if ($s[2] === IMAGETYPE_PNG) {\n                    $bgNum = imagecolorallocatealpha($img, 255, 255, 255, 127);\n                }\n                if ($bgNum === -1) {\n                    list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n                    $bgNum = imagecolorallocate($img, $r, $g, $b);\n                }\n\n                $tmp = imageRotate($img, $degree, $bgNum);\n                if ($bgIdx !== -1) {\n                    imagecolortransparent($tmp, $bgNum);\n                }\n\n                $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                imageDestroy($img);\n                imageDestroy($tmp);\n\n                return $result ? $path : false;\n\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    protected function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n        return elFinder::procExec($command, $output, $return_var, $error_output);\n    }\n\n    /**\n     * Remove thumbnail, also remove recursively if stat is directory\n     *\n     * @param  array $stat file stat\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     * @author Troex Nevelin\n     */\n    protected function rmTmb($stat)\n    {\n        if ($this->tmbPathWritable) {\n            if ($stat['mime'] === 'directory') {\n                foreach ($this->scandirCE($this->decode($stat['hash'])) as $p) {\n                    elFinder::extendTimeLimit(30);\n                    $name = $this->basenameCE($p);\n                    $name != '.' && $name != '..' && $this->rmTmb($this->stat($p));\n                }\n            } else if (!empty($stat['tmb']) && $stat['tmb'] != \"1\") {\n                $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . rawurldecode($stat['tmb']);\n                file_exists($tmb) && unlink($tmb);\n                clearstatcache();\n            }\n        }\n    }\n\n    /**\n     * Create an gd image according to the specified mime type\n     *\n     * @param string $path image file\n     * @param string $mime\n     *\n     * @return resource|false GD image resource identifier\n     */\n    protected function gdImageCreate($path, $mime)\n    {\n        switch ($mime) {\n            case 'image/jpeg':\n                return imagecreatefromjpeg($path);\n\n            case 'image/png':\n                return imagecreatefrompng($path);\n\n            case 'image/gif':\n                return imagecreatefromgif($path);\n\n            case 'image/x-ms-bmp':\n                if (!function_exists('imagecreatefrombmp')) {\n                    include_once dirname(__FILE__) . '/libs/GdBmp.php';\n                }\n                return imagecreatefrombmp($path);\n\n            case 'image/xbm':\n                return imagecreatefromxbm($path);\n\n            case 'image/xpm':\n                return imagecreatefromxpm($path);\n\n            case 'image/webp':\n                return imagecreatefromwebp($path);\n        }\n        return false;\n    }\n\n    /**\n     * Output gd image to file\n     *\n     * @param resource $image      gd image resource\n     * @param string   $filename   The path to save the file to.\n     * @param string   $destformat The Image type to use for $filename\n     * @param string   $mime       The original image mime type\n     * @param int      $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function gdImage($image, $filename, $destformat, $mime, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n        if ($destformat) {\n            switch ($destformat) {\n                case 'jpg':\n                    $mime = 'image/jpeg';\n                    break;\n                case 'gif':\n                    $mime = 'image/gif';\n                    break;\n                case 'png':\n                default:\n                    $mime = 'image/png';\n                    break;\n            }\n        }\n        switch ($mime) {\n            case 'image/gif':\n                return imagegif($image, $filename);\n            case 'image/jpeg':\n                if ($this->options['jpgProgressive']) {\n                    imageinterlace($image, true);\n                }\n                return imagejpeg($image, $filename, $jpgQuality);\n            case 'image/wbmp':\n                return imagewbmp($image, $filename);\n            case 'image/png':\n            default:\n                return imagepng($image, $filename);\n        }\n    }\n\n    /**\n     * Output imagick image to file\n     *\n     * @param imagick $img        imagick image resource\n     * @param string  $filename   The path to save the file to.\n     * @param string  $destformat The Image type to use for $filename\n     * @param int     $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function imagickImage($img, $filename, $destformat, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        try {\n            if ($destformat) {\n                if ($destformat === 'gif') {\n                    $img->setImageFormat('gif');\n                } else if ($destformat === 'png') {\n                    $img->setImageFormat('png');\n                } else if ($destformat === 'jpg') {\n                    $img->setImageFormat('jpeg');\n                }\n            }\n            if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                $img->setImageCompressionQuality($jpgQuality);\n                if ($this->options['jpgProgressive']) {\n                    $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                }\n                try {\n                    $orientation = $img->getImageOrientation();\n                } catch (ImagickException $e) {\n                    $orientation = 0;\n                }\n                $img->stripImage();\n                if ($orientation) {\n                    $img->setImageOrientation($orientation);\n                }\n            }\n            $result = $img->writeImage($filename);\n        } catch (Exception $e) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Assign the proper background to a gd image\n     *\n     * @param resource $image   gd image resource\n     * @param string   $bgcolor background color in #rrggbb format\n     */\n    protected function gdImageBackground($image, $bgcolor)\n    {\n\n        if ($bgcolor === 'transparent') {\n            imagealphablending($image, false);\n            imagesavealpha($image, true);\n        } else {\n            list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n            $bgcolor1 = imagecolorallocate($image, $r, $g, $b);\n            imagefill($image, 0, 0, $bgcolor1);\n        }\n    }\n\n    /**\n     * Prepare variables for exec convert of ImageMagick\n     *\n     * @param  string $path\n     * @param  string $destformat\n     * @param  int    $jpgQuality\n     * @param  array  $imageSize\n     * @param null    $mime\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function imageMagickConvertPrepare($path, $destformat, $jpgQuality, $imageSize = null, $mime = null)\n    {\n        if (is_null($imageSize)) {\n            $imageSize = getimagesize($path);\n        }\n        if (is_null($mime)) {\n            $mime = $this->mimetype($path);\n        }\n        $srcType = $this->getExtentionByMime($mime, ':');\n        $ani = false;\n        if (preg_match('/^(?:gif|png|ico)/', $srcType)) {\n            $cmd = ELFINDER_IDENTIFY_PATH . ' -- ' . escapeshellarg($srcType . $path);\n            if ($this->procExec($cmd, $o) === 0) {\n                $ani = preg_split('/(?:\\r\\n|\\n|\\r)/', trim($o));\n                if (count($ani) < 2) {\n                    $ani = false;\n                }\n            }\n        }\n        $coalesce = $index = $interlace = '';\n        $deconstruct = ' +repage';\n        if ($ani && $destformat !== 'png'/* not createTmb */) {\n            if (is_null($destformat)) {\n                $coalesce = ' -coalesce -repage 0x0';\n                $deconstruct = ' +repage -deconstruct -layers optimize';\n            } else if ($imageSize) {\n                if ($srcType === 'ico:') {\n                    $index = '[0]';\n                    foreach ($ani as $_i => $_info) {\n                        if (preg_match('/ (\\d+)x(\\d+) /', $_info, $m)) {\n                            if ($m[1] == $imageSize[0] && $m[2] == $imageSize[1]) {\n                                $index = '[' . $_i . ']';\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            $index = '[0]';\n        }\n        if ($imageSize && ($imageSize[2] === IMAGETYPE_JPEG || $imageSize[2] === IMAGETYPE_JPEG2000)) {\n            $jpgQuality = ' -quality ' . $jpgQuality;\n            if ($this->options['jpgProgressive']) {\n                $interlace = ' -interlace Plane';\n            }\n        } else {\n            $jpgQuality = '';\n        }\n        $quotedPath = escapeshellarg($srcType . $path . $index);\n        $quotedDstPath = escapeshellarg(($destformat ? ($destformat . ':') : $srcType) . $path);\n        return compact('ani', 'index', 'coalesce', 'deconstruct', 'jpgQuality', 'quotedPath', 'quotedDstPath', 'interlace');\n    }\n\n    /*********************** misc *************************/\n\n    /**\n     * Find position of first occurrence of string in a string with multibyte support\n     *\n     * @param  string $haystack The string being checked.\n     * @param  string $needle   The string to find in haystack.\n     * @param  int    $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return int|bool\n     * @author Alexey Sukhotin\n     **/\n    protected function stripos($haystack, $needle, $offset = 0)\n    {\n        if (function_exists('mb_stripos')) {\n            return mb_stripos($haystack, $needle, $offset, 'UTF-8');\n        } else if (function_exists('mb_strtolower') && function_exists('mb_strpos')) {\n            return mb_strpos(mb_strtolower($haystack, 'UTF-8'), mb_strtolower($needle, 'UTF-8'), $offset);\n        }\n        return stripos($haystack, $needle, $offset);\n    }\n\n    /**\n     * Default serach match method (name match)\n     *\n     * @param  String $name  Item name\n     * @param  String $query Query word\n     * @param  String $path  Item path\n     *\n     * @return bool @return bool\n     */\n    protected function searchMatchName($name, $query, $path)\n    {\n        return $this->stripos($name, $query) !== false;\n    }\n\n    /**\n     * Get server side available archivers\n     *\n     * @param bool $use_cache\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function getArchivers($use_cache = true)\n    {\n        $sessionKey = 'archivers';\n        if ($use_cache) {\n            if (isset($this->options['archivers']) && is_array($this->options['archivers']) && $this->options['archivers']) {\n                $cache = $this->options['archivers'];\n            } else {\n                $cache = elFinder::$archivers;\n            }\n            if ($cache) {\n                return $cache;\n            } else {\n                if ($cache = $this->session->get($sessionKey, array())) {\n                    return elFinder::$archivers = $cache;\n                }\n            }\n        }\n\n        $arcs = array(\n            'create' => array(),\n            'extract' => array()\n        );\n\n        if ($this->procExec('') === 0) {\n\n            $this->procExec(ELFINDER_TAR_PATH . ' --version', $o, $ctar);\n\n            if ($ctar == 0) {\n                $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-chf', 'ext' => 'tar');\n                $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xf', 'ext' => 'tar', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                unset($o);\n                $this->procExec(ELFINDER_GZIP_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-czhf', 'ext' => 'tgz');\n                    $arcs['extract']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xzf', 'ext' => 'tgz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_BZIP2_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cjhf', 'ext' => 'tbz');\n                    $arcs['extract']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xjf', 'ext' => 'tbz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_XZ_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cJhf', 'ext' => 'xz');\n                    $arcs['extract']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xJf', 'ext' => 'xz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n            }\n            unset($o);\n            $this->procExec(ELFINDER_ZIP_PATH . ' -h', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/zip'] = array('cmd' => ELFINDER_ZIP_PATH, 'argc' => '-r9 -q', 'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNZIP_PATH . ' --help', $o, $c);\n            if ($c == 0) {\n                $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_UNZIP_PATH, 'argc' => '-q', 'ext' => 'zip', 'toSpec' => '-d ', 'getsize' => array('argc' => '-Z -t', 'regex' => '/^.+?,\\s?([0-9]+).+$/', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_RAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['create']['application/x-rar'] = array('cmd' => ELFINDER_RAR_PATH, 'argc' => 'a -inul' . (defined('ELFINDER_RAR_MA4') && ELFINDER_RAR_MA4? ' -ma4' : '') . ' --', 'ext' => 'rar');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNRAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_UNRAR_PATH, 'argc' => 'x -y', 'ext' => 'rar', 'toSpec' => '', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)(?:(?:[^\\r\\n0-9]+[0-9]+[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+)|(?:[^\\r\\n0-9]+([0-9]+)[^\\r\\n0-9]+[0-9]+[^\\r\\n]*))$/s', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_7Z_PATH, $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a --', 'ext' => '7z');\n                $arcs['extract']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -y', 'ext' => '7z', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n\n                if (empty($arcs['create']['application/zip'])) {\n                    $arcs['create']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -tzip --', 'ext' => 'zip');\n                }\n                if (empty($arcs['extract']['application/zip'])) {\n                    $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -tzip -y', 'ext' => 'zip', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (empty($arcs['create']['application/x-tar'])) {\n                    $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -ttar --', 'ext' => 'tar');\n                }\n                if (empty($arcs['extract']['application/x-tar'])) {\n                    $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -ttar -y', 'ext' => 'tar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (substr(PHP_OS, 0, 3) === 'WIN' && empty($arcs['extract']['application/x-rar'])) {\n                    $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -trar -y', 'ext' => 'rar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n            }\n\n        }\n\n        // Use PHP ZipArchive Class\n        if (class_exists('ZipArchive', false)) {\n            if (empty($arcs['create']['application/zip'])) {\n                $arcs['create']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveZip'), 'ext' => 'zip');\n            }\n            if (empty($arcs['extract']['application/zip'])) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveUnzip'), 'ext' => 'zip');\n            }\n        }\n\n        $this->session->set($sessionKey, $arcs);\n        return elFinder::$archivers = $arcs;\n    }\n\n    /**\n     * Resolve relative / (Unix-like)absolute path\n     *\n     * @param string $path target path\n     * @param string $base base path\n     *\n     * @return string\n     */\n    protected function getFullPath($path, $base)\n    {\n        $separator = $this->separator;\n        $systemroot = $this->systemRoot;\n        $base = (string)$base;\n\n        if ($base[0] === $separator && substr($base, 0, strlen($systemroot)) !== $systemroot) {\n            $base = $systemroot . substr($base, 1);\n        }\n        if ($base !== $systemroot) {\n            $base = rtrim($base, $separator);\n        }\n\n        // 'Here'\n        if ($path === '' || $path === '.' . $separator) return $base;\n\n        $sepquoted = preg_quote($separator, '#');\n\n        if (substr($path, 0, 3) === '..' . $separator) {\n            $path = $base . $separator . $path;\n        }\n        // normalize `/../`\n        $normreg = '#(' . $sepquoted . ')[^' . $sepquoted . ']+' . $sepquoted . '\\.\\.' . $sepquoted . '#'; // '#(/)[^\\/]+/\\.\\./#'\n        while (preg_match($normreg, $path)) {\n            $path = preg_replace($normreg, '$1', $path, 1);\n        }\n        if ($path !== $systemroot) {\n            $path = rtrim($path, $separator);\n        }\n\n        // Absolute path\n        if ($path[0] === $separator || strpos($path, $systemroot) === 0) {\n            return $path;\n        }\n\n        $preg_separator = '#' . $sepquoted . '#';\n\n        // Relative path from 'Here'\n        if (substr($path, 0, 2) === '.' . $separator || $path[0] !== '.') {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            if ($arrn[0] !== '.') {\n                array_unshift($arrn, '.');\n            }\n            $arrn[0] = rtrim($base, $separator);\n            return join($separator, $arrn);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function rmdirRecursive($dir)\n    {\n        return self::localRmdirRecursive($dir);\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function makeArchive($dir, $files, $name, $arc)\n    {\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            }\n        } else {\n            $cwd = getcwd();\n            if (chdir($dir)) {\n                foreach ($files as $i => $file) {\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                }\n                $files = array_map('escapeshellarg', $files);\n                $prefix = $switch = '';\n                // The zip command accepts the \"-\" at the beginning of the file name as a command switch,\n                // and can't use '--' before archive name, so add \"./\" to name for security reasons.\n                if ($arc['ext'] === 'zip' && strpos($arc['argc'], '-tzip') === false) {\n                    $prefix = './';\n                    $switch = '-- ';\n                }\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . $prefix . escapeshellarg($name) . ' ' . $switch . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            } else {\n                return false;\n            }\n        }\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    }\n\n    /**\n     * Unpack archive\n     *\n     * @param  string      $path archive path\n     * @param  array       $arc  archiver command and arguments (same as in $this->archivers)\n     * @param  bool|string $mode bool: remove archive ( unlink($path) ) | string: extract to directory\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function unpackArchive($path, $arc, $mode = true)\n    {\n        if (is_string($mode)) {\n            $dir = $mode;\n            $chdir = null;\n            $remove = false;\n        } else {\n            $dir = dirname($path);\n            $chdir = $dir;\n            $remove = $mode;\n        }\n        $dir = realpath($dir);\n        $path = realpath($path);\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($path, $dir));\n            }\n        } else {\n            $cwd = getcwd();\n            if (!$chdir || chdir($dir)) {\n                if (!empty($arc['getsize'])) {\n                    // Check total file size after extraction\n                    $getsize = $arc['getsize'];\n                    if (is_array($getsize) && !empty($getsize['regex']) && !empty($getsize['replace'])) {\n                        $cmd = $arc['cmd'] . ' ' . $getsize['argc'] . ' ' . escapeshellarg($path) . (!empty($getsize['toSpec'])? (' ' . $getsize['toSpec']): '');\n                        $this->procExec($cmd, $o, $c);\n                        if ($o) {\n                            $size = preg_replace($getsize['regex'], $getsize['replace'], trim($o));\n                            $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                            if (!empty($this->options['maxArcFilesSize'])) {\n                                if ($comp($size, (string)$this->options['maxArcFilesSize']) > 0) {\n                                    throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                                }\n                            }\n                        }\n                        unset($o, $c);\n                    }\n                }\n                if ($chdir) {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg(basename($path));\n                } else {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($path) . ' ' . $arc['toSpec'] . escapeshellarg($dir);\n                }\n                $this->procExec($cmd, $o, $c);\n                $chdir && chdir($cwd);\n            }\n        }\n        $remove && unlink($path);\n    }\n\n    /**\n     * Check and filter the extracted items\n     *\n     * @param  string $path   target local path\n     * @param  array  $checks types to check default: ['symlink', 'name', 'writable', 'mime']\n     *\n     * @return array  ['symlinks' => [], 'names' => [], 'writables' => [], 'mimes' => [], 'rmNames' => [], 'totalSize' => 0]\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function checkExtractItems($path, $checks = null)\n    {\n        if (is_null($checks) || !is_array($checks)) {\n            $checks = array('symlink', 'name', 'writable', 'mime');\n        }\n        $chkSymlink = in_array('symlink', $checks);\n        $chkName = in_array('name', $checks);\n        $chkWritable = in_array('writable', $checks);\n        $chkMime = in_array('mime', $checks);\n\n        $res = array(\n            'symlinks' => array(),\n            'names' => array(),\n            'writables' => array(),\n            'mimes' => array(),\n            'rmNames' => array(),\n            'totalSize' => 0\n        );\n\n        if (is_dir($path)) {\n            $files = self::localScandir($path);\n        } else {\n            $files = array(basename($path));\n            $path = dirname($path);\n        }\n\n        foreach ($files as $name) {\n            $p = $path . DIRECTORY_SEPARATOR . $name;\n            $utf8Name = elFinder::$instance->utf8Encode($name);\n            if ($name !== $utf8Name) {\n                $fsSame = false;\n                if ($this->encoding) {\n                    // test as fs encoding\n                    $_utf8 = @iconv($this->encoding, 'utf-8//IGNORE', $name);\n                    if (@iconv('utf-8', $this->encoding.'//IGNORE', $_utf8) === $name) {\n                        $fsSame = true;\n                        $utf8Name = $_utf8;\n                    } else {\n                        $_name = $this->convEncIn($utf8Name, true);\n                    }\n                } else {\n                    $_name = $utf8Name;\n                }\n                if (!$fsSame && rename($p, $path . DIRECTORY_SEPARATOR . $_name)) {\n                    $name = $_name;\n                    $p = $path . DIRECTORY_SEPARATOR . $name;\n                }\n            }\n            if (!is_readable($p)) {\n                // Perhaps a symbolic link to open_basedir restricted location\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkSymlink && is_link($p)) {\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            $isDir = is_dir($p);\n            if ($chkName && !$this->nameAccepted($name, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['names'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkWritable && !$this->attr($p, 'write', null, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['writables'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($isDir) {\n                $cRes = $this->checkExtractItems($p, $checks);\n                foreach ($cRes as $k => $v) {\n                    if (is_array($v)) {\n                        $res[$k] = array_merge($res[$k], $cRes[$k]);\n                    } else {\n                        $res[$k] += $cRes[$k];\n                    }\n                }\n            } else {\n                if ($chkMime && ($mimeByName = elFinderVolumeDriver::mimetypeInternalDetect($name)) && !$this->allowPutMime($mimeByName)) {\n                    self::localRmdirRecursive($p);\n                    $res['mimes'][] = $p;\n                    $res['rmNames'][] = $utf8Name;\n                    continue;\n                }\n                $res['totalSize'] += (int)sprintf('%u', filesize($p));\n            }\n        }\n        $res['rmNames'] = array_unique($res['rmNames']);\n\n        return $res;\n    }\n\n    /**\n     * Return files of target directory that is dotfiles excludes.\n     *\n     * @param  string $dir target directory path\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localScandir($dir)\n    {\n        // PHP function scandir() is not work well in specific environment. I dont know why.\n        // ref. https://github.com/Studio-42/elFinder/issues/1248\n        $files = array();\n        if ($dh = opendir($dir)) {\n            while (false !== ($file = readdir($dh))) {\n                if ($file !== '.' && $file !== '..') {\n                    $files[] = $file;\n                }\n            }\n            closedir($dh);\n        } else {\n            throw new Exception('Can not open local directory.');\n        }\n        return $files;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected static function localRmdirRecursive($dir)\n    {\n        // try system command\n        if (is_callable('exec')) {\n            $o = '';\n            $r = 1;\n            if (substr(PHP_OS, 0, 3) === 'WIN') {\n                if (!is_link($dir) && is_dir($dir)) {\n                    exec('rd /S /Q ' . escapeshellarg($dir), $o, $r);\n                } else {\n                    exec('del /F /Q ' . escapeshellarg($dir), $o, $r);\n                }\n            } else {\n                exec('rm -rf ' . escapeshellarg($dir), $o, $r);\n            }\n            if ($r === 0) {\n                return true;\n            }\n        }\n        if (!is_link($dir) && is_dir($dir)) {\n            chmod($dir, 0777);\n            if ($handle = opendir($dir)) {\n                while (false !== ($file = readdir($handle))) {\n                    if ($file === '.' || $file === '..') {\n                        continue;\n                    }\n                    elFinder::extendTimeLimit(30);\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (!is_link($dir) && is_dir($path)) {\n                        self::localRmdirRecursive($path);\n                    } else {\n                        chmod($path, 0666);\n                        unlink($path);\n                    }\n                }\n                closedir($handle);\n            }\n            return rmdir($dir);\n        } else {\n            chmod($dir, 0666);\n            return unlink($dir);\n        }\n    }\n\n    /**\n     * Move item recursive on local file system\n     *\n     * @param string $src\n     * @param string $target\n     * @param bool   $overWrite\n     * @param bool   $copyJoin\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localMoveRecursive($src, $target, $overWrite = true, $copyJoin = true)\n    {\n        $res = false;\n        if (!file_exists($target)) {\n            return rename($src, $target);\n        }\n        if (!$copyJoin || !is_dir($target)) {\n            if ($overWrite) {\n                if (is_dir($target)) {\n                    $del = self::localRmdirRecursive($target);\n                } else {\n                    $del = unlink($target);\n                }\n                if ($del) {\n                    return rename($src, $target);\n                }\n            }\n        } else {\n            foreach (self::localScandir($src) as $item) {\n                $res |= self::localMoveRecursive($src . DIRECTORY_SEPARATOR . $item, $target . DIRECTORY_SEPARATOR . $item, $overWrite, $copyJoin);\n            }\n        }\n        return (bool)$res;\n    }\n\n    /**\n     * Create Zip archive using PHP class ZipArchive\n     *\n     * @param  string        $dir     target dir\n     * @param  array         $files   files names list\n     * @param  string|object $zipPath Zip archive name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveZip($dir, $files, $zipPath)\n    {\n        try {\n            if ($start = is_string($zipPath)) {\n                $zip = new ZipArchive();\n                if ($zip->open($dir . DIRECTORY_SEPARATOR . $zipPath, ZipArchive::CREATE) !== true) {\n                    $zip = false;\n                }\n            } else {\n                $zip = $zipPath;\n            }\n            if ($zip) {\n                foreach ($files as $file) {\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (is_dir($path)) {\n                        $zip->addEmptyDir($file);\n                        $_files = array();\n                        if ($handle = opendir($path)) {\n                            while (false !== ($entry = readdir($handle))) {\n                                if ($entry !== \".\" && $entry !== \"..\") {\n                                    $_files[] = $file . DIRECTORY_SEPARATOR . $entry;\n                                }\n                            }\n                            closedir($handle);\n                        }\n                        if ($_files) {\n                            self::zipArchiveZip($dir, $_files, $zip);\n                        }\n                    } else {\n                        $zip->addFile($path, $file);\n                    }\n                }\n                $start && $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Unpack Zip archive using PHP class ZipArchive\n     *\n     * @param  string $zipPath Zip archive name\n     * @param  string $toDir   Extract to path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveUnzip($zipPath, $toDir)\n    {\n        try {\n            $zip = new ZipArchive();\n            if ($zip->open($zipPath) === true) {\n                // Check total file size after extraction\n                $num = $zip->numFiles;\n                $size = 0;\n                $maxSize = empty(self::$maxArcFilesSize)? '' : (string)self::$maxArcFilesSize;\n                $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                for ($i = 0; $i < $num; $i++) {\n                    $stat = $zip->statIndex($i);\n                    $size += $stat['size'];\n                    if (strpos((string)$size, 'E') !== false) {\n                        // Cannot handle values exceeding PHP_INT_MAX\n                        throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                    }\n                    if (!$maxSize) {\n                        if ($comp($size, $maxSize) > 0) {\n                            throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                        }\n                    }\n                }\n                // do extract\n                $zip->extractTo($toDir);\n                $zip->close();\n            }\n        } catch (Exception $e) {\n            throw $e;\n        }\n        return true;\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected static function localFindSymlinks($path)\n    {\n        if (is_link($path)) {\n            return true;\n        }\n\n        if (is_dir($path)) {\n            foreach (self::localScandir($path) as $name) {\n                $p = $path . DIRECTORY_SEPARATOR . $name;\n                if (is_link($p)) {\n                    return true;\n                }\n                if (is_dir($p) && self::localFindSymlinks($p)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**==================================* abstract methods *====================================**/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dirname($path);\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _basename($path);\n\n    /**\n     * Join dir name and file name and return full path.\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _joinPath($dir, $name);\n\n    /**\n     * Return normalized path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _normpath($path);\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _relpath($path);\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _abspath($path);\n\n    /**\n     * Return fake path started from root dir.\n     * Required to show path on client side.\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _path($path);\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _inpath($path, $parent);\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _stat($path);\n\n\n    /***************** file stat ********************/\n\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _subdirs($path);\n\n    /**\n     * Return object width and height\n     * Ususaly used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dimensions($path, $mime);\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Return files list in directory\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _scandir($path);\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param  string $mode open mode\n     *\n     * @return resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fopen($path, $mode = \"rb\");\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fclose($fp, $path = '');\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkdir($path, $name);\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkfile($path, $name);\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _symlink($source, $targetDir, $name);\n\n    /**\n     * Copy file into another file (only inside one volume)\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _copy($source, $targetDir, $name);\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _move($source, $targetDir, $name);\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _unlink($path);\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _rmdir($path);\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _save($fp, $dir, $name, $stat);\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _getContents($path);\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _filePutContents($path, $content);\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path file path\n     * @param  array  $arc  archiver options\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _extract($path, $arc);\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _archive($dir, $files, $name, $arc);\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _checkArchivers();\n\n    /**\n     * Change file mode (chmod)\n     *\n     * @param  string $path file path\n     * @param  string $mode octal string such as '0755'\n     *\n     * @return bool\n     * @author David Bartle,\n     **/\n    abstract protected function _chmod($path, $mode);\n\n\n} // END class\n", "<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        $_quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                //$hiddens['quarantine'] = $this->options['quarantine'];\n                //$this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n                $_quarantine = $this->_abspath($this->options['quarantine']);\n                $this->options['quarantine'] = '';\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        } else {\n            $_quarantine = $this->_abspath('.quarantine');\n        }\n        is_dir($_quarantine) && self::localRmdirRecursive($_quarantine);\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        } else if ($_path = elFinder::getCommonTempPath()) {\n            $this->quarantine = $_path;\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        $dir = rtrim($dir, DIRECTORY_SEPARATOR);\n        $path = realpath($dir . DIRECTORY_SEPARATOR . $name);\n        // realpath() returns FALSE if the file does not exist\n        if ($path === false || strpos($path, $this->root) !== 0) {\n            if (DIRECTORY_SEPARATOR !== '/') {\n                $name = str_replace('/', DIRECTORY_SEPARATOR, $name);\n            }\n            // Directory traversal measures\n            if (strpos($name, '..' . DIRECTORY_SEPARATOR) !== false) {\n                $name = basename($name);\n            }\n            $path = $dir . DIRECTORY_SEPARATOR . $name;\n        }\n        return $path; \n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n", "<?php\n\n/**\n * Simple elFinder driver for SFTP using phpseclib 1\n *\n * @author Dmitry (dio) Levashov\n * @author Cem (discofever), sitecode\n * @reference http://phpseclib.sourceforge.net/sftp/2.0/examples.html\n **/\nclass elFinderVolumeSFTPphpseclib extends elFinderVolumeFTP {\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     * @author Cem (DiscoFever)\n     */\n    public function __construct()\n    {\n        $opts = array(\n            'host' => 'localhost',\n            'user' => '',\n            'pass' => '',\n            'port' => 22,\n            'path' => '/',\n            'timeout' => 20,\n            'owner' => true,\n            'tmbPath' => '',\n            'tmpPath' => '',\n            'separator' => '/',\n            'phpseclibDir' => '../phpseclib/',\n            'connectCallback' => null, //provide your own already instantiated phpseclib $Sftp object returned by this callback\n                                       //'connectCallback'=> function($options) {\n                                       //     //load and instantiate phpseclib $sftp\n                                       //     return $sftp;\n                                       // },\n            'checkSubfolders' => -1,\n            'dirMode' => 0755,\n            'fileMode' => 0644,\n            'rootCssClass' => 'elfinder-navbar-root-ftp',\n        );\n        $this->options = array_merge($this->options, $opts);\n        $this->options['mimeDetect'] = 'internal';\n    }\n\n    /**\n     * Prepare\n     * Call from elFinder::netmout() before volume->mount()\n     *\n     * @param $options\n     *\n     * @return array volume root options\n     * @author Naoki Sawada\n     */\n    public function netmountPrepare($options)\n    {\n        $options['statOwner'] = true;\n        $options['allowChmodReadOnly'] = true;\n        $options['acceptedName'] = '#^[^/\\\\?*:|\"<>]*[^./\\\\?*:|\"<>]$#';\n        return $options;\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare SFTP connection\n     * Connect to remote server and check if credentials are correct, if so, store the connection\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     * @author Cem (DiscoFever)\n     **/\n    protected function init()\n    {\n        if (!$this->options['connectCallback']) {\n            if (!$this->options['host']\n                || !$this->options['port']) {\n                return $this->setError('Required options undefined.');\n            }\n\n            if (!$this->options['path']) {\n                $this->options['path'] = '/';\n            }\n\n            // make net mount key\n            $this->netMountKey = md5(join('-', array('sftpphpseclib', $this->options['host'], $this->options['port'], $this->options['path'], $this->options['user'])));\n\n            set_include_path(get_include_path() . PATH_SEPARATOR . getcwd().'/'.$this->options['phpseclibDir']);\n            include_once('Net/SFTP.php');\n\n            if (!class_exists('Net_SFTP')) {\n                return $this->setError('SFTP extension not loaded. Install phpseclib version 1: http://phpseclib.sourceforge.net/ Set option \"phpseclibDir\" accordingly.');\n            }\n\n            // remove protocol from host\n            $scheme = parse_url($this->options['host'], PHP_URL_SCHEME);\n\n            if ($scheme) {\n                $this->options['host'] = substr($this->options['host'], strlen($scheme) + 3);\n            }\n        } else {\n            // make net mount key\n            $this->netMountKey = md5(join('-', array('sftpphpseclib', $this->options['path'])));\n        }\n\n        // normalize root path\n        $this->root = $this->options['path'] = $this->_normpath($this->options['path']);\n\n        if (empty($this->options['alias'])) {\n            $this->options['alias'] = $this->options['user'] . '@' . $this->options['host'];\n            if (!empty($this->options['netkey'])) {\n                elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $this->options['alias']);\n            }\n        }\n\n        $this->rootName = $this->options['alias'];\n        $this->options['separator'] = '/';\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n\n        return $this->needOnline? $this->connect() : true;\n\n    }\n\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        parent::configure();\n\n        if (!$this->tmp) {\n            $this->disabled[] = 'mkfile';\n            $this->disabled[] = 'paste';\n            $this->disabled[] = 'upload';\n            $this->disabled[] = 'edit';\n            //$this->disabled[] = 'archive';\n            //$this->disabled[] = 'extract';\n        }\n\n        $this->disabled[] = 'archive';\n        $this->disabled[] = 'extract';\n    }\n\n    /**\n     * Connect to sftp server\n     *\n     * @return bool\n     * @author sitecode\n     **/\n    protected function connect()\n    {\n        //use ca\n        if ($this->options['connectCallback']) {\n            $this->connect = $this->options['connectCallback']($this->options);\n            if (!$this->connect || !$this->connect->isConnected()) {\n                return $this->setError('Unable to connect successfully');\n            }\n\n            return true;\n        }\n\n        try{\n            $host = $this->options['host'] . ($this->options['port'] != 22 ? ':' . $this->options['port'] : '');\n            $this->connect = new Net_SFTP($host);\n            //TODO check fingerprint before login, fail if no match to last time\n            if (!$this->connect->login($this->options['user'], $this->options['pass'])) {\n                return $this->setError('Unable to connect to SFTP server ' . $host);\n            }\n        } catch (Exception $e) {\n            return $this->setError('Error while connecting to SFTP server '  . $host . ': ' . $e->getMessage());\n        }\n\n        if (!$this->connect->chdir($this->root)\n            /*|| $this->root != $this->connect->pwd()*/) {\n            //$this->umount();\n            return $this->setError('Unable to open root folder.');\n        }\n\n        return true;\n    }\n\n    /**\n     * Call rawlist\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    protected function ftpRawList($path)\n    {\n        return $this->connect->rawlist($path ?: '.') ?: [];\n/*\n        $raw = $this->connect->rawlist($path ?: '.') ?: [];\n        $raw = array_map(function($key, $value) {\n            $value['name'] = $key;\n            return $value;\n        }, array_keys($raw), $raw);\n        return $raw;\n*/\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /**\n     * Close opened connection\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n        $this->connect && $this->connect->disconnect();\n    }\n\n\n    /**\n     * Parse line from rawlist() output and return file stat (array)\n     *\n     * @param  string $raw line from rawlist() output\n     * @param         $base\n     * @param bool    $nameOnly\n     *\n     * @return array\n     * @author Dmitry Levashov\n     */\n    protected function parseRaw($raw, $base, $nameOnly = false)\n    {\n        $info = $raw;\n        $stat = array();\n\n        if ($info['filename'] == '.' || $info['filename'] == '..') {\n            return false;\n        }\n\n        $name = $info['filename'];\n\n        if (preg_match('|(.+)\\-\\>(.+)|', $name, $m)) {\n            $name = trim($m[1]);\n            // check recursive processing\n            if ($this->cacheDirTarget && $this->_joinPath($base, $name) !== $this->cacheDirTarget) {\n                return array();\n            }\n            if (!$nameOnly) {\n                $target = trim($m[2]);\n                if (substr($target, 0, 1) !== $this->separator) {\n                    $target = $this->getFullPath($target, $base);\n                }\n                $target = $this->_normpath($target);\n                $stat['name'] = $name;\n                $stat['target'] = $target;\n                return $stat;\n            }\n        }\n\n        if ($nameOnly) {\n            return array('name' => $name);\n        }\n\n        $stat['ts'] = $info['mtime'];\n\n        if ($this->options['statOwner']) {\n            $stat['owner'] = $info['uid'];\n            $stat['group'] = $info['gid'];\n            $stat['perm'] = $info['permissions'];\n            $stat['isowner'] = isset($stat['owner']) ? ($this->options['owner'] ? true : ($stat['owner'] == $this->options['user'])) : true;\n        }\n\n        $owner_computed = isset($stat['isowner']) ? $stat['isowner'] : $this->options['owner'];\n        $perm = $this->parsePermissions($info['permissions'], $owner_computed);\n        $stat['name'] = $name;\n        $stat['mime'] = $info['type'] == NET_SFTP_TYPE_DIRECTORY ? 'directory' : $this->mimetype($stat['name'], true);\n        $stat['size'] = $stat['mime'] == 'directory' ? 0 : $info['size'];\n        $stat['read'] = $perm['read'];\n        $stat['write'] = $perm['write'];\n\n        return $stat;\n    }\n\n    /**\n     * Parse permissions string. Return array(read => true/false, write => true/false)\n     *\n     * @param  int $perm\n     *                                             The isowner parameter is computed by the caller.\n     *                                             If the owner parameter in the options is true, the user is the actual owner of all objects even if the user used in the ftp Login\n     *                                             is different from the file owner id.\n     *                                             If the owner parameter is false to understand if the user is the file owner we compare the ftp user with the file owner id.\n     * @param Boolean $isowner                     . Tell if the current user is the owner of the object.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     * @author sitecode\n     */\n    protected function parsePermissions($permissions, $isowner = true)\n    {\n        $permissions = decoct($permissions);\n        $perm = $isowner ? decbin($permissions[-3]) : decbin($permissions[-1]);\n\n        return array(\n            'read' => $perm[-3],\n            'write' => $perm[-2]\n        );\n    }\n\n    /**\n     * Cache dir contents\n     *\n     * @param  string $path dir path\n     *\n     * @return void\n     * @author Dmitry Levashov, sitecode\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        $list = array();\n        $encPath = $this->convEncIn($path);\n        foreach ($this->ftpRawList($encPath) as $raw) {\n            if (($stat = $this->parseRaw($raw, $encPath))) {\n                $list[] = $stat;\n            }\n        }\n        $list = $this->convEncOut($list);\n        $prefix = ($path === $this->separator) ? $this->separator : $path . $this->separator;\n        $targets = array();\n        foreach ($list as $stat) {\n            $p = $prefix . $stat['name'];\n            if (isset($stat['target'])) {\n                // stat later\n                $targets[$stat['name']] = $stat['target'];\n            } else {\n                $stat = $this->updateCache($p, $stat);\n                if (empty($stat['hidden'])) {\n                    if (!$hasDir && $stat['mime'] === 'directory') {\n                        $hasDir = true;\n                    }\n                    $this->dirsCache[$path][] = $p;\n                }\n            }\n        }\n        // stat link targets\n        foreach ($targets as $name => $target) {\n            $stat = array();\n            $stat['name'] = $name;\n            $p = $prefix . $name;\n            $cacheDirTarget = $this->cacheDirTarget;\n            $this->cacheDirTarget = $this->convEncIn($target, true);\n            if ($tstat = $this->stat($target)) {\n                $stat['size'] = $tstat['size'];\n                $stat['alias'] = $target;\n                $stat['thash'] = $tstat['hash'];\n                $stat['mime'] = $tstat['mime'];\n                $stat['read'] = $tstat['read'];\n                $stat['write'] = $tstat['write'];\n\n                if (isset($tstat['ts'])) {\n                    $stat['ts'] = $tstat['ts'];\n                }\n                if (isset($tstat['owner'])) {\n                    $stat['owner'] = $tstat['owner'];\n                }\n                if (isset($tstat['group'])) {\n                    $stat['group'] = $tstat['group'];\n                }\n                if (isset($tstat['perm'])) {\n                    $stat['perm'] = $tstat['perm'];\n                }\n                if (isset($tstat['isowner'])) {\n                    $stat['isowner'] = $tstat['isowner'];\n                }\n            } else {\n\n                $stat['mime'] = 'symlink-broken';\n                $stat['read'] = false;\n                $stat['write'] = false;\n                $stat['size'] = 0;\n\n            }\n            $this->cacheDirTarget = $cacheDirTarget;\n            $stat = $this->updateCache($p, $stat);\n            if (empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        if (isset($this->sessionCache['subdirs'])) {\n            $this->sessionCache['subdirs'][$path] = $hasDir;\n        }\n    }\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $outPath = $this->convEncOut($path);\n        if (isset($this->cache[$outPath])) {\n            return $this->convEncIn($this->cache[$outPath]);\n        } else {\n            $this->convEncIn();\n        }\n        if ($path === $this->root) {\n            $res = array(\n                'name' => $this->root,\n                'mime' => 'directory',\n                'dirs' => -1\n            );\n            if ($this->needOnline && (($this->ARGS['cmd'] === 'open' && $this->ARGS['target'] === $this->encode($this->root)) || $this->isMyReload())) {\n                $check = array(\n                    'ts' => true,\n                    'dirs' => true,\n                );\n                $ts = 0;\n                foreach ($this->ftpRawList($path) as $str) {\n                    $info = preg_split('/\\s+/', $str, 9);\n                    if ($info[8] === '.') {\n                        $info[8] = 'root';\n                        if ($stat = $this->parseRaw(join(' ', $info), $path)) {\n                            unset($stat['name']);\n                            $res = array_merge($res, $stat);\n                            if ($res['ts']) {\n                                $ts = 0;\n                                unset($check['ts']);\n                            }\n                        }\n                    }\n                    if ($check && ($stat = $this->parseRaw($str, $path))) {\n                        if (isset($stat['ts']) && !empty($stat['ts'])) {\n                            $ts = max($ts, $stat['ts']);\n                        }\n                        if (isset($stat['dirs']) && $stat['mime'] === 'directory') {\n                            $res['dirs'] = 1;\n                            unset($stat['dirs']);\n                        }\n                        if (!$check) {\n                            break;\n                        }\n                    }\n                }\n                if ($ts) {\n                    $res['ts'] = $ts;\n                }\n                $this->cache[$outPath] = $res;\n            }\n            return $res;\n        }\n\n        $pPath = $this->_dirname($path);\n        if ($this->_inPath($pPath, $this->root)) {\n            $outPPpath = $this->convEncOut($pPath);\n            if (!isset($this->dirsCache[$outPPpath])) {\n                $parentSubdirs = null;\n                if (isset($this->sessionCache['subdirs']) && isset($this->sessionCache['subdirs'][$outPPpath])) {\n                    $parentSubdirs = $this->sessionCache['subdirs'][$outPPpath];\n                }\n                $this->cacheDir($outPPpath);\n                if ($parentSubdirs) {\n                    $this->sessionCache['subdirs'][$outPPpath] = $parentSubdirs;\n                }\n            }\n        }\n\n        $stat = $this->convEncIn(isset($this->cache[$outPath]) ? $this->cache[$outPath] : array());\n        if (!$this->mounted) {\n            // dispose incomplete cache made by calling `stat` by 'startPath' option\n            $this->cache = array();\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov, sitecode\n     **/\n    protected function _subdirs($path)\n    {\n        foreach ($this->ftpRawList($path) as $info) {\n            $name = $info['filename'];\n            if ($name && $name !== '.' && $name !== '..' && $info['type'] == NET_SFTP_TYPE_DIRECTORY) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @throws elFinderAbortException\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        if ($this->tmp) {\n            $local = $this->getTempFile($path);\n            $this->connect->get($path, $local);\n            return @fopen($local, $mode);\n        }\n\n        return false;\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        is_resource($fp) && fclose($fp);\n        if ($path) {\n            unlink($this->getTempFile($path));\n        }\n    }\n\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $this->_basename($name));\n        if ($this->connect->mkdir($path) === false) {\n            return false;\n        }\n\n        $this->options['dirMode'] && $this->connect->chmod($this->options['dirMode'], $path);\n        return $path;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author sitecode\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $this->_basename($name));\n        return $this->connect->put($path, '') ? $path : false;\n/*\n        if ($this->tmp) {\n            $path = $this->_joinPath($path, $name);\n            $local = $this->getTempFile();\n            $res = touch($local) && $this->connect->put($path, $local, NET_SFTP_LOCAL_FILE);\n            unlink($local);\n            return $res ? $path : false;\n        }\n\n        return false;\n */\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov, sitecode\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $res = false;\n\n        $target = $this->_joinPath($targetDir, $this->_basename($name));\n        if ($this->tmp) {\n            $local = $this->getTempFile();\n\n            if ($this->connect->get($source, $local)\n                && $this->connect->put($target, $local, NET_SFTP_LOCAL_FILE)) {\n                $res = true;\n            }\n            unlink($local);\n        } else {\n            //not memory efficient\n            $res = $this->_filePutContents($target, $this->_getContents($source));\n        }\n\n        return $res;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $target = $this->_joinPath($targetDir, $this->_basename($name));\n        return $this->connect->rename($source, $target) ? $target : false;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return $this->connect->delete($path, false);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return $this->connect->delete($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        //TODO optionally encrypt $fp before uploading if mime is not already encrypted type\n        $path = $this->_joinPath($dir, $this->_basename($name));\n        return $this->connect->put($path, $fp)\n            ? $path\n            : false;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _getContents($path)\n    {\n        return $this->connect->get($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return $this->connect->put($path, $content);\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return $this->connect->chmod($modeOct, $path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return true\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n        return false; //TODO\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return false; //TODO\n    }\n\n    /**\n     * Gets an array of absolute remote SFTP paths of files and\n     * folders in $remote_directory omitting symbolic links.\n     *\n     * @param $remote_directory string remote SFTP path to scan for file and folders recursively\n     * @param $targets          array  Array of target item. `null` is to get all of items\n     *\n     * @return array of elements each of which is an array of two elements:\n     * <ul>\n     * <li>$item['path'] - absolute remote SFTP path</li>\n     * <li>$item['type'] - either 'f' for file or 'd' for directory</li>\n     * </ul>\n     */\n    protected function ftp_scan_dir($remote_directory, $targets = null)\n    {\n        $buff = $this->ftpRawList($remote_directory);\n        $items = array();\n        if ($targets && is_array($targets)) {\n            $targets = array_flip($targets);\n        } else {\n            $targets = false;\n        }\n        foreach ($buff as $info) {\n            $name = $info['filename'];\n            if ($name !== '.' && $name !== '..' && (!$targets || isset($targets[$name]))) {\n                switch ($info['type']) {\n                    case NET_SFTP_TYPE_SYMLINK : //omit symbolic links\n                    case NET_SFTP_TYPE_DIRECTORY :\n                        $remote_file_path = $this->_joinPath($remote_directory, $name);\n                        $item = array();\n                        $item['path'] = $remote_file_path;\n                        $item['type'] = 'd'; // normal file\n                        $items[] = $item;\n                        $items = array_merge($items, $this->ftp_scan_dir($remote_file_path));\n                        break;\n                    default:\n                        $remote_file_path = $this->_joinPath($remote_directory, $name);\n                        $item = array();\n                        $item['path'] = $remote_file_path;\n                        $item['type'] = 'f'; // normal file\n                        $items[] = $item;\n                }\n            }\n        }\n        return $items;\n    }\n\n} // END class\n"], "filenames": ["php/elFinder.class.php", "php/elFinderVolumeDriver.class.php", "php/elFinderVolumeLocalFileSystem.class.php", "php/elFinderVolumeSFTPphpseclib.class.php"], "buggy_code_start_loc": [420, 5454, 78, 584], "buggy_code_end_loc": [5283, 6877, 1443, 710], "fixing_code_start_loc": [421, 5454, 77, 584], "fixing_code_end_loc": [5376, 6883, 1461, 710], "type": "CWE-22", "message": "elFinder is an open-source file manager for web, written in JavaScript using jQuery UI. Several vulnerabilities affect elFinder 2.1.58. These vulnerabilities can allow an attacker to execute arbitrary code and commands on the server hosting the elFinder PHP connector, even with minimal configuration. The issues were patched in version 2.1.59. As a workaround, ensure the connector is not exposed without authentication.", "other": {"cve": {"id": "CVE-2021-32682", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-14T17:15:07.643", "lastModified": "2022-11-09T03:53:41.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "elFinder is an open-source file manager for web, written in JavaScript using jQuery UI. Several vulnerabilities affect elFinder 2.1.58. These vulnerabilities can allow an attacker to execute arbitrary code and commands on the server hosting the elFinder PHP connector, even with minimal configuration. The issues were patched in version 2.1.59. As a workaround, ensure the connector is not exposed without authentication."}, {"lang": "es", "value": "elFinder es un administrador de archivos de c\u00f3digo abierto para la web, escrito en JavaScript usando la Interfaz de Usuario jQuery. M\u00faltiples vulnerabilidades afectan a elFinder versi\u00f3n 2.1.58. Estas vulnerabilidades pueden permitir a un atacante ejecutar c\u00f3digo y comandos arbitrarios en el servidor que aloja el conector PHP de elFinder, inclusive con una configuraci\u00f3n m\u00ednima. Los problemas fueron parcheados en la versi\u00f3n 2.1.59. Como soluci\u00f3n, aseg\u00farese de que el conector no est\u00e1 expuesto sin autenticaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-78"}, {"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:std42:elfinder:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.59", "matchCriteriaId": "093B9248-A377-422A-BECF-73EAED6B1B2F"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/164173/elFinder-Archive-Command-Injection.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/commit/a106c350b7dfe666a81d6b576816db9fe0899b17", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/security/advisories/GHSA-wph3-44rj-92pr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Studio-42/elFinder/commit/a106c350b7dfe666a81d6b576816db9fe0899b17"}}