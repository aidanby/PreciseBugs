{"buggy_code": ["/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"cpuid.h\"\n#include \"lapic.h\"\n\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/trace_events.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/hrtimer.h>\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n\n#include <asm/cpu.h>\n#include <asm/io.h>\n#include <asm/desc.h>\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/mce.h>\n#include <asm/fpu/internal.h>\n#include <asm/perf_event.h>\n#include <asm/debugreg.h>\n#include <asm/kexec.h>\n#include <asm/apic.h>\n#include <asm/irq_remapping.h>\n\n#include \"trace.h\"\n#include \"pmu.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n#define __ex_clear(x, reg) \\\n\t____kvm_handle_fault_on_reboot(x, \"xor \" reg \" , \" reg)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_VMX),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n\nstatic bool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly vmm_exclusive = 1;\nmodule_param(vmm_exclusive, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_apicv = 1;\nmodule_param(enable_apicv, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_shadow_vmcs = 1;\nmodule_param_named(enable_shadow_vmcs, enable_shadow_vmcs, bool, S_IRUGO);\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 0;\nmodule_param(nested, bool, S_IRUGO);\n\nstatic u64 __read_mostly host_xss;\n\nstatic bool __read_mostly enable_pml = 1;\nmodule_param_named(pml, enable_pml, bool, S_IRUGO);\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\n/* Guest_tsc -> host_tsc conversion requires 64-bit division.  */\nstatic int __read_mostly cpu_preemption_timer_multi;\nstatic bool __read_mostly enable_preemption_timer = 1;\n#ifdef CONFIG_X86_64\nmodule_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);\n#endif\n\n#define KVM_GUEST_CR0_MASK (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST (X86_CR0_WP | X86_CR0_NE)\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_TSD)\n\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE 5\n\n#define VMX_VPID_EXTENT_SUPPORTED_MASK\t\t\\\n\t(VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_NON_GLOBAL_BIT)\n\n/*\n * Hyper-V requires all of these, so mark them as supported even though\n * they are just treated the same as all-context.\n */\n#define VMX_VPID_EXTENT_SUPPORTED_MASK\t\t\\\n\t(VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_NON_GLOBAL_BIT)\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\n#define KVM_VMX_DEFAULT_PLE_GAP           128\n#define KVM_VMX_DEFAULT_PLE_WINDOW        4096\n#define KVM_VMX_DEFAULT_PLE_WINDOW_GROW   2\n#define KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK 0\n#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    \\\n\t\tINT_MAX / KVM_VMX_DEFAULT_PLE_WINDOW_GROW\n\nstatic int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, int, S_IRUGO);\n\nstatic int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, int, S_IRUGO);\n\n/* Default doubles per-vcpu window every exit. */\nstatic int ple_window_grow = KVM_VMX_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, int, S_IRUGO);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic int ple_window_shrink = KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, int, S_IRUGO);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic int ple_window_actual_max = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, int, S_IRUGO);\n\nextern const ulong vmx_return;\n\n#define NR_AUTOLOAD_MSRS 8\n#define VMCS02_POOL_SIZE 1\n\nstruct vmcs {\n\tu32 revision_id;\n\tu32 abort;\n\tchar data[0];\n};\n\n/*\n * Track a VMCS that may be loaded on a certain CPU. If it is (cpu!=-1), also\n * remember whether it was VMLAUNCHed, and maintain a linked list of all VMCSs\n * loaded on this CPU (so we can clear them if the CPU goes down).\n */\nstruct loaded_vmcs {\n\tstruct vmcs *vmcs;\n\tstruct vmcs *shadow_vmcs;\n\tint cpu;\n\tint launched;\n\tstruct list_head loaded_vmcss_on_cpu_link;\n};\n\nstruct shared_msr_entry {\n\tunsigned index;\n\tu64 data;\n\tu64 mask;\n};\n\n/*\n * struct vmcs12 describes the state that our guest hypervisor (L1) keeps for a\n * single nested guest (L2), hence the name vmcs12. Any VMX implementation has\n * a VMCS structure, and vmcs12 is our emulated VMX's VMCS. This structure is\n * stored in guest memory specified by VMPTRLD, but is opaque to the guest,\n * which must access it using VMREAD/VMWRITE/VMCLEAR instructions.\n * More than one of these structures may exist, if L1 runs multiple L2 guests.\n * nested_vmx_run() will use the data here to build a vmcs02: a VMCS for the\n * underlying hardware which will be used to run L2.\n * This structure is packed to ensure that its layout is identical across\n * machines (necessary for live migration).\n * If there are changes in this struct, VMCS12_REVISION must be changed.\n */\ntypedef u64 natural_width;\nstruct __packed vmcs12 {\n\t/* According to the Intel spec, a VMCS region must start with the\n\t * following two fields. Then follow implementation-specific data.\n\t */\n\tu32 revision_id;\n\tu32 abort;\n\n\tu32 launch_state; /* set to 0 by VMCLEAR, to 1 by VMLAUNCH */\n\tu32 padding[7]; /* room for future expansion */\n\n\tu64 io_bitmap_a;\n\tu64 io_bitmap_b;\n\tu64 msr_bitmap;\n\tu64 vm_exit_msr_store_addr;\n\tu64 vm_exit_msr_load_addr;\n\tu64 vm_entry_msr_load_addr;\n\tu64 tsc_offset;\n\tu64 virtual_apic_page_addr;\n\tu64 apic_access_addr;\n\tu64 posted_intr_desc_addr;\n\tu64 ept_pointer;\n\tu64 eoi_exit_bitmap0;\n\tu64 eoi_exit_bitmap1;\n\tu64 eoi_exit_bitmap2;\n\tu64 eoi_exit_bitmap3;\n\tu64 xss_exit_bitmap;\n\tu64 guest_physical_address;\n\tu64 vmcs_link_pointer;\n\tu64 guest_ia32_debugctl;\n\tu64 guest_ia32_pat;\n\tu64 guest_ia32_efer;\n\tu64 guest_ia32_perf_global_ctrl;\n\tu64 guest_pdptr0;\n\tu64 guest_pdptr1;\n\tu64 guest_pdptr2;\n\tu64 guest_pdptr3;\n\tu64 guest_bndcfgs;\n\tu64 host_ia32_pat;\n\tu64 host_ia32_efer;\n\tu64 host_ia32_perf_global_ctrl;\n\tu64 padding64[8]; /* room for future expansion */\n\t/*\n\t * To allow migration of L1 (complete with its L2 guests) between\n\t * machines of different natural widths (32 or 64 bit), we cannot have\n\t * unsigned long fields with no explict size. We use u64 (aliased\n\t * natural_width) instead. Luckily, x86 is little-endian.\n\t */\n\tnatural_width cr0_guest_host_mask;\n\tnatural_width cr4_guest_host_mask;\n\tnatural_width cr0_read_shadow;\n\tnatural_width cr4_read_shadow;\n\tnatural_width cr3_target_value0;\n\tnatural_width cr3_target_value1;\n\tnatural_width cr3_target_value2;\n\tnatural_width cr3_target_value3;\n\tnatural_width exit_qualification;\n\tnatural_width guest_linear_address;\n\tnatural_width guest_cr0;\n\tnatural_width guest_cr3;\n\tnatural_width guest_cr4;\n\tnatural_width guest_es_base;\n\tnatural_width guest_cs_base;\n\tnatural_width guest_ss_base;\n\tnatural_width guest_ds_base;\n\tnatural_width guest_fs_base;\n\tnatural_width guest_gs_base;\n\tnatural_width guest_ldtr_base;\n\tnatural_width guest_tr_base;\n\tnatural_width guest_gdtr_base;\n\tnatural_width guest_idtr_base;\n\tnatural_width guest_dr7;\n\tnatural_width guest_rsp;\n\tnatural_width guest_rip;\n\tnatural_width guest_rflags;\n\tnatural_width guest_pending_dbg_exceptions;\n\tnatural_width guest_sysenter_esp;\n\tnatural_width guest_sysenter_eip;\n\tnatural_width host_cr0;\n\tnatural_width host_cr3;\n\tnatural_width host_cr4;\n\tnatural_width host_fs_base;\n\tnatural_width host_gs_base;\n\tnatural_width host_tr_base;\n\tnatural_width host_gdtr_base;\n\tnatural_width host_idtr_base;\n\tnatural_width host_ia32_sysenter_esp;\n\tnatural_width host_ia32_sysenter_eip;\n\tnatural_width host_rsp;\n\tnatural_width host_rip;\n\tnatural_width paddingl[8]; /* room for future expansion */\n\tu32 pin_based_vm_exec_control;\n\tu32 cpu_based_vm_exec_control;\n\tu32 exception_bitmap;\n\tu32 page_fault_error_code_mask;\n\tu32 page_fault_error_code_match;\n\tu32 cr3_target_count;\n\tu32 vm_exit_controls;\n\tu32 vm_exit_msr_store_count;\n\tu32 vm_exit_msr_load_count;\n\tu32 vm_entry_controls;\n\tu32 vm_entry_msr_load_count;\n\tu32 vm_entry_intr_info_field;\n\tu32 vm_entry_exception_error_code;\n\tu32 vm_entry_instruction_len;\n\tu32 tpr_threshold;\n\tu32 secondary_vm_exec_control;\n\tu32 vm_instruction_error;\n\tu32 vm_exit_reason;\n\tu32 vm_exit_intr_info;\n\tu32 vm_exit_intr_error_code;\n\tu32 idt_vectoring_info_field;\n\tu32 idt_vectoring_error_code;\n\tu32 vm_exit_instruction_len;\n\tu32 vmx_instruction_info;\n\tu32 guest_es_limit;\n\tu32 guest_cs_limit;\n\tu32 guest_ss_limit;\n\tu32 guest_ds_limit;\n\tu32 guest_fs_limit;\n\tu32 guest_gs_limit;\n\tu32 guest_ldtr_limit;\n\tu32 guest_tr_limit;\n\tu32 guest_gdtr_limit;\n\tu32 guest_idtr_limit;\n\tu32 guest_es_ar_bytes;\n\tu32 guest_cs_ar_bytes;\n\tu32 guest_ss_ar_bytes;\n\tu32 guest_ds_ar_bytes;\n\tu32 guest_fs_ar_bytes;\n\tu32 guest_gs_ar_bytes;\n\tu32 guest_ldtr_ar_bytes;\n\tu32 guest_tr_ar_bytes;\n\tu32 guest_interruptibility_info;\n\tu32 guest_activity_state;\n\tu32 guest_sysenter_cs;\n\tu32 host_ia32_sysenter_cs;\n\tu32 vmx_preemption_timer_value;\n\tu32 padding32[7]; /* room for future expansion */\n\tu16 virtual_processor_id;\n\tu16 posted_intr_nv;\n\tu16 guest_es_selector;\n\tu16 guest_cs_selector;\n\tu16 guest_ss_selector;\n\tu16 guest_ds_selector;\n\tu16 guest_fs_selector;\n\tu16 guest_gs_selector;\n\tu16 guest_ldtr_selector;\n\tu16 guest_tr_selector;\n\tu16 guest_intr_status;\n\tu16 host_es_selector;\n\tu16 host_cs_selector;\n\tu16 host_ss_selector;\n\tu16 host_ds_selector;\n\tu16 host_fs_selector;\n\tu16 host_gs_selector;\n\tu16 host_tr_selector;\n};\n\n/*\n * VMCS12_REVISION is an arbitrary id that should be changed if the content or\n * layout of struct vmcs12 is changed. MSR_IA32_VMX_BASIC returns this id, and\n * VMPTRLD verifies that the VMCS region that L1 is loading contains this id.\n */\n#define VMCS12_REVISION 0x11e57ed0\n\n/*\n * VMCS12_SIZE is the number of bytes L1 should allocate for the VMXON region\n * and any VMCS region. Although only sizeof(struct vmcs12) are used by the\n * current implementation, 4K are reserved to avoid future complications.\n */\n#define VMCS12_SIZE 0x1000\n\n/* Used to remember the last vmcs02 used for some recently used vmcs12s */\nstruct vmcs02_list {\n\tstruct list_head list;\n\tgpa_t vmptr;\n\tstruct loaded_vmcs vmcs02;\n};\n\n/*\n * The nested_vmx structure is part of vcpu_vmx, and holds information we need\n * for correct emulation of VMX (i.e., nested VMX) on this vcpu.\n */\nstruct nested_vmx {\n\t/* Has the level1 guest done vmxon? */\n\tbool vmxon;\n\tgpa_t vmxon_ptr;\n\n\t/* The guest-physical address of the current VMCS L1 keeps for L2 */\n\tgpa_t current_vmptr;\n\t/* The host-usable pointer to the above */\n\tstruct page *current_vmcs12_page;\n\tstruct vmcs12 *current_vmcs12;\n\t/*\n\t * Cache of the guest's VMCS, existing outside of guest memory.\n\t * Loaded from guest memory during VMPTRLD. Flushed to guest\n\t * memory during VMXOFF, VMCLEAR, VMPTRLD.\n\t */\n\tstruct vmcs12 *cached_vmcs12;\n\t/*\n\t * Indicates if the shadow vmcs must be updated with the\n\t * data hold by vmcs12\n\t */\n\tbool sync_shadow_vmcs;\n\n\t/* vmcs02_list cache of VMCSs recently used to run L2 guests */\n\tstruct list_head vmcs02_pool;\n\tint vmcs02_num;\n\tbool change_vmcs01_virtual_x2apic_mode;\n\t/* L2 must run next, and mustn't decide to exit to L1. */\n\tbool nested_run_pending;\n\t/*\n\t * Guest pages referred to in vmcs02 with host-physical pointers, so\n\t * we must keep them pinned while L2 runs.\n\t */\n\tstruct page *apic_access_page;\n\tstruct page *virtual_apic_page;\n\tstruct page *pi_desc_page;\n\tstruct pi_desc *pi_desc;\n\tbool pi_pending;\n\tu16 posted_intr_nv;\n\n\tunsigned long *msr_bitmap;\n\n\tstruct hrtimer preemption_timer;\n\tbool preemption_timer_expired;\n\n\t/* to migrate it to L2 if VM_ENTRY_LOAD_DEBUG_CONTROLS is off */\n\tu64 vmcs01_debugctl;\n\n\tu16 vpid02;\n\tu16 last_vpid;\n\n\t/*\n\t * We only store the \"true\" versions of the VMX capability MSRs. We\n\t * generate the \"non-true\" versions by setting the must-be-1 bits\n\t * according to the SDM.\n\t */\n\tu32 nested_vmx_procbased_ctls_low;\n\tu32 nested_vmx_procbased_ctls_high;\n\tu32 nested_vmx_secondary_ctls_low;\n\tu32 nested_vmx_secondary_ctls_high;\n\tu32 nested_vmx_pinbased_ctls_low;\n\tu32 nested_vmx_pinbased_ctls_high;\n\tu32 nested_vmx_exit_ctls_low;\n\tu32 nested_vmx_exit_ctls_high;\n\tu32 nested_vmx_entry_ctls_low;\n\tu32 nested_vmx_entry_ctls_high;\n\tu32 nested_vmx_misc_low;\n\tu32 nested_vmx_misc_high;\n\tu32 nested_vmx_ept_caps;\n\tu32 nested_vmx_vpid_caps;\n\tu64 nested_vmx_basic;\n\tu64 nested_vmx_cr0_fixed0;\n\tu64 nested_vmx_cr0_fixed1;\n\tu64 nested_vmx_cr4_fixed0;\n\tu64 nested_vmx_cr4_fixed1;\n\tu64 nested_vmx_vmcs_enum;\n};\n\n#define POSTED_INTR_ON  0\n#define POSTED_INTR_SN  1\n\n/* Posted-Interrupt Descriptor */\nstruct pi_desc {\n\tu32 pir[8];     /* Posted interrupt requested */\n\tunion {\n\t\tstruct {\n\t\t\t\t/* bit 256 - Outstanding Notification */\n\t\t\tu16\ton\t: 1,\n\t\t\t\t/* bit 257 - Suppress Notification */\n\t\t\t\tsn\t: 1,\n\t\t\t\t/* bit 271:258 - Reserved */\n\t\t\t\trsvd_1\t: 14;\n\t\t\t\t/* bit 279:272 - Notification Vector */\n\t\t\tu8\tnv;\n\t\t\t\t/* bit 287:280 - Reserved */\n\t\t\tu8\trsvd_2;\n\t\t\t\t/* bit 319:288 - Notification Destination */\n\t\t\tu32\tndst;\n\t\t};\n\t\tu64 control;\n\t};\n\tu32 rsvd[6];\n} __aligned(64);\n\nstatic bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic bool pi_test_and_clear_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_clear_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}\n\nstatic inline void pi_clear_sn(struct pi_desc *pi_desc)\n{\n\treturn clear_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline void pi_set_sn(struct pi_desc *pi_desc)\n{\n\treturn set_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n  \t\t  (unsigned long *)&pi_desc->control);\n}\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstruct vcpu_vmx {\n\tstruct kvm_vcpu       vcpu;\n\tunsigned long         host_rsp;\n\tu8                    fail;\n\tbool                  nmi_known_unmasked;\n\tu32                   exit_intr_info;\n\tu32                   idt_vectoring_info;\n\tulong                 rflags;\n\tstruct shared_msr_entry *guest_msrs;\n\tint                   nmsrs;\n\tint                   save_nmsrs;\n\tunsigned long\t      host_idt_base;\n#ifdef CONFIG_X86_64\n\tu64 \t\t      msr_host_kernel_gs_base;\n\tu64 \t\t      msr_guest_kernel_gs_base;\n#endif\n\tu32 vm_entry_controls_shadow;\n\tu32 vm_exit_controls_shadow;\n\t/*\n\t * loaded_vmcs points to the VMCS currently used in this vcpu. For a\n\t * non-nested (L1) guest, it always points to vmcs01. For a nested\n\t * guest (L2), it points to a different VMCS.\n\t */\n\tstruct loaded_vmcs    vmcs01;\n\tstruct loaded_vmcs   *loaded_vmcs;\n\tbool                  __launched; /* temporary, used in vmx_vcpu_run */\n\tstruct msr_autoload {\n\t\tunsigned nr;\n\t\tstruct vmx_msr_entry guest[NR_AUTOLOAD_MSRS];\n\t\tstruct vmx_msr_entry host[NR_AUTOLOAD_MSRS];\n\t} msr_autoload;\n\tstruct {\n\t\tint           loaded;\n\t\tu16           fs_sel, gs_sel, ldt_sel;\n#ifdef CONFIG_X86_64\n\t\tu16           ds_sel, es_sel;\n#endif\n\t\tint           gs_ldt_reload_needed;\n\t\tint           fs_reload_needed;\n\t\tu64           msr_host_bndcfgs;\n\t\tunsigned long vmcs_host_cr4;\t/* May not match real cr4 */\n\t} host_state;\n\tstruct {\n\t\tint vm86_active;\n\t\tulong save_rflags;\n\t\tstruct kvm_segment segs[8];\n\t} rmode;\n\tstruct {\n\t\tu32 bitmask; /* 4 bits per segment (1 bit per field) */\n\t\tstruct kvm_save_segment {\n\t\t\tu16 selector;\n\t\t\tunsigned long base;\n\t\t\tu32 limit;\n\t\t\tu32 ar;\n\t\t} seg[8];\n\t} segment_cache;\n\tint vpid;\n\tbool emulation_required;\n\n\t/* Support for vnmi-less CPUs */\n\tint soft_vnmi_blocked;\n\tktime_t entry_time;\n\ts64 vnmi_blocked_time;\n\tu32 exit_reason;\n\n\t/* Posted interrupt descriptor */\n\tstruct pi_desc pi_desc;\n\n\t/* Support for a guest hypervisor (nested VMX) */\n\tstruct nested_vmx nested;\n\n\t/* Dynamic PLE window. */\n\tint ple_window;\n\tbool ple_window_dirty;\n\n\t/* Support for PML */\n#define PML_ENTITY_NUM\t\t512\n\tstruct page *pml_pg;\n\n\t/* apic deadline value in host tsc */\n\tu64 hv_deadline_tsc;\n\n\tu64 current_tsc_ratio;\n\n\tbool guest_pkru_valid;\n\tu32 guest_pkru;\n\tu32 host_pkru;\n\n\t/*\n\t * Only bits masked by msr_ia32_feature_control_valid_bits can be set in\n\t * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included\n\t * in msr_ia32_feature_control_valid_bits.\n\t */\n\tu64 msr_ia32_feature_control;\n\tu64 msr_ia32_feature_control_valid_bits;\n};\n\nenum segment_cache_field {\n\tSEG_FIELD_SEL = 0,\n\tSEG_FIELD_BASE = 1,\n\tSEG_FIELD_LIMIT = 2,\n\tSEG_FIELD_AR = 3,\n\n\tSEG_FIELD_NR = 4\n};\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}\n\nstatic struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}\n\n#define VMCS12_OFFSET(x) offsetof(struct vmcs12, x)\n#define FIELD(number, name)\t[number] = VMCS12_OFFSET(name)\n#define FIELD64(number, name)\t[number] = VMCS12_OFFSET(name), \\\n\t\t\t\t[number##_HIGH] = VMCS12_OFFSET(name)+4\n\n\nstatic unsigned long shadow_read_only_fields[] = {\n\t/*\n\t * We do NOT shadow fields that are modified when L0\n\t * traps and emulates any vmx instruction (e.g. VMPTRLD,\n\t * VMXON...) executed by L1.\n\t * For example, VM_INSTRUCTION_ERROR is read\n\t * by L1 if a vmx instruction fails (part of the error path).\n\t * Note the code assumes this logic. If for some reason\n\t * we start shadowing these fields then we need to\n\t * force a shadow sync when L0 emulates vmx instructions\n\t * (e.g. force a sync if VM_INSTRUCTION_ERROR is modified\n\t * by nested_vmx_failValid)\n\t */\n\tVM_EXIT_REASON,\n\tVM_EXIT_INTR_INFO,\n\tVM_EXIT_INSTRUCTION_LEN,\n\tIDT_VECTORING_INFO_FIELD,\n\tIDT_VECTORING_ERROR_CODE,\n\tVM_EXIT_INTR_ERROR_CODE,\n\tEXIT_QUALIFICATION,\n\tGUEST_LINEAR_ADDRESS,\n\tGUEST_PHYSICAL_ADDRESS\n};\nstatic int max_shadow_read_only_fields =\n\tARRAY_SIZE(shadow_read_only_fields);\n\nstatic unsigned long shadow_read_write_fields[] = {\n\tTPR_THRESHOLD,\n\tGUEST_RIP,\n\tGUEST_RSP,\n\tGUEST_CR0,\n\tGUEST_CR3,\n\tGUEST_CR4,\n\tGUEST_INTERRUPTIBILITY_INFO,\n\tGUEST_RFLAGS,\n\tGUEST_CS_SELECTOR,\n\tGUEST_CS_AR_BYTES,\n\tGUEST_CS_LIMIT,\n\tGUEST_CS_BASE,\n\tGUEST_ES_BASE,\n\tGUEST_BNDCFGS,\n\tCR0_GUEST_HOST_MASK,\n\tCR0_READ_SHADOW,\n\tCR4_READ_SHADOW,\n\tTSC_OFFSET,\n\tEXCEPTION_BITMAP,\n\tCPU_BASED_VM_EXEC_CONTROL,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tVM_ENTRY_INTR_INFO_FIELD,\n\tVM_ENTRY_INSTRUCTION_LEN,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tHOST_FS_BASE,\n\tHOST_GS_BASE,\n\tHOST_FS_SELECTOR,\n\tHOST_GS_SELECTOR\n};\nstatic int max_shadow_read_write_fields =\n\tARRAY_SIZE(shadow_read_write_fields);\n\nstatic const unsigned short vmcs_field_to_offset_table[] = {\n\tFIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id),\n\tFIELD(POSTED_INTR_NV, posted_intr_nv),\n\tFIELD(GUEST_ES_SELECTOR, guest_es_selector),\n\tFIELD(GUEST_CS_SELECTOR, guest_cs_selector),\n\tFIELD(GUEST_SS_SELECTOR, guest_ss_selector),\n\tFIELD(GUEST_DS_SELECTOR, guest_ds_selector),\n\tFIELD(GUEST_FS_SELECTOR, guest_fs_selector),\n\tFIELD(GUEST_GS_SELECTOR, guest_gs_selector),\n\tFIELD(GUEST_LDTR_SELECTOR, guest_ldtr_selector),\n\tFIELD(GUEST_TR_SELECTOR, guest_tr_selector),\n\tFIELD(GUEST_INTR_STATUS, guest_intr_status),\n\tFIELD(HOST_ES_SELECTOR, host_es_selector),\n\tFIELD(HOST_CS_SELECTOR, host_cs_selector),\n\tFIELD(HOST_SS_SELECTOR, host_ss_selector),\n\tFIELD(HOST_DS_SELECTOR, host_ds_selector),\n\tFIELD(HOST_FS_SELECTOR, host_fs_selector),\n\tFIELD(HOST_GS_SELECTOR, host_gs_selector),\n\tFIELD(HOST_TR_SELECTOR, host_tr_selector),\n\tFIELD64(IO_BITMAP_A, io_bitmap_a),\n\tFIELD64(IO_BITMAP_B, io_bitmap_b),\n\tFIELD64(MSR_BITMAP, msr_bitmap),\n\tFIELD64(VM_EXIT_MSR_STORE_ADDR, vm_exit_msr_store_addr),\n\tFIELD64(VM_EXIT_MSR_LOAD_ADDR, vm_exit_msr_load_addr),\n\tFIELD64(VM_ENTRY_MSR_LOAD_ADDR, vm_entry_msr_load_addr),\n\tFIELD64(TSC_OFFSET, tsc_offset),\n\tFIELD64(VIRTUAL_APIC_PAGE_ADDR, virtual_apic_page_addr),\n\tFIELD64(APIC_ACCESS_ADDR, apic_access_addr),\n\tFIELD64(POSTED_INTR_DESC_ADDR, posted_intr_desc_addr),\n\tFIELD64(EPT_POINTER, ept_pointer),\n\tFIELD64(EOI_EXIT_BITMAP0, eoi_exit_bitmap0),\n\tFIELD64(EOI_EXIT_BITMAP1, eoi_exit_bitmap1),\n\tFIELD64(EOI_EXIT_BITMAP2, eoi_exit_bitmap2),\n\tFIELD64(EOI_EXIT_BITMAP3, eoi_exit_bitmap3),\n\tFIELD64(XSS_EXIT_BITMAP, xss_exit_bitmap),\n\tFIELD64(GUEST_PHYSICAL_ADDRESS, guest_physical_address),\n\tFIELD64(VMCS_LINK_POINTER, vmcs_link_pointer),\n\tFIELD64(GUEST_IA32_DEBUGCTL, guest_ia32_debugctl),\n\tFIELD64(GUEST_IA32_PAT, guest_ia32_pat),\n\tFIELD64(GUEST_IA32_EFER, guest_ia32_efer),\n\tFIELD64(GUEST_IA32_PERF_GLOBAL_CTRL, guest_ia32_perf_global_ctrl),\n\tFIELD64(GUEST_PDPTR0, guest_pdptr0),\n\tFIELD64(GUEST_PDPTR1, guest_pdptr1),\n\tFIELD64(GUEST_PDPTR2, guest_pdptr2),\n\tFIELD64(GUEST_PDPTR3, guest_pdptr3),\n\tFIELD64(GUEST_BNDCFGS, guest_bndcfgs),\n\tFIELD64(HOST_IA32_PAT, host_ia32_pat),\n\tFIELD64(HOST_IA32_EFER, host_ia32_efer),\n\tFIELD64(HOST_IA32_PERF_GLOBAL_CTRL, host_ia32_perf_global_ctrl),\n\tFIELD(PIN_BASED_VM_EXEC_CONTROL, pin_based_vm_exec_control),\n\tFIELD(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control),\n\tFIELD(EXCEPTION_BITMAP, exception_bitmap),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MASK, page_fault_error_code_mask),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MATCH, page_fault_error_code_match),\n\tFIELD(CR3_TARGET_COUNT, cr3_target_count),\n\tFIELD(VM_EXIT_CONTROLS, vm_exit_controls),\n\tFIELD(VM_EXIT_MSR_STORE_COUNT, vm_exit_msr_store_count),\n\tFIELD(VM_EXIT_MSR_LOAD_COUNT, vm_exit_msr_load_count),\n\tFIELD(VM_ENTRY_CONTROLS, vm_entry_controls),\n\tFIELD(VM_ENTRY_MSR_LOAD_COUNT, vm_entry_msr_load_count),\n\tFIELD(VM_ENTRY_INTR_INFO_FIELD, vm_entry_intr_info_field),\n\tFIELD(VM_ENTRY_EXCEPTION_ERROR_CODE, vm_entry_exception_error_code),\n\tFIELD(VM_ENTRY_INSTRUCTION_LEN, vm_entry_instruction_len),\n\tFIELD(TPR_THRESHOLD, tpr_threshold),\n\tFIELD(SECONDARY_VM_EXEC_CONTROL, secondary_vm_exec_control),\n\tFIELD(VM_INSTRUCTION_ERROR, vm_instruction_error),\n\tFIELD(VM_EXIT_REASON, vm_exit_reason),\n\tFIELD(VM_EXIT_INTR_INFO, vm_exit_intr_info),\n\tFIELD(VM_EXIT_INTR_ERROR_CODE, vm_exit_intr_error_code),\n\tFIELD(IDT_VECTORING_INFO_FIELD, idt_vectoring_info_field),\n\tFIELD(IDT_VECTORING_ERROR_CODE, idt_vectoring_error_code),\n\tFIELD(VM_EXIT_INSTRUCTION_LEN, vm_exit_instruction_len),\n\tFIELD(VMX_INSTRUCTION_INFO, vmx_instruction_info),\n\tFIELD(GUEST_ES_LIMIT, guest_es_limit),\n\tFIELD(GUEST_CS_LIMIT, guest_cs_limit),\n\tFIELD(GUEST_SS_LIMIT, guest_ss_limit),\n\tFIELD(GUEST_DS_LIMIT, guest_ds_limit),\n\tFIELD(GUEST_FS_LIMIT, guest_fs_limit),\n\tFIELD(GUEST_GS_LIMIT, guest_gs_limit),\n\tFIELD(GUEST_LDTR_LIMIT, guest_ldtr_limit),\n\tFIELD(GUEST_TR_LIMIT, guest_tr_limit),\n\tFIELD(GUEST_GDTR_LIMIT, guest_gdtr_limit),\n\tFIELD(GUEST_IDTR_LIMIT, guest_idtr_limit),\n\tFIELD(GUEST_ES_AR_BYTES, guest_es_ar_bytes),\n\tFIELD(GUEST_CS_AR_BYTES, guest_cs_ar_bytes),\n\tFIELD(GUEST_SS_AR_BYTES, guest_ss_ar_bytes),\n\tFIELD(GUEST_DS_AR_BYTES, guest_ds_ar_bytes),\n\tFIELD(GUEST_FS_AR_BYTES, guest_fs_ar_bytes),\n\tFIELD(GUEST_GS_AR_BYTES, guest_gs_ar_bytes),\n\tFIELD(GUEST_LDTR_AR_BYTES, guest_ldtr_ar_bytes),\n\tFIELD(GUEST_TR_AR_BYTES, guest_tr_ar_bytes),\n\tFIELD(GUEST_INTERRUPTIBILITY_INFO, guest_interruptibility_info),\n\tFIELD(GUEST_ACTIVITY_STATE, guest_activity_state),\n\tFIELD(GUEST_SYSENTER_CS, guest_sysenter_cs),\n\tFIELD(HOST_IA32_SYSENTER_CS, host_ia32_sysenter_cs),\n\tFIELD(VMX_PREEMPTION_TIMER_VALUE, vmx_preemption_timer_value),\n\tFIELD(CR0_GUEST_HOST_MASK, cr0_guest_host_mask),\n\tFIELD(CR4_GUEST_HOST_MASK, cr4_guest_host_mask),\n\tFIELD(CR0_READ_SHADOW, cr0_read_shadow),\n\tFIELD(CR4_READ_SHADOW, cr4_read_shadow),\n\tFIELD(CR3_TARGET_VALUE0, cr3_target_value0),\n\tFIELD(CR3_TARGET_VALUE1, cr3_target_value1),\n\tFIELD(CR3_TARGET_VALUE2, cr3_target_value2),\n\tFIELD(CR3_TARGET_VALUE3, cr3_target_value3),\n\tFIELD(EXIT_QUALIFICATION, exit_qualification),\n\tFIELD(GUEST_LINEAR_ADDRESS, guest_linear_address),\n\tFIELD(GUEST_CR0, guest_cr0),\n\tFIELD(GUEST_CR3, guest_cr3),\n\tFIELD(GUEST_CR4, guest_cr4),\n\tFIELD(GUEST_ES_BASE, guest_es_base),\n\tFIELD(GUEST_CS_BASE, guest_cs_base),\n\tFIELD(GUEST_SS_BASE, guest_ss_base),\n\tFIELD(GUEST_DS_BASE, guest_ds_base),\n\tFIELD(GUEST_FS_BASE, guest_fs_base),\n\tFIELD(GUEST_GS_BASE, guest_gs_base),\n\tFIELD(GUEST_LDTR_BASE, guest_ldtr_base),\n\tFIELD(GUEST_TR_BASE, guest_tr_base),\n\tFIELD(GUEST_GDTR_BASE, guest_gdtr_base),\n\tFIELD(GUEST_IDTR_BASE, guest_idtr_base),\n\tFIELD(GUEST_DR7, guest_dr7),\n\tFIELD(GUEST_RSP, guest_rsp),\n\tFIELD(GUEST_RIP, guest_rip),\n\tFIELD(GUEST_RFLAGS, guest_rflags),\n\tFIELD(GUEST_PENDING_DBG_EXCEPTIONS, guest_pending_dbg_exceptions),\n\tFIELD(GUEST_SYSENTER_ESP, guest_sysenter_esp),\n\tFIELD(GUEST_SYSENTER_EIP, guest_sysenter_eip),\n\tFIELD(HOST_CR0, host_cr0),\n\tFIELD(HOST_CR3, host_cr3),\n\tFIELD(HOST_CR4, host_cr4),\n\tFIELD(HOST_FS_BASE, host_fs_base),\n\tFIELD(HOST_GS_BASE, host_gs_base),\n\tFIELD(HOST_TR_BASE, host_tr_base),\n\tFIELD(HOST_GDTR_BASE, host_gdtr_base),\n\tFIELD(HOST_IDTR_BASE, host_idtr_base),\n\tFIELD(HOST_IA32_SYSENTER_ESP, host_ia32_sysenter_esp),\n\tFIELD(HOST_IA32_SYSENTER_EIP, host_ia32_sysenter_eip),\n\tFIELD(HOST_RSP, host_rsp),\n\tFIELD(HOST_RIP, host_rip),\n};\n\nstatic inline short vmcs_field_to_offset(unsigned long field)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(vmcs_field_to_offset_table) > SHRT_MAX);\n\n\tif (field >= ARRAY_SIZE(vmcs_field_to_offset_table) ||\n\t    vmcs_field_to_offset_table[field] == 0)\n\t\treturn -ENOENT;\n\n\treturn vmcs_field_to_offset_table[field];\n}\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}\n\nstatic struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)\n{\n\tstruct page *page = kvm_vcpu_gfn_to_page(vcpu, addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}\n\nstatic void nested_release_page_clean(struct page *page)\n{\n\tkvm_release_page_clean(page);\n}\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic u64 construct_eptp(unsigned long root_hpa);\nstatic void kvm_cpu_vmxon(u64 addr);\nstatic void kvm_cpu_vmxoff(void);\nstatic bool vmx_xsaves_supported(void);\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr);\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx);\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx);\nstatic int alloc_identity_pagetable(struct kvm *kvm);\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nstatic DEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\nstatic DEFINE_PER_CPU(struct desc_ptr, host_gdt);\n\n/*\n * We maintian a per-CPU linked-list of vCPU, so in wakeup_handler() we\n * can find which vCPU should be waken up.\n */\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nenum {\n\tVMX_IO_BITMAP_A,\n\tVMX_IO_BITMAP_B,\n\tVMX_MSR_BITMAP_LEGACY,\n\tVMX_MSR_BITMAP_LONGMODE,\n\tVMX_MSR_BITMAP_LEGACY_X2APIC_APICV,\n\tVMX_MSR_BITMAP_LONGMODE_X2APIC_APICV,\n\tVMX_MSR_BITMAP_LEGACY_X2APIC,\n\tVMX_MSR_BITMAP_LONGMODE_X2APIC,\n\tVMX_VMREAD_BITMAP,\n\tVMX_VMWRITE_BITMAP,\n\tVMX_BITMAP_NR\n};\n\nstatic unsigned long *vmx_bitmap[VMX_BITMAP_NR];\n\n#define vmx_io_bitmap_a                      (vmx_bitmap[VMX_IO_BITMAP_A])\n#define vmx_io_bitmap_b                      (vmx_bitmap[VMX_IO_BITMAP_B])\n#define vmx_msr_bitmap_legacy                (vmx_bitmap[VMX_MSR_BITMAP_LEGACY])\n#define vmx_msr_bitmap_longmode              (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE])\n#define vmx_msr_bitmap_legacy_x2apic_apicv   (vmx_bitmap[VMX_MSR_BITMAP_LEGACY_X2APIC_APICV])\n#define vmx_msr_bitmap_longmode_x2apic_apicv (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE_X2APIC_APICV])\n#define vmx_msr_bitmap_legacy_x2apic         (vmx_bitmap[VMX_MSR_BITMAP_LEGACY_X2APIC])\n#define vmx_msr_bitmap_longmode_x2apic       (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE_X2APIC])\n#define vmx_vmread_bitmap                    (vmx_bitmap[VMX_VMREAD_BITMAP])\n#define vmx_vmwrite_bitmap                   (vmx_bitmap[VMX_VMWRITE_BITMAP])\n\nstatic bool cpu_has_load_ia32_efer;\nstatic bool cpu_has_load_perf_global_ctrl;\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 basic_cap;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic struct vmx_capability {\n\tu32 ept;\n\tu32 vpid;\n} vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u64 host_efer;\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\n\n/*\n * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it\n * away by decrementing the array size.\n */\nstatic const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};\n\nstatic inline bool is_exception_n(u32 intr_info, u8 vector)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | vector | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_debug(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, DB_VECTOR);\n}\n\nstatic inline bool is_breakpoint(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, BP_VECTOR);\n}\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}\n\nstatic inline bool is_no_device(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, NM_VECTOR);\n}\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, UD_VECTOR);\n}\n\nstatic inline bool is_external_interrupt(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_EXT_INTR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}\n\nstatic inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_apic_accesses(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}\n\nstatic inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_virtual_intr_delivery(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY;\n}\n\n/*\n * Comment's format: document - errata name - stepping - processor name.\n * Refer from\n * https://www.virtualbox.org/svn/vbox/trunk/src/VBox/VMM/VMMR0/HMR0.cpp\n */\nstatic u32 vmx_preemption_cpu_tfms[] = {\n/* 323344.pdf - BA86   - D0 - Xeon 7500 Series */\n0x000206E6,\n/* 323056.pdf - AAX65  - C2 - Xeon L3406 */\n/* 322814.pdf - AAT59  - C2 - i7-600, i5-500, i5-400 and i3-300 Mobile */\n/* 322911.pdf - AAU65  - C2 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020652,\n/* 322911.pdf - AAU65  - K0 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020655,\n/* 322373.pdf - AAO95  - B1 - Xeon 3400 Series */\n/* 322166.pdf - AAN92  - B1 - i7-800 and i5-700 Desktop */\n/*\n * 320767.pdf - AAP86  - B1 -\n * i7-900 Mobile Extreme, i7-800 and i7-700 Mobile\n */\n0x000106E5,\n/* 321333.pdf - AAM126 - C0 - Xeon 3500 */\n0x000106A0,\n/* 321333.pdf - AAM126 - C1 - Xeon 3500 */\n0x000106A1,\n/* 320836.pdf - AAJ124 - C0 - i7-900 Desktop Extreme and i7-900 Desktop */\n0x000106A4,\n /* 321333.pdf - AAM126 - D0 - Xeon 3500 */\n /* 321324.pdf - AAK139 - D0 - Xeon 5500 */\n /* 320836.pdf - AAJ124 - D0 - i7-900 Extreme and i7-900 Desktop */\n0x000106A5,\n};\n\nstatic inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool cpu_has_vmx_preemption_timer(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline bool cpu_has_vmx_posted_intr(void)\n{\n\treturn IS_ENABLED(CONFIG_X86_LOCAL_APIC) &&\n\t\tvmcs_config.pin_based_exec_ctrl & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_EPT;\n}\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_basic_inout(void)\n{\n\treturn\t(((u64)vmcs_config.basic_cap << 32) & VMX_BASIC_INOUT);\n}\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_shadow_vmcs(void)\n{\n\tu64 vmx_msr;\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t/* check if the cpu supports writing r/o exit information fields */\n\tif (!(vmx_msr & MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS))\n\t\treturn false;\n\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}\n\nstatic inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}\n\nstatic inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}\n\nstatic inline bool nested_cpu_has_xsaves(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES) &&\n\t\tvmx_xsaves_supported();\n}\n\nstatic inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}\n\nstatic inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);\n}\n\nstatic inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);\n}\n\nstatic inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}\n\nstatic inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}\n\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification);\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification);\n\nstatic int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n\nstatic inline void __invept(int ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tasm volatile (__ex(ASM_VMX_INVEPT)\n\t\t\t/* CF==1 or ZF==1 --> rc = -1 */\n\t\t\t\"; ja 1f ; ud2 ; 1:\\n\"\n\t\t\t: : \"a\" (&operand), \"c\" (ext) : \"cc\", \"memory\");\n}\n\nstatic struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}\n\nstatic void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMCLEAR_RAX) \"; setna %0\"\n\t\t      : \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t      : \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmclear fail: %p/%llx\\n\",\n\t\t       vmcs, phys_addr);\n}\n\nstatic inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)\n{\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nstatic void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMPTRLD_RAX) \"; setna %0\"\n\t\t\t: \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t\t: \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmptrld %p/%llx failed\\n\",\n\t\t       vmcs, phys_addr);\n}\n\n#ifdef CONFIG_KEXEC_CORE\n/*\n * This bitmap is used to indicate whether the vmclear\n * operation is enabled on all cpus. All disabled by\n * default.\n */\nstatic cpumask_t crash_vmclear_enabled_bitmap = CPU_MASK_NONE;\n\nstatic inline void crash_enable_local_vmclear(int cpu)\n{\n\tcpumask_set_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline void crash_disable_local_vmclear(int cpu)\n{\n\tcpumask_clear_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline int crash_local_vmclear_enabled(int cpu)\n{\n\treturn cpumask_test_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tif (!crash_local_vmclear_enabled(cpu))\n\t\treturn;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#else\nstatic inline void crash_enable_local_vmclear(int cpu) { }\nstatic inline void crash_disable_local_vmclear(int cpu) { }\n#endif /* CONFIG_KEXEC_CORE */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\tcrash_disable_local_vmclear(cpu);\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * we should ensure updating loaded_vmcs->loaded_vmcss_on_cpu_link\n\t * is before setting loaded_vmcs->vcpu to -1 which is done in\n\t * loaded_vmcs_init. Otherwise, other cpu can see vcpu = -1 fist\n\t * then adds the vmcs into percpu list before it is deleted.\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs_init(loaded_vmcs);\n\tcrash_enable_local_vmclear(cpu);\n}\n\nstatic void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}\n\nstatic inline void ept_sync_global(void)\n{\n\tif (cpu_has_vmx_invept_global())\n\t\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (enable_ept) {\n\t\tif (cpu_has_vmx_invept_context())\n\t\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\t\telse\n\t\t\tept_sync_global();\n\t}\n}\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, \"%0\")\n\t\t      : \"=a\"(value) : \"d\"(field) : \"cc\");\n\treturn value;\n}\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tprintk(KERN_ERR \"vmwrite error: reg %lx value %lx (err %d)\\n\",\n\t       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n\tdump_stack();\n}\n\nstatic __always_inline void __vmcs_writel(unsigned long field, unsigned long value)\n{\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMWRITE_RAX_RDX) \"; setna %0\"\n\t\t       : \"=q\"(error) : \"a\"(value), \"d\"(field) : \"cc\");\n\tif (unlikely(error))\n\t\tvmwrite_error(field, value);\n}\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\tasm volatile (\"\");\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}\n\nstatic inline void vm_entry_controls_reset_shadow(struct vcpu_vmx *vmx)\n{\n\tvmx->vm_entry_controls_shadow = vmcs_read32(VM_ENTRY_CONTROLS);\n}\n\nstatic inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}\n\nstatic inline void vm_entry_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_entry_controls_shadow != val)\n\t\tvm_entry_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_entry_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_entry_controls_shadow;\n}\n\n\nstatic inline void vm_entry_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) | val);\n}\n\nstatic inline void vm_entry_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) & ~val);\n}\n\nstatic inline void vm_exit_controls_reset_shadow(struct vcpu_vmx *vmx)\n{\n\tvmx->vm_exit_controls_shadow = vmcs_read32(VM_EXIT_CONTROLS);\n}\n\nstatic inline void vm_exit_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_EXIT_CONTROLS, val);\n\tvmx->vm_exit_controls_shadow = val;\n}\n\nstatic inline void vm_exit_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_exit_controls_shadow != val)\n\t\tvm_exit_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}\n\n\nstatic inline void vm_exit_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) | val);\n}\n\nstatic inline void vm_exit_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) & ~val);\n}\n\nstatic void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!(vmx->vcpu.arch.regs_avail & (1 << VCPU_EXREG_SEGMENTS))) {\n\t\tvmx->vcpu.arch.regs_avail |= (1 << VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nstatic void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); /* bypass_guest_pf = 0 */\n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == m->nr)\n\t\treturn;\n\t--m->nr;\n\tm->guest[i] = m->guest[m->nr];\n\tm->host[i] = m->host[m->nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == NR_AUTOLOAD_MSRS) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t} else if (i == m->nr) {\n\t\t++m->nr;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n\t}\n\n\tm->guest[i].index = msr;\n\tm->guest[i].value = guest_val;\n\tm->host[i].index = msr;\n\tm->host[i].value = host_val;\n}\n\nstatic void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\tif (!enable_ept) {\n\t\t/*\n\t\t * NX is needed to handle CR0.WP=1, CR4.SMEP=1.  Testing\n\t\t * host CPUID is more efficient than testing guest CPUID\n\t\t * or CR4.  Host SMEP is anyway a requirement for guest SMEP.\n\t\t */\n\t\tif (boot_cpu_has(X86_FEATURE_SMEP))\n\t\t\tguest_efer |= EFER_NX;\n\t\telse if (!(guest_efer & EFER_NX))\n\t\t\tignore_bits |= EFER_NX;\n\t}\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer);\n\t\treturn false;\n\t} else {\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *d;\n\tunsigned long table_base;\n\tunsigned long v;\n\n\tif (!(selector & ~3))\n\t\treturn 0;\n\n\ttable_base = gdt->address;\n\n\tif (selector & 4) {           /* from ldt */\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~3))\n\t\t\treturn 0;\n\n\t\ttable_base = segment_base(ldt_selector);\n\t}\n\td = (struct desc_struct *)(table_base + (selector & ~7));\n\tv = get_desc_base(d);\n#ifdef CONFIG_X86_64\n       if (d->s == 0 && (d->type == 2 || d->type == 9 || d->type == 11))\n               v |= ((unsigned long)((struct ldttss_desc64 *)d)->base3) << 32;\n#endif\n\treturn v;\n}\n\nstatic inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n\nstatic void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (boot_cpu_has(X86_FEATURE_MPX))\n\t\trdmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n\nstatic void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu))\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(vmx->host_state.gs_sel);\n#else\n\t\tloadsegment(gs, vmx->host_state.gs_sel);\n#endif\n\t}\n\tif (vmx->host_state.fs_reload_needed)\n\t\tloadsegment(fs, vmx->host_state.fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(vmx->host_state.ds_sel | vmx->host_state.es_sel)) {\n\t\tloadsegment(ds, vmx->host_state.ds_sel);\n\t\tloadsegment(es, vmx->host_state.es_sel);\n\t}\n#endif\n\treload_tss();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tif (vmx->host_state.msr_host_bndcfgs)\n\t\twrmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tload_gdt(this_cpu_ptr(&host_gdt));\n}\n\nstatic void vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\t__vmx_load_host_state(vmx);\n\tpreempt_enable();\n}\n\nstatic void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\t/*\n\t\t * If 'nv' field is POSTED_INTR_WAKEUP_VECTOR, there\n\t\t * are two possible cases:\n\t\t * 1. After running 'pre_block', context switch\n\t\t *    happened. For this case, 'sn' was set in\n\t\t *    vmx_vcpu_put(), so we need to clear it here.\n\t\t * 2. After running 'pre_block', we were blocked,\n\t\t *    and woken up by some other guy. For this case,\n\t\t *    we don't need to do anything, 'pi_post_block'\n\t\t *    will do everything for us. However, we cannot\n\t\t *    check whether it is case #1 or case #2 here\n\t\t *    (maybe, not needed), so we also clear sn here,\n\t\t *    I think it is not a big deal.\n\t\t */\n\t\tif (pi_desc->nv != POSTED_INTR_WAKEUP_VECTOR) {\n\t\t\tif (vcpu->cpu != cpu) {\n\t\t\t\tdest = cpu_physical_id(cpu);\n\n\t\t\t\tif (x2apic_enabled())\n\t\t\t\t\tnew.ndst = dest;\n\t\t\t\telse\n\t\t\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\t\t\t}\n\n\t\t\t/* set 'NV' to 'notification vector' */\n\t\t\tnew.nv = POSTED_INTR_VECTOR;\n\t\t}\n\n\t\t/* Allow posting non-urgent interrupts */\n\t\tnew.sn = 0;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n}\n\nstatic void decache_tsc_multiplier(struct vcpu_vmx *vmx)\n{\n\tvmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;\n\tvmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(phys_addr);\n\telse if (!already_loaded)\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\n\tif (!already_loaded) {\n\t\tlocal_irq_disable();\n\t\tcrash_disable_local_vmclear(cpu);\n\n\t\t/*\n\t\t * Read loaded_vmcs->cpu should be before fetching\n\t\t * loaded_vmcs->loaded_vmcss_on_cpu_link.\n\t\t * See the comments in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tcrash_enable_local_vmclear(cpu);\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t}\n\n\tif (!already_loaded) {\n\t\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE, kvm_read_tr_base()); /* 22.2.4 */\n\t\tvmcs_writel(HOST_GDTR_BASE, gdt->address);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\tvmx->host_pkru = read_pkru();\n}\n\nstatic void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\t__vmx_load_host_state(to_vmx(vcpu));\n\tif (!vmm_exclusive) {\n\t\t__loaded_vmcs_clear(to_vmx(vcpu)->loaded_vmcs);\n\t\tvcpu->cpu = -1;\n\t\tkvm_cpu_vmxoff();\n\t}\n}\n\nstatic void vmx_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tulong cr0;\n\n\tif (vcpu->fpu_active)\n\t\treturn;\n\tvcpu->fpu_active = 1;\n\tcr0 = vmcs_readl(GUEST_CR0);\n\tcr0 &= ~(X86_CR0_TS | X86_CR0_MP);\n\tcr0 |= kvm_read_cr0_bits(vcpu, X86_CR0_TS | X86_CR0_MP);\n\tvmcs_writel(GUEST_CR0, cr0);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.cr0_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\n\n/*\n * Return the cr0 value that a nested guest would read. This is a combination\n * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by\n * its hypervisor (cr0_read_shadow).\n */\nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n\nstatic void vmx_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\t/* Note that there is no vcpu->fpu_active = 0 here. The caller must\n\t * set this *before* calling this function.\n\t */\n\tvmx_decache_cr0_guest_bits(vcpu);\n\tvmcs_set_bits(GUEST_CR0, X86_CR0_TS | X86_CR0_MP);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = 0;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1's specified read shadow might not contain the TS bit,\n\t\t * so now that we turned on shadowing of this bit, we need to\n\t\t * set this bit of the shadow. Like in nested_vmx_run we need\n\t\t * nested_read_cr0(vmcs12), but vmcs12->guest_cr0 is not yet\n\t\t * up-to-date here because we just decached cr0.TS (and we'll\n\t\t * only update vmcs12->guest_cr0 on nested exit).\n\t\t */\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tvmcs12->guest_cr0 = (vmcs12->guest_cr0 & ~X86_CR0_TS) |\n\t\t\t(vcpu->arch.cr0 & X86_CR0_TS);\n\t\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\t} else\n\t\tvmcs_writel(CR0_READ_SHADOW, vcpu->arch.cr0);\n}\n\nstatic unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags, save_rflags;\n\n\tif (!test_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = to_vmx(vcpu)->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tto_vmx(vcpu)->rflags = rflags;\n\t}\n\treturn to_vmx(vcpu)->rflags;\n}\n\nstatic void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\tto_vmx(vcpu)->rflags = rflags;\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tto_vmx(vcpu)->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n}\n\nstatic u32 vmx_get_pkru(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->guest_pkru;\n}\n\nstatic u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nstatic void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}\n\n/*\n * KVM wants to inject page-faults which it got to the guest. This function\n * checks whether in a nested guest, we need to inject them to L1 or L2.\n */\nstatic int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (!(vmcs12->exception_bitmap & (1u << nr)))\n\t\treturn 0;\n\n\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}\n\nstatic bool vmx_invpcid_supported(void)\n{\n\treturn cpu_has_vmx_invpcid() && enable_ept;\n}\n\n/*\n * Swap MSR entry in host/guest MSR entry array.\n */\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}\n\nstatic void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = to_vmx(vcpu)->nested.msr_bitmap;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu)) {\n\t\t\tif (is_long_mode(vcpu))\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic_apicv;\n\t\t\telse\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic_apicv;\n\t\t} else {\n\t\t\tif (is_long_mode(vcpu))\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\t\telse\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t\t}\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n\n/*\n * Set up the vmcs to automatically save and restore system\n * msrs.  Don't touch the 64-bit msrs if the guest is in legacy\n * mode, as fiddling with msrs is very expensive.\n */\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && guest_cpuid_has_rdtscp(&vmx->vcpu))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\t/*\n\t\t * MSR_STAR is only needed on long mode guests, and only\n\t\t * if efer.sce is enabled.\n\t\t */\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}\n\n/*\n * reads and returns guest's timestamp counter \"register\"\n * guest_tsc = (host_tsc * tsc multiplier) >> 48 + tsc_offset\n * -- Intel TSC Scaling for Virtualization White Paper, sec 1.3\n */\nstatic u64 guest_read_tsc(struct kvm_vcpu *vcpu)\n{\n\tu64 host_tsc, tsc_offset;\n\n\thost_tsc = rdtsc();\n\ttsc_offset = vmcs_read64(TSC_OFFSET);\n\treturn kvm_scale_tsc(vcpu, host_tsc) + tsc_offset;\n}\n\n/*\n * writes 'offset' into guest's timestamp counter offset register\n */\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t\t * to the spec, this should set L1's TSC; The offset that L1\n\t\t * set for L2 remains unchanged, and still needs to be added\n\t\t * to the newly set TSC to get L2's TSC.\n\t\t */\n\t\tstruct vmcs12 *vmcs12;\n\t\t/* recalculate vmcs02.TSC_OFFSET: */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tvmcs_write64(TSC_OFFSET, offset +\n\t\t\t(nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETING) ?\n\t\t\t vmcs12->tsc_offset : 0));\n\t} else {\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   vmcs_read64(TSC_OFFSET), offset);\n\t\tvmcs_write64(TSC_OFFSET, offset);\n\t}\n}\n\nstatic bool guest_cpuid_has_vmx(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & (1 << (X86_FEATURE_VMX & 31)));\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nstatic inline bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has_vmx(vcpu);\n}\n\n/*\n * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be\n * returned for the various VMX controls MSRs when nested VMX is enabled.\n * The same values should also be used to verify that vmcs12 control fields are\n * valid during nested entry from L1 to L2.\n * Each of these control msrs has a low and high 32-bit half: A low bit is on\n * if the corresponding bit in the (32-bit) control field *must* be on, and a\n * bit in the high half is on if the corresponding bit in the control field\n * may be on. See also vmx_control_verify().\n */\nstatic void nested_vmx_setup_ctls_msrs(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\tvmx->nested.nested_vmx_pinbased_ctls_high);\n\tvmx->nested.nested_vmx_pinbased_ctls_low |=\n\t\tPIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_pinbased_ctls_high &=\n\t\tPIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING |\n\t\tPIN_BASED_VIRTUAL_NMIS;\n\tvmx->nested.nested_vmx_pinbased_ctls_high |=\n\t\tPIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tvmx->nested.nested_vmx_pinbased_ctls_high |=\n\t\t\tPIN_BASED_POSTED_INTR;\n\n\t/* exit controls */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\tvmx->nested.nested_vmx_exit_ctls_high);\n\tvmx->nested.nested_vmx_exit_ctls_low =\n\t\tVM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\n\tvmx->nested.nested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tvmx->nested.nested_vmx_exit_ctls_high |=\n\t\tVM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER | VM_EXIT_ACK_INTR_ON_EXIT;\n\n\tif (kvm_mpx_supported())\n\t\tvmx->nested.nested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* We support free control of debug control saving. */\n\tvmx->nested.nested_vmx_exit_ctls_low &= ~VM_EXIT_SAVE_DEBUG_CONTROLS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\tvmx->nested.nested_vmx_entry_ctls_high);\n\tvmx->nested.nested_vmx_entry_ctls_low =\n\t\tVM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tvmx->nested.nested_vmx_entry_ctls_high |=\n\t\t(VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR | VM_ENTRY_LOAD_IA32_EFER);\n\tif (kvm_mpx_supported())\n\t\tvmx->nested.nested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* We support free control of debug control loading. */\n\tvmx->nested.nested_vmx_entry_ctls_low &= ~VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\tvmx->nested.nested_vmx_procbased_ctls_high);\n\tvmx->nested.nested_vmx_procbased_ctls_low =\n\t\tCPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_TRAP_FLAG |\n\t\tCPU_BASED_MONITOR_EXITING | CPU_BASED_RDPMC_EXITING |\n\t\tCPU_BASED_RDTSC_EXITING | CPU_BASED_PAUSE_EXITING |\n\t\tCPU_BASED_TPR_SHADOW | CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tvmx->nested.nested_vmx_procbased_ctls_high |=\n\t\tCPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tCPU_BASED_USE_MSR_BITMAPS;\n\n\t/* We support free control of CR3 access interception. */\n\tvmx->nested.nested_vmx_procbased_ctls_low &=\n\t\t~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\tvmx->nested.nested_vmx_secondary_ctls_high);\n\tvmx->nested.nested_vmx_secondary_ctls_low = 0;\n\tvmx->nested.nested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_RDTSCP |\n\t\tSECONDARY_EXEC_DESC |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\tSECONDARY_EXEC_XSAVES;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\tSECONDARY_EXEC_ENABLE_EPT;\n\t\tvmx->nested.nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tif (cpu_has_vmx_ept_execute_only())\n\t\t\tvmx->nested.nested_vmx_ept_caps |=\n\t\t\t\tVMX_EPT_EXECUTE_ONLY_BIT;\n\t\tvmx->nested.nested_vmx_ept_caps &= vmx_capability.ept;\n\t\tvmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |\n\t\t\tVMX_EPT_EXTENT_CONTEXT_BIT;\n\t} else\n\t\tvmx->nested.nested_vmx_ept_caps = 0;\n\n\t/*\n\t * Old versions of KVM use the single-context version without\n\t * checking for support, so declare that it is supported even\n\t * though it is treated as global context.  The alternative is\n\t * not failing the single-context invvpid, and it is worse.\n\t */\n\tif (enable_vpid)\n\t\tvmx->nested.nested_vmx_vpid_caps = VMX_VPID_INVVPID_BIT |\n\t\t\tVMX_VPID_EXTENT_SUPPORTED_MASK;\n\telse\n\t\tvmx->nested.nested_vmx_vpid_caps = 0;\n\n\tif (enable_unrestricted_guest)\n\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC,\n\t\tvmx->nested.nested_vmx_misc_low,\n\t\tvmx->nested.nested_vmx_misc_high);\n\tvmx->nested.nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tvmx->nested.nested_vmx_misc_low |=\n\t\tVMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tvmx->nested.nested_vmx_misc_high = 0;\n\n\t/*\n\t * This MSR reports some information about VMX support. We\n\t * should return information about the VMX we emulate for the\n\t * guest, and the VMCS structure we give it - not about the\n\t * VMX support of the underlying hardware.\n\t */\n\tvmx->nested.nested_vmx_basic =\n\t\tVMCS12_REVISION |\n\t\tVMX_BASIC_TRUE_CTLS |\n\t\t((u64)VMCS12_SIZE << VMX_BASIC_VMCS_SIZE_SHIFT) |\n\t\t(VMX_BASIC_MEM_TYPE_WB << VMX_BASIC_MEM_TYPE_SHIFT);\n\n\tif (cpu_has_vmx_basic_inout())\n\t\tvmx->nested.nested_vmx_basic |= VMX_BASIC_INOUT;\n\n\t/*\n\t * These MSRs specify bits which the guest must keep fixed on\n\t * while L1 is in VMXON mode (in L1's root mode, or running an L2).\n\t * We picked the standard core2 setting.\n\t */\n#define VMXON_CR0_ALWAYSON     (X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)\n#define VMXON_CR4_ALWAYSON     X86_CR4_VMXE\n\tvmx->nested.nested_vmx_cr0_fixed0 = VMXON_CR0_ALWAYSON;\n\tvmx->nested.nested_vmx_cr4_fixed0 = VMXON_CR4_ALWAYSON;\n\n\t/* These MSRs specify bits which the guest must keep fixed off. */\n\trdmsrl(MSR_IA32_VMX_CR0_FIXED1, vmx->nested.nested_vmx_cr0_fixed1);\n\trdmsrl(MSR_IA32_VMX_CR4_FIXED1, vmx->nested.nested_vmx_cr4_fixed1);\n\n\t/* highest index: VMX_PREEMPTION_TIMER_VALUE */\n\tvmx->nested.nested_vmx_vmcs_enum = 0x2e;\n}\n\n/*\n * if fixed0[i] == 1: val[i] must be 1\n * if fixed1[i] == 0: val[i] must be 0\n */\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}\n\nstatic inline bool vmx_control_verify(u32 control, u32 low, u32 high)\n{\n\treturn fixed_bits_valid(control, low, high);\n}\n\nstatic inline u64 vmx_control_msr(u32 low, u32 high)\n{\n\treturn low | ((u64)high << 32);\n}\n\nstatic bool is_bitwise_subset(u64 superset, u64 subset, u64 mask)\n{\n\tsuperset &= mask;\n\tsubset &= mask;\n\n\treturn (superset | subset) == superset;\n}\n\nstatic int vmx_restore_vmx_basic(struct vcpu_vmx *vmx, u64 data)\n{\n\tconst u64 feature_and_reserved =\n\t\t/* feature (except bit 48; see below) */\n\t\tBIT_ULL(49) | BIT_ULL(54) | BIT_ULL(55) |\n\t\t/* reserved */\n\t\tBIT_ULL(31) | GENMASK_ULL(47, 45) | GENMASK_ULL(63, 56);\n\tu64 vmx_basic = vmx->nested.nested_vmx_basic;\n\n\tif (!is_bitwise_subset(vmx_basic, data, feature_and_reserved))\n\t\treturn -EINVAL;\n\n\t/*\n\t * KVM does not emulate a version of VMX that constrains physical\n\t * addresses of VMX structures (e.g. VMCS) to 32-bits.\n\t */\n\tif (data & BIT_ULL(48))\n\t\treturn -EINVAL;\n\n\tif (vmx_basic_vmcs_revision_id(vmx_basic) !=\n\t    vmx_basic_vmcs_revision_id(data))\n\t\treturn -EINVAL;\n\n\tif (vmx_basic_vmcs_size(vmx_basic) > vmx_basic_vmcs_size(data))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_basic = data;\n\treturn 0;\n}\n\nstatic int\nvmx_restore_control_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)\n{\n\tu64 supported;\n\tu32 *lowp, *highp;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_pinbased_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_pinbased_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_procbased_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_procbased_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_exit_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_exit_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_entry_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_entry_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\tlowp = &vmx->nested.nested_vmx_secondary_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_secondary_ctls_high;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsupported = vmx_control_msr(*lowp, *highp);\n\n\t/* Check must-be-1 bits are still 1. */\n\tif (!is_bitwise_subset(data, supported, GENMASK_ULL(31, 0)))\n\t\treturn -EINVAL;\n\n\t/* Check must-be-0 bits are still 0. */\n\tif (!is_bitwise_subset(supported, data, GENMASK_ULL(63, 32)))\n\t\treturn -EINVAL;\n\n\t*lowp = data;\n\t*highp = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_vmx_misc(struct vcpu_vmx *vmx, u64 data)\n{\n\tconst u64 feature_and_reserved_bits =\n\t\t/* feature */\n\t\tBIT_ULL(5) | GENMASK_ULL(8, 6) | BIT_ULL(14) | BIT_ULL(15) |\n\t\tBIT_ULL(28) | BIT_ULL(29) | BIT_ULL(30) |\n\t\t/* reserved */\n\t\tGENMASK_ULL(13, 9) | BIT_ULL(31);\n\tu64 vmx_misc;\n\n\tvmx_misc = vmx_control_msr(vmx->nested.nested_vmx_misc_low,\n\t\t\t\t   vmx->nested.nested_vmx_misc_high);\n\n\tif (!is_bitwise_subset(vmx_misc, data, feature_and_reserved_bits))\n\t\treturn -EINVAL;\n\n\tif ((vmx->nested.nested_vmx_pinbased_ctls_high &\n\t     PIN_BASED_VMX_PREEMPTION_TIMER) &&\n\t    vmx_misc_preemption_timer_rate(data) !=\n\t    vmx_misc_preemption_timer_rate(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_cr3_count(data) > vmx_misc_cr3_count(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_max_msr(data) > vmx_misc_max_msr(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_mseg_revid(data) != vmx_misc_mseg_revid(vmx_misc))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_misc_low = data;\n\tvmx->nested.nested_vmx_misc_high = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_vmx_ept_vpid_cap(struct vcpu_vmx *vmx, u64 data)\n{\n\tu64 vmx_ept_vpid_cap;\n\n\tvmx_ept_vpid_cap = vmx_control_msr(vmx->nested.nested_vmx_ept_caps,\n\t\t\t\t\t   vmx->nested.nested_vmx_vpid_caps);\n\n\t/* Every bit is either reserved or a feature bit. */\n\tif (!is_bitwise_subset(vmx_ept_vpid_cap, data, -1ULL))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_ept_caps = data;\n\tvmx->nested.nested_vmx_vpid_caps = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_fixed0_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)\n{\n\tu64 *msr;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\tmsr = &vmx->nested.nested_vmx_cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\tmsr = &vmx->nested.nested_vmx_cr4_fixed0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * 1 bits (which indicates bits which \"must-be-1\" during VMX operation)\n\t * must be 1 in the restored value.\n\t */\n\tif (!is_bitwise_subset(data, *msr, -1ULL))\n\t\treturn -EINVAL;\n\n\t*msr = data;\n\treturn 0;\n}\n\n/*\n * Called when userspace is restoring VMX MSRs.\n *\n * Returns 0 on success, non-0 otherwise.\n */\nstatic int vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\treturn vmx_restore_vmx_basic(vmx, data);\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t/*\n\t\t * The \"non-true\" VMX capability MSRs are generated from the\n\t\t * \"true\" MSRs, so we do not support restoring them directly.\n\t\t *\n\t\t * If userspace wants to emulate VMX_BASIC[55]=0, userspace\n\t\t * should restore the \"true\" MSRs with the must-be-1 bits\n\t\t * set according to the SDM Vol 3. A.2 \"RESERVED CONTROLS AND\n\t\t * DEFAULT SETTINGS\".\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\treturn vmx_restore_control_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_MISC:\n\t\treturn vmx_restore_vmx_misc(vmx, data);\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\treturn vmx_restore_fixed0_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t/*\n\t\t * These MSRs are generated based on the vCPU's CPUID, so we\n\t\t * do not support restoring them directly.\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\treturn vmx_restore_vmx_ept_vpid_cap(vmx, data);\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\tvmx->nested.nested_vmx_vmcs_enum = data;\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * The rest of the VMX capability MSRs do not support restore.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n}\n\n/* Returns 0 on success, non-0 otherwise. */\nstatic int vmx_get_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = vmx->nested.nested_vmx_basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\t\tvmx->nested.nested_vmx_pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\t\tvmx->nested.nested_vmx_procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\t\tvmx->nested.nested_vmx_exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\t\tvmx->nested.nested_vmx_entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_misc_low,\n\t\t\tvmx->nested.nested_vmx_misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = vmx->nested.nested_vmx_cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = vmx->nested.nested_vmx_cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = vmx->nested.nested_vmx_cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = vmx->nested.nested_vmx_cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = vmx->nested.nested_vmx_vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\t\tvmx->nested.nested_vmx_secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = vmx->nested.nested_vmx_ept_caps |\n\t\t\t((u64)vmx->nested.nested_vmx_vpid_caps << 32);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct shared_msr_entry *msr;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(to_vmx(vcpu));\n\t\tmsr_info->data = to_vmx(vcpu)->msr_guest_kernel_gs_base;\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = guest_read_tsc(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t      FEATURE_CONTROL_LMCE))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tmsr_info->data = to_vmx(vcpu)->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_XSS:\n\t\tif (!vmx_xsaves_supported())\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!guest_cpuid_has_rdtscp(vcpu) && !msr_info->host_initiated)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(to_vmx(vcpu), msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(vmx);\n\t\tvmx->msr_guest_kernel_gs_base = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported())\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\t\treturn 1;\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEATURE_CONTROL_LMCE)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEATURE_CONTROL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_XSS:\n\t\tif (!vmx_xsaves_supported())\n\t\t\treturn 1;\n\t\t/*\n\t\t * The only supported bit as of Skylake is bit 8, but\n\t\t * it is not supported on KVM.\n\t\t */\n\t\tif (data != 0)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tif (vcpu->arch.ia32_xss != host_xss)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_IA32_XSS,\n\t\t\t\tvcpu->arch.ia32_xss, host_xss);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_IA32_XSS);\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!guest_cpuid_has_rdtscp(vcpu) && !msr_info->host_initiated)\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tu64 old_msr_data = msr->data;\n\t\t\tmsr->data = data;\n\t\t\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\t\t\tpreempt_disable();\n\t\t\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t\t\t msr->mask);\n\t\t\t\tpreempt_enable();\n\t\t\t\tif (ret)\n\t\t\t\t\tmsr->data = old_msr_data;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\tu64 msr;\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, msr);\n\tif (msr & FEATURE_CONTROL_LOCKED) {\n\t\t/* launched w/ TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& tboot_enabled())\n\t\t\treturn 1;\n\t\t/* launched w/o TXT and VMX only enabled w/ TXT */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& !tboot_enabled()) {\n\t\t\tprintk(KERN_WARNING \"kvm: disable TXT in the BIOS or \"\n\t\t\t\t\"activate TXT before enabling KVM\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* launched w/o TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& !tboot_enabled())\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void kvm_cpu_vmxon(u64 addr)\n{\n\tintel_pt_handle_vmx(1);\n\n\tasm volatile (ASM_VMX_VMXON_RAX\n\t\t\t: : \"a\"(&addr), \"m\"(addr)\n\t\t\t: \"memory\", \"cc\");\n}\n\nstatic int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tINIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));\n\tspin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\n\t/*\n\t * Now we can enable the vmclear operation in kdump\n\t * since the loaded_vmcss_on_cpu list on this cpu\n\t * has been initialized.\n\t *\n\t * Though the cpu is not in VMX operation now, there\n\t * is no problem to enable the vmclear operation\n\t * for the loaded_vmcss_on_cpu list is empty!\n\t */\n\tcrash_enable_local_vmclear(cpu);\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\tcr4_set_bits(X86_CR4_VMXE);\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\n\n/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()\n * tricks.\n */\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(ASM_VMX_VMXOFF) : : : \"cc\");\n\n\tintel_pt_handle_vmx(0);\n}\n\nstatic void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\tcr4_clear_bits(X86_CR4_VMXE);\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init bool allow_1_setting(u32 msr, u32 ctl)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\treturn vmx_msr_high & ctl;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_USE_IO_BITMAPS |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\t\tSECONDARY_EXEC_XSAVES |\n\t\t\tSECONDARY_EXEC_ENABLE_PML |\n\t\t\tSECONDARY_EXEC_TSC_SCALING;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t\trdmsr(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t      vmx_capability.ept, vmx_capability.vpid);\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_SAVE_IA32_PAT | VM_EXIT_LOAD_IA32_PAT |\n\t\tVM_EXIT_CLEAR_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |\n\t\t PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (cpu_has_broken_vmx_preemption_timer())\n\t\t_pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->order = get_order(vmcs_conf->size);\n\tvmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n\tcpu_has_load_ia32_efer =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_EFER)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_EFER);\n\n\tcpu_has_load_perf_global_ctrl =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\n\t/*\n\t * Some cpus support VM_ENTRY_(LOAD|SAVE)_IA32_PERF_GLOBAL_CTRL\n\t * but due to errata below it can't be used. Workaround is to use\n\t * msr load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t *\n\t * VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]\n\t *\n\t * AAK155             (model 26)\n\t * AAP115             (model 30)\n\t * AAT100             (model 37)\n\t * BC86,AAY89,BD102   (model 44)\n\t * BA97               (model 46)\n\t *\n\t */\n\tif (cpu_has_load_perf_global_ctrl && boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26:\n\t\tcase 30:\n\t\tcase 37:\n\t\tcase 44:\n\t\tcase 46:\n\t\t\tcpu_has_load_perf_global_ctrl = false;\n\t\t\tprintk_once(KERN_WARNING\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\trdmsrl(MSR_IA32_XSS, host_xss);\n\n\treturn 0;\n}\n\nstatic struct vmcs *alloc_vmcs_cpu(int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, GFP_KERNEL, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\tvmcs->revision_id = vmcs_config.revision_id; /* vmcs revision id */\n\treturn vmcs;\n}\n\nstatic struct vmcs *alloc_vmcs(void)\n{\n\treturn alloc_vmcs_cpu(raw_smp_processor_id());\n}\n\nstatic void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nstatic void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\n\t/* No checks for read only fields yet */\n\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!kvm_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\n\t/* shadowed fields guest access without vmexit */\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(cpu);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_write32(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!vcpu->kvm->arch.tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, vcpu->kvm->arch.tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\t/*\n\t * Force kernel_gs_base reloading before EFER changes, as control\n\t * of this msr depends on is_long_mode().\n\t */\n\tvmx_load_host_state(to_vmx(vcpu));\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic inline void __vmx_flush_tlb(struct kvm_vcpu *vcpu, int vpid)\n{\n\tvpid_sync_context(vpid);\n\tif (enable_ept) {\n\t\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\t\treturn;\n\t\tept_sync_context(construct_eptp(vcpu->arch.mmu.root_hpa));\n\t}\n}\n\nstatic void vmx_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t__vmx_flush_tlb(vcpu, to_vmx(vcpu)->vpid);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}\n\nstatic void vmx_decache_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (enable_ept && is_paging(vcpu))\n\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n}\n\nstatic void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_dirty))\n\t\treturn;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\n}\n\nstatic bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.nested_vmx_secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\n/* No difference in the restrictions on guest and host CR4 in VMX operation. */\n#define nested_guest_cr4_valid\tnested_cr4_valid\n#define nested_host_cr4_valid\tnested_cr4_valid\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tvmx_decache_cr3(vcpu);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) |\n\t\t\t     (CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t      CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) &\n\t\t\t     ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t       CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}\n\nstatic void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_GUEST_CR0_MASK);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tif (!vcpu->fpu_active)\n\t\thw_cr0 |= X86_CR0_TS | X86_CR0_MP;\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic u64 construct_eptp(unsigned long root_hpa)\n{\n\tu64 eptp;\n\n\t/* TODO write the value reading from MSR */\n\teptp = VMX_EPT_DEFAULT_MT |\n\t\tVMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT;\n\tif (enable_ept_ad_bits)\n\t\teptp |= VMX_EPT_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}\n\nstatic void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (is_paging(vcpu) || is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = vcpu->kvm->arch.ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4 =\n\t\t(cr4_read_shadow() & X86_CR4_MCE) |\n\t\t(cr4 & ~X86_CR4_MCE) |\n\t\t(to_vmx(vcpu)->rmode.vm86_active ?\n\t\t KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\tif (enable_ept) {\n\t\tif (!is_paging(vcpu)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t}\n\t}\n\n\tif (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}\n\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nstatic int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = kvm->arch.tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tint i, idx, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\tif (!enable_ept)\n\t\treturn 0;\n\n\t/* Protect kvm->arch.ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm->arch.ept_identity_pagetable_done))\n\t\tgoto out2;\n\n\tidentity_map_pfn = kvm->arch.ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = alloc_identity_pagetable(kvm);\n\tif (r < 0)\n\t\tgoto out2;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm->arch.ept_identity_pagetable_done = true;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\nout2:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic int alloc_identity_pagetable(struct kvm *kvm)\n{\n\t/* Called with kvm->slots_lock held. */\n\n\tint r = 0;\n\n\tBUG_ON(kvm->arch.ept_identity_pagetable_done);\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm->arch.ept_identity_map_addr, PAGE_SIZE);\n\n\treturn r;\n}\n\nstatic int allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}\n\nstatic void free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\n#define MSR_TYPE_R\t1\n#define MSR_TYPE_W\t2\nstatic void __vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\n/*\n * If a msr is allowed by L0, we should check whether it is allowed by L1.\n * The corresponding bit will be cleared unless both of L0 and L1 allow it.\n */\nstatic void nested_vmx_disable_intercept_for_msr(unsigned long *msr_bitmap_l1,\n\t\t\t\t\t       unsigned long *msr_bitmap_nested,\n\t\t\t\t\t       u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap()) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x000 / f))\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x800 / f))\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x400 / f))\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0xc00 / f))\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0xc00 / f);\n\n\t}\n}\n\nstatic void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)\n{\n\tif (!longmode_only)\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n}\n\nstatic void vmx_disable_intercept_msr_x2apic(u32 msr, int type, bool apicv_active)\n{\n\tif (apicv_active) {\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv,\n\t\t\t\tmsr, type);\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv,\n\t\t\t\tmsr, type);\n\t} else {\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\t\tmsr, type);\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\t\tmsr, type);\n\t}\n}\n\nstatic bool vmx_get_enable_apicv(void)\n{\n\treturn enable_apicv;\n}\n\nstatic int vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tvoid *vapic_page;\n\tu16 status;\n\n\tif (vmx->nested.pi_desc &&\n\t    vmx->nested.pi_pending) {\n\t\tvmx->nested.pi_pending = false;\n\t\tif (!pi_test_and_clear_on(vmx->nested.pi_desc))\n\t\t\treturn 0;\n\n\t\tmax_irr = find_last_bit(\n\t\t\t(unsigned long *)vmx->nested.pi_desc->pir, 256);\n\n\t\tif (max_irr == 256)\n\t\t\treturn 0;\n\n\t\tvapic_page = kmap(vmx->nested.virtual_apic_page);\n\t\tif (!vapic_page) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t__kvm_apic_update_irr(vmx->nested.pi_desc->pir, vapic_page);\n\t\tkunmap(vmx->nested.virtual_apic_page);\n\n\t\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\t\tif ((u8)max_irr > ((u8)status & 0xff)) {\n\t\t\tstatus &= ~0xff;\n\t\t\tstatus |= (u8)max_irr;\n\t\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_SMP\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t\t/*\n\t\t * Currently, we don't support urgent interrupt,\n\t\t * all interrupts are recognized as non-urgent\n\t\t * interrupt, so we cannot post interrupts when\n\t\t * 'SN' is set.\n\t\t *\n\t\t * If the vcpu is in guest mode, it means it is\n\t\t * running instead of being scheduled out and\n\t\t * waiting in the run queue, and that's the only\n\t\t * case when 'SN' is set currently, warning if\n\t\t * 'SN' is set.\n\t\t */\n\t\tWARN_ON_ONCE(pi_test_sn(&vmx->pi_desc));\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu),\n\t\t\t\tPOSTED_INTR_VECTOR);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/* the PIR and ON have been set by L1. */\n\t\tkvm_vcpu_trigger_posted_interrupt(vcpu);\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn;\n\n\tr = pi_test_and_set_on(&vmx->pi_desc);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (r || !kvm_vcpu_trigger_posted_interrupt(vcpu))\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!pi_test_on(&vmx->pi_desc))\n\t\treturn;\n\n\tpi_clear_on(&vmx->pi_desc);\n\t/*\n\t * IOMMU can write to PIR.ON, so the barrier matters even on UP.\n\t * But on x86 this is just a compiler barrier anyway.\n\t */\n\tsmp_mb__after_atomic();\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nstatic void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr0, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}\n\nstatic void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\t/* Enable the preemption timer dynamically */\n\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\treturn pin_based_exec_ctrl;\n}\n\nstatic void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\treturn exec_control;\n}\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\tif (!cpu_need_virtualize_apic_accesses(&vmx->vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t\t/* Enable INVPCID for non-ept guests may cause performance regression. */\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (!ple_gap)\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\treturn exec_control;\n}\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n\n#define VMX_XSS_EXIT_BITMAP 0\n/*\n * Sets up the vmcs for emulated real mode.\n */\nstatic int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tvmx->hv_deadline_tsc = -1;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tASSERT(vmx->pml_pg);\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\tu64 cr0;\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx->soft_vnmi_blocked = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tkvm_set_cr8(vcpu, 0);\n\n\tif (!init_event) {\n\t\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t     MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(vcpu))\n\t\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\t\tapic_base_msr.host_initiated = true;\n\t\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\t}\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tif (!init_event) {\n\t\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\t}\n\n\tvmcs_writel(GUEST_RFLAGS, 0x02);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow() && !init_event) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vcpu->arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\tmemset(&vmx->pi_desc, 0, sizeof(struct pi_desc));\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tcr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx->vcpu.arch.cr0 = cr0;\n\tvmx_set_cr0(vcpu, cr0); /* enter rmode */\n\tvmx_set_cr4(vcpu, 0);\n\tvmx_set_efer(vcpu, 0);\n\tvmx_fpu_activate(vcpu);\n\tupdate_exception_bitmap(vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n}\n\n/*\n * In nested virtualization, check if L1 asked to exit on external interrupts.\n * For most existing hypervisors, this will always return true.\n */\nstatic bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}\n\n/*\n * In nested virtualization, check if L1 has set\n * VM_EXIT_ACK_INTR_ON_EXIT\n */\nstatic bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->vm_exit_controls &\n\t\tVM_EXIT_ACK_INTR_ON_EXIT;\n}\n\nstatic bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu)) {\n\t\tif (!cpu_has_virtual_nmis()) {\n\t\t\t/*\n\t\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t\t * highly unlikely, we can live with the residual risk.\n\t\t\t */\n\t\t\tvmx->soft_vnmi_blocked = 1;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\n\t\t++vcpu->stat.nmi_injections;\n\t\tvmx->nmi_known_unmasked = false;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n\nstatic bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tif (!cpu_has_virtual_nmis())\n\t\treturn to_vmx(vcpu)->soft_vnmi_blocked;\n\tif (to_vmx(vcpu)->nmi_known_unmasked)\n\t\treturn false;\n\treturn vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\t& GUEST_INTR_STATE_NMI;\n}\n\nstatic void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\tif (vmx->soft_vnmi_blocked != masked) {\n\t\t\tvmx->soft_vnmi_blocked = masked;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\n\tret = x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t    PAGE_SIZE * 3);\n\tif (ret)\n\t\treturn ret;\n\tkvm->arch.tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\tbreak;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (emulate_instruction(vcpu, 0) == EMULATE_DONE) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\n/*\n * Trigger machine check on the host. We assume all the MSRs are already set up\n * by the CPU and that we still run on the same CPU as the MCE occurred on.\n * We pass a fake environment to the machine check handler because we want\n * the guest to be always treated like user space, no matter what context\n * it used internally.\n */\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* already handled by vcpu_run */\n\treturn 1;\n}\n\nstatic int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string, ret;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\tin = (exit_qualification & 8) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\t/*\n\t * TODO: we might be squashing a KVM_GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_fast_pio_out(vcpu, size, port) && ret;\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\n/* called to set cr0 as appropriate for clts instruction exit. */\nstatic void handle_clts(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We get here when L2 did CLTS, and L1 didn't shadow CR0.TS\n\t\t * but we did (!fpu_active). We need to keep GUEST_CR0.TS on,\n\t\t * just pretend it's off (also in arch.cr0 for fpu_activate).\n\t\t */\n\t\tvmcs_writel(CR0_READ_SHADOW,\n\t\t\tvmcs_readl(CR0_READ_SHADOW) & ~X86_CR0_TS);\n\t\tvcpu->arch.cr0 &= ~X86_CR0_TS;\n\t} else\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\thandle_clts(vcpu);\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\tvmcs_clear_bits(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t\tCPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}\n\nstatic void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tvmcs_set_bits(CPU_BASED_VM_EXEC_CONTROL, CPU_BASED_MOV_DR_EXITING);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_cpuid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_cpuid(vcpu);\n}\n\nstatic int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (vmx_get_msr(vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t/* FIXME: handling of bits 32:63 of rax, rdx */\n\tvcpu->arch.regs[VCPU_REGS_RAX] = msr_info.data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (msr_info.data >> 32) & -1u;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (kvm_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending irq */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int handle_halt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_halt(vcpu);\n}\n\nstatic int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_hypercall(vcpu);\n}\n\nstatic int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_wbinvd(vcpu);\n}\n\nstatic int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_xsaves(struct kvm_vcpu *vcpu)\n{\n\tkvm_skip_emulated_instruction(vcpu);\n\tWARN(1, \"this should never happen\\n\");\n\treturn 1;\n}\n\nstatic int handle_xrstors(struct kvm_vcpu *vcpu)\n{\n\tkvm_skip_emulated_instruction(vcpu);\n\tWARN(1, \"this should never happen\\n\");\n\treturn 1;\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tskip_emulated_instruction(vcpu);\n\n\tif (kvm_task_switch(vcpu, tss_selector,\n\t\t\t    type == INTR_TYPE_SOFT_INTR ? idt_index : -1, reason,\n\t\t\t    has_error_code, error_code) == EMULATE_FAIL) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\n\treturn 1;\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu32 error_code;\n\tint gla_validity;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tgla_validity = (exit_qualification >> 7) & 0x3;\n\tif (gla_validity == 0x2) {\n\t\tprintk(KERN_ERR \"EPT: Handling EPT violation failed!\\n\");\n\t\tprintk(KERN_ERR \"EPT: GPA: 0x%lx, GVA: 0x%lx\\n\",\n\t\t\t(long unsigned int)vmcs_read64(GUEST_PHYSICAL_ADDRESS),\n\t\t\tvmcs_readl(GUEST_LINEAR_ADDRESS));\n\t\tprintk(KERN_ERR \"EPT: Exit qualification is 0x%lx\\n\",\n\t\t\t(long unsigned int)exit_qualification);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_VIOLATION;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* it is a read fault? */\n\terror_code = (exit_qualification << 2) & PFERR_USER_MASK;\n\t/* it is a write fault? */\n\terror_code |= exit_qualification & PFERR_WRITE_MASK;\n\t/* It is a fetch fault? */\n\terror_code |= (exit_qualification << 2) & PFERR_FETCH_MASK;\n\t/* ept page table is present? */\n\terror_code |= (exit_qualification & 0x38) != 0;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t gpa;\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tret = handle_mmio_page_fault(vcpu, gpa, true);\n\tif (likely(ret == RET_MMIO_PF_EMULATE))\n\t\treturn x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==\n\t\t\t\t\t      EMULATE_DONE;\n\n\tif (unlikely(ret == RET_MMIO_PF_INVALID))\n\t\treturn kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);\n\n\tif (unlikely(ret == RET_MMIO_PF_RETRY))\n\t\treturn 1;\n\n\t/* It is the real ept misconfig */\n\tWARN_ON(1);\n\n\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_MISCONFIG;\n\n\treturn 0;\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending NMI */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tenum emulation_result err = EMULATE_DONE;\n\tint ret = 1;\n\tu32 cpu_exec_ctrl;\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tcpu_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tintr_window_requested = cpu_exec_ctrl & CPU_BASED_VIRTUAL_INTR_PENDING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (test_bit(KVM_REQ_EVENT, &vcpu->requests))\n\t\t\treturn 1;\n\n\t\terr = emulate_instruction(vcpu, EMULTYPE_NO_REEXECUTE);\n\n\t\tif (err == EMULATE_USER_EXIT) {\n\t\t\t++vcpu->stat.mmio_exits;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (err != EMULATE_DONE) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\tret = kvm_vcpu_halt(vcpu);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __grow_ple_window(int val)\n{\n\tif (ple_window_grow < 1)\n\t\treturn ple_window;\n\n\tval = min(val, ple_window_actual_max);\n\n\tif (ple_window_grow < ple_window)\n\t\tval *= ple_window_grow;\n\telse\n\t\tval += ple_window_grow;\n\n\treturn val;\n}\n\nstatic int __shrink_ple_window(int val, int modifier, int minimum)\n{\n\tif (modifier < 1)\n\t\treturn ple_window;\n\n\tif (modifier < ple_window)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, minimum);\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old,\n\t                                      ple_window_shrink, ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\n/*\n * ple_window_actual_max is computed to be one grow_ple_window() below\n * ple_window_max. (See __grow_ple_window for the reason.)\n * This prevents overflows, because ple_window_max is int.\n * ple_window_max effectively rounded down to a multiple of ple_window_grow in\n * this process.\n * ple_window_max is also prevented from setting vmx->ple_window < ple_window.\n */\nstatic void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}\n\n/*\n * Handler for POSTED_INTERRUPT_WAKEUP_VECTOR.\n */\nstatic void wakeup_handler(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint cpu = smp_processor_id();\n\n\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\tlist_for_each_entry(vcpu, &per_cpu(blocked_vcpu_on_cpu, cpu),\n\t\t\tblocked_vcpu_list) {\n\t\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\t\tif (pi_test_on(pi_desc) == 1)\n\t\t\tkvm_vcpu_kick(vcpu);\n\t}\n\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n}\n\nstatic __init int hardware_setup(void)\n{\n\tint r = -ENOMEM, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tfor (i = 0; i < VMX_BITMAP_NR; i++) {\n\t\tvmx_bitmap[i] = (unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx_bitmap[i])\n\t\t\tgoto out;\n\t}\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\n\tif (setup_vmcs_config(&vmcs_config) < 0) {\n\t\tr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic_apicv,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic_apicv,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr++) {\n\t\tif (msr == 0x839 /* TMCCT */)\n\t\t\tcontinue;\n\t\tvmx_disable_intercept_msr_x2apic(msr, MSR_TYPE_R, true);\n\t}\n\n\t/*\n\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t * delivery is not in use.\n\t */\n\tvmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_W, true);\n\tvmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_R | MSR_TYPE_W, false);\n\n\t/* EOI */\n\tvmx_disable_intercept_msr_x2apic(0x80b, MSR_TYPE_W, true);\n\t/* SELF-IPI */\n\tvmx_disable_intercept_msr_x2apic(0x83f, MSR_TYPE_W, true);\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\t\tcpu_has_vmx_ept_execute_only() ?\n\t\t\t\t      0ull : VMX_EPT_READABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tkvm_x86_ops->slot_enable_log_dirty = NULL;\n\t\tkvm_x86_ops->slot_disable_log_dirty = NULL;\n\t\tkvm_x86_ops->flush_log_dirty = NULL;\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tif (cpu_has_vmx_preemption_timer() && enable_preemption_timer) {\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\t vmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\t} else {\n\t\tkvm_x86_ops->set_hv_timer = NULL;\n\t\tkvm_x86_ops->cancel_hv_timer = NULL;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\treturn alloc_kvm_area();\n\nout:\n\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\n    return r;\n}\n\nstatic __exit void hardware_unsetup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\n\tfree_kvm_area();\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\nstatic int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\n/*\n * To run an L2 guest, we need a vmcs02 based on the L1-specified vmcs12.\n * We could reuse a single VMCS for all the L2 guests, but we also want the\n * option to allocate a separate vmcs02 for each separate loaded vmcs12 - this\n * allows keeping them loaded on the processor, and in the future will allow\n * optimizations where prepare_vmcs02 doesn't need to set all the fields on\n * every entry if they never change.\n * So we keep, in vmx->nested.vmcs02_pool, a cache of size VMCS02_POOL_SIZE\n * (>=0) with a vmcs02 for each recently loaded vmcs12s, most recent first.\n *\n * The following functions allocate and free a vmcs02 in this pool.\n */\n\n/* Get a VMCS from the pool to use as vmcs02 for the current vmcs12. */\nstatic struct loaded_vmcs *nested_get_current_vmcs02(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmx->nested.current_vmptr) {\n\t\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\t\treturn &item->vmcs02;\n\t\t}\n\n\tif (vmx->nested.vmcs02_num >= max(VMCS02_POOL_SIZE, 1)) {\n\t\t/* Recycle the least recently used VMCS. */\n\t\titem = list_last_entry(&vmx->nested.vmcs02_pool,\n\t\t\t\t       struct vmcs02_list, list);\n\t\titem->vmptr = vmx->nested.current_vmptr;\n\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\treturn &item->vmcs02;\n\t}\n\n\t/* Create a new VMCS */\n\titem = kmalloc(sizeof(struct vmcs02_list), GFP_KERNEL);\n\tif (!item)\n\t\treturn NULL;\n\titem->vmcs02.vmcs = alloc_vmcs();\n\titem->vmcs02.shadow_vmcs = NULL;\n\tif (!item->vmcs02.vmcs) {\n\t\tkfree(item);\n\t\treturn NULL;\n\t}\n\tloaded_vmcs_init(&item->vmcs02);\n\titem->vmptr = vmx->nested.current_vmptr;\n\tlist_add(&(item->list), &(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num++;\n\treturn &item->vmcs02;\n}\n\n/* Free and remove from pool a vmcs02 saved for a vmcs12 (if there is one) */\nstatic void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmptr) {\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t\tvmx->nested.vmcs02_num--;\n\t\t\treturn;\n\t\t}\n}\n\n/*\n * Free all VMCSs saved for this vcpu, except the one pointed by\n * vmx->loaded_vmcs. We must be running L1, so vmx->loaded_vmcs\n * must be &vmx->vmcs01.\n */\nstatic void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\n\tWARN_ON(vmx->loaded_vmcs != &vmx->vmcs01);\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\t/*\n\t\t * Something will leak if the above WARN triggers.  Better than\n\t\t * a use-after-free.\n\t\t */\n\t\tif (vmx->loaded_vmcs == &item->vmcs02)\n\t\t\tcontinue;\n\n\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t\tvmx->nested.vmcs02_num--;\n\t}\n}\n\n/*\n * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),\n * set the success or error code of an emulated VMX instruction, as specified\n * by Vol 2B, VMX Instruction Reference, \"Conventions\".\n */\nstatic void nested_vmx_succeed(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));\n}\n\nstatic void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}\n\nstatic void nested_vmx_failValid(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu32 vm_instruction_error)\n{\n\tif (to_vmx(vcpu)->nested.current_vmptr == -1ull) {\n\t\t/*\n\t\t * failValid writes the error number to the current VMCS, which\n\t\t * can't be done there isn't a current VMCS.\n\t\t */\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn;\n\t}\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_ZF);\n\tget_vmcs12(vcpu)->vm_instruction_error = vm_instruction_error;\n\t/*\n\t * We don't need to force a shadow sync because\n\t * VM_INSTRUCTION_ERROR is not shadowed\n\t */\n}\n\nstatic void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)\n{\n\t/* TODO: not to reset guest simply here. */\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\tpr_debug_ratelimited(\"kvm: nested vmx abort, indicator %d\\n\", indicator);\n}\n\nstatic enum hrtimer_restart vmx_preemption_timer_fn(struct hrtimer *timer)\n{\n\tstruct vcpu_vmx *vmx =\n\t\tcontainer_of(timer, struct vcpu_vmx, nested.preemption_timer);\n\n\tvmx->nested.preemption_timer_expired = true;\n\tkvm_make_request(KVM_REQ_EVENT, &vmx->vcpu);\n\tkvm_vcpu_kick(&vmx->vcpu);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * Decode the memory-address operand of a vmx instruction, as recorded on an\n * exit caused by such an instruction (run by a guest hypervisor).\n * On success, returns 0. When the operand is invalid, returns 1 and throws\n * #UD or #GP.\n */\nstatic int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, bool wr, gva_t *ret)\n{\n\tgva_t off;\n\tbool exn;\n\tstruct kvm_segment s;\n\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\toff = exit_qualification; /* holds the displacement */\n\tif (base_is_valid)\n\t\toff += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\toff += kvm_register_read(vcpu, index_reg)<<scaling;\n\tvmx_get_segment(vcpu, &s, seg_reg);\n\t*ret = s.base + off;\n\n\tif (addr_size == 1) /* 32 bit */\n\t\t*ret &= 0xffffffff;\n\n\t/* Checks for #GP/#SS exceptions. */\n\texn = false;\n\tif (is_long_mode(vcpu)) {\n\t\t/* Long mode: #GP(0)/#SS(0) if the memory address is in a\n\t\t * non-canonical form. This is the only check on the memory\n\t\t * destination for long mode!\n\t\t */\n\t\texn = is_noncanonical_address(*ret);\n\t} else if (is_protmode(vcpu)) {\n\t\t/* Protected mode: apply checks for segment validity in the\n\t\t * following order:\n\t\t * - segment type check (#GP(0) may be thrown)\n\t\t * - usability check (#GP(0)/#SS(0))\n\t\t * - limit check (#GP(0)/#SS(0))\n\t\t */\n\t\tif (wr)\n\t\t\t/* #GP(0) if the destination operand is located in a\n\t\t\t * read-only data segment or any code segment.\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 0 || (s.type & 8));\n\t\telse\n\t\t\t/* #GP(0) if the source operand is located in an\n\t\t\t * execute-only code segment\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 8);\n\t\tif (exn) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.\n\t\t */\n\t\texn = (s.unusable != 0);\n\t\t/* Protected mode: #GP(0)/#SS(0) if the memory\n\t\t * operand is outside the segment limit.\n\t\t */\n\t\texn = exn || (off + sizeof(u64) > s.limit);\n\t}\n\tif (exn) {\n\t\tkvm_queue_exception_e(vcpu,\n\t\t\t\t      seg_reg == VCPU_SREG_SS ?\n\t\t\t\t\t\tSS_VECTOR : GP_VECTOR,\n\t\t\t\t      0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function performs the various checks including\n * - if it's 4KB aligned\n * - No bits beyond the physical address width are set\n * - Returns 0 on success or else 1\n * (Intel SDM Section 30.3)\n */\nstatic int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,\n\t\t\t\t  gpa_t *vmpointer)\n{\n\tgva_t gva;\n\tgpa_t vmptr;\n\tstruct x86_exception e;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmcs_read32(VMX_INSTRUCTION_INFO), false, &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vmptr,\n\t\t\t\tsizeof(vmptr), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_VMON:\n\t\t/*\n\t\t * SDM 3: 24.11.5\n\t\t * The first 4 bytes of VMXON region contain the supported\n\t\t * VMCS revision identifier\n\t\t *\n\t\t * Note - IA32_VMX_BASIC[48] will never be 1\n\t\t * for the nested case;\n\t\t * which replaces physical address width with 32\n\t\t *\n\t\t */\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL ||\n\t\t    *(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tkunmap(page);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tkunmap(page);\n\t\tvmx->nested.vmxon_ptr = vmptr;\n\t\tbreak;\n\tcase EXIT_REASON_VMCLEAR:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_INVALID_ADDRESS);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase EXIT_REASON_VMPTRLD:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_INVALID_ADDRESS);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_VMXON_POINTER);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 1; /* shouldn't happen */\n\t}\n\n\tif (vmpointer)\n\t\t*vmpointer = vmptr;\n\treturn 0;\n}\n\n/*\n * Emulate the VMXON instruction.\n * Currently, we just remember that VMX is active, and do not save or even\n * inspect the argument to VMXON (the so-called \"VMXON pointer\") because we\n * do not currently need to store anything in that guest-allocated memory\n * region. Consequently, VMCLEAR and VMPTRLD also do not verify that the their\n * argument is different from the VMXON pointer (which the spec says they do).\n */\nstatic int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs *shadow_vmcs;\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\t/* The Intel VMX Instruction Reference lists a bunch of bits that\n\t * are prerequisite to running VMXON, most notably cr4.VMXE must be\n\t * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).\n\t * Otherwise, we should fail with #UD. We test these now:\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE) ||\n\t    !kvm_read_cr0_bits(vcpu, X86_CR0_PE) ||\n\t    (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif (is_long_mode(vcpu) && !cs.l) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMON, NULL))\n\t\treturn 1;\n\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tvmx->nested.msr_bitmap =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx->nested.msr_bitmap)\n\t\t\tgoto out_msr_bitmap;\n\t}\n\n\tvmx->nested.cached_vmcs12 = kmalloc(VMCS12_SIZE, GFP_KERNEL);\n\tif (!vmx->nested.cached_vmcs12)\n\t\tgoto out_cached_vmcs12;\n\n\tif (enable_shadow_vmcs) {\n\t\tshadow_vmcs = alloc_vmcs();\n\t\tif (!shadow_vmcs)\n\t\t\tgoto out_shadow_vmcs;\n\t\t/* mark vmcs as shadow */\n\t\tshadow_vmcs->revision_id |= (1u << 31);\n\t\t/* init shadow vmcs */\n\t\tvmcs_clear(shadow_vmcs);\n\t\tvmx->vmcs01.shadow_vmcs = shadow_vmcs;\n\t}\n\n\tINIT_LIST_HEAD(&(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num = 0;\n\n\thrtimer_init(&vmx->nested.preemption_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_PINNED);\n\tvmx->nested.preemption_timer.function = vmx_preemption_timer_fn;\n\n\tvmx->nested.vmxon = true;\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n\nout_shadow_vmcs:\n\tkfree(vmx->nested.cached_vmcs12);\n\nout_cached_vmcs12:\n\tfree_page((unsigned long)vmx->nested.msr_bitmap);\n\nout_msr_bitmap:\n\treturn -ENOMEM;\n}\n\n/*\n * Intel's VMX Instruction Reference specifies a common set of prerequisites\n * for running VMX instructions (except VMXON, whose prerequisites are\n * slightly different). It also specifies what exception to inject otherwise.\n */\nstatic int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif ((vmx_get_rflags(vcpu) & X86_EFLAGS_VM) ||\n\t    (is_long_mode(vcpu) && !cs.l)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline void nested_release_vmcs12(struct vcpu_vmx *vmx)\n{\n\tif (vmx->nested.current_vmptr == -1ull)\n\t\treturn;\n\n\t/* current_vmptr and current_vmcs12 are always set/reset together */\n\tif (WARN_ON(vmx->nested.current_vmcs12 == NULL))\n\t\treturn;\n\n\tif (enable_shadow_vmcs) {\n\t\t/* copy to memory all shadowed fields in case\n\t\t   they were modified */\n\t\tcopy_shadow_to_vmcs12(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tSECONDARY_EXEC_SHADOW_VMCS);\n\t\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\t}\n\tvmx->nested.posted_intr_nv = -1;\n\n\t/* Flush VMCS12 to guest memory */\n\tmemcpy(vmx->nested.current_vmcs12, vmx->nested.cached_vmcs12,\n\t       VMCS12_SIZE);\n\n\tkunmap(vmx->nested.current_vmcs12_page);\n\tnested_release_page(vmx->nested.current_vmcs12_page);\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n}\n\n/*\n * Free whatever needs to be freed from vmx->nested when L1 goes down, or\n * just stops using VMX.\n */\nstatic void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (vmx->nested.msr_bitmap) {\n\t\tfree_page((unsigned long)vmx->nested.msr_bitmap);\n\t\tvmx->nested.msr_bitmap = NULL;\n\t}\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_clear(vmx->vmcs01.shadow_vmcs);\n\t\tfree_vmcs(vmx->vmcs01.shadow_vmcs);\n\t\tvmx->vmcs01.shadow_vmcs = NULL;\n\t}\n\tkfree(vmx->nested.cached_vmcs12);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}\n\n/* Emulate the VMXOFF instruction */\nstatic int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMCLEAR instruction */\nstatic int handle_vmclear(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tstruct vmcs12 *vmcs12;\n\tstruct page *page;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMCLEAR, &vmptr))\n\t\treturn 1;\n\n\tif (vmptr == vmx->nested.current_vmptr)\n\t\tnested_release_vmcs12(vmx);\n\n\tpage = nested_get_page(vcpu, vmptr);\n\tif (page == NULL) {\n\t\t/*\n\t\t * For accurate processor emulation, VMCLEAR beyond available\n\t\t * physical memory should do nothing at all. However, it is\n\t\t * possible that a nested vmx bug, not a guest hypervisor bug,\n\t\t * resulted in this case, so let's shut down before doing any\n\t\t * more damage:\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn 1;\n\t}\n\tvmcs12 = kmap(page);\n\tvmcs12->launch_state = 0;\n\tkunmap(page);\n\tnested_release_page(page);\n\n\tnested_free_vmcs02(vmx, vmptr);\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch);\n\n/* Emulate the VMLAUNCH instruction */\nstatic int handle_vmlaunch(struct kvm_vcpu *vcpu)\n{\n\treturn nested_vmx_run(vcpu, true);\n}\n\n/* Emulate the VMRESUME instruction */\nstatic int handle_vmresume(struct kvm_vcpu *vcpu)\n{\n\n\treturn nested_vmx_run(vcpu, false);\n}\n\nenum vmcs_field_type {\n\tVMCS_FIELD_TYPE_U16 = 0,\n\tVMCS_FIELD_TYPE_U64 = 1,\n\tVMCS_FIELD_TYPE_U32 = 2,\n\tVMCS_FIELD_TYPE_NATURAL_WIDTH = 3\n};\n\nstatic inline int vmcs_field_type(unsigned long field)\n{\n\tif (0x1 & field)\t/* the *_HIGH fields are all 32 bit */\n\t\treturn VMCS_FIELD_TYPE_U32;\n\treturn (field >> 13) & 0x3 ;\n}\n\nstatic inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}\n\n/*\n * Read a vmcs12 field. Since these can have varying lengths and we return\n * one type, we chose the biggest type (u64) and zero-extend the return value\n * to that size. Note that the caller, handle_vmread, might need to use only\n * some of the bits we return here (e.g., on 32-bit guests, only 32 bits of\n * 64-bit fields are to be returned).\n */\nstatic inline int vmcs12_read_any(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned long field, u64 *ret)\n{\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p;\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\tp = ((char *)(get_vmcs12(vcpu))) + offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*ret = *((natural_width *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*ret = *((u16 *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*ret = *((u32 *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*ret = *((u64 *)p);\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n}\n\n\nstatic inline int vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n\n}\n\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)\n{\n\tint i;\n\tunsigned long field;\n\tu64 field_value;\n\tstruct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;\n\tconst unsigned long *fields = shadow_read_write_fields;\n\tconst int num_fields = max_shadow_read_write_fields;\n\n\tpreempt_disable();\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tfield = fields[i];\n\t\tswitch (vmcs_field_type(field)) {\n\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\tfield_value = vmcs_read16(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\tfield_value = vmcs_read32(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\tfield_value = vmcs_read64(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\tfield_value = vmcs_readl(field);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\t}\n\t\tvmcs12_write_any(&vmx->vcpu, field, field_value);\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\n\tpreempt_enable();\n}\n\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long *fields[] = {\n\t\tshadow_read_write_fields,\n\t\tshadow_read_only_fields\n\t};\n\tconst int max_fields[] = {\n\t\tmax_shadow_read_write_fields,\n\t\tmax_shadow_read_only_fields\n\t};\n\tint i, q;\n\tunsigned long field;\n\tu64 field_value = 0;\n\tstruct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (q = 0; q < ARRAY_SIZE(fields); q++) {\n\t\tfor (i = 0; i < max_fields[q]; i++) {\n\t\t\tfield = fields[q][i];\n\t\t\tvmcs12_read_any(&vmx->vcpu, field, &field_value);\n\n\t\t\tswitch (vmcs_field_type(field)) {\n\t\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\t\tvmcs_write16(field, (u16)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\t\tvmcs_write32(field, (u32)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\t\tvmcs_write64(field, (u64)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\t\tvmcs_writel(field, (long)field_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\n/*\n * VMX instructions which assume a current vmcs12 (i.e., that VMPTRLD was\n * used before) all generate the same failure when it is missing.\n */\nstatic int nested_vmx_check_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (vmx->nested.current_vmptr == -1ull) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\t/* Decode instruction info and find the field to read */\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\t/* Read the field, zero-extended to a u64 field_value */\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\t/*\n\t * Now copy part of this value to register or memory, as requested.\n\t * Note that the number of bits actually copied is 32 or 64 depending\n\t * on the guest's mode (32 or 64 bit), not on the given field's length.\n\t */\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\t/* _system ok, as nested_vmx_check_permission verified cpl=0 */\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n\nstatic int handle_vmwrite(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tgva_t gva;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\t/* The value to write might be 32 or 64 bits, depending on L1's long\n\t * mode, and eventually we need to write that into a field of several\n\t * possible lengths. The code below first zero-extends the value to 64\n\t * bit (field_value), and then copies only the appropriate number of\n\t * bits into the vmcs12 field.\n\t */\n\tu64 field_value = 0;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tif (vmx_instruction_info & (1u << 10))\n\t\tfield_value = kvm_register_readl(vcpu,\n\t\t\t(((vmx_instruction_info) >> 3) & 0xf));\n\telse {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, false, &gva))\n\t\t\treturn 1;\n\t\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t   &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {\n\t\t\tkvm_inject_page_fault(vcpu, &e);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs_field_readonly(field)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tif (vmcs12_write_any(vcpu, field, field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMPTRLD instruction */\nstatic int handle_vmptrld(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMPTRLD, &vmptr))\n\t\treturn 1;\n\n\tif (vmx->nested.current_vmptr != vmptr) {\n\t\tstruct vmcs12 *new_vmcs12;\n\t\tstruct page *page;\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tnew_vmcs12 = kmap(page);\n\t\tif (new_vmcs12->revision_id != VMCS12_REVISION) {\n\t\t\tkunmap(page);\n\t\t\tnested_release_page_clean(page);\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tnested_release_vmcs12(vmx);\n\t\tvmx->nested.current_vmptr = vmptr;\n\t\tvmx->nested.current_vmcs12 = new_vmcs12;\n\t\tvmx->nested.current_vmcs12_page = page;\n\t\t/*\n\t\t * Load VMCS12 from guest memory since it is not already\n\t\t * cached.\n\t\t */\n\t\tmemcpy(vmx->nested.cached_vmcs12,\n\t\t       vmx->nested.current_vmcs12, VMCS12_SIZE);\n\n\t\tif (enable_shadow_vmcs) {\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_SHADOW_VMCS);\n\t\t\tvmcs_write64(VMCS_LINK_POINTER,\n\t\t\t\t     __pa(vmx->vmcs01.shadow_vmcs));\n\t\t\tvmx->nested.sync_shadow_vmcs = true;\n\t\t}\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMPTRST instruction */\nstatic int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\t/* ok to use *_system, as nested_vmx_check_permission verified cpl=0 */\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the INVEPT instruction */\nstatic int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(vmx->nested.nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (vmx->nested.nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (type >= 32 || !(types & (1 << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t/*\n\t * TODO: track mappings and invalidate\n\t * single context requests appropriately\n\t */\n\tcase VMX_EPT_EXTENT_CONTEXT:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info;\n\tunsigned long type, types;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tint vpid;\n\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_VPID) ||\n\t\t\t!(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (vmx->nested.nested_vmx_vpid_caps &\n\t\t\tVMX_VPID_EXTENT_SUPPORTED_MASK) >> 8;\n\n\tif (type >= 32 || !(types & (1 << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t/* according to the intel vmx instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,\n\t\t\t\tsizeof(u32), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_VPID_EXTENT_INDIVIDUAL_ADDR:\n\tcase VMX_VPID_EXTENT_SINGLE_CONTEXT:\n\tcase VMX_VPID_EXTENT_SINGLE_NON_GLOBAL:\n\t\tif (!vpid) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase VMX_VPID_EXTENT_ALL_CONTEXT:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t__vmx_flush_tlb(vcpu, vmx->nested.vpid02);\n\tnested_vmx_succeed(vcpu);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_expired_hv_timer(vcpu);\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n\t[EXIT_REASON_VMREAD]                  = handle_vmread,\n\t[EXIT_REASON_VMRESUME]                = handle_vmresume,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n\t[EXIT_REASON_VMOFF]                   = handle_vmoff,\n\t[EXIT_REASON_VMON]                    = handle_vmon,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_invept,\n\t[EXIT_REASON_INVVPID]                 = handle_invvpid,\n\t[EXIT_REASON_XSAVES]                  = handle_xsaves,\n\t[EXIT_REASON_XRSTORS]                 = handle_xrstors,\n\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,\n\t[EXIT_REASON_PREEMPTION_TIMER]\t      = handle_preemption_timer,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tgpa_t bitmap, last_bitmap;\n\tunsigned int port;\n\tint size;\n\tu8 b;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn true;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))\n\t\t\t\treturn true;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn true;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn false;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an MSR access access,\n * rather than handle it ourselves in L0. I.e., check whether L1 expressed\n * disinterest in the current event (read or write a specific MSR) by using an\n * MSR bitmap. This may be the case even when L0 doesn't use MSR bitmaps.\n */\nstatic bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12, u32 exit_reason)\n{\n\tu32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tgpa_t bitmap;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn true;\n\n\t/*\n\t * The MSR_BITMAP page is divided into four 1024-byte bitmaps,\n\t * for the four combinations of read/write and low/high MSR numbers.\n\t * First we need to figure out which of the four to use:\n\t */\n\tbitmap = vmcs12->msr_bitmap;\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\tbitmap += 2048;\n\tif (msr_index >= 0xc0000000) {\n\t\tmsr_index -= 0xc0000000;\n\t\tbitmap += 1024;\n\t}\n\n\t/* Then read the msr_index'th bit from this bitmap: */\n\tif (msr_index < 1024*8) {\n\t\tunsigned char b;\n\t\tif (kvm_vcpu_read_guest(vcpu, bitmap + msr_index/8, &b, 1))\n\t\t\treturn true;\n\t\treturn 1 & (b >> (msr_index & 7));\n\t} else\n\t\treturn true; /* let L1 handle the wrong parameter */\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle a CR access exit,\n * rather than handle it ourselves in L0. I.e., check if L1 wanted to\n * intercept (via guest_host_mask etc.) the current event.\n */\nstatic bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint cr = exit_qualification & 15;\n\tint reg = (exit_qualification >> 8) & 15;\n\tunsigned long val = kvm_register_readl(vcpu, reg);\n\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (vmcs12->cr0_guest_host_mask &\n\t\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((vmcs12->cr3_target_count >= 1 &&\n\t\t\t\t\tvmcs12->cr3_target_value0 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 2 &&\n\t\t\t\t\tvmcs12->cr3_target_value1 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 3 &&\n\t\t\t\t\tvmcs12->cr3_target_value2 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 4 &&\n\t\t\t\t\tvmcs12->cr3_target_value3 == val))\n\t\t\t\treturn false;\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR3_LOAD_EXITING))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (vmcs12->cr4_guest_host_mask &\n\t\t\t    (vmcs12->cr4_read_shadow ^ val))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tif ((vmcs12->cr0_guest_host_mask & X86_CR0_TS) &&\n\t\t    (vmcs12->cr0_read_shadow & X86_CR0_TS))\n\t\t\treturn true;\n\t\tbreak;\n\tcase 1: /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR3_STORE_EXITING)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR8_STORE_EXITING)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\t/*\n\t\t * lmsw can change bits 1..3 of cr0, and only set bit 0 of\n\t\t * cr0. Other attempted changes are ignored, with no exit.\n\t\t */\n\t\tif (vmcs12->cr0_guest_host_mask & 0xe &\n\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\treturn true;\n\t\tif ((vmcs12->cr0_guest_host_mask & 0x1) &&\n\t\t    !(vmcs12->cr0_read_shadow & 0x1) &&\n\t\t    (val & 0x1))\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an exit, or 0 if we\n * should handle it ourselves in L0 (and then continue L2). Only call this\n * when in is_guest_mode (L2).\n */\nstatic bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn true;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn false;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn false;\n\t\telse if (is_debug(intr_info) &&\n\t\t\t vcpu->guest_debug &\n\t\t\t (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\telse if (is_breakpoint(intr_info) &&\n\t\t\t vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn false;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn true;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn true;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn false;\n\t\treturn true;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn true;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n\tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn true;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_TRAP_FLAG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn false;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_APIC_WRITE:\n\tcase EXIT_REASON_EOI_INDUCED:\n\t\t/* apic_write and eoi_induced should exit unconditionally. */\n\t\treturn true;\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn true;\n\tcase EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:\n\t\t/*\n\t\t * This should never happen, since it is not possible to\n\t\t * set XSS to a non-zero value---neither in L1 nor in L2.\n\t\t * If if it were, XSS would have to be checked against\n\t\t * the XSS exit bitmap in vmcs12.\n\t\t */\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}\n\n/*\n * Flush all vcpus' PML buffer and update logged GPAs to dirty_bitmap.\n * Called before reporting dirty_bitmap to userspace.\n */\nstatic void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}\n\nstatic void dump_vmcs(void)\n{\n\tu32 vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tu32 vmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tu32 cpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tu32 pin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tu32 secondary_exec_control = 0;\n\tunsigned long cr4 = vmcs_readl(GUEST_CR4);\n\tu64 efer = vmcs_read64(GUEST_IA32_EFER);\n\tint i, n;\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW)\n\t\tpr_err(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\ttrace_kvm_exit(exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.\n\t */\n\tif (enable_pml)\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_PML_FULL &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tWARN_ONCE(1, \"vmx: unexpected exit reason 0x%x\\n\", exit_reason);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\tif (irr == -1 || tpr < irr) {\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(TPR_THRESHOLD, irr);\n}\n\nstatic void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\tu32 sec_exec_control;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.change_vmcs01_virtual_x2apic_mode = true;\n\t\treturn;\n\t}\n\n\tif (!cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\tif (!cpu_need_tpr_shadow(vcpu))\n\t\treturn;\n\n\tsec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tif (set) {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t} else {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t}\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);\n\n\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Currently we do not handle the nested case where L2 has an\n\t * APIC access page of its own; that page is still pinned.\n\t * Hence, we skip the case where the VCPU is in guest mode _and_\n\t * L1 prepared an APIC access page for L2.\n\t *\n\t * For the case where L1 and L2 share the same APIC access page\n\t * (flexpriority=Y but SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES clear\n\t * in the vmcs12), this function will only update either the vmcs01\n\t * or the vmcs02.  If the former, the vmcs02 will be updated by\n\t * prepare_vmcs02.  If the latter, the vmcs01 will be updated in\n\t * the next L2->L1 exit.\n\t */\n\tif (!is_guest_mode(vcpu) ||\n\t    !nested_cpu_has2(get_vmcs12(&vmx->vcpu),\n\t\t\t     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmx_set_rvi(max_irr);\n\t\treturn;\n\t}\n\n\tif (max_irr == -1)\n\t\treturn;\n\n\t/*\n\t * In guest mode.  If a vmexit is needed, vmx_check_nested_events\n\t * handles it.\n\t */\n\tif (nested_exit_on_intr(vcpu))\n\t\treturn;\n\n\t/*\n\t * Else, fall back to pre-APICv interrupt injection since L2\n\t * is run without virtual interrupt delivery.\n\t */\n\tif (!kvm_event_needs_reinjection(vcpu) &&\n\t    vmx_interrupt_allowed(vcpu)) {\n\t\tkvm_queue_interrupt(vcpu, max_irr, false);\n\t\tvmx_inject_irq(vcpu);\n\t}\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n\nstatic void vmx_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tregister void *__sp asm(_ASM_SP);\n\n\tif ((exit_intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) {\n\t\tunsigned int vector;\n\t\tunsigned long entry;\n\t\tgate_desc *desc;\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n#ifdef CONFIG_X86_64\n\t\tunsigned long tmp;\n#endif\n\n\t\tvector =  exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\tdesc = (gate_desc *)vmx->host_idt_base + vector;\n\t\tentry = gate_offset(*desc);\n\t\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\t\"push $%c[ss]\\n\\t\"\n\t\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\t\"pushf\\n\\t\"\n\t\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\t\t\"call *%[entry]\\n\\t\"\n\t\t\t:\n#ifdef CONFIG_X86_64\n\t\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\t\t\"+r\"(__sp)\n\t\t\t:\n\t\t\t[entry]\"r\"(entry),\n\t\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t\t[cs]\"i\"(__KERNEL_CS)\n\t\t\t);\n\t}\n}\n\nstatic bool vmx_has_high_real_mode_segbase(void)\n{\n\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n}\n\nstatic bool vmx_mpx_supported(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}\n\nstatic bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (cpu_has_virtual_nmis()) {\n\t\tif (vmx->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->soft_vnmi_blocked))\n\t\tvmx->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(), vmx->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}\n\nstatic void vmx_arm_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->hv_deadline_tsc == -1)\n\t\treturn;\n\n\ttscl = rdtsc();\n\tif (vmx->hv_deadline_tsc > tscl)\n\t\t/* sure to be 32 bit only because checked on set_hv_timer */\n\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\tcpu_preemption_timer_multi);\n\telse\n\t\tdelta_tsc = 0;\n\n\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n}\n\nstatic void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tif (vmx->guest_pkru_valid)\n\t\t__write_pkru(vmx->guest_pkru);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx_arm_hv_timer(vcpu);\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\n\t/*\n\t * eager fpu is enabled if PKEY is supported and CR4 is switched\n\t * back on host, so it is safe to read guest PKRU from current\n\t * XSAVE.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_OSPKE)) {\n\t\tvmx->guest_pkru = __read_pkru();\n\t\tif (vmx->guest_pkru != vmx->host_pkru) {\n\t\t\tvmx->guest_pkru_valid = true;\n\t\t\t__write_pkru(vmx->host_pkru);\n\t\t} else\n\t\t\tvmx->guest_pkru_valid = false;\n\t}\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n\nstatic void vmx_load_vmcs01(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\n\tif (vmx->loaded_vmcs == &vmx->vmcs01)\n\t\treturn;\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n}\n\n/*\n * Ensure that the current vmcs of the logical processor is the\n * vmcs01 of the vcpu before calling free_nested().\n */\nstatic void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)\n{\n       struct vcpu_vmx *vmx = to_vmx(vcpu);\n       int r;\n\n       r = vcpu_load(vcpu);\n       BUG_ON(r);\n       vmx_load_vmcs01(vcpu);\n       free_nested(vmx);\n       vcpu_put(vcpu);\n}\n\nstatic void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tleave_guest_mode(vcpu);\n\tvmx_free_vcpu_nested(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n\tkfree(vmx->guest_msrs);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n}\n\nstatic struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tint err;\n\tstruct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tint cpu;\n\n\tif (!vmx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvmx->vpid = allocate_vpid();\n\n\terr = kvm_vcpu_init(&vmx->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_vcpu;\n\n\terr = -ENOMEM;\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest, etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto uninit_vcpu;\n\t}\n\n\tvmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) * sizeof(vmx->guest_msrs[0])\n\t\t     > PAGE_SIZE);\n\n\tif (!vmx->guest_msrs)\n\t\tgoto free_pml;\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx->loaded_vmcs->vmcs = alloc_vmcs();\n\tvmx->loaded_vmcs->shadow_vmcs = NULL;\n\tif (!vmx->loaded_vmcs->vmcs)\n\t\tgoto free_msrs;\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(__pa(per_cpu(vmxarea, raw_smp_processor_id())));\n\tloaded_vmcs_init(vmx->loaded_vmcs);\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxoff();\n\n\tcpu = get_cpu();\n\tvmx_vcpu_load(&vmx->vcpu, cpu);\n\tvmx->vcpu.cpu = cpu;\n\terr = vmx_vcpu_setup(vmx);\n\tvmx_vcpu_put(&vmx->vcpu);\n\tput_cpu();\n\tif (err)\n\t\tgoto free_vmcs;\n\tif (cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {\n\t\terr = alloc_apic_access_page(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept) {\n\t\tif (!kvm->arch.ept_identity_map_addr)\n\t\t\tkvm->arch.ept_identity_map_addr =\n\t\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t\terr = init_rmode_identity_map(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(vmx);\n\t\tvmx->nested.vpid02 = allocate_vpid();\n\t}\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n\n\tvmx->msr_ia32_feature_control_valid_bits = FEATURE_CONTROL_LOCKED;\n\n\treturn &vmx->vcpu;\n\nfree_vmcs:\n\tfree_vpid(vmx->nested.vpid02);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_msrs:\n\tkfree(vmx->guest_msrs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nuninit_vcpu:\n\tkvm_vcpu_uninit(&vmx->vcpu);\nfree_vcpu:\n\tfree_vpid(vmx->vpid);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n\treturn ERR_PTR(err);\n}\n\nstatic void __init vmx_check_processor_compat(void *rtn)\n{\n\tstruct vmcs_config vmcs_conf;\n\n\t*(int *)rtn = 0;\n\tif (setup_vmcs_config(&vmcs_conf) < 0)\n\t\t*(int *)rtn = -EIO;\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\t*(int *)rtn = -EIO;\n\t}\n}\n\nstatic int get_ept_level(void)\n{\n\treturn VMX_EPT_DEFAULT_GAW + 1;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\tu64 ipat = 0;\n\n\t/* For VT-d and EPT combination\n\t * 1. MMIO: always map as UC\n\t * 2. EPT with VT-d:\n\t *   a. VT-d without snooping control feature: can't guarantee the\n\t *\tresult, try to trust guest.\n\t *   b. VT-d with snooping control feature: snooping control feature of\n\t *\tVT-d engine can guarantee the cache correctness. Just set it\n\t *\tto WB to keep consistent with host. So the same as item 3.\n\t * 3. EPT without VT-d: always map as WB and set IPAT=1 to keep\n\t *    consistent with host MTRR\n\t */\n\tif (is_mmio) {\n\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm)) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tcache = MTRR_TYPE_WRBACK;\n\t\tgoto exit;\n\t}\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tcache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);\n\nexit:\n\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;\n}\n\nstatic int vmx_get_lpage_level(void)\n{\n\tif (enable_ept && !cpu_has_vmx_ept_1g_page())\n\t\treturn PT_DIRECTORY_LEVEL;\n\telse\n\t\t/* For shadow and EPT supported 1GB page */\n\t\treturn PT_PDPE_LEVEL;\n}\n\nstatic void vmcs_set_secondary_exec_control(u32 new_ctl)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\n\tu32 cur_ctl = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t     (new_ctl & ~mask) | (cur_ctl & mask));\n}\n\n/*\n * Generate MSR_IA32_VMX_CR{0,4}_FIXED1 according to CPUID. Only set bits\n * (indicating \"allowed-1\") if they are supported in the guest's CPUID.\n */\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.nested_vmx_cr0_fixed1 = 0xffffffff;\n\tvmx->nested.nested_vmx_cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.nested_vmx_cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, bit(X86_FEATURE_TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, bit(X86_FEATURE_DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, bit(X86_FEATURE_PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, bit(X86_FEATURE_PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, bit(X86_FEATURE_MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, bit(X86_FEATURE_PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, bit(X86_FEATURE_FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, bit(X86_FEATURE_XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, bit(X86_FEATURE_VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, bit(X86_FEATURE_SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, bit(X86_FEATURE_PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, bit(X86_FEATURE_XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, bit(X86_FEATURE_FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, bit(X86_FEATURE_SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, bit(X86_FEATURE_SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, bit(X86_FEATURE_PKU));\n\t/* TODO: Use X86_CR4_UMIP and X86_FEATURE_UMIP macros */\n\tcr4_fixed1_update(bit(11),            ecx, bit(2));\n\n#undef cr4_fixed1_update\n}\n\nstatic void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 secondary_exec_ctl = vmx_secondary_exec_control(vmx);\n\n\tif (vmx_rdtscp_supported()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has_rdtscp(vcpu);\n\t\tif (!rdtscp_enabled)\n\t\t\tsecondary_exec_ctl &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\t/* Exposing INVPCID only when PCID is exposed */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    (!best || !(best->ebx & bit(X86_FEATURE_INVPCID)) ||\n\t    !guest_cpuid_has_pcid(vcpu))) {\n\t\tsecondary_exec_ctl &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tvmcs_set_secondary_exec_control(secondary_exec_ctl);\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n}\n\nstatic void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}\n\nstatic void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason;\n\n\tif (fault->error_code & PFERR_RSVD_MASK)\n\t\texit_reason = EXIT_REASON_EPT_MISCONFIG;\n\telse\n\t\texit_reason = EXIT_REASON_EPT_VIOLATION;\n\tnested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);\n\tvmcs12->guest_physical_address = fault->address;\n}\n\n/* Callbacks for nested_ept_init_mmu_context: */\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}\n\nstatic void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_ept_mmu(vcpu,\n\t\t\tto_vmx(vcpu)->nested.nested_vmx_ept_caps &\n\t\t\tVMX_EPT_EXECUTE_ONLY_BIT);\n\tvcpu->arch.mmu.set_cr3           = vmx_set_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;\n\tvcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;\n\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic bool nested_vmx_is_page_fault_vmexit(struct vmcs12 *vmcs12,\n\t\t\t\t\t    u16 error_code)\n{\n\tbool inequality, bit;\n\n\tbit = (vmcs12->exception_bitmap & (1u << PF_VECTOR)) != 0;\n\tinequality =\n\t\t(error_code & vmcs12->page_fault_error_code_mask) !=\n\t\t vmcs12->page_fault_error_code_match;\n\treturn inequality ^ bit;\n}\n\nstatic void vmx_inject_page_fault_nested(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON(!is_guest_mode(vcpu));\n\n\tif (nested_vmx_is_page_fault_vmexit(vmcs12, fault->error_code))\n\t\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\telse\n\t\tkvm_inject_page_fault(vcpu, fault);\n}\n\nstatic bool nested_get_vmcs12_pages(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {\n\t\tif (!PAGE_ALIGNED(vmcs12->apic_access_addr) ||\n\t\t    vmcs12->apic_access_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Translate L1 physical address to host physical\n\t\t * address for vmcs02. Keep the page pinned, so this\n\t\t * physical address remains valid. We keep a reference\n\t\t * to it so we can release it later.\n\t\t */\n\t\tif (vmx->nested.apic_access_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page =\n\t\t\tnested_get_page(vcpu, vmcs12->apic_access_addr);\n\t}\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tif (!PAGE_ALIGNED(vmcs12->virtual_apic_page_addr) ||\n\t\t    vmcs12->virtual_apic_page_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\tif (vmx->nested.virtual_apic_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page =\n\t\t\tnested_get_page(vcpu, vmcs12->virtual_apic_page_addr);\n\n\t\t/*\n\t\t * Failing the vm entry is _not_ what the processor does\n\t\t * but it's basically the only possibility we have.\n\t\t * We could still enter the guest if CR8 load exits are\n\t\t * enabled, CR8 store exits are enabled, and virtualize APIC\n\t\t * access is disabled; in this case the processor would never\n\t\t * use the TPR shadow and we could simply clear the bit from\n\t\t * the execution control.  But such a configuration is useless,\n\t\t * so let's keep the code simple.\n\t\t */\n\t\tif (!vmx->nested.virtual_apic_page)\n\t\t\treturn false;\n\t}\n\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tif (!IS_ALIGNED(vmcs12->posted_intr_desc_addr, 64) ||\n\t\t    vmcs12->posted_intr_desc_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\tif (vmx->nested.pi_desc_page) { /* shouldn't happen */\n\t\t\tkunmap(vmx->nested.pi_desc_page);\n\t\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\t}\n\t\tvmx->nested.pi_desc_page =\n\t\t\tnested_get_page(vcpu, vmcs12->posted_intr_desc_addr);\n\t\tif (!vmx->nested.pi_desc_page)\n\t\t\treturn false;\n\n\t\tvmx->nested.pi_desc =\n\t\t\t(struct pi_desc *)kmap(vmx->nested.pi_desc_page);\n\t\tif (!vmx->nested.pi_desc) {\n\t\t\tnested_release_page_clean(vmx->nested.pi_desc_page);\n\t\t\treturn false;\n\t\t}\n\t\tvmx->nested.pi_desc =\n\t\t\t(struct pi_desc *)((void *)vmx->nested.pi_desc +\n\t\t\t(unsigned long)(vmcs12->posted_intr_desc_addr &\n\t\t\t(PAGE_SIZE - 1)));\n\t}\n\n\treturn true;\n}\n\nstatic void vmx_start_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tu64 preemption_timeout = get_vmcs12(vcpu)->vmx_preemption_timer_value;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vcpu->arch.virtual_tsc_khz == 0)\n\t\treturn;\n\n\t/* Make sure short timeouts reliably trigger an immediate vmexit.\n\t * hrtimer_start does not guarantee this. */\n\tif (preemption_timeout <= 1) {\n\t\tvmx_preemption_timer_fn(&vmx->nested.preemption_timer);\n\t\treturn;\n\t}\n\n\tpreemption_timeout <<= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n\tpreemption_timeout *= 1000000;\n\tdo_div(preemption_timeout, vcpu->arch.virtual_tsc_khz);\n\thrtimer_start(&vmx->nested.preemption_timer,\n\t\t      ns_to_ktime(preemption_timeout), HRTIMER_MODE_REL);\n}\n\nstatic int nested_vmx_check_msr_bitmap_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tint maxphyaddr;\n\tu64 addr;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 0;\n\n\tif (vmcs12_read_any(vcpu, MSR_BITMAP, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (!PAGE_ALIGNED(vmcs12->msr_bitmap) ||\n\t   ((addr + PAGE_SIZE) >> maxphyaddr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Merge L0's and L1's MSR bitmap, return false to indicate that\n * we do not use the hardware.\n */\nstatic inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tint msr;\n\tstruct page *page;\n\tunsigned long *msr_bitmap_l1;\n\tunsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.msr_bitmap;\n\n\t/* This shortcut is ok because we support only x2APIC MSRs so far. */\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12))\n\t\treturn false;\n\n\tpage = nested_get_page(vcpu, vmcs12->msr_bitmap);\n\tif (!page) {\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\tmsr_bitmap_l1 = (unsigned long *)kmap(page);\n\tif (!msr_bitmap_l1) {\n\t\tnested_release_page_clean(page);\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tmemset(msr_bitmap_l0, 0xff, PAGE_SIZE);\n\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12)) {\n\t\tif (nested_cpu_has_apic_reg_virt(vmcs12))\n\t\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tmsr, MSR_TYPE_R);\n\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_TASKPRI >> 4),\n\t\t\t\tMSR_TYPE_R | MSR_TYPE_W);\n\n\t\tif (nested_cpu_has_vid(vmcs12)) {\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_EOI >> 4),\n\t\t\t\tMSR_TYPE_W);\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_SELF_IPI >> 4),\n\t\t\t\tMSR_TYPE_W);\n\t\t}\n\t}\n\tkunmap(page);\n\tnested_release_page_clean(page);\n\n\treturn true;\n}\n\nstatic int nested_vmx_check_apicv_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    !nested_cpu_has_apic_reg_virt(vmcs12) &&\n\t    !nested_cpu_has_vid(vmcs12) &&\n\t    !nested_cpu_has_posted_intr(vmcs12))\n\t\treturn 0;\n\n\t/*\n\t * If virtualize x2apic mode is enabled,\n\t * virtualize apic access must be disabled.\n\t */\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If virtual interrupt delivery is enabled,\n\t * we must exit on external interrupts.\n\t */\n\tif (nested_cpu_has_vid(vmcs12) &&\n\t   !nested_exit_on_intr(vcpu))\n\t\treturn -EINVAL;\n\n\t/*\n\t * bits 15:8 should be zero in posted_intr_nv,\n\t * the descriptor address has been already checked\n\t * in nested_get_vmcs12_pages.\n\t */\n\tif (nested_cpu_has_posted_intr(vmcs12) &&\n\t   (!nested_cpu_has_vid(vmcs12) ||\n\t    !nested_exit_intr_ack_set(vcpu) ||\n\t    vmcs12->posted_intr_nv & 0xff00))\n\t\treturn -EINVAL;\n\n\t/* tpr shadow is needed by all apicv features. */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned long count_field,\n\t\t\t\t       unsigned long addr_field)\n{\n\tint maxphyaddr;\n\tu64 count, addr;\n\n\tif (vmcs12_read_any(vcpu, count_field, &count) ||\n\t    vmcs12_read_any(vcpu, addr_field, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (count == 0)\n\t\treturn 0;\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!IS_ALIGNED(addr, 16) || addr >> maxphyaddr ||\n\t    (addr + count * sizeof(struct vmx_msr_entry) - 1) >> maxphyaddr) {\n\t\tpr_debug_ratelimited(\n\t\t\t\"nVMX: invalid MSR switch (0x%lx, %d, %llu, 0x%08llx)\",\n\t\t\taddr_field, maxphyaddr, count, addr);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nested_vmx_check_msr_switch_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tif (vmcs12->vm_exit_msr_load_count == 0 &&\n\t    vmcs12->vm_exit_msr_store_count == 0 &&\n\t    vmcs12->vm_entry_msr_load_count == 0)\n\t\treturn 0; /* Fast path */\n\tif (nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_LOAD_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_STORE_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_STORE_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_ENTRY_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_ENTRY_MSR_LOAD_ADDR))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_msr_check_common(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmx_msr_entry *e)\n{\n\t/* x2APIC MSR accesses are not allowed */\n\tif (vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8)\n\t\treturn -EINVAL;\n\tif (e->index == MSR_IA32_UCODE_WRITE || /* SDM Table 35-2 */\n\t    e->index == MSR_IA32_UCODE_REV)\n\t\treturn -EINVAL;\n\tif (e->reserved != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_load_msr_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct vmx_msr_entry *e)\n{\n\tif (e->index == MSR_FS_BASE ||\n\t    e->index == MSR_GS_BASE ||\n\t    e->index == MSR_IA32_SMM_MONITOR_CTL || /* SMM is not supported */\n\t    nested_vmx_msr_check_common(vcpu, e))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_store_msr_check(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct vmx_msr_entry *e)\n{\n\tif (e->index == MSR_IA32_SMBASE || /* SMM is not supported */\n\t    nested_vmx_msr_check_common(vcpu, e))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/*\n * Load guest's/host's msr at nested entry/exit.\n * return 0 for success, entry index for failure.\n */\nstatic u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}\n\nstatic int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool nested_cr3_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tunsigned long invalid_mask;\n\n\tinvalid_mask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\treturn (val & invalid_mask) == 0;\n}\n\n/*\n * Load guest's/host's cr3 at nested entry/exit. nested_ept is true if we are\n * emulating VM entry into a guest with EPT enabled.\n * Returns 0 on success, 1 on failure. Invalid state exit qualification code\n * is assigned to entry_failure_code on failure.\n */\nstatic int nested_vmx_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3, bool nested_ept,\n\t\t\t       unsigned long *entry_failure_code)\n{\n\tif (cr3 != kvm_read_cr3(vcpu) || (!nested_ept && pdptrs_changed(vcpu))) {\n\t\tif (!nested_cr3_valid(vcpu, cr3)) {\n\t\t\t*entry_failure_code = ENTRY_FAIL_DEFAULT;\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * If PAE paging and EPT are both on, CR3 is not used by the CPU and\n\t\t * must not be dereferenced.\n\t\t */\n\t\tif (!is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu) &&\n\t\t    !nested_ept) {\n\t\t\tif (!load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3)) {\n\t\t\t\t*entry_failure_code = ENTRY_FAIL_PDPTE;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tvcpu->arch.cr3 = cr3;\n\t\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\n/*\n * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested\n * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function \"merges\" it\n * with L0's requirements for its guest (a.k.a. vmcs01), so we can run the L2\n * guest in a way that will both be appropriate to L1's requests, and our\n * needs. In addition to modifying the active vmcs (which is vmcs02), this\n * function also has additional necessary side-effects, like setting various\n * vcpu->arch fields.\n * Returns 0 on success, 1 on failure. Invalid state exit qualification code\n * is assigned to entry_failure_code on failure.\n */\nstatic int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t  unsigned long *entry_failure_code)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\tbool nested_ept_enabled = false;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tif (nested_cpu_has_xsaves(vmcs12))\n\t\tvmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\n\t/* Preemption timer setting is only taken from vmcs01.  */\n\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\tif (vmx->hv_deadline_tsc == -1)\n\t\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/* Posted interrupts setting is only taken from vmcs12.  */\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\t/*\n\t\t * Note that we use L0's vector here and in\n\t\t * vmx_deliver_nested_posted_interrupt.\n\t\t */\n\t\tvmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;\n\t\tvmx->nested.pi_pending = false;\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR,\n\t\t\tpage_to_phys(vmx->nested.pi_desc_page) +\n\t\t\t(unsigned long)(vmcs12->posted_intr_desc_addr &\n\t\t\t(PAGE_SIZE - 1)));\n\t} else\n\t\texec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_RDTSCP |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\t\t  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (!(nested_cpu_has_virt_x2apic_mode(vmcs12)) &&\n\t\t\t    cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP0,\n\t\t\t\tvmcs12->eoi_exit_bitmap0);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP1,\n\t\t\t\tvmcs12->eoi_exit_bitmap1);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP2,\n\t\t\t\tvmcs12->eoi_exit_bitmap2);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP3,\n\t\t\t\tvmcs12->eoi_exit_bitmap3);\n\t\t\tvmcs_write16(GUEST_INTR_STATUS,\n\t\t\t\tvmcs12->guest_intr_status);\n\t\t}\n\n\t\tnested_ept_enabled = (exec_control & SECONDARY_EXEC_ENABLE_EPT) != 0;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * Set the MSR load/store lists to match L0's settings.\n\t */\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap() &&\n\t    exec_control & CPU_BASED_USE_MSR_BITMAPS &&\n\t    nested_vmx_merge_msr_bitmap(vcpu, vmcs12))\n\t\t; /* MSR_BITMAP will be set by following vmx_set_efer. */\n\telse\n\t\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\n\t/*\n\t * Merging of IO bitmap not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvcpu->arch.tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * There is no direct mapping between vpid02 and vpid12, the\n\t\t * vpid02 is per-vCPU for L0 and reused while the value of\n\t\t * vpid12 is changed w/ one invvpid during nested vmentry.\n\t\t * The vpid12 is allocated by L1 for L2, so it will not\n\t\t * influence global bitmap(for vpid01 and vpid02 allocation)\n\t\t * even if spawn a lot of nested vCPUs.\n\t\t */\n\t\tif (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);\n\t\t\tif (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {\n\t\t\t\tvmx->nested.last_vpid = vmcs12->virtual_processor_id;\n\t\t\t\t__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);\n\t\t\t}\n\t\t} else {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\t\tvmx_flush_tlb(vcpu);\n\t\t}\n\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/* Shadow page tables on either EPT or shadow page tables. */\n\tif (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_ept_enabled,\n\t\t\t\tentry_failure_code))\n\t\treturn 1;\n\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n\treturn 0;\n}\n\n/*\n * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1\n * for running an L2 nested guest.\n */\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\tstruct loaded_vmcs *vmcs02;\n\tbool ia32e;\n\tu32 msr_entry_idx;\n\tunsigned long exit_qualification;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\tgoto out;\n\n\tvmcs12 = get_vmcs12(vcpu);\n\n\tif (enable_shadow_vmcs)\n\t\tcopy_shadow_to_vmcs12(vmx);\n\n\t/*\n\t * The nested entry process starts with enforcing various prerequisites\n\t * on vmcs12 as required by the Intel SDM, and act appropriately when\n\t * they fail: As the SDM explains, some conditions should cause the\n\t * instruction to fail, while others will cause the instruction to seem\n\t * to succeed, but return an EXIT_REASON_INVALID_STATE.\n\t * To speed up the normal (success) code path, we should avoid checking\n\t * for misconfigurations which will anyway be caught by the processor\n\t * when using the merged vmcs02.\n\t */\n\tif (vmcs12->launch_state == launch) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tlaunch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS\n\t\t\t       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);\n\t\tgoto out;\n\t}\n\n\tif (vmcs12->guest_activity_state != GUEST_ACTIVITY_ACTIVE &&\n\t    vmcs12->guest_activity_state != GUEST_ACTIVITY_HLT) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_get_vmcs12_pages(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_msr_bitmap_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_apicv_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_msr_switch_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_procbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->secondary_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->pin_based_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_pinbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_exit_controls,\n\t\t\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_exit_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_entry_controls,\n\t\t\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_entry_ctls_high))\n\t{\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_host_cr0_valid(vcpu, vmcs12->host_cr0) ||\n\t    !nested_host_cr4_valid(vcpu, vmcs12->host_cr4) ||\n\t    !nested_cr3_valid(vcpu, vmcs12->host_cr3)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_ENTRY_INVALID_HOST_STATE_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||\n\t    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\tgoto out;\n\t}\n\tif (vmcs12->vmcs_link_pointer != -1ull) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_VMCS_LINK_PTR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-entry control is 1, the following checks\n\t * are performed on the field for the IA32_EFER MSR:\n\t * - Bits reserved in the IA32_EFER MSR must be 0.\n\t * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of\n\t *   the IA-32e mode guest VM-exit control. It must also be identical\n\t *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to\n\t *   CR0.PG) is 1.\n\t */\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-exit control is 1, bits reserved in the\n\t * IA32_EFER MSR must be 0 in the field for that register. In addition,\n\t * the values of the LMA and LME bits in the field must each be that of\n\t * the host address-space size VM-exit control.\n\t */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME)) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We're finally done with prerequisite checking, and can start with\n\t * the nested entry.\n\t */\n\n\tvmcs02 = nested_get_current_vmcs02(vmx);\n\tif (!vmcs02)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * After this point, the trap flag no longer triggers a singlestep trap\n\t * on the vm entry instructions. Don't call\n\t * kvm_skip_emulated_instruction.\n\t */\n\tskip_emulated_instruction(vcpu);\n\tenter_guest_mode(vcpu);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = vmcs02;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (prepare_vmcs02(vcpu, vmcs12, &exit_qualification)) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_load_vmcs01(vcpu);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, exit_qualification);\n\t\treturn 1;\n\t}\n\n\tmsr_entry_idx = nested_vmx_load_msr(vcpu,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_addr,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_count);\n\tif (msr_entry_idx) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_load_vmcs01(vcpu);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_MSR_LOAD_FAIL, msr_entry_idx);\n\t\treturn 1;\n\t}\n\n\tvmcs12->launch_state = 1;\n\n\tif (vmcs12->guest_activity_state == GUEST_ACTIVITY_HLT)\n\t\treturn kvm_vcpu_halt(vcpu);\n\n\tvmx->nested.nested_run_pending = 1;\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn 1;\n\nout:\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/*\n * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date\n * because L2 may have changed some cr0 bits directly (CRO_GUEST_HOST_MASK).\n * This function returns the new value we should put in vmcs12.guest_cr0.\n * It's not enough to just return the vmcs02 GUEST_CR0. Rather,\n *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now\n *     available in vmcs02 GUEST_CR0. (Note: It's enough to check that L0\n *     didn't trap the bit, because if L1 did, so would L0).\n *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have\n *     been modified by L2, and L1 knows it. So just leave the old value of\n *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0\n *     isn't relevant, because if L0 traps this bit it can set it to anything.\n *  3. Bits that L1 didn't trap, but L0 did. L1 believes the guest could have\n *     changed these bits, and therefore they need to be updated, but L0\n *     didn't necessarily allow them to be changed in GUEST_CR0 - and rather\n *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.\n */\nstatic inline unsigned long\nvmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |\n\t\t\tvcpu->arch.cr0_guest_owned_bits));\n}\n\nstatic inline unsigned long\nvmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |\n\t\t\tvcpu->arch.cr4_guest_owned_bits));\n}\n\nstatic void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tu32 idt_vectoring;\n\tunsigned int nr;\n\n\tif (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) {\n\t\tnr = vcpu->arch.exception.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (kvm_exception_is_soft(nr)) {\n\t\t\tvmcs12->vm_exit_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_EXCEPTION;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_HARD_EXCEPTION;\n\n\t\tif (vcpu->arch.exception.has_error_code) {\n\t\t\tidt_vectoring |= VECTORING_INFO_DELIVER_CODE_MASK;\n\t\t\tvmcs12->idt_vectoring_error_code =\n\t\t\t\tvcpu->arch.exception.error_code;\n\t\t}\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t} else if (vcpu->arch.nmi_injected) {\n\t\tvmcs12->idt_vectoring_info_field =\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR;\n\t} else if (vcpu->arch.interrupt.pending) {\n\t\tnr = vcpu->arch.interrupt.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (vcpu->arch.interrupt.soft) {\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_INTR;\n\t\t\tvmcs12->vm_entry_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_EXT_INTR;\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t}\n}\n\nstatic int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending ||\n\t\t    vcpu->arch.interrupt.pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\t/*\n\t\t * The NMI-triggered VM exit counts as injection:\n\t\t * clear this one and block further NMIs.\n\t\t */\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\n\treturn vmx_complete_nested_posted_interrupt(vcpu);\n}\n\nstatic u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)\n{\n\tktime_t remaining =\n\t\thrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);\n\tu64 value;\n\n\tif (ktime_to_ns(remaining) <= 0)\n\t\treturn 0;\n\n\tvalue = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;\n\tdo_div(value, 1000000);\n\treturn value >> VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n}\n\n/*\n * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits\n * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),\n * and this function updates it to reflect the changes to the guest state while\n * L2 was running (and perhaps made some exits which were handled directly by L0\n * without going back to L1), and to reflect the exit reason.\n * Note that we do not have to copy here all VMCS fields, just those that\n * could have changed by the L2 guest or the exit - i.e., the guest-state and\n * exit-information fields only. Other fields are modified by L1 with VMWRITE,\n * which already writes to vmcs12 directly.\n */\nstatic void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t   u32 exit_reason, u32 exit_intr_info,\n\t\t\t   unsigned long exit_qualification)\n{\n\t/* update guest state fields: */\n\tvmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);\n\tvmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);\n\n\tvmcs12->guest_rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tvmcs12->guest_rip = kvm_register_read(vcpu, VCPU_REGS_RIP);\n\tvmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);\n\n\tvmcs12->guest_es_selector = vmcs_read16(GUEST_ES_SELECTOR);\n\tvmcs12->guest_cs_selector = vmcs_read16(GUEST_CS_SELECTOR);\n\tvmcs12->guest_ss_selector = vmcs_read16(GUEST_SS_SELECTOR);\n\tvmcs12->guest_ds_selector = vmcs_read16(GUEST_DS_SELECTOR);\n\tvmcs12->guest_fs_selector = vmcs_read16(GUEST_FS_SELECTOR);\n\tvmcs12->guest_gs_selector = vmcs_read16(GUEST_GS_SELECTOR);\n\tvmcs12->guest_ldtr_selector = vmcs_read16(GUEST_LDTR_SELECTOR);\n\tvmcs12->guest_tr_selector = vmcs_read16(GUEST_TR_SELECTOR);\n\tvmcs12->guest_es_limit = vmcs_read32(GUEST_ES_LIMIT);\n\tvmcs12->guest_cs_limit = vmcs_read32(GUEST_CS_LIMIT);\n\tvmcs12->guest_ss_limit = vmcs_read32(GUEST_SS_LIMIT);\n\tvmcs12->guest_ds_limit = vmcs_read32(GUEST_DS_LIMIT);\n\tvmcs12->guest_fs_limit = vmcs_read32(GUEST_FS_LIMIT);\n\tvmcs12->guest_gs_limit = vmcs_read32(GUEST_GS_LIMIT);\n\tvmcs12->guest_ldtr_limit = vmcs_read32(GUEST_LDTR_LIMIT);\n\tvmcs12->guest_tr_limit = vmcs_read32(GUEST_TR_LIMIT);\n\tvmcs12->guest_gdtr_limit = vmcs_read32(GUEST_GDTR_LIMIT);\n\tvmcs12->guest_idtr_limit = vmcs_read32(GUEST_IDTR_LIMIT);\n\tvmcs12->guest_es_ar_bytes = vmcs_read32(GUEST_ES_AR_BYTES);\n\tvmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);\n\tvmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);\n\tvmcs12->guest_ds_ar_bytes = vmcs_read32(GUEST_DS_AR_BYTES);\n\tvmcs12->guest_fs_ar_bytes = vmcs_read32(GUEST_FS_AR_BYTES);\n\tvmcs12->guest_gs_ar_bytes = vmcs_read32(GUEST_GS_AR_BYTES);\n\tvmcs12->guest_ldtr_ar_bytes = vmcs_read32(GUEST_LDTR_AR_BYTES);\n\tvmcs12->guest_tr_ar_bytes = vmcs_read32(GUEST_TR_AR_BYTES);\n\tvmcs12->guest_es_base = vmcs_readl(GUEST_ES_BASE);\n\tvmcs12->guest_cs_base = vmcs_readl(GUEST_CS_BASE);\n\tvmcs12->guest_ss_base = vmcs_readl(GUEST_SS_BASE);\n\tvmcs12->guest_ds_base = vmcs_readl(GUEST_DS_BASE);\n\tvmcs12->guest_fs_base = vmcs_readl(GUEST_FS_BASE);\n\tvmcs12->guest_gs_base = vmcs_readl(GUEST_GS_BASE);\n\tvmcs12->guest_ldtr_base = vmcs_readl(GUEST_LDTR_BASE);\n\tvmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);\n\tvmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);\n\tvmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);\n\n\tvmcs12->guest_interruptibility_info =\n\t\tvmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tvmcs12->guest_pending_dbg_exceptions =\n\t\tvmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;\n\telse\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_ACTIVE;\n\n\tif (nested_cpu_has_preemption_timer(vmcs12)) {\n\t\tif (vmcs12->vm_exit_controls &\n\t\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER)\n\t\t\tvmcs12->vmx_preemption_timer_value =\n\t\t\t\tvmx_get_preemption_timer_value(vcpu);\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\t}\n\n\t/*\n\t * In some cases (usually, nested EPT), L2 is allowed to change its\n\t * own CR3 without exiting. If it has changed it, we must keep it.\n\t * Of course, if L0 is using shadow page tables, GUEST_CR3 was defined\n\t * by L0, not L1 or L2, so we mustn't unconditionally copy it to vmcs12.\n\t *\n\t * Additionally, restore L2's PDPTR to vmcs12.\n\t */\n\tif (enable_ept) {\n\t\tvmcs12->guest_cr3 = vmcs_readl(GUEST_CR3);\n\t\tvmcs12->guest_pdptr0 = vmcs_read64(GUEST_PDPTR0);\n\t\tvmcs12->guest_pdptr1 = vmcs_read64(GUEST_PDPTR1);\n\t\tvmcs12->guest_pdptr2 = vmcs_read64(GUEST_PDPTR2);\n\t\tvmcs12->guest_pdptr3 = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12))\n\t\tvmcs12->guest_linear_address = vmcs_readl(GUEST_LINEAR_ADDRESS);\n\n\tif (nested_cpu_has_vid(vmcs12))\n\t\tvmcs12->guest_intr_status = vmcs_read16(GUEST_INTR_STATUS);\n\n\tvmcs12->vm_entry_controls =\n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_IA32E_MODE) |\n\t\t(vm_entry_controls_get(to_vmx(vcpu)) & VM_ENTRY_IA32E_MODE);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_DEBUG_CONTROLS) {\n\t\tkvm_get_dr(vcpu, 7, (unsigned long *)&vmcs12->guest_dr7);\n\t\tvmcs12->guest_ia32_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t}\n\n\t/* TODO: These cannot have changed unless we have MSR bitmaps and\n\t * the relevant bit asks not to trap the change */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\tvmcs12->guest_ia32_pat = vmcs_read64(GUEST_IA32_PAT);\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)\n\t\tvmcs12->guest_ia32_efer = vcpu->arch.efer;\n\tvmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);\n\tvmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);\n\tvmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);\n\tif (kvm_mpx_supported())\n\t\tvmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\tif (nested_cpu_has_xsaves(vmcs12))\n\t\tvmcs12->xss_exit_bitmap = vmcs_read64(XSS_EXIT_BITMAP);\n\n\t/* update exit information fields: */\n\n\tvmcs12->vm_exit_reason = exit_reason;\n\tvmcs12->exit_qualification = exit_qualification;\n\n\tvmcs12->vm_exit_intr_info = exit_intr_info;\n\tif ((vmcs12->vm_exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK))\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\tvmcs12->idt_vectoring_info_field = 0;\n\tvmcs12->vm_exit_instruction_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tvmcs12->vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\n\tif (!(vmcs12->vm_exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY)) {\n\t\t/* vm_entry_intr_info_field is cleared on exit. Emulate this\n\t\t * instead of reading the real value. */\n\t\tvmcs12->vm_entry_intr_info_field &= ~INTR_INFO_VALID_MASK;\n\n\t\t/*\n\t\t * Transfer the event that L0 or L1 may wanted to inject into\n\t\t * L2 to IDT_VECTORING_INFO_FIELD.\n\t\t */\n\t\tvmcs12_save_pending_event(vcpu, vmcs12);\n\t}\n\n\t/*\n\t * Drop what we picked up for L2 via vmx_complete_interrupts. It is\n\t * preserved above and would only end up incorrectly in L1.\n\t */\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n}\n\n/*\n * A part of what we need to when the nested L2 guest exits and we want to\n * run its L1 parent, is to reset L1's guest state to the host state specified\n * in vmcs12.\n * This function is to be called not only on normal nested exit, but also on\n * a nested entry failure, as explained in Intel's spec, 3B.23.7 (\"VM-Entry\n * Failures During or After Loading Guest State\").\n * This function should be called when the active VMCS is L1's (vmcs01).\n */\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tstruct kvm_segment seg;\n\tunsigned long entry_failure_code;\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->host_ia32_efer;\n\telse if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->host_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->host_rip);\n\tvmx_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\t/*\n\t * Note that calling vmx_set_cr0 is important, even if cr0 hasn't\n\t * actually changed, because it depends on the current state of\n\t * fpu_active (which may have changed).\n\t * Note that vmx_set_cr0 refers to efer set above.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->host_cr0);\n\t/*\n\t * If we did fpu_activate()/fpu_deactivate() during L2's run, we need\n\t * to apply the same changes to L1's vmcs. We just set cr0 correctly,\n\t * but we also need to update cr0_guest_host_mask and exception_bitmap.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = (vcpu->fpu_active ? X86_CR0_TS : 0);\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/*\n\t * Note that CR4_GUEST_HOST_MASK is already set in the original vmcs01\n\t * (KVM doesn't change it)- no reason to call set_cr4_guest_host_mask();\n\t */\n\tvcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);\n\tkvm_set_cr4(vcpu, vmcs12->host_cr4);\n\n\tnested_ept_uninit_mmu_context(vcpu);\n\n\t/*\n\t * Only PDPTE load can fail as the value of cr3 was checked on entry and\n\t * couldn't have changed.\n\t */\n\tif (nested_vmx_load_cr3(vcpu, vmcs12->host_cr3, false, &entry_failure_code))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_PDPTE_FAIL);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = kvm_inject_page_fault;\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->host_idtr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->host_gdtr_base);\n\n\t/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_CLEAR_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->host_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->host_ia32_pat;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tvmcs_write64(GUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\tvmcs12->host_ia32_perf_global_ctrl);\n\n\t/* Set L1 segment info according to Intel SDM\n\t    27.5.2 Loading Host Segment and Descriptor-Table Registers */\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.selector = vmcs12->host_cs_selector,\n\t\t.type = 11,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.g = 1\n\t};\n\tif (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tseg.l = 1;\n\telse\n\t\tseg.db = 1;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_CS);\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.type = 3,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.db = 1,\n\t\t.g = 1\n\t};\n\tseg.selector = vmcs12->host_ds_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_DS);\n\tseg.selector = vmcs12->host_es_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_ES);\n\tseg.selector = vmcs12->host_ss_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_SS);\n\tseg.selector = vmcs12->host_fs_selector;\n\tseg.base = vmcs12->host_fs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_FS);\n\tseg.selector = vmcs12->host_gs_selector;\n\tseg.base = vmcs12->host_gs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_GS);\n\tseg = (struct kvm_segment) {\n\t\t.base = vmcs12->host_tr_base,\n\t\t.limit = 0x67,\n\t\t.selector = vmcs12->host_tr_selector,\n\t\t.type = 11,\n\t\t.present = 1\n\t};\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_TR);\n\n\tkvm_set_dr(vcpu, 7, 0x400);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n\n\tif (nested_vmx_load_msr(vcpu, vmcs12->vm_exit_msr_load_addr,\n\t\t\t\tvmcs12->vm_exit_msr_load_count))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_MSR_FAIL);\n}\n\n/*\n * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1\n * and modify vmcs12 to make it see what it would expect to see there if\n * L2 was its real guest. Must only be called when in L2 (is_guest_mode())\n */\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 vm_inst_error = 0;\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t       exit_qualification);\n\n\tif (nested_vmx_store_msr(vcpu, vmcs12->vm_exit_msr_store_addr,\n\t\t\t\t vmcs12->vm_exit_msr_store_count))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_SAVE_GUEST_MSR_FAIL);\n\n\tif (unlikely(vmx->fail))\n\t\tvm_inst_error = vmcs_read32(VM_INSTRUCTION_ERROR);\n\n\tvmx_load_vmcs01(vcpu);\n\n\tif ((exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t    && nested_exit_intr_ack_set(vcpu)) {\n\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\tWARN_ON(irq < 0);\n\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t}\n\n\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t       KVM_ISA_VMX);\n\n\tvm_entry_controls_reset_shadow(vmx);\n\tvm_exit_controls_reset_shadow(vmx);\n\tvmx_segment_cache_clear(vmx);\n\n\t/* if no vmcs02 cache requested, remove the one we used */\n\tif (VMCS02_POOL_SIZE == 0)\n\t\tnested_free_vmcs02(vmx, vmx->nested.current_vmptr);\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->hv_deadline_tsc == -1)\n\t\tvmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n\telse\n\t\tvmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\t      PIN_BASED_VMX_PREEMPTION_TIMER);\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_x2apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_x2apic_mode = false;\n\t\tvmx_set_virtual_x2apic_mode(vcpu,\n\t\t\t\tvcpu->arch.apic_base & X2APIC_ENABLE);\n\t}\n\n\t/* This is needed for same reason as it was needed in prepare_vmcs02 */\n\tvmx->host_rsp = 0;\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\t/*\n\t * Exiting from L2 to L1, we're now back to L1 which thinks it just\n\t * finished a VMLAUNCH or VMRESUME instruction, so we need to set the\n\t * success or failure flag accordingly.\n\t */\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->fail = 0;\n\t\tnested_vmx_failValid(vcpu, vm_inst_error);\n\t} else\n\t\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tvmx->nested.sync_shadow_vmcs = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\n/*\n * Forcibly leave nested mode in order to be able to reset the VCPU later on.\n */\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\tfree_nested(to_vmx(vcpu));\n}\n\n/*\n * L1's failure to enter L2 is a subset of a normal exit, as explained in\n * 23.7 \"VM-entry failures during or after loading guest state\" (this also\n * lists the acceptable exit-reason and exit-qualification parameters).\n * It should only be called before L2 actually succeeded to run, and when\n * vmcs01 is current (it doesn't leave_guest_mode() or switch vmcss).\n */\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\treturn X86EMUL_CONTINUE;\n}\n\n#ifdef CONFIG_X86_64\n/* (a << shift) / divisor, return 1 if overflow otherwise 0 */\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}\n\nstatic int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl = rdtsc();\n\tu64 guest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tu64 delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t\t\tu64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.tsc_scaling_ratio,\n\t\t\t\t&delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\tvmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n\treturn 0;\n}\n\nstatic void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmx->hv_deadline_tsc = -1;\n\tvmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n}\n#endif\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (ple_gap)\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic void vmx_slot_enable_log_dirty(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_leaf_clear_dirty(kvm, slot);\n\tkvm_mmu_slot_largepage_remove_write_access(kvm, slot);\n}\n\nstatic void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}\n\nstatic void vmx_flush_log_dirty(struct kvm *kvm)\n{\n\tkvm_flush_pml_buffers(kvm);\n}\n\nstatic void vmx_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_memory_slot *memslot,\n\t\t\t\t\t   gfn_t offset, unsigned long mask)\n{\n\tkvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);\n}\n\n/*\n * This routine does the following things for vCPU which is going\n * to be blocked if VT-d PI is enabled.\n * - Store the vCPU to the wakeup list, so when interrupts happen\n *   we can find the right vCPU to wake up.\n * - Change the Posted-interrupt descriptor as below:\n *      'NDST' <-- vcpu->pre_pcpu\n *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR\n * - If 'ON' is set during this process, which means at least one\n *   interrupt is posted for this vCPU, we cannot block it, in\n *   this case, return 1, otherwise, return 0.\n *\n */\nstatic int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tvcpu->pre_pcpu = vcpu->cpu;\n\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t  vcpu->pre_pcpu), flags);\n\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t      vcpu->pre_pcpu));\n\tspin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t       vcpu->pre_pcpu), flags);\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\t/*\n\t\t * We should not block the vCPU if\n\t\t * an interrupt is posted for it.\n\t\t */\n\t\tif (pi_test_on(pi_desc) == 1) {\n\t\t\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\t  vcpu->pre_pcpu), flags);\n\t\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\tvcpu->pre_pcpu), flags);\n\t\t\tvcpu->pre_pcpu = -1;\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n\n\treturn 0;\n}\n\nstatic int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n\tif (pi_pre_block(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\treturn 0;\n}\n\nstatic void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\tunsigned long flags;\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* Allow posting non-urgent interrupts */\n\t\tnew.sn = 0;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n\n\tif(vcpu->pre_pcpu != -1) {\n\t\tspin_lock_irqsave(\n\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\tvcpu->pre_pcpu), flags);\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock_irqrestore(\n\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\tvcpu->pre_pcpu), flags);\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}\n\nstatic void vmx_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops->set_hv_timer)\n\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\tpi_post_block(vcpu);\n}\n\n/*\n * vmx_update_pi_irte - set IRTE for Posted-Interrupts\n *\n * @kvm: kvm\n * @host_irq: host irq of the interrupt\n * @guest_irq: gsi of the interrupt\n * @set: set or unset PI\n * returns 0 on success, < 0 on failure\n */\nstatic int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = -EINVAL;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tBUG_ON(guest_irq >= irq_rt->nr_rt_entries);\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse {\n\t\t\t/* suppress notification event before unposting */\n\t\t\tpi_set_sn(vcpu_to_pi_desc(vcpu));\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tpi_clear_sn(vcpu_to_pi_desc(vcpu));\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}\n\nstatic void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEATURE_CONTROL_LMCE;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEATURE_CONTROL_LMCE;\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops __ro_after_init = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.hardware_setup = hardware_setup,\n\t.hardware_unsetup = hardware_unsetup,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_enable = hardware_enable,\n\t.hardware_disable = hardware_disable,\n\t.cpu_has_accelerated_tpr = report_flexpriority,\n\t.cpu_has_high_real_mode_segbase = vmx_has_high_real_mode_segbase,\n\n\t.vcpu_create = vmx_create_vcpu,\n\t.vcpu_free = vmx_free_vcpu,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_guest_switch = vmx_save_host_state,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_bp_intercept = update_exception_bitmap,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = vmx_decache_cr0_guest_bits,\n\t.decache_cr3 = vmx_decache_cr3,\n\t.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.set_cr3 = vmx_set_cr3,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.get_dr6 = vmx_get_dr6,\n\t.set_dr6 = vmx_set_dr6,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\n\t.get_pkru = vmx_get_pkru,\n\n\t.fpu_activate = vmx_fpu_activate,\n\t.fpu_deactivate = vmx_fpu_deactivate,\n\n\t.tlb_flush = vmx_flush_tlb,\n\n\t.run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.set_irq = vmx_inject_irq,\n\t.set_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = vmx_set_virtual_x2apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.get_enable_apicv = vmx_get_enable_apicv,\n\t.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_posted_interrupt = vmx_deliver_posted_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.get_tdp_level = get_ept_level,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.get_lpage_level = vmx_get_lpage_level,\n\n\t.cpuid_update = vmx_cpuid_update,\n\n\t.rdtscp_supported = vmx_rdtscp_supported,\n\t.invpcid_supported = vmx_invpcid_supported,\n\n\t.set_supported_cpuid = vmx_set_supported_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\n\t.set_tdp_cr3 = vmx_set_cr3,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_external_intr = vmx_handle_external_intr,\n\t.mpx_supported = vmx_mpx_supported,\n\t.xsaves_supported = vmx_xsaves_supported,\n\n\t.check_nested_events = vmx_check_nested_events,\n\n\t.sched_in = vmx_sched_in,\n\n\t.slot_enable_log_dirty = vmx_slot_enable_log_dirty,\n\t.slot_disable_log_dirty = vmx_slot_disable_log_dirty,\n\t.flush_log_dirty = vmx_flush_log_dirty,\n\t.enable_log_dirty_pt_masked = vmx_enable_log_dirty_pt_masked,\n\n\t.pre_block = vmx_pre_block,\n\t.post_block = vmx_post_block,\n\n\t.pmu_ops = &intel_pmu_ops,\n\n\t.update_pi_irte = vmx_update_pi_irte,\n\n#ifdef CONFIG_X86_64\n\t.set_hv_timer = vmx_set_hv_timer,\n\t.cancel_hv_timer = vmx_cancel_hv_timer,\n#endif\n\n\t.setup_mce = vmx_setup_mce,\n};\n\nstatic int __init vmx_init(void)\n{\n\tint r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),\n                     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n}\n\nmodule_init(vmx_init)\nmodule_exit(vmx_exit)\n"], "fixing_code": ["/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"cpuid.h\"\n#include \"lapic.h\"\n\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/trace_events.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/hrtimer.h>\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n\n#include <asm/cpu.h>\n#include <asm/io.h>\n#include <asm/desc.h>\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/mce.h>\n#include <asm/fpu/internal.h>\n#include <asm/perf_event.h>\n#include <asm/debugreg.h>\n#include <asm/kexec.h>\n#include <asm/apic.h>\n#include <asm/irq_remapping.h>\n\n#include \"trace.h\"\n#include \"pmu.h\"\n\n#define __ex(x) __kvm_handle_fault_on_reboot(x)\n#define __ex_clear(x, reg) \\\n\t____kvm_handle_fault_on_reboot(x, \"xor \" reg \" , \" reg)\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_FEATURE_MATCH(X86_FEATURE_VMX),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n\nstatic bool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly vmm_exclusive = 1;\nmodule_param(vmm_exclusive, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_apicv = 1;\nmodule_param(enable_apicv, bool, S_IRUGO);\n\nstatic bool __read_mostly enable_shadow_vmcs = 1;\nmodule_param_named(enable_shadow_vmcs, enable_shadow_vmcs, bool, S_IRUGO);\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 0;\nmodule_param(nested, bool, S_IRUGO);\n\nstatic u64 __read_mostly host_xss;\n\nstatic bool __read_mostly enable_pml = 1;\nmodule_param_named(pml, enable_pml, bool, S_IRUGO);\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\n/* Guest_tsc -> host_tsc conversion requires 64-bit division.  */\nstatic int __read_mostly cpu_preemption_timer_multi;\nstatic bool __read_mostly enable_preemption_timer = 1;\n#ifdef CONFIG_X86_64\nmodule_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);\n#endif\n\n#define KVM_GUEST_CR0_MASK (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST (X86_CR0_WP | X86_CR0_NE)\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_TSD)\n\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE 5\n\n#define VMX_VPID_EXTENT_SUPPORTED_MASK\t\t\\\n\t(VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_NON_GLOBAL_BIT)\n\n/*\n * Hyper-V requires all of these, so mark them as supported even though\n * they are just treated the same as all-context.\n */\n#define VMX_VPID_EXTENT_SUPPORTED_MASK\t\t\\\n\t(VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT |\t\\\n\tVMX_VPID_EXTENT_SINGLE_NON_GLOBAL_BIT)\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\n#define KVM_VMX_DEFAULT_PLE_GAP           128\n#define KVM_VMX_DEFAULT_PLE_WINDOW        4096\n#define KVM_VMX_DEFAULT_PLE_WINDOW_GROW   2\n#define KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK 0\n#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    \\\n\t\tINT_MAX / KVM_VMX_DEFAULT_PLE_WINDOW_GROW\n\nstatic int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, int, S_IRUGO);\n\nstatic int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, int, S_IRUGO);\n\n/* Default doubles per-vcpu window every exit. */\nstatic int ple_window_grow = KVM_VMX_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, int, S_IRUGO);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic int ple_window_shrink = KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, int, S_IRUGO);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic int ple_window_actual_max = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, int, S_IRUGO);\n\nextern const ulong vmx_return;\n\n#define NR_AUTOLOAD_MSRS 8\n#define VMCS02_POOL_SIZE 1\n\nstruct vmcs {\n\tu32 revision_id;\n\tu32 abort;\n\tchar data[0];\n};\n\n/*\n * Track a VMCS that may be loaded on a certain CPU. If it is (cpu!=-1), also\n * remember whether it was VMLAUNCHed, and maintain a linked list of all VMCSs\n * loaded on this CPU (so we can clear them if the CPU goes down).\n */\nstruct loaded_vmcs {\n\tstruct vmcs *vmcs;\n\tstruct vmcs *shadow_vmcs;\n\tint cpu;\n\tint launched;\n\tstruct list_head loaded_vmcss_on_cpu_link;\n};\n\nstruct shared_msr_entry {\n\tunsigned index;\n\tu64 data;\n\tu64 mask;\n};\n\n/*\n * struct vmcs12 describes the state that our guest hypervisor (L1) keeps for a\n * single nested guest (L2), hence the name vmcs12. Any VMX implementation has\n * a VMCS structure, and vmcs12 is our emulated VMX's VMCS. This structure is\n * stored in guest memory specified by VMPTRLD, but is opaque to the guest,\n * which must access it using VMREAD/VMWRITE/VMCLEAR instructions.\n * More than one of these structures may exist, if L1 runs multiple L2 guests.\n * nested_vmx_run() will use the data here to build a vmcs02: a VMCS for the\n * underlying hardware which will be used to run L2.\n * This structure is packed to ensure that its layout is identical across\n * machines (necessary for live migration).\n * If there are changes in this struct, VMCS12_REVISION must be changed.\n */\ntypedef u64 natural_width;\nstruct __packed vmcs12 {\n\t/* According to the Intel spec, a VMCS region must start with the\n\t * following two fields. Then follow implementation-specific data.\n\t */\n\tu32 revision_id;\n\tu32 abort;\n\n\tu32 launch_state; /* set to 0 by VMCLEAR, to 1 by VMLAUNCH */\n\tu32 padding[7]; /* room for future expansion */\n\n\tu64 io_bitmap_a;\n\tu64 io_bitmap_b;\n\tu64 msr_bitmap;\n\tu64 vm_exit_msr_store_addr;\n\tu64 vm_exit_msr_load_addr;\n\tu64 vm_entry_msr_load_addr;\n\tu64 tsc_offset;\n\tu64 virtual_apic_page_addr;\n\tu64 apic_access_addr;\n\tu64 posted_intr_desc_addr;\n\tu64 ept_pointer;\n\tu64 eoi_exit_bitmap0;\n\tu64 eoi_exit_bitmap1;\n\tu64 eoi_exit_bitmap2;\n\tu64 eoi_exit_bitmap3;\n\tu64 xss_exit_bitmap;\n\tu64 guest_physical_address;\n\tu64 vmcs_link_pointer;\n\tu64 guest_ia32_debugctl;\n\tu64 guest_ia32_pat;\n\tu64 guest_ia32_efer;\n\tu64 guest_ia32_perf_global_ctrl;\n\tu64 guest_pdptr0;\n\tu64 guest_pdptr1;\n\tu64 guest_pdptr2;\n\tu64 guest_pdptr3;\n\tu64 guest_bndcfgs;\n\tu64 host_ia32_pat;\n\tu64 host_ia32_efer;\n\tu64 host_ia32_perf_global_ctrl;\n\tu64 padding64[8]; /* room for future expansion */\n\t/*\n\t * To allow migration of L1 (complete with its L2 guests) between\n\t * machines of different natural widths (32 or 64 bit), we cannot have\n\t * unsigned long fields with no explict size. We use u64 (aliased\n\t * natural_width) instead. Luckily, x86 is little-endian.\n\t */\n\tnatural_width cr0_guest_host_mask;\n\tnatural_width cr4_guest_host_mask;\n\tnatural_width cr0_read_shadow;\n\tnatural_width cr4_read_shadow;\n\tnatural_width cr3_target_value0;\n\tnatural_width cr3_target_value1;\n\tnatural_width cr3_target_value2;\n\tnatural_width cr3_target_value3;\n\tnatural_width exit_qualification;\n\tnatural_width guest_linear_address;\n\tnatural_width guest_cr0;\n\tnatural_width guest_cr3;\n\tnatural_width guest_cr4;\n\tnatural_width guest_es_base;\n\tnatural_width guest_cs_base;\n\tnatural_width guest_ss_base;\n\tnatural_width guest_ds_base;\n\tnatural_width guest_fs_base;\n\tnatural_width guest_gs_base;\n\tnatural_width guest_ldtr_base;\n\tnatural_width guest_tr_base;\n\tnatural_width guest_gdtr_base;\n\tnatural_width guest_idtr_base;\n\tnatural_width guest_dr7;\n\tnatural_width guest_rsp;\n\tnatural_width guest_rip;\n\tnatural_width guest_rflags;\n\tnatural_width guest_pending_dbg_exceptions;\n\tnatural_width guest_sysenter_esp;\n\tnatural_width guest_sysenter_eip;\n\tnatural_width host_cr0;\n\tnatural_width host_cr3;\n\tnatural_width host_cr4;\n\tnatural_width host_fs_base;\n\tnatural_width host_gs_base;\n\tnatural_width host_tr_base;\n\tnatural_width host_gdtr_base;\n\tnatural_width host_idtr_base;\n\tnatural_width host_ia32_sysenter_esp;\n\tnatural_width host_ia32_sysenter_eip;\n\tnatural_width host_rsp;\n\tnatural_width host_rip;\n\tnatural_width paddingl[8]; /* room for future expansion */\n\tu32 pin_based_vm_exec_control;\n\tu32 cpu_based_vm_exec_control;\n\tu32 exception_bitmap;\n\tu32 page_fault_error_code_mask;\n\tu32 page_fault_error_code_match;\n\tu32 cr3_target_count;\n\tu32 vm_exit_controls;\n\tu32 vm_exit_msr_store_count;\n\tu32 vm_exit_msr_load_count;\n\tu32 vm_entry_controls;\n\tu32 vm_entry_msr_load_count;\n\tu32 vm_entry_intr_info_field;\n\tu32 vm_entry_exception_error_code;\n\tu32 vm_entry_instruction_len;\n\tu32 tpr_threshold;\n\tu32 secondary_vm_exec_control;\n\tu32 vm_instruction_error;\n\tu32 vm_exit_reason;\n\tu32 vm_exit_intr_info;\n\tu32 vm_exit_intr_error_code;\n\tu32 idt_vectoring_info_field;\n\tu32 idt_vectoring_error_code;\n\tu32 vm_exit_instruction_len;\n\tu32 vmx_instruction_info;\n\tu32 guest_es_limit;\n\tu32 guest_cs_limit;\n\tu32 guest_ss_limit;\n\tu32 guest_ds_limit;\n\tu32 guest_fs_limit;\n\tu32 guest_gs_limit;\n\tu32 guest_ldtr_limit;\n\tu32 guest_tr_limit;\n\tu32 guest_gdtr_limit;\n\tu32 guest_idtr_limit;\n\tu32 guest_es_ar_bytes;\n\tu32 guest_cs_ar_bytes;\n\tu32 guest_ss_ar_bytes;\n\tu32 guest_ds_ar_bytes;\n\tu32 guest_fs_ar_bytes;\n\tu32 guest_gs_ar_bytes;\n\tu32 guest_ldtr_ar_bytes;\n\tu32 guest_tr_ar_bytes;\n\tu32 guest_interruptibility_info;\n\tu32 guest_activity_state;\n\tu32 guest_sysenter_cs;\n\tu32 host_ia32_sysenter_cs;\n\tu32 vmx_preemption_timer_value;\n\tu32 padding32[7]; /* room for future expansion */\n\tu16 virtual_processor_id;\n\tu16 posted_intr_nv;\n\tu16 guest_es_selector;\n\tu16 guest_cs_selector;\n\tu16 guest_ss_selector;\n\tu16 guest_ds_selector;\n\tu16 guest_fs_selector;\n\tu16 guest_gs_selector;\n\tu16 guest_ldtr_selector;\n\tu16 guest_tr_selector;\n\tu16 guest_intr_status;\n\tu16 host_es_selector;\n\tu16 host_cs_selector;\n\tu16 host_ss_selector;\n\tu16 host_ds_selector;\n\tu16 host_fs_selector;\n\tu16 host_gs_selector;\n\tu16 host_tr_selector;\n};\n\n/*\n * VMCS12_REVISION is an arbitrary id that should be changed if the content or\n * layout of struct vmcs12 is changed. MSR_IA32_VMX_BASIC returns this id, and\n * VMPTRLD verifies that the VMCS region that L1 is loading contains this id.\n */\n#define VMCS12_REVISION 0x11e57ed0\n\n/*\n * VMCS12_SIZE is the number of bytes L1 should allocate for the VMXON region\n * and any VMCS region. Although only sizeof(struct vmcs12) are used by the\n * current implementation, 4K are reserved to avoid future complications.\n */\n#define VMCS12_SIZE 0x1000\n\n/* Used to remember the last vmcs02 used for some recently used vmcs12s */\nstruct vmcs02_list {\n\tstruct list_head list;\n\tgpa_t vmptr;\n\tstruct loaded_vmcs vmcs02;\n};\n\n/*\n * The nested_vmx structure is part of vcpu_vmx, and holds information we need\n * for correct emulation of VMX (i.e., nested VMX) on this vcpu.\n */\nstruct nested_vmx {\n\t/* Has the level1 guest done vmxon? */\n\tbool vmxon;\n\tgpa_t vmxon_ptr;\n\n\t/* The guest-physical address of the current VMCS L1 keeps for L2 */\n\tgpa_t current_vmptr;\n\t/* The host-usable pointer to the above */\n\tstruct page *current_vmcs12_page;\n\tstruct vmcs12 *current_vmcs12;\n\t/*\n\t * Cache of the guest's VMCS, existing outside of guest memory.\n\t * Loaded from guest memory during VMPTRLD. Flushed to guest\n\t * memory during VMXOFF, VMCLEAR, VMPTRLD.\n\t */\n\tstruct vmcs12 *cached_vmcs12;\n\t/*\n\t * Indicates if the shadow vmcs must be updated with the\n\t * data hold by vmcs12\n\t */\n\tbool sync_shadow_vmcs;\n\n\t/* vmcs02_list cache of VMCSs recently used to run L2 guests */\n\tstruct list_head vmcs02_pool;\n\tint vmcs02_num;\n\tbool change_vmcs01_virtual_x2apic_mode;\n\t/* L2 must run next, and mustn't decide to exit to L1. */\n\tbool nested_run_pending;\n\t/*\n\t * Guest pages referred to in vmcs02 with host-physical pointers, so\n\t * we must keep them pinned while L2 runs.\n\t */\n\tstruct page *apic_access_page;\n\tstruct page *virtual_apic_page;\n\tstruct page *pi_desc_page;\n\tstruct pi_desc *pi_desc;\n\tbool pi_pending;\n\tu16 posted_intr_nv;\n\n\tunsigned long *msr_bitmap;\n\n\tstruct hrtimer preemption_timer;\n\tbool preemption_timer_expired;\n\n\t/* to migrate it to L2 if VM_ENTRY_LOAD_DEBUG_CONTROLS is off */\n\tu64 vmcs01_debugctl;\n\n\tu16 vpid02;\n\tu16 last_vpid;\n\n\t/*\n\t * We only store the \"true\" versions of the VMX capability MSRs. We\n\t * generate the \"non-true\" versions by setting the must-be-1 bits\n\t * according to the SDM.\n\t */\n\tu32 nested_vmx_procbased_ctls_low;\n\tu32 nested_vmx_procbased_ctls_high;\n\tu32 nested_vmx_secondary_ctls_low;\n\tu32 nested_vmx_secondary_ctls_high;\n\tu32 nested_vmx_pinbased_ctls_low;\n\tu32 nested_vmx_pinbased_ctls_high;\n\tu32 nested_vmx_exit_ctls_low;\n\tu32 nested_vmx_exit_ctls_high;\n\tu32 nested_vmx_entry_ctls_low;\n\tu32 nested_vmx_entry_ctls_high;\n\tu32 nested_vmx_misc_low;\n\tu32 nested_vmx_misc_high;\n\tu32 nested_vmx_ept_caps;\n\tu32 nested_vmx_vpid_caps;\n\tu64 nested_vmx_basic;\n\tu64 nested_vmx_cr0_fixed0;\n\tu64 nested_vmx_cr0_fixed1;\n\tu64 nested_vmx_cr4_fixed0;\n\tu64 nested_vmx_cr4_fixed1;\n\tu64 nested_vmx_vmcs_enum;\n};\n\n#define POSTED_INTR_ON  0\n#define POSTED_INTR_SN  1\n\n/* Posted-Interrupt Descriptor */\nstruct pi_desc {\n\tu32 pir[8];     /* Posted interrupt requested */\n\tunion {\n\t\tstruct {\n\t\t\t\t/* bit 256 - Outstanding Notification */\n\t\t\tu16\ton\t: 1,\n\t\t\t\t/* bit 257 - Suppress Notification */\n\t\t\t\tsn\t: 1,\n\t\t\t\t/* bit 271:258 - Reserved */\n\t\t\t\trsvd_1\t: 14;\n\t\t\t\t/* bit 279:272 - Notification Vector */\n\t\t\tu8\tnv;\n\t\t\t\t/* bit 287:280 - Reserved */\n\t\t\tu8\trsvd_2;\n\t\t\t\t/* bit 319:288 - Notification Destination */\n\t\t\tu32\tndst;\n\t\t};\n\t\tu64 control;\n\t};\n\tu32 rsvd[6];\n} __aligned(64);\n\nstatic bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic bool pi_test_and_clear_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_clear_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}\n\nstatic inline void pi_clear_sn(struct pi_desc *pi_desc)\n{\n\treturn clear_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline void pi_set_sn(struct pi_desc *pi_desc)\n{\n\treturn set_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n  \t\t  (unsigned long *)&pi_desc->control);\n}\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstatic inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n\nstruct vcpu_vmx {\n\tstruct kvm_vcpu       vcpu;\n\tunsigned long         host_rsp;\n\tu8                    fail;\n\tbool                  nmi_known_unmasked;\n\tu32                   exit_intr_info;\n\tu32                   idt_vectoring_info;\n\tulong                 rflags;\n\tstruct shared_msr_entry *guest_msrs;\n\tint                   nmsrs;\n\tint                   save_nmsrs;\n\tunsigned long\t      host_idt_base;\n#ifdef CONFIG_X86_64\n\tu64 \t\t      msr_host_kernel_gs_base;\n\tu64 \t\t      msr_guest_kernel_gs_base;\n#endif\n\tu32 vm_entry_controls_shadow;\n\tu32 vm_exit_controls_shadow;\n\t/*\n\t * loaded_vmcs points to the VMCS currently used in this vcpu. For a\n\t * non-nested (L1) guest, it always points to vmcs01. For a nested\n\t * guest (L2), it points to a different VMCS.\n\t */\n\tstruct loaded_vmcs    vmcs01;\n\tstruct loaded_vmcs   *loaded_vmcs;\n\tbool                  __launched; /* temporary, used in vmx_vcpu_run */\n\tstruct msr_autoload {\n\t\tunsigned nr;\n\t\tstruct vmx_msr_entry guest[NR_AUTOLOAD_MSRS];\n\t\tstruct vmx_msr_entry host[NR_AUTOLOAD_MSRS];\n\t} msr_autoload;\n\tstruct {\n\t\tint           loaded;\n\t\tu16           fs_sel, gs_sel, ldt_sel;\n#ifdef CONFIG_X86_64\n\t\tu16           ds_sel, es_sel;\n#endif\n\t\tint           gs_ldt_reload_needed;\n\t\tint           fs_reload_needed;\n\t\tu64           msr_host_bndcfgs;\n\t\tunsigned long vmcs_host_cr4;\t/* May not match real cr4 */\n\t} host_state;\n\tstruct {\n\t\tint vm86_active;\n\t\tulong save_rflags;\n\t\tstruct kvm_segment segs[8];\n\t} rmode;\n\tstruct {\n\t\tu32 bitmask; /* 4 bits per segment (1 bit per field) */\n\t\tstruct kvm_save_segment {\n\t\t\tu16 selector;\n\t\t\tunsigned long base;\n\t\t\tu32 limit;\n\t\t\tu32 ar;\n\t\t} seg[8];\n\t} segment_cache;\n\tint vpid;\n\tbool emulation_required;\n\n\t/* Support for vnmi-less CPUs */\n\tint soft_vnmi_blocked;\n\tktime_t entry_time;\n\ts64 vnmi_blocked_time;\n\tu32 exit_reason;\n\n\t/* Posted interrupt descriptor */\n\tstruct pi_desc pi_desc;\n\n\t/* Support for a guest hypervisor (nested VMX) */\n\tstruct nested_vmx nested;\n\n\t/* Dynamic PLE window. */\n\tint ple_window;\n\tbool ple_window_dirty;\n\n\t/* Support for PML */\n#define PML_ENTITY_NUM\t\t512\n\tstruct page *pml_pg;\n\n\t/* apic deadline value in host tsc */\n\tu64 hv_deadline_tsc;\n\n\tu64 current_tsc_ratio;\n\n\tbool guest_pkru_valid;\n\tu32 guest_pkru;\n\tu32 host_pkru;\n\n\t/*\n\t * Only bits masked by msr_ia32_feature_control_valid_bits can be set in\n\t * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included\n\t * in msr_ia32_feature_control_valid_bits.\n\t */\n\tu64 msr_ia32_feature_control;\n\tu64 msr_ia32_feature_control_valid_bits;\n};\n\nenum segment_cache_field {\n\tSEG_FIELD_SEL = 0,\n\tSEG_FIELD_BASE = 1,\n\tSEG_FIELD_LIMIT = 2,\n\tSEG_FIELD_AR = 3,\n\n\tSEG_FIELD_NR = 4\n};\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}\n\nstatic struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}\n\n#define VMCS12_OFFSET(x) offsetof(struct vmcs12, x)\n#define FIELD(number, name)\t[number] = VMCS12_OFFSET(name)\n#define FIELD64(number, name)\t[number] = VMCS12_OFFSET(name), \\\n\t\t\t\t[number##_HIGH] = VMCS12_OFFSET(name)+4\n\n\nstatic unsigned long shadow_read_only_fields[] = {\n\t/*\n\t * We do NOT shadow fields that are modified when L0\n\t * traps and emulates any vmx instruction (e.g. VMPTRLD,\n\t * VMXON...) executed by L1.\n\t * For example, VM_INSTRUCTION_ERROR is read\n\t * by L1 if a vmx instruction fails (part of the error path).\n\t * Note the code assumes this logic. If for some reason\n\t * we start shadowing these fields then we need to\n\t * force a shadow sync when L0 emulates vmx instructions\n\t * (e.g. force a sync if VM_INSTRUCTION_ERROR is modified\n\t * by nested_vmx_failValid)\n\t */\n\tVM_EXIT_REASON,\n\tVM_EXIT_INTR_INFO,\n\tVM_EXIT_INSTRUCTION_LEN,\n\tIDT_VECTORING_INFO_FIELD,\n\tIDT_VECTORING_ERROR_CODE,\n\tVM_EXIT_INTR_ERROR_CODE,\n\tEXIT_QUALIFICATION,\n\tGUEST_LINEAR_ADDRESS,\n\tGUEST_PHYSICAL_ADDRESS\n};\nstatic int max_shadow_read_only_fields =\n\tARRAY_SIZE(shadow_read_only_fields);\n\nstatic unsigned long shadow_read_write_fields[] = {\n\tTPR_THRESHOLD,\n\tGUEST_RIP,\n\tGUEST_RSP,\n\tGUEST_CR0,\n\tGUEST_CR3,\n\tGUEST_CR4,\n\tGUEST_INTERRUPTIBILITY_INFO,\n\tGUEST_RFLAGS,\n\tGUEST_CS_SELECTOR,\n\tGUEST_CS_AR_BYTES,\n\tGUEST_CS_LIMIT,\n\tGUEST_CS_BASE,\n\tGUEST_ES_BASE,\n\tGUEST_BNDCFGS,\n\tCR0_GUEST_HOST_MASK,\n\tCR0_READ_SHADOW,\n\tCR4_READ_SHADOW,\n\tTSC_OFFSET,\n\tEXCEPTION_BITMAP,\n\tCPU_BASED_VM_EXEC_CONTROL,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tVM_ENTRY_INTR_INFO_FIELD,\n\tVM_ENTRY_INSTRUCTION_LEN,\n\tVM_ENTRY_EXCEPTION_ERROR_CODE,\n\tHOST_FS_BASE,\n\tHOST_GS_BASE,\n\tHOST_FS_SELECTOR,\n\tHOST_GS_SELECTOR\n};\nstatic int max_shadow_read_write_fields =\n\tARRAY_SIZE(shadow_read_write_fields);\n\nstatic const unsigned short vmcs_field_to_offset_table[] = {\n\tFIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id),\n\tFIELD(POSTED_INTR_NV, posted_intr_nv),\n\tFIELD(GUEST_ES_SELECTOR, guest_es_selector),\n\tFIELD(GUEST_CS_SELECTOR, guest_cs_selector),\n\tFIELD(GUEST_SS_SELECTOR, guest_ss_selector),\n\tFIELD(GUEST_DS_SELECTOR, guest_ds_selector),\n\tFIELD(GUEST_FS_SELECTOR, guest_fs_selector),\n\tFIELD(GUEST_GS_SELECTOR, guest_gs_selector),\n\tFIELD(GUEST_LDTR_SELECTOR, guest_ldtr_selector),\n\tFIELD(GUEST_TR_SELECTOR, guest_tr_selector),\n\tFIELD(GUEST_INTR_STATUS, guest_intr_status),\n\tFIELD(HOST_ES_SELECTOR, host_es_selector),\n\tFIELD(HOST_CS_SELECTOR, host_cs_selector),\n\tFIELD(HOST_SS_SELECTOR, host_ss_selector),\n\tFIELD(HOST_DS_SELECTOR, host_ds_selector),\n\tFIELD(HOST_FS_SELECTOR, host_fs_selector),\n\tFIELD(HOST_GS_SELECTOR, host_gs_selector),\n\tFIELD(HOST_TR_SELECTOR, host_tr_selector),\n\tFIELD64(IO_BITMAP_A, io_bitmap_a),\n\tFIELD64(IO_BITMAP_B, io_bitmap_b),\n\tFIELD64(MSR_BITMAP, msr_bitmap),\n\tFIELD64(VM_EXIT_MSR_STORE_ADDR, vm_exit_msr_store_addr),\n\tFIELD64(VM_EXIT_MSR_LOAD_ADDR, vm_exit_msr_load_addr),\n\tFIELD64(VM_ENTRY_MSR_LOAD_ADDR, vm_entry_msr_load_addr),\n\tFIELD64(TSC_OFFSET, tsc_offset),\n\tFIELD64(VIRTUAL_APIC_PAGE_ADDR, virtual_apic_page_addr),\n\tFIELD64(APIC_ACCESS_ADDR, apic_access_addr),\n\tFIELD64(POSTED_INTR_DESC_ADDR, posted_intr_desc_addr),\n\tFIELD64(EPT_POINTER, ept_pointer),\n\tFIELD64(EOI_EXIT_BITMAP0, eoi_exit_bitmap0),\n\tFIELD64(EOI_EXIT_BITMAP1, eoi_exit_bitmap1),\n\tFIELD64(EOI_EXIT_BITMAP2, eoi_exit_bitmap2),\n\tFIELD64(EOI_EXIT_BITMAP3, eoi_exit_bitmap3),\n\tFIELD64(XSS_EXIT_BITMAP, xss_exit_bitmap),\n\tFIELD64(GUEST_PHYSICAL_ADDRESS, guest_physical_address),\n\tFIELD64(VMCS_LINK_POINTER, vmcs_link_pointer),\n\tFIELD64(GUEST_IA32_DEBUGCTL, guest_ia32_debugctl),\n\tFIELD64(GUEST_IA32_PAT, guest_ia32_pat),\n\tFIELD64(GUEST_IA32_EFER, guest_ia32_efer),\n\tFIELD64(GUEST_IA32_PERF_GLOBAL_CTRL, guest_ia32_perf_global_ctrl),\n\tFIELD64(GUEST_PDPTR0, guest_pdptr0),\n\tFIELD64(GUEST_PDPTR1, guest_pdptr1),\n\tFIELD64(GUEST_PDPTR2, guest_pdptr2),\n\tFIELD64(GUEST_PDPTR3, guest_pdptr3),\n\tFIELD64(GUEST_BNDCFGS, guest_bndcfgs),\n\tFIELD64(HOST_IA32_PAT, host_ia32_pat),\n\tFIELD64(HOST_IA32_EFER, host_ia32_efer),\n\tFIELD64(HOST_IA32_PERF_GLOBAL_CTRL, host_ia32_perf_global_ctrl),\n\tFIELD(PIN_BASED_VM_EXEC_CONTROL, pin_based_vm_exec_control),\n\tFIELD(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control),\n\tFIELD(EXCEPTION_BITMAP, exception_bitmap),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MASK, page_fault_error_code_mask),\n\tFIELD(PAGE_FAULT_ERROR_CODE_MATCH, page_fault_error_code_match),\n\tFIELD(CR3_TARGET_COUNT, cr3_target_count),\n\tFIELD(VM_EXIT_CONTROLS, vm_exit_controls),\n\tFIELD(VM_EXIT_MSR_STORE_COUNT, vm_exit_msr_store_count),\n\tFIELD(VM_EXIT_MSR_LOAD_COUNT, vm_exit_msr_load_count),\n\tFIELD(VM_ENTRY_CONTROLS, vm_entry_controls),\n\tFIELD(VM_ENTRY_MSR_LOAD_COUNT, vm_entry_msr_load_count),\n\tFIELD(VM_ENTRY_INTR_INFO_FIELD, vm_entry_intr_info_field),\n\tFIELD(VM_ENTRY_EXCEPTION_ERROR_CODE, vm_entry_exception_error_code),\n\tFIELD(VM_ENTRY_INSTRUCTION_LEN, vm_entry_instruction_len),\n\tFIELD(TPR_THRESHOLD, tpr_threshold),\n\tFIELD(SECONDARY_VM_EXEC_CONTROL, secondary_vm_exec_control),\n\tFIELD(VM_INSTRUCTION_ERROR, vm_instruction_error),\n\tFIELD(VM_EXIT_REASON, vm_exit_reason),\n\tFIELD(VM_EXIT_INTR_INFO, vm_exit_intr_info),\n\tFIELD(VM_EXIT_INTR_ERROR_CODE, vm_exit_intr_error_code),\n\tFIELD(IDT_VECTORING_INFO_FIELD, idt_vectoring_info_field),\n\tFIELD(IDT_VECTORING_ERROR_CODE, idt_vectoring_error_code),\n\tFIELD(VM_EXIT_INSTRUCTION_LEN, vm_exit_instruction_len),\n\tFIELD(VMX_INSTRUCTION_INFO, vmx_instruction_info),\n\tFIELD(GUEST_ES_LIMIT, guest_es_limit),\n\tFIELD(GUEST_CS_LIMIT, guest_cs_limit),\n\tFIELD(GUEST_SS_LIMIT, guest_ss_limit),\n\tFIELD(GUEST_DS_LIMIT, guest_ds_limit),\n\tFIELD(GUEST_FS_LIMIT, guest_fs_limit),\n\tFIELD(GUEST_GS_LIMIT, guest_gs_limit),\n\tFIELD(GUEST_LDTR_LIMIT, guest_ldtr_limit),\n\tFIELD(GUEST_TR_LIMIT, guest_tr_limit),\n\tFIELD(GUEST_GDTR_LIMIT, guest_gdtr_limit),\n\tFIELD(GUEST_IDTR_LIMIT, guest_idtr_limit),\n\tFIELD(GUEST_ES_AR_BYTES, guest_es_ar_bytes),\n\tFIELD(GUEST_CS_AR_BYTES, guest_cs_ar_bytes),\n\tFIELD(GUEST_SS_AR_BYTES, guest_ss_ar_bytes),\n\tFIELD(GUEST_DS_AR_BYTES, guest_ds_ar_bytes),\n\tFIELD(GUEST_FS_AR_BYTES, guest_fs_ar_bytes),\n\tFIELD(GUEST_GS_AR_BYTES, guest_gs_ar_bytes),\n\tFIELD(GUEST_LDTR_AR_BYTES, guest_ldtr_ar_bytes),\n\tFIELD(GUEST_TR_AR_BYTES, guest_tr_ar_bytes),\n\tFIELD(GUEST_INTERRUPTIBILITY_INFO, guest_interruptibility_info),\n\tFIELD(GUEST_ACTIVITY_STATE, guest_activity_state),\n\tFIELD(GUEST_SYSENTER_CS, guest_sysenter_cs),\n\tFIELD(HOST_IA32_SYSENTER_CS, host_ia32_sysenter_cs),\n\tFIELD(VMX_PREEMPTION_TIMER_VALUE, vmx_preemption_timer_value),\n\tFIELD(CR0_GUEST_HOST_MASK, cr0_guest_host_mask),\n\tFIELD(CR4_GUEST_HOST_MASK, cr4_guest_host_mask),\n\tFIELD(CR0_READ_SHADOW, cr0_read_shadow),\n\tFIELD(CR4_READ_SHADOW, cr4_read_shadow),\n\tFIELD(CR3_TARGET_VALUE0, cr3_target_value0),\n\tFIELD(CR3_TARGET_VALUE1, cr3_target_value1),\n\tFIELD(CR3_TARGET_VALUE2, cr3_target_value2),\n\tFIELD(CR3_TARGET_VALUE3, cr3_target_value3),\n\tFIELD(EXIT_QUALIFICATION, exit_qualification),\n\tFIELD(GUEST_LINEAR_ADDRESS, guest_linear_address),\n\tFIELD(GUEST_CR0, guest_cr0),\n\tFIELD(GUEST_CR3, guest_cr3),\n\tFIELD(GUEST_CR4, guest_cr4),\n\tFIELD(GUEST_ES_BASE, guest_es_base),\n\tFIELD(GUEST_CS_BASE, guest_cs_base),\n\tFIELD(GUEST_SS_BASE, guest_ss_base),\n\tFIELD(GUEST_DS_BASE, guest_ds_base),\n\tFIELD(GUEST_FS_BASE, guest_fs_base),\n\tFIELD(GUEST_GS_BASE, guest_gs_base),\n\tFIELD(GUEST_LDTR_BASE, guest_ldtr_base),\n\tFIELD(GUEST_TR_BASE, guest_tr_base),\n\tFIELD(GUEST_GDTR_BASE, guest_gdtr_base),\n\tFIELD(GUEST_IDTR_BASE, guest_idtr_base),\n\tFIELD(GUEST_DR7, guest_dr7),\n\tFIELD(GUEST_RSP, guest_rsp),\n\tFIELD(GUEST_RIP, guest_rip),\n\tFIELD(GUEST_RFLAGS, guest_rflags),\n\tFIELD(GUEST_PENDING_DBG_EXCEPTIONS, guest_pending_dbg_exceptions),\n\tFIELD(GUEST_SYSENTER_ESP, guest_sysenter_esp),\n\tFIELD(GUEST_SYSENTER_EIP, guest_sysenter_eip),\n\tFIELD(HOST_CR0, host_cr0),\n\tFIELD(HOST_CR3, host_cr3),\n\tFIELD(HOST_CR4, host_cr4),\n\tFIELD(HOST_FS_BASE, host_fs_base),\n\tFIELD(HOST_GS_BASE, host_gs_base),\n\tFIELD(HOST_TR_BASE, host_tr_base),\n\tFIELD(HOST_GDTR_BASE, host_gdtr_base),\n\tFIELD(HOST_IDTR_BASE, host_idtr_base),\n\tFIELD(HOST_IA32_SYSENTER_ESP, host_ia32_sysenter_esp),\n\tFIELD(HOST_IA32_SYSENTER_EIP, host_ia32_sysenter_eip),\n\tFIELD(HOST_RSP, host_rsp),\n\tFIELD(HOST_RIP, host_rip),\n};\n\nstatic inline short vmcs_field_to_offset(unsigned long field)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(vmcs_field_to_offset_table) > SHRT_MAX);\n\n\tif (field >= ARRAY_SIZE(vmcs_field_to_offset_table) ||\n\t    vmcs_field_to_offset_table[field] == 0)\n\t\treturn -ENOENT;\n\n\treturn vmcs_field_to_offset_table[field];\n}\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}\n\nstatic struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)\n{\n\tstruct page *page = kvm_vcpu_gfn_to_page(vcpu, addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}\n\nstatic void nested_release_page_clean(struct page *page)\n{\n\tkvm_release_page_clean(page);\n}\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic u64 construct_eptp(unsigned long root_hpa);\nstatic void kvm_cpu_vmxon(u64 addr);\nstatic void kvm_cpu_vmxoff(void);\nstatic bool vmx_xsaves_supported(void);\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr);\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx);\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx);\nstatic int alloc_identity_pagetable(struct kvm *kvm);\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nstatic DEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\nstatic DEFINE_PER_CPU(struct desc_ptr, host_gdt);\n\n/*\n * We maintian a per-CPU linked-list of vCPU, so in wakeup_handler() we\n * can find which vCPU should be waken up.\n */\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nenum {\n\tVMX_IO_BITMAP_A,\n\tVMX_IO_BITMAP_B,\n\tVMX_MSR_BITMAP_LEGACY,\n\tVMX_MSR_BITMAP_LONGMODE,\n\tVMX_MSR_BITMAP_LEGACY_X2APIC_APICV,\n\tVMX_MSR_BITMAP_LONGMODE_X2APIC_APICV,\n\tVMX_MSR_BITMAP_LEGACY_X2APIC,\n\tVMX_MSR_BITMAP_LONGMODE_X2APIC,\n\tVMX_VMREAD_BITMAP,\n\tVMX_VMWRITE_BITMAP,\n\tVMX_BITMAP_NR\n};\n\nstatic unsigned long *vmx_bitmap[VMX_BITMAP_NR];\n\n#define vmx_io_bitmap_a                      (vmx_bitmap[VMX_IO_BITMAP_A])\n#define vmx_io_bitmap_b                      (vmx_bitmap[VMX_IO_BITMAP_B])\n#define vmx_msr_bitmap_legacy                (vmx_bitmap[VMX_MSR_BITMAP_LEGACY])\n#define vmx_msr_bitmap_longmode              (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE])\n#define vmx_msr_bitmap_legacy_x2apic_apicv   (vmx_bitmap[VMX_MSR_BITMAP_LEGACY_X2APIC_APICV])\n#define vmx_msr_bitmap_longmode_x2apic_apicv (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE_X2APIC_APICV])\n#define vmx_msr_bitmap_legacy_x2apic         (vmx_bitmap[VMX_MSR_BITMAP_LEGACY_X2APIC])\n#define vmx_msr_bitmap_longmode_x2apic       (vmx_bitmap[VMX_MSR_BITMAP_LONGMODE_X2APIC])\n#define vmx_vmread_bitmap                    (vmx_bitmap[VMX_VMREAD_BITMAP])\n#define vmx_vmwrite_bitmap                   (vmx_bitmap[VMX_VMWRITE_BITMAP])\n\nstatic bool cpu_has_load_ia32_efer;\nstatic bool cpu_has_load_perf_global_ctrl;\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstatic struct vmcs_config {\n\tint size;\n\tint order;\n\tu32 basic_cap;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n} vmcs_config;\n\nstatic struct vmx_capability {\n\tu32 ept;\n\tu32 vpid;\n} vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u64 host_efer;\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\n\n/*\n * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it\n * away by decrementing the array size.\n */\nstatic const u32 vmx_msr_index[] = {\n#ifdef CONFIG_X86_64\n\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n#endif\n\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n};\n\nstatic inline bool is_exception_n(u32 intr_info, u8 vector)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | vector | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_debug(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, DB_VECTOR);\n}\n\nstatic inline bool is_breakpoint(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, BP_VECTOR);\n}\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}\n\nstatic inline bool is_no_device(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, NM_VECTOR);\n}\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, UD_VECTOR);\n}\n\nstatic inline bool is_external_interrupt(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_EXT_INTR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}\n\nstatic inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_apic_accesses(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}\n\nstatic inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_virtual_intr_delivery(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY;\n}\n\n/*\n * Comment's format: document - errata name - stepping - processor name.\n * Refer from\n * https://www.virtualbox.org/svn/vbox/trunk/src/VBox/VMM/VMMR0/HMR0.cpp\n */\nstatic u32 vmx_preemption_cpu_tfms[] = {\n/* 323344.pdf - BA86   - D0 - Xeon 7500 Series */\n0x000206E6,\n/* 323056.pdf - AAX65  - C2 - Xeon L3406 */\n/* 322814.pdf - AAT59  - C2 - i7-600, i5-500, i5-400 and i3-300 Mobile */\n/* 322911.pdf - AAU65  - C2 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020652,\n/* 322911.pdf - AAU65  - K0 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020655,\n/* 322373.pdf - AAO95  - B1 - Xeon 3400 Series */\n/* 322166.pdf - AAN92  - B1 - i7-800 and i5-700 Desktop */\n/*\n * 320767.pdf - AAP86  - B1 -\n * i7-900 Mobile Extreme, i7-800 and i7-700 Mobile\n */\n0x000106E5,\n/* 321333.pdf - AAM126 - C0 - Xeon 3500 */\n0x000106A0,\n/* 321333.pdf - AAM126 - C1 - Xeon 3500 */\n0x000106A1,\n/* 320836.pdf - AAJ124 - C0 - i7-900 Desktop Extreme and i7-900 Desktop */\n0x000106A4,\n /* 321333.pdf - AAM126 - D0 - Xeon 3500 */\n /* 321324.pdf - AAK139 - D0 - Xeon 5500 */\n /* 320836.pdf - AAJ124 - D0 - i7-900 Extreme and i7-900 Desktop */\n0x000106A5,\n};\n\nstatic inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool cpu_has_vmx_preemption_timer(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline bool cpu_has_vmx_posted_intr(void)\n{\n\treturn IS_ENABLED(CONFIG_X86_LOCAL_APIC) &&\n\t\tvmcs_config.pin_based_exec_ctrl & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_EPT;\n}\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_basic_inout(void)\n{\n\treturn\t(((u64)vmcs_config.basic_cap << 32) & VMX_BASIC_INOUT);\n}\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_shadow_vmcs(void)\n{\n\tu64 vmx_msr;\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t/* check if the cpu supports writing r/o exit information fields */\n\tif (!(vmx_msr & MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS))\n\t\treturn false;\n\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}\n\nstatic inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}\n\nstatic inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}\n\nstatic inline bool nested_cpu_has_xsaves(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES) &&\n\t\tvmx_xsaves_supported();\n}\n\nstatic inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}\n\nstatic inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);\n}\n\nstatic inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);\n}\n\nstatic inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}\n\nstatic inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}\n\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification);\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification);\n\nstatic int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n\nstatic inline void __invept(int ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tasm volatile (__ex(ASM_VMX_INVEPT)\n\t\t\t/* CF==1 or ZF==1 --> rc = -1 */\n\t\t\t\"; ja 1f ; ud2 ; 1:\\n\"\n\t\t\t: : \"a\" (&operand), \"c\" (ext) : \"cc\", \"memory\");\n}\n\nstatic struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}\n\nstatic void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMCLEAR_RAX) \"; setna %0\"\n\t\t      : \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t      : \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmclear fail: %p/%llx\\n\",\n\t\t       vmcs, phys_addr);\n}\n\nstatic inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)\n{\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nstatic void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMPTRLD_RAX) \"; setna %0\"\n\t\t\t: \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t\t: \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmptrld %p/%llx failed\\n\",\n\t\t       vmcs, phys_addr);\n}\n\n#ifdef CONFIG_KEXEC_CORE\n/*\n * This bitmap is used to indicate whether the vmclear\n * operation is enabled on all cpus. All disabled by\n * default.\n */\nstatic cpumask_t crash_vmclear_enabled_bitmap = CPU_MASK_NONE;\n\nstatic inline void crash_enable_local_vmclear(int cpu)\n{\n\tcpumask_set_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline void crash_disable_local_vmclear(int cpu)\n{\n\tcpumask_clear_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic inline int crash_local_vmclear_enabled(int cpu)\n{\n\treturn cpumask_test_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}\n\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tif (!crash_local_vmclear_enabled(cpu))\n\t\treturn;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#else\nstatic inline void crash_enable_local_vmclear(int cpu) { }\nstatic inline void crash_disable_local_vmclear(int cpu) { }\n#endif /* CONFIG_KEXEC_CORE */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\tcrash_disable_local_vmclear(cpu);\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * we should ensure updating loaded_vmcs->loaded_vmcss_on_cpu_link\n\t * is before setting loaded_vmcs->vcpu to -1 which is done in\n\t * loaded_vmcs_init. Otherwise, other cpu can see vcpu = -1 fist\n\t * then adds the vmcs into percpu list before it is deleted.\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs_init(loaded_vmcs);\n\tcrash_enable_local_vmclear(cpu);\n}\n\nstatic void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}\n\nstatic inline void ept_sync_global(void)\n{\n\tif (cpu_has_vmx_invept_global())\n\t\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (enable_ept) {\n\t\tif (cpu_has_vmx_invept_context())\n\t\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\t\telse\n\t\t\tept_sync_global();\n\t}\n}\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, \"%0\")\n\t\t      : \"=a\"(value) : \"d\"(field) : \"cc\");\n\treturn value;\n}\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tprintk(KERN_ERR \"vmwrite error: reg %lx value %lx (err %d)\\n\",\n\t       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n\tdump_stack();\n}\n\nstatic __always_inline void __vmcs_writel(unsigned long field, unsigned long value)\n{\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMWRITE_RAX_RDX) \"; setna %0\"\n\t\t       : \"=q\"(error) : \"a\"(value), \"d\"(field) : \"cc\");\n\tif (unlikely(error))\n\t\tvmwrite_error(field, value);\n}\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\tasm volatile (\"\");\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}\n\nstatic inline void vm_entry_controls_reset_shadow(struct vcpu_vmx *vmx)\n{\n\tvmx->vm_entry_controls_shadow = vmcs_read32(VM_ENTRY_CONTROLS);\n}\n\nstatic inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}\n\nstatic inline void vm_entry_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_entry_controls_shadow != val)\n\t\tvm_entry_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_entry_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_entry_controls_shadow;\n}\n\n\nstatic inline void vm_entry_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) | val);\n}\n\nstatic inline void vm_entry_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) & ~val);\n}\n\nstatic inline void vm_exit_controls_reset_shadow(struct vcpu_vmx *vmx)\n{\n\tvmx->vm_exit_controls_shadow = vmcs_read32(VM_EXIT_CONTROLS);\n}\n\nstatic inline void vm_exit_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_EXIT_CONTROLS, val);\n\tvmx->vm_exit_controls_shadow = val;\n}\n\nstatic inline void vm_exit_controls_set(struct vcpu_vmx *vmx, u32 val)\n{\n\tif (vmx->vm_exit_controls_shadow != val)\n\t\tvm_exit_controls_init(vmx, val);\n}\n\nstatic inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}\n\n\nstatic inline void vm_exit_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) | val);\n}\n\nstatic inline void vm_exit_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) & ~val);\n}\n\nstatic void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!(vmx->vcpu.arch.regs_avail & (1 << VCPU_EXREG_SEGMENTS))) {\n\t\tvmx->vcpu.arch.regs_avail |= (1 << VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nstatic void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); /* bypass_guest_pf = 0 */\n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == m->nr)\n\t\treturn;\n\t--m->nr;\n\tm->guest[i] = m->guest[m->nr];\n\tm->host[i] = m->host[m->nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val)\n{\n\tunsigned i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\tfor (i = 0; i < m->nr; ++i)\n\t\tif (m->guest[i].index == msr)\n\t\t\tbreak;\n\n\tif (i == NR_AUTOLOAD_MSRS) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t} else if (i == m->nr) {\n\t\t++m->nr;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->nr);\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->nr);\n\t}\n\n\tm->guest[i].index = msr;\n\tm->guest[i].value = guest_val;\n\tm->host[i].index = msr;\n\tm->host[i].value = host_val;\n}\n\nstatic void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\tif (!enable_ept) {\n\t\t/*\n\t\t * NX is needed to handle CR0.WP=1, CR4.SMEP=1.  Testing\n\t\t * host CPUID is more efficient than testing guest CPUID\n\t\t * or CR4.  Host SMEP is anyway a requirement for guest SMEP.\n\t\t */\n\t\tif (boot_cpu_has(X86_FEATURE_SMEP))\n\t\t\tguest_efer |= EFER_NX;\n\t\telse if (!(guest_efer & EFER_NX))\n\t\t\tignore_bits |= EFER_NX;\n\t}\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer);\n\t\treturn false;\n\t} else {\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *d;\n\tunsigned long table_base;\n\tunsigned long v;\n\n\tif (!(selector & ~3))\n\t\treturn 0;\n\n\ttable_base = gdt->address;\n\n\tif (selector & 4) {           /* from ldt */\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~3))\n\t\t\treturn 0;\n\n\t\ttable_base = segment_base(ldt_selector);\n\t}\n\td = (struct desc_struct *)(table_base + (selector & ~7));\n\tv = get_desc_base(d);\n#ifdef CONFIG_X86_64\n       if (d->s == 0 && (d->type == 2 || d->type == 9 || d->type == 11))\n               v |= ((unsigned long)((struct ldttss_desc64 *)d)->base3) << 32;\n#endif\n\treturn v;\n}\n\nstatic inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n\nstatic void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (boot_cpu_has(X86_FEATURE_MPX))\n\t\trdmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n\nstatic void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu))\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(vmx->host_state.gs_sel);\n#else\n\t\tloadsegment(gs, vmx->host_state.gs_sel);\n#endif\n\t}\n\tif (vmx->host_state.fs_reload_needed)\n\t\tloadsegment(fs, vmx->host_state.fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(vmx->host_state.ds_sel | vmx->host_state.es_sel)) {\n\t\tloadsegment(ds, vmx->host_state.ds_sel);\n\t\tloadsegment(es, vmx->host_state.es_sel);\n\t}\n#endif\n\treload_tss();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tif (vmx->host_state.msr_host_bndcfgs)\n\t\twrmsrl(MSR_IA32_BNDCFGS, vmx->host_state.msr_host_bndcfgs);\n\tload_gdt(this_cpu_ptr(&host_gdt));\n}\n\nstatic void vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\t__vmx_load_host_state(vmx);\n\tpreempt_enable();\n}\n\nstatic void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\t/*\n\t\t * If 'nv' field is POSTED_INTR_WAKEUP_VECTOR, there\n\t\t * are two possible cases:\n\t\t * 1. After running 'pre_block', context switch\n\t\t *    happened. For this case, 'sn' was set in\n\t\t *    vmx_vcpu_put(), so we need to clear it here.\n\t\t * 2. After running 'pre_block', we were blocked,\n\t\t *    and woken up by some other guy. For this case,\n\t\t *    we don't need to do anything, 'pi_post_block'\n\t\t *    will do everything for us. However, we cannot\n\t\t *    check whether it is case #1 or case #2 here\n\t\t *    (maybe, not needed), so we also clear sn here,\n\t\t *    I think it is not a big deal.\n\t\t */\n\t\tif (pi_desc->nv != POSTED_INTR_WAKEUP_VECTOR) {\n\t\t\tif (vcpu->cpu != cpu) {\n\t\t\t\tdest = cpu_physical_id(cpu);\n\n\t\t\t\tif (x2apic_enabled())\n\t\t\t\t\tnew.ndst = dest;\n\t\t\t\telse\n\t\t\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\t\t\t}\n\n\t\t\t/* set 'NV' to 'notification vector' */\n\t\t\tnew.nv = POSTED_INTR_VECTOR;\n\t\t}\n\n\t\t/* Allow posting non-urgent interrupts */\n\t\tnew.sn = 0;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n}\n\nstatic void decache_tsc_multiplier(struct vcpu_vmx *vmx)\n{\n\tvmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;\n\tvmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(phys_addr);\n\telse if (!already_loaded)\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\n\tif (!already_loaded) {\n\t\tlocal_irq_disable();\n\t\tcrash_disable_local_vmclear(cpu);\n\n\t\t/*\n\t\t * Read loaded_vmcs->cpu should be before fetching\n\t\t * loaded_vmcs->loaded_vmcss_on_cpu_link.\n\t\t * See the comments in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tcrash_enable_local_vmclear(cpu);\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t}\n\n\tif (!already_loaded) {\n\t\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE, kvm_read_tr_base()); /* 22.2.4 */\n\t\tvmcs_writel(HOST_GDTR_BASE, gdt->address);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\tvmx->host_pkru = read_pkru();\n}\n\nstatic void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\t__vmx_load_host_state(to_vmx(vcpu));\n\tif (!vmm_exclusive) {\n\t\t__loaded_vmcs_clear(to_vmx(vcpu)->loaded_vmcs);\n\t\tvcpu->cpu = -1;\n\t\tkvm_cpu_vmxoff();\n\t}\n}\n\nstatic void vmx_fpu_activate(struct kvm_vcpu *vcpu)\n{\n\tulong cr0;\n\n\tif (vcpu->fpu_active)\n\t\treturn;\n\tvcpu->fpu_active = 1;\n\tcr0 = vmcs_readl(GUEST_CR0);\n\tcr0 &= ~(X86_CR0_TS | X86_CR0_MP);\n\tcr0 |= kvm_read_cr0_bits(vcpu, X86_CR0_TS | X86_CR0_MP);\n\tvmcs_writel(GUEST_CR0, cr0);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.cr0_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\n\n/*\n * Return the cr0 value that a nested guest would read. This is a combination\n * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by\n * its hypervisor (cr0_read_shadow).\n */\nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n\nstatic void vmx_fpu_deactivate(struct kvm_vcpu *vcpu)\n{\n\t/* Note that there is no vcpu->fpu_active = 0 here. The caller must\n\t * set this *before* calling this function.\n\t */\n\tvmx_decache_cr0_guest_bits(vcpu);\n\tvmcs_set_bits(GUEST_CR0, X86_CR0_TS | X86_CR0_MP);\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = 0;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1's specified read shadow might not contain the TS bit,\n\t\t * so now that we turned on shadowing of this bit, we need to\n\t\t * set this bit of the shadow. Like in nested_vmx_run we need\n\t\t * nested_read_cr0(vmcs12), but vmcs12->guest_cr0 is not yet\n\t\t * up-to-date here because we just decached cr0.TS (and we'll\n\t\t * only update vmcs12->guest_cr0 on nested exit).\n\t\t */\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tvmcs12->guest_cr0 = (vmcs12->guest_cr0 & ~X86_CR0_TS) |\n\t\t\t(vcpu->arch.cr0 & X86_CR0_TS);\n\t\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\t} else\n\t\tvmcs_writel(CR0_READ_SHADOW, vcpu->arch.cr0);\n}\n\nstatic unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags, save_rflags;\n\n\tif (!test_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = to_vmx(vcpu)->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tto_vmx(vcpu)->rflags = rflags;\n\t}\n\treturn to_vmx(vcpu)->rflags;\n}\n\nstatic void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__set_bit(VCPU_EXREG_RFLAGS, (ulong *)&vcpu->arch.regs_avail);\n\tto_vmx(vcpu)->rflags = rflags;\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tto_vmx(vcpu)->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n}\n\nstatic u32 vmx_get_pkru(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->guest_pkru;\n}\n\nstatic u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nstatic void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}\n\n/*\n * KVM wants to inject page-faults which it got to the guest. This function\n * checks whether in a nested guest, we need to inject them to L1 or L2.\n */\nstatic int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (!(vmcs12->exception_bitmap & (1u << nr)))\n\t\treturn 0;\n\n\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}\n\nstatic bool vmx_invpcid_supported(void)\n{\n\treturn cpu_has_vmx_invpcid() && enable_ept;\n}\n\n/*\n * Swap MSR entry in host/guest MSR entry array.\n */\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}\n\nstatic void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = to_vmx(vcpu)->nested.msr_bitmap;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu)) {\n\t\t\tif (is_long_mode(vcpu))\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic_apicv;\n\t\t\telse\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic_apicv;\n\t\t} else {\n\t\t\tif (is_long_mode(vcpu))\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\t\telse\n\t\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t\t}\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n\n/*\n * Set up the vmcs to automatically save and restore system\n * msrs.  Don't touch the 64-bit msrs if the guest is in legacy\n * mode, as fiddling with msrs is very expensive.\n */\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && guest_cpuid_has_rdtscp(&vmx->vcpu))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\t/*\n\t\t * MSR_STAR is only needed on long mode guests, and only\n\t\t * if efer.sce is enabled.\n\t\t */\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}\n\n/*\n * reads and returns guest's timestamp counter \"register\"\n * guest_tsc = (host_tsc * tsc multiplier) >> 48 + tsc_offset\n * -- Intel TSC Scaling for Virtualization White Paper, sec 1.3\n */\nstatic u64 guest_read_tsc(struct kvm_vcpu *vcpu)\n{\n\tu64 host_tsc, tsc_offset;\n\n\thost_tsc = rdtsc();\n\ttsc_offset = vmcs_read64(TSC_OFFSET);\n\treturn kvm_scale_tsc(vcpu, host_tsc) + tsc_offset;\n}\n\n/*\n * writes 'offset' into guest's timestamp counter offset register\n */\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t\t * to the spec, this should set L1's TSC; The offset that L1\n\t\t * set for L2 remains unchanged, and still needs to be added\n\t\t * to the newly set TSC to get L2's TSC.\n\t\t */\n\t\tstruct vmcs12 *vmcs12;\n\t\t/* recalculate vmcs02.TSC_OFFSET: */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tvmcs_write64(TSC_OFFSET, offset +\n\t\t\t(nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETING) ?\n\t\t\t vmcs12->tsc_offset : 0));\n\t} else {\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   vmcs_read64(TSC_OFFSET), offset);\n\t\tvmcs_write64(TSC_OFFSET, offset);\n\t}\n}\n\nstatic bool guest_cpuid_has_vmx(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & (1 << (X86_FEATURE_VMX & 31)));\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nstatic inline bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has_vmx(vcpu);\n}\n\n/*\n * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be\n * returned for the various VMX controls MSRs when nested VMX is enabled.\n * The same values should also be used to verify that vmcs12 control fields are\n * valid during nested entry from L1 to L2.\n * Each of these control msrs has a low and high 32-bit half: A low bit is on\n * if the corresponding bit in the (32-bit) control field *must* be on, and a\n * bit in the high half is on if the corresponding bit in the control field\n * may be on. See also vmx_control_verify().\n */\nstatic void nested_vmx_setup_ctls_msrs(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\tvmx->nested.nested_vmx_pinbased_ctls_high);\n\tvmx->nested.nested_vmx_pinbased_ctls_low |=\n\t\tPIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_pinbased_ctls_high &=\n\t\tPIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING |\n\t\tPIN_BASED_VIRTUAL_NMIS;\n\tvmx->nested.nested_vmx_pinbased_ctls_high |=\n\t\tPIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tvmx->nested.nested_vmx_pinbased_ctls_high |=\n\t\t\tPIN_BASED_POSTED_INTR;\n\n\t/* exit controls */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\tvmx->nested.nested_vmx_exit_ctls_high);\n\tvmx->nested.nested_vmx_exit_ctls_low =\n\t\tVM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\n\tvmx->nested.nested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tvmx->nested.nested_vmx_exit_ctls_high |=\n\t\tVM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER | VM_EXIT_ACK_INTR_ON_EXIT;\n\n\tif (kvm_mpx_supported())\n\t\tvmx->nested.nested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* We support free control of debug control saving. */\n\tvmx->nested.nested_vmx_exit_ctls_low &= ~VM_EXIT_SAVE_DEBUG_CONTROLS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\tvmx->nested.nested_vmx_entry_ctls_high);\n\tvmx->nested.nested_vmx_entry_ctls_low =\n\t\tVM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tvmx->nested.nested_vmx_entry_ctls_high |=\n\t\t(VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR | VM_ENTRY_LOAD_IA32_EFER);\n\tif (kvm_mpx_supported())\n\t\tvmx->nested.nested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* We support free control of debug control loading. */\n\tvmx->nested.nested_vmx_entry_ctls_low &= ~VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\tvmx->nested.nested_vmx_procbased_ctls_high);\n\tvmx->nested.nested_vmx_procbased_ctls_low =\n\t\tCPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tvmx->nested.nested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_TRAP_FLAG |\n\t\tCPU_BASED_MONITOR_EXITING | CPU_BASED_RDPMC_EXITING |\n\t\tCPU_BASED_RDTSC_EXITING | CPU_BASED_PAUSE_EXITING |\n\t\tCPU_BASED_TPR_SHADOW | CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tvmx->nested.nested_vmx_procbased_ctls_high |=\n\t\tCPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tCPU_BASED_USE_MSR_BITMAPS;\n\n\t/* We support free control of CR3 access interception. */\n\tvmx->nested.nested_vmx_procbased_ctls_low &=\n\t\t~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\tvmx->nested.nested_vmx_secondary_ctls_high);\n\tvmx->nested.nested_vmx_secondary_ctls_low = 0;\n\tvmx->nested.nested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_RDTSCP |\n\t\tSECONDARY_EXEC_DESC |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\tSECONDARY_EXEC_XSAVES;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\tSECONDARY_EXEC_ENABLE_EPT;\n\t\tvmx->nested.nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tif (cpu_has_vmx_ept_execute_only())\n\t\t\tvmx->nested.nested_vmx_ept_caps |=\n\t\t\t\tVMX_EPT_EXECUTE_ONLY_BIT;\n\t\tvmx->nested.nested_vmx_ept_caps &= vmx_capability.ept;\n\t\tvmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |\n\t\t\tVMX_EPT_EXTENT_CONTEXT_BIT;\n\t} else\n\t\tvmx->nested.nested_vmx_ept_caps = 0;\n\n\t/*\n\t * Old versions of KVM use the single-context version without\n\t * checking for support, so declare that it is supported even\n\t * though it is treated as global context.  The alternative is\n\t * not failing the single-context invvpid, and it is worse.\n\t */\n\tif (enable_vpid)\n\t\tvmx->nested.nested_vmx_vpid_caps = VMX_VPID_INVVPID_BIT |\n\t\t\tVMX_VPID_EXTENT_SUPPORTED_MASK;\n\telse\n\t\tvmx->nested.nested_vmx_vpid_caps = 0;\n\n\tif (enable_unrestricted_guest)\n\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC,\n\t\tvmx->nested.nested_vmx_misc_low,\n\t\tvmx->nested.nested_vmx_misc_high);\n\tvmx->nested.nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tvmx->nested.nested_vmx_misc_low |=\n\t\tVMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tvmx->nested.nested_vmx_misc_high = 0;\n\n\t/*\n\t * This MSR reports some information about VMX support. We\n\t * should return information about the VMX we emulate for the\n\t * guest, and the VMCS structure we give it - not about the\n\t * VMX support of the underlying hardware.\n\t */\n\tvmx->nested.nested_vmx_basic =\n\t\tVMCS12_REVISION |\n\t\tVMX_BASIC_TRUE_CTLS |\n\t\t((u64)VMCS12_SIZE << VMX_BASIC_VMCS_SIZE_SHIFT) |\n\t\t(VMX_BASIC_MEM_TYPE_WB << VMX_BASIC_MEM_TYPE_SHIFT);\n\n\tif (cpu_has_vmx_basic_inout())\n\t\tvmx->nested.nested_vmx_basic |= VMX_BASIC_INOUT;\n\n\t/*\n\t * These MSRs specify bits which the guest must keep fixed on\n\t * while L1 is in VMXON mode (in L1's root mode, or running an L2).\n\t * We picked the standard core2 setting.\n\t */\n#define VMXON_CR0_ALWAYSON     (X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)\n#define VMXON_CR4_ALWAYSON     X86_CR4_VMXE\n\tvmx->nested.nested_vmx_cr0_fixed0 = VMXON_CR0_ALWAYSON;\n\tvmx->nested.nested_vmx_cr4_fixed0 = VMXON_CR4_ALWAYSON;\n\n\t/* These MSRs specify bits which the guest must keep fixed off. */\n\trdmsrl(MSR_IA32_VMX_CR0_FIXED1, vmx->nested.nested_vmx_cr0_fixed1);\n\trdmsrl(MSR_IA32_VMX_CR4_FIXED1, vmx->nested.nested_vmx_cr4_fixed1);\n\n\t/* highest index: VMX_PREEMPTION_TIMER_VALUE */\n\tvmx->nested.nested_vmx_vmcs_enum = 0x2e;\n}\n\n/*\n * if fixed0[i] == 1: val[i] must be 1\n * if fixed1[i] == 0: val[i] must be 0\n */\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}\n\nstatic inline bool vmx_control_verify(u32 control, u32 low, u32 high)\n{\n\treturn fixed_bits_valid(control, low, high);\n}\n\nstatic inline u64 vmx_control_msr(u32 low, u32 high)\n{\n\treturn low | ((u64)high << 32);\n}\n\nstatic bool is_bitwise_subset(u64 superset, u64 subset, u64 mask)\n{\n\tsuperset &= mask;\n\tsubset &= mask;\n\n\treturn (superset | subset) == superset;\n}\n\nstatic int vmx_restore_vmx_basic(struct vcpu_vmx *vmx, u64 data)\n{\n\tconst u64 feature_and_reserved =\n\t\t/* feature (except bit 48; see below) */\n\t\tBIT_ULL(49) | BIT_ULL(54) | BIT_ULL(55) |\n\t\t/* reserved */\n\t\tBIT_ULL(31) | GENMASK_ULL(47, 45) | GENMASK_ULL(63, 56);\n\tu64 vmx_basic = vmx->nested.nested_vmx_basic;\n\n\tif (!is_bitwise_subset(vmx_basic, data, feature_and_reserved))\n\t\treturn -EINVAL;\n\n\t/*\n\t * KVM does not emulate a version of VMX that constrains physical\n\t * addresses of VMX structures (e.g. VMCS) to 32-bits.\n\t */\n\tif (data & BIT_ULL(48))\n\t\treturn -EINVAL;\n\n\tif (vmx_basic_vmcs_revision_id(vmx_basic) !=\n\t    vmx_basic_vmcs_revision_id(data))\n\t\treturn -EINVAL;\n\n\tif (vmx_basic_vmcs_size(vmx_basic) > vmx_basic_vmcs_size(data))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_basic = data;\n\treturn 0;\n}\n\nstatic int\nvmx_restore_control_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)\n{\n\tu64 supported;\n\tu32 *lowp, *highp;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_pinbased_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_pinbased_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_procbased_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_procbased_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_exit_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_exit_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\tlowp = &vmx->nested.nested_vmx_entry_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_entry_ctls_high;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\tlowp = &vmx->nested.nested_vmx_secondary_ctls_low;\n\t\thighp = &vmx->nested.nested_vmx_secondary_ctls_high;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsupported = vmx_control_msr(*lowp, *highp);\n\n\t/* Check must-be-1 bits are still 1. */\n\tif (!is_bitwise_subset(data, supported, GENMASK_ULL(31, 0)))\n\t\treturn -EINVAL;\n\n\t/* Check must-be-0 bits are still 0. */\n\tif (!is_bitwise_subset(supported, data, GENMASK_ULL(63, 32)))\n\t\treturn -EINVAL;\n\n\t*lowp = data;\n\t*highp = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_vmx_misc(struct vcpu_vmx *vmx, u64 data)\n{\n\tconst u64 feature_and_reserved_bits =\n\t\t/* feature */\n\t\tBIT_ULL(5) | GENMASK_ULL(8, 6) | BIT_ULL(14) | BIT_ULL(15) |\n\t\tBIT_ULL(28) | BIT_ULL(29) | BIT_ULL(30) |\n\t\t/* reserved */\n\t\tGENMASK_ULL(13, 9) | BIT_ULL(31);\n\tu64 vmx_misc;\n\n\tvmx_misc = vmx_control_msr(vmx->nested.nested_vmx_misc_low,\n\t\t\t\t   vmx->nested.nested_vmx_misc_high);\n\n\tif (!is_bitwise_subset(vmx_misc, data, feature_and_reserved_bits))\n\t\treturn -EINVAL;\n\n\tif ((vmx->nested.nested_vmx_pinbased_ctls_high &\n\t     PIN_BASED_VMX_PREEMPTION_TIMER) &&\n\t    vmx_misc_preemption_timer_rate(data) !=\n\t    vmx_misc_preemption_timer_rate(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_cr3_count(data) > vmx_misc_cr3_count(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_max_msr(data) > vmx_misc_max_msr(vmx_misc))\n\t\treturn -EINVAL;\n\n\tif (vmx_misc_mseg_revid(data) != vmx_misc_mseg_revid(vmx_misc))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_misc_low = data;\n\tvmx->nested.nested_vmx_misc_high = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_vmx_ept_vpid_cap(struct vcpu_vmx *vmx, u64 data)\n{\n\tu64 vmx_ept_vpid_cap;\n\n\tvmx_ept_vpid_cap = vmx_control_msr(vmx->nested.nested_vmx_ept_caps,\n\t\t\t\t\t   vmx->nested.nested_vmx_vpid_caps);\n\n\t/* Every bit is either reserved or a feature bit. */\n\tif (!is_bitwise_subset(vmx_ept_vpid_cap, data, -1ULL))\n\t\treturn -EINVAL;\n\n\tvmx->nested.nested_vmx_ept_caps = data;\n\tvmx->nested.nested_vmx_vpid_caps = data >> 32;\n\treturn 0;\n}\n\nstatic int vmx_restore_fixed0_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)\n{\n\tu64 *msr;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\tmsr = &vmx->nested.nested_vmx_cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\tmsr = &vmx->nested.nested_vmx_cr4_fixed0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * 1 bits (which indicates bits which \"must-be-1\" during VMX operation)\n\t * must be 1 in the restored value.\n\t */\n\tif (!is_bitwise_subset(data, *msr, -1ULL))\n\t\treturn -EINVAL;\n\n\t*msr = data;\n\treturn 0;\n}\n\n/*\n * Called when userspace is restoring VMX MSRs.\n *\n * Returns 0 on success, non-0 otherwise.\n */\nstatic int vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\treturn vmx_restore_vmx_basic(vmx, data);\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t/*\n\t\t * The \"non-true\" VMX capability MSRs are generated from the\n\t\t * \"true\" MSRs, so we do not support restoring them directly.\n\t\t *\n\t\t * If userspace wants to emulate VMX_BASIC[55]=0, userspace\n\t\t * should restore the \"true\" MSRs with the must-be-1 bits\n\t\t * set according to the SDM Vol 3. A.2 \"RESERVED CONTROLS AND\n\t\t * DEFAULT SETTINGS\".\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\treturn vmx_restore_control_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_MISC:\n\t\treturn vmx_restore_vmx_misc(vmx, data);\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\treturn vmx_restore_fixed0_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t/*\n\t\t * These MSRs are generated based on the vCPU's CPUID, so we\n\t\t * do not support restoring them directly.\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\treturn vmx_restore_vmx_ept_vpid_cap(vmx, data);\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\tvmx->nested.nested_vmx_vmcs_enum = data;\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * The rest of the VMX capability MSRs do not support restore.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n}\n\n/* Returns 0 on success, non-0 otherwise. */\nstatic int vmx_get_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = vmx->nested.nested_vmx_basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\t\tvmx->nested.nested_vmx_pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\t\tvmx->nested.nested_vmx_procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\t\tvmx->nested.nested_vmx_exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\t\tvmx->nested.nested_vmx_entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_misc_low,\n\t\t\tvmx->nested.nested_vmx_misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = vmx->nested.nested_vmx_cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = vmx->nested.nested_vmx_cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = vmx->nested.nested_vmx_cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = vmx->nested.nested_vmx_cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = vmx->nested.nested_vmx_vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\t\tvmx->nested.nested_vmx_secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = vmx->nested.nested_vmx_ept_caps |\n\t\t\t((u64)vmx->nested.nested_vmx_vpid_caps << 32);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct shared_msr_entry *msr;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(to_vmx(vcpu));\n\t\tmsr_info->data = to_vmx(vcpu)->msr_guest_kernel_gs_base;\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = guest_read_tsc(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t      FEATURE_CONTROL_LMCE))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tmsr_info->data = to_vmx(vcpu)->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_XSS:\n\t\tif (!vmx_xsaves_supported())\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!guest_cpuid_has_rdtscp(vcpu) && !msr_info->host_initiated)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(to_vmx(vcpu), msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_load_host_state(vmx);\n\t\tvmx->msr_guest_kernel_gs_base = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported())\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\t\treturn 1;\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEATURE_CONTROL_LMCE)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEATURE_CONTROL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEATURE_CONTROL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_XSS:\n\t\tif (!vmx_xsaves_supported())\n\t\t\treturn 1;\n\t\t/*\n\t\t * The only supported bit as of Skylake is bit 8, but\n\t\t * it is not supported on KVM.\n\t\t */\n\t\tif (data != 0)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tif (vcpu->arch.ia32_xss != host_xss)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_IA32_XSS,\n\t\t\t\tvcpu->arch.ia32_xss, host_xss);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_IA32_XSS);\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!guest_cpuid_has_rdtscp(vcpu) && !msr_info->host_initiated)\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\t/* Otherwise falls through */\n\tdefault:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tu64 old_msr_data = msr->data;\n\t\t\tmsr->data = data;\n\t\t\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\t\t\tpreempt_disable();\n\t\t\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t\t\t msr->mask);\n\t\t\t\tpreempt_enable();\n\t\t\t\tif (ret)\n\t\t\t\t\tmsr->data = old_msr_data;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\tu64 msr;\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, msr);\n\tif (msr & FEATURE_CONTROL_LOCKED) {\n\t\t/* launched w/ TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& tboot_enabled())\n\t\t\treturn 1;\n\t\t/* launched w/o TXT and VMX only enabled w/ TXT */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n\t\t\t&& !tboot_enabled()) {\n\t\t\tprintk(KERN_WARNING \"kvm: disable TXT in the BIOS or \"\n\t\t\t\t\"activate TXT before enabling KVM\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* launched w/o TXT and VMX disabled */\n\t\tif (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n\t\t\t&& !tboot_enabled())\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void kvm_cpu_vmxon(u64 addr)\n{\n\tintel_pt_handle_vmx(1);\n\n\tasm volatile (ASM_VMX_VMXON_RAX\n\t\t\t: : \"a\"(&addr), \"m\"(addr)\n\t\t\t: \"memory\", \"cc\");\n}\n\nstatic int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tINIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));\n\tspin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\n\t/*\n\t * Now we can enable the vmclear operation in kdump\n\t * since the loaded_vmcss_on_cpu list on this cpu\n\t * has been initialized.\n\t *\n\t * Though the cpu is not in VMX operation now, there\n\t * is no problem to enable the vmclear operation\n\t * for the loaded_vmcss_on_cpu list is empty!\n\t */\n\tcrash_enable_local_vmclear(cpu);\n\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\tcr4_set_bits(X86_CR4_VMXE);\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\n\n/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()\n * tricks.\n */\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(ASM_VMX_VMXOFF) : : : \"cc\");\n\n\tintel_pt_handle_vmx(0);\n}\n\nstatic void hardware_disable(void)\n{\n\tif (vmm_exclusive) {\n\t\tvmclear_local_loaded_vmcss();\n\t\tkvm_cpu_vmxoff();\n\t}\n\tcr4_clear_bits(X86_CR4_VMXE);\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init bool allow_1_setting(u32 msr, u32 ctl)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\treturn vmx_msr_high & ctl;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_USE_IO_BITMAPS |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\t\tSECONDARY_EXEC_XSAVES |\n\t\t\tSECONDARY_EXEC_ENABLE_PML |\n\t\t\tSECONDARY_EXEC_TSC_SCALING;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t\trdmsr(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t      vmx_capability.ept, vmx_capability.vpid);\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_SAVE_IA32_PAT | VM_EXIT_LOAD_IA32_PAT |\n\t\tVM_EXIT_CLEAR_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |\n\t\t PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (cpu_has_broken_vmx_preemption_timer())\n\t\t_pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_BNDCFGS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->order = get_order(vmcs_conf->size);\n\tvmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n\tcpu_has_load_ia32_efer =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_EFER)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_EFER);\n\n\tcpu_has_load_perf_global_ctrl =\n\t\tallow_1_setting(MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\t&& allow_1_setting(MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t   VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\n\t/*\n\t * Some cpus support VM_ENTRY_(LOAD|SAVE)_IA32_PERF_GLOBAL_CTRL\n\t * but due to errata below it can't be used. Workaround is to use\n\t * msr load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t *\n\t * VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]\n\t *\n\t * AAK155             (model 26)\n\t * AAP115             (model 30)\n\t * AAT100             (model 37)\n\t * BC86,AAY89,BD102   (model 44)\n\t * BA97               (model 46)\n\t *\n\t */\n\tif (cpu_has_load_perf_global_ctrl && boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26:\n\t\tcase 30:\n\t\tcase 37:\n\t\tcase 44:\n\t\tcase 46:\n\t\t\tcpu_has_load_perf_global_ctrl = false;\n\t\t\tprintk_once(KERN_WARNING\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\trdmsrl(MSR_IA32_XSS, host_xss);\n\n\treturn 0;\n}\n\nstatic struct vmcs *alloc_vmcs_cpu(int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, GFP_KERNEL, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\tvmcs->revision_id = vmcs_config.revision_id; /* vmcs revision id */\n\treturn vmcs;\n}\n\nstatic struct vmcs *alloc_vmcs(void)\n{\n\treturn alloc_vmcs_cpu(raw_smp_processor_id());\n}\n\nstatic void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nstatic void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\n\t/* No checks for read only fields yet */\n\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!kvm_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\n\t/* shadowed fields guest access without vmexit */\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(cpu);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_write32(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!vcpu->kvm->arch.tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, vcpu->kvm->arch.tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\t/*\n\t * Force kernel_gs_base reloading before EFER changes, as control\n\t * of this msr depends on is_long_mode().\n\t */\n\tvmx_load_host_state(to_vmx(vcpu));\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic inline void __vmx_flush_tlb(struct kvm_vcpu *vcpu, int vpid)\n{\n\tvpid_sync_context(vpid);\n\tif (enable_ept) {\n\t\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\t\treturn;\n\t\tept_sync_context(construct_eptp(vcpu->arch.mmu.root_hpa));\n\t}\n}\n\nstatic void vmx_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\t__vmx_flush_tlb(vcpu, to_vmx(vcpu)->vpid);\n}\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}\n\nstatic void vmx_decache_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (enable_ept && is_paging(vcpu))\n\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n}\n\nstatic void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_dirty))\n\t\treturn;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\n}\n\nstatic bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.nested_vmx_secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.nested_vmx_cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.nested_vmx_cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\n/* No difference in the restrictions on guest and host CR4 in VMX operation. */\n#define nested_guest_cr4_valid\tnested_cr4_valid\n#define nested_host_cr4_valid\tnested_cr4_valid\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tvmx_decache_cr3(vcpu);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) |\n\t\t\t     (CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t      CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t     vmcs_read32(CPU_BASED_VM_EXEC_CONTROL) &\n\t\t\t     ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t       CPU_BASED_CR3_STORE_EXITING));\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}\n\nstatic void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_GUEST_CR0_MASK);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tif (!vcpu->fpu_active)\n\t\thw_cr0 |= X86_CR0_TS | X86_CR0_MP;\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic u64 construct_eptp(unsigned long root_hpa)\n{\n\tu64 eptp;\n\n\t/* TODO write the value reading from MSR */\n\teptp = VMX_EPT_DEFAULT_MT |\n\t\tVMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT;\n\tif (enable_ept_ad_bits)\n\t\teptp |= VMX_EPT_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}\n\nstatic void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (is_paging(vcpu) || is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = vcpu->kvm->arch.ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\nstatic int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4 =\n\t\t(cr4_read_shadow() & X86_CR4_MCE) |\n\t\t(cr4 & ~X86_CR4_MCE) |\n\t\t(to_vmx(vcpu)->rmode.vm86_active ?\n\t\t KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\tif (enable_ept) {\n\t\tif (!is_paging(vcpu)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t}\n\t}\n\n\tif (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}\n\nstatic void vmx_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nstatic int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = kvm->arch.tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tint i, idx, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\tif (!enable_ept)\n\t\treturn 0;\n\n\t/* Protect kvm->arch.ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm->arch.ept_identity_pagetable_done))\n\t\tgoto out2;\n\n\tidentity_map_pfn = kvm->arch.ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = alloc_identity_pagetable(kvm);\n\tif (r < 0)\n\t\tgoto out2;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm->arch.ept_identity_pagetable_done = true;\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\nout2:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic int alloc_identity_pagetable(struct kvm *kvm)\n{\n\t/* Called with kvm->slots_lock held. */\n\n\tint r = 0;\n\n\tBUG_ON(kvm->arch.ept_identity_pagetable_done);\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm->arch.ept_identity_map_addr, PAGE_SIZE);\n\n\treturn r;\n}\n\nstatic int allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}\n\nstatic void free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\n#define MSR_TYPE_R\t1\n#define MSR_TYPE_W\t2\nstatic void __vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\tu32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n\n/*\n * If a msr is allowed by L0, we should check whether it is allowed by L1.\n * The corresponding bit will be cleared unless both of L0 and L1 allow it.\n */\nstatic void nested_vmx_disable_intercept_for_msr(unsigned long *msr_bitmap_l1,\n\t\t\t\t\t       unsigned long *msr_bitmap_nested,\n\t\t\t\t\t       u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap()) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x000 / f))\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x800 / f))\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0x400 / f))\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W &&\n\t\t   !test_bit(msr, msr_bitmap_l1 + 0xc00 / f))\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap_nested + 0xc00 / f);\n\n\t}\n}\n\nstatic void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)\n{\n\tif (!longmode_only)\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n}\n\nstatic void vmx_disable_intercept_msr_x2apic(u32 msr, int type, bool apicv_active)\n{\n\tif (apicv_active) {\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv,\n\t\t\t\tmsr, type);\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv,\n\t\t\t\tmsr, type);\n\t} else {\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\t\tmsr, type);\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\t\tmsr, type);\n\t}\n}\n\nstatic bool vmx_get_enable_apicv(void)\n{\n\treturn enable_apicv;\n}\n\nstatic int vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tvoid *vapic_page;\n\tu16 status;\n\n\tif (vmx->nested.pi_desc &&\n\t    vmx->nested.pi_pending) {\n\t\tvmx->nested.pi_pending = false;\n\t\tif (!pi_test_and_clear_on(vmx->nested.pi_desc))\n\t\t\treturn 0;\n\n\t\tmax_irr = find_last_bit(\n\t\t\t(unsigned long *)vmx->nested.pi_desc->pir, 256);\n\n\t\tif (max_irr == 256)\n\t\t\treturn 0;\n\n\t\tvapic_page = kmap(vmx->nested.virtual_apic_page);\n\t\tif (!vapic_page) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t__kvm_apic_update_irr(vmx->nested.pi_desc->pir, vapic_page);\n\t\tkunmap(vmx->nested.virtual_apic_page);\n\n\t\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\t\tif ((u8)max_irr > ((u8)status & 0xff)) {\n\t\t\tstatus &= ~0xff;\n\t\t\tstatus |= (u8)max_irr;\n\t\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_SMP\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t\t/*\n\t\t * Currently, we don't support urgent interrupt,\n\t\t * all interrupts are recognized as non-urgent\n\t\t * interrupt, so we cannot post interrupts when\n\t\t * 'SN' is set.\n\t\t *\n\t\t * If the vcpu is in guest mode, it means it is\n\t\t * running instead of being scheduled out and\n\t\t * waiting in the run queue, and that's the only\n\t\t * case when 'SN' is set currently, warning if\n\t\t * 'SN' is set.\n\t\t */\n\t\tWARN_ON_ONCE(pi_test_sn(&vmx->pi_desc));\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu),\n\t\t\t\tPOSTED_INTR_VECTOR);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/* the PIR and ON have been set by L1. */\n\t\tkvm_vcpu_trigger_posted_interrupt(vcpu);\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn;\n\n\tr = pi_test_and_set_on(&vmx->pi_desc);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (r || !kvm_vcpu_trigger_posted_interrupt(vcpu))\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!pi_test_on(&vmx->pi_desc))\n\t\treturn;\n\n\tpi_clear_on(&vmx->pi_desc);\n\t/*\n\t * IOMMU can write to PIR.ON, so the barrier matters even on UP.\n\t * But on x86 this is just a compiler barrier anyway.\n\t */\n\tsmp_mb__after_atomic();\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nstatic void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr0, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}\n\nstatic void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\t/* Enable the preemption timer dynamically */\n\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\treturn pin_based_exec_ctrl;\n}\n\nstatic void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\treturn exec_control;\n}\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\tif (!cpu_need_virtualize_apic_accesses(&vmx->vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t\t/* Enable INVPCID for non-ept guests may cause performance regression. */\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (!ple_gap)\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\treturn exec_control;\n}\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n\n#define VMX_XSS_EXIT_BITMAP 0\n/*\n * Sets up the vmcs for emulated real mode.\n */\nstatic int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tvmx->hv_deadline_tsc = -1;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tASSERT(vmx->pml_pg);\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\tu64 cr0;\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx->soft_vnmi_blocked = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tkvm_set_cr8(vcpu, 0);\n\n\tif (!init_event) {\n\t\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t     MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(vcpu))\n\t\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\t\tapic_base_msr.host_initiated = true;\n\t\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\t}\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tif (!init_event) {\n\t\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\t}\n\n\tvmcs_writel(GUEST_RFLAGS, 0x02);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow() && !init_event) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vcpu->arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\tmemset(&vmx->pi_desc, 0, sizeof(struct pi_desc));\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tcr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx->vcpu.arch.cr0 = cr0;\n\tvmx_set_cr0(vcpu, cr0); /* enter rmode */\n\tvmx_set_cr4(vcpu, 0);\n\tvmx_set_efer(vcpu, 0);\n\tvmx_fpu_activate(vcpu);\n\tupdate_exception_bitmap(vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n}\n\n/*\n * In nested virtualization, check if L1 asked to exit on external interrupts.\n * For most existing hypervisors, this will always return true.\n */\nstatic bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}\n\n/*\n * In nested virtualization, check if L1 has set\n * VM_EXIT_ACK_INTR_ON_EXIT\n */\nstatic bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->vm_exit_controls &\n\t\tVM_EXIT_ACK_INTR_ON_EXIT;\n}\n\nstatic bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tif (!cpu_has_virtual_nmis() ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu)) {\n\t\tif (!cpu_has_virtual_nmis()) {\n\t\t\t/*\n\t\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t\t * highly unlikely, we can live with the residual risk.\n\t\t\t */\n\t\t\tvmx->soft_vnmi_blocked = 1;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\n\t\t++vcpu->stat.nmi_injections;\n\t\tvmx->nmi_known_unmasked = false;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n\nstatic bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tif (!cpu_has_virtual_nmis())\n\t\treturn to_vmx(vcpu)->soft_vnmi_blocked;\n\tif (to_vmx(vcpu)->nmi_known_unmasked)\n\t\treturn false;\n\treturn vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\t& GUEST_INTR_STATE_NMI;\n}\n\nstatic void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\tif (vmx->soft_vnmi_blocked != masked) {\n\t\t\tvmx->soft_vnmi_blocked = masked;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\n\tret = x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t    PAGE_SIZE * 3);\n\tif (ret)\n\t\treturn ret;\n\tkvm->arch.tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\tbreak;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (emulate_instruction(vcpu, 0) == EMULATE_DONE) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\n/*\n * Trigger machine check on the host. We assume all the MSRs are already set up\n * by the CPU and that we still run on the same CPU as the MCE occurred on.\n * We pass a fake environment to the machine check handler because we want\n * the guest to be always treated like user space, no matter what context\n * it used internally.\n */\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* already handled by vcpu_run */\n\treturn 1;\n}\n\nstatic int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif (is_nmi(intr_info))\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string, ret;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\tin = (exit_qualification & 8) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\t/*\n\t * TODO: we might be squashing a KVM_GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_fast_pio_out(vcpu, size, port) && ret;\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\n/* called to set cr0 as appropriate for clts instruction exit. */\nstatic void handle_clts(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * We get here when L2 did CLTS, and L1 didn't shadow CR0.TS\n\t\t * but we did (!fpu_active). We need to keep GUEST_CR0.TS on,\n\t\t * just pretend it's off (also in arch.cr0 for fpu_activate).\n\t\t */\n\t\tvmcs_writel(CR0_READ_SHADOW,\n\t\t\tvmcs_readl(CR0_READ_SHADOW) & ~X86_CR0_TS);\n\t\tvcpu->arch.cr0 &= ~X86_CR0_TS;\n\t} else\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\thandle_clts(vcpu);\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\tvmcs_clear_bits(CPU_BASED_VM_EXEC_CONTROL,\n\t\t\t\tCPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}\n\nstatic void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tvmcs_set_bits(CPU_BASED_VM_EXEC_CONTROL, CPU_BASED_MOV_DR_EXITING);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_cpuid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_cpuid(vcpu);\n}\n\nstatic int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (vmx_get_msr(vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t/* FIXME: handling of bits 32:63 of rax, rdx */\n\tvcpu->arch.regs[VCPU_REGS_RAX] = msr_info.data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (msr_info.data >> 32) & -1u;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (kvm_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending irq */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int handle_halt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_halt(vcpu);\n}\n\nstatic int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_hypercall(vcpu);\n}\n\nstatic int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_wbinvd(vcpu);\n}\n\nstatic int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\treturn 1;\n}\n\nstatic int handle_xsaves(struct kvm_vcpu *vcpu)\n{\n\tkvm_skip_emulated_instruction(vcpu);\n\tWARN(1, \"this should never happen\\n\");\n\treturn 1;\n}\n\nstatic int handle_xrstors(struct kvm_vcpu *vcpu)\n{\n\tkvm_skip_emulated_instruction(vcpu);\n\tWARN(1, \"this should never happen\\n\");\n\treturn 1;\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tskip_emulated_instruction(vcpu);\n\n\tif (kvm_task_switch(vcpu, tss_selector,\n\t\t\t    type == INTR_TYPE_SOFT_INTR ? idt_index : -1, reason,\n\t\t\t    has_error_code, error_code) == EMULATE_FAIL) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\n\treturn 1;\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu32 error_code;\n\tint gla_validity;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tgla_validity = (exit_qualification >> 7) & 0x3;\n\tif (gla_validity == 0x2) {\n\t\tprintk(KERN_ERR \"EPT: Handling EPT violation failed!\\n\");\n\t\tprintk(KERN_ERR \"EPT: GPA: 0x%lx, GVA: 0x%lx\\n\",\n\t\t\t(long unsigned int)vmcs_read64(GUEST_PHYSICAL_ADDRESS),\n\t\t\tvmcs_readl(GUEST_LINEAR_ADDRESS));\n\t\tprintk(KERN_ERR \"EPT: Exit qualification is 0x%lx\\n\",\n\t\t\t(long unsigned int)exit_qualification);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_VIOLATION;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* it is a read fault? */\n\terror_code = (exit_qualification << 2) & PFERR_USER_MASK;\n\t/* it is a write fault? */\n\terror_code |= exit_qualification & PFERR_WRITE_MASK;\n\t/* It is a fetch fault? */\n\terror_code |= (exit_qualification << 2) & PFERR_FETCH_MASK;\n\t/* ept page table is present? */\n\terror_code |= (exit_qualification & 0x38) != 0;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t gpa;\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tret = handle_mmio_page_fault(vcpu, gpa, true);\n\tif (likely(ret == RET_MMIO_PF_EMULATE))\n\t\treturn x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==\n\t\t\t\t\t      EMULATE_DONE;\n\n\tif (unlikely(ret == RET_MMIO_PF_INVALID))\n\t\treturn kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);\n\n\tif (unlikely(ret == RET_MMIO_PF_RETRY))\n\t\treturn 1;\n\n\t/* It is the real ept misconfig */\n\tWARN_ON(1);\n\n\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_MISCONFIG;\n\n\treturn 0;\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\t/* clear pending NMI */\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tenum emulation_result err = EMULATE_DONE;\n\tint ret = 1;\n\tu32 cpu_exec_ctrl;\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tcpu_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tintr_window_requested = cpu_exec_ctrl & CPU_BASED_VIRTUAL_INTR_PENDING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (test_bit(KVM_REQ_EVENT, &vcpu->requests))\n\t\t\treturn 1;\n\n\t\terr = emulate_instruction(vcpu, EMULTYPE_NO_REEXECUTE);\n\n\t\tif (err == EMULATE_USER_EXIT) {\n\t\t\t++vcpu->stat.mmio_exits;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (err != EMULATE_DONE) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\tret = kvm_vcpu_halt(vcpu);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __grow_ple_window(int val)\n{\n\tif (ple_window_grow < 1)\n\t\treturn ple_window;\n\n\tval = min(val, ple_window_actual_max);\n\n\tif (ple_window_grow < ple_window)\n\t\tval *= ple_window_grow;\n\telse\n\t\tval += ple_window_grow;\n\n\treturn val;\n}\n\nstatic int __shrink_ple_window(int val, int modifier, int minimum)\n{\n\tif (modifier < 1)\n\t\treturn ple_window;\n\n\tif (modifier < ple_window)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, minimum);\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old,\n\t                                      ple_window_shrink, ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n\n/*\n * ple_window_actual_max is computed to be one grow_ple_window() below\n * ple_window_max. (See __grow_ple_window for the reason.)\n * This prevents overflows, because ple_window_max is int.\n * ple_window_max effectively rounded down to a multiple of ple_window_grow in\n * this process.\n * ple_window_max is also prevented from setting vmx->ple_window < ple_window.\n */\nstatic void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}\n\n/*\n * Handler for POSTED_INTERRUPT_WAKEUP_VECTOR.\n */\nstatic void wakeup_handler(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint cpu = smp_processor_id();\n\n\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\tlist_for_each_entry(vcpu, &per_cpu(blocked_vcpu_on_cpu, cpu),\n\t\t\tblocked_vcpu_list) {\n\t\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\t\tif (pi_test_on(pi_desc) == 1)\n\t\t\tkvm_vcpu_kick(vcpu);\n\t}\n\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n}\n\nstatic __init int hardware_setup(void)\n{\n\tint r = -ENOMEM, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tfor (i = 0; i < VMX_BITMAP_NR; i++) {\n\t\tvmx_bitmap[i] = (unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx_bitmap[i])\n\t\t\tgoto out;\n\t}\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\n\tif (setup_vmcs_config(&vmcs_config) < 0) {\n\t\tr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic_apicv,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic_apicv,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr++) {\n\t\tif (msr == 0x839 /* TMCCT */)\n\t\t\tcontinue;\n\t\tvmx_disable_intercept_msr_x2apic(msr, MSR_TYPE_R, true);\n\t}\n\n\t/*\n\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t * delivery is not in use.\n\t */\n\tvmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_W, true);\n\tvmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_R | MSR_TYPE_W, false);\n\n\t/* EOI */\n\tvmx_disable_intercept_msr_x2apic(0x80b, MSR_TYPE_W, true);\n\t/* SELF-IPI */\n\tvmx_disable_intercept_msr_x2apic(0x83f, MSR_TYPE_W, true);\n\n\tif (enable_ept) {\n\t\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\t\tcpu_has_vmx_ept_execute_only() ?\n\t\t\t\t      0ull : VMX_EPT_READABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tkvm_x86_ops->slot_enable_log_dirty = NULL;\n\t\tkvm_x86_ops->slot_disable_log_dirty = NULL;\n\t\tkvm_x86_ops->flush_log_dirty = NULL;\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tif (cpu_has_vmx_preemption_timer() && enable_preemption_timer) {\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\t vmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\t} else {\n\t\tkvm_x86_ops->set_hv_timer = NULL;\n\t\tkvm_x86_ops->cancel_hv_timer = NULL;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\treturn alloc_kvm_area();\n\nout:\n\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\n    return r;\n}\n\nstatic __exit void hardware_unsetup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\n\tfree_kvm_area();\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\nstatic int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}\n\n/*\n * To run an L2 guest, we need a vmcs02 based on the L1-specified vmcs12.\n * We could reuse a single VMCS for all the L2 guests, but we also want the\n * option to allocate a separate vmcs02 for each separate loaded vmcs12 - this\n * allows keeping them loaded on the processor, and in the future will allow\n * optimizations where prepare_vmcs02 doesn't need to set all the fields on\n * every entry if they never change.\n * So we keep, in vmx->nested.vmcs02_pool, a cache of size VMCS02_POOL_SIZE\n * (>=0) with a vmcs02 for each recently loaded vmcs12s, most recent first.\n *\n * The following functions allocate and free a vmcs02 in this pool.\n */\n\n/* Get a VMCS from the pool to use as vmcs02 for the current vmcs12. */\nstatic struct loaded_vmcs *nested_get_current_vmcs02(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmx->nested.current_vmptr) {\n\t\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\t\treturn &item->vmcs02;\n\t\t}\n\n\tif (vmx->nested.vmcs02_num >= max(VMCS02_POOL_SIZE, 1)) {\n\t\t/* Recycle the least recently used VMCS. */\n\t\titem = list_last_entry(&vmx->nested.vmcs02_pool,\n\t\t\t\t       struct vmcs02_list, list);\n\t\titem->vmptr = vmx->nested.current_vmptr;\n\t\tlist_move(&item->list, &vmx->nested.vmcs02_pool);\n\t\treturn &item->vmcs02;\n\t}\n\n\t/* Create a new VMCS */\n\titem = kmalloc(sizeof(struct vmcs02_list), GFP_KERNEL);\n\tif (!item)\n\t\treturn NULL;\n\titem->vmcs02.vmcs = alloc_vmcs();\n\titem->vmcs02.shadow_vmcs = NULL;\n\tif (!item->vmcs02.vmcs) {\n\t\tkfree(item);\n\t\treturn NULL;\n\t}\n\tloaded_vmcs_init(&item->vmcs02);\n\titem->vmptr = vmx->nested.current_vmptr;\n\tlist_add(&(item->list), &(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num++;\n\treturn &item->vmcs02;\n}\n\n/* Free and remove from pool a vmcs02 saved for a vmcs12 (if there is one) */\nstatic void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)\n{\n\tstruct vmcs02_list *item;\n\tlist_for_each_entry(item, &vmx->nested.vmcs02_pool, list)\n\t\tif (item->vmptr == vmptr) {\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t\tvmx->nested.vmcs02_num--;\n\t\t\treturn;\n\t\t}\n}\n\n/*\n * Free all VMCSs saved for this vcpu, except the one pointed by\n * vmx->loaded_vmcs. We must be running L1, so vmx->loaded_vmcs\n * must be &vmx->vmcs01.\n */\nstatic void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\n\tWARN_ON(vmx->loaded_vmcs != &vmx->vmcs01);\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\t/*\n\t\t * Something will leak if the above WARN triggers.  Better than\n\t\t * a use-after-free.\n\t\t */\n\t\tif (vmx->loaded_vmcs == &item->vmcs02)\n\t\t\tcontinue;\n\n\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t\tvmx->nested.vmcs02_num--;\n\t}\n}\n\n/*\n * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),\n * set the success or error code of an emulated VMX instruction, as specified\n * by Vol 2B, VMX Instruction Reference, \"Conventions\".\n */\nstatic void nested_vmx_succeed(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));\n}\n\nstatic void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}\n\nstatic void nested_vmx_failValid(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu32 vm_instruction_error)\n{\n\tif (to_vmx(vcpu)->nested.current_vmptr == -1ull) {\n\t\t/*\n\t\t * failValid writes the error number to the current VMCS, which\n\t\t * can't be done there isn't a current VMCS.\n\t\t */\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn;\n\t}\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_ZF);\n\tget_vmcs12(vcpu)->vm_instruction_error = vm_instruction_error;\n\t/*\n\t * We don't need to force a shadow sync because\n\t * VM_INSTRUCTION_ERROR is not shadowed\n\t */\n}\n\nstatic void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)\n{\n\t/* TODO: not to reset guest simply here. */\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\tpr_debug_ratelimited(\"kvm: nested vmx abort, indicator %d\\n\", indicator);\n}\n\nstatic enum hrtimer_restart vmx_preemption_timer_fn(struct hrtimer *timer)\n{\n\tstruct vcpu_vmx *vmx =\n\t\tcontainer_of(timer, struct vcpu_vmx, nested.preemption_timer);\n\n\tvmx->nested.preemption_timer_expired = true;\n\tkvm_make_request(KVM_REQ_EVENT, &vmx->vcpu);\n\tkvm_vcpu_kick(&vmx->vcpu);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * Decode the memory-address operand of a vmx instruction, as recorded on an\n * exit caused by such an instruction (run by a guest hypervisor).\n * On success, returns 0. When the operand is invalid, returns 1 and throws\n * #UD or #GP.\n */\nstatic int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, bool wr, gva_t *ret)\n{\n\tgva_t off;\n\tbool exn;\n\tstruct kvm_segment s;\n\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\toff = exit_qualification; /* holds the displacement */\n\tif (base_is_valid)\n\t\toff += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\toff += kvm_register_read(vcpu, index_reg)<<scaling;\n\tvmx_get_segment(vcpu, &s, seg_reg);\n\t*ret = s.base + off;\n\n\tif (addr_size == 1) /* 32 bit */\n\t\t*ret &= 0xffffffff;\n\n\t/* Checks for #GP/#SS exceptions. */\n\texn = false;\n\tif (is_long_mode(vcpu)) {\n\t\t/* Long mode: #GP(0)/#SS(0) if the memory address is in a\n\t\t * non-canonical form. This is the only check on the memory\n\t\t * destination for long mode!\n\t\t */\n\t\texn = is_noncanonical_address(*ret);\n\t} else if (is_protmode(vcpu)) {\n\t\t/* Protected mode: apply checks for segment validity in the\n\t\t * following order:\n\t\t * - segment type check (#GP(0) may be thrown)\n\t\t * - usability check (#GP(0)/#SS(0))\n\t\t * - limit check (#GP(0)/#SS(0))\n\t\t */\n\t\tif (wr)\n\t\t\t/* #GP(0) if the destination operand is located in a\n\t\t\t * read-only data segment or any code segment.\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 0 || (s.type & 8));\n\t\telse\n\t\t\t/* #GP(0) if the source operand is located in an\n\t\t\t * execute-only code segment\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 8);\n\t\tif (exn) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.\n\t\t */\n\t\texn = (s.unusable != 0);\n\t\t/* Protected mode: #GP(0)/#SS(0) if the memory\n\t\t * operand is outside the segment limit.\n\t\t */\n\t\texn = exn || (off + sizeof(u64) > s.limit);\n\t}\n\tif (exn) {\n\t\tkvm_queue_exception_e(vcpu,\n\t\t\t\t      seg_reg == VCPU_SREG_SS ?\n\t\t\t\t\t\tSS_VECTOR : GP_VECTOR,\n\t\t\t\t      0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function performs the various checks including\n * - if it's 4KB aligned\n * - No bits beyond the physical address width are set\n * - Returns 0 on success or else 1\n * (Intel SDM Section 30.3)\n */\nstatic int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,\n\t\t\t\t  gpa_t *vmpointer)\n{\n\tgva_t gva;\n\tgpa_t vmptr;\n\tstruct x86_exception e;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmcs_read32(VMX_INSTRUCTION_INFO), false, &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vmptr,\n\t\t\t\tsizeof(vmptr), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_VMON:\n\t\t/*\n\t\t * SDM 3: 24.11.5\n\t\t * The first 4 bytes of VMXON region contain the supported\n\t\t * VMCS revision identifier\n\t\t *\n\t\t * Note - IA32_VMX_BASIC[48] will never be 1\n\t\t * for the nested case;\n\t\t * which replaces physical address width with 32\n\t\t *\n\t\t */\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL ||\n\t\t    *(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\tkunmap(page);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tkunmap(page);\n\t\tvmx->nested.vmxon_ptr = vmptr;\n\t\tbreak;\n\tcase EXIT_REASON_VMCLEAR:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_INVALID_ADDRESS);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMCLEAR_VMXON_POINTER);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase EXIT_REASON_VMPTRLD:\n\t\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> maxphyaddr)) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_INVALID_ADDRESS);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tif (vmptr == vmx->nested.vmxon_ptr) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\t\t     VMXERR_VMPTRLD_VMXON_POINTER);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 1; /* shouldn't happen */\n\t}\n\n\tif (vmpointer)\n\t\t*vmpointer = vmptr;\n\treturn 0;\n}\n\n/*\n * Emulate the VMXON instruction.\n * Currently, we just remember that VMX is active, and do not save or even\n * inspect the argument to VMXON (the so-called \"VMXON pointer\") because we\n * do not currently need to store anything in that guest-allocated memory\n * region. Consequently, VMCLEAR and VMPTRLD also do not verify that the their\n * argument is different from the VMXON pointer (which the spec says they do).\n */\nstatic int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs *shadow_vmcs;\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\t/* The Intel VMX Instruction Reference lists a bunch of bits that\n\t * are prerequisite to running VMXON, most notably cr4.VMXE must be\n\t * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).\n\t * Otherwise, we should fail with #UD. We test these now:\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE) ||\n\t    !kvm_read_cr0_bits(vcpu, X86_CR0_PE) ||\n\t    (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif (is_long_mode(vcpu) && !cs.l) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMON, NULL))\n\t\treturn 1;\n\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tvmx->nested.msr_bitmap =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx->nested.msr_bitmap)\n\t\t\tgoto out_msr_bitmap;\n\t}\n\n\tvmx->nested.cached_vmcs12 = kmalloc(VMCS12_SIZE, GFP_KERNEL);\n\tif (!vmx->nested.cached_vmcs12)\n\t\tgoto out_cached_vmcs12;\n\n\tif (enable_shadow_vmcs) {\n\t\tshadow_vmcs = alloc_vmcs();\n\t\tif (!shadow_vmcs)\n\t\t\tgoto out_shadow_vmcs;\n\t\t/* mark vmcs as shadow */\n\t\tshadow_vmcs->revision_id |= (1u << 31);\n\t\t/* init shadow vmcs */\n\t\tvmcs_clear(shadow_vmcs);\n\t\tvmx->vmcs01.shadow_vmcs = shadow_vmcs;\n\t}\n\n\tINIT_LIST_HEAD(&(vmx->nested.vmcs02_pool));\n\tvmx->nested.vmcs02_num = 0;\n\n\thrtimer_init(&vmx->nested.preemption_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_PINNED);\n\tvmx->nested.preemption_timer.function = vmx_preemption_timer_fn;\n\n\tvmx->nested.vmxon = true;\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n\nout_shadow_vmcs:\n\tkfree(vmx->nested.cached_vmcs12);\n\nout_cached_vmcs12:\n\tfree_page((unsigned long)vmx->nested.msr_bitmap);\n\nout_msr_bitmap:\n\treturn -ENOMEM;\n}\n\n/*\n * Intel's VMX Instruction Reference specifies a common set of prerequisites\n * for running VMX instructions (except VMXON, whose prerequisites are\n * slightly different). It also specifies what exception to inject otherwise.\n */\nstatic int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tif ((vmx_get_rflags(vcpu) & X86_EFLAGS_VM) ||\n\t    (is_long_mode(vcpu) && !cs.l)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline void nested_release_vmcs12(struct vcpu_vmx *vmx)\n{\n\tif (vmx->nested.current_vmptr == -1ull)\n\t\treturn;\n\n\t/* current_vmptr and current_vmcs12 are always set/reset together */\n\tif (WARN_ON(vmx->nested.current_vmcs12 == NULL))\n\t\treturn;\n\n\tif (enable_shadow_vmcs) {\n\t\t/* copy to memory all shadowed fields in case\n\t\t   they were modified */\n\t\tcopy_shadow_to_vmcs12(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tSECONDARY_EXEC_SHADOW_VMCS);\n\t\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\t}\n\tvmx->nested.posted_intr_nv = -1;\n\n\t/* Flush VMCS12 to guest memory */\n\tmemcpy(vmx->nested.current_vmcs12, vmx->nested.cached_vmcs12,\n\t       VMCS12_SIZE);\n\n\tkunmap(vmx->nested.current_vmcs12_page);\n\tnested_release_page(vmx->nested.current_vmcs12_page);\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n}\n\n/*\n * Free whatever needs to be freed from vmx->nested when L1 goes down, or\n * just stops using VMX.\n */\nstatic void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (vmx->nested.msr_bitmap) {\n\t\tfree_page((unsigned long)vmx->nested.msr_bitmap);\n\t\tvmx->nested.msr_bitmap = NULL;\n\t}\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_clear(vmx->vmcs01.shadow_vmcs);\n\t\tfree_vmcs(vmx->vmcs01.shadow_vmcs);\n\t\tvmx->vmcs01.shadow_vmcs = NULL;\n\t}\n\tkfree(vmx->nested.cached_vmcs12);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}\n\n/* Emulate the VMXOFF instruction */\nstatic int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMCLEAR instruction */\nstatic int handle_vmclear(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\tstruct vmcs12 *vmcs12;\n\tstruct page *page;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMCLEAR, &vmptr))\n\t\treturn 1;\n\n\tif (vmptr == vmx->nested.current_vmptr)\n\t\tnested_release_vmcs12(vmx);\n\n\tpage = nested_get_page(vcpu, vmptr);\n\tif (page == NULL) {\n\t\t/*\n\t\t * For accurate processor emulation, VMCLEAR beyond available\n\t\t * physical memory should do nothing at all. However, it is\n\t\t * possible that a nested vmx bug, not a guest hypervisor bug,\n\t\t * resulted in this case, so let's shut down before doing any\n\t\t * more damage:\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn 1;\n\t}\n\tvmcs12 = kmap(page);\n\tvmcs12->launch_state = 0;\n\tkunmap(page);\n\tnested_release_page(page);\n\n\tnested_free_vmcs02(vmx, vmptr);\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch);\n\n/* Emulate the VMLAUNCH instruction */\nstatic int handle_vmlaunch(struct kvm_vcpu *vcpu)\n{\n\treturn nested_vmx_run(vcpu, true);\n}\n\n/* Emulate the VMRESUME instruction */\nstatic int handle_vmresume(struct kvm_vcpu *vcpu)\n{\n\n\treturn nested_vmx_run(vcpu, false);\n}\n\nenum vmcs_field_type {\n\tVMCS_FIELD_TYPE_U16 = 0,\n\tVMCS_FIELD_TYPE_U64 = 1,\n\tVMCS_FIELD_TYPE_U32 = 2,\n\tVMCS_FIELD_TYPE_NATURAL_WIDTH = 3\n};\n\nstatic inline int vmcs_field_type(unsigned long field)\n{\n\tif (0x1 & field)\t/* the *_HIGH fields are all 32 bit */\n\t\treturn VMCS_FIELD_TYPE_U32;\n\treturn (field >> 13) & 0x3 ;\n}\n\nstatic inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}\n\n/*\n * Read a vmcs12 field. Since these can have varying lengths and we return\n * one type, we chose the biggest type (u64) and zero-extend the return value\n * to that size. Note that the caller, handle_vmread, might need to use only\n * some of the bits we return here (e.g., on 32-bit guests, only 32 bits of\n * 64-bit fields are to be returned).\n */\nstatic inline int vmcs12_read_any(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned long field, u64 *ret)\n{\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p;\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\tp = ((char *)(get_vmcs12(vcpu))) + offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*ret = *((natural_width *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*ret = *((u16 *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*ret = *((u32 *)p);\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*ret = *((u64 *)p);\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n}\n\n\nstatic inline int vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn offset;\n\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n\n}\n\nstatic void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)\n{\n\tint i;\n\tunsigned long field;\n\tu64 field_value;\n\tstruct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;\n\tconst unsigned long *fields = shadow_read_write_fields;\n\tconst int num_fields = max_shadow_read_write_fields;\n\n\tpreempt_disable();\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tfield = fields[i];\n\t\tswitch (vmcs_field_type(field)) {\n\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\tfield_value = vmcs_read16(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\tfield_value = vmcs_read32(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\tfield_value = vmcs_read64(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\tfield_value = vmcs_readl(field);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\t}\n\t\tvmcs12_write_any(&vmx->vcpu, field, field_value);\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\n\tpreempt_enable();\n}\n\nstatic void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long *fields[] = {\n\t\tshadow_read_write_fields,\n\t\tshadow_read_only_fields\n\t};\n\tconst int max_fields[] = {\n\t\tmax_shadow_read_write_fields,\n\t\tmax_shadow_read_only_fields\n\t};\n\tint i, q;\n\tunsigned long field;\n\tu64 field_value = 0;\n\tstruct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;\n\n\tvmcs_load(shadow_vmcs);\n\n\tfor (q = 0; q < ARRAY_SIZE(fields); q++) {\n\t\tfor (i = 0; i < max_fields[q]; i++) {\n\t\t\tfield = fields[q][i];\n\t\t\tvmcs12_read_any(&vmx->vcpu, field, &field_value);\n\n\t\t\tswitch (vmcs_field_type(field)) {\n\t\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\t\tvmcs_write16(field, (u16)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\t\tvmcs_write32(field, (u32)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\t\tvmcs_write64(field, (u64)field_value);\n\t\t\t\tbreak;\n\t\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\t\tvmcs_writel(field, (long)field_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}\n\n/*\n * VMX instructions which assume a current vmcs12 (i.e., that VMPTRLD was\n * used before) all generate the same failure when it is missing.\n */\nstatic int nested_vmx_check_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (vmx->nested.current_vmptr == -1ull) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\t/* Decode instruction info and find the field to read */\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\t/* Read the field, zero-extended to a u64 field_value */\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\t/*\n\t * Now copy part of this value to register or memory, as requested.\n\t * Note that the number of bits actually copied is 32 or 64 depending\n\t * on the guest's mode (32 or 64 bit), not on the given field's length.\n\t */\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\t/* _system ok, as nested_vmx_check_permission verified cpl=0 */\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n\nstatic int handle_vmwrite(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tgva_t gva;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\t/* The value to write might be 32 or 64 bits, depending on L1's long\n\t * mode, and eventually we need to write that into a field of several\n\t * possible lengths. The code below first zero-extends the value to 64\n\t * bit (field_value), and then copies only the appropriate number of\n\t * bits into the vmcs12 field.\n\t */\n\tu64 field_value = 0;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tif (vmx_instruction_info & (1u << 10))\n\t\tfield_value = kvm_register_readl(vcpu,\n\t\t\t(((vmx_instruction_info) >> 3) & 0xf));\n\telse {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, false, &gva))\n\t\t\treturn 1;\n\t\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t   &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {\n\t\t\tkvm_inject_page_fault(vcpu, &e);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs_field_readonly(field)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tif (vmcs12_write_any(vcpu, field, field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMPTRLD instruction */\nstatic int handle_vmptrld(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t vmptr;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (nested_vmx_check_vmptr(vcpu, EXIT_REASON_VMPTRLD, &vmptr))\n\t\treturn 1;\n\n\tif (vmx->nested.current_vmptr != vmptr) {\n\t\tstruct vmcs12 *new_vmcs12;\n\t\tstruct page *page;\n\t\tpage = nested_get_page(vcpu, vmptr);\n\t\tif (page == NULL) {\n\t\t\tnested_vmx_failInvalid(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tnew_vmcs12 = kmap(page);\n\t\tif (new_vmcs12->revision_id != VMCS12_REVISION) {\n\t\t\tkunmap(page);\n\t\t\tnested_release_page_clean(page);\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\n\t\tnested_release_vmcs12(vmx);\n\t\tvmx->nested.current_vmptr = vmptr;\n\t\tvmx->nested.current_vmcs12 = new_vmcs12;\n\t\tvmx->nested.current_vmcs12_page = page;\n\t\t/*\n\t\t * Load VMCS12 from guest memory since it is not already\n\t\t * cached.\n\t\t */\n\t\tmemcpy(vmx->nested.cached_vmcs12,\n\t\t       vmx->nested.current_vmcs12, VMCS12_SIZE);\n\n\t\tif (enable_shadow_vmcs) {\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_SHADOW_VMCS);\n\t\t\tvmcs_write64(VMCS_LINK_POINTER,\n\t\t\t\t     __pa(vmx->vmcs01.shadow_vmcs));\n\t\t\tvmx->nested.sync_shadow_vmcs = true;\n\t\t}\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the VMPTRST instruction */\nstatic int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\t/* ok to use *_system, as nested_vmx_check_permission verified cpl=0 */\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/* Emulate the INVEPT instruction */\nstatic int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(vmx->nested.nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (vmx->nested.nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (type >= 32 || !(types & (1 << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t/*\n\t * TODO: track mappings and invalidate\n\t * single context requests appropriately\n\t */\n\tcase VMX_EPT_EXTENT_CONTEXT:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info;\n\tunsigned long type, types;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tint vpid;\n\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_VPID) ||\n\t\t\t!(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (vmx->nested.nested_vmx_vpid_caps &\n\t\t\tVMX_VPID_EXTENT_SUPPORTED_MASK) >> 8;\n\n\tif (type >= 32 || !(types & (1 << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t/* according to the intel vmx instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,\n\t\t\t\tsizeof(u32), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_VPID_EXTENT_INDIVIDUAL_ADDR:\n\tcase VMX_VPID_EXTENT_SINGLE_CONTEXT:\n\tcase VMX_VPID_EXTENT_SINGLE_NON_GLOBAL:\n\t\tif (!vpid) {\n\t\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase VMX_VPID_EXTENT_ALL_CONTEXT:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\t__vmx_flush_tlb(vcpu, vmx->nested.vpid02);\n\tnested_vmx_succeed(vcpu);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_expired_hv_timer(vcpu);\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n\t[EXIT_REASON_VMREAD]                  = handle_vmread,\n\t[EXIT_REASON_VMRESUME]                = handle_vmresume,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n\t[EXIT_REASON_VMOFF]                   = handle_vmoff,\n\t[EXIT_REASON_VMON]                    = handle_vmon,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_invept,\n\t[EXIT_REASON_INVVPID]                 = handle_invvpid,\n\t[EXIT_REASON_XSAVES]                  = handle_xsaves,\n\t[EXIT_REASON_XRSTORS]                 = handle_xrstors,\n\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,\n\t[EXIT_REASON_PREEMPTION_TIMER]\t      = handle_preemption_timer,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tgpa_t bitmap, last_bitmap;\n\tunsigned int port;\n\tint size;\n\tu8 b;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn true;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))\n\t\t\t\treturn true;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn true;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn false;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an MSR access access,\n * rather than handle it ourselves in L0. I.e., check whether L1 expressed\n * disinterest in the current event (read or write a specific MSR) by using an\n * MSR bitmap. This may be the case even when L0 doesn't use MSR bitmaps.\n */\nstatic bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12, u32 exit_reason)\n{\n\tu32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tgpa_t bitmap;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn true;\n\n\t/*\n\t * The MSR_BITMAP page is divided into four 1024-byte bitmaps,\n\t * for the four combinations of read/write and low/high MSR numbers.\n\t * First we need to figure out which of the four to use:\n\t */\n\tbitmap = vmcs12->msr_bitmap;\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\tbitmap += 2048;\n\tif (msr_index >= 0xc0000000) {\n\t\tmsr_index -= 0xc0000000;\n\t\tbitmap += 1024;\n\t}\n\n\t/* Then read the msr_index'th bit from this bitmap: */\n\tif (msr_index < 1024*8) {\n\t\tunsigned char b;\n\t\tif (kvm_vcpu_read_guest(vcpu, bitmap + msr_index/8, &b, 1))\n\t\t\treturn true;\n\t\treturn 1 & (b >> (msr_index & 7));\n\t} else\n\t\treturn true; /* let L1 handle the wrong parameter */\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle a CR access exit,\n * rather than handle it ourselves in L0. I.e., check if L1 wanted to\n * intercept (via guest_host_mask etc.) the current event.\n */\nstatic bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint cr = exit_qualification & 15;\n\tint reg = (exit_qualification >> 8) & 15;\n\tunsigned long val = kvm_register_readl(vcpu, reg);\n\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (vmcs12->cr0_guest_host_mask &\n\t\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((vmcs12->cr3_target_count >= 1 &&\n\t\t\t\t\tvmcs12->cr3_target_value0 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 2 &&\n\t\t\t\t\tvmcs12->cr3_target_value1 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 3 &&\n\t\t\t\t\tvmcs12->cr3_target_value2 == val) ||\n\t\t\t\t(vmcs12->cr3_target_count >= 4 &&\n\t\t\t\t\tvmcs12->cr3_target_value3 == val))\n\t\t\t\treturn false;\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR3_LOAD_EXITING))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (vmcs12->cr4_guest_host_mask &\n\t\t\t    (vmcs12->cr4_read_shadow ^ val))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tif ((vmcs12->cr0_guest_host_mask & X86_CR0_TS) &&\n\t\t    (vmcs12->cr0_read_shadow & X86_CR0_TS))\n\t\t\treturn true;\n\t\tbreak;\n\tcase 1: /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR3_STORE_EXITING)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (vmcs12->cpu_based_vm_exec_control &\n\t\t\t    CPU_BASED_CR8_STORE_EXITING)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\t/*\n\t\t * lmsw can change bits 1..3 of cr0, and only set bit 0 of\n\t\t * cr0. Other attempted changes are ignored, with no exit.\n\t\t */\n\t\tif (vmcs12->cr0_guest_host_mask & 0xe &\n\t\t    (val ^ vmcs12->cr0_read_shadow))\n\t\t\treturn true;\n\t\tif ((vmcs12->cr0_guest_host_mask & 0x1) &&\n\t\t    !(vmcs12->cr0_read_shadow & 0x1) &&\n\t\t    (val & 0x1))\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n/*\n * Return 1 if we should exit from L2 to L1 to handle an exit, or 0 if we\n * should handle it ourselves in L0 (and then continue L2). Only call this\n * when in is_guest_mode (L2).\n */\nstatic bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn true;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (is_nmi(intr_info))\n\t\t\treturn false;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn false;\n\t\telse if (is_debug(intr_info) &&\n\t\t\t vcpu->guest_debug &\n\t\t\t (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\telse if (is_breakpoint(intr_info) &&\n\t\t\t vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn false;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn true;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn true;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn false;\n\t\treturn true;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn true;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n\tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn true;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_TRAP_FLAG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn false;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_APIC_WRITE:\n\tcase EXIT_REASON_EOI_INDUCED:\n\t\t/* apic_write and eoi_induced should exit unconditionally. */\n\t\treturn true;\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn true;\n\tcase EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:\n\t\t/*\n\t\t * This should never happen, since it is not possible to\n\t\t * set XSS to a non-zero value---neither in L1 nor in L2.\n\t\t * If if it were, XSS would have to be checked against\n\t\t * the XSS exit bitmap in vmcs12.\n\t\t */\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}\n\n/*\n * Flush all vcpus' PML buffer and update logged GPAs to dirty_bitmap.\n * Called before reporting dirty_bitmap to userspace.\n */\nstatic void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}\n\nstatic void dump_vmcs(void)\n{\n\tu32 vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tu32 vmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tu32 cpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tu32 pin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tu32 secondary_exec_control = 0;\n\tunsigned long cr4 = vmcs_readl(GUEST_CR4);\n\tu64 efer = vmcs_read64(GUEST_IA32_EFER);\n\tint i, n;\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW)\n\t\tpr_err(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\ttrace_kvm_exit(exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.\n\t */\n\tif (enable_pml)\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_PML_FULL &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tWARN_ONCE(1, \"vmx: unexpected exit reason 0x%x\\n\", exit_reason);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\tif (irr == -1 || tpr < irr) {\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(TPR_THRESHOLD, irr);\n}\n\nstatic void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\tu32 sec_exec_control;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.change_vmcs01_virtual_x2apic_mode = true;\n\t\treturn;\n\t}\n\n\tif (!cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\tif (!cpu_need_tpr_shadow(vcpu))\n\t\treturn;\n\n\tsec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tif (set) {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t} else {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t}\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);\n\n\tvmx_set_msr_bitmap(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Currently we do not handle the nested case where L2 has an\n\t * APIC access page of its own; that page is still pinned.\n\t * Hence, we skip the case where the VCPU is in guest mode _and_\n\t * L1 prepared an APIC access page for L2.\n\t *\n\t * For the case where L1 and L2 share the same APIC access page\n\t * (flexpriority=Y but SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES clear\n\t * in the vmcs12), this function will only update either the vmcs01\n\t * or the vmcs02.  If the former, the vmcs02 will be updated by\n\t * prepare_vmcs02.  If the latter, the vmcs01 will be updated in\n\t * the next L2->L1 exit.\n\t */\n\tif (!is_guest_mode(vcpu) ||\n\t    !nested_cpu_has2(get_vmcs12(&vmx->vcpu),\n\t\t\t     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmx_set_rvi(max_irr);\n\t\treturn;\n\t}\n\n\tif (max_irr == -1)\n\t\treturn;\n\n\t/*\n\t * In guest mode.  If a vmexit is needed, vmx_check_nested_events\n\t * handles it.\n\t */\n\tif (nested_exit_on_intr(vcpu))\n\t\treturn;\n\n\t/*\n\t * Else, fall back to pre-APICv interrupt injection since L2\n\t * is run without virtual interrupt delivery.\n\t */\n\tif (!kvm_event_needs_reinjection(vcpu) &&\n\t    vmx_interrupt_allowed(vcpu)) {\n\t\tkvm_queue_interrupt(vcpu, max_irr, false);\n\t\tvmx_inject_irq(vcpu);\n\t}\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\t/* We need to handle NMIs before interrupts are enabled */\n\tif (is_nmi(exit_intr_info)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n\nstatic void vmx_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tregister void *__sp asm(_ASM_SP);\n\n\tif ((exit_intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) {\n\t\tunsigned int vector;\n\t\tunsigned long entry;\n\t\tgate_desc *desc;\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n#ifdef CONFIG_X86_64\n\t\tunsigned long tmp;\n#endif\n\n\t\tvector =  exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\tdesc = (gate_desc *)vmx->host_idt_base + vector;\n\t\tentry = gate_offset(*desc);\n\t\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\t\"push $%c[ss]\\n\\t\"\n\t\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\t\"pushf\\n\\t\"\n\t\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\t\t\"call *%[entry]\\n\\t\"\n\t\t\t:\n#ifdef CONFIG_X86_64\n\t\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\t\t\"+r\"(__sp)\n\t\t\t:\n\t\t\t[entry]\"r\"(entry),\n\t\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t\t[cs]\"i\"(__KERNEL_CS)\n\t\t\t);\n\t}\n}\n\nstatic bool vmx_has_high_real_mode_segbase(void)\n{\n\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n}\n\nstatic bool vmx_mpx_supported(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}\n\nstatic bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (cpu_has_virtual_nmis()) {\n\t\tif (vmx->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->soft_vnmi_blocked))\n\t\tvmx->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(), vmx->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}\n\nstatic void vmx_arm_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->hv_deadline_tsc == -1)\n\t\treturn;\n\n\ttscl = rdtsc();\n\tif (vmx->hv_deadline_tsc > tscl)\n\t\t/* sure to be 32 bit only because checked on set_hv_timer */\n\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\tcpu_preemption_timer_multi);\n\telse\n\t\tdelta_tsc = 0;\n\n\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n}\n\nstatic void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tif (vmx->guest_pkru_valid)\n\t\t__write_pkru(vmx->guest_pkru);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx_arm_hv_timer(vcpu);\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\n\t/*\n\t * eager fpu is enabled if PKEY is supported and CR4 is switched\n\t * back on host, so it is safe to read guest PKRU from current\n\t * XSAVE.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_OSPKE)) {\n\t\tvmx->guest_pkru = __read_pkru();\n\t\tif (vmx->guest_pkru != vmx->host_pkru) {\n\t\t\tvmx->guest_pkru_valid = true;\n\t\t\t__write_pkru(vmx->host_pkru);\n\t\t} else\n\t\t\tvmx->guest_pkru_valid = false;\n\t}\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n\nstatic void vmx_load_vmcs01(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\n\tif (vmx->loaded_vmcs == &vmx->vmcs01)\n\t\treturn;\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n}\n\n/*\n * Ensure that the current vmcs of the logical processor is the\n * vmcs01 of the vcpu before calling free_nested().\n */\nstatic void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)\n{\n       struct vcpu_vmx *vmx = to_vmx(vcpu);\n       int r;\n\n       r = vcpu_load(vcpu);\n       BUG_ON(r);\n       vmx_load_vmcs01(vcpu);\n       free_nested(vmx);\n       vcpu_put(vcpu);\n}\n\nstatic void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tleave_guest_mode(vcpu);\n\tvmx_free_vcpu_nested(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n\tkfree(vmx->guest_msrs);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n}\n\nstatic struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tint err;\n\tstruct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tint cpu;\n\n\tif (!vmx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvmx->vpid = allocate_vpid();\n\n\terr = kvm_vcpu_init(&vmx->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_vcpu;\n\n\terr = -ENOMEM;\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest, etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto uninit_vcpu;\n\t}\n\n\tvmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) * sizeof(vmx->guest_msrs[0])\n\t\t     > PAGE_SIZE);\n\n\tif (!vmx->guest_msrs)\n\t\tgoto free_pml;\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx->loaded_vmcs->vmcs = alloc_vmcs();\n\tvmx->loaded_vmcs->shadow_vmcs = NULL;\n\tif (!vmx->loaded_vmcs->vmcs)\n\t\tgoto free_msrs;\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(__pa(per_cpu(vmxarea, raw_smp_processor_id())));\n\tloaded_vmcs_init(vmx->loaded_vmcs);\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxoff();\n\n\tcpu = get_cpu();\n\tvmx_vcpu_load(&vmx->vcpu, cpu);\n\tvmx->vcpu.cpu = cpu;\n\terr = vmx_vcpu_setup(vmx);\n\tvmx_vcpu_put(&vmx->vcpu);\n\tput_cpu();\n\tif (err)\n\t\tgoto free_vmcs;\n\tif (cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {\n\t\terr = alloc_apic_access_page(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept) {\n\t\tif (!kvm->arch.ept_identity_map_addr)\n\t\t\tkvm->arch.ept_identity_map_addr =\n\t\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t\terr = init_rmode_identity_map(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(vmx);\n\t\tvmx->nested.vpid02 = allocate_vpid();\n\t}\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n\n\tvmx->msr_ia32_feature_control_valid_bits = FEATURE_CONTROL_LOCKED;\n\n\treturn &vmx->vcpu;\n\nfree_vmcs:\n\tfree_vpid(vmx->nested.vpid02);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_msrs:\n\tkfree(vmx->guest_msrs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nuninit_vcpu:\n\tkvm_vcpu_uninit(&vmx->vcpu);\nfree_vcpu:\n\tfree_vpid(vmx->vpid);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n\treturn ERR_PTR(err);\n}\n\nstatic void __init vmx_check_processor_compat(void *rtn)\n{\n\tstruct vmcs_config vmcs_conf;\n\n\t*(int *)rtn = 0;\n\tif (setup_vmcs_config(&vmcs_conf) < 0)\n\t\t*(int *)rtn = -EIO;\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\t*(int *)rtn = -EIO;\n\t}\n}\n\nstatic int get_ept_level(void)\n{\n\treturn VMX_EPT_DEFAULT_GAW + 1;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\tu64 ipat = 0;\n\n\t/* For VT-d and EPT combination\n\t * 1. MMIO: always map as UC\n\t * 2. EPT with VT-d:\n\t *   a. VT-d without snooping control feature: can't guarantee the\n\t *\tresult, try to trust guest.\n\t *   b. VT-d with snooping control feature: snooping control feature of\n\t *\tVT-d engine can guarantee the cache correctness. Just set it\n\t *\tto WB to keep consistent with host. So the same as item 3.\n\t * 3. EPT without VT-d: always map as WB and set IPAT=1 to keep\n\t *    consistent with host MTRR\n\t */\n\tif (is_mmio) {\n\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm)) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tcache = MTRR_TYPE_WRBACK;\n\t\tgoto exit;\n\t}\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tcache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);\n\nexit:\n\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;\n}\n\nstatic int vmx_get_lpage_level(void)\n{\n\tif (enable_ept && !cpu_has_vmx_ept_1g_page())\n\t\treturn PT_DIRECTORY_LEVEL;\n\telse\n\t\t/* For shadow and EPT supported 1GB page */\n\t\treturn PT_PDPE_LEVEL;\n}\n\nstatic void vmcs_set_secondary_exec_control(u32 new_ctl)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\n\tu32 cur_ctl = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t     (new_ctl & ~mask) | (cur_ctl & mask));\n}\n\n/*\n * Generate MSR_IA32_VMX_CR{0,4}_FIXED1 according to CPUID. Only set bits\n * (indicating \"allowed-1\") if they are supported in the guest's CPUID.\n */\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.nested_vmx_cr0_fixed1 = 0xffffffff;\n\tvmx->nested.nested_vmx_cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.nested_vmx_cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, bit(X86_FEATURE_TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, bit(X86_FEATURE_DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, bit(X86_FEATURE_PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, bit(X86_FEATURE_PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, bit(X86_FEATURE_MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, bit(X86_FEATURE_PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, bit(X86_FEATURE_FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, bit(X86_FEATURE_XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, bit(X86_FEATURE_VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, bit(X86_FEATURE_SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, bit(X86_FEATURE_PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, bit(X86_FEATURE_XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, bit(X86_FEATURE_FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, bit(X86_FEATURE_SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, bit(X86_FEATURE_SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, bit(X86_FEATURE_PKU));\n\t/* TODO: Use X86_CR4_UMIP and X86_FEATURE_UMIP macros */\n\tcr4_fixed1_update(bit(11),            ecx, bit(2));\n\n#undef cr4_fixed1_update\n}\n\nstatic void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 secondary_exec_ctl = vmx_secondary_exec_control(vmx);\n\n\tif (vmx_rdtscp_supported()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has_rdtscp(vcpu);\n\t\tif (!rdtscp_enabled)\n\t\t\tsecondary_exec_ctl &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\t/* Exposing INVPCID only when PCID is exposed */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    (!best || !(best->ebx & bit(X86_FEATURE_INVPCID)) ||\n\t    !guest_cpuid_has_pcid(vcpu))) {\n\t\tsecondary_exec_ctl &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tvmcs_set_secondary_exec_control(secondary_exec_ctl);\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n}\n\nstatic void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}\n\nstatic void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason;\n\n\tif (fault->error_code & PFERR_RSVD_MASK)\n\t\texit_reason = EXIT_REASON_EPT_MISCONFIG;\n\telse\n\t\texit_reason = EXIT_REASON_EPT_VIOLATION;\n\tnested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);\n\tvmcs12->guest_physical_address = fault->address;\n}\n\n/* Callbacks for nested_ept_init_mmu_context: */\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}\n\nstatic void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tkvm_init_shadow_ept_mmu(vcpu,\n\t\t\tto_vmx(vcpu)->nested.nested_vmx_ept_caps &\n\t\t\tVMX_EPT_EXECUTE_ONLY_BIT);\n\tvcpu->arch.mmu.set_cr3           = vmx_set_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;\n\tvcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;\n\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}\n\nstatic bool nested_vmx_is_page_fault_vmexit(struct vmcs12 *vmcs12,\n\t\t\t\t\t    u16 error_code)\n{\n\tbool inequality, bit;\n\n\tbit = (vmcs12->exception_bitmap & (1u << PF_VECTOR)) != 0;\n\tinequality =\n\t\t(error_code & vmcs12->page_fault_error_code_mask) !=\n\t\t vmcs12->page_fault_error_code_match;\n\treturn inequality ^ bit;\n}\n\nstatic void vmx_inject_page_fault_nested(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON(!is_guest_mode(vcpu));\n\n\tif (nested_vmx_is_page_fault_vmexit(vmcs12, fault->error_code))\n\t\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\telse\n\t\tkvm_inject_page_fault(vcpu, fault);\n}\n\nstatic bool nested_get_vmcs12_pages(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {\n\t\tif (!PAGE_ALIGNED(vmcs12->apic_access_addr) ||\n\t\t    vmcs12->apic_access_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Translate L1 physical address to host physical\n\t\t * address for vmcs02. Keep the page pinned, so this\n\t\t * physical address remains valid. We keep a reference\n\t\t * to it so we can release it later.\n\t\t */\n\t\tif (vmx->nested.apic_access_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page =\n\t\t\tnested_get_page(vcpu, vmcs12->apic_access_addr);\n\t}\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tif (!PAGE_ALIGNED(vmcs12->virtual_apic_page_addr) ||\n\t\t    vmcs12->virtual_apic_page_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\tif (vmx->nested.virtual_apic_page) /* shouldn't happen */\n\t\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page =\n\t\t\tnested_get_page(vcpu, vmcs12->virtual_apic_page_addr);\n\n\t\t/*\n\t\t * Failing the vm entry is _not_ what the processor does\n\t\t * but it's basically the only possibility we have.\n\t\t * We could still enter the guest if CR8 load exits are\n\t\t * enabled, CR8 store exits are enabled, and virtualize APIC\n\t\t * access is disabled; in this case the processor would never\n\t\t * use the TPR shadow and we could simply clear the bit from\n\t\t * the execution control.  But such a configuration is useless,\n\t\t * so let's keep the code simple.\n\t\t */\n\t\tif (!vmx->nested.virtual_apic_page)\n\t\t\treturn false;\n\t}\n\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tif (!IS_ALIGNED(vmcs12->posted_intr_desc_addr, 64) ||\n\t\t    vmcs12->posted_intr_desc_addr >> maxphyaddr)\n\t\t\treturn false;\n\n\t\tif (vmx->nested.pi_desc_page) { /* shouldn't happen */\n\t\t\tkunmap(vmx->nested.pi_desc_page);\n\t\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\t}\n\t\tvmx->nested.pi_desc_page =\n\t\t\tnested_get_page(vcpu, vmcs12->posted_intr_desc_addr);\n\t\tif (!vmx->nested.pi_desc_page)\n\t\t\treturn false;\n\n\t\tvmx->nested.pi_desc =\n\t\t\t(struct pi_desc *)kmap(vmx->nested.pi_desc_page);\n\t\tif (!vmx->nested.pi_desc) {\n\t\t\tnested_release_page_clean(vmx->nested.pi_desc_page);\n\t\t\treturn false;\n\t\t}\n\t\tvmx->nested.pi_desc =\n\t\t\t(struct pi_desc *)((void *)vmx->nested.pi_desc +\n\t\t\t(unsigned long)(vmcs12->posted_intr_desc_addr &\n\t\t\t(PAGE_SIZE - 1)));\n\t}\n\n\treturn true;\n}\n\nstatic void vmx_start_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tu64 preemption_timeout = get_vmcs12(vcpu)->vmx_preemption_timer_value;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vcpu->arch.virtual_tsc_khz == 0)\n\t\treturn;\n\n\t/* Make sure short timeouts reliably trigger an immediate vmexit.\n\t * hrtimer_start does not guarantee this. */\n\tif (preemption_timeout <= 1) {\n\t\tvmx_preemption_timer_fn(&vmx->nested.preemption_timer);\n\t\treturn;\n\t}\n\n\tpreemption_timeout <<= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n\tpreemption_timeout *= 1000000;\n\tdo_div(preemption_timeout, vcpu->arch.virtual_tsc_khz);\n\thrtimer_start(&vmx->nested.preemption_timer,\n\t\t      ns_to_ktime(preemption_timeout), HRTIMER_MODE_REL);\n}\n\nstatic int nested_vmx_check_msr_bitmap_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tint maxphyaddr;\n\tu64 addr;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 0;\n\n\tif (vmcs12_read_any(vcpu, MSR_BITMAP, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\tif (!PAGE_ALIGNED(vmcs12->msr_bitmap) ||\n\t   ((addr + PAGE_SIZE) >> maxphyaddr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Merge L0's and L1's MSR bitmap, return false to indicate that\n * we do not use the hardware.\n */\nstatic inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tint msr;\n\tstruct page *page;\n\tunsigned long *msr_bitmap_l1;\n\tunsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.msr_bitmap;\n\n\t/* This shortcut is ok because we support only x2APIC MSRs so far. */\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12))\n\t\treturn false;\n\n\tpage = nested_get_page(vcpu, vmcs12->msr_bitmap);\n\tif (!page) {\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\tmsr_bitmap_l1 = (unsigned long *)kmap(page);\n\tif (!msr_bitmap_l1) {\n\t\tnested_release_page_clean(page);\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tmemset(msr_bitmap_l0, 0xff, PAGE_SIZE);\n\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12)) {\n\t\tif (nested_cpu_has_apic_reg_virt(vmcs12))\n\t\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\t\tmsr, MSR_TYPE_R);\n\n\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_TASKPRI >> 4),\n\t\t\t\tMSR_TYPE_R | MSR_TYPE_W);\n\n\t\tif (nested_cpu_has_vid(vmcs12)) {\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_EOI >> 4),\n\t\t\t\tMSR_TYPE_W);\n\t\t\tnested_vmx_disable_intercept_for_msr(\n\t\t\t\tmsr_bitmap_l1, msr_bitmap_l0,\n\t\t\t\tAPIC_BASE_MSR + (APIC_SELF_IPI >> 4),\n\t\t\t\tMSR_TYPE_W);\n\t\t}\n\t}\n\tkunmap(page);\n\tnested_release_page_clean(page);\n\n\treturn true;\n}\n\nstatic int nested_vmx_check_apicv_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tif (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    !nested_cpu_has_apic_reg_virt(vmcs12) &&\n\t    !nested_cpu_has_vid(vmcs12) &&\n\t    !nested_cpu_has_posted_intr(vmcs12))\n\t\treturn 0;\n\n\t/*\n\t * If virtualize x2apic mode is enabled,\n\t * virtualize apic access must be disabled.\n\t */\n\tif (nested_cpu_has_virt_x2apic_mode(vmcs12) &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If virtual interrupt delivery is enabled,\n\t * we must exit on external interrupts.\n\t */\n\tif (nested_cpu_has_vid(vmcs12) &&\n\t   !nested_exit_on_intr(vcpu))\n\t\treturn -EINVAL;\n\n\t/*\n\t * bits 15:8 should be zero in posted_intr_nv,\n\t * the descriptor address has been already checked\n\t * in nested_get_vmcs12_pages.\n\t */\n\tif (nested_cpu_has_posted_intr(vmcs12) &&\n\t   (!nested_cpu_has_vid(vmcs12) ||\n\t    !nested_exit_intr_ack_set(vcpu) ||\n\t    vmcs12->posted_intr_nv & 0xff00))\n\t\treturn -EINVAL;\n\n\t/* tpr shadow is needed by all apicv features. */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned long count_field,\n\t\t\t\t       unsigned long addr_field)\n{\n\tint maxphyaddr;\n\tu64 count, addr;\n\n\tif (vmcs12_read_any(vcpu, count_field, &count) ||\n\t    vmcs12_read_any(vcpu, addr_field, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (count == 0)\n\t\treturn 0;\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!IS_ALIGNED(addr, 16) || addr >> maxphyaddr ||\n\t    (addr + count * sizeof(struct vmx_msr_entry) - 1) >> maxphyaddr) {\n\t\tpr_debug_ratelimited(\n\t\t\t\"nVMX: invalid MSR switch (0x%lx, %d, %llu, 0x%08llx)\",\n\t\t\taddr_field, maxphyaddr, count, addr);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nested_vmx_check_msr_switch_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tif (vmcs12->vm_exit_msr_load_count == 0 &&\n\t    vmcs12->vm_exit_msr_store_count == 0 &&\n\t    vmcs12->vm_entry_msr_load_count == 0)\n\t\treturn 0; /* Fast path */\n\tif (nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_LOAD_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_STORE_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_STORE_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_ENTRY_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_ENTRY_MSR_LOAD_ADDR))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_msr_check_common(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmx_msr_entry *e)\n{\n\t/* x2APIC MSR accesses are not allowed */\n\tif (vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8)\n\t\treturn -EINVAL;\n\tif (e->index == MSR_IA32_UCODE_WRITE || /* SDM Table 35-2 */\n\t    e->index == MSR_IA32_UCODE_REV)\n\t\treturn -EINVAL;\n\tif (e->reserved != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_load_msr_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct vmx_msr_entry *e)\n{\n\tif (e->index == MSR_FS_BASE ||\n\t    e->index == MSR_GS_BASE ||\n\t    e->index == MSR_IA32_SMM_MONITOR_CTL || /* SMM is not supported */\n\t    nested_vmx_msr_check_common(vcpu, e))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nested_vmx_store_msr_check(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct vmx_msr_entry *e)\n{\n\tif (e->index == MSR_IA32_SMBASE || /* SMM is not supported */\n\t    nested_vmx_msr_check_common(vcpu, e))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/*\n * Load guest's/host's msr at nested entry/exit.\n * return 0 for success, entry index for failure.\n */\nstatic u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}\n\nstatic int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool nested_cr3_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tunsigned long invalid_mask;\n\n\tinvalid_mask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\treturn (val & invalid_mask) == 0;\n}\n\n/*\n * Load guest's/host's cr3 at nested entry/exit. nested_ept is true if we are\n * emulating VM entry into a guest with EPT enabled.\n * Returns 0 on success, 1 on failure. Invalid state exit qualification code\n * is assigned to entry_failure_code on failure.\n */\nstatic int nested_vmx_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3, bool nested_ept,\n\t\t\t       unsigned long *entry_failure_code)\n{\n\tif (cr3 != kvm_read_cr3(vcpu) || (!nested_ept && pdptrs_changed(vcpu))) {\n\t\tif (!nested_cr3_valid(vcpu, cr3)) {\n\t\t\t*entry_failure_code = ENTRY_FAIL_DEFAULT;\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * If PAE paging and EPT are both on, CR3 is not used by the CPU and\n\t\t * must not be dereferenced.\n\t\t */\n\t\tif (!is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu) &&\n\t\t    !nested_ept) {\n\t\t\tif (!load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3)) {\n\t\t\t\t*entry_failure_code = ENTRY_FAIL_PDPTE;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tvcpu->arch.cr3 = cr3;\n\t\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\n/*\n * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested\n * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function \"merges\" it\n * with L0's requirements for its guest (a.k.a. vmcs01), so we can run the L2\n * guest in a way that will both be appropriate to L1's requests, and our\n * needs. In addition to modifying the active vmcs (which is vmcs02), this\n * function also has additional necessary side-effects, like setting various\n * vcpu->arch fields.\n * Returns 0 on success, 1 on failure. Invalid state exit qualification code\n * is assigned to entry_failure_code on failure.\n */\nstatic int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t  unsigned long *entry_failure_code)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\tbool nested_ept_enabled = false;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tif (nested_cpu_has_xsaves(vmcs12))\n\t\tvmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\n\t/* Preemption timer setting is only taken from vmcs01.  */\n\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\tif (vmx->hv_deadline_tsc == -1)\n\t\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/* Posted interrupts setting is only taken from vmcs12.  */\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\t/*\n\t\t * Note that we use L0's vector here and in\n\t\t * vmx_deliver_nested_posted_interrupt.\n\t\t */\n\t\tvmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;\n\t\tvmx->nested.pi_pending = false;\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR,\n\t\t\tpage_to_phys(vmx->nested.pi_desc_page) +\n\t\t\t(unsigned long)(vmcs12->posted_intr_desc_addr &\n\t\t\t(PAGE_SIZE - 1)));\n\t} else\n\t\texec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_RDTSCP |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\t\t  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (!(nested_cpu_has_virt_x2apic_mode(vmcs12)) &&\n\t\t\t    cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP0,\n\t\t\t\tvmcs12->eoi_exit_bitmap0);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP1,\n\t\t\t\tvmcs12->eoi_exit_bitmap1);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP2,\n\t\t\t\tvmcs12->eoi_exit_bitmap2);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP3,\n\t\t\t\tvmcs12->eoi_exit_bitmap3);\n\t\t\tvmcs_write16(GUEST_INTR_STATUS,\n\t\t\t\tvmcs12->guest_intr_status);\n\t\t}\n\n\t\tnested_ept_enabled = (exec_control & SECONDARY_EXEC_ENABLE_EPT) != 0;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * Set the MSR load/store lists to match L0's settings.\n\t */\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap() &&\n\t    exec_control & CPU_BASED_USE_MSR_BITMAPS &&\n\t    nested_vmx_merge_msr_bitmap(vcpu, vmcs12))\n\t\t; /* MSR_BITMAP will be set by following vmx_set_efer. */\n\telse\n\t\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\n\t/*\n\t * Merging of IO bitmap not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvcpu->arch.tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * There is no direct mapping between vpid02 and vpid12, the\n\t\t * vpid02 is per-vCPU for L0 and reused while the value of\n\t\t * vpid12 is changed w/ one invvpid during nested vmentry.\n\t\t * The vpid12 is allocated by L1 for L2, so it will not\n\t\t * influence global bitmap(for vpid01 and vpid02 allocation)\n\t\t * even if spawn a lot of nested vCPUs.\n\t\t */\n\t\tif (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);\n\t\t\tif (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {\n\t\t\t\tvmx->nested.last_vpid = vmcs12->virtual_processor_id;\n\t\t\t\t__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);\n\t\t\t}\n\t\t} else {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\t\tvmx_flush_tlb(vcpu);\n\t\t}\n\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/* Shadow page tables on either EPT or shadow page tables. */\n\tif (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_ept_enabled,\n\t\t\t\tentry_failure_code))\n\t\treturn 1;\n\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n\treturn 0;\n}\n\n/*\n * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1\n * for running an L2 nested guest.\n */\nstatic int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\tstruct loaded_vmcs *vmcs02;\n\tbool ia32e;\n\tu32 msr_entry_idx;\n\tunsigned long exit_qualification;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\tgoto out;\n\n\tvmcs12 = get_vmcs12(vcpu);\n\n\tif (enable_shadow_vmcs)\n\t\tcopy_shadow_to_vmcs12(vmx);\n\n\t/*\n\t * The nested entry process starts with enforcing various prerequisites\n\t * on vmcs12 as required by the Intel SDM, and act appropriately when\n\t * they fail: As the SDM explains, some conditions should cause the\n\t * instruction to fail, while others will cause the instruction to seem\n\t * to succeed, but return an EXIT_REASON_INVALID_STATE.\n\t * To speed up the normal (success) code path, we should avoid checking\n\t * for misconfigurations which will anyway be caught by the processor\n\t * when using the merged vmcs02.\n\t */\n\tif (vmcs12->launch_state == launch) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tlaunch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS\n\t\t\t       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);\n\t\tgoto out;\n\t}\n\n\tif (vmcs12->guest_activity_state != GUEST_ACTIVITY_ACTIVE &&\n\t    vmcs12->guest_activity_state != GUEST_ACTIVITY_HLT) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_get_vmcs12_pages(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_msr_bitmap_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_apicv_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (nested_vmx_check_msr_switch_controls(vcpu, vmcs12)) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_procbased_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_procbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->secondary_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_secondary_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->pin_based_vm_exec_control,\n\t\t\t\tvmx->nested.nested_vmx_pinbased_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_pinbased_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_exit_controls,\n\t\t\t\tvmx->nested.nested_vmx_exit_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_exit_ctls_high) ||\n\t    !vmx_control_verify(vmcs12->vm_entry_controls,\n\t\t\t\tvmx->nested.nested_vmx_entry_ctls_low,\n\t\t\t\tvmx->nested.nested_vmx_entry_ctls_high))\n\t{\n\t\tnested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_host_cr0_valid(vcpu, vmcs12->host_cr0) ||\n\t    !nested_host_cr4_valid(vcpu, vmcs12->host_cr4) ||\n\t    !nested_cr3_valid(vcpu, vmcs12->host_cr3)) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\tVMXERR_ENTRY_INVALID_HOST_STATE_FIELD);\n\t\tgoto out;\n\t}\n\n\tif (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||\n\t    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\tgoto out;\n\t}\n\tif (vmcs12->vmcs_link_pointer != -1ull) {\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_VMCS_LINK_PTR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-entry control is 1, the following checks\n\t * are performed on the field for the IA32_EFER MSR:\n\t * - Bits reserved in the IA32_EFER MSR must be 0.\n\t * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of\n\t *   the IA-32e mode guest VM-exit control. It must also be identical\n\t *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to\n\t *   CR0.PG) is 1.\n\t */\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the load IA32_EFER VM-exit control is 1, bits reserved in the\n\t * IA32_EFER MSR must be 0 in the field for that register. In addition,\n\t * the values of the LMA and LME bits in the field must each be that of\n\t * the host address-space size VM-exit control.\n\t */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME)) {\n\t\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We're finally done with prerequisite checking, and can start with\n\t * the nested entry.\n\t */\n\n\tvmcs02 = nested_get_current_vmcs02(vmx);\n\tif (!vmcs02)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * After this point, the trap flag no longer triggers a singlestep trap\n\t * on the vm entry instructions. Don't call\n\t * kvm_skip_emulated_instruction.\n\t */\n\tskip_emulated_instruction(vcpu);\n\tenter_guest_mode(vcpu);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = vmcs02;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (prepare_vmcs02(vcpu, vmcs12, &exit_qualification)) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_load_vmcs01(vcpu);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_INVALID_STATE, exit_qualification);\n\t\treturn 1;\n\t}\n\n\tmsr_entry_idx = nested_vmx_load_msr(vcpu,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_addr,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_count);\n\tif (msr_entry_idx) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_load_vmcs01(vcpu);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_MSR_LOAD_FAIL, msr_entry_idx);\n\t\treturn 1;\n\t}\n\n\tvmcs12->launch_state = 1;\n\n\tif (vmcs12->guest_activity_state == GUEST_ACTIVITY_HLT)\n\t\treturn kvm_vcpu_halt(vcpu);\n\n\tvmx->nested.nested_run_pending = 1;\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn 1;\n\nout:\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\n/*\n * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date\n * because L2 may have changed some cr0 bits directly (CRO_GUEST_HOST_MASK).\n * This function returns the new value we should put in vmcs12.guest_cr0.\n * It's not enough to just return the vmcs02 GUEST_CR0. Rather,\n *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now\n *     available in vmcs02 GUEST_CR0. (Note: It's enough to check that L0\n *     didn't trap the bit, because if L1 did, so would L0).\n *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have\n *     been modified by L2, and L1 knows it. So just leave the old value of\n *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0\n *     isn't relevant, because if L0 traps this bit it can set it to anything.\n *  3. Bits that L1 didn't trap, but L0 did. L1 believes the guest could have\n *     changed these bits, and therefore they need to be updated, but L0\n *     didn't necessarily allow them to be changed in GUEST_CR0 - and rather\n *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.\n */\nstatic inline unsigned long\nvmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |\n\t\t\tvcpu->arch.cr0_guest_owned_bits));\n}\n\nstatic inline unsigned long\nvmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t/*1*/\t(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |\n\t/*2*/\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask) |\n\t/*3*/\t(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |\n\t\t\tvcpu->arch.cr4_guest_owned_bits));\n}\n\nstatic void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tu32 idt_vectoring;\n\tunsigned int nr;\n\n\tif (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) {\n\t\tnr = vcpu->arch.exception.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (kvm_exception_is_soft(nr)) {\n\t\t\tvmcs12->vm_exit_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_EXCEPTION;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_HARD_EXCEPTION;\n\n\t\tif (vcpu->arch.exception.has_error_code) {\n\t\t\tidt_vectoring |= VECTORING_INFO_DELIVER_CODE_MASK;\n\t\t\tvmcs12->idt_vectoring_error_code =\n\t\t\t\tvcpu->arch.exception.error_code;\n\t\t}\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t} else if (vcpu->arch.nmi_injected) {\n\t\tvmcs12->idt_vectoring_info_field =\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR;\n\t} else if (vcpu->arch.interrupt.pending) {\n\t\tnr = vcpu->arch.interrupt.nr;\n\t\tidt_vectoring = nr | VECTORING_INFO_VALID_MASK;\n\n\t\tif (vcpu->arch.interrupt.soft) {\n\t\t\tidt_vectoring |= INTR_TYPE_SOFT_INTR;\n\t\t\tvmcs12->vm_entry_instruction_len =\n\t\t\t\tvcpu->arch.event_exit_inst_len;\n\t\t} else\n\t\t\tidt_vectoring |= INTR_TYPE_EXT_INTR;\n\n\t\tvmcs12->idt_vectoring_info_field = idt_vectoring;\n\t}\n}\n\nstatic int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending ||\n\t\t    vcpu->arch.interrupt.pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\t/*\n\t\t * The NMI-triggered VM exit counts as injection:\n\t\t * clear this one and block further NMIs.\n\t\t */\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\n\treturn vmx_complete_nested_posted_interrupt(vcpu);\n}\n\nstatic u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)\n{\n\tktime_t remaining =\n\t\thrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);\n\tu64 value;\n\n\tif (ktime_to_ns(remaining) <= 0)\n\t\treturn 0;\n\n\tvalue = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;\n\tdo_div(value, 1000000);\n\treturn value >> VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;\n}\n\n/*\n * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits\n * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),\n * and this function updates it to reflect the changes to the guest state while\n * L2 was running (and perhaps made some exits which were handled directly by L0\n * without going back to L1), and to reflect the exit reason.\n * Note that we do not have to copy here all VMCS fields, just those that\n * could have changed by the L2 guest or the exit - i.e., the guest-state and\n * exit-information fields only. Other fields are modified by L1 with VMWRITE,\n * which already writes to vmcs12 directly.\n */\nstatic void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t   u32 exit_reason, u32 exit_intr_info,\n\t\t\t   unsigned long exit_qualification)\n{\n\t/* update guest state fields: */\n\tvmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);\n\tvmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);\n\n\tvmcs12->guest_rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tvmcs12->guest_rip = kvm_register_read(vcpu, VCPU_REGS_RIP);\n\tvmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);\n\n\tvmcs12->guest_es_selector = vmcs_read16(GUEST_ES_SELECTOR);\n\tvmcs12->guest_cs_selector = vmcs_read16(GUEST_CS_SELECTOR);\n\tvmcs12->guest_ss_selector = vmcs_read16(GUEST_SS_SELECTOR);\n\tvmcs12->guest_ds_selector = vmcs_read16(GUEST_DS_SELECTOR);\n\tvmcs12->guest_fs_selector = vmcs_read16(GUEST_FS_SELECTOR);\n\tvmcs12->guest_gs_selector = vmcs_read16(GUEST_GS_SELECTOR);\n\tvmcs12->guest_ldtr_selector = vmcs_read16(GUEST_LDTR_SELECTOR);\n\tvmcs12->guest_tr_selector = vmcs_read16(GUEST_TR_SELECTOR);\n\tvmcs12->guest_es_limit = vmcs_read32(GUEST_ES_LIMIT);\n\tvmcs12->guest_cs_limit = vmcs_read32(GUEST_CS_LIMIT);\n\tvmcs12->guest_ss_limit = vmcs_read32(GUEST_SS_LIMIT);\n\tvmcs12->guest_ds_limit = vmcs_read32(GUEST_DS_LIMIT);\n\tvmcs12->guest_fs_limit = vmcs_read32(GUEST_FS_LIMIT);\n\tvmcs12->guest_gs_limit = vmcs_read32(GUEST_GS_LIMIT);\n\tvmcs12->guest_ldtr_limit = vmcs_read32(GUEST_LDTR_LIMIT);\n\tvmcs12->guest_tr_limit = vmcs_read32(GUEST_TR_LIMIT);\n\tvmcs12->guest_gdtr_limit = vmcs_read32(GUEST_GDTR_LIMIT);\n\tvmcs12->guest_idtr_limit = vmcs_read32(GUEST_IDTR_LIMIT);\n\tvmcs12->guest_es_ar_bytes = vmcs_read32(GUEST_ES_AR_BYTES);\n\tvmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);\n\tvmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);\n\tvmcs12->guest_ds_ar_bytes = vmcs_read32(GUEST_DS_AR_BYTES);\n\tvmcs12->guest_fs_ar_bytes = vmcs_read32(GUEST_FS_AR_BYTES);\n\tvmcs12->guest_gs_ar_bytes = vmcs_read32(GUEST_GS_AR_BYTES);\n\tvmcs12->guest_ldtr_ar_bytes = vmcs_read32(GUEST_LDTR_AR_BYTES);\n\tvmcs12->guest_tr_ar_bytes = vmcs_read32(GUEST_TR_AR_BYTES);\n\tvmcs12->guest_es_base = vmcs_readl(GUEST_ES_BASE);\n\tvmcs12->guest_cs_base = vmcs_readl(GUEST_CS_BASE);\n\tvmcs12->guest_ss_base = vmcs_readl(GUEST_SS_BASE);\n\tvmcs12->guest_ds_base = vmcs_readl(GUEST_DS_BASE);\n\tvmcs12->guest_fs_base = vmcs_readl(GUEST_FS_BASE);\n\tvmcs12->guest_gs_base = vmcs_readl(GUEST_GS_BASE);\n\tvmcs12->guest_ldtr_base = vmcs_readl(GUEST_LDTR_BASE);\n\tvmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);\n\tvmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);\n\tvmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);\n\n\tvmcs12->guest_interruptibility_info =\n\t\tvmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tvmcs12->guest_pending_dbg_exceptions =\n\t\tvmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;\n\telse\n\t\tvmcs12->guest_activity_state = GUEST_ACTIVITY_ACTIVE;\n\n\tif (nested_cpu_has_preemption_timer(vmcs12)) {\n\t\tif (vmcs12->vm_exit_controls &\n\t\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER)\n\t\t\tvmcs12->vmx_preemption_timer_value =\n\t\t\t\tvmx_get_preemption_timer_value(vcpu);\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\t}\n\n\t/*\n\t * In some cases (usually, nested EPT), L2 is allowed to change its\n\t * own CR3 without exiting. If it has changed it, we must keep it.\n\t * Of course, if L0 is using shadow page tables, GUEST_CR3 was defined\n\t * by L0, not L1 or L2, so we mustn't unconditionally copy it to vmcs12.\n\t *\n\t * Additionally, restore L2's PDPTR to vmcs12.\n\t */\n\tif (enable_ept) {\n\t\tvmcs12->guest_cr3 = vmcs_readl(GUEST_CR3);\n\t\tvmcs12->guest_pdptr0 = vmcs_read64(GUEST_PDPTR0);\n\t\tvmcs12->guest_pdptr1 = vmcs_read64(GUEST_PDPTR1);\n\t\tvmcs12->guest_pdptr2 = vmcs_read64(GUEST_PDPTR2);\n\t\tvmcs12->guest_pdptr3 = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12))\n\t\tvmcs12->guest_linear_address = vmcs_readl(GUEST_LINEAR_ADDRESS);\n\n\tif (nested_cpu_has_vid(vmcs12))\n\t\tvmcs12->guest_intr_status = vmcs_read16(GUEST_INTR_STATUS);\n\n\tvmcs12->vm_entry_controls =\n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_IA32E_MODE) |\n\t\t(vm_entry_controls_get(to_vmx(vcpu)) & VM_ENTRY_IA32E_MODE);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_DEBUG_CONTROLS) {\n\t\tkvm_get_dr(vcpu, 7, (unsigned long *)&vmcs12->guest_dr7);\n\t\tvmcs12->guest_ia32_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t}\n\n\t/* TODO: These cannot have changed unless we have MSR bitmaps and\n\t * the relevant bit asks not to trap the change */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\tvmcs12->guest_ia32_pat = vmcs_read64(GUEST_IA32_PAT);\n\tif (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)\n\t\tvmcs12->guest_ia32_efer = vcpu->arch.efer;\n\tvmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);\n\tvmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);\n\tvmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);\n\tif (kvm_mpx_supported())\n\t\tvmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\tif (nested_cpu_has_xsaves(vmcs12))\n\t\tvmcs12->xss_exit_bitmap = vmcs_read64(XSS_EXIT_BITMAP);\n\n\t/* update exit information fields: */\n\n\tvmcs12->vm_exit_reason = exit_reason;\n\tvmcs12->exit_qualification = exit_qualification;\n\n\tvmcs12->vm_exit_intr_info = exit_intr_info;\n\tif ((vmcs12->vm_exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK))\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\tvmcs12->idt_vectoring_info_field = 0;\n\tvmcs12->vm_exit_instruction_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tvmcs12->vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\n\tif (!(vmcs12->vm_exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY)) {\n\t\t/* vm_entry_intr_info_field is cleared on exit. Emulate this\n\t\t * instead of reading the real value. */\n\t\tvmcs12->vm_entry_intr_info_field &= ~INTR_INFO_VALID_MASK;\n\n\t\t/*\n\t\t * Transfer the event that L0 or L1 may wanted to inject into\n\t\t * L2 to IDT_VECTORING_INFO_FIELD.\n\t\t */\n\t\tvmcs12_save_pending_event(vcpu, vmcs12);\n\t}\n\n\t/*\n\t * Drop what we picked up for L2 via vmx_complete_interrupts. It is\n\t * preserved above and would only end up incorrectly in L1.\n\t */\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n}\n\n/*\n * A part of what we need to when the nested L2 guest exits and we want to\n * run its L1 parent, is to reset L1's guest state to the host state specified\n * in vmcs12.\n * This function is to be called not only on normal nested exit, but also on\n * a nested entry failure, as explained in Intel's spec, 3B.23.7 (\"VM-Entry\n * Failures During or After Loading Guest State\").\n * This function should be called when the active VMCS is L1's (vmcs01).\n */\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12)\n{\n\tstruct kvm_segment seg;\n\tunsigned long entry_failure_code;\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->host_ia32_efer;\n\telse if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->host_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->host_rip);\n\tvmx_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\t/*\n\t * Note that calling vmx_set_cr0 is important, even if cr0 hasn't\n\t * actually changed, because it depends on the current state of\n\t * fpu_active (which may have changed).\n\t * Note that vmx_set_cr0 refers to efer set above.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->host_cr0);\n\t/*\n\t * If we did fpu_activate()/fpu_deactivate() during L2's run, we need\n\t * to apply the same changes to L1's vmcs. We just set cr0 correctly,\n\t * but we also need to update cr0_guest_host_mask and exception_bitmap.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits = (vcpu->fpu_active ? X86_CR0_TS : 0);\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/*\n\t * Note that CR4_GUEST_HOST_MASK is already set in the original vmcs01\n\t * (KVM doesn't change it)- no reason to call set_cr4_guest_host_mask();\n\t */\n\tvcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);\n\tkvm_set_cr4(vcpu, vmcs12->host_cr4);\n\n\tnested_ept_uninit_mmu_context(vcpu);\n\n\t/*\n\t * Only PDPTE load can fail as the value of cr3 was checked on entry and\n\t * couldn't have changed.\n\t */\n\tif (nested_vmx_load_cr3(vcpu, vmcs12->host_cr3, false, &entry_failure_code))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_PDPTE_FAIL);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = kvm_inject_page_fault;\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->host_idtr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->host_gdtr_base);\n\n\t/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */\n\tif (vmcs12->vm_exit_controls & VM_EXIT_CLEAR_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->host_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->host_ia32_pat;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tvmcs_write64(GUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\tvmcs12->host_ia32_perf_global_ctrl);\n\n\t/* Set L1 segment info according to Intel SDM\n\t    27.5.2 Loading Host Segment and Descriptor-Table Registers */\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.selector = vmcs12->host_cs_selector,\n\t\t.type = 11,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.g = 1\n\t};\n\tif (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)\n\t\tseg.l = 1;\n\telse\n\t\tseg.db = 1;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_CS);\n\tseg = (struct kvm_segment) {\n\t\t.base = 0,\n\t\t.limit = 0xFFFFFFFF,\n\t\t.type = 3,\n\t\t.present = 1,\n\t\t.s = 1,\n\t\t.db = 1,\n\t\t.g = 1\n\t};\n\tseg.selector = vmcs12->host_ds_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_DS);\n\tseg.selector = vmcs12->host_es_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_ES);\n\tseg.selector = vmcs12->host_ss_selector;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_SS);\n\tseg.selector = vmcs12->host_fs_selector;\n\tseg.base = vmcs12->host_fs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_FS);\n\tseg.selector = vmcs12->host_gs_selector;\n\tseg.base = vmcs12->host_gs_base;\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_GS);\n\tseg = (struct kvm_segment) {\n\t\t.base = vmcs12->host_tr_base,\n\t\t.limit = 0x67,\n\t\t.selector = vmcs12->host_tr_selector,\n\t\t.type = 11,\n\t\t.present = 1\n\t};\n\tvmx_set_segment(vcpu, &seg, VCPU_SREG_TR);\n\n\tkvm_set_dr(vcpu, 7, 0x400);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n\n\tif (nested_vmx_load_msr(vcpu, vmcs12->vm_exit_msr_load_addr,\n\t\t\t\tvmcs12->vm_exit_msr_load_count))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_MSR_FAIL);\n}\n\n/*\n * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1\n * and modify vmcs12 to make it see what it would expect to see there if\n * L2 was its real guest. Must only be called when in L2 (is_guest_mode())\n */\nstatic void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t\t      u32 exit_intr_info,\n\t\t\t      unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 vm_inst_error = 0;\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t       exit_qualification);\n\n\tif (nested_vmx_store_msr(vcpu, vmcs12->vm_exit_msr_store_addr,\n\t\t\t\t vmcs12->vm_exit_msr_store_count))\n\t\tnested_vmx_abort(vcpu, VMX_ABORT_SAVE_GUEST_MSR_FAIL);\n\n\tif (unlikely(vmx->fail))\n\t\tvm_inst_error = vmcs_read32(VM_INSTRUCTION_ERROR);\n\n\tvmx_load_vmcs01(vcpu);\n\n\tif ((exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t    && nested_exit_intr_ack_set(vcpu)) {\n\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\tWARN_ON(irq < 0);\n\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t}\n\n\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t       KVM_ISA_VMX);\n\n\tvm_entry_controls_reset_shadow(vmx);\n\tvm_exit_controls_reset_shadow(vmx);\n\tvmx_segment_cache_clear(vmx);\n\n\t/* if no vmcs02 cache requested, remove the one we used */\n\tif (VMCS02_POOL_SIZE == 0)\n\t\tnested_free_vmcs02(vmx, vmx->nested.current_vmptr);\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->hv_deadline_tsc == -1)\n\t\tvmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n\telse\n\t\tvmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\t      PIN_BASED_VMX_PREEMPTION_TIMER);\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_x2apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_x2apic_mode = false;\n\t\tvmx_set_virtual_x2apic_mode(vcpu,\n\t\t\t\tvcpu->arch.apic_base & X2APIC_ENABLE);\n\t}\n\n\t/* This is needed for same reason as it was needed in prepare_vmcs02 */\n\tvmx->host_rsp = 0;\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\t/*\n\t * Exiting from L2 to L1, we're now back to L1 which thinks it just\n\t * finished a VMLAUNCH or VMRESUME instruction, so we need to set the\n\t * success or failure flag accordingly.\n\t */\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->fail = 0;\n\t\tnested_vmx_failValid(vcpu, vm_inst_error);\n\t} else\n\t\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tvmx->nested.sync_shadow_vmcs = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\n/*\n * Forcibly leave nested mode in order to be able to reset the VCPU later on.\n */\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\tfree_nested(to_vmx(vcpu));\n}\n\n/*\n * L1's failure to enter L2 is a subset of a normal exit, as explained in\n * 23.7 \"VM-entry failures during or after loading guest state\" (this also\n * lists the acceptable exit-reason and exit-qualification parameters).\n * It should only be called before L2 actually succeeded to run, and when\n * vmcs01 is current (it doesn't leave_guest_mode() or switch vmcss).\n */\nstatic void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\treturn X86EMUL_CONTINUE;\n}\n\n#ifdef CONFIG_X86_64\n/* (a << shift) / divisor, return 1 if overflow otherwise 0 */\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}\n\nstatic int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl = rdtsc();\n\tu64 guest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tu64 delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t\t\tu64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.tsc_scaling_ratio,\n\t\t\t\t&delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\tvmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n\treturn 0;\n}\n\nstatic void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmx->hv_deadline_tsc = -1;\n\tvmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n}\n#endif\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (ple_gap)\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic void vmx_slot_enable_log_dirty(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_leaf_clear_dirty(kvm, slot);\n\tkvm_mmu_slot_largepage_remove_write_access(kvm, slot);\n}\n\nstatic void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}\n\nstatic void vmx_flush_log_dirty(struct kvm *kvm)\n{\n\tkvm_flush_pml_buffers(kvm);\n}\n\nstatic void vmx_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_memory_slot *memslot,\n\t\t\t\t\t   gfn_t offset, unsigned long mask)\n{\n\tkvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);\n}\n\n/*\n * This routine does the following things for vCPU which is going\n * to be blocked if VT-d PI is enabled.\n * - Store the vCPU to the wakeup list, so when interrupts happen\n *   we can find the right vCPU to wake up.\n * - Change the Posted-interrupt descriptor as below:\n *      'NDST' <-- vcpu->pre_pcpu\n *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR\n * - If 'ON' is set during this process, which means at least one\n *   interrupt is posted for this vCPU, we cannot block it, in\n *   this case, return 1, otherwise, return 0.\n *\n */\nstatic int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tvcpu->pre_pcpu = vcpu->cpu;\n\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t  vcpu->pre_pcpu), flags);\n\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t      vcpu->pre_pcpu));\n\tspin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t       vcpu->pre_pcpu), flags);\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\t/*\n\t\t * We should not block the vCPU if\n\t\t * an interrupt is posted for it.\n\t\t */\n\t\tif (pi_test_on(pi_desc) == 1) {\n\t\t\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\t  vcpu->pre_pcpu), flags);\n\t\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\tvcpu->pre_pcpu), flags);\n\t\t\tvcpu->pre_pcpu = -1;\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n\n\treturn 0;\n}\n\nstatic int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n\tif (pi_pre_block(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\treturn 0;\n}\n\nstatic void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\tunsigned long flags;\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* Allow posting non-urgent interrupts */\n\t\tnew.sn = 0;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n\n\tif(vcpu->pre_pcpu != -1) {\n\t\tspin_lock_irqsave(\n\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\tvcpu->pre_pcpu), flags);\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock_irqrestore(\n\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\tvcpu->pre_pcpu), flags);\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}\n\nstatic void vmx_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops->set_hv_timer)\n\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\tpi_post_block(vcpu);\n}\n\n/*\n * vmx_update_pi_irte - set IRTE for Posted-Interrupts\n *\n * @kvm: kvm\n * @host_irq: host irq of the interrupt\n * @guest_irq: gsi of the interrupt\n * @set: set or unset PI\n * returns 0 on success, < 0 on failure\n */\nstatic int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = -EINVAL;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tBUG_ON(guest_irq >= irq_rt->nr_rt_entries);\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse {\n\t\t\t/* suppress notification event before unposting */\n\t\t\tpi_set_sn(vcpu_to_pi_desc(vcpu));\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tpi_clear_sn(vcpu_to_pi_desc(vcpu));\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}\n\nstatic void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEATURE_CONTROL_LMCE;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEATURE_CONTROL_LMCE;\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops __ro_after_init = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.hardware_setup = hardware_setup,\n\t.hardware_unsetup = hardware_unsetup,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_enable = hardware_enable,\n\t.hardware_disable = hardware_disable,\n\t.cpu_has_accelerated_tpr = report_flexpriority,\n\t.cpu_has_high_real_mode_segbase = vmx_has_high_real_mode_segbase,\n\n\t.vcpu_create = vmx_create_vcpu,\n\t.vcpu_free = vmx_free_vcpu,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_guest_switch = vmx_save_host_state,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_bp_intercept = update_exception_bitmap,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.decache_cr0_guest_bits = vmx_decache_cr0_guest_bits,\n\t.decache_cr3 = vmx_decache_cr3,\n\t.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.set_cr3 = vmx_set_cr3,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.get_dr6 = vmx_get_dr6,\n\t.set_dr6 = vmx_set_dr6,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\n\t.get_pkru = vmx_get_pkru,\n\n\t.fpu_activate = vmx_fpu_activate,\n\t.fpu_deactivate = vmx_fpu_deactivate,\n\n\t.tlb_flush = vmx_flush_tlb,\n\n\t.run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = skip_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.set_irq = vmx_inject_irq,\n\t.set_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = enable_nmi_window,\n\t.enable_irq_window = enable_irq_window,\n\t.update_cr8_intercept = update_cr8_intercept,\n\t.set_virtual_x2apic_mode = vmx_set_virtual_x2apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.get_enable_apicv = vmx_get_enable_apicv,\n\t.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_posted_interrupt = vmx_deliver_posted_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.get_tdp_level = get_ept_level,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.get_lpage_level = vmx_get_lpage_level,\n\n\t.cpuid_update = vmx_cpuid_update,\n\n\t.rdtscp_supported = vmx_rdtscp_supported,\n\t.invpcid_supported = vmx_invpcid_supported,\n\n\t.set_supported_cpuid = vmx_set_supported_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\n\t.set_tdp_cr3 = vmx_set_cr3,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_external_intr = vmx_handle_external_intr,\n\t.mpx_supported = vmx_mpx_supported,\n\t.xsaves_supported = vmx_xsaves_supported,\n\n\t.check_nested_events = vmx_check_nested_events,\n\n\t.sched_in = vmx_sched_in,\n\n\t.slot_enable_log_dirty = vmx_slot_enable_log_dirty,\n\t.slot_disable_log_dirty = vmx_slot_disable_log_dirty,\n\t.flush_log_dirty = vmx_flush_log_dirty,\n\t.enable_log_dirty_pt_masked = vmx_enable_log_dirty_pt_masked,\n\n\t.pre_block = vmx_pre_block,\n\t.post_block = vmx_post_block,\n\n\t.pmu_ops = &intel_pmu_ops,\n\n\t.update_pi_irte = vmx_update_pi_irte,\n\n#ifdef CONFIG_X86_64\n\t.set_hv_timer = vmx_set_hv_timer,\n\t.cancel_hv_timer = vmx_cancel_hv_timer,\n#endif\n\n\t.setup_mce = vmx_setup_mce,\n};\n\nstatic int __init vmx_init(void)\n{\n\tint r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),\n                     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n}\n\nmodule_init(vmx_init)\nmodule_exit(vmx_exit)\n"], "filenames": ["arch/x86/kvm/vmx.c"], "buggy_code_start_loc": [1392], "buggy_code_end_loc": [8770], "fixing_code_start_loc": [1392], "fixing_code_end_loc": [8769], "type": "CWE-388", "message": "arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest.", "other": {"cve": {"id": "CVE-2016-9588", "sourceIdentifier": "secalert@redhat.com", "published": "2016-12-28T07:59:00.353", "lastModified": "2023-02-12T23:27:20.753", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest."}, {"lang": "es", "value": "arch/x86/kvm/vmx.c en el kernek de Linux hasta la versi\u00f3n 4.9 no gestiona adecuadamente las excepciones #BP y #OF, lo que permite a usuarios del SO invitados provocar una denegaci\u00f3n de servicio (ca\u00edda del SO invitado) declinando el manejo de una excepci\u00f3n lanzada por un invitado L2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-388"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9", "matchCriteriaId": "C078FF02-3FD1-41D4-AB11-F63F20B93EB0"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ef85b67385436ddc1998f45f1d6a210f935b3388", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3804", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/15/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/94933", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1404924", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/3822-1/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3822-2/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388"}}