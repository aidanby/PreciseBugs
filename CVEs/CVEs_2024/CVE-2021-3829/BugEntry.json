{"buggy_code": ["var http = require('http');\nvar querystring = require('querystring');\nvar errorTemplate = require('../templates/error.js');\nconst snip = require('../snip.js');\n\nconst genReqLogLine = ({ head, method, path, params, suffix }) =>\n  !process.appParams.color\n    ? [\n        head,\n        method,\n        path[0] + (path.length > 1 ? '?' + path.slice(1).join('?') : ''),\n        suffix,\n        params,\n      ]\n    : [\n        head.grey,\n        method.cyan,\n        path[0].green +\n          (path.length > 1 ? '?' + path.slice(1).join('?') : '').yellow,\n        suffix.white,\n        params.grey,\n      ];\n\nhttp.IncomingMessage.prototype.logToConsole = function (suffix, params) {\n  console.log(\n    ...genReqLogLine({\n      head: '\u25b6 ' + new Date().toISOString(),\n      method: this.method,\n      path: this.url.split('?'),\n      params:\n        typeof params === 'object'\n          ? JSON.stringify(snip.formatPrivateFields(params))\n          : '',\n      suffix: suffix ? '(' + suffix + ')' : '',\n    })\n  );\n};\n\nvar config = require('./config.js');\nvar mongodb = require('./mongodb.js');\nvar loggingTemplate = require('../templates/logging.js');\nvar renderUnauthorizedPage = loggingTemplate.renderUnauthorizedPage;\n\n// ========= USER AGENT STUFF\n\n/**\n * Gets the http referer of a request\n */\nhttp.IncomingMessage.prototype.getReferer = function () {\n  return this.headers['referrer'] || this.headers['referer'];\n};\n\n// ========= COOKIE STUFF\n\n/**\n * Generates a user session cookie string\n * that can be supplied to a Set-Cookie HTTP header.\n */\n/*\nexports.makeCookie = function(user) {\n\tvar date = new Date((new Date()).getTime() + 1000 * 60 * 60 * 24 * 365);\n\treturn 'whydUid=\"'+(user.id || '')+'\"; Expires=' + date.toGMTString();\n};\n*/\n\n/**\n * Transforms cookies found in the request into an object\n */\nhttp.IncomingMessage.prototype.getCookies = (function () {\n  //var cookieReg = /([^=\\s]+)=\"([^\"]*)\"/;\n  return function () {\n    //console.log(\"cookies raw:\", this.headers.cookie);\n    if (!this.headers.cookie) return null;\n    var cookiesArray = this.headers.cookie.split(';');\n    //console.log(\"cookies array:\", cookiesArray);\n    var cookies = {};\n    for (let i = 0; i < cookiesArray.length; i++) {\n      //var match = cookiesArray[i].trim().match(cookieReg);\n      //if (match)\n      cookiesArray[i] = cookiesArray[i].trim();\n      var separ = cookiesArray[i].indexOf('=');\n      if (separ > 0)\n        cookies[cookiesArray[i].substr(0, separ)] = cookiesArray[i].substring(\n          separ + 1\n        );\n    }\n    //console.log(\"cookies object:\", cookies);\n    return cookies;\n  };\n})();\n\n/**\n * Return facebook's \"fbs_\" cookie object from the request\n */\nhttp.IncomingMessage.prototype.getFacebookCookie = function () {\n  var cookies = this.getCookies();\n  //console.log(\"cookies:\", cookies);\n  for (let i in cookies)\n    if (i.startsWith('fbs_')) {\n      const cookie = {},\n        cookieArray = cookies[i].split('&');\n      for (let j in cookieArray) {\n        var cookieItem = cookieArray[j].split('=');\n        cookie[cookieItem[0]] = cookieItem[1];\n      }\n      console.log('found facebook cookie'); //, cookie);\n      return cookie;\n    } else if (i.startsWith('fbsr_')) {\n      // https://developers.facebook.com/docs/authentication/signed_request/\n      try {\n        let cookie = cookies[i].split('.')[1];\n        cookie = Buffer.from(cookie /*|| \"\"*/, 'base64').toString('ascii');\n        cookie = JSON.parse(cookie);\n        console.log('found secure facebook cookie'); //, cookie);\n        return cookie;\n      } catch (e) {\n        console.log('secure facebook connect error: ', e);\n      }\n    }\n  return null;\n};\n\n// ========= USER ACCESSORS\n\n/**\n * Returns the logged in user's facebook uid, from its cookie\n */\nhttp.IncomingMessage.prototype.getFbUid = function () {\n  var fbCookie = this.getFacebookCookie();\n  if (fbCookie && fbCookie.uid)\n    this.getFbUid = function () {\n      return fbCookie.uid;\n    };\n  else if (fbCookie && fbCookie.user_id)\n    this.getFbUid = function () {\n      return fbCookie.user_id;\n    };\n  else return null;\n  return this.getFbUid();\n};\n\n/**\n * Returns the logged in user's uid, from its openwhyd session cookie\n */\nhttp.IncomingMessage.prototype.getUid = function () {\n  /*\n\tvar uid = (this.getCookies() || {})[\"whydUid\"];\n\tif (uid) uid = uid.replace(/\\\"/g, \"\");\n\t//if (uid) console.log(\"found openwhyd session cookie\", uid);\n\treturn uid;\n\t*/\n  return (this.session || {}).whydUid;\n};\n\n/**\n * Returns the logged in user as an object {_id, id, fbId, name, img}\n */\nhttp.IncomingMessage.prototype.getUser = function () {\n  var uid = this.getUid();\n  if (uid) {\n    var user = mongodb.usernames[uid];\n    if (user) user.id = '' + user._id;\n    return user;\n  } else return null;\n};\n\n//http.IncomingMessage.prototype.getUserFromFbUid = mongodb.getUserFromFbUid;\n\nhttp.IncomingMessage.prototype.getUserFromId = mongodb.getUserFromId;\n\nhttp.IncomingMessage.prototype.getUserNameFromId = mongodb.getUserNameFromId;\n\n// ========= LOGIN/SESSION/PRIVILEGES STUFF\n\n/**\n * Checks that a registered user is logged in, and return that user, or show an error page\n */\nhttp.IncomingMessage.prototype.checkLogin = function (response, format) {\n  var user = this.getUser();\n  //console.log(\"checkLogin, cached record for logged in user: \", user);\n  if (!user /*|| !user.name*/) {\n    if (response) {\n      if (format && format.toLowerCase() == 'json')\n        errorTemplate.renderErrorResponse(\n          { errorCode: 'REQ_LOGIN' },\n          response,\n          'json'\n        );\n      else response.renderHTML(renderUnauthorizedPage());\n    }\n    return false;\n  }\n  return user;\n};\n\nhttp.IncomingMessage.prototype.isUserAdmin = exports.isUserAdmin = function (\n  user\n) {\n  return user.email && config.adminEmails[user.email];\n};\n\nhttp.IncomingMessage.prototype.isAdmin = function () {\n  return this.isUserAdmin(this.getUser());\n};\n\nhttp.IncomingMessage.prototype.checkAdmin = function (response, format) {\n  var user = this.checkLogin(response, format);\n  if (!user) return false;\n  else if (!exports.isUserAdmin(user)) {\n    console.log(\n      'access restricted, user is not an admin: ',\n      user._id || user.id\n    );\n    response && response.legacyRender('nice try! ;-)');\n    return false;\n  }\n  return user;\n};\n\n// ========= HTTP RESPONSE SNIPPETS\n\nhttp.ServerResponse.prototype.renderHTML = function (html, statusCode) {\n  return this.legacyRender(\n    html,\n    null,\n    { 'content-type': 'text/html; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderJSON = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'application/json; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderWrappedJSON = function (json, statusCode) {\n  this.renderHTML(\n    '<!DOCTYPE html><html><body><textarea>' +\n      JSON.stringify(json) +\n      '</textarea></body></html>',\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderText = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'text/text; charset=utf-8' },\n    statusCode\n  );\n};\n\n// TODO: this function is overrided by Express => delete it to prevent ambiguity\nhttp.ServerResponse.prototype.redirect = function (url) {\n  return this.renderHTML(loggingTemplate.htmlRedirect(url));\n};\n\nhttp.ServerResponse.prototype.safeRedirect = function (url) {\n  const fullURL = new URL(url, config.urlPrefix);\n  if (!fullURL.toString().startsWith(config.urlPrefix)) return this.forbidden();\n  this.redirect(url);\n};\n\nhttp.ServerResponse.prototype.redirectWithTracking = function (url, title) {\n  return this.renderHTML(\n    loggingTemplate.renderRedirectPageWithTracking(url, title)\n  );\n};\n\nhttp.ServerResponse.prototype.renderIframe = function (url, metaOverrides) {\n  return this.renderHTML(loggingTemplate.renderIframe(url, metaOverrides));\n};\n\nhttp.ServerResponse.prototype.temporaryRedirect = function (_url, _reqParams) {\n  let url = '' + _url;\n  if (_reqParams /*request.method.toLowerCase() == \"get\"*/) {\n    const reqParams = querystring.stringify(_reqParams);\n    if (reqParams.length) url += '?' + reqParams;\n  }\n  this.redirect(307, url); // see https://expressjs.com/fr/4x/api.html#res.redirect\n};\n\nhttp.ServerResponse.prototype.badRequest = function (error) {\n  this.status(400).send(error ? '' + error : 'BAD REQUEST');\n};\n\nhttp.ServerResponse.prototype.forbidden = function (error) {\n  this.status(403).send(error ? '' + error : 'FORBIDDEN');\n};\n\nhttp.ServerResponse.prototype.notFound = function () {\n  this.status(404).send();\n};\n", "/* global describe, it, before */\n\nconst { promisify } = require('util');\nconst assert = require('assert');\n\nconst { ADMIN_USER, cleanup, URL_PREFIX } = require('../fixtures.js');\nconst apiClient = require('../api-client.js');\n\nconst postRaw = promisify(apiClient.postRaw);\nconst loginAs = promisify(apiClient.loginAs);\n\nbefore(cleanup);\n\ndescribe('security', () => {\n  describe('Open Redirect', () => {\n    it('should allow redirect to /stream', async () => {\n      const target = `/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it(`should allow redirect to ${URL_PREFIX}/stream`, async () => {\n      const target = `${URL_PREFIX}/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it('should NOT allow redirect to other domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `http://google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n  });\n});\n"], "fixing_code": ["var http = require('http');\nvar querystring = require('querystring');\nvar errorTemplate = require('../templates/error.js');\nconst snip = require('../snip.js');\n\nconst genReqLogLine = ({ head, method, path, params, suffix }) =>\n  !process.appParams.color\n    ? [\n        head,\n        method,\n        path[0] + (path.length > 1 ? '?' + path.slice(1).join('?') : ''),\n        suffix,\n        params,\n      ]\n    : [\n        head.grey,\n        method.cyan,\n        path[0].green +\n          (path.length > 1 ? '?' + path.slice(1).join('?') : '').yellow,\n        suffix.white,\n        params.grey,\n      ];\n\nhttp.IncomingMessage.prototype.logToConsole = function (suffix, params) {\n  console.log(\n    ...genReqLogLine({\n      head: '\u25b6 ' + new Date().toISOString(),\n      method: this.method,\n      path: this.url.split('?'),\n      params:\n        typeof params === 'object'\n          ? JSON.stringify(snip.formatPrivateFields(params))\n          : '',\n      suffix: suffix ? '(' + suffix + ')' : '',\n    })\n  );\n};\n\nvar config = require('./config.js');\nvar mongodb = require('./mongodb.js');\nvar loggingTemplate = require('../templates/logging.js');\nvar renderUnauthorizedPage = loggingTemplate.renderUnauthorizedPage;\n\n// ========= USER AGENT STUFF\n\n/**\n * Gets the http referer of a request\n */\nhttp.IncomingMessage.prototype.getReferer = function () {\n  return this.headers['referrer'] || this.headers['referer'];\n};\n\n// ========= COOKIE STUFF\n\n/**\n * Generates a user session cookie string\n * that can be supplied to a Set-Cookie HTTP header.\n */\n/*\nexports.makeCookie = function(user) {\n\tvar date = new Date((new Date()).getTime() + 1000 * 60 * 60 * 24 * 365);\n\treturn 'whydUid=\"'+(user.id || '')+'\"; Expires=' + date.toGMTString();\n};\n*/\n\n/**\n * Transforms cookies found in the request into an object\n */\nhttp.IncomingMessage.prototype.getCookies = (function () {\n  //var cookieReg = /([^=\\s]+)=\"([^\"]*)\"/;\n  return function () {\n    //console.log(\"cookies raw:\", this.headers.cookie);\n    if (!this.headers.cookie) return null;\n    var cookiesArray = this.headers.cookie.split(';');\n    //console.log(\"cookies array:\", cookiesArray);\n    var cookies = {};\n    for (let i = 0; i < cookiesArray.length; i++) {\n      //var match = cookiesArray[i].trim().match(cookieReg);\n      //if (match)\n      cookiesArray[i] = cookiesArray[i].trim();\n      var separ = cookiesArray[i].indexOf('=');\n      if (separ > 0)\n        cookies[cookiesArray[i].substr(0, separ)] = cookiesArray[i].substring(\n          separ + 1\n        );\n    }\n    //console.log(\"cookies object:\", cookies);\n    return cookies;\n  };\n})();\n\n/**\n * Return facebook's \"fbs_\" cookie object from the request\n */\nhttp.IncomingMessage.prototype.getFacebookCookie = function () {\n  var cookies = this.getCookies();\n  //console.log(\"cookies:\", cookies);\n  for (let i in cookies)\n    if (i.startsWith('fbs_')) {\n      const cookie = {},\n        cookieArray = cookies[i].split('&');\n      for (let j in cookieArray) {\n        var cookieItem = cookieArray[j].split('=');\n        cookie[cookieItem[0]] = cookieItem[1];\n      }\n      console.log('found facebook cookie'); //, cookie);\n      return cookie;\n    } else if (i.startsWith('fbsr_')) {\n      // https://developers.facebook.com/docs/authentication/signed_request/\n      try {\n        let cookie = cookies[i].split('.')[1];\n        cookie = Buffer.from(cookie /*|| \"\"*/, 'base64').toString('ascii');\n        cookie = JSON.parse(cookie);\n        console.log('found secure facebook cookie'); //, cookie);\n        return cookie;\n      } catch (e) {\n        console.log('secure facebook connect error: ', e);\n      }\n    }\n  return null;\n};\n\n// ========= USER ACCESSORS\n\n/**\n * Returns the logged in user's facebook uid, from its cookie\n */\nhttp.IncomingMessage.prototype.getFbUid = function () {\n  var fbCookie = this.getFacebookCookie();\n  if (fbCookie && fbCookie.uid)\n    this.getFbUid = function () {\n      return fbCookie.uid;\n    };\n  else if (fbCookie && fbCookie.user_id)\n    this.getFbUid = function () {\n      return fbCookie.user_id;\n    };\n  else return null;\n  return this.getFbUid();\n};\n\n/**\n * Returns the logged in user's uid, from its openwhyd session cookie\n */\nhttp.IncomingMessage.prototype.getUid = function () {\n  /*\n\tvar uid = (this.getCookies() || {})[\"whydUid\"];\n\tif (uid) uid = uid.replace(/\\\"/g, \"\");\n\t//if (uid) console.log(\"found openwhyd session cookie\", uid);\n\treturn uid;\n\t*/\n  return (this.session || {}).whydUid;\n};\n\n/**\n * Returns the logged in user as an object {_id, id, fbId, name, img}\n */\nhttp.IncomingMessage.prototype.getUser = function () {\n  var uid = this.getUid();\n  if (uid) {\n    var user = mongodb.usernames[uid];\n    if (user) user.id = '' + user._id;\n    return user;\n  } else return null;\n};\n\n//http.IncomingMessage.prototype.getUserFromFbUid = mongodb.getUserFromFbUid;\n\nhttp.IncomingMessage.prototype.getUserFromId = mongodb.getUserFromId;\n\nhttp.IncomingMessage.prototype.getUserNameFromId = mongodb.getUserNameFromId;\n\n// ========= LOGIN/SESSION/PRIVILEGES STUFF\n\n/**\n * Checks that a registered user is logged in, and return that user, or show an error page\n */\nhttp.IncomingMessage.prototype.checkLogin = function (response, format) {\n  var user = this.getUser();\n  //console.log(\"checkLogin, cached record for logged in user: \", user);\n  if (!user /*|| !user.name*/) {\n    if (response) {\n      if (format && format.toLowerCase() == 'json')\n        errorTemplate.renderErrorResponse(\n          { errorCode: 'REQ_LOGIN' },\n          response,\n          'json'\n        );\n      else response.renderHTML(renderUnauthorizedPage());\n    }\n    return false;\n  }\n  return user;\n};\n\nhttp.IncomingMessage.prototype.isUserAdmin = exports.isUserAdmin = function (\n  user\n) {\n  return user.email && config.adminEmails[user.email];\n};\n\nhttp.IncomingMessage.prototype.isAdmin = function () {\n  return this.isUserAdmin(this.getUser());\n};\n\nhttp.IncomingMessage.prototype.checkAdmin = function (response, format) {\n  var user = this.checkLogin(response, format);\n  if (!user) return false;\n  else if (!exports.isUserAdmin(user)) {\n    console.log(\n      'access restricted, user is not an admin: ',\n      user._id || user.id\n    );\n    response && response.legacyRender('nice try! ;-)');\n    return false;\n  }\n  return user;\n};\n\n// ========= HTTP RESPONSE SNIPPETS\n\nhttp.ServerResponse.prototype.renderHTML = function (html, statusCode) {\n  return this.legacyRender(\n    html,\n    null,\n    { 'content-type': 'text/html; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderJSON = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'application/json; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderWrappedJSON = function (json, statusCode) {\n  this.renderHTML(\n    '<!DOCTYPE html><html><body><textarea>' +\n      JSON.stringify(json) +\n      '</textarea></body></html>',\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderText = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'text/text; charset=utf-8' },\n    statusCode\n  );\n};\n\n// TODO: this function is overrided by Express => delete it to prevent ambiguity\nhttp.ServerResponse.prototype.redirect = function (url) {\n  return this.renderHTML(loggingTemplate.htmlRedirect(url));\n};\n\nhttp.ServerResponse.prototype.safeRedirect = function (url) {\n  const fullURL = new URL(url, config.urlPrefix);\n  if (`${fullURL.protocol}//${fullURL.host}` !== config.urlPrefix)\n    return this.forbidden();\n  this.redirect(url);\n};\n\nhttp.ServerResponse.prototype.redirectWithTracking = function (url, title) {\n  return this.renderHTML(\n    loggingTemplate.renderRedirectPageWithTracking(url, title)\n  );\n};\n\nhttp.ServerResponse.prototype.renderIframe = function (url, metaOverrides) {\n  return this.renderHTML(loggingTemplate.renderIframe(url, metaOverrides));\n};\n\nhttp.ServerResponse.prototype.temporaryRedirect = function (_url, _reqParams) {\n  let url = '' + _url;\n  if (_reqParams /*request.method.toLowerCase() == \"get\"*/) {\n    const reqParams = querystring.stringify(_reqParams);\n    if (reqParams.length) url += '?' + reqParams;\n  }\n  this.redirect(307, url); // see https://expressjs.com/fr/4x/api.html#res.redirect\n};\n\nhttp.ServerResponse.prototype.badRequest = function (error) {\n  this.status(400).send(error ? '' + error : 'BAD REQUEST');\n};\n\nhttp.ServerResponse.prototype.forbidden = function (error) {\n  this.status(403).send(error ? '' + error : 'FORBIDDEN');\n};\n\nhttp.ServerResponse.prototype.notFound = function () {\n  this.status(404).send();\n};\n", "/* global describe, it, before */\n\nconst { promisify } = require('util');\nconst assert = require('assert');\n\nconst { ADMIN_USER, cleanup, URL_PREFIX } = require('../fixtures.js');\nconst apiClient = require('../api-client.js');\n\nconst postRaw = promisify(apiClient.postRaw);\nconst loginAs = promisify(apiClient.loginAs);\n\nbefore(cleanup);\n\ndescribe('security', () => {\n  describe('Open Redirect', () => {\n    it('should allow redirect to /stream', async () => {\n      const target = `/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it(`should allow redirect to ${URL_PREFIX}/stream`, async () => {\n      const target = `${URL_PREFIX}/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it('should NOT allow redirect to other domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `http://google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n\n    it('should NOT allow redirect to a disguised domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `${URL_PREFIX}@google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n  });\n});\n"], "filenames": ["app/models/logging.js", "test/api/security.api.tests.js"], "buggy_code_start_loc": [265, 45], "buggy_code_end_loc": [266, 45], "fixing_code_start_loc": [265, 46], "fixing_code_end_loc": [267, 55], "type": "CWE-601", "message": "openwhyd is vulnerable to URL Redirection to Untrusted Site", "other": {"cve": {"id": "CVE-2021-3829", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-10T16:15:09.310", "lastModified": "2021-12-14T00:53:58.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openwhyd is vulnerable to URL Redirection to Untrusted Site"}, {"lang": "es", "value": "openwhyd es vulnerable a una Redirecci\u00f3n de URLs a Sitios no Confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openwhyd:openwhyd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.45.3", "matchCriteriaId": "90FC2E31-456E-47AD-BDF4-98F7D5A4EFC0"}]}]}], "references": [{"url": "https://github.com/openwhyd/openwhyd/commit/38707930103dcba49d89d993f56bebd346069640", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6b8acb0c-8b5d-461e-9b46-b1bfb5a8ccdf", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openwhyd/openwhyd/commit/38707930103dcba49d89d993f56bebd346069640"}}