{"buggy_code": ["/*\n * Ut Video decoder\n * Copyright (c) 2011 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Ut Video decoder\n */\n\n#include <inttypes.h>\n#include <stdlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"thread.h\"\n#include \"utvideo.h\"\n\nstatic int build_huff10(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[1024];\n    int last;\n    uint32_t codes[1024];\n    uint8_t bits[1024];\n    uint16_t syms[1024];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 1024; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 1024, sizeof(*he), ff_ut10_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 1023;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32) {\n        return -1;\n    }\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int build_huff(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[256];\n    int last;\n    uint32_t codes[256];\n    uint8_t bits[256];\n    uint8_t syms[256];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 256; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 256, sizeof(*he), ff_ut_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 255;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32)\n        return -1;\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int decode_plane10(UtvideoContext *c, int plane_no,\n                          uint16_t *dst, int step, int stride,\n                          int width, int height,\n                          const uint8_t *src, const uint8_t *huff,\n                          int use_pred)\n{\n    int i, j, slice, pix, ret;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n\n    if ((ret = build_huff10(huff, &vlc, &fsym)) < 0) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return ret;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint16_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices);\n            dest   = dst + sstart * stride;\n\n            prev = 0x200;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        prev &= 0x3FF;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint16_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices);\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x200;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    prev &= 0x3FF;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int decode_plane(UtvideoContext *c, int plane_no,\n                        uint8_t *dst, int step, int stride,\n                        int width, int height,\n                        const uint8_t *src, int use_pred)\n{\n    int i, j, slice, pix;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n    const int cmask = ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n    if (build_huff(src, &vlc, &fsym)) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint8_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices) & cmask;\n            dest   = dst + sstart * stride;\n\n            prev = 0x80;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    src      += 256;\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint8_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices) & cmask;\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x80;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic void restore_rgb_planes(uint8_t *src, int step, int stride, int width,\n                               int height)\n{\n    int i, j;\n    uint8_t r, g, b;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width * step; i += step) {\n            r = src[i];\n            g = src[i + 1];\n            b = src[i + 2];\n            src[i]     = r + g - 0x80;\n            src[i + 2] = b + g - 0x80;\n        }\n        src += stride;\n    }\n}\n\nstatic void restore_rgb_planes10(AVFrame *frame, int width, int height)\n{\n    uint16_t *src_r = (uint16_t *)frame->data[2];\n    uint16_t *src_g = (uint16_t *)frame->data[0];\n    uint16_t *src_b = (uint16_t *)frame->data[1];\n    int r, g, b;\n    int i, j;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width; i++) {\n            r = src_r[i];\n            g = src_g[i];\n            b = src_b[i];\n            src_r[i] = (r + g - 0x200) & 0x3FF;\n            src_b[i] = (b + g - 0x200) & 0x3FF;\n        }\n        src_r += frame->linesize[2] / 2;\n        src_g += frame->linesize[0] / 2;\n        src_b += frame->linesize[1] / 2;\n    }\n}\n\nstatic void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}\n\n/* UtVideo interlaced mode treats every two lines as a single one,\n * so restoring function should take care of possible padding between\n * two parts of the same \"line\".\n */\nstatic void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    UtvideoContext *c = avctx->priv_data;\n    int i, j;\n    const uint8_t *plane_start[5];\n    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;\n    int ret;\n    GetByteContext gb;\n    ThreadFrame frame = { .f = data };\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    /* parse plane structure to get frame flags and validate slice offsets */\n    bytestream2_init(&gb, buf, buf_size);\n    if (c->pro) {\n        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        c->frame_info = bytestream2_get_le32u(&gb);\n        c->slices = ((c->frame_info >> 16) & 0xff) + 1;\n        for (i = 0; i < c->planes; i++) {\n            plane_start[i] = gb.buffer;\n            if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {\n                av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            slice_start = 0;\n            slice_end   = 0;\n            for (j = 0; j < c->slices; j++) {\n                slice_end   = bytestream2_get_le32u(&gb);\n                if (slice_end < 0 || slice_end < slice_start ||\n                    bytestream2_get_bytes_left(&gb) < slice_end) {\n                    av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                slice_size  = slice_end - slice_start;\n                slice_start = slice_end;\n                max_slice_size = FFMAX(max_slice_size, slice_size);\n            }\n            plane_size = slice_end;\n            bytestream2_skipu(&gb, plane_size);\n            bytestream2_skipu(&gb, 1024);\n        }\n        plane_start[c->planes] = gb.buffer;\n    } else {\n        for (i = 0; i < c->planes; i++) {\n            plane_start[i] = gb.buffer;\n            if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {\n                av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_skipu(&gb, 256);\n            slice_start = 0;\n            slice_end   = 0;\n            for (j = 0; j < c->slices; j++) {\n                slice_end   = bytestream2_get_le32u(&gb);\n                if (slice_end < 0 || slice_end < slice_start ||\n                    bytestream2_get_bytes_left(&gb) < slice_end) {\n                    av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                slice_size  = slice_end - slice_start;\n                slice_start = slice_end;\n                max_slice_size = FFMAX(max_slice_size, slice_size);\n            }\n            plane_size = slice_end;\n            bytestream2_skipu(&gb, plane_size);\n        }\n        plane_start[c->planes] = gb.buffer;\n        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        c->frame_info = bytestream2_get_le32u(&gb);\n    }\n    av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",\n           c->frame_info);\n\n    c->frame_pred = (c->frame_info >> 8) & 3;\n\n    if (c->frame_pred == PRED_GRADIENT) {\n        avpriv_request_sample(avctx, \"Frame with gradient prediction\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_fast_malloc(&c->slice_bits, &c->slice_bits_size,\n                   max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!c->slice_bits) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    switch (c->avctx->pix_fmt) {\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],\n                               c->planes, frame.f->linesize[0], avctx->width,\n                               avctx->height, plane_start[i],\n                               c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[0] + ff_ut_rgb_order[i],\n                                   c->planes, frame.f->linesize[0], avctx->width,\n                                   avctx->height, c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],\n                                      c->planes, frame.f->linesize[0],\n                                      avctx->width, avctx->height, c->slices,\n                                      0);\n                }\n            }\n        }\n        restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],\n                           avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_GBRAP10:\n    case AV_PIX_FMT_GBRP10:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1,\n                                 frame.f->linesize[i] / 2, avctx->width,\n                                 avctx->height, plane_start[i],\n                                 plane_start[i + 1] - 1024,\n                                 c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n        }\n        restore_rgb_planes10(frame.f, avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_YUV420P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height >> !!i,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height >> !!i,\n                                   c->slices, !i);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width  >> !!i,\n                                      avctx->height >> !!i,\n                                      c->slices, !i);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width >> !!i, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV444P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P10:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1, frame.f->linesize[i] / 2,\n                                 avctx->width >> !!i, avctx->height,\n                                 plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n        }\n        break;\n    }\n\n    frame.f->key_frame = 1;\n    frame.f->pict_type = AV_PICTURE_TYPE_I;\n    frame.f->interlaced_frame = !!c->interlaced;\n\n    *got_frame = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    c->avctx = avctx;\n\n    ff_bswapdsp_init(&c->bdsp);\n\n    if (avctx->extradata_size >= 16) {\n        av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n               avctx->extradata[3], avctx->extradata[2],\n               avctx->extradata[1], avctx->extradata[0]);\n        av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n               AV_RB32(avctx->extradata + 4));\n        c->frame_info_size = AV_RL32(avctx->extradata + 8);\n        c->flags           = AV_RL32(avctx->extradata + 12);\n\n        if (c->frame_info_size != 4)\n            avpriv_request_sample(avctx, \"Frame info not 4 bytes\");\n        av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);\n        c->slices      = (c->flags >> 24) + 1;\n        c->compression = c->flags & 1;\n        c->interlaced  = c->flags & 0x800;\n    } else if (avctx->extradata_size == 8) {\n        av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n               avctx->extradata[3], avctx->extradata[2],\n               avctx->extradata[1], avctx->extradata[0]);\n        av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n               AV_RB32(avctx->extradata + 4));\n        c->interlaced  = 0;\n        c->pro         = 1;\n        c->frame_info_size = 4;\n    } else {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Insufficient extradata size %d, should be at least 16\\n\",\n               avctx->extradata_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->slice_bits_size = 0;\n\n    switch (avctx->codec_tag) {\n    case MKTAG('U', 'L', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case MKTAG('U', 'L', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        break;\n    case MKTAG('U', 'L', 'Y', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '4'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'Q', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n        break;\n    case MKTAG('U', 'Q', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        break;\n    case MKTAG('U', 'Q', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_GBRAP10;\n        break;\n    case MKTAG('U', 'L', 'H', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '4'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",\n               avctx->codec_tag);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    av_freep(&c->slice_bits);\n\n    return 0;\n}\n\nAVCodec ff_utvideo_decoder = {\n    .name           = \"utvideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Ut Video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_UTVIDEO,\n    .priv_data_size = sizeof(UtvideoContext),\n    .init           = decode_init,\n    .close          = decode_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n};\n"], "fixing_code": ["/*\n * Ut Video decoder\n * Copyright (c) 2011 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Ut Video decoder\n */\n\n#include <inttypes.h>\n#include <stdlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"thread.h\"\n#include \"utvideo.h\"\n\nstatic int build_huff10(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[1024];\n    int last;\n    uint32_t codes[1024];\n    uint8_t bits[1024];\n    uint16_t syms[1024];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 1024; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 1024, sizeof(*he), ff_ut10_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 1023;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32) {\n        return -1;\n    }\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int build_huff(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[256];\n    int last;\n    uint32_t codes[256];\n    uint8_t bits[256];\n    uint8_t syms[256];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 256; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 256, sizeof(*he), ff_ut_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 255;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32)\n        return -1;\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int decode_plane10(UtvideoContext *c, int plane_no,\n                          uint16_t *dst, int step, int stride,\n                          int width, int height,\n                          const uint8_t *src, const uint8_t *huff,\n                          int use_pred)\n{\n    int i, j, slice, pix, ret;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n\n    if ((ret = build_huff10(huff, &vlc, &fsym)) < 0) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return ret;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint16_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices);\n            dest   = dst + sstart * stride;\n\n            prev = 0x200;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        prev &= 0x3FF;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint16_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices);\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x200;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    prev &= 0x3FF;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int decode_plane(UtvideoContext *c, int plane_no,\n                        uint8_t *dst, int step, int stride,\n                        int width, int height,\n                        const uint8_t *src, int use_pred)\n{\n    int i, j, slice, pix;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n    const int cmask = ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n    if (build_huff(src, &vlc, &fsym)) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint8_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices) & cmask;\n            dest   = dst + sstart * stride;\n\n            prev = 0x80;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    src      += 256;\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint8_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices) & cmask;\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x80;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic void restore_rgb_planes(uint8_t *src, int step, int stride, int width,\n                               int height)\n{\n    int i, j;\n    uint8_t r, g, b;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width * step; i += step) {\n            r = src[i];\n            g = src[i + 1];\n            b = src[i + 2];\n            src[i]     = r + g - 0x80;\n            src[i + 2] = b + g - 0x80;\n        }\n        src += stride;\n    }\n}\n\nstatic void restore_rgb_planes10(AVFrame *frame, int width, int height)\n{\n    uint16_t *src_r = (uint16_t *)frame->data[2];\n    uint16_t *src_g = (uint16_t *)frame->data[0];\n    uint16_t *src_b = (uint16_t *)frame->data[1];\n    int r, g, b;\n    int i, j;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width; i++) {\n            r = src_r[i];\n            g = src_g[i];\n            b = src_b[i];\n            src_r[i] = (r + g - 0x200) & 0x3FF;\n            src_b[i] = (b + g - 0x200) & 0x3FF;\n        }\n        src_r += frame->linesize[2] / 2;\n        src_g += frame->linesize[0] / 2;\n        src_b += frame->linesize[1] / 2;\n    }\n}\n\nstatic void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}\n\n/* UtVideo interlaced mode treats every two lines as a single one,\n * so restoring function should take care of possible padding between\n * two parts of the same \"line\".\n */\nstatic void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    UtvideoContext *c = avctx->priv_data;\n    int i, j;\n    const uint8_t *plane_start[5];\n    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;\n    int ret;\n    GetByteContext gb;\n    ThreadFrame frame = { .f = data };\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    /* parse plane structure to get frame flags and validate slice offsets */\n    bytestream2_init(&gb, buf, buf_size);\n    if (c->pro) {\n        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        c->frame_info = bytestream2_get_le32u(&gb);\n        c->slices = ((c->frame_info >> 16) & 0xff) + 1;\n        for (i = 0; i < c->planes; i++) {\n            plane_start[i] = gb.buffer;\n            if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {\n                av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            slice_start = 0;\n            slice_end   = 0;\n            for (j = 0; j < c->slices; j++) {\n                slice_end   = bytestream2_get_le32u(&gb);\n                if (slice_end < 0 || slice_end < slice_start ||\n                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {\n                    av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                slice_size  = slice_end - slice_start;\n                slice_start = slice_end;\n                max_slice_size = FFMAX(max_slice_size, slice_size);\n            }\n            plane_size = slice_end;\n            bytestream2_skipu(&gb, plane_size);\n            bytestream2_skipu(&gb, 1024);\n        }\n        plane_start[c->planes] = gb.buffer;\n    } else {\n        for (i = 0; i < c->planes; i++) {\n            plane_start[i] = gb.buffer;\n            if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {\n                av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_skipu(&gb, 256);\n            slice_start = 0;\n            slice_end   = 0;\n            for (j = 0; j < c->slices; j++) {\n                slice_end   = bytestream2_get_le32u(&gb);\n                if (slice_end < 0 || slice_end < slice_start ||\n                    bytestream2_get_bytes_left(&gb) < slice_end) {\n                    av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                slice_size  = slice_end - slice_start;\n                slice_start = slice_end;\n                max_slice_size = FFMAX(max_slice_size, slice_size);\n            }\n            plane_size = slice_end;\n            bytestream2_skipu(&gb, plane_size);\n        }\n        plane_start[c->planes] = gb.buffer;\n        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        c->frame_info = bytestream2_get_le32u(&gb);\n    }\n    av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",\n           c->frame_info);\n\n    c->frame_pred = (c->frame_info >> 8) & 3;\n\n    if (c->frame_pred == PRED_GRADIENT) {\n        avpriv_request_sample(avctx, \"Frame with gradient prediction\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_fast_malloc(&c->slice_bits, &c->slice_bits_size,\n                   max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!c->slice_bits) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    switch (c->avctx->pix_fmt) {\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],\n                               c->planes, frame.f->linesize[0], avctx->width,\n                               avctx->height, plane_start[i],\n                               c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[0] + ff_ut_rgb_order[i],\n                                   c->planes, frame.f->linesize[0], avctx->width,\n                                   avctx->height, c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],\n                                      c->planes, frame.f->linesize[0],\n                                      avctx->width, avctx->height, c->slices,\n                                      0);\n                }\n            }\n        }\n        restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],\n                           avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_GBRAP10:\n    case AV_PIX_FMT_GBRP10:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1,\n                                 frame.f->linesize[i] / 2, avctx->width,\n                                 avctx->height, plane_start[i],\n                                 plane_start[i + 1] - 1024,\n                                 c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n        }\n        restore_rgb_planes10(frame.f, avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_YUV420P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height >> !!i,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height >> !!i,\n                                   c->slices, !i);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width  >> !!i,\n                                      avctx->height >> !!i,\n                                      c->slices, !i);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width >> !!i, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV444P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P10:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1, frame.f->linesize[i] / 2,\n                                 avctx->width >> !!i, avctx->height,\n                                 plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n        }\n        break;\n    }\n\n    frame.f->key_frame = 1;\n    frame.f->pict_type = AV_PICTURE_TYPE_I;\n    frame.f->interlaced_frame = !!c->interlaced;\n\n    *got_frame = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    c->avctx = avctx;\n\n    ff_bswapdsp_init(&c->bdsp);\n\n    if (avctx->extradata_size >= 16) {\n        av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n               avctx->extradata[3], avctx->extradata[2],\n               avctx->extradata[1], avctx->extradata[0]);\n        av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n               AV_RB32(avctx->extradata + 4));\n        c->frame_info_size = AV_RL32(avctx->extradata + 8);\n        c->flags           = AV_RL32(avctx->extradata + 12);\n\n        if (c->frame_info_size != 4)\n            avpriv_request_sample(avctx, \"Frame info not 4 bytes\");\n        av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);\n        c->slices      = (c->flags >> 24) + 1;\n        c->compression = c->flags & 1;\n        c->interlaced  = c->flags & 0x800;\n    } else if (avctx->extradata_size == 8) {\n        av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n               avctx->extradata[3], avctx->extradata[2],\n               avctx->extradata[1], avctx->extradata[0]);\n        av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n               AV_RB32(avctx->extradata + 4));\n        c->interlaced  = 0;\n        c->pro         = 1;\n        c->frame_info_size = 4;\n    } else {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Insufficient extradata size %d, should be at least 16\\n\",\n               avctx->extradata_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->slice_bits_size = 0;\n\n    switch (avctx->codec_tag) {\n    case MKTAG('U', 'L', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case MKTAG('U', 'L', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        break;\n    case MKTAG('U', 'L', 'Y', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '4'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'Q', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n        break;\n    case MKTAG('U', 'Q', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        break;\n    case MKTAG('U', 'Q', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_GBRAP10;\n        break;\n    case MKTAG('U', 'L', 'H', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '4'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",\n               avctx->codec_tag);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    av_freep(&c->slice_bits);\n\n    return 0;\n}\n\nAVCodec ff_utvideo_decoder = {\n    .name           = \"utvideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Ut Video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_UTVIDEO,\n    .priv_data_size = sizeof(UtvideoContext),\n    .init           = decode_init,\n    .close          = decode_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n};\n"], "filenames": ["libavcodec/utvideodec.c"], "buggy_code_start_loc": [537], "buggy_code_end_loc": [538], "fixing_code_start_loc": [537], "fixing_code_end_loc": [538], "type": "CWE-125", "message": "The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.", "other": {"cve": {"id": "CVE-2018-6621", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-05T04:29:00.917", "lastModified": "2021-03-02T21:11:42.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file."}, {"lang": "es", "value": "La funci\u00f3n decode_frame en libavcodec/utvideodec.c en FFmpeg hasta la versi\u00f3n 3.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de array) utilizando un archivo AVI manipulado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "98D5A462-DB87-4AED-8D15-FBE04BF58756"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102950", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/118e1b0b3370dd1c0da442901b486689efd1654b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/22aa37c0fedf14531783189a197542a055959b6c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4249", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/22aa37c0fedf14531783189a197542a055959b6c"}}