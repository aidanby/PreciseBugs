{"buggy_code": ["package tar\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\tgopath \"path\"\n\tfp \"path/filepath\"\n\t\"strings\"\n)\n\ntype Extractor struct {\n\tPath     string\n\tProgress func(int64) int64\n\n\t// SanitizePathFunc can be provided if you wish to inspect and/or modify the source path\n\t// returning an error from this function will abort extraction\n\tSanitizePathFunc func(path string) (saferPath string, userDefined error)\n\n\t// LinkFunc can be provided for user specified handling of filesystem links\n\t// returning an error from this function aborts extraction\n\tLinkFunc func(Link) error\n}\n\n// Link represents a filesystem link where Name is the link's destination path,\n// Target is what the link actually points to,\n// and Root is the extraction root\ntype Link struct {\n\tRoot, Name, Target string\n}\n\nfunc (te *Extractor) Extract(reader io.Reader) error {\n\tif isNullDevice(te.Path) {\n\t\treturn nil\n\t}\n\n\ttarReader := tar.NewReader(reader)\n\n\t// Check if the output path already exists, so we know whether we should\n\t// create our output with that name, or if we should put the output inside\n\t// a preexisting directory\n\trootExists := true\n\trootIsDir := false\n\tif stat, err := os.Stat(te.Path); err != nil && os.IsNotExist(err) {\n\t\trootExists = false\n\t} else if err != nil {\n\t\treturn err\n\t} else if stat.IsDir() {\n\t\trootIsDir = true\n\t}\n\n\t// files come recursively in order (i == 0 is root directory)\n\tfor i := 0; ; i++ {\n\t\theader, err := tarReader.Next()\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif header == nil || err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif err := te.extractDir(header, i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeReg:\n\t\t\tif err := te.extractFile(header, tarReader, i, rootExists, rootIsDir); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeSymlink:\n\t\t\tif err := te.extractSymlink(header); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unrecognized tar header type: %d\", header.Typeflag)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Sanitize sets up the extractor to use built in sanitation functions\n// (Modify paths to be platform legal, symlinks may not escape extraction root)\n// or unsets any previously set sanitation functions on the extractor\n// (no special rules are applied when extracting)\nfunc (te *Extractor) Sanitize(toggle bool) {\n\tif toggle {\n\t\tte.SanitizePathFunc = sanitizePath\n\t\tte.LinkFunc = func(inLink Link) error {\n\t\t\tif err := childrenOnly(inLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := platformLink(inLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn os.Symlink(inLink.Target, inLink.Name)\n\t\t}\n\t} else {\n\t\tte.SanitizePathFunc = nil\n\t\tte.LinkFunc = nil\n\t}\n}\n\n// outputPath returns the path at which to place tarPath\nfunc (te *Extractor) outputPath(tarPath string) (outPath string, err error) {\n\telems := strings.Split(tarPath, \"/\")    // break into elems\n\telems = elems[1:]                       // remove original root\n\toutPath = strings.Join(elems, \"/\")      // join elems\n\toutPath = gopath.Join(te.Path, outPath) // rebase on to extraction target root\n\t// sanitize path to be platform legal\n\tif te.SanitizePathFunc != nil {\n\t\toutPath, err = te.SanitizePathFunc(outPath)\n\t} else {\n\t\toutPath = fp.FromSlash(outPath)\n\t}\n\treturn\n}\n\nfunc (te *Extractor) extractDir(h *tar.Header, depth int) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif depth == 0 {\n\t\t// if this is the root directory, use it as the output path for remaining files\n\t\tte.Path = path\n\t}\n\n\treturn os.MkdirAll(path, 0755)\n}\n\nfunc (te *Extractor) extractSymlink(h *tar.Header) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif te.LinkFunc != nil {\n\t\treturn te.LinkFunc(Link{Root: te.Path, Name: h.Name, Target: h.Linkname})\n\t}\n\n\treturn os.Symlink(h.Linkname, path)\n}\n\nfunc (te *Extractor) extractFile(h *tar.Header, r *tar.Reader, depth int, rootExists bool, rootIsDir bool) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif depth == 0 { // if depth is 0, this is the only file (we aren't extracting a directory)\n\t\tif rootExists && rootIsDir {\n\t\t\t// putting file inside of a root dir.\n\t\t\tfnameo := gopath.Base(h.Name)\n\t\t\tfnamen := fp.Base(path)\n\t\t\t// add back original name if lost.\n\t\t\tif fnameo != fnamen {\n\t\t\t\tpath = fp.Join(path, fnameo)\n\t\t\t}\n\t\t} // else if old file exists, just overwrite it.\n\t}\n\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn copyWithProgress(file, r, te.Progress)\n}\n\nfunc copyWithProgress(to io.Writer, from io.Reader, cb func(int64) int64) error {\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := from.Read(buf)\n\t\tif n != 0 {\n\t\t\tif cb != nil {\n\t\t\t\tcb(int64(n))\n\t\t\t}\n\t\t\t_, err2 := to.Write(buf[:n])\n\t\t\tif err2 != nil {\n\t\t\t\treturn err2\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// childrenOnly will return an error if link targets escape their root\nfunc childrenOnly(inLink Link) error {\n\tif fp.IsAbs(inLink.Target) {\n\t\treturn fmt.Errorf(\"Link target %q is an absolute path (forbidden)\", inLink.Target)\n\t}\n\n\tresolvedTarget := fp.Join(inLink.Name, inLink.Target)\n\trel, err := fp.Rel(inLink.Root, resolvedTarget)\n\tif err != nil {\n\t\treturn err\n\t}\n\t//disallow symlinks from climbing out of the target root\n\tif strings.HasPrefix(rel, \"..\") {\n\t\treturn fmt.Errorf(\"Symlink target %q escapes root %q\", inLink.Target, inLink.Root)\n\t}\n\t//disallow pointing to your own root from above as well\n\tif strings.HasPrefix(resolvedTarget, inLink.Root) {\n\t\treturn fmt.Errorf(\"Symlink target %q escapes and re-enters its own root %q (forbidden)\", inLink.Target, inLink.Root)\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["package tar\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\tgopath \"path\"\n\tfp \"path/filepath\"\n\t\"strings\"\n)\n\ntype Extractor struct {\n\tPath     string\n\tProgress func(int64) int64\n\n\t// SanitizePathFunc can be provided if you wish to inspect and/or modify the source path\n\t// returning an error from this function will abort extraction\n\tSanitizePathFunc func(path string) (saferPath string, userDefined error)\n\n\t// LinkFunc can be provided for user specified handling of filesystem links\n\t// returning an error from this function aborts extraction\n\tLinkFunc func(Link) error\n}\n\n// Link represents a filesystem link where Name is the link's destination path,\n// Target is what the link actually points to,\n// and Root is the extraction root\ntype Link struct {\n\tRoot, Name, Target string\n}\n\nfunc (te *Extractor) Extract(reader io.Reader) error {\n\tif isNullDevice(te.Path) {\n\t\treturn nil\n\t}\n\n\ttarReader := tar.NewReader(reader)\n\n\t// Check if the output path already exists, so we know whether we should\n\t// create our output with that name, or if we should put the output inside\n\t// a preexisting directory\n\trootExists := true\n\trootIsDir := false\n\tif stat, err := os.Stat(te.Path); err != nil && os.IsNotExist(err) {\n\t\trootExists = false\n\t} else if err != nil {\n\t\treturn err\n\t} else if stat.IsDir() {\n\t\trootIsDir = true\n\t}\n\n\t// files come recursively in order (i == 0 is root directory)\n\tfor i := 0; ; i++ {\n\t\theader, err := tarReader.Next()\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif header == nil || err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif err := te.extractDir(header, i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeReg:\n\t\t\tif err := te.extractFile(header, tarReader, i, rootExists, rootIsDir); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeSymlink:\n\t\t\tif err := te.extractSymlink(header); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unrecognized tar header type: %d\", header.Typeflag)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Sanitize sets up the extractor to use built in sanitation functions\n// (Modify paths to be platform legal, symlinks may not escape extraction root)\n// or unsets any previously set sanitation functions on the extractor\n// (no special rules are applied when extracting)\nfunc (te *Extractor) Sanitize(toggle bool) {\n\tif toggle {\n\t\tte.SanitizePathFunc = sanitizePath\n\t\tte.LinkFunc = func(inLink Link) error {\n\t\t\tif err := childrenOnly(inLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := platformLink(inLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn os.Symlink(inLink.Target, inLink.Name)\n\t\t}\n\t} else {\n\t\tte.SanitizePathFunc = nil\n\t\tte.LinkFunc = nil\n\t}\n}\n\n// outputPath returns the path at which to place tarPath\nfunc (te *Extractor) outputPath(tarPath string) (outPath string, err error) {\n\telems := strings.Split(tarPath, \"/\") // break into elems\n\tfor _, e := range elems {\n\t\tif e == \"..\" {\n\t\t\treturn \"\", fmt.Errorf(\"%s : path contains '..'\", tarPath)\n\t\t}\n\t}\n\telems = elems[1:]                       // remove original root\n\toutPath = strings.Join(elems, \"/\")      // join elems\n\toutPath = gopath.Join(te.Path, outPath) // rebase on to extraction target root\n\t// sanitize path to be platform legal\n\tif te.SanitizePathFunc != nil {\n\t\toutPath, err = te.SanitizePathFunc(outPath)\n\t} else {\n\t\toutPath = fp.FromSlash(outPath)\n\t}\n\treturn\n}\n\nfunc (te *Extractor) extractDir(h *tar.Header, depth int) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif depth == 0 {\n\t\t// if this is the root directory, use it as the output path for remaining files\n\t\tte.Path = path\n\t}\n\n\treturn os.MkdirAll(path, 0755)\n}\n\nfunc (te *Extractor) extractSymlink(h *tar.Header) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif te.LinkFunc != nil {\n\t\treturn te.LinkFunc(Link{Root: te.Path, Name: h.Name, Target: h.Linkname})\n\t}\n\n\treturn os.Symlink(h.Linkname, path)\n}\n\nfunc (te *Extractor) extractFile(h *tar.Header, r *tar.Reader, depth int, rootExists bool, rootIsDir bool) error {\n\tpath, err := te.outputPath(h.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif depth == 0 { // if depth is 0, this is the only file (we aren't extracting a directory)\n\t\tif rootExists && rootIsDir {\n\t\t\t// putting file inside of a root dir.\n\t\t\tfnameo := gopath.Base(h.Name)\n\t\t\tfnamen := fp.Base(path)\n\t\t\t// add back original name if lost.\n\t\t\tif fnameo != fnamen {\n\t\t\t\tpath = fp.Join(path, fnameo)\n\t\t\t}\n\t\t} // else if old file exists, just overwrite it.\n\t}\n\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn copyWithProgress(file, r, te.Progress)\n}\n\nfunc copyWithProgress(to io.Writer, from io.Reader, cb func(int64) int64) error {\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := from.Read(buf)\n\t\tif n != 0 {\n\t\t\tif cb != nil {\n\t\t\t\tcb(int64(n))\n\t\t\t}\n\t\t\t_, err2 := to.Write(buf[:n])\n\t\t\tif err2 != nil {\n\t\t\t\treturn err2\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// childrenOnly will return an error if link targets escape their root\nfunc childrenOnly(inLink Link) error {\n\tif fp.IsAbs(inLink.Target) {\n\t\treturn fmt.Errorf(\"Link target %q is an absolute path (forbidden)\", inLink.Target)\n\t}\n\n\tresolvedTarget := fp.Join(inLink.Name, inLink.Target)\n\trel, err := fp.Rel(inLink.Root, resolvedTarget)\n\tif err != nil {\n\t\treturn err\n\t}\n\t//disallow symlinks from climbing out of the target root\n\tif strings.HasPrefix(rel, \"..\") {\n\t\treturn fmt.Errorf(\"Symlink target %q escapes root %q\", inLink.Target, inLink.Root)\n\t}\n\t//disallow pointing to your own root from above as well\n\tif strings.HasPrefix(resolvedTarget, inLink.Root) {\n\t\treturn fmt.Errorf(\"Symlink target %q escapes and re-enters its own root %q (forbidden)\", inLink.Target, inLink.Root)\n\t}\n\n\treturn nil\n}\n"], "filenames": ["extractor.go"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [108], "fixing_code_start_loc": [107], "fixing_code_end_loc": [113], "type": "CWE-22", "message": "Due to improper path sanitization, archives containing relative file paths can cause files to be written (or overwritten) outside of the target directory.", "other": {"cve": {"id": "CVE-2020-36566", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.723", "lastModified": "2023-06-08T21:15:15.587", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Due to improper path sanitization, archives containing relative file paths can cause files to be written (or overwritten) outside of the target directory."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tar-utils_project:tar-utils:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.0.0-20201201191210-20a61371de5b", "matchCriteriaId": "45A7C271-AF61-494E-AA9B-D65348D37F0F"}]}]}], "references": [{"url": "https://github.com/whyrusleeping/tar-utils/commit/20a61371de5b51380bbdb0c7935b30b0625ac227", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2021-0106", "source": "security@golang.org", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/research/zip-slip-vulnerability", "source": "security@golang.org", "tags": ["Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/whyrusleeping/tar-utils/commit/20a61371de5b51380bbdb0c7935b30b0625ac227"}}