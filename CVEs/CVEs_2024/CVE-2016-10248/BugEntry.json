{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Math-Related Code\n *\n * $Id$\n */\n\n#ifndef\tJAS_MATH_H\n#define\tJAS_MATH_H\n\n/******************************************************************************\\\n* Includes\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Macros\n\\******************************************************************************/\n\n/* Compute the absolute value. */\n#define\tJAS_ABS(x) \\\n\t(((x) >= 0) ? (x) : (-(x)))\n\n/* Compute the minimum of two values. */\n#define\tJAS_MIN(x, y) \\\n\t(((x) < (y)) ? (x) : (y))\n\n/* Compute the maximum of two values. */\n#define\tJAS_MAX(x, y) \\\n\t(((x) > (y)) ? (x) : (y))\n\n/* Compute the remainder from division (where division is defined such\n  that the remainder is always nonnegative). */\n#define\tJAS_MOD(x, y) \\\n\t(((x) < 0) ? (((-x) % (y)) ? ((y) - ((-(x)) % (y))) : (0)) : ((x) % (y)))\n\n/* Compute the integer with the specified number of least significant bits\n  set to one. */\n#define\tJAS_ONES(n) \\\n  ((1 << (n)) - 1)\n\n/******************************************************************************\\\n* Safe integer arithmetic (i.e., with overflow checking).\n\\******************************************************************************/\n\n/* Compute the product of two size_t integers with overflow checking. */\ninline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result)\n{\n\t/* Check if overflow would occur */\n\tif (x && y > SIZE_MAX / x) {\n\t\t/* Overflow would occur. */\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x * y;\n\treturn true;\n}\n\ninline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n{\n\tif (y > SIZE_MAX - x) {\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x + y;\n\treturn true;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n#ifndef JAS_SEQ_H\n#define JAS_SEQ_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <jasper/jas_stream.h>\n#include <jasper/jas_types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/* This matrix is a reference to another matrix. */\n#define JAS_MATRIX_REF\t0x0001\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* An element in a sequence. */\ntypedef int_fast32_t jas_seqent_t;\n\n/* An element in a matrix. */\ntypedef int_fast32_t jas_matent_t;\n\n/* Matrix. */\n\ntypedef struct {\n\n\t/* Additional state information. */\n\tint flags_;\n\n\t/* The starting horizontal index. */\n\tint_fast32_t xstart_;\n\n\t/* The starting vertical index. */\n\tint_fast32_t ystart_;\n\n\t/* The ending horizontal index. */\n\tint_fast32_t xend_;\n\n\t/* The ending vertical index. */\n\tint_fast32_t yend_;\n\n\t/* The number of rows in the matrix. */\n\tint_fast32_t numrows_;\n\n\t/* The number of columns in the matrix. */\n\tint_fast32_t numcols_;\n\n\t/* Pointers to the start of each row. */\n\tjas_seqent_t **rows_;\n\n\t/* The allocated size of the rows array. */\n\tint_fast32_t maxrows_;\n\n\t/* The matrix data buffer. */\n\tjas_seqent_t *data_;\n\n\t/* The allocated size of the data array. */\n\tint_fast32_t datasize_;\n\n} jas_matrix_t;\n\ntypedef jas_matrix_t jas_seq2d_t;\ntypedef jas_matrix_t jas_seq_t;\n\n/******************************************************************************\\\n* Functions/macros for matrix class.\n\\******************************************************************************/\n\n/* Get the number of rows. */\n#define jas_matrix_numrows(matrix) \\\n\t((matrix)->numrows_)\n\n/* Get the number of columns. */\n#define jas_matrix_numcols(matrix) \\\n\t((matrix)->numcols_)\n\n/* Get a matrix element. */\n#define jas_matrix_get(matrix, i, j) \\\n\t((matrix)->rows_[i][j])\n\n/* Set a matrix element. */\n#define jas_matrix_set(matrix, i, j, v) \\\n\t((matrix)->rows_[i][j] = (v))\n\n/* Get an element from a matrix that is known to be a row or column vector. */\n#define jas_matrix_getv(matrix, i) \\\n\t(((matrix)->numrows_ == 1) ? ((matrix)->rows_[0][i]) : \\\n\t  ((matrix)->rows_[i][0]))\n\n/* Set an element in a matrix that is known to be a row or column vector. */\n#define jas_matrix_setv(matrix, i, v) \\\n\t(((matrix)->numrows_ == 1) ? ((matrix)->rows_[0][i] = (v)) : \\\n\t  ((matrix)->rows_[i][0] = (v)))\n\n/* Get the address of an element in a matrix. */\n#define\tjas_matrix_getref(matrix, i, j) \\\n\t(&(matrix)->rows_[i][j])\n\n#define\tjas_matrix_getvref(matrix, i) \\\n\t(((matrix)->numrows_ > 1) ? jas_matrix_getref(matrix, i, 0) : jas_matrix_getref(matrix, 0, i))\n\n#define jas_matrix_length(matrix) \\\n\t(max((matrix)->numrows_, (matrix)->numcols_))\n\n/* Create a matrix with the specified dimensions. */\njas_matrix_t *jas_matrix_create(int numrows, int numcols);\n\n/* Destroy a matrix. */\nvoid jas_matrix_destroy(jas_matrix_t *matrix);\n\n/* Resize a matrix.  The previous contents of the matrix are lost. */\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols);\n\nint jas_matrix_output(jas_matrix_t *matrix, FILE *out);\n\n/* Create a matrix that references part of another matrix. */\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,\n  int c0, int r1, int c1);\n\n/* Create a matrix that is a reference to a row of another matrix. */\n#define jas_matrix_bindrow(mat0, mat1, r) \\\n  (jas_matrix_bindsub((mat0), (mat1), (r), 0, (r), (mat1)->numcols_ - 1))\n\n/* Create a matrix that is a reference to a column of another matrix. */\n#define jas_matrix_bindcol(mat0, mat1, c) \\\n  (jas_matrix_bindsub((mat0), (mat1), 0, (c), (mat1)->numrows_ - 1, (c)))\n\n/* Clip the values of matrix elements to the specified range. */\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,\n  jas_seqent_t maxval);\n\n/* Arithmetic shift left of all elements in a matrix. */\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n);\n\n/* Arithmetic shift right of all elements in a matrix. */\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n);\n\n/* Almost-but-not-quite arithmetic shift right of all elements in a matrix. */\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n);\n\n/* Set all elements of a matrix to the specified value. */\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val);\n\n/* The spacing between rows of a matrix. */\n#define\tjas_matrix_rowstep(matrix) \\\n\t(((matrix)->numrows_ > 1) ? ((matrix)->rows_[1] - (matrix)->rows_[0]) : (0))\n\n/* The spacing between columns of a matrix. */\n#define\tjas_matrix_step(matrix) \\\n\t(((matrix)->numrows_ > 1) ? (jas_matrix_rowstep(matrix)) : (1))\n\n/* Compare two matrices for equality. */\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1);\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x);\n\njas_matrix_t *jas_matrix_input(FILE *);\n\n/******************************************************************************\\\n* Functions/macros for 2-D sequence class.\n\\******************************************************************************/\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x);\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n\n#define\tjas_seq2d_destroy(s) \\\n\tjas_matrix_destroy(s)\n\n#define\tjas_seq2d_xstart(s) \\\n\t((s)->xstart_)\n#define\tjas_seq2d_ystart(s) \\\n\t((s)->ystart_)\n#define\tjas_seq2d_xend(s) \\\n\t((s)->xend_)\n#define\tjas_seq2d_yend(s) \\\n\t((s)->yend_)\n#define\tjas_seq2d_getref(s, x, y) \\\n\t(jas_matrix_getref(s, (y) - (s)->ystart_, (x) - (s)->xstart_))\n#define\tjas_seq2d_get(s, x, y) \\\n\t(jas_matrix_get(s, (y) - (s)->ystart_, (x) - (s)->xstart_))\n#define\tjas_seq2d_rowstep(s) \\\n\tjas_matrix_rowstep(s)\n#define\tjas_seq2d_width(s) \\\n\t((s)->xend_ - (s)->xstart_)\n#define\tjas_seq2d_height(s) \\\n\t((s)->yend_ - (s)->ystart_)\n#define\tjas_seq2d_setshift(s, x, y) \\\n\t((s)->xstart_ = (x), (s)->ystart_ = (y), \\\n\t  (s)->xend_ = (s)->xstart_ + (s)->numcols_, \\\n\t  (s)->yend_ = (s)->ystart_ + (s)->numrows_)\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n  int ystart, int xend, int yend);\n\n/******************************************************************************\\\n* Functions/macros for 1-D sequence class.\n\\******************************************************************************/\n\n#define\tjas_seq_create(start, end) \\\n\t(jas_seq2d_create(start, 0, end, 1))\n\n#define\tjas_seq_destroy(seq) \\\n\t(jas_seq2d_destroy(seq))\n\n#define jas_seq_set(seq, i, v) \\\n\t((seq)->rows_[0][(i) - (seq)->xstart_] = (v))\n#define\tjas_seq_getref(seq, i) \\\n\t(&(seq)->rows_[0][(i) - (seq)->xstart_])\n#define\tjas_seq_get(seq, i) \\\n\t((seq)->rows_[0][(i) - (seq)->xstart_])\n#define\tjas_seq_start(seq) \\\n\t((seq)->xstart_)\n#define\tjas_seq_end(seq) \\\n\t((seq)->xend_)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\nfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\nfprintf(out, \"BAND %d\\n\", bandno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\nfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\nfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2004 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tree-Structured Filter Bank (TSFB) Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_seq.h\"\n\n#include \"jpc_tsfb.h\"\n#include \"jpc_cod.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_util.h\"\n#include \"jpc_math.h\"\n\nvoid jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart,\n  int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,\n  int numlvls);\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\njpc_tsfb_t *jpc_cod_gettsfb(int qmfbid, int numlvls)\n{\n\tjpc_tsfb_t *tsfb;\n\n\tif (!(tsfb = malloc(sizeof(jpc_tsfb_t))))\n\t\treturn 0;\n\n\tif (numlvls > 0) {\n\t\tswitch (qmfbid) {\n\t\tcase JPC_COX_INS:\n\t\t\ttsfb->qmfb = &jpc_ns_qmfb2d;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase JPC_COX_RFT:\n\t\t\ttsfb->qmfb = &jpc_ft_qmfb2d;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttsfb->qmfb = 0;\n\t}\n\ttsfb->numlvls = numlvls;\n\treturn tsfb;\n}\n\nvoid jpc_tsfb_destroy(jpc_tsfb_t *tsfb)\n{\n\tfree(tsfb);\n}\n\nint jpc_tsfb_analyze(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_analyze2(tsfb, jas_seq2d_getref(a,\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a)), jas_seq2d_xstart(a),\n\t  jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n\nint jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n  int width, int height, int stride, int numlvls)\n{\n\tif (width > 0 && height > 0) {\n\t\tif ((*tsfb->qmfb->analyze)(a, xstart, ystart, width, height, stride))\n\t\t\treturn -1;\n\t\tif (numlvls > 0) {\n\t\t\tif (jpc_tsfb_analyze2(tsfb, a, JPC_CEILDIVPOW2(xstart,\n\t\t\t  1), JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(\n\t\t\t  xstart + width, 1) - JPC_CEILDIVPOW2(xstart, 1),\n\t\t\t  JPC_CEILDIVPOW2(ystart + height, 1) -\n\t\t\t  JPC_CEILDIVPOW2(ystart, 1), stride, numlvls - 1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n\nint jpc_tsfb_synthesize2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n  int width, int height, int stride, int numlvls)\n{\n\tif (numlvls > 0) {\n\t\tif (jpc_tsfb_synthesize2(tsfb, a, JPC_CEILDIVPOW2(xstart, 1),\n\t\t  JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(xstart + width,\n\t\t  1) - JPC_CEILDIVPOW2(xstart, 1), JPC_CEILDIVPOW2(ystart +\n\t\t  height, 1) - JPC_CEILDIVPOW2(ystart, 1), stride, numlvls -\n\t\t  1)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (width > 0 && height > 0) {\n\t\tif ((*tsfb->qmfb->synthesize)(a, xstart, ystart, width, height, stride)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jpc_tsfb_getbands(jpc_tsfb_t *tsfb, uint_fast32_t xstart,\n  uint_fast32_t ystart, uint_fast32_t xend, uint_fast32_t yend,\n  jpc_tsfb_band_t *bands)\n{\n\tjpc_tsfb_band_t *band;\n\n\tband = bands;\n\tif (tsfb->numlvls > 0) {\n\t\tjpc_tsfb_getbands2(tsfb, xstart, ystart, xstart, ystart, xend, yend,\n\t\t  &band, tsfb->numlvls);\n\t} else {\n\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = xstart;\n\t\tband->locystart = ystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = JPC_FIX_ONE;\n\t\t++band;\n\t}\n\treturn band - bands;\n}\n\nvoid jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart,\n  int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,\n  int numlvls)\n{\n\tint newxstart;\n\tint newystart;\n\tint newxend;\n\tint newyend;\n\tjpc_tsfb_band_t *band;\n\n\tnewxstart = JPC_CEILDIVPOW2(xstart, 1);\n\tnewystart = JPC_CEILDIVPOW2(ystart, 1);\n\tnewxend = JPC_CEILDIVPOW2(xend, 1);\n\tnewyend = JPC_CEILDIVPOW2(yend, 1);\n\n\tif (numlvls > 0) {\n\n\t\tjpc_tsfb_getbands2(tsfb, locxstart, locystart, newxstart, newystart,\n\t\t  newxend, newyend, bands, numlvls - 1);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = newystart;\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = newyend;\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = newxstart;\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = newxend;\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t} else {\n\n\t\tband = *bands;\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1]);\n\t\t++(*bands);\n\n\t}\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Math-Related Code\n *\n * $Id$\n */\n\n#ifndef\tJAS_MATH_H\n#define\tJAS_MATH_H\n\n/******************************************************************************\\\n* Includes\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Macros\n\\******************************************************************************/\n\n/* Compute the absolute value. */\n#define\tJAS_ABS(x) \\\n\t(((x) >= 0) ? (x) : (-(x)))\n\n/* Compute the minimum of two values. */\n#define\tJAS_MIN(x, y) \\\n\t(((x) < (y)) ? (x) : (y))\n\n/* Compute the maximum of two values. */\n#define\tJAS_MAX(x, y) \\\n\t(((x) > (y)) ? (x) : (y))\n\n/* Compute the remainder from division (where division is defined such\n  that the remainder is always nonnegative). */\n#define\tJAS_MOD(x, y) \\\n\t(((x) < 0) ? (((-x) % (y)) ? ((y) - ((-(x)) % (y))) : (0)) : ((x) % (y)))\n\n/* Compute the integer with the specified number of least significant bits\n  set to one. */\n#define\tJAS_ONES(n) \\\n  ((1 << (n)) - 1)\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n__attribute__((no_sanitize(\"undefined\")))\ninline static jas_int_asr(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x >> n;\n}\n\n__attribute__((no_sanitize(\"undefined\")))\ninline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}\n\n/******************************************************************************\\\n* Safe integer arithmetic (i.e., with overflow checking).\n\\******************************************************************************/\n\n/* Compute the product of two size_t integers with overflow checking. */\ninline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result)\n{\n\t/* Check if overflow would occur */\n\tif (x && y > SIZE_MAX / x) {\n\t\t/* Overflow would occur. */\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x * y;\n\treturn true;\n}\n\ninline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n{\n\tif (y > SIZE_MAX - x) {\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x + y;\n\treturn true;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n#ifndef JAS_SEQ_H\n#define JAS_SEQ_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <jasper/jas_stream.h>\n#include <jasper/jas_types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/* This matrix is a reference to another matrix. */\n#define JAS_MATRIX_REF\t0x0001\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* An element in a sequence. */\ntypedef int_fast32_t jas_seqent_t;\n\n/* An element in a matrix. */\ntypedef int_fast32_t jas_matent_t;\n\n/* Matrix. */\n\ntypedef struct {\n\n\t/* Additional state information. */\n\tint flags_;\n\n\t/* The starting horizontal index. */\n\tint_fast32_t xstart_;\n\n\t/* The starting vertical index. */\n\tint_fast32_t ystart_;\n\n\t/* The ending horizontal index. */\n\tint_fast32_t xend_;\n\n\t/* The ending vertical index. */\n\tint_fast32_t yend_;\n\n\t/* The number of rows in the matrix. */\n\tint_fast32_t numrows_;\n\n\t/* The number of columns in the matrix. */\n\tint_fast32_t numcols_;\n\n\t/* Pointers to the start of each row. */\n\tjas_seqent_t **rows_;\n\n\t/* The allocated size of the rows array. */\n\tint_fast32_t maxrows_;\n\n\t/* The matrix data buffer. */\n\tjas_seqent_t *data_;\n\n\t/* The allocated size of the data array. */\n\tint_fast32_t datasize_;\n\n} jas_matrix_t;\n\ntypedef jas_matrix_t jas_seq2d_t;\ntypedef jas_matrix_t jas_seq_t;\n\n/******************************************************************************\\\n* Functions/macros for matrix class.\n\\******************************************************************************/\n\n/* Get the number of rows. */\n#define jas_matrix_numrows(matrix) \\\n\t((matrix)->numrows_)\n\n/* Get the number of columns. */\n#define jas_matrix_numcols(matrix) \\\n\t((matrix)->numcols_)\n\n#define jas_matrix_size(matrix) \\\n\t(jas_matrix_width(matrix) * jas_matrix_height(matrix))\n\n/* Get a matrix element. */\n#define jas_matrix_get(matrix, i, j) \\\n\t((matrix)->rows_[i][j])\n\n/* Set a matrix element. */\n#define jas_matrix_set(matrix, i, j, v) \\\n\t((matrix)->rows_[i][j] = (v))\n\n/* Get an element from a matrix that is known to be a row or column vector. */\n#define jas_matrix_getv(matrix, i) \\\n\t(((matrix)->numrows_ == 1) ? ((matrix)->rows_[0][i]) : \\\n\t  ((matrix)->rows_[i][0]))\n\n/* Set an element in a matrix that is known to be a row or column vector. */\n#define jas_matrix_setv(matrix, i, v) \\\n\t(((matrix)->numrows_ == 1) ? ((matrix)->rows_[0][i] = (v)) : \\\n\t  ((matrix)->rows_[i][0] = (v)))\n\n/* Get the address of an element in a matrix. */\n#define\tjas_matrix_getref(matrix, i, j) \\\n\t(&(matrix)->rows_[i][j])\n\n#define\tjas_matrix_getvref(matrix, i) \\\n\t(((matrix)->numrows_ > 1) ? jas_matrix_getref(matrix, i, 0) : jas_matrix_getref(matrix, 0, i))\n\n#define jas_matrix_length(matrix) \\\n\t(max((matrix)->numrows_, (matrix)->numcols_))\n\n/* Create a matrix with the specified dimensions. */\njas_matrix_t *jas_matrix_create(int numrows, int numcols);\n\n/* Destroy a matrix. */\nvoid jas_matrix_destroy(jas_matrix_t *matrix);\n\n/* Resize a matrix.  The previous contents of the matrix are lost. */\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols);\n\nint jas_matrix_output(jas_matrix_t *matrix, FILE *out);\n\n/* Create a matrix that references part of another matrix. */\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,\n  int c0, int r1, int c1);\n\n/* Create a matrix that is a reference to a row of another matrix. */\n#define jas_matrix_bindrow(mat0, mat1, r) \\\n  (jas_matrix_bindsub((mat0), (mat1), (r), 0, (r), (mat1)->numcols_ - 1))\n\n/* Create a matrix that is a reference to a column of another matrix. */\n#define jas_matrix_bindcol(mat0, mat1, c) \\\n  (jas_matrix_bindsub((mat0), (mat1), 0, (c), (mat1)->numrows_ - 1, (c)))\n\n/* Clip the values of matrix elements to the specified range. */\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,\n  jas_seqent_t maxval);\n\n/* Arithmetic shift left of all elements in a matrix. */\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n);\n\n/* Arithmetic shift right of all elements in a matrix. */\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n);\n\n/* Almost-but-not-quite arithmetic shift right of all elements in a matrix. */\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n);\n\n/* Set all elements of a matrix to the specified value. */\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val);\n\n/* The spacing between rows of a matrix. */\n#define\tjas_matrix_rowstep(matrix) \\\n\t(((matrix)->numrows_ > 1) ? ((matrix)->rows_[1] - (matrix)->rows_[0]) : (0))\n\n/* The spacing between columns of a matrix. */\n#define\tjas_matrix_step(matrix) \\\n\t(((matrix)->numrows_ > 1) ? (jas_matrix_rowstep(matrix)) : (1))\n\n/* Compare two matrices for equality. */\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1);\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x);\n\njas_matrix_t *jas_matrix_input(FILE *);\n\n/******************************************************************************\\\n* Functions/macros for 2-D sequence class.\n\\******************************************************************************/\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x);\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n\n#define\tjas_seq2d_destroy(s) \\\n\tjas_matrix_destroy(s)\n\n#define\tjas_seq2d_xstart(s) \\\n\t((s)->xstart_)\n#define\tjas_seq2d_ystart(s) \\\n\t((s)->ystart_)\n#define\tjas_seq2d_xend(s) \\\n\t((s)->xend_)\n#define\tjas_seq2d_yend(s) \\\n\t((s)->yend_)\n#define\tjas_seq2d_getref(s, x, y) \\\n\t(jas_matrix_getref(s, (y) - (s)->ystart_, (x) - (s)->xstart_))\n#define\tjas_seq2d_get(s, x, y) \\\n\t(jas_matrix_get(s, (y) - (s)->ystart_, (x) - (s)->xstart_))\n#define\tjas_seq2d_rowstep(s) \\\n\tjas_matrix_rowstep(s)\n#define\tjas_seq2d_width(s) \\\n\t((s)->xend_ - (s)->xstart_)\n#define\tjas_seq2d_height(s) \\\n\t((s)->yend_ - (s)->ystart_)\n#define\tjas_seq2d_setshift(s, x, y) \\\n\t((s)->xstart_ = (x), (s)->ystart_ = (y), \\\n\t  (s)->xend_ = (s)->xstart_ + (s)->numcols_, \\\n\t  (s)->yend_ = (s)->ystart_ + (s)->numrows_)\n#define jas_seq2d_size(s) \\\n\t(jas_seq2d_width(s) * jas_seq2d_height(s))\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n  int ystart, int xend, int yend);\n\n/******************************************************************************\\\n* Functions/macros for 1-D sequence class.\n\\******************************************************************************/\n\n#define\tjas_seq_create(start, end) \\\n\t(jas_seq2d_create(start, 0, end, 1))\n\n#define\tjas_seq_destroy(seq) \\\n\t(jas_seq2d_destroy(seq))\n\n#define jas_seq_set(seq, i, v) \\\n\t((seq)->rows_[0][(i) - (seq)->xstart_] = (v))\n#define\tjas_seq_getref(seq, i) \\\n\t(&(seq)->rows_[0][(i) - (seq)->xstart_])\n#define\tjas_seq_get(seq, i) \\\n\t((seq)->rows_[0][(i) - (seq)->xstart_])\n#define\tjas_seq_start(seq) \\\n\t((seq)->xstart_)\n#define\tjas_seq_end(seq) \\\n\t((seq)->xend_)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\nfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\nfprintf(out, \"BAND %d\\n\", bandno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\nfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\nfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2004 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tree-Structured Filter Bank (TSFB) Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_seq.h\"\n\n#include \"jpc_tsfb.h\"\n#include \"jpc_cod.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_util.h\"\n#include \"jpc_math.h\"\n\nvoid jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart,\n  int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,\n  int numlvls);\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\njpc_tsfb_t *jpc_cod_gettsfb(int qmfbid, int numlvls)\n{\n\tjpc_tsfb_t *tsfb;\n\n\tif (!(tsfb = malloc(sizeof(jpc_tsfb_t))))\n\t\treturn 0;\n\n\tif (numlvls > 0) {\n\t\tswitch (qmfbid) {\n\t\tcase JPC_COX_INS:\n\t\t\ttsfb->qmfb = &jpc_ns_qmfb2d;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase JPC_COX_RFT:\n\t\t\ttsfb->qmfb = &jpc_ft_qmfb2d;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttsfb->qmfb = 0;\n\t}\n\ttsfb->numlvls = numlvls;\n\treturn tsfb;\n}\n\nvoid jpc_tsfb_destroy(jpc_tsfb_t *tsfb)\n{\n\tfree(tsfb);\n}\n\nint jpc_tsfb_analyze(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_analyze2(tsfb, jas_seq2d_getref(a,\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a)), jas_seq2d_xstart(a),\n\t  jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n\nint jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n  int width, int height, int stride, int numlvls)\n{\n\tif (width > 0 && height > 0) {\n\t\tif ((*tsfb->qmfb->analyze)(a, xstart, ystart, width, height, stride))\n\t\t\treturn -1;\n\t\tif (numlvls > 0) {\n\t\t\tif (jpc_tsfb_analyze2(tsfb, a, JPC_CEILDIVPOW2(xstart,\n\t\t\t  1), JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(\n\t\t\t  xstart + width, 1) - JPC_CEILDIVPOW2(xstart, 1),\n\t\t\t  JPC_CEILDIVPOW2(ystart + height, 1) -\n\t\t\t  JPC_CEILDIVPOW2(ystart, 1), stride, numlvls - 1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n\t  jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n\nint jpc_tsfb_synthesize2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n  int width, int height, int stride, int numlvls)\n{\n\tif (numlvls > 0) {\n\t\tif (jpc_tsfb_synthesize2(tsfb, a, JPC_CEILDIVPOW2(xstart, 1),\n\t\t  JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(xstart + width,\n\t\t  1) - JPC_CEILDIVPOW2(xstart, 1), JPC_CEILDIVPOW2(ystart +\n\t\t  height, 1) - JPC_CEILDIVPOW2(ystart, 1), stride, numlvls -\n\t\t  1)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (width > 0 && height > 0) {\n\t\tif ((*tsfb->qmfb->synthesize)(a, xstart, ystart, width, height, stride)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jpc_tsfb_getbands(jpc_tsfb_t *tsfb, uint_fast32_t xstart,\n  uint_fast32_t ystart, uint_fast32_t xend, uint_fast32_t yend,\n  jpc_tsfb_band_t *bands)\n{\n\tjpc_tsfb_band_t *band;\n\n\tband = bands;\n\tif (tsfb->numlvls > 0) {\n\t\tjpc_tsfb_getbands2(tsfb, xstart, ystart, xstart, ystart, xend, yend,\n\t\t  &band, tsfb->numlvls);\n\t} else {\n\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = xstart;\n\t\tband->locystart = ystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = JPC_FIX_ONE;\n\t\t++band;\n\t}\n\treturn band - bands;\n}\n\nvoid jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart,\n  int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,\n  int numlvls)\n{\n\tint newxstart;\n\tint newystart;\n\tint newxend;\n\tint newyend;\n\tjpc_tsfb_band_t *band;\n\n\tnewxstart = JPC_CEILDIVPOW2(xstart, 1);\n\tnewystart = JPC_CEILDIVPOW2(ystart, 1);\n\tnewxend = JPC_CEILDIVPOW2(xend, 1);\n\tnewyend = JPC_CEILDIVPOW2(yend, 1);\n\n\tif (numlvls > 0) {\n\n\t\tjpc_tsfb_getbands2(tsfb, locxstart, locystart, newxstart, newystart,\n\t\t  newxend, newyend, bands, numlvls - 1);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = newystart;\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = newyend;\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = newxstart;\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = newxend;\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t} else {\n\n\t\tband = *bands;\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1]);\n\t\t++(*bands);\n\n\t}\n\n}\n"], "filenames": ["src/libjasper/include/jasper/jas_math.h", "src/libjasper/include/jasper/jas_seq.h", "src/libjasper/jpc/jpc_dec.c", "src/libjasper/jpc/jpc_tsfb.c"], "buggy_code_start_loc": [115, 156, 1840, 151], "buggy_code_end_loc": [115, 271, 1860, 152], "fixing_code_start_loc": [116, 157, 1841, 151], "fixing_code_end_loc": [134, 277, 1867, 153], "type": "CWE-476", "message": "The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.", "other": {"cve": {"id": "CVE-2016-10248", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T14:59:00.167", "lastModified": "2018-06-29T01:29:00.533", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence."}, {"lang": "es", "value": "La funci\u00f3n jpc_tsfb_synthesize en jpc_tsfb.c en JasPer en versiones anteriores a 1.900.9 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) a trav\u00e9s de vectores que implican una secuencia vac\u00eda."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.8", "matchCriteriaId": "737A6392-6F8C-4639-8050-6CA8764D7AB7"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/93797", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/10/20/jasper-null-pointer-dereference-in-jpc_tsfb_synthesize-jpc_tsfb-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd"}}