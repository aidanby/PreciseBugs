{"buggy_code": ["Changes\n=======\n\nv2 has many incompatibilities with v1. To see the full list of differences between\nv1 and v2, please read the Changes-v2.md file (https://github.com/lestrrat-go/jwx/blob/develop/v2/Changes-v2.md)\n\nv2.0.17 20 Nov 2023\n[Bug Fixes]\n  * [jws] Previously, `jws.UnregisterSigner` did not remove the previous signer instance when\n    the signer was registered and unregistered multiple times (#1016). This has been fixed.\n\n[New Features]\n  * [jwe] (EXPERIMENTAL) `jwe.WithCEK` has been added to extract the content encryption key (CEK) from the Decrypt operation.\n  * [jwe] (EXPERIMENTAL) `jwe.EncryptStatic` has been added to encrypt content using a static CEK.\n    Using static CEKs has serious security implications, and you should not use\n    this unless you completely understand the risks involved.\n\nv2.0.16 31 Oct 2023\n[Security]\n  * [jws] ECDSA signature verification requires us to check if the signature\n    is of the desired length of bytes, but this check that used to exist before\n    had been removed in #65, resulting in certain malformed signatures to pass\n    verification.\n\n    One of the ways this could happen if R is a 31 byte integer and S is 32 byte integer,\n    both containing the correct signature values, but R is not zero-padded.\n\n       Correct = R: [ 0 , ... ] (32 bytes) S: [ ... ] (32 bytes)\n       Wrong   = R: [ ... ] (31 bytes)     S: [ ... ] (32 bytes)\n\n    In order for this check to pass, you would still need to have all 63 bytes\n    populated with the correct signature. The only modification a bad actor\n    may be able to do is to add one more byte at the end, in which case the\n    first 32 bytes (including what would have been S's first byte) is used for R,\n    and S would contain the rest. But this will only result in the verification to\n    fail. Therefore this in itself should not pose any security risk, albeit\n    allowing some illegally formated messages to be verified.\n\n  * [jwk] `jwk.Key` objects now have a `Validate()` method to validate the data\n    stored in the keys. However, this still does not necessarily mean that the key's\n    are valid for use in cryptographic operations. If `Validate()` is successful,\n    it only means that the keys are in the right _format_, including the presence\n    of required fields and that certain fields have proper length, etc.\n\n[New Features]\n  * [jws] Added `jws.WithValidateKey()` to force calling `key.Validate()` before\n    signing or verification.\n\n  * [jws] `jws.Sign()` now returns a special type of error that can hold the\n    individual errors from the signers. The stringification is still the same\n    as before to preserve backwards compatibility.\n\n  * [jwk] Added `jwk.IsKeyValidationError` that checks if an error is an error\n    from `key.Validate()`.\n\n[Bug Fixes]\n  * [jwt] `jwt.ParseInsecure()` was running verification if you provided a key\n    via `jwt.WithKey()` or `jwt.WithKeySet()` (#1007)\n\nv2.0.15 19 20 Oct 2023\n[Bug fixes]\n  * [jws] jws.Sign() now properly check for valid algorithm / key type pair when\n    the key implements crypto.Signer. This was caused by the fact that when \n    jws.WithKey() accepted keys that implemented crypto.Signer, there really\n    is no way to robustly check what algorithm the crypto.Signer implements.\n\n    The code has now been modified to check for KNOWN key types, i.e. those\n    that are defined in Go standard library, and those that are defined in\n    this library. For example, now calling jws.Sign() with jws.WithKey(jwa.RS256, ecdsaKey)\n    where ecdsaKey is either an instance of *ecdsa.PrivateKey or jwk.ECDSAPrivateKey\n    will produce an error.\n\n    However, if you use a separate library that wraps some KMS library which implements\n    crypto.Signer, this same check will not be performed due to the fact that\n    it is an unknown library to us. And there's no way to query a crypto.Signer\n    for its algorithm family.\n\nv2.0.14 17 Oct 2023\n[New Features]\n  * [jwk] jwk.IsPrivateKey(), as well as jwk.AsymmetricKey has been added.\n    The function can be used to tell if a jwk.Key is a private key of an\n    asymmetric key pair.\n[Security]\n  * golang.org/x/crypto has been updated to 0.14.0. The update contains a fix for HTTP/2\n    rapid reset DoS vulnerability, which some security scanning softwares may flag.\n    However, do note that this library is NOT affected by the issue, as it does not have\n    the capability to serve as an HTTP/2 server. This is included in this release\n    document so that users will be able to tell why this library may be flagged\n    when/if their scanning software do so.\n\nv2.0.13 26 Sep 2023\n[New Features]\n  * [jwk] jwk.Equal has been added. Please note that this is equivalent to\n  comparing the keys' thumbprints, therefore it does NOT take in consideration\n  non-essential fields.\n\n[Miscellaneous]\n  * Various documentation fixes and additions.\n\nv2.0.12 - 11 Aug 2023\n[Bug fixes]\n  * [jwt] jwt.Serializer was ignoring JWE flags (#951)\n\n[Miscellaneous]\n  * [jwk] Check for seed length on OKP JWKs to avoid panics (#947)\n  * [jws] Documentation for jws.WithKeySet()\n\nv2.0.11 - 14 Jun 2023\n[Security]\n  * Potential Padding Oracle Attack Vulnerability and Timing Attack Vulnerability \n    for JWE AES-CBC encrypted payloads affecting all v2 releases up to v2.0.10,\n    all v1 releases up to v1.2.25, and all v0 releases up to v0.9.2 have been reported by\n    @shogo82148.\n\n    Please note that v0 versions will NOT receive fixes.\n    This release fixes these vulnerabilities for the v2 series.\n\nv2.0.10 - 12 Jun 2023\n[New Features]\n  * [jwe] (EXPERIMENTAL) Added `jwe.KeyEncrypter` and `jwe.KeyDecrypter` interfaces\n    that works in similar ways as how `crypto.Signer` works for signature\n    generation and verification. It can act as the interface for your encryption/decryption\n    keys that are for example stored in an hardware device.\n\n    This feature is labeled experimental because the API for the above interfaces have not\n    been battle tested, and may need to changed yet. Please be aware that until the API\n    is deemed stable, you may have to adapat our code to these possible changes,\n    _even_ during minor version upgrades of this library.\n   \n[Bug fixes]\n  * Registering JWS signers/verifiers did not work since v2.0.0, because the\n    way we handle algorithm names changed in 2aa98ce6884187180a7145b73da78c859dd46c84.\n    (We previously thought that this would be checked by the example code, but it\n     apparently failed to flag us properly)\n\n    The logic behind managing the internal database has been fixed, and\n    `jws.RegisterSigner` and `jws.RegisterVerifier` now properly hooks into the new\n    `jwa.RegisterSignatureAlgorithm` to automatically register new algorithm names\n    (#910, #911)\n[Miscellaneous]\n  * Added limited support for github.com/segmentio/asm/base64. Compile your code\n    with the `jwx_asmbase64` build tag. This feature is EXPERIMENTAL.\n\n    Through limited testing, the use of a faster base64 library provide 1~5% increase\n    in throughput on average. It might make more difference if the input/output is large.\n    If you care about this performance improvement, you should probably enable\n    `goccy` JSON parser as well, by specifying `jwx_goccy,jwx_asmbase64` in your build call.\n  * Slightly changed the way global variables underneath `jwk.Fetch` are initialized and\n    configured. `jwk.Fetch` creates an object that spawns wokers to fetch JWKS when it's\n    first called.\n    You can now also use `jwk.SetGlobalFetcher()` to set a fetcher object which you can\n    control.\n\nv2.0.9 - 21 Mar 2023\n[Security Fixes]\n  * Updated use of golang.org/x/crypto to v0.7.0\n[Bug fixes]\n  * Emitted PEM file for EC private key types used the wrong PEM armor (#875)\n[Miscellaneous]\n  * Banners for generated files have been modified to allow tools to pick them up (#867)\n  * Remove unused variables around ReadFileOption (#866)\n  * Fix test failures\n  * Support bazel out of the box\n  * Now you can create JWS messages using `{\"alg\":\"none\"}`, by calling `jws.Sign()`\n    with `jws.WithInsecureNoSignature()` option. (#888, #890).\n\n    Note that there is no way to call\n    `jws.Verify()` while allowing `{\"alg\":\"none\"}` as you wouldn't be _verifying_\n    the message if we allowed the \"none\" algorithm. `jws.Parse()` will parse such\n    messages witout verification.\n\n    `jwt` also allows you to sign using alg=\"none\", but there's no symmetrical\n    way to verify such messages.\n\nv2.0.8 - 25 Nov 2022\n[Security Fixes]\n  * [jws][jwe] Starting from go 1.19, code related to elliptic algorithms\n    panics (instead of returning an error) when certain methods\n    such as `ScalarMult` are called using points that are not on the\n    elliptic curve being used.\n\n    Using inputs that cause this condition, and you accept unverified JWK\n    from the outside it may be possible for a third-party to cause panics\n    in your program.\n\n    This has been fixed by verifying that the point being used is actually\n    on the curve before such computations (#840)\n[Miscellaneous]\n  * `jwx.GuessFormat` now returns `jwx.InvalidFormat` when the heuristics\n    is sure that the buffer format is invalid.\n\nv2.0.7 - 15 Nov 2022\n[New features]\n  * [jwt] Each `jwt.Token` now has an `Options()` method\n  * [jwt] `jwt.Settings(jwt.WithFlattenedAudience(true))` has a slightly\n    different semantic than before. Instead of changing a global variable,\n    it now specifies that the default value of each per-token option for\n    `jwt.FlattenAudience` is true.\n\n    Therefore, this is what happens:\n\n       // No global settings\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // false\n\n       // With global settings\n       jwt.Settings(jwt.WithFlattenedAudience(true))\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // true\n       // But you can still turn FlattenAudience off for this\n       // token alone\n       tok.Options.Disable(jwt.FlattenAudience)\n\n    Note that while unlikely to happen for users relying on the old behavior,\n    this change DOES introduce timing issues: whereas old versions switched the\n    JSON marshaling for ALL tokens immediately after calling `jwt.Settings`,\n    the new behavior does NOT affect tokens that have been created before the\n    call to `jwt.Settings` (but marshaled afterwards).\n\n    So the following may happen:\n\n      // < v2.0.7\n      tok := jwt.New() \n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten = on\n\n      // >= v2.0.7\n      tok := jwt.New() // flatten = off\n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten is still off\n\n    It is recommended that you only set the global setting once at the\n    very beginning of your program to avoid problems.\n\n    Also note that `Clone()` copies the settings as well.\n\n[Miscellaneous]\n  * WithCompact's stringification should have been that of the\n    internal indentity struct (\"WithSerialization\"), but it was\n    wrongly producing \"WithCompact\". This has been fixed.\n  * Go Workspaces have been enabled within this module.\n    - When developing, modules will refer to the main jwx module that they\n      are part of. This allows us to explicitly specify the dependency version\n      in, for example, ./cmd/jwx/go.mod but still develop against the local version.\n    - If you are using `goimports` and other tools, you might want to upgrade\n      binaries -- for example, when using vim-go's auto-format-on-save feature,\n      my old binaries took well over 5~10 seconds to compute the import paths.\n      This was fixed when I switched to using go1.19, and upgraded the binaries\n      used by vim-go\n\nv2.0.6 - 25 Aug 2022\n[Bug fixes][Security]\n  * [jwe] Agreement Party UInfo and VInfo (apv/apu) were not properly being\n    passed to the functions to compute the aad when encrypting using ECDH-ES\n    family of algorithms. Therefore, when using apu/apv, messages encrypted\n    via this module would have failed to be properly decrypted.\n\n    Please note that bogus encrypted messages would not have succeed being\n    decrypted (i.e. this problem does not allow spoofed messages to be decrypted).\n    Therefore this would not have caused unwanted data to to creep in --\n    however it did pose problems for data to be sent and decrypted from this module\n    when using ECDH-ES with apu/apv.\n\n    While not extensively tested, we believe this regression was introduced\n    with the v2 release.\n\nv2.0.5 - 11 Aug 2022\n[Bug fixes]\n  * [jwt] Remove stray debug log\n  * [jwk] Fix x5u field name, caused by a typo\n  * [misc] Update golangci-lint action to v3; v2 was causing weird problems\n\nv2.0.4 - 19 Jul 2022\n[Bug Fixes]\n  * [jwk] github.com/lestrrat-go/httprc, which jwk.Cache depends on,\n    had a problem with inserting URLs to be re-fetched into its queue.\n    As a result it could have been the case that some JWKS were not\n    updated properly. Please upgrade if you use jwk.Cache.\n\n  * [jwk] cert.Get could fail with an out of bounds index look up\n\n  * [jwk] Fix doc buglet in `KeyType()` method\n\n[New Features]\n  * [jws] Add `jws.WithMultipleKeysPerKeyID()` sub-option to allow non-unique\n    key IDs in a given JWK set. By default we assume that a key ID is unique\n    within a key set, but enabling this option allows you to handle JWK sets\n    that contain multiple keys that contain the same key ID.\n\n  * [jwt] Before v2.0.1, sub-second accuracy for time based fields\n    (i.e. `iat`, `exp`, `nbf`) were not respected. Because of this the code\n    to evaluate this code had always truncated any-subsecond portion\n    of these fields, and therefore no sub-second comparisons worked.\n    A new option for validation `jwt.WithTruncation()` has been added\n    to workaround this. This option controls the value used to truncate\n    the time fields. When set to 0, sub-second comparison would be\n    possible.\n    FIY, truncatation will still happen because we do not want to\n    use the monotonic clocks when making comparisons. It's just that\n    truncating using `0` as its argument effectively only strips out\n    the monotonic clock\n\nv2.0.3 - 13 Jun 2022\n[Bug Fixes]\n  * [jwk] Update dependency on github.com/lestrrat-go/httprc to v1.0.2 to\n    avoid unintended blocking in the update goroutine for jwk.Cache\n\nv2.0.2 - 23 May 2022\n[Bug Fixes][Security]\n  * [jwe] An old bug from at least 7 years ago existed in handling AES-CBC unpadding,\n    where the unpad operation might remove more bytes than necessary (#744)\n    This affects all jwx code that is available before v2.0.2 and v1.2.25.\n\n[New Features]\n  * [jwt] RFC3339 timestamps are also accepted for Numeric Date types in JWT tokens.\n    This allows users to parse servers that errnously use RFC3339 timestamps in\n    some pre-defined fields. You can change this behavior by setting \n    `jwt.WithNumericDateParsePedantic` to `false`\n  * [jwt] `jwt.WithNumericDateParsePedantic` has been added. This is a global\n    option that is set using `jwt.Settings`\n\nv2.0.1 - 06 May 2022\n  * [jwk] `jwk.Set` had erronously been documented as not returning an error\n    when the same key already exists in the set. This is a behavior change\n    since v2, and it was missing in the docs (#730)\n  * [jwt] `jwt.ErrMissingRequiredClaim` has been deprecated. Please use\n    `jwt.ErrRequiredClaim` instead.\n  * [jwt] `jwt.WithNumericDateParsePrecision` and `jwt.WithNumericDateFormatPrecision`\n    have been added to parse and format fractional seconds. These options can be\n    passed to `jwt.Settings`.\n    The default precision is set to 0, and fractional portions are not parsed nor\n    formatted. The precision may be set up to 9.\n  * `golang.org/x/crypto` has been upgraded (#724)\n  * `io/ioutil` has been removed from the source code.\n\nv2.0.0 - 24 Apr 2022\n  * This i the first v2 release, which represents a set of design changes\n    that were learnt over the previous 2 years. As a result the v2 API\n    should be much more consistent and uniform across packages, and\n    should be much more flexible to accomodate real-world needs.\n    \n    For a complete list of changes, please see the Changes-v2.md file,\n    or check the diff at https://github.com/lestrrat-go/jwx/compare/v1...v2\n\n[Miscellaneous]\n  * Minor house cleaning on code generation tools\n\n[jwt]\n  * `jwt.ErrMissingRequiredClaim()` has been added\n\nv2.0.0-beta2 - 16 Apr 2022\n[jwk]\n  * Updated `jwk.Set` API and reflected pending changes from v1 which were\n    left over. Please see Changes-v2.md file for details.\n\n  * Added `jwk.CachedSet`, a shim over `jwk.Cache` that allows you to\n    have to write wrappers around `jwk.Cache` that retrieves a particular\n    `jwk.Set` out of it. You can use it to, for example, pass `jwk.CachedSet`\n    to a `jws.Verify`\n\n      cache := jwk.NewCache(ctx)\n      cache.Register(ctx, jwksURL)\n      cachedSet := jwk.NewCachedSet(cache, jwksURL)\n      jws.Verify(signed, jws.WithKeySet(cachedSet))\n\nv2.0.0-beta1 - 09 Apr 2022\n[Miscellaneous]\n  * Renamed Changes.v2 to Changes-v2.md\n  * Housecleaning for lint action.\n  * While v2 was not affected, ported over equivalent test for #681 to catch\n    regressions in the future.\n  * Please note that there is no stability guarantees on pre-releases.\n\nv2.0.0-alpha1 - 04 Apr 2022\n  * Initial pre-release of v2 line. Please note that there is no stability guarantees\n    on pre-releases.\n", "//go:generate ../tools/cmd/genjwe.sh\n\n// Package jwe implements JWE as described in https://tools.ietf.org/html/rfc7516\npackage jwe\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/lestrrat-go/blackmagic\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/keyconv\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/content_crypt\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/keyenc\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/keygen\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n)\n\nconst (\n\tfmtInvalid = iota\n\tfmtCompact\n\tfmtJSON\n\tfmtJSONPretty\n\tfmtMax\n)\n\nvar _ = fmtInvalid\nvar _ = fmtMax\n\nvar registry = json.NewRegistry()\n\ntype keyEncrypterWrapper struct {\n\tencrypter KeyEncrypter\n}\n\nfunc (w *keyEncrypterWrapper) Algorithm() jwa.KeyEncryptionAlgorithm {\n\treturn w.encrypter.Algorithm()\n}\n\nfunc (w *keyEncrypterWrapper) EncryptKey(cek []byte) (keygen.ByteSource, error) {\n\tencrypted, err := w.encrypter.EncryptKey(cek)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn keygen.ByteKey(encrypted), nil\n}\n\ntype recipientBuilder struct {\n\talg     jwa.KeyEncryptionAlgorithm\n\tkey     interface{}\n\theaders Headers\n}\n\nfunc (b *recipientBuilder) Build(cek []byte, calg jwa.ContentEncryptionAlgorithm, cc *content_crypt.Generic) (Recipient, []byte, error) {\n\tvar enc keyenc.Encrypter\n\n\t// we need the raw key for later use\n\trawKey := b.key\n\n\tvar keyID string\n\tif ke, ok := b.key.(KeyEncrypter); ok {\n\t\tenc = &keyEncrypterWrapper{encrypter: ke}\n\t\tif kider, ok := enc.(KeyIDer); ok {\n\t\t\tkeyID = kider.KeyID()\n\t\t}\n\t} else if jwkKey, ok := b.key.(jwk.Key); ok {\n\t\t// Meanwhile, grab the kid as well\n\t\tkeyID = jwkKey.KeyID()\n\n\t\tvar raw interface{}\n\t\tif err := jwkKey.Raw(&raw); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to retrieve raw key out of %T: %w`, b.key, err)\n\t\t}\n\n\t\trawKey = raw\n\t}\n\n\tif enc == nil {\n\t\tswitch b.alg {\n\t\tcase jwa.RSA1_5:\n\t\t\tvar pubkey rsa.PublicKey\n\t\t\tif err := keyconv.RSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, rawKey, err)\n\t\t\t}\n\n\t\t\tv, err := keyenc.NewRSAPKCSEncrypt(b.alg, &pubkey)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create RSA PKCS encrypter: %w`, err)\n\t\t\t}\n\t\t\tenc = v\n\t\tcase jwa.RSA_OAEP, jwa.RSA_OAEP_256:\n\t\t\tvar pubkey rsa.PublicKey\n\t\t\tif err := keyconv.RSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, rawKey, err)\n\t\t\t}\n\n\t\t\tv, err := keyenc.NewRSAOAEPEncrypt(b.alg, &pubkey)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create RSA OAEP encrypter: %w`, err)\n\t\t\t}\n\t\t\tenc = v\n\t\tcase jwa.A128KW, jwa.A192KW, jwa.A256KW,\n\t\t\tjwa.A128GCMKW, jwa.A192GCMKW, jwa.A256GCMKW,\n\t\t\tjwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\t\tsharedkey, ok := rawKey.([]byte)\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, fmt.Errorf(`invalid key: []byte required (%T)`, rawKey)\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tswitch b.alg {\n\t\t\tcase jwa.A128KW, jwa.A192KW, jwa.A256KW:\n\t\t\t\tenc, err = keyenc.NewAES(b.alg, sharedkey)\n\t\t\tcase jwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\t\t\tenc, err = keyenc.NewPBES2Encrypt(b.alg, sharedkey)\n\t\t\tdefault:\n\t\t\t\tenc, err = keyenc.NewAESGCMEncrypt(b.alg, sharedkey)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create key wrap encrypter: %w`, err)\n\t\t\t}\n\t\t\t// NOTE: there was formerly a restriction, introduced\n\t\t\t// in PR #26, which disallowed certain key/content\n\t\t\t// algorithm combinations. This seemed bogus, and\n\t\t\t// interop with the jose tool demonstrates it.\n\t\tcase jwa.ECDH_ES, jwa.ECDH_ES_A128KW, jwa.ECDH_ES_A192KW, jwa.ECDH_ES_A256KW:\n\t\t\tvar keysize int\n\t\t\tswitch b.alg {\n\t\t\tcase jwa.ECDH_ES:\n\t\t\t\t// https://tools.ietf.org/html/rfc7518#page-15\n\t\t\t\t// In Direct Key Agreement mode, the output of the Concat KDF MUST be a\n\t\t\t\t// key of the same length as that used by the \"enc\" algorithm.\n\t\t\t\tkeysize = cc.KeySize()\n\t\t\tcase jwa.ECDH_ES_A128KW:\n\t\t\t\tkeysize = 16\n\t\t\tcase jwa.ECDH_ES_A192KW:\n\t\t\t\tkeysize = 24\n\t\t\tcase jwa.ECDH_ES_A256KW:\n\t\t\t\tkeysize = 32\n\t\t\t}\n\n\t\t\tswitch key := rawKey.(type) {\n\t\t\tcase x25519.PublicKey:\n\t\t\t\tvar apu, apv []byte\n\t\t\t\tif hdrs := b.headers; hdrs != nil {\n\t\t\t\t\tapu = hdrs.AgreementPartyUInfo()\n\t\t\t\t\tapv = hdrs.AgreementPartyVInfo()\n\t\t\t\t}\n\n\t\t\t\tv, err := keyenc.NewECDHESEncrypt(b.alg, calg, keysize, rawKey, apu, apv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create ECDHS key wrap encrypter: %w`, err)\n\t\t\t\t}\n\t\t\t\tenc = v\n\t\t\tdefault:\n\t\t\t\tvar pubkey ecdsa.PublicKey\n\t\t\t\tif err := keyconv.ECDSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, key, err)\n\t\t\t\t}\n\n\t\t\t\tvar apu, apv []byte\n\t\t\t\tif hdrs := b.headers; hdrs != nil {\n\t\t\t\t\tapu = hdrs.AgreementPartyUInfo()\n\t\t\t\t\tapv = hdrs.AgreementPartyVInfo()\n\t\t\t\t}\n\n\t\t\t\tv, err := keyenc.NewECDHESEncrypt(b.alg, calg, keysize, &pubkey, apu, apv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create ECDHS key wrap encrypter: %w`, err)\n\t\t\t\t}\n\t\t\t\tenc = v\n\t\t\t}\n\t\tcase jwa.DIRECT:\n\t\t\tsharedkey, ok := rawKey.([]byte)\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid key: []byte required\")\n\t\t\t}\n\t\t\tenc, _ = keyenc.NewNoop(b.alg, sharedkey)\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(`invalid key encryption algorithm (%s)`, b.alg)\n\t\t}\n\t}\n\n\tr := NewRecipient()\n\tif hdrs := b.headers; hdrs != nil {\n\t\t_ = r.SetHeaders(hdrs)\n\t}\n\n\tif err := r.Headers().Set(AlgorithmKey, b.alg); err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to set header: %w`, err)\n\t}\n\n\tif keyID != \"\" {\n\t\tif err := r.Headers().Set(KeyIDKey, keyID); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to set header: %w`, err)\n\t\t}\n\t}\n\n\tvar rawCEK []byte\n\tenckey, err := enc.EncryptKey(cek)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to encrypt key: %w`, err)\n\t}\n\tif enc.Algorithm() == jwa.ECDH_ES || enc.Algorithm() == jwa.DIRECT {\n\t\trawCEK = enckey.Bytes()\n\t} else {\n\t\tif err := r.SetEncryptedKey(enckey.Bytes()); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to set encrypted key: %w`, err)\n\t\t}\n\t}\n\n\tif hp, ok := enckey.(populater); ok {\n\t\tif err := hp.Populate(r.Headers()); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to populate: %w`, err)\n\t\t}\n\t}\n\n\treturn r, rawCEK, nil\n}\n\n// Encrypt generates a JWE message for the given payload and returns\n// it in serialized form, which can be in either compact or\n// JSON format. Default is compact.\n//\n// You must pass at least one key to `jwe.Encrypt()` by using `jwe.WithKey()`\n// option.\n//\n//\tjwe.Encrypt(payload, jwe.WithKey(alg, key))\n//\tjwe.Encrypt(payload, jws.WithJSON(), jws.WithKey(alg1, key1), jws.WithKey(alg2, key2))\n//\n// Note that in the second example the `jws.WithJSON()` option is\n// specified as well. This is because the compact serialization\n// format does not support multiple recipients, and users must\n// specifically ask for the JSON serialization format.\n//\n// Read the documentation for `jwe.WithKey()` to learn more about the\n// possible values that can be used for `alg` and `key`.\n//\n// Look for options that return `jwe.EncryptOption` or `jws.EncryptDecryptOption`\n// for a complete list of options that can be passed to this function.\nfunc Encrypt(payload []byte, options ...EncryptOption) ([]byte, error) {\n\treturn encrypt(payload, nil, options...)\n}\n\n// Encryptstatic is exactly like Encrypt, except it accepts a static\n// content encryption key (CEK). It is separated out from the main\n// Encrypt function such that the latter does not accidentally use a static\n// CEK.\n//\n// DO NOT attempt to use this function unless you completely understand the\n// security implications to using static CEKs. You have been warned.\n//\n// This function is currently considered EXPERIMENTAL, and is subject to\n// future changes across minor/micro versions.\nfunc EncryptStatic(payload, cek []byte, options ...EncryptOption) ([]byte, error) {\n\tif len(cek) <= 0 {\n\t\treturn nil, fmt.Errorf(`jwe.EncryptStatic: empty CEK`)\n\t}\n\treturn encrypt(payload, cek, options...)\n}\n\n// encrypt is separate so it can receive cek from outside.\n// (but we don't want to receive it in the options slice)\nfunc encrypt(payload, cek []byte, options ...EncryptOption) ([]byte, error) {\n\t// default content encryption algorithm\n\tcalg := jwa.A256GCM\n\n\t// default compression is \"none\"\n\tcompression := jwa.NoCompress\n\n\t// default format is compact serialization\n\tformat := fmtCompact\n\n\t// builds each \"recipient\" with encrypted_key and headers\n\tvar builders []*recipientBuilder\n\n\tvar protected Headers\n\tvar mergeProtected bool\n\tvar useRawCEK bool\n\tfor _, option := range options {\n\t\t//nolint:forcetypeassert\n\t\tswitch option.Ident() {\n\t\tcase identKey{}:\n\t\t\tdata := option.Value().(*withKey)\n\t\t\tv, ok := data.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: expected alg to be jwa.KeyEncryptionAlgorithm, but got %T`, data.alg)\n\t\t\t}\n\n\t\t\tswitch v {\n\t\t\tcase jwa.DIRECT, jwa.ECDH_ES:\n\t\t\t\tuseRawCEK = true\n\t\t\t}\n\n\t\t\tbuilders = append(builders, &recipientBuilder{\n\t\t\t\talg:     v,\n\t\t\t\tkey:     data.key,\n\t\t\t\theaders: data.headers,\n\t\t\t})\n\t\tcase identContentEncryptionAlgorithm{}:\n\t\t\tcalg = option.Value().(jwa.ContentEncryptionAlgorithm)\n\t\tcase identCompress{}:\n\t\t\tcompression = option.Value().(jwa.CompressionAlgorithm)\n\t\tcase identMergeProtectedHeaders{}:\n\t\t\tmergeProtected = option.Value().(bool)\n\t\tcase identProtectedHeaders{}:\n\t\t\tv := option.Value().(Headers)\n\t\t\tif !mergeProtected || protected == nil {\n\t\t\t\tprotected = v\n\t\t\t} else {\n\t\t\t\tctx := context.TODO()\n\t\t\t\tmerged, err := protected.Merge(ctx, v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to merge headers: %w`, err)\n\t\t\t\t}\n\t\t\t\tprotected = merged\n\t\t\t}\n\t\tcase identSerialization{}:\n\t\t\tformat = option.Value().(int)\n\t\t}\n\t}\n\n\t// We need to have at least one builder\n\tswitch l := len(builders); {\n\tcase l == 0:\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: missing key encryption builders: use jwe.WithKey() to specify one`)\n\tcase l > 1:\n\t\tif format == fmtCompact {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: cannot use compact serialization when multiple recipients exist (check the number of WithKey() argument, or use WithJSON())`)\n\t\t}\n\t}\n\n\tif useRawCEK {\n\t\tif len(builders) != 1 {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: multiple recipients for ECDH-ES/DIRECT mode supported`)\n\t\t}\n\t}\n\n\t// There is exactly one content encrypter.\n\tcontentcrypt, err := content_crypt.NewGeneric(calg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to create AES encrypter: %w`, err)\n\t}\n\n\tif len(cek) <= 0 {\n\t\tgenerator := keygen.NewRandom(contentcrypt.KeySize())\n\t\tbk, err := generator.Generate()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to generate key: %w`, err)\n\t\t}\n\t\tcek = bk.Bytes()\n\t}\n\n\trecipients := make([]Recipient, len(builders))\n\tfor i, builder := range builders {\n\t\t// some builders require hint from the contentcrypt object\n\t\tr, rawCEK, err := builder.Build(cek, calg, contentcrypt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to create recipient #%d: %w`, i, err)\n\t\t}\n\t\trecipients[i] = r\n\n\t\t// Kinda feels weird, but if useRawCEK == true, we asserted earlier\n\t\t// that len(builders) == 1, so this is OK\n\t\tif useRawCEK {\n\t\t\tcek = rawCEK\n\t\t}\n\t}\n\n\tif protected == nil {\n\t\tprotected = NewHeaders()\n\t}\n\n\tif err := protected.Set(ContentEncryptionKey, calg); err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to set \"enc\" in protected header: %w`, err)\n\t}\n\n\tif compression != jwa.NoCompress {\n\t\tpayload, err = compress(payload)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to compress payload before encryption: %w`, err)\n\t\t}\n\t\tif err := protected.Set(CompressionKey, compression); err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to set \"zip\" in protected header: %w`, err)\n\t\t}\n\t}\n\n\t// If there's only one recipient, you want to include that in the\n\t// protected header\n\tif len(recipients) == 1 {\n\t\th, err := protected.Merge(context.TODO(), recipients[0].Headers())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to merge protected headers: %w`, err)\n\t\t}\n\t\tprotected = h\n\t}\n\n\taad, err := protected.Encode()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 encode protected headers: %w`, err)\n\t}\n\n\tiv, ciphertext, tag, err := contentcrypt.Encrypt(cek, payload, aad)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to encrypt payload: %w`, err)\n\t}\n\n\tmsg := NewMessage()\n\n\tif err := msg.Set(CipherTextKey, ciphertext); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, CipherTextKey, err)\n\t}\n\tif err := msg.Set(InitializationVectorKey, iv); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, InitializationVectorKey, err)\n\t}\n\tif err := msg.Set(ProtectedHeadersKey, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, ProtectedHeadersKey, err)\n\t}\n\tif err := msg.Set(RecipientsKey, recipients); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, RecipientsKey, err)\n\t}\n\tif err := msg.Set(TagKey, tag); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, TagKey, err)\n\t}\n\n\tswitch format {\n\tcase fmtCompact:\n\t\treturn Compact(msg)\n\tcase fmtJSON:\n\t\treturn json.Marshal(msg)\n\tcase fmtJSONPretty:\n\t\treturn json.MarshalIndent(msg, \"\", \"  \")\n\tdefault:\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: invalid serialization`)\n\t}\n}\n\ntype decryptCtx struct {\n\tmsg              *Message\n\taad              []byte\n\tcek              *[]byte\n\tcomputedAad      []byte\n\tkeyProviders     []KeyProvider\n\tprotectedHeaders Headers\n}\n\n// Decrypt takes the key encryption algorithm and the corresponding\n// key to decrypt the JWE message, and returns the decrypted payload.\n// The JWE message can be either compact or full JSON format.\n//\n// `alg` accepts a `jwa.KeyAlgorithm` for convenience so you can directly pass\n// the result of `(jwk.Key).Algorithm()`, but in practice it must be of type\n// `jwa.KeyEncryptionAlgorithm` or otherwise it will cause an error.\n//\n// `key` must be a private key. It can be either in its raw format (e.g. *rsa.PrivateKey) or a jwk.Key\nfunc Decrypt(buf []byte, options ...DecryptOption) ([]byte, error) {\n\tvar keyProviders []KeyProvider\n\tvar keyUsed interface{}\n\tvar cek *[]byte\n\tvar dst *Message\n\t//nolint:forcetypeassert\n\tfor _, option := range options {\n\t\tswitch option.Ident() {\n\t\tcase identMessage{}:\n\t\t\tdst = option.Value().(*Message)\n\t\tcase identKeyProvider{}:\n\t\t\tkeyProviders = append(keyProviders, option.Value().(KeyProvider))\n\t\tcase identKeyUsed{}:\n\t\t\tkeyUsed = option.Value()\n\t\tcase identKey{}:\n\t\t\tpair := option.Value().(*withKey)\n\t\t\talg, ok := pair.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(`WithKey() option must be specified using jwa.KeyEncryptionAlgorithm (got %T)`, pair.alg)\n\t\t\t}\n\t\t\tkeyProviders = append(keyProviders, &staticKeyProvider{\n\t\t\t\talg: alg,\n\t\t\t\tkey: pair.key,\n\t\t\t})\n\t\tcase identCEK{}:\n\t\t\tcek = option.Value().(*[]byte)\n\t\t}\n\t}\n\n\tif len(keyProviders) < 1 {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: no key providers have been provided (see jwe.WithKey(), jwe.WithKeySet(), and jwe.WithKeyProvider()`)\n\t}\n\n\tmsg, err := parseJSONOrCompact(buf, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse buffer for Decrypt: %w`, err)\n\t}\n\n\t// Process things that are common to the message\n\tctx := context.TODO()\n\th, err := msg.protectedHeaders.Clone(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to copy protected headers: %w`, err)\n\t}\n\th, err = h.Merge(ctx, msg.unprotectedHeaders)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to merge headers for message decryption: %w`, err)\n\t}\n\n\tvar aad []byte\n\tif aadContainer := msg.authenticatedData; aadContainer != nil {\n\t\taad = base64.Encode(aadContainer)\n\t}\n\n\tvar computedAad []byte\n\tif len(msg.rawProtectedHeaders) > 0 {\n\t\tcomputedAad = msg.rawProtectedHeaders\n\t} else {\n\t\t// this is probably not required once msg.Decrypt is deprecated\n\t\tvar err error\n\t\tcomputedAad, err = msg.protectedHeaders.Encode()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to encode protected headers: %w`, err)\n\t\t}\n\t}\n\n\t// for each recipient, attempt to match the key providers\n\t// if we have no recipients, pretend like we only have one\n\trecipients := msg.recipients\n\tif len(recipients) == 0 {\n\t\tr := NewRecipient()\n\t\tif err := r.SetHeaders(msg.protectedHeaders); err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to set headers to recipient: %w`, err)\n\t\t}\n\t\trecipients = append(recipients, r)\n\t}\n\n\tvar dctx decryptCtx\n\n\tdctx.aad = aad\n\tdctx.computedAad = computedAad\n\tdctx.msg = msg\n\tdctx.keyProviders = keyProviders\n\tdctx.protectedHeaders = h\n\tdctx.cek = cek\n\n\tvar lastError error\n\tfor _, recipient := range recipients {\n\t\tdecrypted, err := dctx.try(ctx, recipient, keyUsed)\n\t\tif err != nil {\n\t\t\tlastError = err\n\t\t\tcontinue\n\t\t}\n\t\tif dst != nil {\n\t\t\t*dst = *msg\n\t\t\tdst.rawProtectedHeaders = nil\n\t\t\tdst.storeProtectedHeaders = false\n\t\t}\n\t\treturn decrypted, nil\n\t}\n\treturn nil, fmt.Errorf(`jwe.Decrypt: failed to decrypt any of the recipients (last error = %w)`, lastError)\n}\n\nfunc (dctx *decryptCtx) try(ctx context.Context, recipient Recipient, keyUsed interface{}) ([]byte, error) {\n\tvar tried int\n\tvar lastError error\n\tfor i, kp := range dctx.keyProviders {\n\t\tvar sink algKeySink\n\t\tif err := kp.FetchKeys(ctx, &sink, recipient, dctx.msg); err != nil {\n\t\t\treturn nil, fmt.Errorf(`key provider %d failed: %w`, i, err)\n\t\t}\n\n\t\tfor _, pair := range sink.list {\n\t\t\ttried++\n\t\t\t// alg is converted here because pair.alg is of type jwa.KeyAlgorithm.\n\t\t\t// this may seem ugly, but we're trying to avoid declaring separate\n\t\t\t// structs for `alg jwa.KeyAlgorithm` and `alg jwa.SignatureAlgorithm`\n\t\t\t//nolint:forcetypeassert\n\t\t\talg := pair.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tkey := pair.key\n\n\t\t\tdecrypted, err := dctx.decryptContent(ctx, alg, key, recipient)\n\t\t\tif err != nil {\n\t\t\t\tlastError = err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif keyUsed != nil {\n\t\t\t\tif err := blackmagic.AssignIfCompatible(keyUsed, key); err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(`failed to assign used key (%T) to %T: %w`, key, keyUsed, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn decrypted, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(`jwe.Decrypt: tried %d keys, but failed to match any of the keys with recipient (last error = %s)`, tried, lastError)\n}\n\nfunc (dctx *decryptCtx) decryptContent(ctx context.Context, alg jwa.KeyEncryptionAlgorithm, key interface{}, recipient Recipient) ([]byte, error) {\n\tif jwkKey, ok := key.(jwk.Key); ok {\n\t\tvar raw interface{}\n\t\tif err := jwkKey.Raw(&raw); err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to retrieve raw key from %T: %w`, key, err)\n\t\t}\n\t\tkey = raw\n\t}\n\n\tdec := newDecrypter(alg, dctx.msg.protectedHeaders.ContentEncryption(), key).\n\t\tAuthenticatedData(dctx.aad).\n\t\tComputedAuthenticatedData(dctx.computedAad).\n\t\tInitializationVector(dctx.msg.initializationVector).\n\t\tTag(dctx.msg.tag).\n\t\tCEK(dctx.cek)\n\n\tif recipient.Headers().Algorithm() != alg {\n\t\t// algorithms don't match\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: key and recipient algorithms do not match`)\n\t}\n\n\th2, err := dctx.protectedHeaders.Clone(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: failed to copy headers (1): %w`, err)\n\t}\n\n\th2, err = h2.Merge(ctx, recipient.Headers())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to copy headers (2): %w`, err)\n\t}\n\n\tswitch alg {\n\tcase jwa.ECDH_ES, jwa.ECDH_ES_A128KW, jwa.ECDH_ES_A192KW, jwa.ECDH_ES_A256KW:\n\t\tepkif, ok := h2.Get(EphemeralPublicKeyKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'epk' field`)\n\t\t}\n\t\tswitch epk := epkif.(type) {\n\t\tcase jwk.ECDSAPublicKey:\n\t\t\tvar pubkey ecdsa.PublicKey\n\t\t\tif err := epk.Raw(&pubkey); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to get public key: %w`, err)\n\t\t\t}\n\t\t\tdec.PublicKey(&pubkey)\n\t\tcase jwk.OKPPublicKey:\n\t\t\tvar pubkey interface{}\n\t\t\tif err := epk.Raw(&pubkey); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to get public key: %w`, err)\n\t\t\t}\n\t\t\tdec.PublicKey(pubkey)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected 'epk' type %T for alg %s\", epkif, alg)\n\t\t}\n\n\t\tif apu := h2.AgreementPartyUInfo(); len(apu) > 0 {\n\t\t\tdec.AgreementPartyUInfo(apu)\n\t\t}\n\t\tif apv := h2.AgreementPartyVInfo(); len(apv) > 0 {\n\t\t\tdec.AgreementPartyVInfo(apv)\n\t\t}\n\tcase jwa.A128GCMKW, jwa.A192GCMKW, jwa.A256GCMKW:\n\t\tivB64, ok := h2.Get(InitializationVectorKey)\n\t\tif ok {\n\t\t\tivB64Str, ok := ivB64.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'iv': %T\", ivB64)\n\t\t\t}\n\t\t\tiv, err := base64.DecodeString(ivB64Str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'iv': %w`, err)\n\t\t\t}\n\t\t\tdec.KeyInitializationVector(iv)\n\t\t}\n\t\ttagB64, ok := h2.Get(TagKey)\n\t\tif ok {\n\t\t\ttagB64Str, ok := tagB64.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'tag': %T\", tagB64)\n\t\t\t}\n\t\t\ttag, err := base64.DecodeString(tagB64Str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'tag': %w`, err)\n\t\t\t}\n\t\t\tdec.KeyTag(tag)\n\t\t}\n\tcase jwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\tsaltB64, ok := h2.Get(SaltKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'p2s' field`)\n\t\t}\n\t\tsaltB64Str, ok := saltB64.(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'p2s': %T\", saltB64)\n\t\t}\n\n\t\tcount, ok := h2.Get(CountKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'p2c' field`)\n\t\t}\n\t\tcountFlt, ok := count.(float64)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'p2c': %T\", count)\n\t\t}\n\t\tsalt, err := base64.DecodeString(saltB64Str)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'salt': %w`, err)\n\t\t}\n\t\tdec.KeySalt(salt)\n\t\tdec.KeyCount(int(countFlt))\n\t}\n\n\tplaintext, err := dec.Decrypt(recipient, dctx.msg.cipherText, dctx.msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: decryption failed: %w`, err)\n\t}\n\n\tif h2.Compression() == jwa.Deflate {\n\t\tbuf, err := uncompress(plaintext)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Derypt: failed to uncompress payload: %w`, err)\n\t\t}\n\t\tplaintext = buf\n\t}\n\n\tif plaintext == nil {\n\t\treturn nil, fmt.Errorf(`failed to find matching recipient`)\n\t}\n\n\treturn plaintext, nil\n}\n\n// Parse parses the JWE message into a Message object. The JWE message\n// can be either compact or full JSON format.\n//\n// Parse() currently does not take any options, but the API accepts it\n// in anticipation of future addition.\nfunc Parse(buf []byte, _ ...ParseOption) (*Message, error) {\n\treturn parseJSONOrCompact(buf, false)\n}\n\nfunc parseJSONOrCompact(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tbuf = bytes.TrimSpace(buf)\n\tif len(buf) == 0 {\n\t\treturn nil, fmt.Errorf(`empty buffer`)\n\t}\n\n\tif buf[0] == '{' {\n\t\treturn parseJSON(buf, storeProtectedHeaders)\n\t}\n\treturn parseCompact(buf, storeProtectedHeaders)\n}\n\n// ParseString is the same as Parse, but takes a string.\nfunc ParseString(s string) (*Message, error) {\n\treturn Parse([]byte(s))\n}\n\n// ParseReader is the same as Parse, but takes an io.Reader.\nfunc ParseReader(src io.Reader) (*Message, error) {\n\tbuf, err := io.ReadAll(src)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to read from io.Reader: %w`, err)\n\t}\n\treturn Parse(buf)\n}\n\nfunc parseJSON(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tm := NewMessage()\n\tm.storeProtectedHeaders = storeProtectedHeaders\n\tif err := json.Unmarshal(buf, &m); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse JSON: %w`, err)\n\t}\n\treturn m, nil\n}\n\nfunc parseCompact(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tparts := bytes.Split(buf, []byte{'.'})\n\tif len(parts) != 5 {\n\t\treturn nil, fmt.Errorf(`compact JWE format must have five parts (%d)`, len(parts))\n\t}\n\n\thdrbuf, err := base64.Decode(parts[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse first part of compact form: %w`, err)\n\t}\n\n\tprotected := NewHeaders()\n\tif err := json.Unmarshal(hdrbuf, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse header JSON: %w`, err)\n\t}\n\n\tivbuf, err := base64.Decode(parts[2])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode iv: %w`, err)\n\t}\n\n\tctbuf, err := base64.Decode(parts[3])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode content: %w`, err)\n\t}\n\n\ttagbuf, err := base64.Decode(parts[4])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode tag: %w`, err)\n\t}\n\n\tm := NewMessage()\n\tif err := m.Set(CipherTextKey, ctbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, CipherTextKey, err)\n\t}\n\tif err := m.Set(InitializationVectorKey, ivbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, InitializationVectorKey, err)\n\t}\n\tif err := m.Set(ProtectedHeadersKey, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, ProtectedHeadersKey, err)\n\t}\n\n\tif err := m.makeDummyRecipient(string(parts[1]), protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to setup recipient: %w`, err)\n\t}\n\n\tif err := m.Set(TagKey, tagbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, TagKey, err)\n\t}\n\n\tif storeProtectedHeaders {\n\t\t// This is later used for decryption.\n\t\tm.rawProtectedHeaders = parts[0]\n\t}\n\n\treturn m, nil\n}\n\n// RegisterCustomField allows users to specify that a private field\n// be decoded as an instance of the specified type. This option has\n// a global effect.\n//\n// For example, suppose you have a custom field `x-birthday`, which\n// you want to represent as a string formatted in RFC3339 in JSON,\n// but want it back as `time.Time`.\n//\n// In that case you would register a custom field as follows\n//\n//\tjwe.RegisterCustomField(`x-birthday`, timeT)\n//\n// Then `hdr.Get(\"x-birthday\")` will still return an `interface{}`,\n// but you can convert its type to `time.Time`\n//\n//\tbdayif, _ := hdr.Get(`x-birthday`)\n//\tbday := bdayif.(time.Time)\nfunc RegisterCustomField(name string, object interface{}) {\n\tregistry.Register(name, object)\n}\n", "package jwe_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/jwxtest\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\texamplePayload = `The true sign of intelligence is not knowledge but imagination.`\n)\n\nvar rsaPrivKey rsa.PrivateKey\n\nfunc init() {\n\tvar jwkstr = []byte(`\n     {\"kty\":\"RSA\",\n      \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n      \"e\":\"AQAB\",\n      \"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n      \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n      \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n      \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n      \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n      \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\"\n     }`)\n\n\tprivkey, err := jwk.ParseKey(jwkstr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := privkey.Raw(&rsaPrivKey); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestSanityCheck_JWEExamplePayload(t *testing.T) {\n\texpected := []byte{\n\t\t84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,\n\t\t111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,\n\t\t101, 32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,\n\t\t101, 100, 103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,\n\t\t110, 97, 116, 105, 111, 110, 46,\n\t}\n\tassert.Equal(t, expected, []byte(examplePayload), \"examplePayload OK\")\n}\n\nfunc TestParse(t *testing.T) {\n\tconst s = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\tt.Run(\"Compact format\", func(t *testing.T) {\n\t\tt.Run(\"Normal\", func(t *testing.T) {\n\t\t\tmsg, err := jwe.Parse([]byte(s))\n\t\t\tif !assert.NoError(t, err, \"Parsing JWE is successful\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !assert.Len(t, msg.Recipients(), 1, \"There is exactly 1 recipient\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\n\t\tparts := strings.Split(s, \".\")\n\t\tt.Run(\"Missing parts\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(parts[:4], \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with missing parts`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid header\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append([]string(nil), \"!!invalidheader!!\"), parts[1:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid header`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid encrypted key\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[0]), \"!!invalidenckey!!\"), parts[2:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid encrypted key`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid initialization vector\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[:2]...), \"!!invalidiv!!\"), parts[3:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid initialization vector`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid content\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[:3]...), \"!!invalidcontent!!\"), parts[4:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid content`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid tag\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(parts[:4], \"!!invalidtag!!\"), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid tag`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"JSON format\", func(t *testing.T) {\n\t\tmsg, err := jwe.Parse([]byte(s))\n\t\tif !assert.NoError(t, err, \"Parsing JWE is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, \"Serializing to JSON format should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tmsg2, err := jwe.Parse(buf)\n\t\tif !assert.NoError(t, err, \"Parsing JWE in JSON format should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, msg, msg2, \"messages should match\") {\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// This test parses the example found in https://tools.ietf.org/html/rfc7516#appendix-A.1,\n// and checks if we can roundtrip to the same compact serialization format.\nfunc TestParse_RSAES_OAEP_AES_GCM(t *testing.T) {\n\tconst payload = `The true sign of intelligence is not knowledge but imagination.`\n\tconst serialized = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\tvar jwkstr = []byte(`\n     {\"kty\":\"RSA\",\n      \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n      \"e\":\"AQAB\",\n      \"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n      \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n      \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n      \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n      \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n      \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\"\n     }`)\n\n\tprivkey, err := jwk.ParseKey(jwkstr)\n\tif !assert.NoError(t, err, `parsing jwk should succeed`) {\n\t\treturn\n\t}\n\n\tvar rawkey rsa.PrivateKey\n\tif !assert.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`) {\n\t\treturn\n\t}\n\n\tmsg := jwe.NewMessage()\n\tplaintext, err := jwe.Decrypt([]byte(serialized), jwe.WithKey(jwa.RSA_OAEP, rawkey), jwe.WithMessage(msg))\n\tif !assert.NoError(t, err, \"jwe.Decrypt should be successful\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, 1, len(msg.Recipients()), \"message recipients header length is 1\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, payload, string(plaintext), \"decrypted value does not match\") {\n\t\treturn\n\t}\n\n\ttemplates := []*struct {\n\t\tName     string\n\t\tOptions  []jwe.EncryptOption\n\t\tExpected string\n\t}{\n\t\t{\n\t\t\tName:     \"Compact\",\n\t\t\tOptions:  []jwe.EncryptOption{jwe.WithCompact()},\n\t\t\tExpected: serialized,\n\t\t},\n\t\t{\n\t\t\tName:     \"JSON\",\n\t\t\tOptions:  []jwe.EncryptOption{jwe.WithJSON()},\n\t\t\tExpected: `{\"ciphertext\":\"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A\",\"iv\":\"48V1_ALb6US04U3b\",\"protected\":\"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\",\"header\":{\"alg\":\"RSA-OAEP\"},\"encrypted_key\":\"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg\",\"tag\":\"XFBoMYUZodetZdvTiFvSkQ\"}`,\n\t\t},\n\t\t{\n\t\t\tName:    \"JSON (Pretty)\",\n\t\t\tOptions: []jwe.EncryptOption{jwe.WithJSON(jwe.WithPretty(true))},\n\t\t\tExpected: `{\n  \"ciphertext\": \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A\",\n  \"iv\": \"48V1_ALb6US04U3b\",\n  \"protected\": \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\",\n  \"header\": {\n    \"alg\": \"RSA-OAEP\"\n  },\n  \"encrypted_key\": \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg\",\n  \"tag\": \"XFBoMYUZodetZdvTiFvSkQ\"\n}`,\n\t\t},\n\t}\n\n\tntmpl := len(templates)\n\ttestcases := make([]struct {\n\t\tName     string\n\t\tOptions  []jwe.EncryptOption\n\t\tExpected string\n\t}, ntmpl*2)\n\n\tfor i, tmpl := range templates {\n\t\toptions := make([]jwe.EncryptOption, len(tmpl.Options))\n\t\tcopy(options, tmpl.Options)\n\n\t\tfor j, compression := range []jwa.CompressionAlgorithm{jwa.NoCompress, jwa.Deflate} {\n\t\t\tcompName := compression.String()\n\t\t\tif compName == \"\" {\n\t\t\t\tcompName = \"none\"\n\t\t\t}\n\t\t\ttc := testcases[i+j]\n\t\t\ttc.Name = tmpl.Name + \" (compression=\" + compName + \")\"\n\t\t\ttc.Expected = tmpl.Expected\n\t\t\ttc.Options = append(options, jwe.WithCompress(compression))\n\t\t}\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\toptions := tc.Options\n\t\t\toptions = append(options, jwe.WithKey(jwa.RSA_OAEP, rawkey.PublicKey))\n\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, options...)\n\t\t\tif !assert.NoError(t, err, \"jwe.Encrypt should succeed\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Logf(\"%s\", encrypted)\n\n\t\t\tt.Run(\"WithKey\", func(t *testing.T) {\n\t\t\t\tplaintext, err = jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rawkey))\n\t\t\t\tif !assert.NoError(t, err, \"jwe.Decrypt should succeed\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, payload, string(plaintext), \"jwe.Decrypt should produce the same plaintext\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"WithKeySet\", func(t *testing.T) {\n\t\t\t\tpkJwk, err := jwk.FromRaw(rawkey)\n\t\t\t\tif !assert.NoError(t, err, `jwk.New should succeed`) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Keys are not going to be selected without an algorithm\n\t\t\t\t_ = pkJwk.Set(jwe.AlgorithmKey, jwa.RSA_OAEP)\n\t\t\t\tset := jwk.NewSet()\n\t\t\t\tset.AddKey(pkJwk)\n\n\t\t\t\tvar used interface{}\n\t\t\t\tplaintext, err = jwe.Decrypt(encrypted, jwe.WithKeySet(set, jwe.WithRequireKid(false)), jwe.WithKeyUsed(&used))\n\t\t\t\tif !assert.NoError(t, err, \"jwe.Decrypt should succeed\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, payload, string(plaintext), \"jwe.Decrypt should produce the same plaintext\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, pkJwk, used) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t// Test direct marshaling and unmarshaling\n\tt.Run(\"Marshal/Unmarshal\", func(t *testing.T) {\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, `json.Marshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tm2 := jwe.NewMessage()\n\t\tif !assert.NoError(t, json.Unmarshal(buf, m2), `json.Unmarshal should succeed`) {\n\t\t\tt.Logf(\"%s\", buf)\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, msg, m2, `messages should be the same after roundtrip`) {\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// https://tools.ietf.org/html/rfc7516#appendix-A.1.\nfunc TestRoundtrip_RSAES_OAEP_AES_GCM(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,\n\t\t111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,\n\t\t101, 32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,\n\t\t101, 100, 103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,\n\t\t110, 97, 116, 105, 111, 110, 46,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA_OAEP, &rsaPrivKey.PublicKey))\n\t\tif !assert.NoError(t, err, \"Encrypt should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rsaPrivKey))\n\t\tif !assert.NoError(t, err, \"Decrypt should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted content should match\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestRoundtrip_RSA1_5_A128CBC_HS256(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA1_5, &rsaPrivKey.PublicKey), jwe.WithContentEncryption(jwa.A128CBC_HS256))\n\t\tif !assert.NoError(t, err, \"Encrypt is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA1_5, rsaPrivKey))\n\t\tif !assert.NoError(t, err, \"Decrypt successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted correct plaintext\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// https://tools.ietf.org/html/rfc7516#appendix-A.3. Note that cek is dynamically\n// generated, so the encrypted values will NOT match that of the RFC.\nfunc TestEncode_A128KW_A128CBC_HS256(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46,\n\t}\n\tvar sharedkey = []byte{\n\t\t25, 172, 32, 130, 225, 114, 26, 181, 138, 106, 254, 192, 95, 133, 74, 82,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.A128KW, sharedkey), jwe.WithContentEncryption(jwa.A128CBC_HS256))\n\t\tif !assert.NoError(t, err, \"Encrypt is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.A128KW, sharedkey))\n\t\tif !assert.NoError(t, err, \"Decrypt successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted correct plaintext\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n//nolint:thelper\nfunc testEncodeECDHWithKey(t *testing.T, privkey interface{}, pubkey interface{}) {\n\tplaintext := []byte(\"Lorem ipsum\")\n\n\talgorithms := []jwa.KeyEncryptionAlgorithm{\n\t\tjwa.ECDH_ES,\n\t\tjwa.ECDH_ES_A256KW,\n\t\tjwa.ECDH_ES_A192KW,\n\t\tjwa.ECDH_ES_A128KW,\n\t}\n\n\tfor _, alg := range algorithms {\n\t\talg := alg\n\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(alg, pubkey))\n\t\t\tif !assert.NoError(t, err, \"Encrypt succeeds\") {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = jwe.Parse(encrypted)\n\t\t\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(alg, privkey))\n\t\t\tif !assert.NoError(t, err, \"Decrypt succeeds\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Logf(\"%s\", decrypted)\n\t\t})\n\t}\n}\n\nfunc TestEncode_ECDH(t *testing.T) {\n\tcurves := []elliptic.Curve{\n\t\telliptic.P256(),\n\t\telliptic.P384(),\n\t\telliptic.P521(),\n\t}\n\tfor _, crv := range curves {\n\t\tcrv := crv\n\t\tt.Run(crv.Params().Name, func(t *testing.T) {\n\t\t\tprivkey, err := ecdsa.GenerateKey(crv, rand.Reader)\n\t\t\tif !assert.NoError(t, err, `ecdsa.GenerateKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttestEncodeECDHWithKey(t, privkey, &privkey.PublicKey)\n\t\t})\n\t}\n}\n\nfunc TestEncode_X25519(t *testing.T) {\n\tpubkey, privkey, err := x25519.GenerateKey(rand.Reader)\n\tif !assert.NoError(t, err, `x25519.GenerateKey should succeed`) {\n\t\treturn\n\t}\n\n\ttestEncodeECDHWithKey(t, privkey, pubkey)\n}\n\nfunc Test_GHIssue207(t *testing.T) {\n\tconst plaintext = \"hi\\n\"\n\tvar testcases = []struct {\n\t\tAlgorithm  jwa.KeyEncryptionAlgorithm\n\t\tKey        string\n\t\tData       string\n\t\tThumbprint string\n\t\tName       string\n\t}{\n\t\t{\n\t\t\tName:       `ECDH-ES`,\n\t\t\tKey:        `{\"alg\":\"ECDH-ES\",\"crv\":\"P-521\",\"d\":\"ARxUkIjnB7pjFzM2OIIFcclR-4qbZwv7DoC96cksPKyvVWOkEsZ0CK6deM4AC6G5GClR5TXWMQVC_bNDmfuwPPqF\",\"key_ops\":[\"wrapKey\",\"unwrapKey\"],\"kty\":\"EC\",\"x\":\"ACewmG5j0POUDQw3rIqFQozK_6yXUsfNjiZtWqQOU7MXsSKK9RsRS8ySmeTG14heUpbbnrC9VdYKSOUGkYnYUl2Y\",\"y\":\"ACkXSOma_FP93R3u5uYX7gUOlM0LDkNsij9dVFPbafF8hlfYEnUGit2o-tt7W0Zq3t38jEhpjUoGgM04JDJ6_m0x\"}`,\n\t\t\tData:       `{\"ciphertext\":\"sp0cLt4Rx1p0Ax0Q1OZj7w\",\"header\":{\"alg\":\"ECDH-ES\",\"epk\":{\"crv\":\"P-521\",\"kty\":\"EC\",\"x\":\"APMKQpje5vu39-eS_LX_g15stqbNZ37GgYimW8PZf7d_OOuAygK2YlINYnPoUybrxkoaLRPhbmxc9MBWFdaY8SXx\",\"y\":\"AMpq4DFi6w-pfnprO58CkfX-ncXtJ8fvox2Ej8Ey3ZY1xjVUtbDJCDCjY53snYaNCEjnFQPAn-IkAG90p2Xcm8ut\"}},\"iv\":\"Fjnb5uUWp9euqp1MK_hT4A\",\"protected\":\"eyJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0\",\"tag\":\"6nhiy-vyqwVjpy08jrorTpWqvam66HdKxU36XsE3Z3s\"}`,\n\t\t\tThumbprint: `0_6x6e2sZKeq3ka0QV0PEkJagqg`,\n\t\t},\n\t\t{\n\t\t\tName:       `ECDH-ES+A256KW`,\n\t\t\tKey:        `{\"alg\":\"ECDH-ES+A256KW\",\"crv\":\"P-521\",\"d\":\"AcH8h_ctsMnopTiCH7wiuM-nAb1CNikC0ubcOZQDLYSVEw93h6_D57aD7DLWbjIsVNzn7Qq8P-kRiTYVoH5GTQVg\",\"key_ops\":[\"wrapKey\",\"unwrapKey\"],\"kty\":\"EC\",\"x\":\"AAQoEbNeiG3ExYj9bJLGFn4h_bFjERfIcmpQMW5KWlFhqcXTFg0g8-5YWjdJXdNmO_2EuaKe7zOvEq8dCFCb12-R\",\"y\":\"Ad8E2jp6FSCSd8laERqIt67A2T-MIqQE5301jNYb5SMsCSV1rs1McyvhzHaclYcqTUptoA-rW5kNS9N5124XPHky\"}`,\n\t\t\tData:       `{\"ciphertext\":\"evXmzoQ5TWQvEXdpv9ZCBQ\",\"encrypted_key\":\"ceVsjF-0LhziK75oHRC-C539hlFJMSbub015a3YtIBgCt7c0IRzkzwoOvo_Jf44FXZi0Vd-4fvDjRkZDzx9DcuDd4ASYDLvW\",\"header\":{\"alg\":\"ECDH-ES+A256KW\",\"epk\":{\"crv\":\"P-521\",\"kty\":\"EC\",\"x\":\"Aad7PFl9cct7WcfM3b_LNkhCHfCotW_nRuarX7GACDyyZkr2dd1g6r3rz-8r2-AyOGD9gc2nhrTEjVHT2W7eu65U\",\"y\":\"Ab0Mj6BK8g3Fok6oyFlkvKOyquEVxeeJOlsyXKYBputPxFT5Gljr2FoJdViAxVspoSiw1K5oG1h59UBJgPWG4GQV\"}},\"iv\":\"KsJgq2xyzE1dZi2BM2xf5g\",\"protected\":\"eyJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0\",\"tag\":\"b6m_nW9vfk6xJugm_-Uuj4cbAQh9ECelLc1ZBfO86L0\"}`,\n\t\t\tThumbprint: `G4OtKQL_qr9Q57atNOU6SJnJxB8`,\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\twebKey, err := jwk.ParseKey([]byte(tc.Key))\n\t\t\tif !assert.NoError(t, err, `jwk.ParseKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthumbprint, err := webKey.Thumbprint(crypto.SHA1)\n\t\t\tif !assert.NoError(t, err, `jwk.Thumbprint should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, base64.RawURLEncoding.EncodeToString(thumbprint), tc.Thumbprint, `thumbprints should match`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar key ecdsa.PrivateKey\n\t\t\tif !assert.NoError(t, webKey.Raw(&key), `jwk.Raw should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt([]byte(tc.Data), jwe.WithKeyProvider(jwe.KeyProviderFunc(func(_ context.Context, sink jwe.KeySink, r jwe.Recipient, _ *jwe.Message) error {\n\t\t\t\tsink.Key(r.Headers().Algorithm(), &key)\n\t\t\t\treturn nil\n\t\t\t})))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, string(decrypted), plaintext, `plaintext should match`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\n// tests direct key encryption by encrypting-decrypting a plaintext\nfunc TestEncode_Direct(t *testing.T) {\n\tvar testcases = []struct {\n\t\tAlgorithm jwa.ContentEncryptionAlgorithm\n\t\tKeySize   int // in bytes\n\t}{\n\t\t{jwa.A128CBC_HS256, 32},\n\t\t{jwa.A128GCM, 16},\n\t\t{jwa.A192CBC_HS384, 48},\n\t\t{jwa.A192GCM, 24},\n\t\t{jwa.A256CBC_HS512, 64},\n\t\t{jwa.A256GCM, 32},\n\t}\n\tplaintext := []byte(\"Lorem ipsum\")\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Algorithm.String(), func(t *testing.T) {\n\t\t\tkey := make([]byte, tc.KeySize)\n\t\t\t/*\n\t\t\t\t_, err := rand.Read(key)\n\t\t\t\tif !assert.NoError(t, err, \"Key generation succeeds\") {\n\t\t\t\t\treturn\n\t\t\t\t}*/\n\t\t\tfor n := 0; n < len(key); {\n\t\t\t\tw := copy(key[n:], []byte(`12345678`))\n\t\t\t\tn += w\n\t\t\t}\n\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.DIRECT, key), jwe.WithContentEncryption(tc.Algorithm))\n\t\t\tif !assert.NoError(t, err, `jwe.Encrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.DIRECT, key))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.Equal(t, plaintext, decrypted, `jwe.Decrypt should match input plaintext`)\n\t\t})\n\t}\n}\n\n// Decrypts messages generated by `jose` tool. It helps check compatibility with other jwx implementations.\nfunc TestDecodePredefined_Direct(t *testing.T) {\n\tvar testcases = []struct {\n\t\tAlgorithm  jwa.ContentEncryptionAlgorithm\n\t\tKey        string // generated with 'jose jwk gen -i '{\"alg\":\"A128GCM\"}' -o key.jwk'\n\t\tThumbprint string // generated with 'jose jwk thp -i key.jwk`\n\t\tData       string // generated with 'jose jwe enc -I msg.txt -k key.jwk -o msg.jwe'\n\t}{\n\t\t{\n\t\t\tjwa.A128CBC_HS256,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A128GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A192CBC_HS384,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A192GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A256CBC_HS512,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A256GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t}\n\tplaintext := \"Lorem ipsum\"\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Algorithm.String(), func(t *testing.T) {\n\t\t\twebKey, err := jwk.ParseKey([]byte(tc.Key))\n\t\t\tif !assert.NoError(t, err, `jwk.ParseKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthumbprint, err := webKey.Thumbprint(crypto.SHA1)\n\t\t\tif !assert.NoError(t, err, `jwk.Thumbprint should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, base64.RawURLEncoding.EncodeToString(thumbprint), tc.Thumbprint, `thumbprints should match`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar key []byte\n\t\t\tif !assert.NoError(t, webKey.Raw(&key), `jwk.Raw should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt([]byte(tc.Data), jwe.WithKey(jwa.DIRECT, key))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, plaintext, string(decrypted), `plaintext should match`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGHIssue230(t *testing.T) {\n\tt.Parallel()\n\n\tconst data = `{\"ciphertext\":\"wko\",\"encrypted_key\":\"\",\"iv\":\"y-wj7nfa-T8XG58z\",\"protected\":\"eyJhbGciOiJkaXIiLCJjbGV2aXMiOnsicGluIjoidHBtMiIsInRwbTIiOnsiaGFzaCI6InNoYTI1NiIsImp3a19wcml2IjoiQU80QUlCSTFRYjQ2SHZXUmNSRHVxRXdoN2ZWc3hSNE91MVhsOHBRX2hMMTlPeUc3QUJDVG80S2RqWEZYcEFUOWtLeWptVVJPOTVBaXc4U1o4MGZXRmtDMGdEazJLTXEtamJTZU1wcFZFaFJaWEpxQmhWNXVGZ1V0T0J4eUFjRzFZRjhFMW5Ob1dPWk9Eek5EUkRrOE1ZVWZrWVNpS0ZKb2pPZ0UxSjRIZkRoM0lBelY2MFR6V2NWcXJ0QnlwX2EyZ1V2a0JqcGpTeVF2Nmc2amJMSXpEaG10VnZLMmxDazhlMjUzdG1MSDNPQWk0Q0tZcWFZY0tjTTltSTdTRXBpVldlSjZZVFBEdmtORndpa0tNRjE3czVYQUlFUjZpczNNTVBpNkZTOWQ3ZmdMV25hUkpabDVNNUJDMldxN2NsVmYiLCJqd2tfcHViIjoiQUM0QUNBQUxBQUFFMGdBQUFCQUFJREpTSVhRSVVocjVPaDVkNXZWaWVGUDBmZG9pVFd3S1RicXJRRVRhVmx4QyIsImtleSI6ImVjYyJ9fSwiZW5jIjoiQTI1NkdDTSJ9\",\"tag\":\"lir7v9YbCCZQKf5-yJ0BTQ\"}`\n\n\tmsg, err := jwe.Parse([]byte(data))\n\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\treturn\n\t}\n\n\tcompact, err := jwe.Compact(msg)\n\tif !assert.NoError(t, err, `jwe.Compact should succeed`) {\n\t\treturn\n\t}\n\n\tmsg2, err := jwe.Parse(compact)\n\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, msg, msg2, `data -> msg -> compact -> msg2 produces msg == msg2`) {\n\t\tt.Logf(\"msg -> %#v\", msg)\n\t\tt.Logf(\"msg2 -> %#v\", msg2)\n\t\treturn\n\t}\n}\n\nfunc TestReadFile(t *testing.T) {\n\tconst s = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\n\tf, err := os.CreateTemp(\"\", \"test-read-file-*.jwe\")\n\tif !assert.NoError(t, err, `os.CreateTemp should succeed`) {\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tfmt.Fprintf(f, \"%s\", s)\n\n\tif _, err := jwe.ReadFile(f.Name()); !assert.NoError(t, err, `jwe.ReadFile should succeed`) {\n\t\treturn\n\t}\n}\n\nfunc TestCustomField(t *testing.T) {\n\t// XXX has global effect!!!\n\tjwe.RegisterCustomField(`x-birthday`, time.Time{})\n\tdefer jwe.RegisterCustomField(`x-birthday`, nil)\n\n\texpected := time.Date(2015, 11, 4, 5, 12, 52, 0, time.UTC)\n\tbdaybytes, _ := expected.MarshalText() // RFC3339\n\n\tplaintext := []byte(\"Hello, World!\")\n\trsakey, err := jwxtest.GenerateRsaJwk()\n\tif !assert.NoError(t, err, `jwxtest.GenerateRsaJwk() should succeed`) {\n\t\treturn\n\t}\n\tpubkey, err := jwk.PublicKeyOf(rsakey)\n\tif !assert.NoError(t, err, `jwk.PublicKeyOf() should succeed`) {\n\t\treturn\n\t}\n\n\tprotected := jwe.NewHeaders()\n\tprotected.Set(`x-birthday`, string(bdaybytes))\n\n\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA_OAEP, pubkey), jwe.WithProtectedHeaders(protected))\n\tif !assert.NoError(t, err, `jwe.Encrypt should succeed`) {\n\t\treturn\n\t}\n\n\tt.Run(\"jwe.Parse + json.Unmarshal\", func(t *testing.T) {\n\t\tmsg, err := jwe.Parse(encrypted)\n\t\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tv, ok := msg.ProtectedHeaders().Get(`x-birthday`)\n\t\tif !assert.True(t, ok, `msg.ProtectedHeaders().Get(\"x-birthday\") should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, expected, v, `values should match`) {\n\t\t\treturn\n\t\t}\n\n\t\t// Create JSON from jwe.Message\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, `json.Marshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tvar msg2 jwe.Message\n\t\tif !assert.NoError(t, json.Unmarshal(buf, &msg2), `json.Unmarshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tv, ok = msg2.ProtectedHeaders().Get(`x-birthday`)\n\t\tif !assert.True(t, ok, `msg2.ProtectedHeaders().Get(\"x-birthday\") should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, expected, v, `values should match`) {\n\t\t\treturn\n\t\t}\n\t})\n}\n\nfunc TestGH554(t *testing.T) {\n\tconst keyID = `very-secret-key`\n\tconst plaintext = `hello world!`\n\tprivkey, err := jwxtest.GenerateEcdsaJwk()\n\tif !assert.NoError(t, err, `jwxtest.GenerateEcdsaJwk() should succeed`) {\n\t\treturn\n\t}\n\n\t_ = privkey.Set(jwk.KeyIDKey, keyID)\n\n\tpubkey, err := jwk.PublicKeyOf(privkey)\n\tif !assert.NoError(t, err, `jwk.PublicKeyOf() should succeed`) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, keyID, pubkey.KeyID(), `key ID should match`) {\n\t\treturn\n\t}\n\n\tencrypted, err := jwe.Encrypt([]byte(plaintext), jwe.WithKey(jwa.ECDH_ES, pubkey))\n\tif !assert.NoError(t, err, `jwk.Encrypt() should succeed`) {\n\t\treturn\n\t}\n\n\tmsg, err := jwe.Parse(encrypted)\n\tif !assert.NoError(t, err, `jwe.Parse() should succeed`) {\n\t\treturn\n\t}\n\n\trecipients := msg.Recipients()\n\n\t// The epk must have the same key ID as the original\n\tkid := recipients[0].Headers().KeyID()\n\tif !assert.Equal(t, keyID, kid, `key ID in epk should match`) {\n\t\treturn\n\t}\n}\n\nfunc TestGH803(t *testing.T) {\n\tprivateKey, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\trequire.NoError(t, err, `ecdsa.GenerateKey should succeed`)\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\tapu := []byte(`Alice`)\n\tapv := []byte(`Bob`)\n\thdrs := jwe.NewHeaders()\n\thdrs.Set(jwe.AgreementPartyUInfoKey, apu)\n\thdrs.Set(jwe.AgreementPartyVInfoKey, apv)\n\tencrypted, err := jwe.Encrypt(\n\t\tpayload,\n\t\tjwe.WithJSON(),\n\t\tjwe.WithKey(jwa.ECDH_ES, privateKey.PublicKey, jwe.WithPerRecipientHeaders(hdrs)),\n\t\tjwe.WithContentEncryption(jwa.A128GCM),\n\t)\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\n\tvar msg jwe.Message\n\tdecrypted, err := jwe.Decrypt(\n\t\tencrypted,\n\t\tjwe.WithKey(jwa.ECDH_ES, privateKey),\n\t\tjwe.WithMessage(&msg),\n\t)\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\trequire.Equal(t, payload, decrypted, `decrypt messages match`)\n\trequire.Equal(t, apu, msg.ProtectedHeaders().AgreementPartyUInfo())\n\trequire.Equal(t, apv, msg.ProtectedHeaders().AgreementPartyVInfo())\n}\n\nfunc TestGH840(t *testing.T) {\n\t// Go 1.19+ panics if elliptic curve operations are called against\n\t// a point that's _NOT_ on the curve\n\tuntrustedJWK := []byte(`{\n\t\t\"kty\": \"EC\",\n\t\t\"crv\": \"P-256\",\n\t\t\"x\": \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqx7D4\",\n\t\t\"y\": \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n\t\t\"d\": \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\"\n\t}`)\n\n\tprivkey, err := jwk.ParseKey(untrustedJWK)\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubkey, err := privkey.PublicKey()\n\trequire.NoError(t, err, `privkey.PublicKey should succeed`)\n\n\tconst payload = `Lorem ipsum`\n\t_, err = jwe.Encrypt([]byte(payload), jwe.WithKey(jwa.ECDH_ES_A128KW, pubkey))\n\trequire.Error(t, err, `jwe.Encrypt should fail (instead of panic)`)\n}\n\ntype dummyKeyEncrypterDecrypter struct {\n\tkey []byte\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) DecryptKey(_ jwa.KeyEncryptionAlgorithm, cek []byte, _ jwe.Recipient, _ *jwe.Message) ([]byte, error) {\n\treturn bytes.TrimSuffix(cek, kd.key), nil\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) Algorithm() jwa.KeyEncryptionAlgorithm {\n\treturn jwa.A128GCMKW\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) EncryptKey(key []byte) ([]byte, error) {\n\treturn append(key, kd.key...), nil\n}\n\nvar _ jwe.KeyEncrypter = (*dummyKeyEncrypterDecrypter)(nil)\n\nfunc TestGH924(t *testing.T) {\n\tsharedKey := []byte(\"abra-kadabra\")\n\n\tked := &dummyKeyEncrypterDecrypter{key: sharedKey}\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\tencrypted, err := jwe.Encrypt(\n\t\tpayload,\n\t\tjwe.WithJSON(),\n\t\tjwe.WithKey(jwa.A128GCMKW, ked),\n\t\tjwe.WithContentEncryption(jwa.A128GCM),\n\t)\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\n\tvar msg jwe.Message\n\tdecrypted, err := jwe.Decrypt(\n\t\tencrypted,\n\t\tjwe.WithKey(jwa.A128GCMKW, ked),\n\t\tjwe.WithMessage(&msg),\n\t)\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\trequire.Equal(t, payload, decrypted, `decrypt messages match`)\n}\n\nfunc TestGH1001(t *testing.T) {\n\trawKey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaKey should succeed`)\n\n\tencrypted, err := jwe.Encrypt([]byte(\"Lorem Ipsum\"), jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\tvar cek []byte\n\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rawKey), jwe.WithCEK(&cek))\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\n\trequire.Equal(t, \"Lorem Ipsum\", string(decrypted), `decrypted message should match`)\n\trequire.NotNil(t, cek, `cek should not be nil`)\n\n\treEncrypted, err := jwe.EncryptStatic([]byte(\"Lorem Ipsum\"), cek, jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.NoError(t, err, `jwe.EncryptStatic should succeed`)\n\n\t// sanity. empty CEKs should be rejected\n\t_, err = jwe.EncryptStatic([]byte(\"Lorem Ipsum\"), nil, jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.Error(t, err, `jwe.Encryptstatic should fail with empty cek`)\n\n\tcek = []byte(nil)\n\tdecrypted, err = jwe.Decrypt(reEncrypted, jwe.WithKey(jwa.RSA_OAEP, rawKey), jwe.WithCEK(&cek))\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\n\trequire.Equal(t, \"Lorem Ipsum\", string(decrypted), `decrypted message should match`)\n\trequire.NotNil(t, cek, `cek should not be nil`)\n}\n", "package_name: jwe\noutput: jwe/options_gen.go\ninterfaces:\n  - name: CompactOption\n    comment: |\n      CompactOption describes options that can be passed to `jwe.Compact`\n  - name: DecryptOption\n    comment: |\n      DecryptOption describes options that can be passed to `jwe.Decrypt`\n  - name: EncryptOption\n    comment: |\n      EncryptOption describes options that can be passed to `jwe.Encrypt`\n  - name: EncryptDecryptOption\n    methods:\n      - encryptOption\n      - decryptOption\n    comment: |\n      EncryptDecryptOption describes options that can be passed to either `jwe.Encrypt` or `jwe.Decrypt`\n  - name: WithJSONSuboption\n    concrete_type: withJSONSuboption\n    comment: |\n      JSONSuboption describes suboptions that can be passed to `jwe.WithJSON()` option\n  - name: WithKeySetSuboption\n    comment: |\n      WithKeySetSuboption is a suboption passed to the WithKeySet() option\n  - name: ParseOption\n    methods:\n      - readFileOption\n    comment: |\n      ReadFileOption is a type of `Option` that can be passed to `jwe.Parse`\n  - name: ReadFileOption\n    comment: |\n      ReadFileOption is a type of `Option` that can be passed to `jwe.ReadFile`\noptions:\n  - ident: Key\n    skip_option: true\n  - ident: Pretty\n    skip_option: true\n  - ident: ProtectedHeaders\n    skip_option: true\n  - ident: PerRecipientHeaders\n    skip_option: true\n  - ident: KeyProvider\n    interface: DecryptOption\n    argument_type: KeyProvider\n  - ident: Serialization\n    option_name: WithCompact\n    interface: EncryptOption\n    constant_value: fmtCompact\n    comment: |\n      WithCompact specifies that the result of `jwe.Encrypt()` is serialized in\n      compact format.\n      \n      By default `jwe.Encrypt()` will opt to use compact format, so you usually\n      do not need to specify this option other than to be explicit about it\n  - ident: Compress\n    interface: EncryptOption\n    argument_type: jwa.CompressionAlgorithm\n    comment: |\n      WithCompress specifies the compression algorithm to use when encrypting\n      a payload using `jwe.Encrypt` (Yes, we know it can only be \"\" or \"DEF\",\n      but the way the specification is written it could allow for more options,\n      and therefore this option takes an argument)\n  - ident: ContentEncryptionAlgorithm\n    interface: EncryptOption\n    option_name: WithContentEncryption\n    argument_type: jwa.ContentEncryptionAlgorithm\n    comment: |\n      WithContentEncryptionAlgorithm specifies the algorithm to encrypt the\n      JWE message content with. If not provided, `jwa.A256GCM` is used.\n  - ident: Message\n    interface: DecryptOption\n    argument_type: '*Message'\n    comment: |\n      WithMessage provides a message object to be populated by `jwe.Decrpt`\n      Using this option allows you to decrypt AND obtain the `jwe.Message`\n      in one go.\n      \n      Note that you should NOT be using the message object for anything other\n      than inspecting its contents. Particularly, do not expect the message\n      reliable when you call `Decrypt` on it. `(jwe.Message).Decrypt` is\n      slated to be deprecated in the next major version.\n  - ident: RequireKid\n    interface: WithKeySetSuboption\n    argument_type: bool\n    comment: |\n      WithrequiredKid specifies whether the keys in the jwk.Set should\n      only be matched if the target JWE message's Key ID and the Key ID\n      in the given key matches.\n  - ident: Pretty\n    interface: WithJSONSuboption\n    argument_type: bool\n    comment: |\n      WithPretty specifies whether the JSON output should be formatted and\n      indented\n  - ident: MergeProtectedHeaders\n    interface: EncryptOption\n    argument_type: bool\n    comment: |\n      WithMergeProtectedHeaders specify that when given multiple headers\n      as options to `jwe.Encrypt`, these headers should be merged instead\n      of overwritten\n  - ident: FS\n    interface: ReadFileOption\n    argument_type: fs.FS\n    comment: |\n      WithFS specifies the source `fs.FS` object to read the file from.\n  - ident: KeyUsed\n    interface: DecryptOption\n    argument_type: 'interface{}'\n    comment: |\n      WithKeyUsed allows you to specify the `jwe.Decrypt()` function to\n      return the key used for decryption. This may be useful when\n      you specify multiple key sources or if you pass a `jwk.Set`\n      and you want to know which key was successful at decrypting the\n      signature.\n      \n      `v` must be a pointer to an empty `interface{}`. Do not use\n      `jwk.Key` here unless you are 100% sure that all keys that you\n      have provided are instances of `jwk.Key` (remember that the\n      jwx API allows users to specify a raw key such as *rsa.PublicKey)\n  - ident: CEK\n    interface: DecryptOption\n    argument_type: '*[]byte'\n    comment: |\n      WithCEK allows users to specify a variable to store the CEK used in the\n      message upon successful decryption. The variable must be a pointer to\n      a byte slice, and it will only be populated if the decryption is successful.\n      \n      This option is currently considered EXPERIMENTAL, and is subject to\n      future changes across minor/micro versions.\n", "// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.\n\npackage jwe\n\nimport (\n\t\"io/fs\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/option\"\n)\n\ntype Option = option.Interface\n\n// CompactOption describes options that can be passed to `jwe.Compact`\ntype CompactOption interface {\n\tOption\n\tcompactOption()\n}\n\ntype compactOption struct {\n\tOption\n}\n\nfunc (*compactOption) compactOption() {}\n\n// DecryptOption describes options that can be passed to `jwe.Decrypt`\ntype DecryptOption interface {\n\tOption\n\tdecryptOption()\n}\n\ntype decryptOption struct {\n\tOption\n}\n\nfunc (*decryptOption) decryptOption() {}\n\n// EncryptDecryptOption describes options that can be passed to either `jwe.Encrypt` or `jwe.Decrypt`\ntype EncryptDecryptOption interface {\n\tOption\n\tencryptOption()\n\tdecryptOption()\n}\n\ntype encryptDecryptOption struct {\n\tOption\n}\n\nfunc (*encryptDecryptOption) encryptOption() {}\n\nfunc (*encryptDecryptOption) decryptOption() {}\n\n// EncryptOption describes options that can be passed to `jwe.Encrypt`\ntype EncryptOption interface {\n\tOption\n\tencryptOption()\n}\n\ntype encryptOption struct {\n\tOption\n}\n\nfunc (*encryptOption) encryptOption() {}\n\n// ReadFileOption is a type of `Option` that can be passed to `jwe.Parse`\ntype ParseOption interface {\n\tOption\n\treadFileOption()\n}\n\ntype parseOption struct {\n\tOption\n}\n\nfunc (*parseOption) readFileOption() {}\n\n// ReadFileOption is a type of `Option` that can be passed to `jwe.ReadFile`\ntype ReadFileOption interface {\n\tOption\n\treadFileOption()\n}\n\ntype readFileOption struct {\n\tOption\n}\n\nfunc (*readFileOption) readFileOption() {}\n\n// JSONSuboption describes suboptions that can be passed to `jwe.WithJSON()` option\ntype WithJSONSuboption interface {\n\tOption\n\twithJSONSuboption()\n}\n\ntype withJSONSuboption struct {\n\tOption\n}\n\nfunc (*withJSONSuboption) withJSONSuboption() {}\n\n// WithKeySetSuboption is a suboption passed to the WithKeySet() option\ntype WithKeySetSuboption interface {\n\tOption\n\twithKeySetSuboption()\n}\n\ntype withKeySetSuboption struct {\n\tOption\n}\n\nfunc (*withKeySetSuboption) withKeySetSuboption() {}\n\ntype identCEK struct{}\ntype identCompress struct{}\ntype identContentEncryptionAlgorithm struct{}\ntype identFS struct{}\ntype identKey struct{}\ntype identKeyProvider struct{}\ntype identKeyUsed struct{}\ntype identMergeProtectedHeaders struct{}\ntype identMessage struct{}\ntype identPerRecipientHeaders struct{}\ntype identPretty struct{}\ntype identProtectedHeaders struct{}\ntype identRequireKid struct{}\ntype identSerialization struct{}\n\nfunc (identCEK) String() string {\n\treturn \"WithCEK\"\n}\n\nfunc (identCompress) String() string {\n\treturn \"WithCompress\"\n}\n\nfunc (identContentEncryptionAlgorithm) String() string {\n\treturn \"WithContentEncryption\"\n}\n\nfunc (identFS) String() string {\n\treturn \"WithFS\"\n}\n\nfunc (identKey) String() string {\n\treturn \"WithKey\"\n}\n\nfunc (identKeyProvider) String() string {\n\treturn \"WithKeyProvider\"\n}\n\nfunc (identKeyUsed) String() string {\n\treturn \"WithKeyUsed\"\n}\n\nfunc (identMergeProtectedHeaders) String() string {\n\treturn \"WithMergeProtectedHeaders\"\n}\n\nfunc (identMessage) String() string {\n\treturn \"WithMessage\"\n}\n\nfunc (identPerRecipientHeaders) String() string {\n\treturn \"WithPerRecipientHeaders\"\n}\n\nfunc (identPretty) String() string {\n\treturn \"WithPretty\"\n}\n\nfunc (identProtectedHeaders) String() string {\n\treturn \"WithProtectedHeaders\"\n}\n\nfunc (identRequireKid) String() string {\n\treturn \"WithRequireKid\"\n}\n\nfunc (identSerialization) String() string {\n\treturn \"WithSerialization\"\n}\n\n// WithCEK allows users to specify a variable to store the CEK used in the\n// message upon successful decryption. The variable must be a pointer to\n// a byte slice, and it will only be populated if the decryption is successful.\n//\n// This option is currently considered EXPERIMENTAL, and is subject to\n// future changes across minor/micro versions.\nfunc WithCEK(v *[]byte) DecryptOption {\n\treturn &decryptOption{option.New(identCEK{}, v)}\n}\n\n// WithCompress specifies the compression algorithm to use when encrypting\n// a payload using `jwe.Encrypt` (Yes, we know it can only be \"\" or \"DEF\",\n// but the way the specification is written it could allow for more options,\n// and therefore this option takes an argument)\nfunc WithCompress(v jwa.CompressionAlgorithm) EncryptOption {\n\treturn &encryptOption{option.New(identCompress{}, v)}\n}\n\n// WithContentEncryptionAlgorithm specifies the algorithm to encrypt the\n// JWE message content with. If not provided, `jwa.A256GCM` is used.\nfunc WithContentEncryption(v jwa.ContentEncryptionAlgorithm) EncryptOption {\n\treturn &encryptOption{option.New(identContentEncryptionAlgorithm{}, v)}\n}\n\n// WithFS specifies the source `fs.FS` object to read the file from.\nfunc WithFS(v fs.FS) ReadFileOption {\n\treturn &readFileOption{option.New(identFS{}, v)}\n}\n\nfunc WithKeyProvider(v KeyProvider) DecryptOption {\n\treturn &decryptOption{option.New(identKeyProvider{}, v)}\n}\n\n// WithKeyUsed allows you to specify the `jwe.Decrypt()` function to\n// return the key used for decryption. This may be useful when\n// you specify multiple key sources or if you pass a `jwk.Set`\n// and you want to know which key was successful at decrypting the\n// signature.\n//\n// `v` must be a pointer to an empty `interface{}`. Do not use\n// `jwk.Key` here unless you are 100% sure that all keys that you\n// have provided are instances of `jwk.Key` (remember that the\n// jwx API allows users to specify a raw key such as *rsa.PublicKey)\nfunc WithKeyUsed(v interface{}) DecryptOption {\n\treturn &decryptOption{option.New(identKeyUsed{}, v)}\n}\n\n// WithMergeProtectedHeaders specify that when given multiple headers\n// as options to `jwe.Encrypt`, these headers should be merged instead\n// of overwritten\nfunc WithMergeProtectedHeaders(v bool) EncryptOption {\n\treturn &encryptOption{option.New(identMergeProtectedHeaders{}, v)}\n}\n\n// WithMessage provides a message object to be populated by `jwe.Decrpt`\n// Using this option allows you to decrypt AND obtain the `jwe.Message`\n// in one go.\n//\n// Note that you should NOT be using the message object for anything other\n// than inspecting its contents. Particularly, do not expect the message\n// reliable when you call `Decrypt` on it. `(jwe.Message).Decrypt` is\n// slated to be deprecated in the next major version.\nfunc WithMessage(v *Message) DecryptOption {\n\treturn &decryptOption{option.New(identMessage{}, v)}\n}\n\n// WithPretty specifies whether the JSON output should be formatted and\n// indented\nfunc WithPretty(v bool) WithJSONSuboption {\n\treturn &withJSONSuboption{option.New(identPretty{}, v)}\n}\n\n// WithrequiredKid specifies whether the keys in the jwk.Set should\n// only be matched if the target JWE message's Key ID and the Key ID\n// in the given key matches.\nfunc WithRequireKid(v bool) WithKeySetSuboption {\n\treturn &withKeySetSuboption{option.New(identRequireKid{}, v)}\n}\n\n// WithCompact specifies that the result of `jwe.Encrypt()` is serialized in\n// compact format.\n//\n// By default `jwe.Encrypt()` will opt to use compact format, so you usually\n// do not need to specify this option other than to be explicit about it\nfunc WithCompact() EncryptOption {\n\treturn &encryptOption{option.New(identSerialization{}, fmtCompact)}\n}\n", "// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.\n\npackage jwe\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestOptionIdent(t *testing.T) {\n\trequire.Equal(t, \"WithCEK\", identCEK{}.String())\n\trequire.Equal(t, \"WithCompress\", identCompress{}.String())\n\trequire.Equal(t, \"WithContentEncryption\", identContentEncryptionAlgorithm{}.String())\n\trequire.Equal(t, \"WithFS\", identFS{}.String())\n\trequire.Equal(t, \"WithKey\", identKey{}.String())\n\trequire.Equal(t, \"WithKeyProvider\", identKeyProvider{}.String())\n\trequire.Equal(t, \"WithKeyUsed\", identKeyUsed{}.String())\n\trequire.Equal(t, \"WithMergeProtectedHeaders\", identMergeProtectedHeaders{}.String())\n\trequire.Equal(t, \"WithMessage\", identMessage{}.String())\n\trequire.Equal(t, \"WithPerRecipientHeaders\", identPerRecipientHeaders{}.String())\n\trequire.Equal(t, \"WithPretty\", identPretty{}.String())\n\trequire.Equal(t, \"WithProtectedHeaders\", identProtectedHeaders{}.String())\n\trequire.Equal(t, \"WithRequireKid\", identRequireKid{}.String())\n\trequire.Equal(t, \"WithSerialization\", identSerialization{}.String())\n}\n"], "fixing_code": ["Changes\n=======\n\nv2 has many incompatibilities with v1. To see the full list of differences between\nv1 and v2, please read the Changes-v2.md file (https://github.com/lestrrat-go/jwx/blob/develop/v2/Changes-v2.md)\n\nv2.0.18 UNRELEASED\n[Security Fixes]\n  * [jwe] A large number in p2c parameter for PBKDF2 based encryptions could cause a DoS attack,\n    similar to https://nvd.nist.gov/vuln/detail/CVE-2022-36083.  All users who use JWE via this\n    package should upgrade. While the JOSE spec allows for encryption using JWE on JWTs, users of\n    the `jwt` package are not immediately susceptible unless they explicitly try to decrypt\n    JWTs -- by default the `jwt` package verifies signatures, but does not decrypt messages.\n    [GHSA-7f9x-gw85-8grf]\n\nv2.0.17 20 Nov 2023\n[Bug Fixes]\n  * [jws] Previously, `jws.UnregisterSigner` did not remove the previous signer instance when\n    the signer was registered and unregistered multiple times (#1016). This has been fixed.\n\n[New Features]\n  * [jwe] (EXPERIMENTAL) `jwe.WithCEK` has been added to extract the content encryption key (CEK) from the Decrypt operation.\n  * [jwe] (EXPERIMENTAL) `jwe.EncryptStatic` has been added to encrypt content using a static CEK.\n    Using static CEKs has serious security implications, and you should not use\n    this unless you completely understand the risks involved.\n\nv2.0.16 31 Oct 2023\n[Security]\n  * [jws] ECDSA signature verification requires us to check if the signature\n    is of the desired length of bytes, but this check that used to exist before\n    had been removed in #65, resulting in certain malformed signatures to pass\n    verification.\n\n    One of the ways this could happen if R is a 31 byte integer and S is 32 byte integer,\n    both containing the correct signature values, but R is not zero-padded.\n\n       Correct = R: [ 0 , ... ] (32 bytes) S: [ ... ] (32 bytes)\n       Wrong   = R: [ ... ] (31 bytes)     S: [ ... ] (32 bytes)\n\n    In order for this check to pass, you would still need to have all 63 bytes\n    populated with the correct signature. The only modification a bad actor\n    may be able to do is to add one more byte at the end, in which case the\n    first 32 bytes (including what would have been S's first byte) is used for R,\n    and S would contain the rest. But this will only result in the verification to\n    fail. Therefore this in itself should not pose any security risk, albeit\n    allowing some illegally formated messages to be verified.\n\n  * [jwk] `jwk.Key` objects now have a `Validate()` method to validate the data\n    stored in the keys. However, this still does not necessarily mean that the key's\n    are valid for use in cryptographic operations. If `Validate()` is successful,\n    it only means that the keys are in the right _format_, including the presence\n    of required fields and that certain fields have proper length, etc.\n\n[New Features]\n  * [jws] Added `jws.WithValidateKey()` to force calling `key.Validate()` before\n    signing or verification.\n\n  * [jws] `jws.Sign()` now returns a special type of error that can hold the\n    individual errors from the signers. The stringification is still the same\n    as before to preserve backwards compatibility.\n\n  * [jwk] Added `jwk.IsKeyValidationError` that checks if an error is an error\n    from `key.Validate()`.\n\n[Bug Fixes]\n  * [jwt] `jwt.ParseInsecure()` was running verification if you provided a key\n    via `jwt.WithKey()` or `jwt.WithKeySet()` (#1007)\n\nv2.0.15 19 20 Oct 2023\n[Bug fixes]\n  * [jws] jws.Sign() now properly check for valid algorithm / key type pair when\n    the key implements crypto.Signer. This was caused by the fact that when \n    jws.WithKey() accepted keys that implemented crypto.Signer, there really\n    is no way to robustly check what algorithm the crypto.Signer implements.\n\n    The code has now been modified to check for KNOWN key types, i.e. those\n    that are defined in Go standard library, and those that are defined in\n    this library. For example, now calling jws.Sign() with jws.WithKey(jwa.RS256, ecdsaKey)\n    where ecdsaKey is either an instance of *ecdsa.PrivateKey or jwk.ECDSAPrivateKey\n    will produce an error.\n\n    However, if you use a separate library that wraps some KMS library which implements\n    crypto.Signer, this same check will not be performed due to the fact that\n    it is an unknown library to us. And there's no way to query a crypto.Signer\n    for its algorithm family.\n\nv2.0.14 17 Oct 2023\n[New Features]\n  * [jwk] jwk.IsPrivateKey(), as well as jwk.AsymmetricKey has been added.\n    The function can be used to tell if a jwk.Key is a private key of an\n    asymmetric key pair.\n[Security]\n  * golang.org/x/crypto has been updated to 0.14.0. The update contains a fix for HTTP/2\n    rapid reset DoS vulnerability, which some security scanning softwares may flag.\n    However, do note that this library is NOT affected by the issue, as it does not have\n    the capability to serve as an HTTP/2 server. This is included in this release\n    document so that users will be able to tell why this library may be flagged\n    when/if their scanning software do so.\n\nv2.0.13 26 Sep 2023\n[New Features]\n  * [jwk] jwk.Equal has been added. Please note that this is equivalent to\n  comparing the keys' thumbprints, therefore it does NOT take in consideration\n  non-essential fields.\n\n[Miscellaneous]\n  * Various documentation fixes and additions.\n\nv2.0.12 - 11 Aug 2023\n[Bug fixes]\n  * [jwt] jwt.Serializer was ignoring JWE flags (#951)\n\n[Miscellaneous]\n  * [jwk] Check for seed length on OKP JWKs to avoid panics (#947)\n  * [jws] Documentation for jws.WithKeySet()\n\nv2.0.11 - 14 Jun 2023\n[Security]\n  * Potential Padding Oracle Attack Vulnerability and Timing Attack Vulnerability \n    for JWE AES-CBC encrypted payloads affecting all v2 releases up to v2.0.10,\n    all v1 releases up to v1.2.25, and all v0 releases up to v0.9.2 have been reported by\n    @shogo82148.\n\n    Please note that v0 versions will NOT receive fixes.\n    This release fixes these vulnerabilities for the v2 series.\n\nv2.0.10 - 12 Jun 2023\n[New Features]\n  * [jwe] (EXPERIMENTAL) Added `jwe.KeyEncrypter` and `jwe.KeyDecrypter` interfaces\n    that works in similar ways as how `crypto.Signer` works for signature\n    generation and verification. It can act as the interface for your encryption/decryption\n    keys that are for example stored in an hardware device.\n\n    This feature is labeled experimental because the API for the above interfaces have not\n    been battle tested, and may need to changed yet. Please be aware that until the API\n    is deemed stable, you may have to adapat our code to these possible changes,\n    _even_ during minor version upgrades of this library.\n   \n[Bug fixes]\n  * Registering JWS signers/verifiers did not work since v2.0.0, because the\n    way we handle algorithm names changed in 2aa98ce6884187180a7145b73da78c859dd46c84.\n    (We previously thought that this would be checked by the example code, but it\n     apparently failed to flag us properly)\n\n    The logic behind managing the internal database has been fixed, and\n    `jws.RegisterSigner` and `jws.RegisterVerifier` now properly hooks into the new\n    `jwa.RegisterSignatureAlgorithm` to automatically register new algorithm names\n    (#910, #911)\n[Miscellaneous]\n  * Added limited support for github.com/segmentio/asm/base64. Compile your code\n    with the `jwx_asmbase64` build tag. This feature is EXPERIMENTAL.\n\n    Through limited testing, the use of a faster base64 library provide 1~5% increase\n    in throughput on average. It might make more difference if the input/output is large.\n    If you care about this performance improvement, you should probably enable\n    `goccy` JSON parser as well, by specifying `jwx_goccy,jwx_asmbase64` in your build call.\n  * Slightly changed the way global variables underneath `jwk.Fetch` are initialized and\n    configured. `jwk.Fetch` creates an object that spawns wokers to fetch JWKS when it's\n    first called.\n    You can now also use `jwk.SetGlobalFetcher()` to set a fetcher object which you can\n    control.\n\nv2.0.9 - 21 Mar 2023\n[Security Fixes]\n  * Updated use of golang.org/x/crypto to v0.7.0\n[Bug fixes]\n  * Emitted PEM file for EC private key types used the wrong PEM armor (#875)\n[Miscellaneous]\n  * Banners for generated files have been modified to allow tools to pick them up (#867)\n  * Remove unused variables around ReadFileOption (#866)\n  * Fix test failures\n  * Support bazel out of the box\n  * Now you can create JWS messages using `{\"alg\":\"none\"}`, by calling `jws.Sign()`\n    with `jws.WithInsecureNoSignature()` option. (#888, #890).\n\n    Note that there is no way to call\n    `jws.Verify()` while allowing `{\"alg\":\"none\"}` as you wouldn't be _verifying_\n    the message if we allowed the \"none\" algorithm. `jws.Parse()` will parse such\n    messages witout verification.\n\n    `jwt` also allows you to sign using alg=\"none\", but there's no symmetrical\n    way to verify such messages.\n\nv2.0.8 - 25 Nov 2022\n[Security Fixes]\n  * [jws][jwe] Starting from go 1.19, code related to elliptic algorithms\n    panics (instead of returning an error) when certain methods\n    such as `ScalarMult` are called using points that are not on the\n    elliptic curve being used.\n\n    Using inputs that cause this condition, and you accept unverified JWK\n    from the outside it may be possible for a third-party to cause panics\n    in your program.\n\n    This has been fixed by verifying that the point being used is actually\n    on the curve before such computations (#840)\n[Miscellaneous]\n  * `jwx.GuessFormat` now returns `jwx.InvalidFormat` when the heuristics\n    is sure that the buffer format is invalid.\n\nv2.0.7 - 15 Nov 2022\n[New features]\n  * [jwt] Each `jwt.Token` now has an `Options()` method\n  * [jwt] `jwt.Settings(jwt.WithFlattenedAudience(true))` has a slightly\n    different semantic than before. Instead of changing a global variable,\n    it now specifies that the default value of each per-token option for\n    `jwt.FlattenAudience` is true.\n\n    Therefore, this is what happens:\n\n       // No global settings\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // false\n\n       // With global settings\n       jwt.Settings(jwt.WithFlattenedAudience(true))\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // true\n       // But you can still turn FlattenAudience off for this\n       // token alone\n       tok.Options.Disable(jwt.FlattenAudience)\n\n    Note that while unlikely to happen for users relying on the old behavior,\n    this change DOES introduce timing issues: whereas old versions switched the\n    JSON marshaling for ALL tokens immediately after calling `jwt.Settings`,\n    the new behavior does NOT affect tokens that have been created before the\n    call to `jwt.Settings` (but marshaled afterwards).\n\n    So the following may happen:\n\n      // < v2.0.7\n      tok := jwt.New() \n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten = on\n\n      // >= v2.0.7\n      tok := jwt.New() // flatten = off\n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten is still off\n\n    It is recommended that you only set the global setting once at the\n    very beginning of your program to avoid problems.\n\n    Also note that `Clone()` copies the settings as well.\n\n[Miscellaneous]\n  * WithCompact's stringification should have been that of the\n    internal indentity struct (\"WithSerialization\"), but it was\n    wrongly producing \"WithCompact\". This has been fixed.\n  * Go Workspaces have been enabled within this module.\n    - When developing, modules will refer to the main jwx module that they\n      are part of. This allows us to explicitly specify the dependency version\n      in, for example, ./cmd/jwx/go.mod but still develop against the local version.\n    - If you are using `goimports` and other tools, you might want to upgrade\n      binaries -- for example, when using vim-go's auto-format-on-save feature,\n      my old binaries took well over 5~10 seconds to compute the import paths.\n      This was fixed when I switched to using go1.19, and upgraded the binaries\n      used by vim-go\n\nv2.0.6 - 25 Aug 2022\n[Bug fixes][Security]\n  * [jwe] Agreement Party UInfo and VInfo (apv/apu) were not properly being\n    passed to the functions to compute the aad when encrypting using ECDH-ES\n    family of algorithms. Therefore, when using apu/apv, messages encrypted\n    via this module would have failed to be properly decrypted.\n\n    Please note that bogus encrypted messages would not have succeed being\n    decrypted (i.e. this problem does not allow spoofed messages to be decrypted).\n    Therefore this would not have caused unwanted data to to creep in --\n    however it did pose problems for data to be sent and decrypted from this module\n    when using ECDH-ES with apu/apv.\n\n    While not extensively tested, we believe this regression was introduced\n    with the v2 release.\n\nv2.0.5 - 11 Aug 2022\n[Bug fixes]\n  * [jwt] Remove stray debug log\n  * [jwk] Fix x5u field name, caused by a typo\n  * [misc] Update golangci-lint action to v3; v2 was causing weird problems\n\nv2.0.4 - 19 Jul 2022\n[Bug Fixes]\n  * [jwk] github.com/lestrrat-go/httprc, which jwk.Cache depends on,\n    had a problem with inserting URLs to be re-fetched into its queue.\n    As a result it could have been the case that some JWKS were not\n    updated properly. Please upgrade if you use jwk.Cache.\n\n  * [jwk] cert.Get could fail with an out of bounds index look up\n\n  * [jwk] Fix doc buglet in `KeyType()` method\n\n[New Features]\n  * [jws] Add `jws.WithMultipleKeysPerKeyID()` sub-option to allow non-unique\n    key IDs in a given JWK set. By default we assume that a key ID is unique\n    within a key set, but enabling this option allows you to handle JWK sets\n    that contain multiple keys that contain the same key ID.\n\n  * [jwt] Before v2.0.1, sub-second accuracy for time based fields\n    (i.e. `iat`, `exp`, `nbf`) were not respected. Because of this the code\n    to evaluate this code had always truncated any-subsecond portion\n    of these fields, and therefore no sub-second comparisons worked.\n    A new option for validation `jwt.WithTruncation()` has been added\n    to workaround this. This option controls the value used to truncate\n    the time fields. When set to 0, sub-second comparison would be\n    possible.\n    FIY, truncatation will still happen because we do not want to\n    use the monotonic clocks when making comparisons. It's just that\n    truncating using `0` as its argument effectively only strips out\n    the monotonic clock\n\nv2.0.3 - 13 Jun 2022\n[Bug Fixes]\n  * [jwk] Update dependency on github.com/lestrrat-go/httprc to v1.0.2 to\n    avoid unintended blocking in the update goroutine for jwk.Cache\n\nv2.0.2 - 23 May 2022\n[Bug Fixes][Security]\n  * [jwe] An old bug from at least 7 years ago existed in handling AES-CBC unpadding,\n    where the unpad operation might remove more bytes than necessary (#744)\n    This affects all jwx code that is available before v2.0.2 and v1.2.25.\n\n[New Features]\n  * [jwt] RFC3339 timestamps are also accepted for Numeric Date types in JWT tokens.\n    This allows users to parse servers that errnously use RFC3339 timestamps in\n    some pre-defined fields. You can change this behavior by setting \n    `jwt.WithNumericDateParsePedantic` to `false`\n  * [jwt] `jwt.WithNumericDateParsePedantic` has been added. This is a global\n    option that is set using `jwt.Settings`\n\nv2.0.1 - 06 May 2022\n  * [jwk] `jwk.Set` had erronously been documented as not returning an error\n    when the same key already exists in the set. This is a behavior change\n    since v2, and it was missing in the docs (#730)\n  * [jwt] `jwt.ErrMissingRequiredClaim` has been deprecated. Please use\n    `jwt.ErrRequiredClaim` instead.\n  * [jwt] `jwt.WithNumericDateParsePrecision` and `jwt.WithNumericDateFormatPrecision`\n    have been added to parse and format fractional seconds. These options can be\n    passed to `jwt.Settings`.\n    The default precision is set to 0, and fractional portions are not parsed nor\n    formatted. The precision may be set up to 9.\n  * `golang.org/x/crypto` has been upgraded (#724)\n  * `io/ioutil` has been removed from the source code.\n\nv2.0.0 - 24 Apr 2022\n  * This i the first v2 release, which represents a set of design changes\n    that were learnt over the previous 2 years. As a result the v2 API\n    should be much more consistent and uniform across packages, and\n    should be much more flexible to accomodate real-world needs.\n    \n    For a complete list of changes, please see the Changes-v2.md file,\n    or check the diff at https://github.com/lestrrat-go/jwx/compare/v1...v2\n\n[Miscellaneous]\n  * Minor house cleaning on code generation tools\n\n[jwt]\n  * `jwt.ErrMissingRequiredClaim()` has been added\n\nv2.0.0-beta2 - 16 Apr 2022\n[jwk]\n  * Updated `jwk.Set` API and reflected pending changes from v1 which were\n    left over. Please see Changes-v2.md file for details.\n\n  * Added `jwk.CachedSet`, a shim over `jwk.Cache` that allows you to\n    have to write wrappers around `jwk.Cache` that retrieves a particular\n    `jwk.Set` out of it. You can use it to, for example, pass `jwk.CachedSet`\n    to a `jws.Verify`\n\n      cache := jwk.NewCache(ctx)\n      cache.Register(ctx, jwksURL)\n      cachedSet := jwk.NewCachedSet(cache, jwksURL)\n      jws.Verify(signed, jws.WithKeySet(cachedSet))\n\nv2.0.0-beta1 - 09 Apr 2022\n[Miscellaneous]\n  * Renamed Changes.v2 to Changes-v2.md\n  * Housecleaning for lint action.\n  * While v2 was not affected, ported over equivalent test for #681 to catch\n    regressions in the future.\n  * Please note that there is no stability guarantees on pre-releases.\n\nv2.0.0-alpha1 - 04 Apr 2022\n  * Initial pre-release of v2 line. Please note that there is no stability guarantees\n    on pre-releases.\n", "//go:generate ../tools/cmd/genjwe.sh\n\n// Package jwe implements JWE as described in https://tools.ietf.org/html/rfc7516\npackage jwe\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\n\t\"github.com/lestrrat-go/blackmagic\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/keyconv\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/content_crypt\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/keyenc\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe/internal/keygen\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n)\n\nvar muSettings sync.RWMutex\nvar maxPBES2Count = 10000\n\nfunc Settings(options ...GlobalOption) {\n\tmuSettings.Lock()\n\tdefer muSettings.Unlock()\n\tfor _, option := range options {\n\t\tswitch option.Ident() {\n\t\tcase identMaxPBES2Count{}:\n\t\t\tmaxPBES2Count = option.Value().(int)\n\t\t}\n\t}\n}\n\nconst (\n\tfmtInvalid = iota\n\tfmtCompact\n\tfmtJSON\n\tfmtJSONPretty\n\tfmtMax\n)\n\nvar _ = fmtInvalid\nvar _ = fmtMax\n\nvar registry = json.NewRegistry()\n\ntype keyEncrypterWrapper struct {\n\tencrypter KeyEncrypter\n}\n\nfunc (w *keyEncrypterWrapper) Algorithm() jwa.KeyEncryptionAlgorithm {\n\treturn w.encrypter.Algorithm()\n}\n\nfunc (w *keyEncrypterWrapper) EncryptKey(cek []byte) (keygen.ByteSource, error) {\n\tencrypted, err := w.encrypter.EncryptKey(cek)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn keygen.ByteKey(encrypted), nil\n}\n\ntype recipientBuilder struct {\n\talg     jwa.KeyEncryptionAlgorithm\n\tkey     interface{}\n\theaders Headers\n}\n\nfunc (b *recipientBuilder) Build(cek []byte, calg jwa.ContentEncryptionAlgorithm, cc *content_crypt.Generic) (Recipient, []byte, error) {\n\tvar enc keyenc.Encrypter\n\n\t// we need the raw key for later use\n\trawKey := b.key\n\n\tvar keyID string\n\tif ke, ok := b.key.(KeyEncrypter); ok {\n\t\tenc = &keyEncrypterWrapper{encrypter: ke}\n\t\tif kider, ok := enc.(KeyIDer); ok {\n\t\t\tkeyID = kider.KeyID()\n\t\t}\n\t} else if jwkKey, ok := b.key.(jwk.Key); ok {\n\t\t// Meanwhile, grab the kid as well\n\t\tkeyID = jwkKey.KeyID()\n\n\t\tvar raw interface{}\n\t\tif err := jwkKey.Raw(&raw); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to retrieve raw key out of %T: %w`, b.key, err)\n\t\t}\n\n\t\trawKey = raw\n\t}\n\n\tif enc == nil {\n\t\tswitch b.alg {\n\t\tcase jwa.RSA1_5:\n\t\t\tvar pubkey rsa.PublicKey\n\t\t\tif err := keyconv.RSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, rawKey, err)\n\t\t\t}\n\n\t\t\tv, err := keyenc.NewRSAPKCSEncrypt(b.alg, &pubkey)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create RSA PKCS encrypter: %w`, err)\n\t\t\t}\n\t\t\tenc = v\n\t\tcase jwa.RSA_OAEP, jwa.RSA_OAEP_256:\n\t\t\tvar pubkey rsa.PublicKey\n\t\t\tif err := keyconv.RSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, rawKey, err)\n\t\t\t}\n\n\t\t\tv, err := keyenc.NewRSAOAEPEncrypt(b.alg, &pubkey)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create RSA OAEP encrypter: %w`, err)\n\t\t\t}\n\t\t\tenc = v\n\t\tcase jwa.A128KW, jwa.A192KW, jwa.A256KW,\n\t\t\tjwa.A128GCMKW, jwa.A192GCMKW, jwa.A256GCMKW,\n\t\t\tjwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\t\tsharedkey, ok := rawKey.([]byte)\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, fmt.Errorf(`invalid key: []byte required (%T)`, rawKey)\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tswitch b.alg {\n\t\t\tcase jwa.A128KW, jwa.A192KW, jwa.A256KW:\n\t\t\t\tenc, err = keyenc.NewAES(b.alg, sharedkey)\n\t\t\tcase jwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\t\t\tenc, err = keyenc.NewPBES2Encrypt(b.alg, sharedkey)\n\t\t\tdefault:\n\t\t\t\tenc, err = keyenc.NewAESGCMEncrypt(b.alg, sharedkey)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create key wrap encrypter: %w`, err)\n\t\t\t}\n\t\t\t// NOTE: there was formerly a restriction, introduced\n\t\t\t// in PR #26, which disallowed certain key/content\n\t\t\t// algorithm combinations. This seemed bogus, and\n\t\t\t// interop with the jose tool demonstrates it.\n\t\tcase jwa.ECDH_ES, jwa.ECDH_ES_A128KW, jwa.ECDH_ES_A192KW, jwa.ECDH_ES_A256KW:\n\t\t\tvar keysize int\n\t\t\tswitch b.alg {\n\t\t\tcase jwa.ECDH_ES:\n\t\t\t\t// https://tools.ietf.org/html/rfc7518#page-15\n\t\t\t\t// In Direct Key Agreement mode, the output of the Concat KDF MUST be a\n\t\t\t\t// key of the same length as that used by the \"enc\" algorithm.\n\t\t\t\tkeysize = cc.KeySize()\n\t\t\tcase jwa.ECDH_ES_A128KW:\n\t\t\t\tkeysize = 16\n\t\t\tcase jwa.ECDH_ES_A192KW:\n\t\t\t\tkeysize = 24\n\t\t\tcase jwa.ECDH_ES_A256KW:\n\t\t\t\tkeysize = 32\n\t\t\t}\n\n\t\t\tswitch key := rawKey.(type) {\n\t\t\tcase x25519.PublicKey:\n\t\t\t\tvar apu, apv []byte\n\t\t\t\tif hdrs := b.headers; hdrs != nil {\n\t\t\t\t\tapu = hdrs.AgreementPartyUInfo()\n\t\t\t\t\tapv = hdrs.AgreementPartyVInfo()\n\t\t\t\t}\n\n\t\t\t\tv, err := keyenc.NewECDHESEncrypt(b.alg, calg, keysize, rawKey, apu, apv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create ECDHS key wrap encrypter: %w`, err)\n\t\t\t\t}\n\t\t\t\tenc = v\n\t\t\tdefault:\n\t\t\t\tvar pubkey ecdsa.PublicKey\n\t\t\t\tif err := keyconv.ECDSAPublicKey(&pubkey, rawKey); err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to generate public key from key (%T): %w`, key, err)\n\t\t\t\t}\n\n\t\t\t\tvar apu, apv []byte\n\t\t\t\tif hdrs := b.headers; hdrs != nil {\n\t\t\t\t\tapu = hdrs.AgreementPartyUInfo()\n\t\t\t\t\tapv = hdrs.AgreementPartyVInfo()\n\t\t\t\t}\n\n\t\t\t\tv, err := keyenc.NewECDHESEncrypt(b.alg, calg, keysize, &pubkey, apu, apv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(`failed to create ECDHS key wrap encrypter: %w`, err)\n\t\t\t\t}\n\t\t\t\tenc = v\n\t\t\t}\n\t\tcase jwa.DIRECT:\n\t\t\tsharedkey, ok := rawKey.([]byte)\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid key: []byte required\")\n\t\t\t}\n\t\t\tenc, _ = keyenc.NewNoop(b.alg, sharedkey)\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(`invalid key encryption algorithm (%s)`, b.alg)\n\t\t}\n\t}\n\n\tr := NewRecipient()\n\tif hdrs := b.headers; hdrs != nil {\n\t\t_ = r.SetHeaders(hdrs)\n\t}\n\n\tif err := r.Headers().Set(AlgorithmKey, b.alg); err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to set header: %w`, err)\n\t}\n\n\tif keyID != \"\" {\n\t\tif err := r.Headers().Set(KeyIDKey, keyID); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to set header: %w`, err)\n\t\t}\n\t}\n\n\tvar rawCEK []byte\n\tenckey, err := enc.EncryptKey(cek)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to encrypt key: %w`, err)\n\t}\n\tif enc.Algorithm() == jwa.ECDH_ES || enc.Algorithm() == jwa.DIRECT {\n\t\trawCEK = enckey.Bytes()\n\t} else {\n\t\tif err := r.SetEncryptedKey(enckey.Bytes()); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to set encrypted key: %w`, err)\n\t\t}\n\t}\n\n\tif hp, ok := enckey.(populater); ok {\n\t\tif err := hp.Populate(r.Headers()); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(`failed to populate: %w`, err)\n\t\t}\n\t}\n\n\treturn r, rawCEK, nil\n}\n\n// Encrypt generates a JWE message for the given payload and returns\n// it in serialized form, which can be in either compact or\n// JSON format. Default is compact.\n//\n// You must pass at least one key to `jwe.Encrypt()` by using `jwe.WithKey()`\n// option.\n//\n//\tjwe.Encrypt(payload, jwe.WithKey(alg, key))\n//\tjwe.Encrypt(payload, jws.WithJSON(), jws.WithKey(alg1, key1), jws.WithKey(alg2, key2))\n//\n// Note that in the second example the `jws.WithJSON()` option is\n// specified as well. This is because the compact serialization\n// format does not support multiple recipients, and users must\n// specifically ask for the JSON serialization format.\n//\n// Read the documentation for `jwe.WithKey()` to learn more about the\n// possible values that can be used for `alg` and `key`.\n//\n// Look for options that return `jwe.EncryptOption` or `jws.EncryptDecryptOption`\n// for a complete list of options that can be passed to this function.\nfunc Encrypt(payload []byte, options ...EncryptOption) ([]byte, error) {\n\treturn encrypt(payload, nil, options...)\n}\n\n// Encryptstatic is exactly like Encrypt, except it accepts a static\n// content encryption key (CEK). It is separated out from the main\n// Encrypt function such that the latter does not accidentally use a static\n// CEK.\n//\n// DO NOT attempt to use this function unless you completely understand the\n// security implications to using static CEKs. You have been warned.\n//\n// This function is currently considered EXPERIMENTAL, and is subject to\n// future changes across minor/micro versions.\nfunc EncryptStatic(payload, cek []byte, options ...EncryptOption) ([]byte, error) {\n\tif len(cek) <= 0 {\n\t\treturn nil, fmt.Errorf(`jwe.EncryptStatic: empty CEK`)\n\t}\n\treturn encrypt(payload, cek, options...)\n}\n\n// encrypt is separate so it can receive cek from outside.\n// (but we don't want to receive it in the options slice)\nfunc encrypt(payload, cek []byte, options ...EncryptOption) ([]byte, error) {\n\t// default content encryption algorithm\n\tcalg := jwa.A256GCM\n\n\t// default compression is \"none\"\n\tcompression := jwa.NoCompress\n\n\t// default format is compact serialization\n\tformat := fmtCompact\n\n\t// builds each \"recipient\" with encrypted_key and headers\n\tvar builders []*recipientBuilder\n\n\tvar protected Headers\n\tvar mergeProtected bool\n\tvar useRawCEK bool\n\tfor _, option := range options {\n\t\t//nolint:forcetypeassert\n\t\tswitch option.Ident() {\n\t\tcase identKey{}:\n\t\t\tdata := option.Value().(*withKey)\n\t\t\tv, ok := data.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: expected alg to be jwa.KeyEncryptionAlgorithm, but got %T`, data.alg)\n\t\t\t}\n\n\t\t\tswitch v {\n\t\t\tcase jwa.DIRECT, jwa.ECDH_ES:\n\t\t\t\tuseRawCEK = true\n\t\t\t}\n\n\t\t\tbuilders = append(builders, &recipientBuilder{\n\t\t\t\talg:     v,\n\t\t\t\tkey:     data.key,\n\t\t\t\theaders: data.headers,\n\t\t\t})\n\t\tcase identContentEncryptionAlgorithm{}:\n\t\t\tcalg = option.Value().(jwa.ContentEncryptionAlgorithm)\n\t\tcase identCompress{}:\n\t\t\tcompression = option.Value().(jwa.CompressionAlgorithm)\n\t\tcase identMergeProtectedHeaders{}:\n\t\t\tmergeProtected = option.Value().(bool)\n\t\tcase identProtectedHeaders{}:\n\t\t\tv := option.Value().(Headers)\n\t\t\tif !mergeProtected || protected == nil {\n\t\t\t\tprotected = v\n\t\t\t} else {\n\t\t\t\tctx := context.TODO()\n\t\t\t\tmerged, err := protected.Merge(ctx, v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to merge headers: %w`, err)\n\t\t\t\t}\n\t\t\t\tprotected = merged\n\t\t\t}\n\t\tcase identSerialization{}:\n\t\t\tformat = option.Value().(int)\n\t\t}\n\t}\n\n\t// We need to have at least one builder\n\tswitch l := len(builders); {\n\tcase l == 0:\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: missing key encryption builders: use jwe.WithKey() to specify one`)\n\tcase l > 1:\n\t\tif format == fmtCompact {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: cannot use compact serialization when multiple recipients exist (check the number of WithKey() argument, or use WithJSON())`)\n\t\t}\n\t}\n\n\tif useRawCEK {\n\t\tif len(builders) != 1 {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: multiple recipients for ECDH-ES/DIRECT mode supported`)\n\t\t}\n\t}\n\n\t// There is exactly one content encrypter.\n\tcontentcrypt, err := content_crypt.NewGeneric(calg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to create AES encrypter: %w`, err)\n\t}\n\n\tif len(cek) <= 0 {\n\t\tgenerator := keygen.NewRandom(contentcrypt.KeySize())\n\t\tbk, err := generator.Generate()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to generate key: %w`, err)\n\t\t}\n\t\tcek = bk.Bytes()\n\t}\n\n\trecipients := make([]Recipient, len(builders))\n\tfor i, builder := range builders {\n\t\t// some builders require hint from the contentcrypt object\n\t\tr, rawCEK, err := builder.Build(cek, calg, contentcrypt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to create recipient #%d: %w`, i, err)\n\t\t}\n\t\trecipients[i] = r\n\n\t\t// Kinda feels weird, but if useRawCEK == true, we asserted earlier\n\t\t// that len(builders) == 1, so this is OK\n\t\tif useRawCEK {\n\t\t\tcek = rawCEK\n\t\t}\n\t}\n\n\tif protected == nil {\n\t\tprotected = NewHeaders()\n\t}\n\n\tif err := protected.Set(ContentEncryptionKey, calg); err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to set \"enc\" in protected header: %w`, err)\n\t}\n\n\tif compression != jwa.NoCompress {\n\t\tpayload, err = compress(payload)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to compress payload before encryption: %w`, err)\n\t\t}\n\t\tif err := protected.Set(CompressionKey, compression); err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to set \"zip\" in protected header: %w`, err)\n\t\t}\n\t}\n\n\t// If there's only one recipient, you want to include that in the\n\t// protected header\n\tif len(recipients) == 1 {\n\t\th, err := protected.Merge(context.TODO(), recipients[0].Headers())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Encrypt: failed to merge protected headers: %w`, err)\n\t\t}\n\t\tprotected = h\n\t}\n\n\taad, err := protected.Encode()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 encode protected headers: %w`, err)\n\t}\n\n\tiv, ciphertext, tag, err := contentcrypt.Encrypt(cek, payload, aad)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to encrypt payload: %w`, err)\n\t}\n\n\tmsg := NewMessage()\n\n\tif err := msg.Set(CipherTextKey, ciphertext); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, CipherTextKey, err)\n\t}\n\tif err := msg.Set(InitializationVectorKey, iv); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, InitializationVectorKey, err)\n\t}\n\tif err := msg.Set(ProtectedHeadersKey, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, ProtectedHeadersKey, err)\n\t}\n\tif err := msg.Set(RecipientsKey, recipients); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, RecipientsKey, err)\n\t}\n\tif err := msg.Set(TagKey, tag); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, TagKey, err)\n\t}\n\n\tswitch format {\n\tcase fmtCompact:\n\t\treturn Compact(msg)\n\tcase fmtJSON:\n\t\treturn json.Marshal(msg)\n\tcase fmtJSONPretty:\n\t\treturn json.MarshalIndent(msg, \"\", \"  \")\n\tdefault:\n\t\treturn nil, fmt.Errorf(`jwe.Encrypt: invalid serialization`)\n\t}\n}\n\ntype decryptCtx struct {\n\tmsg              *Message\n\taad              []byte\n\tcek              *[]byte\n\tcomputedAad      []byte\n\tkeyProviders     []KeyProvider\n\tprotectedHeaders Headers\n}\n\n// Decrypt takes the key encryption algorithm and the corresponding\n// key to decrypt the JWE message, and returns the decrypted payload.\n// The JWE message can be either compact or full JSON format.\n//\n// `alg` accepts a `jwa.KeyAlgorithm` for convenience so you can directly pass\n// the result of `(jwk.Key).Algorithm()`, but in practice it must be of type\n// `jwa.KeyEncryptionAlgorithm` or otherwise it will cause an error.\n//\n// `key` must be a private key. It can be either in its raw format (e.g. *rsa.PrivateKey) or a jwk.Key\nfunc Decrypt(buf []byte, options ...DecryptOption) ([]byte, error) {\n\tvar keyProviders []KeyProvider\n\tvar keyUsed interface{}\n\tvar cek *[]byte\n\tvar dst *Message\n\t//nolint:forcetypeassert\n\tfor _, option := range options {\n\t\tswitch option.Ident() {\n\t\tcase identMessage{}:\n\t\t\tdst = option.Value().(*Message)\n\t\tcase identKeyProvider{}:\n\t\t\tkeyProviders = append(keyProviders, option.Value().(KeyProvider))\n\t\tcase identKeyUsed{}:\n\t\t\tkeyUsed = option.Value()\n\t\tcase identKey{}:\n\t\t\tpair := option.Value().(*withKey)\n\t\t\talg, ok := pair.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(`WithKey() option must be specified using jwa.KeyEncryptionAlgorithm (got %T)`, pair.alg)\n\t\t\t}\n\t\t\tkeyProviders = append(keyProviders, &staticKeyProvider{\n\t\t\t\talg: alg,\n\t\t\t\tkey: pair.key,\n\t\t\t})\n\t\tcase identCEK{}:\n\t\t\tcek = option.Value().(*[]byte)\n\t\t}\n\t}\n\n\tif len(keyProviders) < 1 {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: no key providers have been provided (see jwe.WithKey(), jwe.WithKeySet(), and jwe.WithKeyProvider()`)\n\t}\n\n\tmsg, err := parseJSONOrCompact(buf, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse buffer for Decrypt: %w`, err)\n\t}\n\n\t// Process things that are common to the message\n\tctx := context.TODO()\n\th, err := msg.protectedHeaders.Clone(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to copy protected headers: %w`, err)\n\t}\n\th, err = h.Merge(ctx, msg.unprotectedHeaders)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to merge headers for message decryption: %w`, err)\n\t}\n\n\tvar aad []byte\n\tif aadContainer := msg.authenticatedData; aadContainer != nil {\n\t\taad = base64.Encode(aadContainer)\n\t}\n\n\tvar computedAad []byte\n\tif len(msg.rawProtectedHeaders) > 0 {\n\t\tcomputedAad = msg.rawProtectedHeaders\n\t} else {\n\t\t// this is probably not required once msg.Decrypt is deprecated\n\t\tvar err error\n\t\tcomputedAad, err = msg.protectedHeaders.Encode()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to encode protected headers: %w`, err)\n\t\t}\n\t}\n\n\t// for each recipient, attempt to match the key providers\n\t// if we have no recipients, pretend like we only have one\n\trecipients := msg.recipients\n\tif len(recipients) == 0 {\n\t\tr := NewRecipient()\n\t\tif err := r.SetHeaders(msg.protectedHeaders); err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to set headers to recipient: %w`, err)\n\t\t}\n\t\trecipients = append(recipients, r)\n\t}\n\n\tvar dctx decryptCtx\n\n\tdctx.aad = aad\n\tdctx.computedAad = computedAad\n\tdctx.msg = msg\n\tdctx.keyProviders = keyProviders\n\tdctx.protectedHeaders = h\n\tdctx.cek = cek\n\n\tvar lastError error\n\tfor _, recipient := range recipients {\n\t\tdecrypted, err := dctx.try(ctx, recipient, keyUsed)\n\t\tif err != nil {\n\t\t\tlastError = err\n\t\t\tcontinue\n\t\t}\n\t\tif dst != nil {\n\t\t\t*dst = *msg\n\t\t\tdst.rawProtectedHeaders = nil\n\t\t\tdst.storeProtectedHeaders = false\n\t\t}\n\t\treturn decrypted, nil\n\t}\n\treturn nil, fmt.Errorf(`jwe.Decrypt: failed to decrypt any of the recipients (last error = %w)`, lastError)\n}\n\nfunc (dctx *decryptCtx) try(ctx context.Context, recipient Recipient, keyUsed interface{}) ([]byte, error) {\n\tvar tried int\n\tvar lastError error\n\tfor i, kp := range dctx.keyProviders {\n\t\tvar sink algKeySink\n\t\tif err := kp.FetchKeys(ctx, &sink, recipient, dctx.msg); err != nil {\n\t\t\treturn nil, fmt.Errorf(`key provider %d failed: %w`, i, err)\n\t\t}\n\n\t\tfor _, pair := range sink.list {\n\t\t\ttried++\n\t\t\t// alg is converted here because pair.alg is of type jwa.KeyAlgorithm.\n\t\t\t// this may seem ugly, but we're trying to avoid declaring separate\n\t\t\t// structs for `alg jwa.KeyAlgorithm` and `alg jwa.SignatureAlgorithm`\n\t\t\t//nolint:forcetypeassert\n\t\t\talg := pair.alg.(jwa.KeyEncryptionAlgorithm)\n\t\t\tkey := pair.key\n\n\t\t\tdecrypted, err := dctx.decryptContent(ctx, alg, key, recipient)\n\t\t\tif err != nil {\n\t\t\t\tlastError = err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif keyUsed != nil {\n\t\t\t\tif err := blackmagic.AssignIfCompatible(keyUsed, key); err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(`failed to assign used key (%T) to %T: %w`, key, keyUsed, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn decrypted, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(`jwe.Decrypt: tried %d keys, but failed to match any of the keys with recipient (last error = %s)`, tried, lastError)\n}\n\nfunc (dctx *decryptCtx) decryptContent(ctx context.Context, alg jwa.KeyEncryptionAlgorithm, key interface{}, recipient Recipient) ([]byte, error) {\n\tif jwkKey, ok := key.(jwk.Key); ok {\n\t\tvar raw interface{}\n\t\tif err := jwkKey.Raw(&raw); err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to retrieve raw key from %T: %w`, key, err)\n\t\t}\n\t\tkey = raw\n\t}\n\n\tdec := newDecrypter(alg, dctx.msg.protectedHeaders.ContentEncryption(), key).\n\t\tAuthenticatedData(dctx.aad).\n\t\tComputedAuthenticatedData(dctx.computedAad).\n\t\tInitializationVector(dctx.msg.initializationVector).\n\t\tTag(dctx.msg.tag).\n\t\tCEK(dctx.cek)\n\n\tif recipient.Headers().Algorithm() != alg {\n\t\t// algorithms don't match\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: key and recipient algorithms do not match`)\n\t}\n\n\th2, err := dctx.protectedHeaders.Clone(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: failed to copy headers (1): %w`, err)\n\t}\n\n\th2, err = h2.Merge(ctx, recipient.Headers())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to copy headers (2): %w`, err)\n\t}\n\n\tswitch alg {\n\tcase jwa.ECDH_ES, jwa.ECDH_ES_A128KW, jwa.ECDH_ES_A192KW, jwa.ECDH_ES_A256KW:\n\t\tepkif, ok := h2.Get(EphemeralPublicKeyKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'epk' field`)\n\t\t}\n\t\tswitch epk := epkif.(type) {\n\t\tcase jwk.ECDSAPublicKey:\n\t\t\tvar pubkey ecdsa.PublicKey\n\t\t\tif err := epk.Raw(&pubkey); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to get public key: %w`, err)\n\t\t\t}\n\t\t\tdec.PublicKey(&pubkey)\n\t\tcase jwk.OKPPublicKey:\n\t\t\tvar pubkey interface{}\n\t\t\tif err := epk.Raw(&pubkey); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to get public key: %w`, err)\n\t\t\t}\n\t\t\tdec.PublicKey(pubkey)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected 'epk' type %T for alg %s\", epkif, alg)\n\t\t}\n\n\t\tif apu := h2.AgreementPartyUInfo(); len(apu) > 0 {\n\t\t\tdec.AgreementPartyUInfo(apu)\n\t\t}\n\t\tif apv := h2.AgreementPartyVInfo(); len(apv) > 0 {\n\t\t\tdec.AgreementPartyVInfo(apv)\n\t\t}\n\tcase jwa.A128GCMKW, jwa.A192GCMKW, jwa.A256GCMKW:\n\t\tivB64, ok := h2.Get(InitializationVectorKey)\n\t\tif ok {\n\t\t\tivB64Str, ok := ivB64.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'iv': %T\", ivB64)\n\t\t\t}\n\t\t\tiv, err := base64.DecodeString(ivB64Str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'iv': %w`, err)\n\t\t\t}\n\t\t\tdec.KeyInitializationVector(iv)\n\t\t}\n\t\ttagB64, ok := h2.Get(TagKey)\n\t\tif ok {\n\t\t\ttagB64Str, ok := tagB64.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'tag': %T\", tagB64)\n\t\t\t}\n\t\t\ttag, err := base64.DecodeString(tagB64Str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'tag': %w`, err)\n\t\t\t}\n\t\t\tdec.KeyTag(tag)\n\t\t}\n\tcase jwa.PBES2_HS256_A128KW, jwa.PBES2_HS384_A192KW, jwa.PBES2_HS512_A256KW:\n\t\tsaltB64, ok := h2.Get(SaltKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'p2s' field`)\n\t\t}\n\t\tsaltB64Str, ok := saltB64.(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'p2s': %T\", saltB64)\n\t\t}\n\n\t\tcount, ok := h2.Get(CountKey)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(`failed to get 'p2c' field`)\n\t\t}\n\t\tcountFlt, ok := count.(float64)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected type for 'p2c': %T\", count)\n\t\t}\n\t\tmuSettings.RLock()\n\t\tmaxCount := maxPBES2Count\n\t\tmuSettings.RUnlock()\n\t\tif countFlt > float64(maxCount) {\n\t\t\treturn nil, fmt.Errorf(\"invalid 'p2c' value\")\n\t\t}\n\t\tsalt, err := base64.DecodeString(saltB64Str)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to b64-decode 'salt': %w`, err)\n\t\t}\n\t\tdec.KeySalt(salt)\n\t\tdec.KeyCount(int(countFlt))\n\t}\n\n\tplaintext, err := dec.Decrypt(recipient, dctx.msg.cipherText, dctx.msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jwe.Decrypt: decryption failed: %w`, err)\n\t}\n\n\tif h2.Compression() == jwa.Deflate {\n\t\tbuf, err := uncompress(plaintext)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`jwe.Derypt: failed to uncompress payload: %w`, err)\n\t\t}\n\t\tplaintext = buf\n\t}\n\n\tif plaintext == nil {\n\t\treturn nil, fmt.Errorf(`failed to find matching recipient`)\n\t}\n\n\treturn plaintext, nil\n}\n\n// Parse parses the JWE message into a Message object. The JWE message\n// can be either compact or full JSON format.\n//\n// Parse() currently does not take any options, but the API accepts it\n// in anticipation of future addition.\nfunc Parse(buf []byte, _ ...ParseOption) (*Message, error) {\n\treturn parseJSONOrCompact(buf, false)\n}\n\nfunc parseJSONOrCompact(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tbuf = bytes.TrimSpace(buf)\n\tif len(buf) == 0 {\n\t\treturn nil, fmt.Errorf(`empty buffer`)\n\t}\n\n\tif buf[0] == '{' {\n\t\treturn parseJSON(buf, storeProtectedHeaders)\n\t}\n\treturn parseCompact(buf, storeProtectedHeaders)\n}\n\n// ParseString is the same as Parse, but takes a string.\nfunc ParseString(s string) (*Message, error) {\n\treturn Parse([]byte(s))\n}\n\n// ParseReader is the same as Parse, but takes an io.Reader.\nfunc ParseReader(src io.Reader) (*Message, error) {\n\tbuf, err := io.ReadAll(src)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to read from io.Reader: %w`, err)\n\t}\n\treturn Parse(buf)\n}\n\nfunc parseJSON(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tm := NewMessage()\n\tm.storeProtectedHeaders = storeProtectedHeaders\n\tif err := json.Unmarshal(buf, &m); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse JSON: %w`, err)\n\t}\n\treturn m, nil\n}\n\nfunc parseCompact(buf []byte, storeProtectedHeaders bool) (*Message, error) {\n\tparts := bytes.Split(buf, []byte{'.'})\n\tif len(parts) != 5 {\n\t\treturn nil, fmt.Errorf(`compact JWE format must have five parts (%d)`, len(parts))\n\t}\n\n\thdrbuf, err := base64.Decode(parts[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse first part of compact form: %w`, err)\n\t}\n\n\tprotected := NewHeaders()\n\tif err := json.Unmarshal(hdrbuf, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to parse header JSON: %w`, err)\n\t}\n\n\tivbuf, err := base64.Decode(parts[2])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode iv: %w`, err)\n\t}\n\n\tctbuf, err := base64.Decode(parts[3])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode content: %w`, err)\n\t}\n\n\ttagbuf, err := base64.Decode(parts[4])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to base64 decode tag: %w`, err)\n\t}\n\n\tm := NewMessage()\n\tif err := m.Set(CipherTextKey, ctbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, CipherTextKey, err)\n\t}\n\tif err := m.Set(InitializationVectorKey, ivbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, InitializationVectorKey, err)\n\t}\n\tif err := m.Set(ProtectedHeadersKey, protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, ProtectedHeadersKey, err)\n\t}\n\n\tif err := m.makeDummyRecipient(string(parts[1]), protected); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to setup recipient: %w`, err)\n\t}\n\n\tif err := m.Set(TagKey, tagbuf); err != nil {\n\t\treturn nil, fmt.Errorf(`failed to set %s: %w`, TagKey, err)\n\t}\n\n\tif storeProtectedHeaders {\n\t\t// This is later used for decryption.\n\t\tm.rawProtectedHeaders = parts[0]\n\t}\n\n\treturn m, nil\n}\n\n// RegisterCustomField allows users to specify that a private field\n// be decoded as an instance of the specified type. This option has\n// a global effect.\n//\n// For example, suppose you have a custom field `x-birthday`, which\n// you want to represent as a string formatted in RFC3339 in JSON,\n// but want it back as `time.Time`.\n//\n// In that case you would register a custom field as follows\n//\n//\tjwe.RegisterCustomField(`x-birthday`, timeT)\n//\n// Then `hdr.Get(\"x-birthday\")` will still return an `interface{}`,\n// but you can convert its type to `time.Time`\n//\n//\tbdayif, _ := hdr.Get(`x-birthday`)\n//\tbday := bdayif.(time.Time)\nfunc RegisterCustomField(name string, object interface{}) {\n\tregistry.Register(name, object)\n}\n", "package jwe_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/jwxtest\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwe\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\texamplePayload = `The true sign of intelligence is not knowledge but imagination.`\n)\n\nvar rsaPrivKey rsa.PrivateKey\n\nfunc init() {\n\tvar jwkstr = []byte(`\n     {\"kty\":\"RSA\",\n      \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n      \"e\":\"AQAB\",\n      \"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n      \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n      \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n      \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n      \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n      \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\"\n     }`)\n\n\tprivkey, err := jwk.ParseKey(jwkstr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := privkey.Raw(&rsaPrivKey); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestSanityCheck_JWEExamplePayload(t *testing.T) {\n\texpected := []byte{\n\t\t84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,\n\t\t111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,\n\t\t101, 32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,\n\t\t101, 100, 103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,\n\t\t110, 97, 116, 105, 111, 110, 46,\n\t}\n\tassert.Equal(t, expected, []byte(examplePayload), \"examplePayload OK\")\n}\n\nfunc TestParse(t *testing.T) {\n\tconst s = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\tt.Run(\"Compact format\", func(t *testing.T) {\n\t\tt.Run(\"Normal\", func(t *testing.T) {\n\t\t\tmsg, err := jwe.Parse([]byte(s))\n\t\t\tif !assert.NoError(t, err, \"Parsing JWE is successful\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !assert.Len(t, msg.Recipients(), 1, \"There is exactly 1 recipient\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\n\t\tparts := strings.Split(s, \".\")\n\t\tt.Run(\"Missing parts\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(parts[:4], \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with missing parts`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid header\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append([]string(nil), \"!!invalidheader!!\"), parts[1:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid header`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid encrypted key\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[0]), \"!!invalidenckey!!\"), parts[2:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid encrypted key`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid initialization vector\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[:2]...), \"!!invalidiv!!\"), parts[3:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid initialization vector`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid content\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(append(append([]string(nil), parts[:3]...), \"!!invalidcontent!!\"), parts[4:]...), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid content`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Invalid tag\", func(t *testing.T) {\n\t\t\ts2 := strings.Join(append(parts[:4], \"!!invalidtag!!\"), \".\")\n\t\t\t_, err := jwe.Parse([]byte(s2))\n\t\t\tif !assert.Error(t, err, `should fail to parse compact format with invalid tag`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"JSON format\", func(t *testing.T) {\n\t\tmsg, err := jwe.Parse([]byte(s))\n\t\tif !assert.NoError(t, err, \"Parsing JWE is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, \"Serializing to JSON format should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tmsg2, err := jwe.Parse(buf)\n\t\tif !assert.NoError(t, err, \"Parsing JWE in JSON format should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, msg, msg2, \"messages should match\") {\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// This test parses the example found in https://tools.ietf.org/html/rfc7516#appendix-A.1,\n// and checks if we can roundtrip to the same compact serialization format.\nfunc TestParse_RSAES_OAEP_AES_GCM(t *testing.T) {\n\tconst payload = `The true sign of intelligence is not knowledge but imagination.`\n\tconst serialized = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\tvar jwkstr = []byte(`\n     {\"kty\":\"RSA\",\n      \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n      \"e\":\"AQAB\",\n      \"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n      \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n      \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n      \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n      \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n      \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\"\n     }`)\n\n\tprivkey, err := jwk.ParseKey(jwkstr)\n\tif !assert.NoError(t, err, `parsing jwk should succeed`) {\n\t\treturn\n\t}\n\n\tvar rawkey rsa.PrivateKey\n\tif !assert.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`) {\n\t\treturn\n\t}\n\n\tmsg := jwe.NewMessage()\n\tplaintext, err := jwe.Decrypt([]byte(serialized), jwe.WithKey(jwa.RSA_OAEP, rawkey), jwe.WithMessage(msg))\n\tif !assert.NoError(t, err, \"jwe.Decrypt should be successful\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, 1, len(msg.Recipients()), \"message recipients header length is 1\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, payload, string(plaintext), \"decrypted value does not match\") {\n\t\treturn\n\t}\n\n\ttemplates := []*struct {\n\t\tName     string\n\t\tOptions  []jwe.EncryptOption\n\t\tExpected string\n\t}{\n\t\t{\n\t\t\tName:     \"Compact\",\n\t\t\tOptions:  []jwe.EncryptOption{jwe.WithCompact()},\n\t\t\tExpected: serialized,\n\t\t},\n\t\t{\n\t\t\tName:     \"JSON\",\n\t\t\tOptions:  []jwe.EncryptOption{jwe.WithJSON()},\n\t\t\tExpected: `{\"ciphertext\":\"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A\",\"iv\":\"48V1_ALb6US04U3b\",\"protected\":\"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\",\"header\":{\"alg\":\"RSA-OAEP\"},\"encrypted_key\":\"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg\",\"tag\":\"XFBoMYUZodetZdvTiFvSkQ\"}`,\n\t\t},\n\t\t{\n\t\t\tName:    \"JSON (Pretty)\",\n\t\t\tOptions: []jwe.EncryptOption{jwe.WithJSON(jwe.WithPretty(true))},\n\t\t\tExpected: `{\n  \"ciphertext\": \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A\",\n  \"iv\": \"48V1_ALb6US04U3b\",\n  \"protected\": \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\",\n  \"header\": {\n    \"alg\": \"RSA-OAEP\"\n  },\n  \"encrypted_key\": \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg\",\n  \"tag\": \"XFBoMYUZodetZdvTiFvSkQ\"\n}`,\n\t\t},\n\t}\n\n\tntmpl := len(templates)\n\ttestcases := make([]struct {\n\t\tName     string\n\t\tOptions  []jwe.EncryptOption\n\t\tExpected string\n\t}, ntmpl*2)\n\n\tfor i, tmpl := range templates {\n\t\toptions := make([]jwe.EncryptOption, len(tmpl.Options))\n\t\tcopy(options, tmpl.Options)\n\n\t\tfor j, compression := range []jwa.CompressionAlgorithm{jwa.NoCompress, jwa.Deflate} {\n\t\t\tcompName := compression.String()\n\t\t\tif compName == \"\" {\n\t\t\t\tcompName = \"none\"\n\t\t\t}\n\t\t\ttc := testcases[i+j]\n\t\t\ttc.Name = tmpl.Name + \" (compression=\" + compName + \")\"\n\t\t\ttc.Expected = tmpl.Expected\n\t\t\ttc.Options = append(options, jwe.WithCompress(compression))\n\t\t}\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\toptions := tc.Options\n\t\t\toptions = append(options, jwe.WithKey(jwa.RSA_OAEP, rawkey.PublicKey))\n\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, options...)\n\t\t\tif !assert.NoError(t, err, \"jwe.Encrypt should succeed\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Logf(\"%s\", encrypted)\n\n\t\t\tt.Run(\"WithKey\", func(t *testing.T) {\n\t\t\t\tplaintext, err = jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rawkey))\n\t\t\t\tif !assert.NoError(t, err, \"jwe.Decrypt should succeed\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, payload, string(plaintext), \"jwe.Decrypt should produce the same plaintext\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"WithKeySet\", func(t *testing.T) {\n\t\t\t\tpkJwk, err := jwk.FromRaw(rawkey)\n\t\t\t\tif !assert.NoError(t, err, `jwk.New should succeed`) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Keys are not going to be selected without an algorithm\n\t\t\t\t_ = pkJwk.Set(jwe.AlgorithmKey, jwa.RSA_OAEP)\n\t\t\t\tset := jwk.NewSet()\n\t\t\t\tset.AddKey(pkJwk)\n\n\t\t\t\tvar used interface{}\n\t\t\t\tplaintext, err = jwe.Decrypt(encrypted, jwe.WithKeySet(set, jwe.WithRequireKid(false)), jwe.WithKeyUsed(&used))\n\t\t\t\tif !assert.NoError(t, err, \"jwe.Decrypt should succeed\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, payload, string(plaintext), \"jwe.Decrypt should produce the same plaintext\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !assert.Equal(t, pkJwk, used) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t// Test direct marshaling and unmarshaling\n\tt.Run(\"Marshal/Unmarshal\", func(t *testing.T) {\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, `json.Marshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tm2 := jwe.NewMessage()\n\t\tif !assert.NoError(t, json.Unmarshal(buf, m2), `json.Unmarshal should succeed`) {\n\t\t\tt.Logf(\"%s\", buf)\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, msg, m2, `messages should be the same after roundtrip`) {\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// https://tools.ietf.org/html/rfc7516#appendix-A.1.\nfunc TestRoundtrip_RSAES_OAEP_AES_GCM(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,\n\t\t111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,\n\t\t101, 32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,\n\t\t101, 100, 103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,\n\t\t110, 97, 116, 105, 111, 110, 46,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA_OAEP, &rsaPrivKey.PublicKey))\n\t\tif !assert.NoError(t, err, \"Encrypt should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rsaPrivKey))\n\t\tif !assert.NoError(t, err, \"Decrypt should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted content should match\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestRoundtrip_RSA1_5_A128CBC_HS256(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA1_5, &rsaPrivKey.PublicKey), jwe.WithContentEncryption(jwa.A128CBC_HS256))\n\t\tif !assert.NoError(t, err, \"Encrypt is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA1_5, rsaPrivKey))\n\t\tif !assert.NoError(t, err, \"Decrypt successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted correct plaintext\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// https://tools.ietf.org/html/rfc7516#appendix-A.3. Note that cek is dynamically\n// generated, so the encrypted values will NOT match that of the RFC.\nfunc TestEncode_A128KW_A128CBC_HS256(t *testing.T) {\n\tvar plaintext = []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46,\n\t}\n\tvar sharedkey = []byte{\n\t\t25, 172, 32, 130, 225, 114, 26, 181, 138, 106, 254, 192, 95, 133, 74, 82,\n\t}\n\n\tmax := 100\n\tif testing.Short() {\n\t\tmax = 1\n\t}\n\n\tfor i := 0; i < max; i++ {\n\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.A128KW, sharedkey), jwe.WithContentEncryption(jwa.A128CBC_HS256))\n\t\tif !assert.NoError(t, err, \"Encrypt is successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.A128KW, sharedkey))\n\t\tif !assert.NoError(t, err, \"Decrypt successful\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, plaintext, decrypted, \"Decrypted correct plaintext\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n//nolint:thelper\nfunc testEncodeECDHWithKey(t *testing.T, privkey interface{}, pubkey interface{}) {\n\tplaintext := []byte(\"Lorem ipsum\")\n\n\talgorithms := []jwa.KeyEncryptionAlgorithm{\n\t\tjwa.ECDH_ES,\n\t\tjwa.ECDH_ES_A256KW,\n\t\tjwa.ECDH_ES_A192KW,\n\t\tjwa.ECDH_ES_A128KW,\n\t}\n\n\tfor _, alg := range algorithms {\n\t\talg := alg\n\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(alg, pubkey))\n\t\t\tif !assert.NoError(t, err, \"Encrypt succeeds\") {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = jwe.Parse(encrypted)\n\t\t\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(alg, privkey))\n\t\t\tif !assert.NoError(t, err, \"Decrypt succeeds\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Logf(\"%s\", decrypted)\n\t\t})\n\t}\n}\n\nfunc TestEncode_ECDH(t *testing.T) {\n\tcurves := []elliptic.Curve{\n\t\telliptic.P256(),\n\t\telliptic.P384(),\n\t\telliptic.P521(),\n\t}\n\tfor _, crv := range curves {\n\t\tcrv := crv\n\t\tt.Run(crv.Params().Name, func(t *testing.T) {\n\t\t\tprivkey, err := ecdsa.GenerateKey(crv, rand.Reader)\n\t\t\tif !assert.NoError(t, err, `ecdsa.GenerateKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttestEncodeECDHWithKey(t, privkey, &privkey.PublicKey)\n\t\t})\n\t}\n}\n\nfunc TestEncode_X25519(t *testing.T) {\n\tpubkey, privkey, err := x25519.GenerateKey(rand.Reader)\n\tif !assert.NoError(t, err, `x25519.GenerateKey should succeed`) {\n\t\treturn\n\t}\n\n\ttestEncodeECDHWithKey(t, privkey, pubkey)\n}\n\nfunc Test_GHIssue207(t *testing.T) {\n\tconst plaintext = \"hi\\n\"\n\tvar testcases = []struct {\n\t\tAlgorithm  jwa.KeyEncryptionAlgorithm\n\t\tKey        string\n\t\tData       string\n\t\tThumbprint string\n\t\tName       string\n\t}{\n\t\t{\n\t\t\tName:       `ECDH-ES`,\n\t\t\tKey:        `{\"alg\":\"ECDH-ES\",\"crv\":\"P-521\",\"d\":\"ARxUkIjnB7pjFzM2OIIFcclR-4qbZwv7DoC96cksPKyvVWOkEsZ0CK6deM4AC6G5GClR5TXWMQVC_bNDmfuwPPqF\",\"key_ops\":[\"wrapKey\",\"unwrapKey\"],\"kty\":\"EC\",\"x\":\"ACewmG5j0POUDQw3rIqFQozK_6yXUsfNjiZtWqQOU7MXsSKK9RsRS8ySmeTG14heUpbbnrC9VdYKSOUGkYnYUl2Y\",\"y\":\"ACkXSOma_FP93R3u5uYX7gUOlM0LDkNsij9dVFPbafF8hlfYEnUGit2o-tt7W0Zq3t38jEhpjUoGgM04JDJ6_m0x\"}`,\n\t\t\tData:       `{\"ciphertext\":\"sp0cLt4Rx1p0Ax0Q1OZj7w\",\"header\":{\"alg\":\"ECDH-ES\",\"epk\":{\"crv\":\"P-521\",\"kty\":\"EC\",\"x\":\"APMKQpje5vu39-eS_LX_g15stqbNZ37GgYimW8PZf7d_OOuAygK2YlINYnPoUybrxkoaLRPhbmxc9MBWFdaY8SXx\",\"y\":\"AMpq4DFi6w-pfnprO58CkfX-ncXtJ8fvox2Ej8Ey3ZY1xjVUtbDJCDCjY53snYaNCEjnFQPAn-IkAG90p2Xcm8ut\"}},\"iv\":\"Fjnb5uUWp9euqp1MK_hT4A\",\"protected\":\"eyJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0\",\"tag\":\"6nhiy-vyqwVjpy08jrorTpWqvam66HdKxU36XsE3Z3s\"}`,\n\t\t\tThumbprint: `0_6x6e2sZKeq3ka0QV0PEkJagqg`,\n\t\t},\n\t\t{\n\t\t\tName:       `ECDH-ES+A256KW`,\n\t\t\tKey:        `{\"alg\":\"ECDH-ES+A256KW\",\"crv\":\"P-521\",\"d\":\"AcH8h_ctsMnopTiCH7wiuM-nAb1CNikC0ubcOZQDLYSVEw93h6_D57aD7DLWbjIsVNzn7Qq8P-kRiTYVoH5GTQVg\",\"key_ops\":[\"wrapKey\",\"unwrapKey\"],\"kty\":\"EC\",\"x\":\"AAQoEbNeiG3ExYj9bJLGFn4h_bFjERfIcmpQMW5KWlFhqcXTFg0g8-5YWjdJXdNmO_2EuaKe7zOvEq8dCFCb12-R\",\"y\":\"Ad8E2jp6FSCSd8laERqIt67A2T-MIqQE5301jNYb5SMsCSV1rs1McyvhzHaclYcqTUptoA-rW5kNS9N5124XPHky\"}`,\n\t\t\tData:       `{\"ciphertext\":\"evXmzoQ5TWQvEXdpv9ZCBQ\",\"encrypted_key\":\"ceVsjF-0LhziK75oHRC-C539hlFJMSbub015a3YtIBgCt7c0IRzkzwoOvo_Jf44FXZi0Vd-4fvDjRkZDzx9DcuDd4ASYDLvW\",\"header\":{\"alg\":\"ECDH-ES+A256KW\",\"epk\":{\"crv\":\"P-521\",\"kty\":\"EC\",\"x\":\"Aad7PFl9cct7WcfM3b_LNkhCHfCotW_nRuarX7GACDyyZkr2dd1g6r3rz-8r2-AyOGD9gc2nhrTEjVHT2W7eu65U\",\"y\":\"Ab0Mj6BK8g3Fok6oyFlkvKOyquEVxeeJOlsyXKYBputPxFT5Gljr2FoJdViAxVspoSiw1K5oG1h59UBJgPWG4GQV\"}},\"iv\":\"KsJgq2xyzE1dZi2BM2xf5g\",\"protected\":\"eyJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0\",\"tag\":\"b6m_nW9vfk6xJugm_-Uuj4cbAQh9ECelLc1ZBfO86L0\"}`,\n\t\t\tThumbprint: `G4OtKQL_qr9Q57atNOU6SJnJxB8`,\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\twebKey, err := jwk.ParseKey([]byte(tc.Key))\n\t\t\tif !assert.NoError(t, err, `jwk.ParseKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthumbprint, err := webKey.Thumbprint(crypto.SHA1)\n\t\t\tif !assert.NoError(t, err, `jwk.Thumbprint should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, base64.RawURLEncoding.EncodeToString(thumbprint), tc.Thumbprint, `thumbprints should match`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar key ecdsa.PrivateKey\n\t\t\tif !assert.NoError(t, webKey.Raw(&key), `jwk.Raw should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt([]byte(tc.Data), jwe.WithKeyProvider(jwe.KeyProviderFunc(func(_ context.Context, sink jwe.KeySink, r jwe.Recipient, _ *jwe.Message) error {\n\t\t\t\tsink.Key(r.Headers().Algorithm(), &key)\n\t\t\t\treturn nil\n\t\t\t})))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, string(decrypted), plaintext, `plaintext should match`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\n// tests direct key encryption by encrypting-decrypting a plaintext\nfunc TestEncode_Direct(t *testing.T) {\n\tvar testcases = []struct {\n\t\tAlgorithm jwa.ContentEncryptionAlgorithm\n\t\tKeySize   int // in bytes\n\t}{\n\t\t{jwa.A128CBC_HS256, 32},\n\t\t{jwa.A128GCM, 16},\n\t\t{jwa.A192CBC_HS384, 48},\n\t\t{jwa.A192GCM, 24},\n\t\t{jwa.A256CBC_HS512, 64},\n\t\t{jwa.A256GCM, 32},\n\t}\n\tplaintext := []byte(\"Lorem ipsum\")\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Algorithm.String(), func(t *testing.T) {\n\t\t\tkey := make([]byte, tc.KeySize)\n\t\t\t/*\n\t\t\t\t_, err := rand.Read(key)\n\t\t\t\tif !assert.NoError(t, err, \"Key generation succeeds\") {\n\t\t\t\t\treturn\n\t\t\t\t}*/\n\t\t\tfor n := 0; n < len(key); {\n\t\t\t\tw := copy(key[n:], []byte(`12345678`))\n\t\t\t\tn += w\n\t\t\t}\n\n\t\t\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.DIRECT, key), jwe.WithContentEncryption(tc.Algorithm))\n\t\t\tif !assert.NoError(t, err, `jwe.Encrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.DIRECT, key))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.Equal(t, plaintext, decrypted, `jwe.Decrypt should match input plaintext`)\n\t\t})\n\t}\n}\n\n// Decrypts messages generated by `jose` tool. It helps check compatibility with other jwx implementations.\nfunc TestDecodePredefined_Direct(t *testing.T) {\n\tvar testcases = []struct {\n\t\tAlgorithm  jwa.ContentEncryptionAlgorithm\n\t\tKey        string // generated with 'jose jwk gen -i '{\"alg\":\"A128GCM\"}' -o key.jwk'\n\t\tThumbprint string // generated with 'jose jwk thp -i key.jwk`\n\t\tData       string // generated with 'jose jwe enc -I msg.txt -k key.jwk -o msg.jwe'\n\t}{\n\t\t{\n\t\t\tjwa.A128CBC_HS256,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A128GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A192CBC_HS384,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A192GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A256CBC_HS512,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t\t{\n\t\t\tjwa.A256GCM,\n\t\t\t`{\"alg\":\"A128GCM\",\"k\":\"9hexZKVSV9pZhPNzgXiD8g\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}`,\n\t\t\t`RwW22IemrIJLFwlqZ-OQUe_Lnbo`,\n\t\t\t`{\"ciphertext\":\"FX_px9cuyO_hZfo\",\"encrypted_key\":\"\",\"header\":{\"alg\":\"dir\"},\"iv\":\"Z9CRJCFPtpEI5Pwq\",\"protected\":\"eyJlbmMiOiJBMTI4R0NNIn0\",\"tag\":\"1iq0MNDX40XVtqGYinhUtQ\"}`,\n\t\t},\n\t}\n\tplaintext := \"Lorem ipsum\"\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\tt.Run(tc.Algorithm.String(), func(t *testing.T) {\n\t\t\twebKey, err := jwk.ParseKey([]byte(tc.Key))\n\t\t\tif !assert.NoError(t, err, `jwk.ParseKey should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthumbprint, err := webKey.Thumbprint(crypto.SHA1)\n\t\t\tif !assert.NoError(t, err, `jwk.Thumbprint should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, base64.RawURLEncoding.EncodeToString(thumbprint), tc.Thumbprint, `thumbprints should match`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar key []byte\n\t\t\tif !assert.NoError(t, webKey.Raw(&key), `jwk.Raw should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdecrypted, err := jwe.Decrypt([]byte(tc.Data), jwe.WithKey(jwa.DIRECT, key))\n\t\t\tif !assert.NoError(t, err, `jwe.Decrypt should succeed`) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !assert.Equal(t, plaintext, string(decrypted), `plaintext should match`) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGHIssue230(t *testing.T) {\n\tt.Parallel()\n\n\tconst data = `{\"ciphertext\":\"wko\",\"encrypted_key\":\"\",\"iv\":\"y-wj7nfa-T8XG58z\",\"protected\":\"eyJhbGciOiJkaXIiLCJjbGV2aXMiOnsicGluIjoidHBtMiIsInRwbTIiOnsiaGFzaCI6InNoYTI1NiIsImp3a19wcml2IjoiQU80QUlCSTFRYjQ2SHZXUmNSRHVxRXdoN2ZWc3hSNE91MVhsOHBRX2hMMTlPeUc3QUJDVG80S2RqWEZYcEFUOWtLeWptVVJPOTVBaXc4U1o4MGZXRmtDMGdEazJLTXEtamJTZU1wcFZFaFJaWEpxQmhWNXVGZ1V0T0J4eUFjRzFZRjhFMW5Ob1dPWk9Eek5EUkRrOE1ZVWZrWVNpS0ZKb2pPZ0UxSjRIZkRoM0lBelY2MFR6V2NWcXJ0QnlwX2EyZ1V2a0JqcGpTeVF2Nmc2amJMSXpEaG10VnZLMmxDazhlMjUzdG1MSDNPQWk0Q0tZcWFZY0tjTTltSTdTRXBpVldlSjZZVFBEdmtORndpa0tNRjE3czVYQUlFUjZpczNNTVBpNkZTOWQ3ZmdMV25hUkpabDVNNUJDMldxN2NsVmYiLCJqd2tfcHViIjoiQUM0QUNBQUxBQUFFMGdBQUFCQUFJREpTSVhRSVVocjVPaDVkNXZWaWVGUDBmZG9pVFd3S1RicXJRRVRhVmx4QyIsImtleSI6ImVjYyJ9fSwiZW5jIjoiQTI1NkdDTSJ9\",\"tag\":\"lir7v9YbCCZQKf5-yJ0BTQ\"}`\n\n\tmsg, err := jwe.Parse([]byte(data))\n\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\treturn\n\t}\n\n\tcompact, err := jwe.Compact(msg)\n\tif !assert.NoError(t, err, `jwe.Compact should succeed`) {\n\t\treturn\n\t}\n\n\tmsg2, err := jwe.Parse(compact)\n\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, msg, msg2, `data -> msg -> compact -> msg2 produces msg == msg2`) {\n\t\tt.Logf(\"msg -> %#v\", msg)\n\t\tt.Logf(\"msg2 -> %#v\", msg2)\n\t\treturn\n\t}\n}\n\nfunc TestReadFile(t *testing.T) {\n\tconst s = `eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ`\n\n\tf, err := os.CreateTemp(\"\", \"test-read-file-*.jwe\")\n\tif !assert.NoError(t, err, `os.CreateTemp should succeed`) {\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tfmt.Fprintf(f, \"%s\", s)\n\n\tif _, err := jwe.ReadFile(f.Name()); !assert.NoError(t, err, `jwe.ReadFile should succeed`) {\n\t\treturn\n\t}\n}\n\nfunc TestCustomField(t *testing.T) {\n\t// XXX has global effect!!!\n\tjwe.RegisterCustomField(`x-birthday`, time.Time{})\n\tdefer jwe.RegisterCustomField(`x-birthday`, nil)\n\n\texpected := time.Date(2015, 11, 4, 5, 12, 52, 0, time.UTC)\n\tbdaybytes, _ := expected.MarshalText() // RFC3339\n\n\tplaintext := []byte(\"Hello, World!\")\n\trsakey, err := jwxtest.GenerateRsaJwk()\n\tif !assert.NoError(t, err, `jwxtest.GenerateRsaJwk() should succeed`) {\n\t\treturn\n\t}\n\tpubkey, err := jwk.PublicKeyOf(rsakey)\n\tif !assert.NoError(t, err, `jwk.PublicKeyOf() should succeed`) {\n\t\treturn\n\t}\n\n\tprotected := jwe.NewHeaders()\n\tprotected.Set(`x-birthday`, string(bdaybytes))\n\n\tencrypted, err := jwe.Encrypt(plaintext, jwe.WithKey(jwa.RSA_OAEP, pubkey), jwe.WithProtectedHeaders(protected))\n\tif !assert.NoError(t, err, `jwe.Encrypt should succeed`) {\n\t\treturn\n\t}\n\n\tt.Run(\"jwe.Parse + json.Unmarshal\", func(t *testing.T) {\n\t\tmsg, err := jwe.Parse(encrypted)\n\t\tif !assert.NoError(t, err, `jwe.Parse should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tv, ok := msg.ProtectedHeaders().Get(`x-birthday`)\n\t\tif !assert.True(t, ok, `msg.ProtectedHeaders().Get(\"x-birthday\") should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, expected, v, `values should match`) {\n\t\t\treturn\n\t\t}\n\n\t\t// Create JSON from jwe.Message\n\t\tbuf, err := json.Marshal(msg)\n\t\tif !assert.NoError(t, err, `json.Marshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tvar msg2 jwe.Message\n\t\tif !assert.NoError(t, json.Unmarshal(buf, &msg2), `json.Unmarshal should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tv, ok = msg2.ProtectedHeaders().Get(`x-birthday`)\n\t\tif !assert.True(t, ok, `msg2.ProtectedHeaders().Get(\"x-birthday\") should succeed`) {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, expected, v, `values should match`) {\n\t\t\treturn\n\t\t}\n\t})\n}\n\nfunc TestGH554(t *testing.T) {\n\tconst keyID = `very-secret-key`\n\tconst plaintext = `hello world!`\n\tprivkey, err := jwxtest.GenerateEcdsaJwk()\n\tif !assert.NoError(t, err, `jwxtest.GenerateEcdsaJwk() should succeed`) {\n\t\treturn\n\t}\n\n\t_ = privkey.Set(jwk.KeyIDKey, keyID)\n\n\tpubkey, err := jwk.PublicKeyOf(privkey)\n\tif !assert.NoError(t, err, `jwk.PublicKeyOf() should succeed`) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, keyID, pubkey.KeyID(), `key ID should match`) {\n\t\treturn\n\t}\n\n\tencrypted, err := jwe.Encrypt([]byte(plaintext), jwe.WithKey(jwa.ECDH_ES, pubkey))\n\tif !assert.NoError(t, err, `jwk.Encrypt() should succeed`) {\n\t\treturn\n\t}\n\n\tmsg, err := jwe.Parse(encrypted)\n\tif !assert.NoError(t, err, `jwe.Parse() should succeed`) {\n\t\treturn\n\t}\n\n\trecipients := msg.Recipients()\n\n\t// The epk must have the same key ID as the original\n\tkid := recipients[0].Headers().KeyID()\n\tif !assert.Equal(t, keyID, kid, `key ID in epk should match`) {\n\t\treturn\n\t}\n}\n\nfunc TestGH803(t *testing.T) {\n\tprivateKey, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\trequire.NoError(t, err, `ecdsa.GenerateKey should succeed`)\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\tapu := []byte(`Alice`)\n\tapv := []byte(`Bob`)\n\thdrs := jwe.NewHeaders()\n\thdrs.Set(jwe.AgreementPartyUInfoKey, apu)\n\thdrs.Set(jwe.AgreementPartyVInfoKey, apv)\n\tencrypted, err := jwe.Encrypt(\n\t\tpayload,\n\t\tjwe.WithJSON(),\n\t\tjwe.WithKey(jwa.ECDH_ES, privateKey.PublicKey, jwe.WithPerRecipientHeaders(hdrs)),\n\t\tjwe.WithContentEncryption(jwa.A128GCM),\n\t)\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\n\tvar msg jwe.Message\n\tdecrypted, err := jwe.Decrypt(\n\t\tencrypted,\n\t\tjwe.WithKey(jwa.ECDH_ES, privateKey),\n\t\tjwe.WithMessage(&msg),\n\t)\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\trequire.Equal(t, payload, decrypted, `decrypt messages match`)\n\trequire.Equal(t, apu, msg.ProtectedHeaders().AgreementPartyUInfo())\n\trequire.Equal(t, apv, msg.ProtectedHeaders().AgreementPartyVInfo())\n}\n\nfunc TestGH840(t *testing.T) {\n\t// Go 1.19+ panics if elliptic curve operations are called against\n\t// a point that's _NOT_ on the curve\n\tuntrustedJWK := []byte(`{\n\t\t\"kty\": \"EC\",\n\t\t\"crv\": \"P-256\",\n\t\t\"x\": \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqx7D4\",\n\t\t\"y\": \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n\t\t\"d\": \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\"\n\t}`)\n\n\tprivkey, err := jwk.ParseKey(untrustedJWK)\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubkey, err := privkey.PublicKey()\n\trequire.NoError(t, err, `privkey.PublicKey should succeed`)\n\n\tconst payload = `Lorem ipsum`\n\t_, err = jwe.Encrypt([]byte(payload), jwe.WithKey(jwa.ECDH_ES_A128KW, pubkey))\n\trequire.Error(t, err, `jwe.Encrypt should fail (instead of panic)`)\n}\n\ntype dummyKeyEncrypterDecrypter struct {\n\tkey []byte\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) DecryptKey(_ jwa.KeyEncryptionAlgorithm, cek []byte, _ jwe.Recipient, _ *jwe.Message) ([]byte, error) {\n\treturn bytes.TrimSuffix(cek, kd.key), nil\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) Algorithm() jwa.KeyEncryptionAlgorithm {\n\treturn jwa.A128GCMKW\n}\n\nfunc (kd *dummyKeyEncrypterDecrypter) EncryptKey(key []byte) ([]byte, error) {\n\treturn append(key, kd.key...), nil\n}\n\nvar _ jwe.KeyEncrypter = (*dummyKeyEncrypterDecrypter)(nil)\n\nfunc TestGH924(t *testing.T) {\n\tsharedKey := []byte(\"abra-kadabra\")\n\n\tked := &dummyKeyEncrypterDecrypter{key: sharedKey}\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\tencrypted, err := jwe.Encrypt(\n\t\tpayload,\n\t\tjwe.WithJSON(),\n\t\tjwe.WithKey(jwa.A128GCMKW, ked),\n\t\tjwe.WithContentEncryption(jwa.A128GCM),\n\t)\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\n\tvar msg jwe.Message\n\tdecrypted, err := jwe.Decrypt(\n\t\tencrypted,\n\t\tjwe.WithKey(jwa.A128GCMKW, ked),\n\t\tjwe.WithMessage(&msg),\n\t)\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\trequire.Equal(t, payload, decrypted, `decrypt messages match`)\n}\n\nfunc TestGH1001(t *testing.T) {\n\trawKey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaKey should succeed`)\n\n\tencrypted, err := jwe.Encrypt([]byte(\"Lorem Ipsum\"), jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.NoError(t, err, `jwe.Encrypt should succeed`)\n\tvar cek []byte\n\tdecrypted, err := jwe.Decrypt(encrypted, jwe.WithKey(jwa.RSA_OAEP, rawKey), jwe.WithCEK(&cek))\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\n\trequire.Equal(t, \"Lorem Ipsum\", string(decrypted), `decrypted message should match`)\n\trequire.NotNil(t, cek, `cek should not be nil`)\n\n\treEncrypted, err := jwe.EncryptStatic([]byte(\"Lorem Ipsum\"), cek, jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.NoError(t, err, `jwe.EncryptStatic should succeed`)\n\n\t// sanity. empty CEKs should be rejected\n\t_, err = jwe.EncryptStatic([]byte(\"Lorem Ipsum\"), nil, jwe.WithKey(jwa.RSA_OAEP, rawKey.PublicKey))\n\trequire.Error(t, err, `jwe.Encryptstatic should fail with empty cek`)\n\n\tcek = []byte(nil)\n\tdecrypted, err = jwe.Decrypt(reEncrypted, jwe.WithKey(jwa.RSA_OAEP, rawKey), jwe.WithCEK(&cek))\n\trequire.NoError(t, err, `jwe.Decrypt should succeed`)\n\n\trequire.Equal(t, \"Lorem Ipsum\", string(decrypted), `decrypted message should match`)\n\trequire.NotNil(t, cek, `cek should not be nil`)\n}\n\nfunc TestGHSA_7f9x_gw85_8grf(t *testing.T) {\n\ttoken := []byte(\"eyJhbGciOiJQQkVTMi1IUzI1NitBMTI4S1ciLCJlbmMiOiJBMjU2R0NNIiwicDJjIjoyMDAwMDAwMDAwLCJwMnMiOiJNNzczSnlmV2xlX2FsSXNrc0NOTU9BIn0=.S8B1kXdIR7BM6i_TaGsgqEOxU-1Sgdakp4mHq7UVhn-_REzOiGz2gg.gU_LfzhBXtQdwYjh.9QUIS-RWkLc.m9TudmzUoCzDhHsGGfzmCA\")\n\tkey, err := jwk.FromRaw([]byte(`abcdefg`))\n\trequire.NoError(t, err, `jwk.FromRaw should succeed`)\n\n\t{\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\tdone := make(chan struct{})\n\t\tgo func(t *testing.T, done chan struct{}) {\n\t\t\t_, err := jwe.Decrypt(token, jwe.WithKey(jwa.PBES2_HS256_A128KW, key))\n\t\t\trequire.Error(t, err, `jwe.Decrypt should fail`)\n\t\t\tclose(done)\n\t\t}(t, done)\n\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-ctx.Done():\n\t\t\trequire.Fail(t, \"jwe.Decrypt should not block\")\n\t\t}\n\t}\n\n\t// NOTE: HAS GLOBAL EFFECT\n\t// Should allow for timeout to occur\n\tjwe.Settings(jwe.WithMaxPBES2Count(100000000000000000))\n\n\t// put it back to normal after the test\n\tdefer jwe.Settings(jwe.WithMaxPBES2Count(10000))\n\t{\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\tdone := make(chan struct{})\n\t\tgo func(t *testing.T, done chan struct{}) {\n\t\t\t_, _ = jwe.Decrypt(token, jwe.WithKey(jwa.PBES2_HS256_A128KW, key))\n\t\t\tclose(done)\n\t\t}(t, done)\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\trequire.Fail(t, \"jwe.Decrypt should block\")\n\t\tcase <-ctx.Done():\n\t\t\t// timeout occurred as it should\n\t\t}\n\t}\n}\n", "package_name: jwe\noutput: jwe/options_gen.go\ninterfaces:\n  - name: GlobalOption\n    comment: |\n      GlobalOption describes options that changes global settings for this package\n  - name: CompactOption\n    comment: |\n      CompactOption describes options that can be passed to `jwe.Compact`\n  - name: DecryptOption\n    comment: |\n      DecryptOption describes options that can be passed to `jwe.Decrypt`\n  - name: EncryptOption\n    comment: |\n      EncryptOption describes options that can be passed to `jwe.Encrypt`\n  - name: EncryptDecryptOption\n    methods:\n      - encryptOption\n      - decryptOption\n    comment: |\n      EncryptDecryptOption describes options that can be passed to either `jwe.Encrypt` or `jwe.Decrypt`\n  - name: WithJSONSuboption\n    concrete_type: withJSONSuboption\n    comment: |\n      JSONSuboption describes suboptions that can be passed to `jwe.WithJSON()` option\n  - name: WithKeySetSuboption\n    comment: |\n      WithKeySetSuboption is a suboption passed to the WithKeySet() option\n  - name: ParseOption\n    methods:\n      - readFileOption\n    comment: |\n      ReadFileOption is a type of `Option` that can be passed to `jwe.Parse`\n  - name: ReadFileOption\n    comment: |\n      ReadFileOption is a type of `Option` that can be passed to `jwe.ReadFile`\noptions:\n  - ident: Key\n    skip_option: true\n  - ident: Pretty\n    skip_option: true\n  - ident: ProtectedHeaders\n    skip_option: true\n  - ident: PerRecipientHeaders\n    skip_option: true\n  - ident: KeyProvider\n    interface: DecryptOption\n    argument_type: KeyProvider\n  - ident: Serialization\n    option_name: WithCompact\n    interface: EncryptOption\n    constant_value: fmtCompact\n    comment: |\n      WithCompact specifies that the result of `jwe.Encrypt()` is serialized in\n      compact format.\n      \n      By default `jwe.Encrypt()` will opt to use compact format, so you usually\n      do not need to specify this option other than to be explicit about it\n  - ident: Compress\n    interface: EncryptOption\n    argument_type: jwa.CompressionAlgorithm\n    comment: |\n      WithCompress specifies the compression algorithm to use when encrypting\n      a payload using `jwe.Encrypt` (Yes, we know it can only be \"\" or \"DEF\",\n      but the way the specification is written it could allow for more options,\n      and therefore this option takes an argument)\n  - ident: ContentEncryptionAlgorithm\n    interface: EncryptOption\n    option_name: WithContentEncryption\n    argument_type: jwa.ContentEncryptionAlgorithm\n    comment: |\n      WithContentEncryptionAlgorithm specifies the algorithm to encrypt the\n      JWE message content with. If not provided, `jwa.A256GCM` is used.\n  - ident: Message\n    interface: DecryptOption\n    argument_type: '*Message'\n    comment: |\n      WithMessage provides a message object to be populated by `jwe.Decrpt`\n      Using this option allows you to decrypt AND obtain the `jwe.Message`\n      in one go.\n      \n      Note that you should NOT be using the message object for anything other\n      than inspecting its contents. Particularly, do not expect the message\n      reliable when you call `Decrypt` on it. `(jwe.Message).Decrypt` is\n      slated to be deprecated in the next major version.\n  - ident: RequireKid\n    interface: WithKeySetSuboption\n    argument_type: bool\n    comment: |\n      WithrequiredKid specifies whether the keys in the jwk.Set should\n      only be matched if the target JWE message's Key ID and the Key ID\n      in the given key matches.\n  - ident: Pretty\n    interface: WithJSONSuboption\n    argument_type: bool\n    comment: |\n      WithPretty specifies whether the JSON output should be formatted and\n      indented\n  - ident: MergeProtectedHeaders\n    interface: EncryptOption\n    argument_type: bool\n    comment: |\n      WithMergeProtectedHeaders specify that when given multiple headers\n      as options to `jwe.Encrypt`, these headers should be merged instead\n      of overwritten\n  - ident: FS\n    interface: ReadFileOption\n    argument_type: fs.FS\n    comment: |\n      WithFS specifies the source `fs.FS` object to read the file from.\n  - ident: KeyUsed\n    interface: DecryptOption\n    argument_type: 'interface{}'\n    comment: |\n      WithKeyUsed allows you to specify the `jwe.Decrypt()` function to\n      return the key used for decryption. This may be useful when\n      you specify multiple key sources or if you pass a `jwk.Set`\n      and you want to know which key was successful at decrypting the\n      signature.\n      \n      `v` must be a pointer to an empty `interface{}`. Do not use\n      `jwk.Key` here unless you are 100% sure that all keys that you\n      have provided are instances of `jwk.Key` (remember that the\n      jwx API allows users to specify a raw key such as *rsa.PublicKey)\n  - ident: CEK\n    interface: DecryptOption\n    argument_type: '*[]byte'\n    comment: |\n      WithCEK allows users to specify a variable to store the CEK used in the\n      message upon successful decryption. The variable must be a pointer to\n      a byte slice, and it will only be populated if the decryption is successful.\n      \n      This option is currently considered EXPERIMENTAL, and is subject to\n      future changes across minor/micro versions.\n  - ident: MaxPBES2Count\n    interface: GlobalOption\n    argument_type: int\n    comment: |\n      WithMaxPBES2Count specifies the maximum number of PBES2 iterations\n      to use when decrypting a message. If not specified, the default\n      value of 10,000 is used.", "// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.\n\npackage jwe\n\nimport (\n\t\"io/fs\"\n\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/option\"\n)\n\ntype Option = option.Interface\n\n// CompactOption describes options that can be passed to `jwe.Compact`\ntype CompactOption interface {\n\tOption\n\tcompactOption()\n}\n\ntype compactOption struct {\n\tOption\n}\n\nfunc (*compactOption) compactOption() {}\n\n// DecryptOption describes options that can be passed to `jwe.Decrypt`\ntype DecryptOption interface {\n\tOption\n\tdecryptOption()\n}\n\ntype decryptOption struct {\n\tOption\n}\n\nfunc (*decryptOption) decryptOption() {}\n\n// EncryptDecryptOption describes options that can be passed to either `jwe.Encrypt` or `jwe.Decrypt`\ntype EncryptDecryptOption interface {\n\tOption\n\tencryptOption()\n\tdecryptOption()\n}\n\ntype encryptDecryptOption struct {\n\tOption\n}\n\nfunc (*encryptDecryptOption) encryptOption() {}\n\nfunc (*encryptDecryptOption) decryptOption() {}\n\n// EncryptOption describes options that can be passed to `jwe.Encrypt`\ntype EncryptOption interface {\n\tOption\n\tencryptOption()\n}\n\ntype encryptOption struct {\n\tOption\n}\n\nfunc (*encryptOption) encryptOption() {}\n\n// GlobalOption describes options that changes global settings for this package\ntype GlobalOption interface {\n\tOption\n\tglobalOption()\n}\n\ntype globalOption struct {\n\tOption\n}\n\nfunc (*globalOption) globalOption() {}\n\n// ReadFileOption is a type of `Option` that can be passed to `jwe.Parse`\ntype ParseOption interface {\n\tOption\n\treadFileOption()\n}\n\ntype parseOption struct {\n\tOption\n}\n\nfunc (*parseOption) readFileOption() {}\n\n// ReadFileOption is a type of `Option` that can be passed to `jwe.ReadFile`\ntype ReadFileOption interface {\n\tOption\n\treadFileOption()\n}\n\ntype readFileOption struct {\n\tOption\n}\n\nfunc (*readFileOption) readFileOption() {}\n\n// JSONSuboption describes suboptions that can be passed to `jwe.WithJSON()` option\ntype WithJSONSuboption interface {\n\tOption\n\twithJSONSuboption()\n}\n\ntype withJSONSuboption struct {\n\tOption\n}\n\nfunc (*withJSONSuboption) withJSONSuboption() {}\n\n// WithKeySetSuboption is a suboption passed to the WithKeySet() option\ntype WithKeySetSuboption interface {\n\tOption\n\twithKeySetSuboption()\n}\n\ntype withKeySetSuboption struct {\n\tOption\n}\n\nfunc (*withKeySetSuboption) withKeySetSuboption() {}\n\ntype identCEK struct{}\ntype identCompress struct{}\ntype identContentEncryptionAlgorithm struct{}\ntype identFS struct{}\ntype identKey struct{}\ntype identKeyProvider struct{}\ntype identKeyUsed struct{}\ntype identMaxPBES2Count struct{}\ntype identMergeProtectedHeaders struct{}\ntype identMessage struct{}\ntype identPerRecipientHeaders struct{}\ntype identPretty struct{}\ntype identProtectedHeaders struct{}\ntype identRequireKid struct{}\ntype identSerialization struct{}\n\nfunc (identCEK) String() string {\n\treturn \"WithCEK\"\n}\n\nfunc (identCompress) String() string {\n\treturn \"WithCompress\"\n}\n\nfunc (identContentEncryptionAlgorithm) String() string {\n\treturn \"WithContentEncryption\"\n}\n\nfunc (identFS) String() string {\n\treturn \"WithFS\"\n}\n\nfunc (identKey) String() string {\n\treturn \"WithKey\"\n}\n\nfunc (identKeyProvider) String() string {\n\treturn \"WithKeyProvider\"\n}\n\nfunc (identKeyUsed) String() string {\n\treturn \"WithKeyUsed\"\n}\n\nfunc (identMaxPBES2Count) String() string {\n\treturn \"WithMaxPBES2Count\"\n}\n\nfunc (identMergeProtectedHeaders) String() string {\n\treturn \"WithMergeProtectedHeaders\"\n}\n\nfunc (identMessage) String() string {\n\treturn \"WithMessage\"\n}\n\nfunc (identPerRecipientHeaders) String() string {\n\treturn \"WithPerRecipientHeaders\"\n}\n\nfunc (identPretty) String() string {\n\treturn \"WithPretty\"\n}\n\nfunc (identProtectedHeaders) String() string {\n\treturn \"WithProtectedHeaders\"\n}\n\nfunc (identRequireKid) String() string {\n\treturn \"WithRequireKid\"\n}\n\nfunc (identSerialization) String() string {\n\treturn \"WithSerialization\"\n}\n\n// WithCEK allows users to specify a variable to store the CEK used in the\n// message upon successful decryption. The variable must be a pointer to\n// a byte slice, and it will only be populated if the decryption is successful.\n//\n// This option is currently considered EXPERIMENTAL, and is subject to\n// future changes across minor/micro versions.\nfunc WithCEK(v *[]byte) DecryptOption {\n\treturn &decryptOption{option.New(identCEK{}, v)}\n}\n\n// WithCompress specifies the compression algorithm to use when encrypting\n// a payload using `jwe.Encrypt` (Yes, we know it can only be \"\" or \"DEF\",\n// but the way the specification is written it could allow for more options,\n// and therefore this option takes an argument)\nfunc WithCompress(v jwa.CompressionAlgorithm) EncryptOption {\n\treturn &encryptOption{option.New(identCompress{}, v)}\n}\n\n// WithContentEncryptionAlgorithm specifies the algorithm to encrypt the\n// JWE message content with. If not provided, `jwa.A256GCM` is used.\nfunc WithContentEncryption(v jwa.ContentEncryptionAlgorithm) EncryptOption {\n\treturn &encryptOption{option.New(identContentEncryptionAlgorithm{}, v)}\n}\n\n// WithFS specifies the source `fs.FS` object to read the file from.\nfunc WithFS(v fs.FS) ReadFileOption {\n\treturn &readFileOption{option.New(identFS{}, v)}\n}\n\nfunc WithKeyProvider(v KeyProvider) DecryptOption {\n\treturn &decryptOption{option.New(identKeyProvider{}, v)}\n}\n\n// WithKeyUsed allows you to specify the `jwe.Decrypt()` function to\n// return the key used for decryption. This may be useful when\n// you specify multiple key sources or if you pass a `jwk.Set`\n// and you want to know which key was successful at decrypting the\n// signature.\n//\n// `v` must be a pointer to an empty `interface{}`. Do not use\n// `jwk.Key` here unless you are 100% sure that all keys that you\n// have provided are instances of `jwk.Key` (remember that the\n// jwx API allows users to specify a raw key such as *rsa.PublicKey)\nfunc WithKeyUsed(v interface{}) DecryptOption {\n\treturn &decryptOption{option.New(identKeyUsed{}, v)}\n}\n\n// WithMaxPBES2Count specifies the maximum number of PBES2 iterations\n// to use when decrypting a message. If not specified, the default\n// value of 10,000 is used.\nfunc WithMaxPBES2Count(v int) GlobalOption {\n\treturn &globalOption{option.New(identMaxPBES2Count{}, v)}\n}\n\n// WithMergeProtectedHeaders specify that when given multiple headers\n// as options to `jwe.Encrypt`, these headers should be merged instead\n// of overwritten\nfunc WithMergeProtectedHeaders(v bool) EncryptOption {\n\treturn &encryptOption{option.New(identMergeProtectedHeaders{}, v)}\n}\n\n// WithMessage provides a message object to be populated by `jwe.Decrpt`\n// Using this option allows you to decrypt AND obtain the `jwe.Message`\n// in one go.\n//\n// Note that you should NOT be using the message object for anything other\n// than inspecting its contents. Particularly, do not expect the message\n// reliable when you call `Decrypt` on it. `(jwe.Message).Decrypt` is\n// slated to be deprecated in the next major version.\nfunc WithMessage(v *Message) DecryptOption {\n\treturn &decryptOption{option.New(identMessage{}, v)}\n}\n\n// WithPretty specifies whether the JSON output should be formatted and\n// indented\nfunc WithPretty(v bool) WithJSONSuboption {\n\treturn &withJSONSuboption{option.New(identPretty{}, v)}\n}\n\n// WithrequiredKid specifies whether the keys in the jwk.Set should\n// only be matched if the target JWE message's Key ID and the Key ID\n// in the given key matches.\nfunc WithRequireKid(v bool) WithKeySetSuboption {\n\treturn &withKeySetSuboption{option.New(identRequireKid{}, v)}\n}\n\n// WithCompact specifies that the result of `jwe.Encrypt()` is serialized in\n// compact format.\n//\n// By default `jwe.Encrypt()` will opt to use compact format, so you usually\n// do not need to specify this option other than to be explicit about it\nfunc WithCompact() EncryptOption {\n\treturn &encryptOption{option.New(identSerialization{}, fmtCompact)}\n}\n", "// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.\n\npackage jwe\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestOptionIdent(t *testing.T) {\n\trequire.Equal(t, \"WithCEK\", identCEK{}.String())\n\trequire.Equal(t, \"WithCompress\", identCompress{}.String())\n\trequire.Equal(t, \"WithContentEncryption\", identContentEncryptionAlgorithm{}.String())\n\trequire.Equal(t, \"WithFS\", identFS{}.String())\n\trequire.Equal(t, \"WithKey\", identKey{}.String())\n\trequire.Equal(t, \"WithKeyProvider\", identKeyProvider{}.String())\n\trequire.Equal(t, \"WithKeyUsed\", identKeyUsed{}.String())\n\trequire.Equal(t, \"WithMaxPBES2Count\", identMaxPBES2Count{}.String())\n\trequire.Equal(t, \"WithMergeProtectedHeaders\", identMergeProtectedHeaders{}.String())\n\trequire.Equal(t, \"WithMessage\", identMessage{}.String())\n\trequire.Equal(t, \"WithPerRecipientHeaders\", identPerRecipientHeaders{}.String())\n\trequire.Equal(t, \"WithPretty\", identPretty{}.String())\n\trequire.Equal(t, \"WithProtectedHeaders\", identProtectedHeaders{}.String())\n\trequire.Equal(t, \"WithRequireKid\", identRequireKid{}.String())\n\trequire.Equal(t, \"WithSerialization\", identSerialization{}.String())\n}\n"], "filenames": ["Changes", "jwe/jwe.go", "jwe/jwe_test.go", "jwe/options.yaml", "jwe/options_gen.go", "jwe/options_gen_test.go"], "buggy_code_start_loc": [5, 12, 913, 3, 63, 18], "buggy_code_end_loc": [5, 704, 913, 131, 230, 18], "fixing_code_start_loc": [6, 13, 914, 4, 64, 19], "fixing_code_end_loc": [15, 726, 962, 142, 255, 20], "type": "CWE-400", "message": "lestrrat-go/jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. A p2c parameter set too high in JWE's algorithm PBES2-* could lead to a denial of service. The JWE key management algorithms based on PBKDF2 require a JOSE Header Parameter called p2c (PBES2 Count). This parameter dictates the number of PBKDF2 iterations needed to derive a CEK wrapping key. Its primary purpose is to intentionally slow down the key derivation function, making password brute-force and dictionary attacks more resource- intensive. Therefore, if an attacker sets the p2c parameter in JWE to a very large number, it can cause a lot of computational consumption, resulting in a denial of service. This vulnerability has been addressed in commit `64f2a229b` which has been included in release version 1.2.27 and 2.0.18. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-49290", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-05T00:15:09.190", "lastModified": "2024-03-04T22:59:00.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lestrrat-go/jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. A p2c parameter set too high in JWE's algorithm PBES2-* could lead to a denial of service. The JWE key management algorithms based on PBKDF2 require a JOSE Header Parameter called p2c (PBES2 Count). This parameter dictates the number of PBKDF2 iterations needed to derive a CEK wrapping key. Its primary purpose is to intentionally slow down the key derivation function, making password brute-force and dictionary attacks more resource- intensive. Therefore, if an attacker sets the p2c parameter in JWE to a very large number, it can cause a lot of computational consumption, resulting in a denial of service. This vulnerability has been addressed in commit `64f2a229b` which has been included in release version 1.2.27 and 2.0.18. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "lestrrat-go/jwx es un m\u00f3dulo Go que implementa varias tecnolog\u00edas JWx (JWA/JWE/JWK/JWS/JWT, tambi\u00e9n conocidas como JOSE). Un par\u00e1metro p2c establecido demasiado alto en el algoritmo PBES2-* de JWE podr\u00eda provocar una denegaci\u00f3n de servicio. Los algoritmos de gesti\u00f3n de claves JWE basados en PBKDF2 requieren un par\u00e1metro de encabezado JOSE llamado p2c (PBES2 Count). Este par\u00e1metro dicta el n\u00famero de iteraciones de PBKDF2 necesarias para derivar una clave de envoltura CEK. Su objetivo principal es ralentizar intencionalmente la funci\u00f3n de derivaci\u00f3n de claves, haciendo que los ataques de fuerza bruta a contrase\u00f1as y de diccionario requieran m\u00e1s recursos. Por lo tanto, si un atacante establece el par\u00e1metro p2c en JWE en un n\u00famero muy grande, puede provocar un gran consumo computacional, lo que resultar\u00e1 en una denegaci\u00f3n de servicio. Esta vulnerabilidad se solucion\u00f3 en el commit `64f2a229b` que se incluy\u00f3 en las versiones 1.2.27 y 2.0.18. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lestrrat-go:jwx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.27", "matchCriteriaId": "D883F8E3-02A2-4BC4-ADB3-F420624DD720"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lestrrat-go:jwx:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.18", "matchCriteriaId": "566A6052-A735-4FDB-975D-47C594210E70"}]}]}], "references": [{"url": "https://github.com/lestrrat-go/jwx/commit/64f2a229b8e18605f47361d292b526bdc4aee01c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-7f9x-gw85-8grf", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lestrrat-go/jwx/commit/64f2a229b8e18605f47361d292b526bdc4aee01c"}}