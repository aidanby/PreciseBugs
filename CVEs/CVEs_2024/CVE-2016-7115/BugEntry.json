{"buggy_code": ["/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _BSD_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#if defined(__APPLE__)\n# include <libkern/OSByteOrder.h>\n# define htole16 OSSwapHostToLittleInt16\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <net/ethernet.h>\n#else\n#include <netinet/ether.h>\n#endif\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <string.h>\n#ifdef __linux__\n#include <linux/if_ether.h>\n#include <sys/mman.h>\n#endif\n#include \"md5.h\"\n#include \"protocol.h\"\n#include \"console.h\"\n#include \"interfaces.h\"\n#include \"config.h\"\n#include \"mactelnet.h\"\n#include \"mndp.h\"\n#include \"autologin.h\"\n#include \"utlist.h\"\n\n#define PROGRAM_NAME \"MAC-Telnet\"\n\n#define _(String) gettext (String)\n\nstatic int sockfd = 0;\nstatic int insockfd;\n\nstatic unsigned int outcounter = 0;\nstatic long incounter = -1;\nstatic int sessionkey = 0;\nstatic int running = 1;\n\nstatic unsigned char use_raw_socket = 0;\nstatic unsigned char terminal_mode = 0;\n\nstatic unsigned char srcmac[ETH_ALEN];\nstatic unsigned char dstmac[ETH_ALEN];\n\nstatic struct in_addr sourceip; \nstatic struct in_addr destip;\nstatic int sourceport;\n\nstatic int connect_timeout = CONNECT_TIMEOUT;\nstatic char run_mndp = 0;\nstatic int mndp_timeout = 0;\n\nstatic int is_a_tty = 1;\nstatic int quiet_mode = 0;\nstatic int batch_mode = 0;\nstatic int no_autologin = 0;\n\nstatic char autologin_path[255];\n\nstatic int keepalive_counter = 0;\n\nstatic unsigned char pass_salt[17];\nstatic char username[MT_MNDP_MAX_STRING_SIZE];\nstatic char password[MT_MNDP_MAX_STRING_SIZE];\nstatic char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];\n\nstruct net_interface *interfaces=NULL;\nstruct net_interface *active_interface;\n\n/* Protocol data direction */\nunsigned char mt_direction_fromserver = 0;\n\nstatic unsigned int send_socket;\n\nstatic int handle_packet(unsigned char *data, int data_len);\n\nstatic void print_version() {\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\n}\n\nvoid drop_privileges(char *username) {\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\n\tif (user == NULL) {\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\n\t\texit(1);\n\t}\n\tif (getuid() == 0) {\n\t\t/* process is running as root, drop privileges */\n\t\tif (setgid(user->pw_gid) != 0) {\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tif (setuid(user->pw_uid) != 0) {\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/* Verify if the privileges were developed. */\n\t\tif (setuid(0) != -1) {\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic int send_udp(struct mt_packet *packet, int retransmit) {\n\tint sent_bytes;\n\n\t/* Clear keepalive counter */\n\tkeepalive_counter = 0;\n\n\tif (!use_raw_socket) {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t} else {\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\n\t}\n\n\t/* \n\t * Retransmit packet if no data is received within\n\t * retransmit_intervals milliseconds.\n\t */\n\tif (retransmit) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\n\t\t\tfd_set read_fds;\n\t\t\tint reads;\n\t\t\tstruct timeval timeout;\n\t\t\tint interval = retransmit_intervals[i] * 1000;\n\n\t\t\t/* Init select */\n\t\t\tFD_ZERO(&read_fds);\n\t\t\tFD_SET(insockfd, &read_fds);\n\t\t\ttimeout.tv_sec = 0;\n\t\t\ttimeout.tv_usec = interval;\n\n\t\t\t/* Wait for data or timeout */\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tint result;\n\n\t\t\t\tbzero(buff, sizeof(buff));\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\n\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\n\t\t\t\t\treturn sent_bytes;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Retransmit */\n\t\t\tsend_udp(packet, 0);\n\t\t}\n\n\t\tif (is_a_tty && terminal_mode) {\n\t\t\treset_term();\n\t\t}\n\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\n\t\texit(1);\n\t}\n\treturn sent_bytes;\n}\n\nstatic void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tstrncpy(md5data + 1, password, 82);\n\tmd5data[83] = '\\0';\n\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}\n\nstatic void sig_winch(int sig) {\n\tunsigned short width,height;\n\tstruct mt_packet data;\n\tint plen;\n\n\t/* terminal height/width has changed, inform server */\n\tif (get_terminal_size(&width, &height) != -1) {\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t\toutcounter += plen;\n\n\t\tsend_udp(&data, 1);\n\t}\n\n\t/* reinstate signal handler */\n\tsignal(SIGWINCH, sig_winch);\n}\n\nstatic int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}\n\nstatic int find_interface() {\n\tfd_set read_fds;\n\tstruct mt_packet data;\n\tstruct sockaddr_in myip;\n\tunsigned char emptymac[ETH_ALEN];\n\tint testsocket;\n\tstruct timeval timeout;\n\tint optval = 1;\n\tstruct net_interface *interface;\n\n\t/* TODO: reread interfaces on HUP */\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\n\n\tbzero(emptymac, ETH_ALEN);\n\n\tif (net_get_interfaces(&interfaces) <= 0) {\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\n\t\texit(1);\n\t}\n\n\tDL_FOREACH(interfaces, interface) {\n\t\t/* Skip loopback interfaces */\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize receiving socket on the device chosen */\n\t\tmyip.sin_family = AF_INET;\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\n\t\tmyip.sin_port = htons(sourceport);\n\n\t\t/* Initialize socket and bind to udp port */\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\n\t\t\tclose(testsocket);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure that we have mac-address for this interface  */\n\t\tif (!interface->has_mac) {\n\t\t\tclose(testsocket);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Set the global socket handle and source mac address for send_udp() */\n\t\tsend_socket = testsocket;\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\n\t\tactive_interface = interface;\n\n\t\t/* Send a SESSIONSTART message with the current device */\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\n\t\tsend_udp(&data, 0);\n\n\t\ttimeout.tv_sec = connect_timeout;\n\t\ttimeout.tv_usec = 0;\n\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(insockfd, &read_fds);\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t/* We got a response, this is the correct device to use */\n\t\t\treturn 1;\n\t\t}\n\n\t\tclose(testsocket);\n\t}\n\treturn 0;\n}\n\n/*\n * TODO: Rewrite main() when all sub-functionality is tested\n */\nint main (int argc, char **argv) {\n\tint result;\n\tstruct mt_packet data;\n\tstruct sockaddr_in si_me;\n\tstruct autologin_profile *login_profile;\n\tstruct net_interface *interface, *tmp;\n\tunsigned char buff[MT_PACKET_LEN];\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\n\tunsigned char drop_priv = 0;\n\tint c;\n\tint optval = 1;\n\n\tstrncpy(autologin_path, AUTOLOGIN_PATH, sizeof(autologin_path));\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\twhile (1) {\n\t\tc = getopt(argc, argv, \"lnqt:u:p:U:vh?BAa:\");\n\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u':\n\t\t\t\t/* Save username */\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t\thave_username = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\t/* Save password */\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\t\tmlock(password, sizeof(password));\n#endif\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t\thave_password = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\t\t/* Save nonpriv_username */\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\n\t\t\t\tdrop_priv = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tconnect_timeout = atoi(optarg);\n\t\t\t\tmndp_timeout = connect_timeout;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'q':\n\t\t\t\tquiet_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\trun_mndp = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'B':\n\t\t\t\tbatch_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'A':\n\t\t\t\tno_autologin = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\tstrncpy(autologin_path, optarg, sizeof(autologin_path) - 1);\n\t\t\t\tautologin_path[sizeof(autologin_path) - 1] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\tif (run_mndp) {\n\t\treturn mndp(mndp_timeout, batch_mode);\n\t}\n\tif (argc - optind < 1 || print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-h] [-n] [-a <path>] [-A] [-t <timeout>] [-u <user>] [-p <password>] [-U <user>] | -l [-B] [-t <timeout>]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  MAC            MAC-Address of the RouterOS/mactelnetd device. Use mndp to\\n\"\n\t\t\t\"                 discover it.\\n\"\n\t\t\t\"  identity       The identity/name of your destination device. Uses\\n\"\n\t\t\t\"                 MNDP protocol to find it.\\n\"\n\t\t\t\"  -l             List/Search for routers nearby (MNDP). You may use -t to set timeout.\\n\"\n\t\t\t\"  -B             Batch mode. Use computer readable output (CSV), for use with -l.\\n\"\n\t\t\t\"  -n             Do not use broadcast packets. Less insecure but requires\\n\"\n\t\t\t\"                 root privileges.\\n\"\n\t\t\t\"  -a <path>      Use specified path instead of the default: \" AUTOLOGIN_PATH \" for autologin config file.\\n\"\n\t\t\t\"  -A             Disable autologin feature.\\n\"\n\t\t\t\"  -t <timeout>   Amount of seconds to wait for a response on each interface.\\n\"\n\t\t\t\"  -u <user>      Specify username on command line.\\n\"\n\t\t\t\"  -p <password>  Specify password on command line.\\n\"\n\t\t\t\"  -U <user>      Drop privileges to this user. Used in conjunction with -n\\n\"\n\t\t\t\"                 for security.\\n\"\n\t\t\t\"  -q             Quiet mode.\\n\"\n\t\t\t\"  -h             This help.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\n\tif (!is_a_tty) {\n\t\tquiet_mode = 1;\n\t}\n\n\tif (!no_autologin) {\n\t\tautologin_readfile(autologin_path);\n\t\tlogin_profile = autologin_find_profile(argv[optind]);\n\n\t\tif (!quiet_mode && login_profile != NULL && (login_profile->hasUsername || login_profile->hasPassword)) {\n\t\t\tfprintf(stderr, _(\"Using autologin credentials from %s\\n\"), autologin_path);\n\t\t}\n\t\tif (!have_username) {\n\t\t\tif (login_profile != NULL && login_profile->hasUsername) {\n\t\t\t\thave_username = 1;\n\t\t\t\tstrncpy(username, login_profile->username, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (!have_password) {\n\t\t\tif (login_profile != NULL && login_profile->hasPassword) {\n\t\t\t\thave_password = 1;\n\t\t\t\tstrncpy(password, login_profile->password, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\tif (geteuid() != 0) {\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsockfd = net_init_raw_socket();\n\n\t\tif (drop_priv) {\n\t\t\tdrop_privileges(nonpriv_username);\n\t\t}\n\t} else if (drop_priv) {\n\t\tfprintf(stderr, _(\"The -U option must be used in conjunction with the -n parameter.\\n\"));\n\t\treturn 1;\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\tif (!use_raw_socket) {\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\tperror(\"SO_BROADCAST\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Need to use, to be able to autodetect which interface to use */\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Get mac-address from string, or check for hostname via mndp */\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\n\t\t/* No valid mac address found, abort */\n\t\treturn 1;\n\t}\n\n\tif (!have_username) {\n\t\tif (!quiet_mode) {\n\t\t\tprintf(_(\"Login: \"));\n\t\t\tfflush(stdout);\n\t\t}\n\t\tscanf(\"%127s\", username);\n\t}\n\n\tif (!have_password) {\n\t\tchar *tmp;\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(password, sizeof(password));\n#endif\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\n\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t/* security */\n\t\tmemset(tmp, 0, strlen(tmp));\n#ifdef __linux__\n\t\tfree(tmp);\n#endif\n\t}\n\n\n\t/* Set random source port */\n\tsourceport = 1024 + (rand() % 1024);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\n\n\t/* Session key */\n\tsessionkey = rand() % 65535;\n\n\t/* stop output buffering */\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\n\n\tif (!quiet_mode) {\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\n\t}\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0)) < 1) {\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\n\t\treturn 1;\n\t}\n\tif (!quiet_mode) {\n\t\tprintf(_(\"done\\n\"));\n\t}\n\n\t/* Handle first received packet */\n\thandle_packet(buff, result);\n\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\n\toutcounter += add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\n\n\t/* TODO: handle result of send_udp */\n\tresult = send_udp(&data, 1);\n\n\twhile (running) {\n\t\tfd_set read_fds;\n\t\tint reads;\n\t\tstatic int terminal_gone = 0;\n\t\tstruct timeval timeout;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tif (!terminal_gone) {\n\t\t\tFD_SET(0, &read_fds);\n\t\t}\n\t\tFD_SET(insockfd, &read_fds);\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(insockfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from server */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tbzero(buff, sizeof(buff));\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\n\t\t\t\thandle_packet(buff, result);\n\t\t\t}\n\t\t\t/* Handle data from keyboard/local terminal */\n\t\t\tif (FD_ISSET(0, &read_fds) && terminal_mode) {\n\t\t\t\tunsigned char keydata[512];\n\t\t\t\tint datalen;\n\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, sizeof(keydata));\n\n\t\t\t\tif (datalen > 0) {\n\t\t\t\t\t/* Data received, transmit to server */\n\t\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\t\toutcounter += datalen;\n\t\t\t\t\tsend_udp(&data, 1);\n\t\t\t\t} else {\n\t\t\t\t\tterminal_gone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t} else {\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\n\t\t\t   of inactivity  */\n\t\t\tif (keepalive_counter++ == 10) {\n\t\t\t\tstruct mt_packet odata;\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tsend_udp(&odata, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_a_tty && terminal_mode) {\n\t\t/* Reset terminal back to old settings */\n\t\treset_term();\n\t}\n\n\tclose(sockfd);\n\tclose(insockfd);\n\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\tDL_DELETE(interfaces, interface);\n\t\tfree(interface);\n\t}\n\n\treturn 0;\n}\n", "/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _POSIX_C_SOURCE 199309L\n#define _XOPEN_SOURCE 600\n#define _BSD_SOURCE\n#define _DARWIN_C_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#if defined(__APPLE__)\n# include <sys/sysctl.h>\n# include <libkern/OSByteOrder.h>\n# define le16toh OSSwapLittleToHostInt16\n# define htole32 OSSwapHostToLittleInt32\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <paths.h>\n#endif\n#include <time.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <net/ethernet.h>\n#include <netinet/in.h>\n#if !defined(__FreeBSD__) && !defined(__APPLE__)\n#include <netinet/ether.h>\n#endif\n#include <sys/time.h>\n#include <time.h>\n#include <sys/socket.h>\n#include <string.h>\n#ifdef __linux__\n#include <linux/if_ether.h>\n#include <sys/mman.h>\n#else\n#include <sys/time.h>\n#endif\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#if defined(__linux__)\n#include <sys/sysinfo.h>\n#endif\n#include <pwd.h>\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <sys/time.h>\n/* This is the really Posix interface the Linux code should have used !!*/\n#include <utmpx.h>\n#else\n#include <utmp.h>\n#endif\n#include <syslog.h>\n#include <sys/utsname.h>\n#include \"md5.h\"\n#include \"protocol.h\"\n#include \"console.h\"\n#include \"interfaces.h\"\n#include \"users.h\"\n#include \"config.h\"\n#include \"utlist.h\"\n\n#define PROGRAM_NAME \"MAC-Telnet Daemon\"\n\n#define MAX_INSOCKETS 100\n\n#define MT_INTERFACE_LEN 128\n\n/* Max ~5 pings per second */\n#define MT_MAXPPS MT_MNDP_BROADCAST_INTERVAL * 5\n\n#define _(String) gettext (String)\n#define gettext_noop(String) String\n\nstatic int sockfd;\nstatic int insockfd;\nstatic int mndpsockfd;\n\nstatic int pings = 0;\n\nstruct net_interface *interfaces = NULL;\n\nstatic int use_raw_socket = 0;\n\nstatic struct in_addr sourceip; \nstatic struct in_addr destip;\nstatic int sourceport;\n\nstatic time_t last_mndp_time = 0;\n\n/* Protocol data direction */\nunsigned char mt_direction_fromserver = 1;\n\n/* Anti-timeout is every 10 seconds. Give up after 15. */\n#define MT_CONNECTION_TIMEOUT 15\n\n/* Connection states */\nenum mt_connection_state {\n\tSTATE_AUTH,\n\tSTATE_CLOSED,\n\tSTATE_ACTIVE\n};\n\n/** Connection struct */\nstruct mt_connection {\n\tstruct net_interface *interface;\n\tchar interface_name[256];\n\n\tunsigned short seskey;\n\tunsigned int incounter;\n\tunsigned int outcounter;\n\tunsigned int lastack;\n\ttime_t lastdata;\n\n\tint terminal_mode;\n\tenum mt_connection_state state;\n\tint ptsfd;\n\tint slavefd;\n\tint pid;\n\tint wait_for_ack;\n\tint have_pass_salt;\n\n\tchar username[MT_MNDP_MAX_STRING_SIZE];\n\tunsigned char trypassword[17];\n\tunsigned char srcip[IPV4_ALEN];\n\tunsigned char srcmac[ETH_ALEN];\n\tunsigned short srcport;\n\tunsigned char dstmac[ETH_ALEN];\n\tunsigned char pass_salt[16];\n\tunsigned short terminal_width;\n\tunsigned short terminal_height;\n\tchar terminal_type[30];\n\n\tstruct mt_connection *prev;\n\tstruct mt_connection *next;\n};\n\nstatic void uwtmp_login(struct mt_connection *);\nstatic void uwtmp_logout(struct mt_connection *);\n\nstatic struct mt_connection *connections_head = NULL;\n\nstatic void list_add_connection(struct mt_connection *conn) {\n\tDL_APPEND(connections_head, conn);\n}\n\nstatic void list_remove_connection(struct mt_connection *conn) {\n\tif (connections_head == NULL) {\n\t\treturn;\n\t}\n\n\tif (conn->state == STATE_ACTIVE && conn->ptsfd > 0) {\n\t\tclose(conn->ptsfd);\n\t}\n\tif (conn->state == STATE_ACTIVE && conn->slavefd > 0) {\n\t\tclose(conn->slavefd);\n\t}\n\n\tuwtmp_logout(conn);\n\n\tDL_DELETE(connections_head, conn);\n\tfree(conn);\n}\n\nstatic struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {\n\tstruct mt_connection *p;\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_interface *find_socket(unsigned char *mac) {\n\tstruct net_interface *interface;\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tif (memcmp(mac, interface->mac_addr, ETH_ALEN) == 0) {\n\t\t\treturn interface;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void setup_sockets() {\n\tstruct net_interface *interface;\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tint optval = 1;\n\t\tstruct sockaddr_in si_me;\n\t\tstruct ether_addr *mac = (struct ether_addr *)&(interface->mac_addr);\n\n\t\tif (!interface->has_mac) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!use_raw_socket) {\n\t\t\tinterface->socketfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\t\t\tif (interface->socketfd < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (setsockopt(interface->socketfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\t\tperror(\"SO_BROADCAST\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsetsockopt(interface->socketfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t\t\t/* Initialize receiving socket on the device chosen */\n\t\t\tsi_me.sin_family = AF_INET;\n\t\t\tsi_me.sin_port = htons(MT_MACTELNET_PORT);\n\t\t\tmemcpy(&(si_me.sin_addr.s_addr), interface->ipv4_addr, IPV4_ALEN);\n\n\t\t\tif (bind(interface->socketfd, (struct sockaddr *)&si_me, sizeof(si_me))==-1) {\n\t\t\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsyslog(LOG_NOTICE, _(\"Listening on %s for %s\\n\"), interface->name, ether_ntoa(mac));\n\n\t}\n}\n\nstatic int send_udp(const struct mt_connection *conn, const struct mt_packet *packet) {\n\tif (use_raw_socket) {\n\t\treturn net_send_udp(sockfd, conn->interface, conn->dstmac, conn->srcmac, &sourceip, sourceport, &destip, conn->srcport, packet->data, packet->size);\n\t} else {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(conn->srcport);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\treturn sendto(conn->interface->socketfd, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t}\n}\n\nstatic int send_special_udp(struct net_interface *interface, unsigned short port, const struct mt_packet *packet) {\n\tunsigned char dstmac[ETH_ALEN];\n\n\tif (use_raw_socket) {\n\t\tmemset(dstmac, 0xff, ETH_ALEN);\n\t\treturn net_send_udp(sockfd, interface, interface->mac_addr, dstmac, (const struct in_addr *)&interface->ipv4_addr, port, &destip, port, packet->data, packet->size);\n\t} else {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(port);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\treturn sendto(interface->socketfd, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t}\n}\n\n\nstatic void display_motd() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(\"/etc/motd\", \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n\nstatic void display_nologin() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(_PATH_NOLOGIN, \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n\nstatic void uwtmp_login(struct mt_connection *conn) {\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tstruct utmpx utent;\n#else\n\tstruct utmp utent;\n#endif\n\tpid_t pid;\n\n\tpid = getpid();\n\n\tchar *line = ttyname(conn->slavefd);\n\tif (strncmp(line, \"/dev/\", 5) == 0) {\n\t\tline += 5;\n\t}\n\n\t/* Setup utmp struct */\n\tmemset((void *) &utent, 0, sizeof(utent));\n\tutent.ut_type = USER_PROCESS;\n\tutent.ut_pid = pid;\n\tstrncpy(utent.ut_user, conn->username, sizeof(utent.ut_user));\n\tstrncpy(utent.ut_line, line, sizeof(utent.ut_line));\n\tstrncpy(utent.ut_id, utent.ut_line + 3, sizeof(utent.ut_id));\n\tstrncpy(utent.ut_host,\n                ether_ntoa((const struct ether_addr *)conn->srcmac),\n                sizeof(utent.ut_host));\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tgettimeofday(&utent.ut_tv, NULL);\n#else\n\ttime((time_t *)&(utent.ut_time));\n#endif\n\n\t/* Update utmp and/or wtmp */\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tsetutxent();\n\tpututxline(&utent);\n\tendutxent();\n#else\n\tsetutent();\n\tpututline(&utent);\n\tendutent();\n\tupdwtmp(_PATH_WTMP, &utent);\n#endif\n}\n\nstatic void uwtmp_logout(struct mt_connection *conn) {\n\tif (conn->pid > 0) {\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\tstruct utmpx *utentp;\n\t\tstruct utmpx utent;\n\t\tsetutxent();\n#else\n\t\tstruct utmp *utentp;\n\t\tstruct utmp utent;\n\t\tsetutent();\n#endif\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\twhile ((utentp = getutxent()) != NULL) {\n#else\n\t\twhile ((utentp = getutent()) != NULL) {\n#endif\n\t\t\tif (utentp->ut_pid == conn->pid && utentp->ut_id) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (utentp) {\n\t\t\tutent = *utentp;\n\n\t\t\tutent.ut_type = DEAD_PROCESS;\n\t\t\tutent.ut_tv.tv_sec = time(NULL);\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\t\tpututxline(&utent);\n\t\t\tendutxent();\n#else\n\t\t\tpututline(&utent);\n\t\t\tendutent();\n\t\t\tupdwtmp(_PATH_WTMP, &utent);\n#endif\n\t\t}\n\t}\n}\n\nstatic void abort_connection(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, char *message) {\n\tstruct mt_packet pdata;\n\n\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, message, strlen(message));\n\tsend_udp(curconn, &pdata);\n\n\t/* Make connection time out; lets the previous message get acked before disconnecting */\n\tcurconn->state = STATE_CLOSED;\n\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\tsend_udp(curconn, &pdata);\n}\n\nstatic void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tstrncpy(md5data + 1, user->password, 82);\n\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}\n\nstatic void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}\n\nstatic void handle_packet(unsigned char *data, int data_len, const struct sockaddr_in *address) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\tstruct mt_connection *curconn = NULL;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface;\n\n\t/* Check for minimal size */\n\tif (data_len < MT_HEADER_LEN - 4) {\n\t\treturn;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* Drop packets not belonging to us */\n\tif ((interface = find_socket(pkthdr.dstaddr)) < 0) {\n\t\treturn;\n\t}\n\n\tswitch (pkthdr.ptype) {\n\n\t\tcase MT_PTYPE_PING:\n\t\t\tif (pings++ > MT_MAXPPS) {\n\t\t\t\t/* Don't want it to wrap around back to the valid range */\n\t\t\t\tpings--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinit_pongpacket(&pdata, (unsigned char *)&(pkthdr.dstaddr), (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tadd_packetdata(&pdata, pkthdr.data - 4, data_len - (MT_HEADER_LEN - 4));\n\t\t\t{\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tsend_special_udp(interface, MT_MACTELNET_PORT, &pdata);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MT_PTYPE_SESSIONSTART:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn != NULL) {\n\t\t\t\t/* Ignore multiple session starts from the same sender, this can be same mac but different interface */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsyslog(LOG_DEBUG, _(\"(%d) New connection from %s.\"), pkthdr.seskey, ether_ntoa((struct ether_addr*)&(pkthdr.srcaddr)));\n\t\t\tcurconn = calloc(1, sizeof(struct mt_connection));\n\t\t\tcurconn->seskey = pkthdr.seskey;\n\t\t\tcurconn->lastdata = time(NULL);\n\t\t\tcurconn->state = STATE_AUTH;\n\t\t\tcurconn->interface = interface;\n\t\t\tstrncpy(curconn->interface_name, interface->name, 254);\n\t\t\tcurconn->interface_name[255] = '\\0';\n\t\t\tmemcpy(curconn->srcmac, pkthdr.srcaddr, ETH_ALEN);\n\t\t\tmemcpy(curconn->srcip, &(address->sin_addr), IPV4_ALEN);\n\t\t\tcurconn->srcport = htons(address->sin_port);\n\t\t\tmemcpy(curconn->dstmac, pkthdr.dstaddr, ETH_ALEN);\n\n\t\t\tlist_add_connection(curconn);\n\n\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\tbreak;\n\n\t\tcase MT_PTYPE_END:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (curconn->state != STATE_CLOSED) {\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t\tsyslog(LOG_DEBUG, _(\"(%d) Connection closed.\"), curconn->seskey);\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\n\t\tcase MT_PTYPE_ACK:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pkthdr.counter <= curconn->outcounter) {\n\t\t\t\tcurconn->wait_for_ack = 0;\n\t\t\t\tcurconn->lastack = pkthdr.counter;\n\t\t\t}\n\n\t\t\tif (time(0) - curconn->lastdata > 9 || pkthdr.counter == curconn->lastack) {\n\t\t\t\t// Answer to anti-timeout packet\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t\tcurconn->lastdata = time(NULL);\n\t\t\treturn;\n\n\t\tcase MT_PTYPE_DATA:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurconn->lastdata = time(NULL);\n\n\t\t\t/* now check the right size */\n\t\t\tif (data_len < MT_HEADER_LEN) {\n\t\t\t\t/* Ignore illegal packet */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* ack the data packet */\n\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\t\tsend_udp(curconn, &pdata);\n\n\t\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\t\twrapped around. */\n\t\t\tif (curconn->incounter == 0 || pkthdr.counter > curconn->incounter || (curconn->incounter - pkthdr.counter) > 16777216) {\n\t\t\t\tcurconn->incounter = pkthdr.counter;\n\t\t\t} else {\n\t\t\t\t/* Ignore double or old packets */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thandle_data_packet(curconn, &pkthdr, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (curconn) {\n\t\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled packet type: %d\"), curconn->seskey, pkthdr.ptype);\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t}\n\tif (0 && curconn != NULL) {\n\t\tprintf(\"Packet, incounter %d, outcounter %d\\n\", curconn->incounter, curconn->outcounter);\n\t}\n}\n\nstatic void print_version() {\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\n}\n\nvoid mndp_broadcast() {\n\tstruct mt_packet pdata;\n\tstruct utsname s_uname;\n\tstruct net_interface *interface;\n\tunsigned int uptime;\n#if defined(__APPLE__)\n\tint mib[] = {CTL_KERN, KERN_BOOTTIME};\n\tstruct timeval boottime;\n\tsize_t tv_size = sizeof(boottime);\n\tif (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &boottime, &tv_size, NULL, 0) == -1) {\n\t  return;\n\t}\n\tuptime = htole32(boottime.tv_sec);\n#elif defined(__linux__)\n\tstruct sysinfo s_sysinfo;\n\n\tif (sysinfo(&s_sysinfo) != 0) {\n\t\treturn;\n\t}\n\n\t/* Seems like ping uptime is transmitted as little endian? */\n\tuptime = htole32(s_sysinfo.uptime);\n#else\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_UPTIME, &ts) != -1) {\n\t\tuptime = htole32(((unsigned int)ts.tv_sec));\n\t}\n#endif\n\n\tif (uname(&s_uname) != 0) {\n\t\treturn;\n\t}\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tstruct mt_mndp_hdr *header = (struct mt_mndp_hdr *)&(pdata.data);\n\n\t\tif (interface->has_mac == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmndp_init_packet(&pdata, 0, 1);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_ADDRESS, interface->mac_addr, ETH_ALEN);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_IDENTITY, s_uname.nodename, strlen(s_uname.nodename));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_VERSION, s_uname.release, strlen(s_uname.release));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_PLATFORM, PLATFORM_NAME, strlen(PLATFORM_NAME));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_HARDWARE, s_uname.machine, strlen(s_uname.machine));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_TIMESTAMP, &uptime, 4);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_SOFTID, MT_SOFTID_MACTELNET, strlen(MT_SOFTID_MACTELNET));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_IFNAME, interface->name, strlen(interface->name));\n\n\t\theader->cksum = in_cksum((unsigned short *)&(pdata.data), pdata.size);\n\t\tsend_special_udp(interface, MT_MNDP_PORT, &pdata);\n\t}\n}\n\nvoid sigterm_handler() {\n\tstruct mt_connection *p;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface, *tmp;\n\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\tchar message[] = gettext_noop(\"\\r\\n\\r\\nDaemon shutting down.\\r\\n\");\n\n\tsyslog(LOG_NOTICE, _(\"Daemon shutting down\"));\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->state == STATE_ACTIVE) {\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->interface->mac_addr, p->srcmac, p->seskey, p->outcounter);\n\t\t\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, _(message), strlen(_(message)));\n\t\t\tsend_udp(p, &pdata);\n\n\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->interface->mac_addr, p->srcmac, p->seskey, p->outcounter);\n\t\t\tsend_udp(p, &pdata);\n\t\t}\n\t}\n\n\t/* Doesn't hurt to tidy up */\n\tclose(sockfd);\n\tclose(insockfd);\n\tif (!use_raw_socket) {\n\t\tDL_FOREACH(interfaces, interface) {\n\t\t\tif (interface->socketfd > 0)\n\t\t\t\tclose(interface->socketfd);\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\tDL_DELETE(interfaces, interface);\n\t\tfree(interface);\n\t}\n\tcloselog();\n\texit(0);\n}\n\nvoid sighup_handler() {\n\tstruct mt_connection *p;\n\n\tsyslog(LOG_NOTICE, _(\"SIGHUP: Reloading interfaces\"));\n\n\tif (!use_raw_socket) {\n\t\tstruct net_interface *interface, *tmp;\n\t\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\t\tclose(interface->socketfd);\n\t\t\tDL_DELETE(interfaces, interface);\n\t\t\tfree(interface);\n\t\t}\n\t\tinterfaces = NULL;\n\t}\n\n\tif (net_get_interfaces(&interfaces) <= 0) {\n\t\tsyslog(LOG_ERR, _(\"No devices found! Exiting.\\n\"));\n\t\texit(1);\n\t}\n\n\tsetup_sockets();\n\n\t/* Reassign outgoing interfaces to connections again, since they may have changed */\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->interface_name != NULL) {\n\t\t\tstruct net_interface *interface = net_get_interface_ptr(&interfaces, p->interface_name, 0);\n\t\t\tif (interface != NULL) {\n\t\t\t\tp->interface = interface;\n\t\t\t} else {\n\t\t\t\tstruct mt_connection tmp;\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) Connection closed because interface %s is gone.\"), p->seskey, p->interface_name);\n\t\t\t\ttmp.next = p->next;\n\t\t\t\tlist_remove_connection(p);\n\t\t\t\tp = &tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * TODO: Rewrite main() when all sub-functionality is tested\n */\nint main (int argc, char **argv) {\n\tint result;\n\tstruct sockaddr_in si_me;\n\tstruct sockaddr_in si_me_mndp;\n\tstruct timeval timeout;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface;\n\tfd_set read_fds;\n\tint c,optval = 1;\n\tint print_help = 0;\n\tint foreground = 0;\n\tint interface_count = 0;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\twhile ((c = getopt(argc, argv, \"fnvh?\")) != -1) {\n\t\tswitch (c) {\n\t\t\tcase 'f':\n\t\t\t\tforeground = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tif (print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s [-f|-n|-h]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  -f        Run process in foreground.\\n\"\n\t\t\t\"  -n        Do not use broadcast packets. Just a tad less insecure.\\n\"\n\t\t\t\"  -h        This help.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, _(\"You need to have root privileges to use %s.\\n\"), argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* Try to read user file */\n\tread_userfile();\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\t/* Transmit raw packets with this socket */\n\t\tsockfd = net_init_raw_socket();\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\t/* Set source port */\n\tsourceport = MT_MACTELNET_PORT;\n\n\t/* Listen address*/\n\tinet_pton(AF_INET, (char *)\"0.0.0.0\", &sourceip);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\tmemcpy(&(si_me.sin_addr), &sourceip, IPV4_ALEN);\n\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me))==-1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\t/* TODO: Move socket initialization out of main() */\n\n\t/* Receive mndp udp packets with this socket */\n\tmndpsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (mndpsockfd < 0) {\n\t\tperror(\"mndpsockfd\");\n\t\treturn 1;\n\t}\n\n\tmemset((char *)&si_me_mndp, 0, sizeof(si_me_mndp));\n\tsi_me_mndp.sin_family = AF_INET;\n\tsi_me_mndp.sin_port = htons(MT_MNDP_PORT);\n\tmemcpy(&(si_me_mndp.sin_addr), &sourceip, IPV4_ALEN);\n\n\tsetsockopt(mndpsockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Bind to udp port */\n\tif (bind(mndpsockfd, (struct sockaddr *)&si_me_mndp, sizeof(si_me_mndp))==-1) {\n\t\tfprintf(stderr, _(\"MNDP: Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me_mndp.sin_addr), MT_MNDP_PORT, strerror(errno));\n\t}\n\n\topenlog(\"mactelnetd\", LOG_PID, LOG_DAEMON);\n\tsyslog(LOG_NOTICE, _(\"Bound to %s:%d\"), inet_ntoa(si_me.sin_addr), sourceport);\n\n\t/* Enumerate available interfaces */\n\tnet_get_interfaces(&interfaces);\n\n\tsetup_sockets();\n\n\tif (!foreground) {\n\t\tdaemon(0, 0);\n\t}\n\n\t/* Handle zombies etc */\n\tsignal(SIGCHLD,SIG_IGN);\n\tsignal(SIGTSTP,SIG_IGN);\n\tsignal(SIGTTOU,SIG_IGN);\n\tsignal(SIGTTIN,SIG_IGN);\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tif (interface->has_mac) {\n\t\t\tinterface_count++;\n\t\t}\n\t}\n\n\tif (interface_count == 0) {\n\t\tsyslog(LOG_ERR, _(\"Unable to find any valid network interfaces\\n\"));\n\t\texit(1);\n\t}\n\n\twhile (1) {\n\t\tint reads;\n\t\tstruct mt_connection *p;\n\t\tint maxfd=0;\n\t\ttime_t now;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(insockfd, &read_fds);\n\t\tFD_SET(mndpsockfd, &read_fds);\n\t\tmaxfd = insockfd > mndpsockfd ? insockfd : mndpsockfd;\n\n\t\t/* Add active connections to select queue */\n\t\tDL_FOREACH(connections_head, p) {\n\t\t\tif (p->state == STATE_ACTIVE && p->wait_for_ack == 0 && p->ptsfd > 0) {\n\t\t\t\tFD_SET(p->ptsfd, &read_fds);\n\t\t\t\tif (p->ptsfd > maxfd) {\n\t\t\t\t\tmaxfd = p->ptsfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(maxfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from clients\n\t\t\t TODO: Enable broadcast support (without raw sockets)\n\t\t\t */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tstruct sockaddr_in saddress;\n\t\t\t\tunsigned int slen = sizeof(saddress);\n\t\t\t\tbzero(buff, MT_HEADER_LEN);\n\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, (struct sockaddr *)&saddress, &slen);\n\t\t\t\thandle_packet(buff, result, &saddress);\n\t\t\t}\n\t\t\tif (FD_ISSET(mndpsockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tstruct sockaddr_in saddress;\n\t\t\t\tunsigned int slen = sizeof(saddress);\n\t\t\t\tresult = recvfrom(mndpsockfd, buff, sizeof(buff), 0, (struct sockaddr *)&saddress, &slen);\n\n\t\t\t\t/* Handle MNDP broadcast request, max 1 rps */\n\t\t\t\tif (result == 4 && time(NULL) - last_mndp_time > 0) {\n\t\t\t\t\tmndp_broadcast();\n\t\t\t\t\ttime(&last_mndp_time);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Handle data from terminal sessions */\n\t\t\tDL_FOREACH(connections_head, p) {\n\t\t\t\t/* Check if we have data ready in the pty buffer for the active session */\n\t\t\t\tif (p->state == STATE_ACTIVE && p->ptsfd > 0 && p->wait_for_ack == 0 && FD_ISSET(p->ptsfd, &read_fds)) {\n\t\t\t\t\tunsigned char keydata[1024];\n\t\t\t\t\tint datalen,plen;\n\n\t\t\t\t\t/* Read it */\n\t\t\t\t\tdatalen = read(p->ptsfd, &keydata, sizeof(keydata));\n\t\t\t\t\tif (datalen > 0) {\n\t\t\t\t\t\t/* Send it */\n\t\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\t\t\tp->outcounter += plen;\n\t\t\t\t\t\tp->wait_for_ack = 1;\n\t\t\t\t\t\tresult = send_udp(p, &pdata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Shell exited */\n\t\t\t\t\t\tstruct mt_connection tmp;\n\t\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t\tsend_udp(p, &pdata);\n\t\t\t\t\t\tif (p->username != NULL) {\n\t\t\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Connection to user %s closed.\"), p->seskey, p->username);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Connection closed.\"), p->seskey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.next = p->next;\n\t\t\t\t\t\tlist_remove_connection(p);\n\t\t\t\t\t\tp = &tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (p->state == STATE_ACTIVE && p->ptsfd > 0 && p->wait_for_ack == 1 && FD_ISSET(p->ptsfd, &read_fds)) {\n\t\t\t\t\tprintf(_(\"(%d) Waiting for ack\\n\"), p->seskey);\n\t\t\t\t}\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t}\n\t\ttime(&now);\n\n\t\tif (now - last_mndp_time > MT_MNDP_BROADCAST_INTERVAL) {\n\t\t\tpings = 0;\n\t\t\tmndp_broadcast();\n\t\t\tlast_mndp_time = now;\n\t\t}\n\t\tif (connections_head != NULL) {\n\t\t\tstruct mt_connection *p,tmp;\n\t\t\tDL_FOREACH(connections_head, p) {\n\t\t\t\tif (now - p->lastdata >= MT_CONNECTION_TIMEOUT) {\n\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Session timed out\"), p->seskey);\n\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\t\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, _(\"Timeout\\r\\n\"), 9);\n\t\t\t\t\tsend_udp(p, &pdata);\n\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\tsend_udp(p, &pdata);\n\n\t\t\t\t\ttmp.next = p->next;\n\t\t\t\t\tlist_remove_connection(p);\n\t\t\t\t\tp = &tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Never reached */\n\treturn 0;\n}\n", "/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _BSD_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#ifdef __LINUX__\n#include <linux/if_ether.h>\n#endif\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <net/ethernet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#else\n#include <netinet/ether.h>\n#endif\n#include <time.h>\n#if defined(__APPLE__)\n# include <libkern/OSByteOrder.h>\n# define le32toh OSSwapLittleToHostInt32\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#include \"protocol.h\"\n#include \"config.h\"\n\n#define _(String) gettext (String)\n\nint init_packet(struct mt_packet *packet, enum mt_ptype ptype, unsigned char *srcmac, unsigned char *dstmac, unsigned short sessionkey, unsigned int counter) {\n\tunsigned char *data = packet->data;\n\n\t/* Packet version */\n\tdata[0] = 1;\n\n\t/* Packet type */\n\tdata[1] = ptype;\n\n\t/* src ethernet address */\n\tmemcpy(data + 2, srcmac, ETH_ALEN);\n\n\t/* dst ethernet address */\n\tmemcpy(data + 8, dstmac, ETH_ALEN);\n\n\t/* Session key */\n\tsessionkey = htons(sessionkey);\n\tmemcpy(data + (mt_direction_fromserver ? 16 : 14), &sessionkey, sizeof(sessionkey));\n\n\t/* Client type: Mac Telnet */\n\tmemcpy(data + (mt_direction_fromserver ? 14 : 16), &mt_mactelnet_clienttype, sizeof(mt_mactelnet_clienttype));\n\n\t/* Received/sent data counter */\n\tcounter = htonl(counter);\n\tmemcpy(data + 18, &counter, sizeof(counter));\n\n\t/* 22 bytes header */\n\tpacket->size = 22;\n\treturn 22;\n}\n\nint add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + act_size > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}\n\nint init_pingpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned char *dstmac) {\n\tinit_packet(packet, MT_PTYPE_PING, srcmac, dstmac, 0, 0);\n\n\t/* Zero out sessionkey & counter */\n\tbzero(packet->data + 14, 4);\n\n\t/* Remove data counter field from header */\n\tpacket->size -= 4;\n\treturn packet->size;\n}\n\nint init_pongpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned char *dstmac) {\n\tinit_packet(packet, MT_PTYPE_PONG, srcmac, dstmac, 0, 0);\n\n\t/* Zero out sessionkey & counter */\n\tbzero(packet->data + 14, 4);\n\n\t/* Remove data counter field from header */\n\tpacket->size -= 4;\n\treturn packet->size;\n}\n\nint add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\tif (packet->size + length > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}\n\nvoid parse_packet(unsigned char *data, struct mt_mactelnet_hdr *pkthdr) {\n\t/* Packet version */\n\tpkthdr->ver = data[0];\n\n\t/* Packet type */\n\tpkthdr->ptype = data[1];\n\n\t/* src ethernet addr */\n\tmemcpy(pkthdr->srcaddr, data + 2, ETH_ALEN);\n\n\t/* dst ethernet addr */\n\tmemcpy(pkthdr->dstaddr, data + 8, ETH_ALEN);\n\n\t/* Session key */\n\tmemcpy(&(pkthdr->seskey), data + (mt_direction_fromserver ? 14 : 16), sizeof(pkthdr->seskey));\n\tpkthdr->seskey = ntohs(pkthdr->seskey);\n\n\t/* server type */\n\tmemcpy(&(pkthdr->clienttype), data + (mt_direction_fromserver ? 16 : 14), 2);\n\n\t/* Received/sent data counter */\n\tmemcpy(&(pkthdr->counter), data + 18, sizeof(pkthdr->counter));\n\tpkthdr->counter = ntohl(pkthdr->counter);\n\n\t/* Set pointer to actual data */\n\tpkthdr->data = data + 22;\n}\n\n\nint parse_control_packet(unsigned char *packetdata, unsigned short data_len, struct mt_mactelnet_control_hdr *cpkthdr) {\n\tstatic unsigned char *int_data;\n\tstatic unsigned int int_data_len;\n\tstatic unsigned int int_pos;\n\tunsigned char *data;\n\n\t/* Store info so we can call this function once with data,\n\t   and then several times for each control packets. Letting this function\n\t   control the data position. */\n\tif (packetdata != NULL) {\n\t\tif (data_len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint_data = packetdata;\n\t\tint_data_len = data_len;\n\t\tint_pos = 0;\n\t}\n\n\t/* No more data to parse? */\n\tif (int_pos >= int_data_len) {\n\t\treturn 0;\n\t}\n\n\t/* Set current position in data buffer */\n\tdata = int_data + int_pos;\n\n\t/* Check for valid minimum packet length & magic header */\n\tif ((int_data_len - int_pos) >= MT_CPHEADER_LEN && memcmp(data, &mt_mactelnet_cpmagic, 4) == 0) {\n\n\t\t/* Control packet type */\n\t\tcpkthdr->cptype = data[4];\n\n\t\t/* Control packet data length */\n\t\tmemcpy(&(cpkthdr->length), data + 5, sizeof(cpkthdr->length));\n\t\tcpkthdr->length = ntohl(cpkthdr->length);\n\n\t\t/* We want no buffer overflows */\n\t\tif (cpkthdr->length > int_data_len - MT_CPHEADER_LEN - int_pos) {\n\t\t\tcpkthdr->length = int_data_len - MT_CPHEADER_LEN - int_pos;\n\t\t}\n\n\t\t/* Set pointer to actual data */\n\t\tcpkthdr->data = data + MT_CPHEADER_LEN;\n\n\t\t/* Remember old position, for next call */\n\t\tint_pos += cpkthdr->length + MT_CPHEADER_LEN;\n\n\t\t/* Read data successfully */\n\t\treturn 1;\n\n\t} else {\n\t\t/* Mark data as raw terminal data */\n\t\tcpkthdr->cptype = MT_CPTYPE_PLAINDATA;\n\t\tcpkthdr->length = int_data_len - int_pos;\n\t\tcpkthdr->data = data;\n\n\t\t/* Consume the whole rest of the packet */\n\t\tint_pos = int_data_len;\n\n\t\t/* Read data successfully */\n\t\treturn 1;\n\t}\n}\n\nint mndp_init_packet(struct mt_packet *packet, unsigned char version, unsigned char ttl) {\n\tstruct mt_mndp_hdr *header = (struct mt_mndp_hdr *)packet->data;\n\n\theader->version = version;\n\theader->ttl = ttl;\n\theader->cksum = 0;\n\n\tpacket->size = sizeof(*header);\n\n\treturn sizeof(*header);\n}\n\nint mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}\n\n\nstruct mt_mndp_info *parse_mndp(const unsigned char *data, const int packet_len) {\n\tconst unsigned char *p;\n\tstatic struct mt_mndp_info packet;\n\tstruct mt_mndp_info *packetp = &packet;\n\tstruct mt_mndp_hdr *mndp_hdr;\n\n\t/* Check for valid packet length */\n\tif (packet_len < 18) {\n\t\treturn NULL;\n\t}\n\n\tbzero(packetp, sizeof(*packetp));\n\n\tmndp_hdr = (struct mt_mndp_hdr*)data;\n\n\tmemcpy(&packetp->header, mndp_hdr, sizeof(struct mt_mndp_hdr));\n\n\tp = data + sizeof(struct mt_mndp_hdr);\n\n\twhile(p + 4 < data + packet_len) {\n\t\tunsigned short type, len;\n\n\t\tmemcpy(&type, p, 2);\n\t\tmemcpy(&len, p + 2, 2);\n\n\t\ttype = ntohs(type);\n\t\tlen = ntohs(len);\n\n\t\tp += 4;\n\n\t\t/* Check if len is invalid */\n\t\tif (p + len > data + packet_len) {\n\t\t        fprintf(stderr, \"%s: invalid data: \"\n\t\t\t\t        \"%p + %u > %p + %d\\n\",\n\t\t\t\t\t__func__, p, len, data, packet_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\t\tcase MT_MNDPTYPE_ADDRESS:\n\t\t\t\tif (len >= ETH_ALEN) {\n\t\t\t\t\tmemcpy(packetp->address, p, ETH_ALEN);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_IDENTITY:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->identity, p, len);\n\t\t\t\tpacketp->identity[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_PLATFORM:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->platform, p, len);\n\t\t\t\tpacketp->platform[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_VERSION:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->version, p, len);\n\t\t\t\tpacketp->version[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_TIMESTAMP:\n\t\t\t\tif (len >= 4) {\n\t\t\t\t\tmemcpy(&packetp->uptime, p, 4);\n\t\t\t\t\t/* Seems like ping uptime is transmitted as little endian? */\n\t\t\t\t\tpacketp->uptime = le32toh(packetp->uptime);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_HARDWARE:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->hardware, p, len);\n\t\t\t\tpacketp->hardware[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_SOFTID:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->softid, p, len);\n\t\t\t\tpacketp->softid[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_IFNAME:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->ifname, p, len);\n\t\t\t\tpacketp->ifname[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\t/*default:\n\t\t\t\t Unhandled MNDP type\n\t\t\t*/\n\t\t}\n\n\t\tp += len;\n\t}\n\n\treturn packetp;\n}\n\nint query_mndp(const char *identity, unsigned char *mac) {\n\tint fastlookup = 0;\n\tint sock, length;\n\tint optval = 1;\n\tstruct sockaddr_in si_me, si_remote;\n\tunsigned char buff[MT_PACKET_LEN];\n\tunsigned int message = 0;\n\tstruct timeval timeout;\n\ttime_t start_time;\n\tfd_set read_fds;\n\tstruct mt_mndp_info *packet;\n\n\tstart_time = time(0);\n\n\t/* Open a UDP socket handle */\n\tsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n\t/* Allow to share socket */\n\tsetsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t/* Set initialize address/port */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(MT_MNDP_PORT);\n\tsi_me.sin_addr.s_addr = htonl(INADDR_ANY);\n\n\t/* Bind to specified address/port */\n\tif (bind(sock, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d\\n\"), inet_ntoa(si_me.sin_addr), MT_MNDP_PORT);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\t/* Set the socket to allow sending broadcast packets */\n\tsetsockopt(sock, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval));\n\n\t/* Request routers identify themselves */\n\tmemset((char *) &si_remote, 0, sizeof(si_remote));\n\tsi_remote.sin_family = AF_INET;\n\tsi_remote.sin_port = htons(MT_MNDP_PORT);\n\tsi_remote.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\tif (sendto(sock, &message, sizeof (message), 0, (struct sockaddr *)&si_remote, sizeof(si_remote)) == -1) {\n\t\tfprintf(stderr, _(\"Unable to send broadcast packet: Router lookup will be slow\\n\"));\n\t\tfastlookup = 0;\n\t} else {\n\t\tfastlookup = 1;\n\t}\n\n\twhile (1) {\n\t\t/* Timeout, in case we receive a lot of packets, but from the wrong routers */\n\t\tif (time(0) - start_time > (fastlookup ? MT_MNDP_TIMEOUT : MT_MNDP_LONGTIMEOUT)) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(sock, &read_fds);\n\n\t\ttimeout.tv_sec = fastlookup ? MT_MNDP_TIMEOUT : MT_MNDP_LONGTIMEOUT;\n\t\ttimeout.tv_usec = 0;\n\n\t\tselect(sock + 1, &read_fds, NULL, NULL, &timeout);\n\t\tif (!FD_ISSET(sock, &read_fds)) {\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Read UDP packet */\n\t\tlength = recvfrom(sock, buff, sizeof(buff), 0, 0, 0);\n\t\tif (length < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Parse MNDP packet */\n\t\tpacket = parse_mndp(buff, length);\n\n\t\tif (packet != NULL) {\n\t\t\tif (strcasecmp(identity, packet->identity) == 0) {\n\t\t\t\tmemcpy(mac, packet->address, ETH_ALEN);\n\t\t\t\tclose(sock);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tclose(sock);\n\treturn 0;\n}\n\n/*\n * This function accepts either a full MAC address using : or - as seperators.\n * Or a router hostname. The hostname will be searched for via MNDP broadcast packets.\n */\nint query_mndp_or_mac(char *address, unsigned char *dstmac, int verbose) {\n\tchar *p = address;\n\tint colons = 0;\n\tint dashs = 0;\n\n\twhile (*p++) {\n\t\tif (*p == ':') {\n\t\t\tcolons++;\n\t\t}\n\t\telse if (*p == '-') {\n\t\t\tdashs++;\n\t\t}\n\t}\n\n\t/* \n\t* Windows users often enter macs with dash instead\n\t* of colon.\n\t*/\n\tif (colons == 0 && dashs == 5) {\n\t\tp = address;\n\t\twhile (*p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = ':';\n\t\t\t}\n\t\t}\n\t\tcolons = dashs;\n\t}\n\n\tif (colons != 5) {\n\t\t/* \n\t\t * Not a valid mac-address.\n\t\t * Search for Router by identity name, using MNDP\n\t\t */\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, _(\"Searching for '%s'...\"), address);\n\t\t}\n\t\tif (!query_mndp(address, dstmac)) {\n\t\t\tif (verbose) {\n\t\t\t\tfprintf(stderr, _(\"not found\\n\"));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Router found, display mac and continue */\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, _(\"found\\n\"));\n\t\t}\n\t} else {\n\t\t/* Convert mac address string to ether_addr struct */\n#if defined(__APPLE__)\n\t\tstruct ether_addr* dstmac_buf = ether_aton(address);\n\t\tmemcpy(dstmac, dstmac_buf, sizeof(struct ether_addr));\n#else\n\t\tether_aton_r(address, (struct ether_addr *)dstmac);\n#endif\n\t}\n\n\treturn 1;\n}\n"], "fixing_code": ["/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _BSD_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#if defined(__APPLE__)\n# include <libkern/OSByteOrder.h>\n# define htole16 OSSwapHostToLittleInt16\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <net/ethernet.h>\n#else\n#include <netinet/ether.h>\n#endif\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <string.h>\n#ifdef __linux__\n#include <linux/if_ether.h>\n#include <sys/mman.h>\n#endif\n#include \"md5.h\"\n#include \"protocol.h\"\n#include \"console.h\"\n#include \"interfaces.h\"\n#include \"config.h\"\n#include \"mactelnet.h\"\n#include \"mndp.h\"\n#include \"autologin.h\"\n#include \"utlist.h\"\n\n#define PROGRAM_NAME \"MAC-Telnet\"\n\n#define _(String) gettext (String)\n\nstatic int sockfd = 0;\nstatic int insockfd;\n\nstatic unsigned int outcounter = 0;\nstatic long incounter = -1;\nstatic int sessionkey = 0;\nstatic int running = 1;\n\nstatic unsigned char use_raw_socket = 0;\nstatic unsigned char terminal_mode = 0;\n\nstatic unsigned char srcmac[ETH_ALEN];\nstatic unsigned char dstmac[ETH_ALEN];\n\nstatic struct in_addr sourceip; \nstatic struct in_addr destip;\nstatic int sourceport;\n\nstatic int connect_timeout = CONNECT_TIMEOUT;\nstatic char run_mndp = 0;\nstatic int mndp_timeout = 0;\n\nstatic int is_a_tty = 1;\nstatic int quiet_mode = 0;\nstatic int batch_mode = 0;\nstatic int no_autologin = 0;\n\nstatic char autologin_path[255];\n\nstatic int keepalive_counter = 0;\n\nstatic unsigned char pass_salt[16];\nstatic char username[MT_MNDP_MAX_STRING_SIZE];\nstatic char password[MT_MNDP_MAX_STRING_SIZE];\nstatic char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];\n\nstruct net_interface *interfaces=NULL;\nstruct net_interface *active_interface;\n\n/* Protocol data direction */\nunsigned char mt_direction_fromserver = 0;\n\nstatic unsigned int send_socket;\n\nstatic int handle_packet(unsigned char *data, int data_len);\n\nstatic void print_version() {\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\n}\n\nvoid drop_privileges(char *username) {\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\n\tif (user == NULL) {\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\n\t\texit(1);\n\t}\n\tif (getuid() == 0) {\n\t\t/* process is running as root, drop privileges */\n\t\tif (setgid(user->pw_gid) != 0) {\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tif (setuid(user->pw_uid) != 0) {\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/* Verify if the privileges were developed. */\n\t\tif (setuid(0) != -1) {\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic int send_udp(struct mt_packet *packet, int retransmit) {\n\tint sent_bytes;\n\n\t/* Clear keepalive counter */\n\tkeepalive_counter = 0;\n\n\tif (!use_raw_socket) {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t} else {\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\n\t}\n\n\t/* \n\t * Retransmit packet if no data is received within\n\t * retransmit_intervals milliseconds.\n\t */\n\tif (retransmit) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\n\t\t\tfd_set read_fds;\n\t\t\tint reads;\n\t\t\tstruct timeval timeout;\n\t\t\tint interval = retransmit_intervals[i] * 1000;\n\n\t\t\t/* Init select */\n\t\t\tFD_ZERO(&read_fds);\n\t\t\tFD_SET(insockfd, &read_fds);\n\t\t\ttimeout.tv_sec = 0;\n\t\t\ttimeout.tv_usec = interval;\n\n\t\t\t/* Wait for data or timeout */\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tint result;\n\n\t\t\t\tbzero(buff, sizeof(buff));\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\n\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\n\t\t\t\t\treturn sent_bytes;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Retransmit */\n\t\t\tsend_udp(packet, 0);\n\t\t}\n\n\t\tif (is_a_tty && terminal_mode) {\n\t\t\treset_term();\n\t\t}\n\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\n\t\texit(1);\n\t}\n\treturn sent_bytes;\n}\n\nstatic void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen, act_pass_len;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* calculate the actual password's length */\n\tact_pass_len = strnlen(password, 82);\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tmemcpy(md5data + 1, password, act_pass_len);\n\t/* in case that password is long, calculate only using the used-up parts */\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}\n\nstatic void sig_winch(int sig) {\n\tunsigned short width,height;\n\tstruct mt_packet data;\n\tint plen;\n\n\t/* terminal height/width has changed, inform server */\n\tif (get_terminal_size(&width, &height) != -1) {\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t\toutcounter += plen;\n\n\t\tsend_udp(&data, 1);\n\t}\n\n\t/* reinstate signal handler */\n\tsignal(SIGWINCH, sig_winch);\n}\n\nstatic int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\n\t\t\t\tif (cpkt.length != 16) {\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n\t\t\t\t}\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}\n\nstatic int find_interface() {\n\tfd_set read_fds;\n\tstruct mt_packet data;\n\tstruct sockaddr_in myip;\n\tunsigned char emptymac[ETH_ALEN];\n\tint testsocket;\n\tstruct timeval timeout;\n\tint optval = 1;\n\tstruct net_interface *interface;\n\n\t/* TODO: reread interfaces on HUP */\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\n\n\tbzero(emptymac, ETH_ALEN);\n\n\tif (net_get_interfaces(&interfaces) <= 0) {\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\n\t\texit(1);\n\t}\n\n\tDL_FOREACH(interfaces, interface) {\n\t\t/* Skip loopback interfaces */\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize receiving socket on the device chosen */\n\t\tmyip.sin_family = AF_INET;\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\n\t\tmyip.sin_port = htons(sourceport);\n\n\t\t/* Initialize socket and bind to udp port */\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\n\t\t\tclose(testsocket);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure that we have mac-address for this interface  */\n\t\tif (!interface->has_mac) {\n\t\t\tclose(testsocket);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Set the global socket handle and source mac address for send_udp() */\n\t\tsend_socket = testsocket;\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\n\t\tactive_interface = interface;\n\n\t\t/* Send a SESSIONSTART message with the current device */\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\n\t\tsend_udp(&data, 0);\n\n\t\ttimeout.tv_sec = connect_timeout;\n\t\ttimeout.tv_usec = 0;\n\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(insockfd, &read_fds);\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t/* We got a response, this is the correct device to use */\n\t\t\treturn 1;\n\t\t}\n\n\t\tclose(testsocket);\n\t}\n\treturn 0;\n}\n\n/*\n * TODO: Rewrite main() when all sub-functionality is tested\n */\nint main (int argc, char **argv) {\n\tint result;\n\tstruct mt_packet data;\n\tstruct sockaddr_in si_me;\n\tstruct autologin_profile *login_profile;\n\tstruct net_interface *interface, *tmp;\n\tunsigned char buff[MT_PACKET_LEN];\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\n\tunsigned char drop_priv = 0;\n\tint c;\n\tint optval = 1;\n\n\tstrncpy(autologin_path, AUTOLOGIN_PATH, sizeof(autologin_path));\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\twhile (1) {\n\t\tc = getopt(argc, argv, \"lnqt:u:p:U:vh?BAa:\");\n\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u':\n\t\t\t\t/* Save username */\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t\thave_username = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\t/* Save password */\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\t\tmlock(password, sizeof(password));\n#endif\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t\thave_password = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\t\t/* Save nonpriv_username */\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\n\t\t\t\tdrop_priv = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tconnect_timeout = atoi(optarg);\n\t\t\t\tmndp_timeout = connect_timeout;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'q':\n\t\t\t\tquiet_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\trun_mndp = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'B':\n\t\t\t\tbatch_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'A':\n\t\t\t\tno_autologin = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\tstrncpy(autologin_path, optarg, sizeof(autologin_path) - 1);\n\t\t\t\tautologin_path[sizeof(autologin_path) - 1] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\tif (run_mndp) {\n\t\treturn mndp(mndp_timeout, batch_mode);\n\t}\n\tif (argc - optind < 1 || print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-h] [-n] [-a <path>] [-A] [-t <timeout>] [-u <user>] [-p <password>] [-U <user>] | -l [-B] [-t <timeout>]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  MAC            MAC-Address of the RouterOS/mactelnetd device. Use mndp to\\n\"\n\t\t\t\"                 discover it.\\n\"\n\t\t\t\"  identity       The identity/name of your destination device. Uses\\n\"\n\t\t\t\"                 MNDP protocol to find it.\\n\"\n\t\t\t\"  -l             List/Search for routers nearby (MNDP). You may use -t to set timeout.\\n\"\n\t\t\t\"  -B             Batch mode. Use computer readable output (CSV), for use with -l.\\n\"\n\t\t\t\"  -n             Do not use broadcast packets. Less insecure but requires\\n\"\n\t\t\t\"                 root privileges.\\n\"\n\t\t\t\"  -a <path>      Use specified path instead of the default: \" AUTOLOGIN_PATH \" for autologin config file.\\n\"\n\t\t\t\"  -A             Disable autologin feature.\\n\"\n\t\t\t\"  -t <timeout>   Amount of seconds to wait for a response on each interface.\\n\"\n\t\t\t\"  -u <user>      Specify username on command line.\\n\"\n\t\t\t\"  -p <password>  Specify password on command line.\\n\"\n\t\t\t\"  -U <user>      Drop privileges to this user. Used in conjunction with -n\\n\"\n\t\t\t\"                 for security.\\n\"\n\t\t\t\"  -q             Quiet mode.\\n\"\n\t\t\t\"  -h             This help.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\n\tif (!is_a_tty) {\n\t\tquiet_mode = 1;\n\t}\n\n\tif (!no_autologin) {\n\t\tautologin_readfile(autologin_path);\n\t\tlogin_profile = autologin_find_profile(argv[optind]);\n\n\t\tif (!quiet_mode && login_profile != NULL && (login_profile->hasUsername || login_profile->hasPassword)) {\n\t\t\tfprintf(stderr, _(\"Using autologin credentials from %s\\n\"), autologin_path);\n\t\t}\n\t\tif (!have_username) {\n\t\t\tif (login_profile != NULL && login_profile->hasUsername) {\n\t\t\t\thave_username = 1;\n\t\t\t\tstrncpy(username, login_profile->username, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (!have_password) {\n\t\t\tif (login_profile != NULL && login_profile->hasPassword) {\n\t\t\t\thave_password = 1;\n\t\t\t\tstrncpy(password, login_profile->password, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\tif (geteuid() != 0) {\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsockfd = net_init_raw_socket();\n\n\t\tif (drop_priv) {\n\t\t\tdrop_privileges(nonpriv_username);\n\t\t}\n\t} else if (drop_priv) {\n\t\tfprintf(stderr, _(\"The -U option must be used in conjunction with the -n parameter.\\n\"));\n\t\treturn 1;\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\tif (!use_raw_socket) {\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\tperror(\"SO_BROADCAST\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Need to use, to be able to autodetect which interface to use */\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Get mac-address from string, or check for hostname via mndp */\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\n\t\t/* No valid mac address found, abort */\n\t\treturn 1;\n\t}\n\n\tif (!have_username) {\n\t\tif (!quiet_mode) {\n\t\t\tprintf(_(\"Login: \"));\n\t\t\tfflush(stdout);\n\t\t}\n\t\tscanf(\"%127s\", username);\n\t}\n\n\tif (!have_password) {\n\t\tchar *tmp;\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(password, sizeof(password));\n#endif\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\n\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t/* security */\n\t\tmemset(tmp, 0, strlen(tmp));\n#ifdef __linux__\n\t\tfree(tmp);\n#endif\n\t}\n\n\n\t/* Set random source port */\n\tsourceport = 1024 + (rand() % 1024);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\n\n\t/* Session key */\n\tsessionkey = rand() % 65535;\n\n\t/* stop output buffering */\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\n\n\tif (!quiet_mode) {\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\n\t}\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0)) < 1) {\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\n\t\treturn 1;\n\t}\n\tif (!quiet_mode) {\n\t\tprintf(_(\"done\\n\"));\n\t}\n\n\t/* Handle first received packet */\n\thandle_packet(buff, result);\n\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\n\toutcounter += add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\n\n\t/* TODO: handle result of send_udp */\n\tresult = send_udp(&data, 1);\n\n\twhile (running) {\n\t\tfd_set read_fds;\n\t\tint reads;\n\t\tstatic int terminal_gone = 0;\n\t\tstruct timeval timeout;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tif (!terminal_gone) {\n\t\t\tFD_SET(0, &read_fds);\n\t\t}\n\t\tFD_SET(insockfd, &read_fds);\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(insockfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from server */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tbzero(buff, sizeof(buff));\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\n\t\t\t\thandle_packet(buff, result);\n\t\t\t}\n\t\t\t/* Handle data from keyboard/local terminal */\n\t\t\tif (FD_ISSET(0, &read_fds) && terminal_mode) {\n\t\t\t\tunsigned char keydata[512];\n\t\t\t\tint datalen;\n\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, sizeof(keydata));\n\n\t\t\t\tif (datalen > 0) {\n\t\t\t\t\t/* Data received, transmit to server */\n\t\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\t\toutcounter += datalen;\n\t\t\t\t\tsend_udp(&data, 1);\n\t\t\t\t} else {\n\t\t\t\t\tterminal_gone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t} else {\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\n\t\t\t   of inactivity  */\n\t\t\tif (keepalive_counter++ == 10) {\n\t\t\t\tstruct mt_packet odata;\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tsend_udp(&odata, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_a_tty && terminal_mode) {\n\t\t/* Reset terminal back to old settings */\n\t\treset_term();\n\t}\n\n\tclose(sockfd);\n\tclose(insockfd);\n\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\tDL_DELETE(interfaces, interface);\n\t\tfree(interface);\n\t}\n\n\treturn 0;\n}\n", "/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _POSIX_C_SOURCE 199309L\n#define _XOPEN_SOURCE 600\n#define _BSD_SOURCE\n#define _DARWIN_C_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#if defined(__APPLE__)\n# include <sys/sysctl.h>\n# include <libkern/OSByteOrder.h>\n# define le16toh OSSwapLittleToHostInt16\n# define htole32 OSSwapHostToLittleInt32\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <paths.h>\n#endif\n#include <time.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <net/ethernet.h>\n#include <netinet/in.h>\n#if !defined(__FreeBSD__) && !defined(__APPLE__)\n#include <netinet/ether.h>\n#endif\n#include <sys/time.h>\n#include <time.h>\n#include <sys/socket.h>\n#include <string.h>\n#ifdef __linux__\n#include <linux/if_ether.h>\n#include <sys/mman.h>\n#else\n#include <sys/time.h>\n#endif\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#if defined(__linux__)\n#include <sys/sysinfo.h>\n#endif\n#include <pwd.h>\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <sys/time.h>\n/* This is the really Posix interface the Linux code should have used !!*/\n#include <utmpx.h>\n#else\n#include <utmp.h>\n#endif\n#include <syslog.h>\n#include <sys/utsname.h>\n#include \"md5.h\"\n#include \"protocol.h\"\n#include \"console.h\"\n#include \"interfaces.h\"\n#include \"users.h\"\n#include \"config.h\"\n#include \"utlist.h\"\n\n#define PROGRAM_NAME \"MAC-Telnet Daemon\"\n\n#define MAX_INSOCKETS 100\n\n#define MT_INTERFACE_LEN 128\n\n/* Max ~5 pings per second */\n#define MT_MAXPPS MT_MNDP_BROADCAST_INTERVAL * 5\n\n#define _(String) gettext (String)\n#define gettext_noop(String) String\n\nstatic int sockfd;\nstatic int insockfd;\nstatic int mndpsockfd;\n\nstatic int pings = 0;\n\nstruct net_interface *interfaces = NULL;\n\nstatic int use_raw_socket = 0;\n\nstatic struct in_addr sourceip; \nstatic struct in_addr destip;\nstatic int sourceport;\n\nstatic time_t last_mndp_time = 0;\n\n/* Protocol data direction */\nunsigned char mt_direction_fromserver = 1;\n\n/* Anti-timeout is every 10 seconds. Give up after 15. */\n#define MT_CONNECTION_TIMEOUT 15\n\n/* Connection states */\nenum mt_connection_state {\n\tSTATE_AUTH,\n\tSTATE_CLOSED,\n\tSTATE_ACTIVE\n};\n\n/** Connection struct */\nstruct mt_connection {\n\tstruct net_interface *interface;\n\tchar interface_name[256];\n\n\tunsigned short seskey;\n\tunsigned int incounter;\n\tunsigned int outcounter;\n\tunsigned int lastack;\n\ttime_t lastdata;\n\n\tint terminal_mode;\n\tenum mt_connection_state state;\n\tint ptsfd;\n\tint slavefd;\n\tint pid;\n\tint wait_for_ack;\n\tint have_pass_salt;\n\n\tchar username[MT_MNDP_MAX_STRING_SIZE];\n\tunsigned char trypassword[17];\n\tunsigned char srcip[IPV4_ALEN];\n\tunsigned char srcmac[ETH_ALEN];\n\tunsigned short srcport;\n\tunsigned char dstmac[ETH_ALEN];\n\tunsigned char pass_salt[16];\n\tunsigned short terminal_width;\n\tunsigned short terminal_height;\n\tchar terminal_type[30];\n\n\tstruct mt_connection *prev;\n\tstruct mt_connection *next;\n};\n\nstatic void uwtmp_login(struct mt_connection *);\nstatic void uwtmp_logout(struct mt_connection *);\n\nstatic struct mt_connection *connections_head = NULL;\n\nstatic void list_add_connection(struct mt_connection *conn) {\n\tDL_APPEND(connections_head, conn);\n}\n\nstatic void list_remove_connection(struct mt_connection *conn) {\n\tif (connections_head == NULL) {\n\t\treturn;\n\t}\n\n\tif (conn->state == STATE_ACTIVE && conn->ptsfd > 0) {\n\t\tclose(conn->ptsfd);\n\t}\n\tif (conn->state == STATE_ACTIVE && conn->slavefd > 0) {\n\t\tclose(conn->slavefd);\n\t}\n\n\tuwtmp_logout(conn);\n\n\tDL_DELETE(connections_head, conn);\n\tfree(conn);\n}\n\nstatic struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {\n\tstruct mt_connection *p;\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_interface *find_socket(unsigned char *mac) {\n\tstruct net_interface *interface;\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tif (memcmp(mac, interface->mac_addr, ETH_ALEN) == 0) {\n\t\t\treturn interface;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void setup_sockets() {\n\tstruct net_interface *interface;\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tint optval = 1;\n\t\tstruct sockaddr_in si_me;\n\t\tstruct ether_addr *mac = (struct ether_addr *)&(interface->mac_addr);\n\n\t\tif (!interface->has_mac) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!use_raw_socket) {\n\t\t\tinterface->socketfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\t\t\tif (interface->socketfd < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (setsockopt(interface->socketfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\t\tperror(\"SO_BROADCAST\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsetsockopt(interface->socketfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t\t\t/* Initialize receiving socket on the device chosen */\n\t\t\tsi_me.sin_family = AF_INET;\n\t\t\tsi_me.sin_port = htons(MT_MACTELNET_PORT);\n\t\t\tmemcpy(&(si_me.sin_addr.s_addr), interface->ipv4_addr, IPV4_ALEN);\n\n\t\t\tif (bind(interface->socketfd, (struct sockaddr *)&si_me, sizeof(si_me))==-1) {\n\t\t\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsyslog(LOG_NOTICE, _(\"Listening on %s for %s\\n\"), interface->name, ether_ntoa(mac));\n\n\t}\n}\n\nstatic int send_udp(const struct mt_connection *conn, const struct mt_packet *packet) {\n\tif (use_raw_socket) {\n\t\treturn net_send_udp(sockfd, conn->interface, conn->dstmac, conn->srcmac, &sourceip, sourceport, &destip, conn->srcport, packet->data, packet->size);\n\t} else {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(conn->srcport);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\treturn sendto(conn->interface->socketfd, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t}\n}\n\nstatic int send_special_udp(struct net_interface *interface, unsigned short port, const struct mt_packet *packet) {\n\tunsigned char dstmac[ETH_ALEN];\n\n\tif (use_raw_socket) {\n\t\tmemset(dstmac, 0xff, ETH_ALEN);\n\t\treturn net_send_udp(sockfd, interface, interface->mac_addr, dstmac, (const struct in_addr *)&interface->ipv4_addr, port, &destip, port, packet->data, packet->size);\n\t} else {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(port);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\treturn sendto(interface->socketfd, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t}\n}\n\n\nstatic void display_motd() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(\"/etc/motd\", \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n\nstatic void display_nologin() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(_PATH_NOLOGIN, \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n\nstatic void uwtmp_login(struct mt_connection *conn) {\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tstruct utmpx utent;\n#else\n\tstruct utmp utent;\n#endif\n\tpid_t pid;\n\n\tpid = getpid();\n\n\tchar *line = ttyname(conn->slavefd);\n\tif (strncmp(line, \"/dev/\", 5) == 0) {\n\t\tline += 5;\n\t}\n\n\t/* Setup utmp struct */\n\tmemset((void *) &utent, 0, sizeof(utent));\n\tutent.ut_type = USER_PROCESS;\n\tutent.ut_pid = pid;\n\tstrncpy(utent.ut_user, conn->username, sizeof(utent.ut_user));\n\tstrncpy(utent.ut_line, line, sizeof(utent.ut_line));\n\tstrncpy(utent.ut_id, utent.ut_line + 3, sizeof(utent.ut_id));\n\tstrncpy(utent.ut_host,\n                ether_ntoa((const struct ether_addr *)conn->srcmac),\n                sizeof(utent.ut_host));\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tgettimeofday(&utent.ut_tv, NULL);\n#else\n\ttime((time_t *)&(utent.ut_time));\n#endif\n\n\t/* Update utmp and/or wtmp */\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tsetutxent();\n\tpututxline(&utent);\n\tendutxent();\n#else\n\tsetutent();\n\tpututline(&utent);\n\tendutent();\n\tupdwtmp(_PATH_WTMP, &utent);\n#endif\n}\n\nstatic void uwtmp_logout(struct mt_connection *conn) {\n\tif (conn->pid > 0) {\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\tstruct utmpx *utentp;\n\t\tstruct utmpx utent;\n\t\tsetutxent();\n#else\n\t\tstruct utmp *utentp;\n\t\tstruct utmp utent;\n\t\tsetutent();\n#endif\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\twhile ((utentp = getutxent()) != NULL) {\n#else\n\t\twhile ((utentp = getutent()) != NULL) {\n#endif\n\t\t\tif (utentp->ut_pid == conn->pid && utentp->ut_id) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (utentp) {\n\t\t\tutent = *utentp;\n\n\t\t\tutent.ut_type = DEAD_PROCESS;\n\t\t\tutent.ut_tv.tv_sec = time(NULL);\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\t\tpututxline(&utent);\n\t\t\tendutxent();\n#else\n\t\t\tpututline(&utent);\n\t\t\tendutent();\n\t\t\tupdwtmp(_PATH_WTMP, &utent);\n#endif\n\t\t}\n\t}\n}\n\nstatic void abort_connection(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, char *message) {\n\tstruct mt_packet pdata;\n\n\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, message, strlen(message));\n\tsend_udp(curconn, &pdata);\n\n\t/* Make connection time out; lets the previous message get acked before disconnecting */\n\tcurconn->state = STATE_CLOSED;\n\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\tsend_udp(curconn, &pdata);\n}\n\nstatic void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\tint act_pass_len;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* calculate the password's actual length */\n\t\tact_pass_len = strlen(user->password);\n\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}\n\nstatic void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}\n\nstatic void handle_packet(unsigned char *data, int data_len, const struct sockaddr_in *address) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\tstruct mt_connection *curconn = NULL;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface;\n\n\t/* Check for minimal size */\n\tif (data_len < MT_HEADER_LEN - 4) {\n\t\treturn;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* Drop packets not belonging to us */\n\tif ((interface = find_socket(pkthdr.dstaddr)) < 0) {\n\t\treturn;\n\t}\n\n\tswitch (pkthdr.ptype) {\n\n\t\tcase MT_PTYPE_PING:\n\t\t\tif (pings++ > MT_MAXPPS) {\n\t\t\t\t/* Don't want it to wrap around back to the valid range */\n\t\t\t\tpings--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinit_pongpacket(&pdata, (unsigned char *)&(pkthdr.dstaddr), (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tadd_packetdata(&pdata, pkthdr.data - 4, data_len - (MT_HEADER_LEN - 4));\n\t\t\t{\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tsend_special_udp(interface, MT_MACTELNET_PORT, &pdata);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MT_PTYPE_SESSIONSTART:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn != NULL) {\n\t\t\t\t/* Ignore multiple session starts from the same sender, this can be same mac but different interface */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsyslog(LOG_DEBUG, _(\"(%d) New connection from %s.\"), pkthdr.seskey, ether_ntoa((struct ether_addr*)&(pkthdr.srcaddr)));\n\t\t\tcurconn = calloc(1, sizeof(struct mt_connection));\n\t\t\tcurconn->seskey = pkthdr.seskey;\n\t\t\tcurconn->lastdata = time(NULL);\n\t\t\tcurconn->state = STATE_AUTH;\n\t\t\tcurconn->interface = interface;\n\t\t\tstrncpy(curconn->interface_name, interface->name, 254);\n\t\t\tcurconn->interface_name[255] = '\\0';\n\t\t\tmemcpy(curconn->srcmac, pkthdr.srcaddr, ETH_ALEN);\n\t\t\tmemcpy(curconn->srcip, &(address->sin_addr), IPV4_ALEN);\n\t\t\tcurconn->srcport = htons(address->sin_port);\n\t\t\tmemcpy(curconn->dstmac, pkthdr.dstaddr, ETH_ALEN);\n\n\t\t\tlist_add_connection(curconn);\n\n\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\tbreak;\n\n\t\tcase MT_PTYPE_END:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (curconn->state != STATE_CLOSED) {\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t\tsyslog(LOG_DEBUG, _(\"(%d) Connection closed.\"), curconn->seskey);\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\n\t\tcase MT_PTYPE_ACK:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pkthdr.counter <= curconn->outcounter) {\n\t\t\t\tcurconn->wait_for_ack = 0;\n\t\t\t\tcurconn->lastack = pkthdr.counter;\n\t\t\t}\n\n\t\t\tif (time(0) - curconn->lastdata > 9 || pkthdr.counter == curconn->lastack) {\n\t\t\t\t// Answer to anti-timeout packet\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t\tcurconn->lastdata = time(NULL);\n\t\t\treturn;\n\n\t\tcase MT_PTYPE_DATA:\n\t\t\tcurconn = list_find_connection(pkthdr.seskey, (unsigned char *)&(pkthdr.srcaddr));\n\t\t\tif (curconn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurconn->lastdata = time(NULL);\n\n\t\t\t/* now check the right size */\n\t\t\tif (data_len < MT_HEADER_LEN) {\n\t\t\t\t/* Ignore illegal packet */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* ack the data packet */\n\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\t\tsend_udp(curconn, &pdata);\n\n\t\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\t\twrapped around. */\n\t\t\tif (curconn->incounter == 0 || pkthdr.counter > curconn->incounter || (curconn->incounter - pkthdr.counter) > 16777216) {\n\t\t\t\tcurconn->incounter = pkthdr.counter;\n\t\t\t} else {\n\t\t\t\t/* Ignore double or old packets */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thandle_data_packet(curconn, &pkthdr, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (curconn) {\n\t\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled packet type: %d\"), curconn->seskey, pkthdr.ptype);\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_ACK, pkthdr.dstaddr, pkthdr.srcaddr, pkthdr.seskey, pkthdr.counter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t}\n\t\t}\n\tif (0 && curconn != NULL) {\n\t\tprintf(\"Packet, incounter %d, outcounter %d\\n\", curconn->incounter, curconn->outcounter);\n\t}\n}\n\nstatic void print_version() {\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\n}\n\nvoid mndp_broadcast() {\n\tstruct mt_packet pdata;\n\tstruct utsname s_uname;\n\tstruct net_interface *interface;\n\tunsigned int uptime;\n#if defined(__APPLE__)\n\tint mib[] = {CTL_KERN, KERN_BOOTTIME};\n\tstruct timeval boottime;\n\tsize_t tv_size = sizeof(boottime);\n\tif (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &boottime, &tv_size, NULL, 0) == -1) {\n\t  return;\n\t}\n\tuptime = htole32(boottime.tv_sec);\n#elif defined(__linux__)\n\tstruct sysinfo s_sysinfo;\n\n\tif (sysinfo(&s_sysinfo) != 0) {\n\t\treturn;\n\t}\n\n\t/* Seems like ping uptime is transmitted as little endian? */\n\tuptime = htole32(s_sysinfo.uptime);\n#else\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_UPTIME, &ts) != -1) {\n\t\tuptime = htole32(((unsigned int)ts.tv_sec));\n\t}\n#endif\n\n\tif (uname(&s_uname) != 0) {\n\t\treturn;\n\t}\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tstruct mt_mndp_hdr *header = (struct mt_mndp_hdr *)&(pdata.data);\n\n\t\tif (interface->has_mac == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmndp_init_packet(&pdata, 0, 1);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_ADDRESS, interface->mac_addr, ETH_ALEN);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_IDENTITY, s_uname.nodename, strlen(s_uname.nodename));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_VERSION, s_uname.release, strlen(s_uname.release));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_PLATFORM, PLATFORM_NAME, strlen(PLATFORM_NAME));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_HARDWARE, s_uname.machine, strlen(s_uname.machine));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_TIMESTAMP, &uptime, 4);\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_SOFTID, MT_SOFTID_MACTELNET, strlen(MT_SOFTID_MACTELNET));\n\t\tmndp_add_attribute(&pdata, MT_MNDPTYPE_IFNAME, interface->name, strlen(interface->name));\n\n\t\theader->cksum = in_cksum((unsigned short *)&(pdata.data), pdata.size);\n\t\tsend_special_udp(interface, MT_MNDP_PORT, &pdata);\n\t}\n}\n\nvoid sigterm_handler() {\n\tstruct mt_connection *p;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface, *tmp;\n\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\tchar message[] = gettext_noop(\"\\r\\n\\r\\nDaemon shutting down.\\r\\n\");\n\n\tsyslog(LOG_NOTICE, _(\"Daemon shutting down\"));\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->state == STATE_ACTIVE) {\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->interface->mac_addr, p->srcmac, p->seskey, p->outcounter);\n\t\t\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, _(message), strlen(_(message)));\n\t\t\tsend_udp(p, &pdata);\n\n\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->interface->mac_addr, p->srcmac, p->seskey, p->outcounter);\n\t\t\tsend_udp(p, &pdata);\n\t\t}\n\t}\n\n\t/* Doesn't hurt to tidy up */\n\tclose(sockfd);\n\tclose(insockfd);\n\tif (!use_raw_socket) {\n\t\tDL_FOREACH(interfaces, interface) {\n\t\t\tif (interface->socketfd > 0)\n\t\t\t\tclose(interface->socketfd);\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\tDL_DELETE(interfaces, interface);\n\t\tfree(interface);\n\t}\n\tcloselog();\n\texit(0);\n}\n\nvoid sighup_handler() {\n\tstruct mt_connection *p;\n\n\tsyslog(LOG_NOTICE, _(\"SIGHUP: Reloading interfaces\"));\n\n\tif (!use_raw_socket) {\n\t\tstruct net_interface *interface, *tmp;\n\t\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\n\t\t\tclose(interface->socketfd);\n\t\t\tDL_DELETE(interfaces, interface);\n\t\t\tfree(interface);\n\t\t}\n\t\tinterfaces = NULL;\n\t}\n\n\tif (net_get_interfaces(&interfaces) <= 0) {\n\t\tsyslog(LOG_ERR, _(\"No devices found! Exiting.\\n\"));\n\t\texit(1);\n\t}\n\n\tsetup_sockets();\n\n\t/* Reassign outgoing interfaces to connections again, since they may have changed */\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->interface_name != NULL) {\n\t\t\tstruct net_interface *interface = net_get_interface_ptr(&interfaces, p->interface_name, 0);\n\t\t\tif (interface != NULL) {\n\t\t\t\tp->interface = interface;\n\t\t\t} else {\n\t\t\t\tstruct mt_connection tmp;\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) Connection closed because interface %s is gone.\"), p->seskey, p->interface_name);\n\t\t\t\ttmp.next = p->next;\n\t\t\t\tlist_remove_connection(p);\n\t\t\t\tp = &tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * TODO: Rewrite main() when all sub-functionality is tested\n */\nint main (int argc, char **argv) {\n\tint result;\n\tstruct sockaddr_in si_me;\n\tstruct sockaddr_in si_me_mndp;\n\tstruct timeval timeout;\n\tstruct mt_packet pdata;\n\tstruct net_interface *interface;\n\tfd_set read_fds;\n\tint c,optval = 1;\n\tint print_help = 0;\n\tint foreground = 0;\n\tint interface_count = 0;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\twhile ((c = getopt(argc, argv, \"fnvh?\")) != -1) {\n\t\tswitch (c) {\n\t\t\tcase 'f':\n\t\t\t\tforeground = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tif (print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s [-f|-n|-h]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  -f        Run process in foreground.\\n\"\n\t\t\t\"  -n        Do not use broadcast packets. Just a tad less insecure.\\n\"\n\t\t\t\"  -h        This help.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, _(\"You need to have root privileges to use %s.\\n\"), argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* Try to read user file */\n\tread_userfile();\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\t/* Transmit raw packets with this socket */\n\t\tsockfd = net_init_raw_socket();\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\t/* Set source port */\n\tsourceport = MT_MACTELNET_PORT;\n\n\t/* Listen address*/\n\tinet_pton(AF_INET, (char *)\"0.0.0.0\", &sourceip);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\tmemcpy(&(si_me.sin_addr), &sourceip, IPV4_ALEN);\n\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me))==-1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\t/* TODO: Move socket initialization out of main() */\n\n\t/* Receive mndp udp packets with this socket */\n\tmndpsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (mndpsockfd < 0) {\n\t\tperror(\"mndpsockfd\");\n\t\treturn 1;\n\t}\n\n\tmemset((char *)&si_me_mndp, 0, sizeof(si_me_mndp));\n\tsi_me_mndp.sin_family = AF_INET;\n\tsi_me_mndp.sin_port = htons(MT_MNDP_PORT);\n\tmemcpy(&(si_me_mndp.sin_addr), &sourceip, IPV4_ALEN);\n\n\tsetsockopt(mndpsockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Bind to udp port */\n\tif (bind(mndpsockfd, (struct sockaddr *)&si_me_mndp, sizeof(si_me_mndp))==-1) {\n\t\tfprintf(stderr, _(\"MNDP: Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me_mndp.sin_addr), MT_MNDP_PORT, strerror(errno));\n\t}\n\n\topenlog(\"mactelnetd\", LOG_PID, LOG_DAEMON);\n\tsyslog(LOG_NOTICE, _(\"Bound to %s:%d\"), inet_ntoa(si_me.sin_addr), sourceport);\n\n\t/* Enumerate available interfaces */\n\tnet_get_interfaces(&interfaces);\n\n\tsetup_sockets();\n\n\tif (!foreground) {\n\t\tdaemon(0, 0);\n\t}\n\n\t/* Handle zombies etc */\n\tsignal(SIGCHLD,SIG_IGN);\n\tsignal(SIGTSTP,SIG_IGN);\n\tsignal(SIGTTOU,SIG_IGN);\n\tsignal(SIGTTIN,SIG_IGN);\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\n\tDL_FOREACH(interfaces, interface) {\n\t\tif (interface->has_mac) {\n\t\t\tinterface_count++;\n\t\t}\n\t}\n\n\tif (interface_count == 0) {\n\t\tsyslog(LOG_ERR, _(\"Unable to find any valid network interfaces\\n\"));\n\t\texit(1);\n\t}\n\n\twhile (1) {\n\t\tint reads;\n\t\tstruct mt_connection *p;\n\t\tint maxfd=0;\n\t\ttime_t now;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(insockfd, &read_fds);\n\t\tFD_SET(mndpsockfd, &read_fds);\n\t\tmaxfd = insockfd > mndpsockfd ? insockfd : mndpsockfd;\n\n\t\t/* Add active connections to select queue */\n\t\tDL_FOREACH(connections_head, p) {\n\t\t\tif (p->state == STATE_ACTIVE && p->wait_for_ack == 0 && p->ptsfd > 0) {\n\t\t\t\tFD_SET(p->ptsfd, &read_fds);\n\t\t\t\tif (p->ptsfd > maxfd) {\n\t\t\t\t\tmaxfd = p->ptsfd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(maxfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from clients\n\t\t\t TODO: Enable broadcast support (without raw sockets)\n\t\t\t */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tstruct sockaddr_in saddress;\n\t\t\t\tunsigned int slen = sizeof(saddress);\n\t\t\t\tbzero(buff, MT_HEADER_LEN);\n\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, (struct sockaddr *)&saddress, &slen);\n\t\t\t\thandle_packet(buff, result, &saddress);\n\t\t\t}\n\t\t\tif (FD_ISSET(mndpsockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tstruct sockaddr_in saddress;\n\t\t\t\tunsigned int slen = sizeof(saddress);\n\t\t\t\tresult = recvfrom(mndpsockfd, buff, sizeof(buff), 0, (struct sockaddr *)&saddress, &slen);\n\n\t\t\t\t/* Handle MNDP broadcast request, max 1 rps */\n\t\t\t\tif (result == 4 && time(NULL) - last_mndp_time > 0) {\n\t\t\t\t\tmndp_broadcast();\n\t\t\t\t\ttime(&last_mndp_time);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Handle data from terminal sessions */\n\t\t\tDL_FOREACH(connections_head, p) {\n\t\t\t\t/* Check if we have data ready in the pty buffer for the active session */\n\t\t\t\tif (p->state == STATE_ACTIVE && p->ptsfd > 0 && p->wait_for_ack == 0 && FD_ISSET(p->ptsfd, &read_fds)) {\n\t\t\t\t\tunsigned char keydata[1024];\n\t\t\t\t\tint datalen,plen;\n\n\t\t\t\t\t/* Read it */\n\t\t\t\t\tdatalen = read(p->ptsfd, &keydata, sizeof(keydata));\n\t\t\t\t\tif (datalen > 0) {\n\t\t\t\t\t\t/* Send it */\n\t\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\t\t\tp->outcounter += plen;\n\t\t\t\t\t\tp->wait_for_ack = 1;\n\t\t\t\t\t\tresult = send_udp(p, &pdata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Shell exited */\n\t\t\t\t\t\tstruct mt_connection tmp;\n\t\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t\tsend_udp(p, &pdata);\n\t\t\t\t\t\tif (p->username != NULL) {\n\t\t\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Connection to user %s closed.\"), p->seskey, p->username);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Connection closed.\"), p->seskey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.next = p->next;\n\t\t\t\t\t\tlist_remove_connection(p);\n\t\t\t\t\t\tp = &tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (p->state == STATE_ACTIVE && p->ptsfd > 0 && p->wait_for_ack == 1 && FD_ISSET(p->ptsfd, &read_fds)) {\n\t\t\t\t\tprintf(_(\"(%d) Waiting for ack\\n\"), p->seskey);\n\t\t\t\t}\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t}\n\t\ttime(&now);\n\n\t\tif (now - last_mndp_time > MT_MNDP_BROADCAST_INTERVAL) {\n\t\t\tpings = 0;\n\t\t\tmndp_broadcast();\n\t\t\tlast_mndp_time = now;\n\t\t}\n\t\tif (connections_head != NULL) {\n\t\t\tstruct mt_connection *p,tmp;\n\t\t\tDL_FOREACH(connections_head, p) {\n\t\t\t\tif (now - p->lastdata >= MT_CONNECTION_TIMEOUT) {\n\t\t\t\t\tsyslog(LOG_INFO, _(\"(%d) Session timed out\"), p->seskey);\n\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\t\tadd_control_packet(&pdata, MT_CPTYPE_PLAINDATA, _(\"Timeout\\r\\n\"), 9);\n\t\t\t\t\tsend_udp(p, &pdata);\n\t\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, p->dstmac, p->srcmac, p->seskey, p->outcounter);\n\t\t\t\t\tsend_udp(p, &pdata);\n\n\t\t\t\t\ttmp.next = p->next;\n\t\t\t\t\tlist_remove_connection(p);\n\t\t\t\t\tp = &tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Never reached */\n\treturn 0;\n}\n", "/*\n    Mac-Telnet - Connect to RouterOS or mactelnetd devices via MAC address\n    Copyright (C) 2010, H\u00e5kon Nessj\u00f8en <haakon.nessjoen@gmail.com>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _BSD_SOURCE\n#include <libintl.h>\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#ifdef __LINUX__\n#include <linux/if_ether.h>\n#endif\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#include <net/ethernet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#else\n#include <netinet/ether.h>\n#endif\n#include <time.h>\n#if defined(__APPLE__)\n# include <libkern/OSByteOrder.h>\n# define le32toh OSSwapLittleToHostInt32\n#elif defined(__FreeBSD__)\n#include <sys/endian.h>\n#else\n#include <endian.h>\n#endif\n#include \"protocol.h\"\n#include \"config.h\"\n\n#define _(String) gettext (String)\n\nint init_packet(struct mt_packet *packet, enum mt_ptype ptype, unsigned char *srcmac, unsigned char *dstmac, unsigned short sessionkey, unsigned int counter) {\n\tunsigned char *data = packet->data;\n\n\t/* Packet version */\n\tdata[0] = 1;\n\n\t/* Packet type */\n\tdata[1] = ptype;\n\n\t/* src ethernet address */\n\tmemcpy(data + 2, srcmac, ETH_ALEN);\n\n\t/* dst ethernet address */\n\tmemcpy(data + 8, dstmac, ETH_ALEN);\n\n\t/* Session key */\n\tsessionkey = htons(sessionkey);\n\tmemcpy(data + (mt_direction_fromserver ? 16 : 14), &sessionkey, sizeof(sessionkey));\n\n\t/* Client type: Mac Telnet */\n\tmemcpy(data + (mt_direction_fromserver ? 14 : 16), &mt_mactelnet_clienttype, sizeof(mt_mactelnet_clienttype));\n\n\t/* Received/sent data counter */\n\tcounter = htonl(counter);\n\tmemcpy(data + 18, &counter, sizeof(counter));\n\n\t/* 22 bytes header */\n\tpacket->size = 22;\n\treturn 22;\n}\n\nint add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\n       perform an Integer-Overflow safe check */\n\tif (act_size > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}\n\nint init_pingpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned char *dstmac) {\n\tinit_packet(packet, MT_PTYPE_PING, srcmac, dstmac, 0, 0);\n\n\t/* Zero out sessionkey & counter */\n\tbzero(packet->data + 14, 4);\n\n\t/* Remove data counter field from header */\n\tpacket->size -= 4;\n\treturn packet->size;\n}\n\nint init_pongpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned char *dstmac) {\n\tinit_packet(packet, MT_PTYPE_PONG, srcmac, dstmac, 0, 0);\n\n\t/* Zero out sessionkey & counter */\n\tbzero(packet->data + 14, 4);\n\n\t/* Remove data counter field from header */\n\tpacket->size -= 4;\n\treturn packet->size;\n}\n\nint add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\t/* Integer-Overflow safe check */\n\tif (length > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}\n\nvoid parse_packet(unsigned char *data, struct mt_mactelnet_hdr *pkthdr) {\n\t/* Packet version */\n\tpkthdr->ver = data[0];\n\n\t/* Packet type */\n\tpkthdr->ptype = data[1];\n\n\t/* src ethernet addr */\n\tmemcpy(pkthdr->srcaddr, data + 2, ETH_ALEN);\n\n\t/* dst ethernet addr */\n\tmemcpy(pkthdr->dstaddr, data + 8, ETH_ALEN);\n\n\t/* Session key */\n\tmemcpy(&(pkthdr->seskey), data + (mt_direction_fromserver ? 14 : 16), sizeof(pkthdr->seskey));\n\tpkthdr->seskey = ntohs(pkthdr->seskey);\n\n\t/* server type */\n\tmemcpy(&(pkthdr->clienttype), data + (mt_direction_fromserver ? 16 : 14), 2);\n\n\t/* Received/sent data counter */\n\tmemcpy(&(pkthdr->counter), data + 18, sizeof(pkthdr->counter));\n\tpkthdr->counter = ntohl(pkthdr->counter);\n\n\t/* Set pointer to actual data */\n\tpkthdr->data = data + 22;\n}\n\n\nint parse_control_packet(unsigned char *packetdata, unsigned short data_len, struct mt_mactelnet_control_hdr *cpkthdr) {\n\tstatic unsigned char *int_data;\n\tstatic unsigned int int_data_len;\n\tstatic unsigned int int_pos;\n\tunsigned char *data;\n\n\t/* Store info so we can call this function once with data,\n\t   and then several times for each control packets. Letting this function\n\t   control the data position. */\n\tif (packetdata != NULL) {\n\t\tif (data_len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint_data = packetdata;\n\t\tint_data_len = data_len;\n\t\tint_pos = 0;\n\t}\n\n\t/* No more data to parse? */\n\tif (int_pos >= int_data_len) {\n\t\treturn 0;\n\t}\n\n\t/* Set current position in data buffer */\n\tdata = int_data + int_pos;\n\n\t/* Check for valid minimum packet length & magic header */\n\tif ((int_data_len - int_pos) >= MT_CPHEADER_LEN && memcmp(data, &mt_mactelnet_cpmagic, 4) == 0) {\n\n\t\t/* Control packet type */\n\t\tcpkthdr->cptype = data[4];\n\n\t\t/* Control packet data length */\n\t\tmemcpy(&(cpkthdr->length), data + 5, sizeof(cpkthdr->length));\n\t\tcpkthdr->length = ntohl(cpkthdr->length);\n\n\t\t/* We want no buffer overflows */\n\t\tif (cpkthdr->length > int_data_len - MT_CPHEADER_LEN - int_pos) {\n\t\t\tcpkthdr->length = int_data_len - MT_CPHEADER_LEN - int_pos;\n\t\t}\n\n\t\t/* Set pointer to actual data */\n\t\tcpkthdr->data = data + MT_CPHEADER_LEN;\n\n\t\t/* Remember old position, for next call */\n\t\tint_pos += cpkthdr->length + MT_CPHEADER_LEN;\n\n\t\t/* Read data successfully */\n\t\treturn 1;\n\n\t} else {\n\t\t/* Mark data as raw terminal data */\n\t\tcpkthdr->cptype = MT_CPTYPE_PLAINDATA;\n\t\tcpkthdr->length = int_data_len - int_pos;\n\t\tcpkthdr->data = data;\n\n\t\t/* Consume the whole rest of the packet */\n\t\tint_pos = int_data_len;\n\n\t\t/* Read data successfully */\n\t\treturn 1;\n\t}\n}\n\nint mndp_init_packet(struct mt_packet *packet, unsigned char version, unsigned char ttl) {\n\tstruct mt_mndp_hdr *header = (struct mt_mndp_hdr *)packet->data;\n\n\theader->version = version;\n\theader->ttl = ttl;\n\theader->cksum = 0;\n\n\tpacket->size = sizeof(*header);\n\n\treturn sizeof(*header);\n}\n\nint mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}\n\n\nstruct mt_mndp_info *parse_mndp(const unsigned char *data, const int packet_len) {\n\tconst unsigned char *p;\n\tstatic struct mt_mndp_info packet;\n\tstruct mt_mndp_info *packetp = &packet;\n\tstruct mt_mndp_hdr *mndp_hdr;\n\n\t/* Check for valid packet length */\n\tif (packet_len < 18) {\n\t\treturn NULL;\n\t}\n\n\tbzero(packetp, sizeof(*packetp));\n\n\tmndp_hdr = (struct mt_mndp_hdr*)data;\n\n\tmemcpy(&packetp->header, mndp_hdr, sizeof(struct mt_mndp_hdr));\n\n\tp = data + sizeof(struct mt_mndp_hdr);\n\n\twhile(p + 4 < data + packet_len) {\n\t\tunsigned short type, len;\n\n\t\tmemcpy(&type, p, 2);\n\t\tmemcpy(&len, p + 2, 2);\n\n\t\ttype = ntohs(type);\n\t\tlen = ntohs(len);\n\n\t\tp += 4;\n\n\t\t/* Check if len is invalid */\n\t\tif (p + len > data + packet_len) {\n\t\t        fprintf(stderr, \"%s: invalid data: \"\n\t\t\t\t        \"%p + %u > %p + %d\\n\",\n\t\t\t\t\t__func__, p, len, data, packet_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\t\tcase MT_MNDPTYPE_ADDRESS:\n\t\t\t\tif (len >= ETH_ALEN) {\n\t\t\t\t\tmemcpy(packetp->address, p, ETH_ALEN);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_IDENTITY:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->identity, p, len);\n\t\t\t\tpacketp->identity[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_PLATFORM:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->platform, p, len);\n\t\t\t\tpacketp->platform[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_VERSION:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->version, p, len);\n\t\t\t\tpacketp->version[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_TIMESTAMP:\n\t\t\t\tif (len >= 4) {\n\t\t\t\t\tmemcpy(&packetp->uptime, p, 4);\n\t\t\t\t\t/* Seems like ping uptime is transmitted as little endian? */\n\t\t\t\t\tpacketp->uptime = le32toh(packetp->uptime);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_HARDWARE:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->hardware, p, len);\n\t\t\t\tpacketp->hardware[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_SOFTID:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->softid, p, len);\n\t\t\t\tpacketp->softid[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase MT_MNDPTYPE_IFNAME:\n\t\t\t\tif (len >= MT_MNDP_MAX_STRING_SIZE) {\n\t\t\t\t\tlen = MT_MNDP_MAX_STRING_SIZE - 1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(packetp->ifname, p, len);\n\t\t\t\tpacketp->ifname[len] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\t/*default:\n\t\t\t\t Unhandled MNDP type\n\t\t\t*/\n\t\t}\n\n\t\tp += len;\n\t}\n\n\treturn packetp;\n}\n\nint query_mndp(const char *identity, unsigned char *mac) {\n\tint fastlookup = 0;\n\tint sock, length;\n\tint optval = 1;\n\tstruct sockaddr_in si_me, si_remote;\n\tunsigned char buff[MT_PACKET_LEN];\n\tunsigned int message = 0;\n\tstruct timeval timeout;\n\ttime_t start_time;\n\tfd_set read_fds;\n\tstruct mt_mndp_info *packet;\n\n\tstart_time = time(0);\n\n\t/* Open a UDP socket handle */\n\tsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n\t/* Allow to share socket */\n\tsetsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n\t/* Set initialize address/port */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(MT_MNDP_PORT);\n\tsi_me.sin_addr.s_addr = htonl(INADDR_ANY);\n\n\t/* Bind to specified address/port */\n\tif (bind(sock, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d\\n\"), inet_ntoa(si_me.sin_addr), MT_MNDP_PORT);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\t/* Set the socket to allow sending broadcast packets */\n\tsetsockopt(sock, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval));\n\n\t/* Request routers identify themselves */\n\tmemset((char *) &si_remote, 0, sizeof(si_remote));\n\tsi_remote.sin_family = AF_INET;\n\tsi_remote.sin_port = htons(MT_MNDP_PORT);\n\tsi_remote.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\tif (sendto(sock, &message, sizeof (message), 0, (struct sockaddr *)&si_remote, sizeof(si_remote)) == -1) {\n\t\tfprintf(stderr, _(\"Unable to send broadcast packet: Router lookup will be slow\\n\"));\n\t\tfastlookup = 0;\n\t} else {\n\t\tfastlookup = 1;\n\t}\n\n\twhile (1) {\n\t\t/* Timeout, in case we receive a lot of packets, but from the wrong routers */\n\t\tif (time(0) - start_time > (fastlookup ? MT_MNDP_TIMEOUT : MT_MNDP_LONGTIMEOUT)) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tFD_ZERO(&read_fds);\n\t\tFD_SET(sock, &read_fds);\n\n\t\ttimeout.tv_sec = fastlookup ? MT_MNDP_TIMEOUT : MT_MNDP_LONGTIMEOUT;\n\t\ttimeout.tv_usec = 0;\n\n\t\tselect(sock + 1, &read_fds, NULL, NULL, &timeout);\n\t\tif (!FD_ISSET(sock, &read_fds)) {\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Read UDP packet */\n\t\tlength = recvfrom(sock, buff, sizeof(buff), 0, 0, 0);\n\t\tif (length < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Parse MNDP packet */\n\t\tpacket = parse_mndp(buff, length);\n\n\t\tif (packet != NULL) {\n\t\t\tif (strcasecmp(identity, packet->identity) == 0) {\n\t\t\t\tmemcpy(mac, packet->address, ETH_ALEN);\n\t\t\t\tclose(sock);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tclose(sock);\n\treturn 0;\n}\n\n/*\n * This function accepts either a full MAC address using : or - as seperators.\n * Or a router hostname. The hostname will be searched for via MNDP broadcast packets.\n */\nint query_mndp_or_mac(char *address, unsigned char *dstmac, int verbose) {\n\tchar *p = address;\n\tint colons = 0;\n\tint dashs = 0;\n\n\twhile (*p++) {\n\t\tif (*p == ':') {\n\t\t\tcolons++;\n\t\t}\n\t\telse if (*p == '-') {\n\t\t\tdashs++;\n\t\t}\n\t}\n\n\t/* \n\t* Windows users often enter macs with dash instead\n\t* of colon.\n\t*/\n\tif (colons == 0 && dashs == 5) {\n\t\tp = address;\n\t\twhile (*p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = ':';\n\t\t\t}\n\t\t}\n\t\tcolons = dashs;\n\t}\n\n\tif (colons != 5) {\n\t\t/* \n\t\t * Not a valid mac-address.\n\t\t * Search for Router by identity name, using MNDP\n\t\t */\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, _(\"Searching for '%s'...\"), address);\n\t\t}\n\t\tif (!query_mndp(address, dstmac)) {\n\t\t\tif (verbose) {\n\t\t\t\tfprintf(stderr, _(\"not found\\n\"));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Router found, display mac and continue */\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, _(\"found\\n\"));\n\t\t}\n\t} else {\n\t\t/* Convert mac address string to ether_addr struct */\n#if defined(__APPLE__)\n\t\tstruct ether_addr* dstmac_buf = ether_aton(address);\n\t\tmemcpy(dstmac, dstmac_buf, sizeof(struct ether_addr));\n#else\n\t\tether_aton_r(address, (struct ether_addr *)dstmac);\n#endif\n\t}\n\n\treturn 1;\n}\n"], "filenames": ["mactelnet.c", "mactelnetd.c", "protocol.c"], "buggy_code_start_loc": [99, 409, 87], "buggy_code_end_loc": [316, 655, 276], "fixing_code_start_loc": [99, 410, 87], "fixing_code_end_loc": [323, 660, 278], "type": "CWE-119", "message": "Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.", "other": {"cve": {"id": "CVE-2016-7115", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-30T17:59:04.550", "lastModified": "2016-11-28T20:37:12.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n handle_packet en mactelnet.c en el cliente en MAC-Telnet 0.4.3 y versiones anteriores permite a servidores TELNET remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de una cadena larga en un paquete de control MT_CPTYPE_PASSSALT."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mac-telnet_project:mac-telnet:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.3", "matchCriteriaId": "C2EB01A5-3978-42A1-9CD4-9A9B61C3F5F6"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/92699", "source": "cve@mitre.org"}, {"url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/haakonnessjoen/MAC-Telnet/pull/20", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a"}}