{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'omniauth-oauth2'\nrequire 'net/https'\n\nmodule OmniAuth\n  module Strategies\n    class Apple < OmniAuth::Strategies::OAuth2\n      option :name, 'apple'\n\n      option :client_options,\n             site: 'https://appleid.apple.com',\n             authorize_url: '/auth/authorize',\n             token_url: '/auth/token'\n      option :authorize_params,\n             response_mode: 'form_post',\n             scope: 'email name'\n      option :authorized_client_ids, []\n\n      uid { id_info['sub'] }\n\n      info do\n        prune!(\n          sub: id_info['sub'],\n          email: email,\n          first_name: first_name,\n          last_name: last_name,\n          name: (first_name || last_name) ? [first_name, last_name].join(' ') : email,\n        )\n      end\n\n      extra do\n        id_token = request.params['id_token'] || access_token&.params&.dig('id_token')\n        prune!(raw_info: {id_info: id_info, user_info: user_info, id_token: id_token})\n      end\n\n      def client\n        ::OAuth2::Client.new(client_id, client_secret, deep_symbolize(options.client_options))\n      end\n\n      def authorize_params\n        super.merge(nonce: new_nonce)\n      end\n\n      def callback_url\n        options[:redirect_uri] || (full_host + script_name + callback_path)\n      end\n\n      private\n\n      def new_nonce\n        session['omniauth.nonce'] = SecureRandom.urlsafe_base64(16)\n      end\n\n      def stored_nonce\n        session.delete('omniauth.nonce')\n      end\n\n      def id_info\n        @id_info ||= if request.params&.key?('id_token') || access_token&.params&.key?('id_token')\n                       id_token = request.params['id_token'] || access_token.params['id_token']\n                       jwt_options = {\n                         verify_iss: true,\n                         iss: 'https://appleid.apple.com',\n                         verify_iat: true,\n                         verify_aud: true,\n                         aud: [options.client_id].concat(options.authorized_client_ids),\n                         algorithms: ['RS256'],\n                         jwks: fetch_jwks\n                       }\n                       payload, _header = ::JWT.decode(id_token, nil, true, jwt_options)\n                       verify_nonce!(payload)\n                       payload\n                     end\n      end\n\n      def fetch_jwks\n        uri = URI.parse('https://appleid.apple.com/auth/keys')\n        response = Net::HTTP.get_response(uri)\n        JSON.parse(response.body, symbolize_names: true)\n      end\n\n      def verify_nonce!(payload)\n        return unless payload['nonce_supported']\n\n        return if payload['nonce'] && payload['nonce'] == stored_nonce\n\n        fail!(:nonce_mismatch, CallbackError.new(:nonce_mismatch, 'nonce mismatch'))\n      end\n\n      def client_id\n        @client_id ||= if id_info.nil?\n                         options.client_id\n                       else\n                         id_info['aud'] if options.authorized_client_ids.include? id_info['aud']\n                       end\n      end\n\n      def user_info\n        user = request.params['user']\n        return {} if user.nil?\n\n        @user_info ||= JSON.parse(user)\n      end\n\n      def email\n        user_info['email'] || id_info['email']\n      end\n\n      def first_name\n        user_info.dig('name', 'firstName')\n      end\n\n      def last_name\n        user_info.dig('name', 'lastName')\n      end\n\n      def prune!(hash)\n        hash.delete_if do |_, v|\n          prune!(v) if v.is_a?(Hash)\n          v.nil? || (v.respond_to?(:empty?) && v.empty?)\n        end\n      end\n\n      def client_secret\n        payload = {\n          iss: options.team_id,\n          aud: 'https://appleid.apple.com',\n          sub: client_id,\n          iat: Time.now.to_i,\n          exp: Time.now.to_i + 60\n        }\n        headers = { kid: options.key_id }\n\n        ::JWT.encode(payload, private_key, 'ES256', headers)\n      end\n\n      def private_key\n        ::OpenSSL::PKey::EC.new(options.pem)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'spec_helper'\nrequire 'json'\nrequire 'omniauth-apple'\n\ndescribe OmniAuth::Strategies::Apple do\n  let(:request) { double('Request', params: {}, cookies: {}, env: {}) }\n  let(:app) do\n    lambda do\n      [200, {}, ['Hello.']]\n    end\n  end\n\n  let(:options) {{\n      team_id: 'my-team-id',\n      key_id: 'my-key-id',\n      pem: ::OpenSSL::PKey::EC.generate('prime256v1').to_pem,\n  }}\n\n  let(:apple_key) { OpenSSL::PKey::RSA.generate(1024) }\n  let(:auth_keys) do\n    {\n        keys: [\n            {\n                kty: \"RSA\",\n                kid: \"1\",\n                use: \"sig\",\n                alg: \"RS256\",\n                n: Base64.urlsafe_encode64(apple_key.n.to_s(2)),\n                e: Base64.urlsafe_encode64(apple_key.e.to_s(2)),\n            }\n        ]\n    }\n  end\n  let(:id_token_header)  do\n    { kid: '1' }\n  end\n  let(:id_token_payload) do\n    {\n        'iss' => 'https://appleid.apple.com',\n        'sub' => 'sub-1',\n        'aud' => 'appid',\n        'exp' => Time.now.to_i + 3600,\n        'iat' => Time.now.to_i,\n        'nonce_supported' => true,\n        'email' => 'something@privatrerelay.appleid.com',\n        'email_verified' => true,\n    }\n  end\n  let(:id_token) { JWT.encode(id_token_payload, apple_key, 'RS256', id_token_header) }\n  let(:access_token) { OAuth2::AccessToken.from_hash(subject.client, 'id_token' => id_token) }\n\n  subject do\n    OmniAuth::Strategies::Apple.new(app, 'appid', 'secret', options ).tap do |strategy|\n      allow(strategy).to receive(:request) do\n        request\n      end\n    end\n  end\n\n  before do\n    OmniAuth.config.test_mode = true\n    stub_request(:get, 'https://appleid.apple.com/auth/keys').to_return(body: auth_keys.to_json)\n  end\n\n  after do\n    OmniAuth.config.test_mode = false\n    WebMock.reset!\n  end\n\n  describe '#client_options' do\n    it 'has correct site' do\n      expect(subject.client.site).to eq('https://appleid.apple.com')\n    end\n\n    it 'has correct authorize_url' do\n      expect(subject.client.options[:authorize_url]).to eq('/auth/authorize')\n    end\n\n    it 'has correct token_url' do\n      expect(subject.client.options[:token_url]).to eq('/auth/token')\n    end\n\n    describe 'overrides' do\n      context 'as strings' do\n        it 'should allow overriding the site' do\n          options.merge!({ client_options: {'site' => 'https://example.com'} })\n          expect(subject.client.site).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the authorize_url' do\n          options.merge!({ client_options: { 'authorize_url' => 'https://example.com' } })\n          expect(subject.client.options[:authorize_url]).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the token_url' do\n          options.merge!({ client_options: { 'token_url' => 'https://example.com' } })\n          expect(subject.client.options[:token_url]).to eq('https://example.com')\n        end\n      end\n\n      context 'as symbols' do\n        it 'should allow overriding the site' do\n          options.merge!({ client_options: { site: 'https://example.com' } })\n          expect(subject.client.site).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the authorize_url' do\n          options.merge!({ client_options: { authorize_url: 'https://example.com' } })\n          expect(subject.client.options[:authorize_url]).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the token_url' do\n          options.merge!({ client_options: { token_url: 'https://example.com' } })\n          expect(subject.client.options[:token_url]).to eq('https://example.com')\n        end\n      end\n    end\n  end\n\n  describe '#authorize_options' do\n    %i[scope].each do |k|\n      it \"should support '#{k}'\" do\n        options.merge!({ k => 'http://someval' })\n        expect(subject.authorize_params[k.to_s]).to eq('http://someval')\n      end\n    end\n\n    describe 'redirect_uri' do\n      it 'should default to nil' do\n        expect(subject.authorize_params['redirect_uri']).to eq(nil)\n      end\n    end\n\n    describe 'scope' do\n      it \"should set default scope to 'email name'\" do\n        expect(subject.authorize_params['scope']).to eq('email name')\n      end\n\n      it 'should support space delimited scopes' do\n        options.merge!(scope: 'one two')\n        expect(subject.authorize_params['scope']).to eq('one two')\n      end\n\n    end\n\n    describe 'state' do\n      it 'should set the omniauth.state' do\n        expect(subject.authorize_params['state']).to match /\\h+/\n      end\n    end\n\n    describe 'overrides' do\n      it 'should include top-level options that are marked as :authorize_options' do\n        options.merge!(authorize_options: %i[scope foo request_visible_actions], scope: 'http://bar', foo: 'baz', hd: 'wow', request_visible_actions: 'something')\n        expect(subject.authorize_params['scope']).to eq('http://bar')\n        expect(subject.authorize_params['foo']).to eq('baz')\n        expect(subject.authorize_params['hd']).to eq(nil)\n        expect(subject.authorize_params['request_visible_actions']).to eq('something')\n      end\n    end\n  end\n\n  describe '#authorize_params' do\n    it 'should include any authorize params passed in the :authorize_params option' do\n      options.merge!(authorize_params: { request_visible_actions: 'something', foo: 'bar', baz: 'zip' }, bad: 'not_included')\n      expect(subject.authorize_params['request_visible_actions']).to eq('something')\n      expect(subject.authorize_params['foo']).to eq('bar')\n      expect(subject.authorize_params['baz']).to eq('zip')\n      expect(subject.authorize_params['bad']).to eq(nil)\n    end\n  end\n\n  describe '#token_params' do\n    it 'should include any token params passed in the :token_params option' do\n      options.merge!(token_params: { foo: 'bar', baz: 'zip' })\n      expect(subject.token_params['foo']).to eq('bar')\n      expect(subject.token_params['baz']).to eq('zip')\n    end\n  end\n\n  describe '#token_options' do\n    it 'should include top-level options that are marked as :token_options' do\n      options.merge!(token_options: %i[scope foo], scope: 'bar', foo: 'baz', bad: 'not_included')\n      expect(subject.token_params['scope']).to eq('bar')\n      expect(subject.token_params['foo']).to eq('baz')\n      expect(subject.token_params['bad']).to eq(nil)\n    end\n  end\n\n  describe '#callback_path' do\n    it 'has the correct default callback path' do\n      expect(subject.callback_path).to eq('/auth/apple/callback')\n    end\n\n    it 'should set the callback_path parameter if present' do\n      options.merge!(callback_path: '/auth/foo/callback')\n      expect(subject.callback_path).to eq('/auth/foo/callback')\n    end\n  end\n\n  describe '#info' do\n    let(:user_info_payload) do\n      {\n          name: {\n              firstName: 'first',\n              lastName: 'last',\n          },\n          email: 'something@privatrerelay.appleid.com',\n      }\n    end\n    before(:each) do\n      subject.authorize_params # initializes session / populates 'nonce', 'state', etc\n      id_token_payload['nonce'] = subject.session['omniauth.nonce']\n      request.params.merge!('id_token' => id_token, 'user' => user_info_payload.to_json)\n    end\n\n    it 'should return sub' do\n      expect(subject.info[:sub]).to eq 'sub-1'\n    end\n\n    it 'should return email' do\n      expect(subject.info[:email]).to eq('something@privatrerelay.appleid.com')\n    end\n\n    it 'should return first_name' do\n      expect(subject.info[:first_name]).to eq 'first'\n    end\n\n    it 'should return last_name' do\n      expect(subject.info[:last_name]).to eq 'last'\n    end\n\n    it 'should return name' do\n      # https://github.com/omniauth/omniauth/wiki/Auth-Hash-Schema\n      # schema lists 'name' as required property\n      expect(subject.info[:name]).to eq 'first last'\n    end\n\n    context 'fails nonce' do\n      before(:each) do\n        expect(subject).to receive(:fail!).with(:nonce_mismatch, instance_of(OmniAuth::Strategies::OAuth2::CallbackError))\n      end\n      it 'when differs from session' do\n        subject.session['omniauth.nonce'] = 'abc'\n        subject.info\n      end\n      it 'when missing from session' do\n        subject.session.delete('omniauth.nonce')\n        subject.info\n      end\n    end\n\n  end\n\n  describe '#extra' do\n    before(:each) do\n      subject.authorize_params # initializes session / populates 'nonce', 'state', etc\n      id_token_payload['nonce'] = subject.session['omniauth.nonce']\n    end\n\n    describe 'id_token' do\n      context 'issued by valid issuer' do\n        before(:each) do\n          request.params.merge!('id_token' => id_token)\n        end\n        context 'when the id_token is passed into the access token' do\n          it 'should include id_token when set on the access_token' do\n            expect(subject.extra[:raw_info]).to include(id_token: id_token)\n          end\n\n          it 'should include id_info when id_token is set on the access_token' do\n            expect(subject.extra[:raw_info]).to include(id_info: id_token_payload)\n          end\n        end\n      end\n\n      context 'issued by invalid issuer' do\n        it 'raises JWT::InvalidIssuerError' do\n          id_token_payload['iss'] = 'https://appleid.badguy.com'\n          request.params.merge!('id_token' => id_token)\n          expect { subject.extra }.to raise_error(JWT::InvalidIssuerError)\n        end\n      end\n\n      context 'when the id_token is missing' do\n        it 'should not include id_token' do\n          allow(subject).to receive(:access_token).and_return(nil)\n          expect(subject.extra).not_to have_key(:raw_info)\n        end\n\n        it 'should not include id_info' do\n          allow(subject).to receive(:access_token).and_return(nil)\n          expect(subject.extra).not_to have_key(:raw_info)\n        end\n      end\n    end\n\n end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'omniauth-oauth2'\nrequire 'net/https'\n\nmodule OmniAuth\n  module Strategies\n    class Apple < OmniAuth::Strategies::OAuth2\n      option :name, 'apple'\n\n      option :client_options,\n             site: 'https://appleid.apple.com',\n             authorize_url: '/auth/authorize',\n             token_url: '/auth/token'\n      option :authorize_params,\n             response_mode: 'form_post',\n             scope: 'email name'\n      option :authorized_client_ids, []\n\n      uid { id_info['sub'] }\n\n      info do\n        prune!(\n          sub: id_info['sub'],\n          email: email,\n          first_name: first_name,\n          last_name: last_name,\n          name: (first_name || last_name) ? [first_name, last_name].join(' ') : email,\n        )\n      end\n\n      extra do\n        id_token = request.params['id_token'] || access_token&.params&.dig('id_token')\n        prune!(raw_info: {id_info: id_info, user_info: user_info, id_token: id_token})\n      end\n\n      def client\n        ::OAuth2::Client.new(client_id, client_secret, deep_symbolize(options.client_options))\n      end\n\n      def authorize_params\n        super.merge(nonce: new_nonce)\n      end\n\n      def callback_url\n        options[:redirect_uri] || (full_host + script_name + callback_path)\n      end\n\n      private\n\n      def new_nonce\n        session['omniauth.nonce'] = SecureRandom.urlsafe_base64(16)\n      end\n\n      def stored_nonce\n        session.delete('omniauth.nonce')\n      end\n\n      def id_info\n        @id_info ||= if request.params&.key?('id_token') || access_token&.params&.key?('id_token')\n                       id_token = request.params['id_token'] || access_token.params['id_token']\n                       jwt_options = {\n                         verify_iss: true,\n                         iss: 'https://appleid.apple.com',\n                         verify_iat: true,\n                         verify_aud: true,\n                         aud: [options.client_id].concat(options.authorized_client_ids),\n                         algorithms: ['RS256'],\n                         jwks: fetch_jwks\n                       }\n                       payload, _header = ::JWT.decode(id_token, nil, true, jwt_options)\n                       verify_nonce!(payload)\n                       payload\n                     end\n      end\n\n      def fetch_jwks\n        uri = URI.parse('https://appleid.apple.com/auth/keys')\n        response = Net::HTTP.get_response(uri)\n        JSON.parse(response.body, symbolize_names: true)\n      end\n\n      def verify_nonce!(payload)\n        return unless payload['nonce_supported']\n\n        return if payload['nonce'] && payload['nonce'] == stored_nonce\n\n        fail!(:nonce_mismatch, CallbackError.new(:nonce_mismatch, 'nonce mismatch'))\n      end\n\n      def client_id\n        @client_id ||= if id_info.nil?\n                         options.client_id\n                       else\n                         id_info['aud'] if options.authorized_client_ids.include? id_info['aud']\n                       end\n      end\n\n      def user_info\n        user = request.params['user']\n        return {} if user.nil?\n\n        @user_info ||= JSON.parse(user)\n      end\n\n      def email\n        id_info['email']\n      end\n\n      def first_name\n        user_info.dig('name', 'firstName')\n      end\n\n      def last_name\n        user_info.dig('name', 'lastName')\n      end\n\n      def prune!(hash)\n        hash.delete_if do |_, v|\n          prune!(v) if v.is_a?(Hash)\n          v.nil? || (v.respond_to?(:empty?) && v.empty?)\n        end\n      end\n\n      def client_secret\n        payload = {\n          iss: options.team_id,\n          aud: 'https://appleid.apple.com',\n          sub: client_id,\n          iat: Time.now.to_i,\n          exp: Time.now.to_i + 60\n        }\n        headers = { kid: options.key_id }\n\n        ::JWT.encode(payload, private_key, 'ES256', headers)\n      end\n\n      def private_key\n        ::OpenSSL::PKey::EC.new(options.pem)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'spec_helper'\nrequire 'json'\nrequire 'omniauth-apple'\n\ndescribe OmniAuth::Strategies::Apple do\n  let(:request) { double('Request', params: {}, cookies: {}, env: {}) }\n  let(:app) do\n    lambda do\n      [200, {}, ['Hello.']]\n    end\n  end\n\n  let(:options) {{\n      team_id: 'my-team-id',\n      key_id: 'my-key-id',\n      pem: ::OpenSSL::PKey::EC.generate('prime256v1').to_pem,\n  }}\n\n  let(:apple_key) { OpenSSL::PKey::RSA.generate(1024) }\n  let(:auth_keys) do\n    {\n        keys: [\n            {\n                kty: \"RSA\",\n                kid: \"1\",\n                use: \"sig\",\n                alg: \"RS256\",\n                n: Base64.urlsafe_encode64(apple_key.n.to_s(2)),\n                e: Base64.urlsafe_encode64(apple_key.e.to_s(2)),\n            }\n        ]\n    }\n  end\n  let(:id_token_header)  do\n    { kid: '1' }\n  end\n  let(:id_token_payload) do\n    {\n        'iss' => 'https://appleid.apple.com',\n        'sub' => 'sub-1',\n        'aud' => 'appid',\n        'exp' => Time.now.to_i + 3600,\n        'iat' => Time.now.to_i,\n        'nonce_supported' => true,\n        'email' => 'something@privatrerelay.appleid.com',\n        'email_verified' => true,\n    }\n  end\n  let(:id_token) { JWT.encode(id_token_payload, apple_key, 'RS256', id_token_header) }\n  let(:access_token) { OAuth2::AccessToken.from_hash(subject.client, 'id_token' => id_token) }\n\n  subject do\n    OmniAuth::Strategies::Apple.new(app, 'appid', 'secret', options ).tap do |strategy|\n      allow(strategy).to receive(:request) do\n        request\n      end\n    end\n  end\n\n  before do\n    OmniAuth.config.test_mode = true\n    stub_request(:get, 'https://appleid.apple.com/auth/keys').to_return(body: auth_keys.to_json)\n  end\n\n  after do\n    OmniAuth.config.test_mode = false\n    WebMock.reset!\n  end\n\n  describe '#client_options' do\n    it 'has correct site' do\n      expect(subject.client.site).to eq('https://appleid.apple.com')\n    end\n\n    it 'has correct authorize_url' do\n      expect(subject.client.options[:authorize_url]).to eq('/auth/authorize')\n    end\n\n    it 'has correct token_url' do\n      expect(subject.client.options[:token_url]).to eq('/auth/token')\n    end\n\n    describe 'overrides' do\n      context 'as strings' do\n        it 'should allow overriding the site' do\n          options.merge!({ client_options: {'site' => 'https://example.com'} })\n          expect(subject.client.site).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the authorize_url' do\n          options.merge!({ client_options: { 'authorize_url' => 'https://example.com' } })\n          expect(subject.client.options[:authorize_url]).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the token_url' do\n          options.merge!({ client_options: { 'token_url' => 'https://example.com' } })\n          expect(subject.client.options[:token_url]).to eq('https://example.com')\n        end\n      end\n\n      context 'as symbols' do\n        it 'should allow overriding the site' do\n          options.merge!({ client_options: { site: 'https://example.com' } })\n          expect(subject.client.site).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the authorize_url' do\n          options.merge!({ client_options: { authorize_url: 'https://example.com' } })\n          expect(subject.client.options[:authorize_url]).to eq('https://example.com')\n        end\n\n        it 'should allow overriding the token_url' do\n          options.merge!({ client_options: { token_url: 'https://example.com' } })\n          expect(subject.client.options[:token_url]).to eq('https://example.com')\n        end\n      end\n    end\n  end\n\n  describe '#authorize_options' do\n    %i[scope].each do |k|\n      it \"should support '#{k}'\" do\n        options.merge!({ k => 'http://someval' })\n        expect(subject.authorize_params[k.to_s]).to eq('http://someval')\n      end\n    end\n\n    describe 'redirect_uri' do\n      it 'should default to nil' do\n        expect(subject.authorize_params['redirect_uri']).to eq(nil)\n      end\n    end\n\n    describe 'scope' do\n      it \"should set default scope to 'email name'\" do\n        expect(subject.authorize_params['scope']).to eq('email name')\n      end\n\n      it 'should support space delimited scopes' do\n        options.merge!(scope: 'one two')\n        expect(subject.authorize_params['scope']).to eq('one two')\n      end\n\n    end\n\n    describe 'state' do\n      it 'should set the omniauth.state' do\n        expect(subject.authorize_params['state']).to match /\\h+/\n      end\n    end\n\n    describe 'overrides' do\n      it 'should include top-level options that are marked as :authorize_options' do\n        options.merge!(authorize_options: %i[scope foo request_visible_actions], scope: 'http://bar', foo: 'baz', hd: 'wow', request_visible_actions: 'something')\n        expect(subject.authorize_params['scope']).to eq('http://bar')\n        expect(subject.authorize_params['foo']).to eq('baz')\n        expect(subject.authorize_params['hd']).to eq(nil)\n        expect(subject.authorize_params['request_visible_actions']).to eq('something')\n      end\n    end\n  end\n\n  describe '#authorize_params' do\n    it 'should include any authorize params passed in the :authorize_params option' do\n      options.merge!(authorize_params: { request_visible_actions: 'something', foo: 'bar', baz: 'zip' }, bad: 'not_included')\n      expect(subject.authorize_params['request_visible_actions']).to eq('something')\n      expect(subject.authorize_params['foo']).to eq('bar')\n      expect(subject.authorize_params['baz']).to eq('zip')\n      expect(subject.authorize_params['bad']).to eq(nil)\n    end\n  end\n\n  describe '#token_params' do\n    it 'should include any token params passed in the :token_params option' do\n      options.merge!(token_params: { foo: 'bar', baz: 'zip' })\n      expect(subject.token_params['foo']).to eq('bar')\n      expect(subject.token_params['baz']).to eq('zip')\n    end\n  end\n\n  describe '#token_options' do\n    it 'should include top-level options that are marked as :token_options' do\n      options.merge!(token_options: %i[scope foo], scope: 'bar', foo: 'baz', bad: 'not_included')\n      expect(subject.token_params['scope']).to eq('bar')\n      expect(subject.token_params['foo']).to eq('baz')\n      expect(subject.token_params['bad']).to eq(nil)\n    end\n  end\n\n  describe '#callback_path' do\n    it 'has the correct default callback path' do\n      expect(subject.callback_path).to eq('/auth/apple/callback')\n    end\n\n    it 'should set the callback_path parameter if present' do\n      options.merge!(callback_path: '/auth/foo/callback')\n      expect(subject.callback_path).to eq('/auth/foo/callback')\n    end\n  end\n\n  describe '#info' do\n    let(:user_info_payload) do\n      {\n          name: {\n              firstName: 'first',\n              lastName: 'last',\n          },\n          email: 'something@privatrerelay.appleid.com',\n      }\n    end\n    before(:each) do\n      subject.authorize_params # initializes session / populates 'nonce', 'state', etc\n      id_token_payload['nonce'] = subject.session['omniauth.nonce']\n      request.params.merge!('id_token' => id_token, 'user' => user_info_payload.to_json)\n    end\n\n    it 'should return sub' do\n      expect(subject.info[:sub]).to eq 'sub-1'\n    end\n\n    it 'should return email' do\n      expect(subject.info[:email]).to eq('something@privatrerelay.appleid.com')\n    end\n\n    it 'should return first_name' do\n      expect(subject.info[:first_name]).to eq 'first'\n    end\n\n    it 'should return last_name' do\n      expect(subject.info[:last_name]).to eq 'last'\n    end\n\n    it 'should return name' do\n      # https://github.com/omniauth/omniauth/wiki/Auth-Hash-Schema\n      # schema lists 'name' as required property\n      expect(subject.info[:name]).to eq 'first last'\n    end\n\n    context 'fails nonce' do\n      before(:each) do\n        expect(subject).to receive(:fail!).with(:nonce_mismatch, instance_of(OmniAuth::Strategies::OAuth2::CallbackError))\n      end\n      it 'when differs from session' do\n        subject.session['omniauth.nonce'] = 'abc'\n        subject.info\n      end\n      it 'when missing from session' do\n        subject.session.delete('omniauth.nonce')\n        subject.info\n      end\n    end\n\n    context 'with a spoofed email in the user payload' do\n      before do\n        request.params['user'] = {\n          name: {\n            firstName: 'first',\n            lastName: 'last'\n          },\n          email: \"spoofed@example.com\"\n        }.to_json\n      end\n\n      it 'should return the true email' do\n        expect(subject.info[:email]).to eq('something@privatrerelay.appleid.com')\n      end\n    end\n  end\n\n  describe '#extra' do\n    before(:each) do\n      subject.authorize_params # initializes session / populates 'nonce', 'state', etc\n      id_token_payload['nonce'] = subject.session['omniauth.nonce']\n    end\n\n    describe 'id_token' do\n      context 'issued by valid issuer' do\n        before(:each) do\n          request.params.merge!('id_token' => id_token)\n        end\n        context 'when the id_token is passed into the access token' do\n          it 'should include id_token when set on the access_token' do\n            expect(subject.extra[:raw_info]).to include(id_token: id_token)\n          end\n\n          it 'should include id_info when id_token is set on the access_token' do\n            expect(subject.extra[:raw_info]).to include(id_info: id_token_payload)\n          end\n        end\n      end\n\n      context 'issued by invalid issuer' do\n        it 'raises JWT::InvalidIssuerError' do\n          id_token_payload['iss'] = 'https://appleid.badguy.com'\n          request.params.merge!('id_token' => id_token)\n          expect { subject.extra }.to raise_error(JWT::InvalidIssuerError)\n        end\n      end\n\n      context 'when the id_token is missing' do\n        it 'should not include id_token' do\n          allow(subject).to receive(:access_token).and_return(nil)\n          expect(subject.extra).not_to have_key(:raw_info)\n        end\n\n        it 'should not include id_info' do\n          allow(subject).to receive(:access_token).and_return(nil)\n          expect(subject.extra).not_to have_key(:raw_info)\n        end\n      end\n    end\n\n end\n\nend\n"], "filenames": ["lib/omniauth/strategies/apple.rb", "spec/omniauth/strategies/apple_spec.rb"], "buggy_code_start_loc": [107, 254], "buggy_code_end_loc": [108, 254], "fixing_code_start_loc": [107, 255], "fixing_code_end_loc": [108, 270], "type": "CWE-290", "message": "omniauth-apple is the OmniAuth strategy for \"Sign In with Apple\" (RubyGem omniauth-apple). In omniauth-apple before version 1.0.1 attackers can fake their email address during authentication. This vulnerability impacts applications using the omniauth-apple strategy of OmniAuth and using the info.email field of OmniAuth's Auth Hash Schema for any kind of identification. The value of this field may be set to any value of the attacker's choice including email addresses of other users. Applications not using info.email for identification but are instead using the uid field are not impacted in the same manner. Note, these applications may still be negatively affected if the value of info.email is being used for other purposes. Applications using affected versions of omniauth-apple are advised to upgrade to omniauth-apple version 1.0.1 or later.", "other": {"cve": {"id": "CVE-2020-26254", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-08T15:15:11.130", "lastModified": "2020-12-10T14:46:43.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "omniauth-apple is the OmniAuth strategy for \"Sign In with Apple\" (RubyGem omniauth-apple). In omniauth-apple before version 1.0.1 attackers can fake their email address during authentication. This vulnerability impacts applications using the omniauth-apple strategy of OmniAuth and using the info.email field of OmniAuth's Auth Hash Schema for any kind of identification. The value of this field may be set to any value of the attacker's choice including email addresses of other users. Applications not using info.email for identification but are instead using the uid field are not impacted in the same manner. Note, these applications may still be negatively affected if the value of info.email is being used for other purposes. Applications using affected versions of omniauth-apple are advised to upgrade to omniauth-apple version 1.0.1 or later."}, {"lang": "es", "value": "omniauth-apple es la estrategia de OmniAuth para \"Sign In with Apple\" (RubyGem omniauth-apple).&#xa0;En omniauth-apple anterior a versi\u00f3n 1.0.1, los atacantes pueden falsificar su direcci\u00f3n de correo electr\u00f3nico durante la autenticaci\u00f3n.&#xa0;Esta vulnerabilidad afecta a las aplicaciones que usan la estrategia omniauth-apple de OmniAuth y el campo info.email del Auth Hash Schema de OmniAuth para cualquier tipo de identificaci\u00f3n.&#xa0;El valor de este campo puede ser establecido en cualquier valor que elija el atacante, incluyendo las direcciones de correo electr\u00f3nico de otros usuarios.&#xa0;Las aplicaciones que no usan info.email para la identificaci\u00f3n, sino que en su lugar usan el campo uid, no est\u00e1n afectadas de la misma manera.&#xa0;Tome en cuenta que estas aplicaciones a\u00fan pueden estar afectadas negativamente si el valor de info.email se utiliza para otros fines.&#xa0;Se recomienda a las aplicaciones que utilizan versiones afectadas de omniauth-apple que se actualicen a omniauth-apple versi\u00f3n 1.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:omniauth-apple_project:omniauth-apple:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "D5C95EE3-9B9F-4092-A4F6-1DA130F196EC"}]}]}], "references": [{"url": "https://github.com/nhosoya/omniauth-apple/blob/master/CHANGELOG.md#101---2020-12-03", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/nhosoya/omniauth-apple/commit/b37d5409213adae2ca06a67fec14c8d3d07d9016", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nhosoya/omniauth-apple/security/advisories/GHSA-49r3-2549-3633", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nhosoya/omniauth-apple/commit/b37d5409213adae2ca06a67fec14c8d3d07d9016"}}