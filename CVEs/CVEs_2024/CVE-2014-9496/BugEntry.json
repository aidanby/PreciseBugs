{"buggy_code": ["/*\n** Copyright (C) 2001-2014 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2004 Paavo Jumppanen\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n/*\n** The sd2 support implemented in this file was partially sponsored\n** (financially) by Paavo Jumppanen.\n*/\n\n/*\n** Documentation on the Mac resource fork was obtained here :\n** http://developer.apple.com/documentation/mac/MoreToolbox/MoreToolbox-99.html\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdio.h>\n#include\t<stdlib.h>\n#include\t<string.h>\n#include\t<ctype.h>\n\n#include\t\"sndfile.h\"\n#include\t\"sfendian.h\"\n#include\t\"common.h\"\n\n/*------------------------------------------------------------------------------\n * Markers.\n*/\n\n#define\tSd2f_MARKER\t\t\tMAKE_MARKER ('S', 'd', '2', 'f')\n#define\tSd2a_MARKER\t\t\tMAKE_MARKER ('S', 'd', '2', 'a')\n#define\tALCH_MARKER\t\t\tMAKE_MARKER ('A', 'L', 'C', 'H')\n#define lsf1_MARKER\t\t\tMAKE_MARKER ('l', 's', 'f', '1')\n\n#define STR_MARKER\t\t\tMAKE_MARKER ('S', 'T', 'R', ' ')\n#define sdML_MARKER\t\t\tMAKE_MARKER ('s', 'd', 'M', 'L')\n\nenum\n{\tRSRC_STR = 111,\n\tRSRC_BIN\n} ;\n\ntypedef struct\n{\tunsigned char * rsrc_data ;\n\tint rsrc_len ;\n\tint need_to_free_rsrc_data ;\n\n\tint data_offset, data_length ;\n\tint map_offset, map_length ;\n\n\tint type_count, type_offset ;\n\tint item_offset ;\n\n\tint str_index, str_count ;\n\n\tint string_offset ;\n\n\t/* All the above just to get these three. */\n\tint sample_size, sample_rate, channels ;\n} SD2_RSRC ;\n\ntypedef struct\n{\tint type ;\n\tint id ;\n\tchar name [32] ;\n\tchar value [32] ;\n\tint value_len ;\n} STR_RSRC ;\n\n/*------------------------------------------------------------------------------\n * Private static functions.\n*/\n\nstatic int sd2_close\t(SF_PRIVATE *psf) ;\n\nstatic int sd2_parse_rsrc_fork (SF_PRIVATE *psf) ;\nstatic int parse_str_rsrc (SF_PRIVATE *psf, SD2_RSRC * rsrc) ;\n\nstatic int sd2_write_rsrc_fork (SF_PRIVATE *psf, int calc_length) ;\n\n/*------------------------------------------------------------------------------\n** Public functions.\n*/\n\nint\nsd2_open (SF_PRIVATE *psf)\n{\tint subformat, error = 0, valid ;\n\n\t/* SD2 is always big endian. */\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->rsrclength > 0))\n\t{\tpsf_use_rsrc (psf, SF_TRUE) ;\n\t\tvalid = psf_file_valid (psf) ;\n\t\tpsf_use_rsrc (psf, SF_FALSE) ;\n\t\tif (! valid)\n\t\t{\tpsf_log_printf (psf, \"sd2_open : psf->rsrc.filedes < 0\\n\") ;\n\t\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t\t} ;\n\n\t\terror = sd2_parse_rsrc_fork (psf) ;\n\n\t\tif (error)\n\t\t\tgoto error_cleanup ;\n\t\t} ;\n\n\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_SD2)\n\t{\terror = SFE_BAD_OPEN_FORMAT ;\n\t\tgoto error_cleanup ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\tpsf->dataoffset = 0 ;\n\n\t/* Only open and write the resource in RDWR mode is its current length is zero. */\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->rsrclength == 0))\n\t{\tpsf->rsrc.mode = psf->file.mode ;\n\t\tpsf_open_rsrc (psf) ;\n\n\t\terror = sd2_write_rsrc_fork (psf, SF_FALSE) ;\n\n\t\tif (error)\n\t\t\tgoto error_cleanup ;\n\n\t\t/* Not needed. */\n\t\tpsf->write_header = NULL ;\n\t\t} ;\n\n\tpsf->container_close = sd2_close ;\n\n\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_S8 :\t/* 8-bit linear PCM. */\n\t\tcase SF_FORMAT_PCM_16 :\t/* 16-bit linear PCM. */\n\t\tcase SF_FORMAT_PCM_24 :\t/* 24-bit linear PCM */\n\t\tcase SF_FORMAT_PCM_32 :\t/* 32-bit linear PCM */\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_UNIMPLEMENTED ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\nerror_cleanup:\n\n\t/* Close the resource fork regardless. We won't need it again. */\n\tpsf_close_rsrc (psf) ;\n\n\treturn error ;\n} /* sd2_open */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int\nsd2_close\t(SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_WRITE)\n\t{\t/*  Now we know for certain the audio_length of the file we can re-write\n\t\t**\tcorrect values for the FORM, 8SVX and BODY chunks.\n\t\t*/\n\n\t\t} ;\n\n\treturn 0 ;\n} /* sd2_close */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic inline void\nwrite_char (unsigned char * data, int offset, char value)\n{\tdata [offset] = value ;\n} /* write_char */\n\nstatic inline void\nwrite_short (unsigned char * data, int offset, short value)\n{\tdata [offset] = value >> 8 ;\n\tdata [offset + 1] = value ;\n} /* write_char */\n\nstatic inline void\nwrite_int (unsigned char * data, int offset, int value)\n{\tdata [offset] = value >> 24 ;\n\tdata [offset + 1] = value >> 16 ;\n\tdata [offset + 2] = value >> 8 ;\n\tdata [offset + 3] = value ;\n} /* write_int */\n\nstatic inline void\nwrite_marker (unsigned char * data, int offset, int value)\n{\n\tif (CPU_IS_BIG_ENDIAN)\n\t{\tdata [offset] = value >> 24 ;\n\t\tdata [offset + 1] = value >> 16 ;\n\t\tdata [offset + 2] = value >> 8 ;\n\t\tdata [offset + 3] = value ;\n\t\t}\n\telse\n\t{\tdata [offset] = value ;\n\t\tdata [offset + 1] = value >> 8 ;\n\t\tdata [offset + 2] = value >> 16 ;\n\t\tdata [offset + 3] = value >> 24 ;\n\t\t} ;\n} /* write_marker */\n\nstatic void\nwrite_str (unsigned char * data, int offset, const char * buffer, int buffer_len)\n{\tmemcpy (data + offset, buffer, buffer_len) ;\n} /* write_str */\n\nstatic int\nsd2_write_rsrc_fork (SF_PRIVATE *psf, int UNUSED (calc_length))\n{\tSD2_RSRC rsrc ;\n\tSTR_RSRC str_rsrc [] =\n\t{\t{ RSRC_STR, 1000, \"_sample-size\", \"\", 0 },\n\t\t{ RSRC_STR, 1001, \"_sample-rate\", \"\", 0 },\n\t\t{ RSRC_STR, 1002, \"_channels\", \"\", 0 },\n\t\t{ RSRC_BIN, 1000, \"_Markers\", \"\", 8 }\n\t\t} ;\n\n\tint k, str_offset, data_offset, next_str ;\n\n\tpsf_use_rsrc (psf, SF_TRUE) ;\n\n\tmemset (&rsrc, 0, sizeof (rsrc)) ;\n\n\trsrc.sample_rate = psf->sf.samplerate ;\n\trsrc.sample_size = psf->bytewidth ;\n\trsrc.channels = psf->sf.channels ;\n\n\trsrc.rsrc_data = psf->header ;\n\trsrc.rsrc_len = sizeof (psf->header) ;\n\tmemset (rsrc.rsrc_data, 0xea, rsrc.rsrc_len) ;\n\n\tsnprintf (str_rsrc [0].value, sizeof (str_rsrc [0].value), \"_%d\", rsrc.sample_size) ;\n\tsnprintf (str_rsrc [1].value, sizeof (str_rsrc [1].value), \"_%d.000000\", rsrc.sample_rate) ;\n\tsnprintf (str_rsrc [2].value, sizeof (str_rsrc [2].value), \"_%d\", rsrc.channels) ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t{\tif (str_rsrc [k].value_len == 0)\n\t\t{\tstr_rsrc [k].value_len = strlen (str_rsrc [k].value) ;\n\t\t\tstr_rsrc [k].value [0] = str_rsrc [k].value_len - 1 ;\n\t\t\t} ;\n\n\t\t/* Turn name string into a pascal string. */\n\t\tstr_rsrc [k].name [0] = strlen (str_rsrc [k].name) - 1 ;\n\t\t} ;\n\n\trsrc.data_offset = 0x100 ;\n\n\t/*\n\t** Calculate data length :\n\t**\t\tlength of strings, plus the length of the sdML chunk.\n\t*/\n\trsrc.data_length = 0 ;\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t\trsrc.data_length += str_rsrc [k].value_len + 4 ;\n\n\trsrc.map_offset = rsrc.data_offset + rsrc.data_length ;\n\n\t/* Very start of resource fork. */\n\twrite_int (rsrc.rsrc_data, 0, rsrc.data_offset) ;\n\twrite_int (rsrc.rsrc_data, 4, rsrc.map_offset) ;\n\twrite_int (rsrc.rsrc_data, 8, rsrc.data_length) ;\n\n\twrite_char (rsrc.rsrc_data, 0x30, strlen (psf->file.name.c)) ;\n\twrite_str (rsrc.rsrc_data, 0x31, psf->file.name.c, strlen (psf->file.name.c)) ;\n\n\twrite_short (rsrc.rsrc_data, 0x50, 0) ;\n\twrite_marker (rsrc.rsrc_data, 0x52, Sd2f_MARKER) ;\n\twrite_marker (rsrc.rsrc_data, 0x56, lsf1_MARKER) ;\n\n\t/* Very start of resource map. */\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 0, rsrc.data_offset) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 4, rsrc.map_offset) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 8, rsrc.data_length) ;\n\n\t/* These I don't currently understand. */\n\tif (1)\n\t{\twrite_char (rsrc.rsrc_data, rsrc.map_offset+ 16, 1) ;\n\t\t/* Next resource map. */\n\t\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 17, 0x12345678) ;\n\t\t/* File ref number. */\n\t\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 21, 0xabcd) ;\n\t\t/* Fork attributes. */\n\t\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 23, 0) ;\n\t\t} ;\n\n\t/* Resource type offset. */\n\trsrc.type_offset = rsrc.map_offset + 30 ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 24, rsrc.type_offset - rsrc.map_offset - 2) ;\n\n\t/* Type index max. */\n\trsrc.type_count = 2 ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 28, rsrc.type_count - 1) ;\n\n\trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;\n\n\trsrc.str_count = ARRAY_LEN (str_rsrc) ;\n\trsrc.string_offset = rsrc.item_offset + (rsrc.str_count + 1) * 12 - rsrc.map_offset ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 26, rsrc.string_offset) ;\n\n\t/* Write 'STR ' resource type. */\n\trsrc.str_count = 3 ;\n\twrite_marker (rsrc.rsrc_data, rsrc.type_offset, STR_MARKER) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 4, rsrc.str_count - 1) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 6, 0x12) ;\n\n\t/* Write 'sdML' resource type. */\n\twrite_marker (rsrc.rsrc_data, rsrc.type_offset + 8, sdML_MARKER) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 12, 0) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 14, 0x36) ;\n\n\tstr_offset = rsrc.map_offset + rsrc.string_offset ;\n\tnext_str = 0 ;\n\tdata_offset = rsrc.data_offset ;\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t{\twrite_str (rsrc.rsrc_data, str_offset, str_rsrc [k].name, strlen (str_rsrc [k].name)) ;\n\n\t\twrite_short (rsrc.rsrc_data, rsrc.item_offset + k * 12, str_rsrc [k].id) ;\n\t\twrite_short (rsrc.rsrc_data, rsrc.item_offset + k * 12 + 2, next_str) ;\n\n\t\tstr_offset += strlen (str_rsrc [k].name) ;\n\t\tnext_str += strlen (str_rsrc [k].name) ;\n\n\t\twrite_int (rsrc.rsrc_data, rsrc.item_offset + k * 12 + 4, data_offset - rsrc.data_offset) ;\n\n\t\twrite_int (rsrc.rsrc_data, data_offset, str_rsrc [k].value_len) ;\n\t\twrite_str (rsrc.rsrc_data, data_offset + 4, str_rsrc [k].value, str_rsrc [k].value_len) ;\n\t\tdata_offset += 4 + str_rsrc [k].value_len ;\n\t\t} ;\n\n\t/* Finally, calculate and set map length. */\n\trsrc.map_length = str_offset - rsrc.map_offset ;\n\twrite_int (rsrc.rsrc_data, 12, rsrc.map_length) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 12, rsrc.map_length) ;\n\n\trsrc.rsrc_len = rsrc.map_offset + rsrc.map_length ;\n\n\tpsf_fwrite (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;\n\n\tpsf_use_rsrc (psf, SF_FALSE) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\treturn 0 ;\n} /* sd2_write_rsrc_fork */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic inline int\nread_rsrc_char (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn data [offset] ;\n} /* read_rsrc_char */\n\nstatic inline int\nread_rsrc_short (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset + 1 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn (data [offset] << 8) + data [offset + 1] ;\n} /* read_rsrc_short */\n\nstatic inline int\nread_rsrc_int (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset + 3 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn (((uint32_t) data [offset]) << 24) + (data [offset + 1] << 16) + (data [offset + 2] << 8) + data [offset + 3] ;\n} /* read_rsrc_int */\n\nstatic inline int\nread_rsrc_marker (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\n\tif (offset < 0 || offset + 3 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\n\tif (CPU_IS_BIG_ENDIAN)\n\t\treturn (((uint32_t) data [offset]) << 24) + (data [offset + 1] << 16) + (data [offset + 2] << 8) + data [offset + 3] ;\n\tif (CPU_IS_LITTLE_ENDIAN)\n\t\treturn data [offset] + (data [offset + 1] << 8) + (data [offset + 2] << 16) + (((uint32_t) data [offset + 3]) << 24) ;\n\n\treturn 0 ;\n} /* read_rsrc_marker */\n\nstatic void\nread_rsrc_str (const SD2_RSRC *prsrc, int offset, char * buffer, int buffer_len)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tint k ;\n\n\tmemset (buffer, 0, buffer_len) ;\n\n\tif (offset < 0 || offset + buffer_len >= prsrc->rsrc_len)\n\t\treturn ;\n\n\tfor (k = 0 ; k < buffer_len - 1 ; k++)\n\t{\tif (psf_isprint (data [offset + k]) == 0)\n\t\t\treturn ;\n\t\tbuffer [k] = data [offset + k] ;\n\t\t} ;\n\treturn ;\n} /* read_rsrc_str */\n\nstatic int\nsd2_parse_rsrc_fork (SF_PRIVATE *psf)\n{\tSD2_RSRC rsrc ;\n\tint k, marker, error = 0 ;\n\n\tpsf_use_rsrc (psf, SF_TRUE) ;\n\n\tmemset (&rsrc, 0, sizeof (rsrc)) ;\n\n\trsrc.rsrc_len = psf_get_filelen (psf) ;\n\tpsf_log_printf (psf, \"Resource length : %d (0x%04X)\\n\", rsrc.rsrc_len, rsrc.rsrc_len) ;\n\n\tif (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))\n\t{\trsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;\n\t\trsrc.need_to_free_rsrc_data = SF_TRUE ;\n\t\t}\n\telse\n\t{\n\t\trsrc.rsrc_data = psf->header ;\n\t\trsrc.need_to_free_rsrc_data = SF_FALSE ;\n\t\t} ;\n\n\t/* Read in the whole lot. */\n\tpsf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;\n\n\t/* Reset the header storage because we have changed to the rsrcdes. */\n\tpsf->headindex = psf->headend = rsrc.rsrc_len ;\n\n\trsrc.data_offset = read_rsrc_int (&rsrc, 0) ;\n\trsrc.map_offset = read_rsrc_int (&rsrc, 4) ;\n\trsrc.data_length = read_rsrc_int (&rsrc, 8) ;\n\trsrc.map_length = read_rsrc_int (&rsrc, 12) ;\n\n\tif (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)\n\t{\tpsf_log_printf (psf, \"Trying offset of 0x52 bytes.\\n\") ;\n\t\trsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;\n\t\trsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;\n\t\trsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;\n\t\trsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  data offset : 0x%04X\\n  map  offset : 0x%04X\\n\"\n\t\t\t\t\"  data length : 0x%04X\\n  map  length : 0x%04X\\n\",\n\t\t\t\trsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;\n\n\tif (rsrc.data_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.data_offset (%d, 0x%x) > len\\n\", rsrc.data_offset, rsrc.data_offset) ;\n\t\terror = SFE_SD2_BAD_DATA_OFFSET ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.map_offset > len\\n\") ;\n\t\terror = SFE_SD2_BAD_MAP_OFFSET ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.data_length > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.data_length > len\\n\") ;\n\t\terror = SFE_SD2_BAD_DATA_LENGTH ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_length > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.map_length > len\\n\") ;\n\t\terror = SFE_SD2_BAD_MAP_LENGTH ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : This does not look like a MacOSX resource fork.\\n\") ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_offset + 28 >= rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad map offset (%d + 28 > %d).\\n\", rsrc.map_offset, rsrc.rsrc_len) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;\n\tif (rsrc.string_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad string offset (%d).\\n\", rsrc.string_offset) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.type_offset = rsrc.map_offset + 30 ;\n\n\trsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;\n\tif (rsrc.type_count < 1)\n\t{\tpsf_log_printf (psf, \"Bad type count.\\n\") ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;\n\tif (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad item offset (%d).\\n\", rsrc.item_offset) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.str_index = -1 ;\n\tfor (k = 0 ; k < rsrc.type_count ; k ++)\n\t{\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;\n\n\t\tif (marker == STR_MARKER)\n\t\t{\trsrc.str_index = k ;\n\t\t\trsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;\n\t\t\terror = parse_str_rsrc (psf, &rsrc) ;\n\t\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t\t} ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"No 'STR ' resource.\\n\") ;\n\terror = SFE_SD2_BAD_RSRC ;\n\nparse_rsrc_fork_cleanup :\n\n\tpsf_use_rsrc (psf, SF_FALSE) ;\n\n\tif (rsrc.need_to_free_rsrc_data)\n\t\tfree (rsrc.rsrc_data) ;\n\n\treturn error ;\n} /* sd2_parse_rsrc_fork */\n\nstatic int\nparse_str_rsrc (SF_PRIVATE *psf, SD2_RSRC * rsrc)\n{\tchar name [32], value [32] ;\n\tint k, str_offset, rsrc_id, data_offset = 0, data_len = 0 ;\n\n\tpsf_log_printf (psf, \"Finding parameters :\\n\") ;\n\n\tstr_offset = rsrc->string_offset ;\n\tpsf_log_printf (psf, \"  Offset    RsrcId    dlen    slen    Value\\n\") ;\n\n\tfor (k = 0 ; data_offset + data_len < rsrc->rsrc_len ; k++)\n\t{\tint slen ;\n\n\t\tslen = read_rsrc_char (rsrc, str_offset) ;\n\t\tread_rsrc_str (rsrc, str_offset + 1, name, SF_MIN (SIGNED_SIZEOF (name), slen + 1)) ;\n\t\tstr_offset += slen + 1 ;\n\n\t\trsrc_id = read_rsrc_short (rsrc, rsrc->item_offset + k * 12) ;\n\n\t\tdata_offset = rsrc->data_offset + read_rsrc_int (rsrc, rsrc->item_offset + k * 12 + 4) ;\n\t\tif (data_offset < 0 || data_offset > rsrc->rsrc_len)\n\t\t{\tpsf_log_printf (psf, \"Exiting parser on data offset of %d.\\n\", data_offset) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tdata_len = read_rsrc_int (rsrc, data_offset) ;\n\t\tif (data_len < 0 || data_len > rsrc->rsrc_len)\n\t\t{\tpsf_log_printf (psf, \"Exiting parser on data length of %d.\\n\", data_len) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tslen = read_rsrc_char (rsrc, data_offset + 4) ;\n\t\tread_rsrc_str (rsrc, data_offset + 5, value, SF_MIN (SIGNED_SIZEOF (value), slen + 1)) ;\n\n\t\tpsf_log_printf (psf, \"  0x%04x     %4d     %4d     %3d    '%s'\\n\", data_offset, rsrc_id, data_len, slen, value) ;\n\n\t\tif (rsrc_id == 1000 && rsrc->sample_size == 0)\n\t\t\trsrc->sample_size = strtol (value, NULL, 10) ;\n\t\telse if (rsrc_id == 1001 && rsrc->sample_rate == 0)\n\t\t\trsrc->sample_rate = strtol (value, NULL, 10) ;\n\t\telse if (rsrc_id == 1002 && rsrc->channels == 0)\n\t\t\trsrc->channels = strtol (value, NULL, 10) ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"Found Parameters :\\n\") ;\n\tpsf_log_printf (psf, \"  sample-size : %d\\n\", rsrc->sample_size) ;\n\tpsf_log_printf (psf, \"  sample-rate : %d\\n\", rsrc->sample_rate) ;\n\tpsf_log_printf (psf, \"  channels    : %d\\n\", rsrc->channels) ;\n\n\tif (rsrc->sample_rate <= 4 && rsrc->sample_size > 4)\n\t{\tint temp ;\n\n\t\tpsf_log_printf (psf, \"Geez!! Looks like sample rate and sample size got switched.\\nCorrecting this screw up.\\n\") ;\n\t\ttemp = rsrc->sample_rate ;\n\t\trsrc->sample_rate = rsrc->sample_size ;\n\t\trsrc->sample_size = temp ;\n\t\t} ;\n\n\tif (rsrc->sample_rate < 0)\n\t{\tpsf_log_printf (psf, \"Bad sample rate (%d)\\n\", rsrc->sample_rate) ;\n\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t} ;\n\n\tif (rsrc->channels < 0)\n\t{\tpsf_log_printf (psf, \"Bad channel count (%d)\\n\", rsrc->channels) ;\n\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t} ;\n\n\tpsf->sf.samplerate = rsrc->sample_rate ;\n\tpsf->sf.channels = rsrc->channels ;\n\tpsf->bytewidth = rsrc->sample_size ;\n\n\tswitch (rsrc->sample_size)\n\t{\tcase 1 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_S8 ;\n\t\t\tbreak ;\n\n\t\tcase 2 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_16 ;\n\t\t\tbreak ;\n\n\t\tcase 3 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_24 ;\n\t\t\tbreak ;\n\n\t\tcase 4 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_32 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad sample size (%d)\\n\", rsrc->sample_size) ;\n\t\t\treturn SFE_SD2_BAD_SAMPLE_SIZE ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"ok\\n\") ;\n\n\treturn 0 ;\n} /* parse_str_rsrc */\n\n"], "fixing_code": ["/*\n** Copyright (C) 2001-2014 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2004 Paavo Jumppanen\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n/*\n** The sd2 support implemented in this file was partially sponsored\n** (financially) by Paavo Jumppanen.\n*/\n\n/*\n** Documentation on the Mac resource fork was obtained here :\n** http://developer.apple.com/documentation/mac/MoreToolbox/MoreToolbox-99.html\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdio.h>\n#include\t<stdlib.h>\n#include\t<string.h>\n#include\t<ctype.h>\n\n#include\t\"sndfile.h\"\n#include\t\"sfendian.h\"\n#include\t\"common.h\"\n\n/*------------------------------------------------------------------------------\n * Markers.\n*/\n\n#define\tSd2f_MARKER\t\t\tMAKE_MARKER ('S', 'd', '2', 'f')\n#define\tSd2a_MARKER\t\t\tMAKE_MARKER ('S', 'd', '2', 'a')\n#define\tALCH_MARKER\t\t\tMAKE_MARKER ('A', 'L', 'C', 'H')\n#define lsf1_MARKER\t\t\tMAKE_MARKER ('l', 's', 'f', '1')\n\n#define STR_MARKER\t\t\tMAKE_MARKER ('S', 'T', 'R', ' ')\n#define sdML_MARKER\t\t\tMAKE_MARKER ('s', 'd', 'M', 'L')\n\nenum\n{\tRSRC_STR = 111,\n\tRSRC_BIN\n} ;\n\ntypedef struct\n{\tunsigned char * rsrc_data ;\n\tint rsrc_len ;\n\tint need_to_free_rsrc_data ;\n\n\tint data_offset, data_length ;\n\tint map_offset, map_length ;\n\n\tint type_count, type_offset ;\n\tint item_offset ;\n\n\tint str_index, str_count ;\n\n\tint string_offset ;\n\n\t/* All the above just to get these three. */\n\tint sample_size, sample_rate, channels ;\n} SD2_RSRC ;\n\ntypedef struct\n{\tint type ;\n\tint id ;\n\tchar name [32] ;\n\tchar value [32] ;\n\tint value_len ;\n} STR_RSRC ;\n\n/*------------------------------------------------------------------------------\n * Private static functions.\n*/\n\nstatic int sd2_close\t(SF_PRIVATE *psf) ;\n\nstatic int sd2_parse_rsrc_fork (SF_PRIVATE *psf) ;\nstatic int parse_str_rsrc (SF_PRIVATE *psf, SD2_RSRC * rsrc) ;\n\nstatic int sd2_write_rsrc_fork (SF_PRIVATE *psf, int calc_length) ;\n\n/*------------------------------------------------------------------------------\n** Public functions.\n*/\n\nint\nsd2_open (SF_PRIVATE *psf)\n{\tint subformat, error = 0, valid ;\n\n\t/* SD2 is always big endian. */\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->rsrclength > 0))\n\t{\tpsf_use_rsrc (psf, SF_TRUE) ;\n\t\tvalid = psf_file_valid (psf) ;\n\t\tpsf_use_rsrc (psf, SF_FALSE) ;\n\t\tif (! valid)\n\t\t{\tpsf_log_printf (psf, \"sd2_open : psf->rsrc.filedes < 0\\n\") ;\n\t\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t\t} ;\n\n\t\terror = sd2_parse_rsrc_fork (psf) ;\n\n\t\tif (error)\n\t\t\tgoto error_cleanup ;\n\t\t} ;\n\n\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_SD2)\n\t{\terror = SFE_BAD_OPEN_FORMAT ;\n\t\tgoto error_cleanup ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\tpsf->dataoffset = 0 ;\n\n\t/* Only open and write the resource in RDWR mode is its current length is zero. */\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->rsrclength == 0))\n\t{\tpsf->rsrc.mode = psf->file.mode ;\n\t\tpsf_open_rsrc (psf) ;\n\n\t\terror = sd2_write_rsrc_fork (psf, SF_FALSE) ;\n\n\t\tif (error)\n\t\t\tgoto error_cleanup ;\n\n\t\t/* Not needed. */\n\t\tpsf->write_header = NULL ;\n\t\t} ;\n\n\tpsf->container_close = sd2_close ;\n\n\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_S8 :\t/* 8-bit linear PCM. */\n\t\tcase SF_FORMAT_PCM_16 :\t/* 16-bit linear PCM. */\n\t\tcase SF_FORMAT_PCM_24 :\t/* 24-bit linear PCM */\n\t\tcase SF_FORMAT_PCM_32 :\t/* 32-bit linear PCM */\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_UNIMPLEMENTED ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\nerror_cleanup:\n\n\t/* Close the resource fork regardless. We won't need it again. */\n\tpsf_close_rsrc (psf) ;\n\n\treturn error ;\n} /* sd2_open */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int\nsd2_close\t(SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_WRITE)\n\t{\t/*  Now we know for certain the audio_length of the file we can re-write\n\t\t**\tcorrect values for the FORM, 8SVX and BODY chunks.\n\t\t*/\n\n\t\t} ;\n\n\treturn 0 ;\n} /* sd2_close */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic inline void\nwrite_char (unsigned char * data, int offset, char value)\n{\tdata [offset] = value ;\n} /* write_char */\n\nstatic inline void\nwrite_short (unsigned char * data, int offset, short value)\n{\tdata [offset] = value >> 8 ;\n\tdata [offset + 1] = value ;\n} /* write_char */\n\nstatic inline void\nwrite_int (unsigned char * data, int offset, int value)\n{\tdata [offset] = value >> 24 ;\n\tdata [offset + 1] = value >> 16 ;\n\tdata [offset + 2] = value >> 8 ;\n\tdata [offset + 3] = value ;\n} /* write_int */\n\nstatic inline void\nwrite_marker (unsigned char * data, int offset, int value)\n{\n\tif (CPU_IS_BIG_ENDIAN)\n\t{\tdata [offset] = value >> 24 ;\n\t\tdata [offset + 1] = value >> 16 ;\n\t\tdata [offset + 2] = value >> 8 ;\n\t\tdata [offset + 3] = value ;\n\t\t}\n\telse\n\t{\tdata [offset] = value ;\n\t\tdata [offset + 1] = value >> 8 ;\n\t\tdata [offset + 2] = value >> 16 ;\n\t\tdata [offset + 3] = value >> 24 ;\n\t\t} ;\n} /* write_marker */\n\nstatic void\nwrite_str (unsigned char * data, int offset, const char * buffer, int buffer_len)\n{\tmemcpy (data + offset, buffer, buffer_len) ;\n} /* write_str */\n\nstatic int\nsd2_write_rsrc_fork (SF_PRIVATE *psf, int UNUSED (calc_length))\n{\tSD2_RSRC rsrc ;\n\tSTR_RSRC str_rsrc [] =\n\t{\t{ RSRC_STR, 1000, \"_sample-size\", \"\", 0 },\n\t\t{ RSRC_STR, 1001, \"_sample-rate\", \"\", 0 },\n\t\t{ RSRC_STR, 1002, \"_channels\", \"\", 0 },\n\t\t{ RSRC_BIN, 1000, \"_Markers\", \"\", 8 }\n\t\t} ;\n\n\tint k, str_offset, data_offset, next_str ;\n\n\tpsf_use_rsrc (psf, SF_TRUE) ;\n\n\tmemset (&rsrc, 0, sizeof (rsrc)) ;\n\n\trsrc.sample_rate = psf->sf.samplerate ;\n\trsrc.sample_size = psf->bytewidth ;\n\trsrc.channels = psf->sf.channels ;\n\n\trsrc.rsrc_data = psf->header ;\n\trsrc.rsrc_len = sizeof (psf->header) ;\n\tmemset (rsrc.rsrc_data, 0xea, rsrc.rsrc_len) ;\n\n\tsnprintf (str_rsrc [0].value, sizeof (str_rsrc [0].value), \"_%d\", rsrc.sample_size) ;\n\tsnprintf (str_rsrc [1].value, sizeof (str_rsrc [1].value), \"_%d.000000\", rsrc.sample_rate) ;\n\tsnprintf (str_rsrc [2].value, sizeof (str_rsrc [2].value), \"_%d\", rsrc.channels) ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t{\tif (str_rsrc [k].value_len == 0)\n\t\t{\tstr_rsrc [k].value_len = strlen (str_rsrc [k].value) ;\n\t\t\tstr_rsrc [k].value [0] = str_rsrc [k].value_len - 1 ;\n\t\t\t} ;\n\n\t\t/* Turn name string into a pascal string. */\n\t\tstr_rsrc [k].name [0] = strlen (str_rsrc [k].name) - 1 ;\n\t\t} ;\n\n\trsrc.data_offset = 0x100 ;\n\n\t/*\n\t** Calculate data length :\n\t**\t\tlength of strings, plus the length of the sdML chunk.\n\t*/\n\trsrc.data_length = 0 ;\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t\trsrc.data_length += str_rsrc [k].value_len + 4 ;\n\n\trsrc.map_offset = rsrc.data_offset + rsrc.data_length ;\n\n\t/* Very start of resource fork. */\n\twrite_int (rsrc.rsrc_data, 0, rsrc.data_offset) ;\n\twrite_int (rsrc.rsrc_data, 4, rsrc.map_offset) ;\n\twrite_int (rsrc.rsrc_data, 8, rsrc.data_length) ;\n\n\twrite_char (rsrc.rsrc_data, 0x30, strlen (psf->file.name.c)) ;\n\twrite_str (rsrc.rsrc_data, 0x31, psf->file.name.c, strlen (psf->file.name.c)) ;\n\n\twrite_short (rsrc.rsrc_data, 0x50, 0) ;\n\twrite_marker (rsrc.rsrc_data, 0x52, Sd2f_MARKER) ;\n\twrite_marker (rsrc.rsrc_data, 0x56, lsf1_MARKER) ;\n\n\t/* Very start of resource map. */\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 0, rsrc.data_offset) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 4, rsrc.map_offset) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 8, rsrc.data_length) ;\n\n\t/* These I don't currently understand. */\n\tif (1)\n\t{\twrite_char (rsrc.rsrc_data, rsrc.map_offset+ 16, 1) ;\n\t\t/* Next resource map. */\n\t\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 17, 0x12345678) ;\n\t\t/* File ref number. */\n\t\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 21, 0xabcd) ;\n\t\t/* Fork attributes. */\n\t\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 23, 0) ;\n\t\t} ;\n\n\t/* Resource type offset. */\n\trsrc.type_offset = rsrc.map_offset + 30 ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 24, rsrc.type_offset - rsrc.map_offset - 2) ;\n\n\t/* Type index max. */\n\trsrc.type_count = 2 ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 28, rsrc.type_count - 1) ;\n\n\trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;\n\n\trsrc.str_count = ARRAY_LEN (str_rsrc) ;\n\trsrc.string_offset = rsrc.item_offset + (rsrc.str_count + 1) * 12 - rsrc.map_offset ;\n\twrite_short (rsrc.rsrc_data, rsrc.map_offset + 26, rsrc.string_offset) ;\n\n\t/* Write 'STR ' resource type. */\n\trsrc.str_count = 3 ;\n\twrite_marker (rsrc.rsrc_data, rsrc.type_offset, STR_MARKER) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 4, rsrc.str_count - 1) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 6, 0x12) ;\n\n\t/* Write 'sdML' resource type. */\n\twrite_marker (rsrc.rsrc_data, rsrc.type_offset + 8, sdML_MARKER) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 12, 0) ;\n\twrite_short (rsrc.rsrc_data, rsrc.type_offset + 14, 0x36) ;\n\n\tstr_offset = rsrc.map_offset + rsrc.string_offset ;\n\tnext_str = 0 ;\n\tdata_offset = rsrc.data_offset ;\n\tfor (k = 0 ; k < ARRAY_LEN (str_rsrc) ; k++)\n\t{\twrite_str (rsrc.rsrc_data, str_offset, str_rsrc [k].name, strlen (str_rsrc [k].name)) ;\n\n\t\twrite_short (rsrc.rsrc_data, rsrc.item_offset + k * 12, str_rsrc [k].id) ;\n\t\twrite_short (rsrc.rsrc_data, rsrc.item_offset + k * 12 + 2, next_str) ;\n\n\t\tstr_offset += strlen (str_rsrc [k].name) ;\n\t\tnext_str += strlen (str_rsrc [k].name) ;\n\n\t\twrite_int (rsrc.rsrc_data, rsrc.item_offset + k * 12 + 4, data_offset - rsrc.data_offset) ;\n\n\t\twrite_int (rsrc.rsrc_data, data_offset, str_rsrc [k].value_len) ;\n\t\twrite_str (rsrc.rsrc_data, data_offset + 4, str_rsrc [k].value, str_rsrc [k].value_len) ;\n\t\tdata_offset += 4 + str_rsrc [k].value_len ;\n\t\t} ;\n\n\t/* Finally, calculate and set map length. */\n\trsrc.map_length = str_offset - rsrc.map_offset ;\n\twrite_int (rsrc.rsrc_data, 12, rsrc.map_length) ;\n\twrite_int (rsrc.rsrc_data, rsrc.map_offset + 12, rsrc.map_length) ;\n\n\trsrc.rsrc_len = rsrc.map_offset + rsrc.map_length ;\n\n\tpsf_fwrite (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;\n\n\tpsf_use_rsrc (psf, SF_FALSE) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\treturn 0 ;\n} /* sd2_write_rsrc_fork */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic inline int\nread_rsrc_char (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn data [offset] ;\n} /* read_rsrc_char */\n\nstatic inline int\nread_rsrc_short (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset + 1 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn (data [offset] << 8) + data [offset + 1] ;\n} /* read_rsrc_short */\n\nstatic inline int\nread_rsrc_int (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tif (offset < 0 || offset + 3 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\treturn (((uint32_t) data [offset]) << 24) + (data [offset + 1] << 16) + (data [offset + 2] << 8) + data [offset + 3] ;\n} /* read_rsrc_int */\n\nstatic inline int\nread_rsrc_marker (const SD2_RSRC *prsrc, int offset)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\n\tif (offset < 0 || offset + 3 >= prsrc->rsrc_len)\n\t\treturn 0 ;\n\n\tif (CPU_IS_BIG_ENDIAN)\n\t\treturn (((uint32_t) data [offset]) << 24) + (data [offset + 1] << 16) + (data [offset + 2] << 8) + data [offset + 3] ;\n\tif (CPU_IS_LITTLE_ENDIAN)\n\t\treturn data [offset] + (data [offset + 1] << 8) + (data [offset + 2] << 16) + (((uint32_t) data [offset + 3]) << 24) ;\n\n\treturn 0 ;\n} /* read_rsrc_marker */\n\nstatic void\nread_rsrc_str (const SD2_RSRC *prsrc, int offset, char * buffer, int buffer_len)\n{\tconst unsigned char * data = prsrc->rsrc_data ;\n\tint k ;\n\n\tmemset (buffer, 0, buffer_len) ;\n\n\tif (offset < 0 || offset + buffer_len >= prsrc->rsrc_len)\n\t\treturn ;\n\n\tfor (k = 0 ; k < buffer_len - 1 ; k++)\n\t{\tif (psf_isprint (data [offset + k]) == 0)\n\t\t\treturn ;\n\t\tbuffer [k] = data [offset + k] ;\n\t\t} ;\n\treturn ;\n} /* read_rsrc_str */\n\nstatic int\nsd2_parse_rsrc_fork (SF_PRIVATE *psf)\n{\tSD2_RSRC rsrc ;\n\tint k, marker, error = 0 ;\n\n\tpsf_use_rsrc (psf, SF_TRUE) ;\n\n\tmemset (&rsrc, 0, sizeof (rsrc)) ;\n\n\trsrc.rsrc_len = psf_get_filelen (psf) ;\n\tpsf_log_printf (psf, \"Resource length : %d (0x%04X)\\n\", rsrc.rsrc_len, rsrc.rsrc_len) ;\n\n\tif (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))\n\t{\trsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;\n\t\trsrc.need_to_free_rsrc_data = SF_TRUE ;\n\t\t}\n\telse\n\t{\n\t\trsrc.rsrc_data = psf->header ;\n\t\trsrc.need_to_free_rsrc_data = SF_FALSE ;\n\t\t} ;\n\n\t/* Read in the whole lot. */\n\tpsf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;\n\n\t/* Reset the header storage because we have changed to the rsrcdes. */\n\tpsf->headindex = psf->headend = rsrc.rsrc_len ;\n\n\trsrc.data_offset = read_rsrc_int (&rsrc, 0) ;\n\trsrc.map_offset = read_rsrc_int (&rsrc, 4) ;\n\trsrc.data_length = read_rsrc_int (&rsrc, 8) ;\n\trsrc.map_length = read_rsrc_int (&rsrc, 12) ;\n\n\tif (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)\n\t{\tpsf_log_printf (psf, \"Trying offset of 0x52 bytes.\\n\") ;\n\t\trsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;\n\t\trsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;\n\t\trsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;\n\t\trsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  data offset : 0x%04X\\n  map  offset : 0x%04X\\n\"\n\t\t\t\t\"  data length : 0x%04X\\n  map  length : 0x%04X\\n\",\n\t\t\t\trsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;\n\n\tif (rsrc.data_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.data_offset (%d, 0x%x) > len\\n\", rsrc.data_offset, rsrc.data_offset) ;\n\t\terror = SFE_SD2_BAD_DATA_OFFSET ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.map_offset > len\\n\") ;\n\t\terror = SFE_SD2_BAD_MAP_OFFSET ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.data_length > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.data_length > len\\n\") ;\n\t\terror = SFE_SD2_BAD_DATA_LENGTH ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_length > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : rsrc.map_length > len\\n\") ;\n\t\terror = SFE_SD2_BAD_MAP_LENGTH ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Error : This does not look like a MacOSX resource fork.\\n\") ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\tif (rsrc.map_offset + 28 >= rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad map offset (%d + 28 > %d).\\n\", rsrc.map_offset, rsrc.rsrc_len) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;\n\tif (rsrc.string_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad string offset (%d).\\n\", rsrc.string_offset) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.type_offset = rsrc.map_offset + 30 ;\n\n\tif (rsrc.map_offset + 28 > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad map offset.\\n\") ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;\n\tif (rsrc.type_count < 1)\n\t{\tpsf_log_printf (psf, \"Bad type count.\\n\") ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;\n\tif (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)\n\t{\tpsf_log_printf (psf, \"Bad item offset (%d).\\n\", rsrc.item_offset) ;\n\t\terror = SFE_SD2_BAD_RSRC ;\n\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t} ;\n\n\trsrc.str_index = -1 ;\n\tfor (k = 0 ; k < rsrc.type_count ; k ++)\n\t{\tif (rsrc.type_offset + k * 8 > rsrc.rsrc_len)\n\t\t{\tpsf_log_printf (psf, \"Bad rsrc marker.\\n\") ;\n\t\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t\t} ;\n\n\t\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;\n\n\t\tif (marker == STR_MARKER)\n\t\t{\trsrc.str_index = k ;\n\t\t\trsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;\n\t\t\terror = parse_str_rsrc (psf, &rsrc) ;\n\t\t\tgoto parse_rsrc_fork_cleanup ;\n\t\t\t} ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"No 'STR ' resource.\\n\") ;\n\terror = SFE_SD2_BAD_RSRC ;\n\nparse_rsrc_fork_cleanup :\n\n\tpsf_use_rsrc (psf, SF_FALSE) ;\n\n\tif (rsrc.need_to_free_rsrc_data)\n\t\tfree (rsrc.rsrc_data) ;\n\n\treturn error ;\n} /* sd2_parse_rsrc_fork */\n\nstatic int\nparse_str_rsrc (SF_PRIVATE *psf, SD2_RSRC * rsrc)\n{\tchar name [32], value [32] ;\n\tint k, str_offset, rsrc_id, data_offset = 0, data_len = 0 ;\n\n\tpsf_log_printf (psf, \"Finding parameters :\\n\") ;\n\n\tstr_offset = rsrc->string_offset ;\n\tpsf_log_printf (psf, \"  Offset    RsrcId    dlen    slen    Value\\n\") ;\n\n\tfor (k = 0 ; data_offset + data_len < rsrc->rsrc_len ; k++)\n\t{\tint slen ;\n\n\t\tslen = read_rsrc_char (rsrc, str_offset) ;\n\t\tread_rsrc_str (rsrc, str_offset + 1, name, SF_MIN (SIGNED_SIZEOF (name), slen + 1)) ;\n\t\tstr_offset += slen + 1 ;\n\n\t\trsrc_id = read_rsrc_short (rsrc, rsrc->item_offset + k * 12) ;\n\n\t\tdata_offset = rsrc->data_offset + read_rsrc_int (rsrc, rsrc->item_offset + k * 12 + 4) ;\n\t\tif (data_offset < 0 || data_offset > rsrc->rsrc_len)\n\t\t{\tpsf_log_printf (psf, \"Exiting parser on data offset of %d.\\n\", data_offset) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tdata_len = read_rsrc_int (rsrc, data_offset) ;\n\t\tif (data_len < 0 || data_len > rsrc->rsrc_len)\n\t\t{\tpsf_log_printf (psf, \"Exiting parser on data length of %d.\\n\", data_len) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tslen = read_rsrc_char (rsrc, data_offset + 4) ;\n\t\tread_rsrc_str (rsrc, data_offset + 5, value, SF_MIN (SIGNED_SIZEOF (value), slen + 1)) ;\n\n\t\tpsf_log_printf (psf, \"  0x%04x     %4d     %4d     %3d    '%s'\\n\", data_offset, rsrc_id, data_len, slen, value) ;\n\n\t\tif (rsrc_id == 1000 && rsrc->sample_size == 0)\n\t\t\trsrc->sample_size = strtol (value, NULL, 10) ;\n\t\telse if (rsrc_id == 1001 && rsrc->sample_rate == 0)\n\t\t\trsrc->sample_rate = strtol (value, NULL, 10) ;\n\t\telse if (rsrc_id == 1002 && rsrc->channels == 0)\n\t\t\trsrc->channels = strtol (value, NULL, 10) ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"Found Parameters :\\n\") ;\n\tpsf_log_printf (psf, \"  sample-size : %d\\n\", rsrc->sample_size) ;\n\tpsf_log_printf (psf, \"  sample-rate : %d\\n\", rsrc->sample_rate) ;\n\tpsf_log_printf (psf, \"  channels    : %d\\n\", rsrc->channels) ;\n\n\tif (rsrc->sample_rate <= 4 && rsrc->sample_size > 4)\n\t{\tint temp ;\n\n\t\tpsf_log_printf (psf, \"Geez!! Looks like sample rate and sample size got switched.\\nCorrecting this screw up.\\n\") ;\n\t\ttemp = rsrc->sample_rate ;\n\t\trsrc->sample_rate = rsrc->sample_size ;\n\t\trsrc->sample_size = temp ;\n\t\t} ;\n\n\tif (rsrc->sample_rate < 0)\n\t{\tpsf_log_printf (psf, \"Bad sample rate (%d)\\n\", rsrc->sample_rate) ;\n\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t} ;\n\n\tif (rsrc->channels < 0)\n\t{\tpsf_log_printf (psf, \"Bad channel count (%d)\\n\", rsrc->channels) ;\n\t\treturn SFE_SD2_BAD_RSRC ;\n\t\t} ;\n\n\tpsf->sf.samplerate = rsrc->sample_rate ;\n\tpsf->sf.channels = rsrc->channels ;\n\tpsf->bytewidth = rsrc->sample_size ;\n\n\tswitch (rsrc->sample_size)\n\t{\tcase 1 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_S8 ;\n\t\t\tbreak ;\n\n\t\tcase 2 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_16 ;\n\t\t\tbreak ;\n\n\t\tcase 3 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_24 ;\n\t\t\tbreak ;\n\n\t\tcase 4 :\n\t\t\tpsf->sf.format = SF_FORMAT_SD2 | SF_FORMAT_PCM_32 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad sample size (%d)\\n\", rsrc->sample_size) ;\n\t\t\treturn SFE_SD2_BAD_SAMPLE_SIZE ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"ok\\n\") ;\n\n\treturn 0 ;\n} /* parse_str_rsrc */\n\n"], "filenames": ["src/sd2.c"], "buggy_code_start_loc": [519], "buggy_code_end_loc": [537], "fixing_code_start_loc": [520], "fixing_code_end_loc": [547], "type": "NVD-CWE-noinfo", "message": "The sd2_parse_rsrc_fork function in sd2.c in libsndfile allows attackers to have unspecified impact via vectors related to a (1) map offset or (2) rsrc marker, which triggers an out-of-bounds read.", "other": {"cve": {"id": "CVE-2014-9496", "sourceIdentifier": "cve@mitre.org", "published": "2015-01-16T16:59:16.030", "lastModified": "2020-11-20T17:34:08.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sd2_parse_rsrc_fork function in sd2.c in libsndfile allows attackers to have unspecified impact via vectors related to a (1) map offset or (2) rsrc marker, which triggers an out-of-bounds read."}, {"lang": "es", "value": "La funci\u00f3n sd2_parse_rsrc_fork en sd2.c en libsndfile permite a atacantes tener un impacto no especificado a trav\u00e9s de vectores relacionados con un (1) desplazamiento de mapa o (2) marcador rsrc, lo que provoca una lectura fuera de rango."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsndfile_project:libsndfile:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.26", "matchCriteriaId": "35427800-460C-4B42-B2AA-936ADD3D7BB6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.2:*:*:*:*:*:*:*", "matchCriteriaId": "0B1C288F-326B-497B-B26C-D26E01262DDB"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2015-0015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-01/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:024", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/01/04/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjan2015-2370101.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71796", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2832-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/erikd/libsndfile/commit/dbe14f00030af5d3577f4cabbf9861db59e9c378", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/erikd/libsndfile/issues/93", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Apr/23", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/erikd/libsndfile/commit/dbe14f00030af5d3577f4cabbf9861db59e9c378"}}