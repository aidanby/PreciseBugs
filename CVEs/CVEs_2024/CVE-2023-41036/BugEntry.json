{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * MMAppController\n *\n * MMAppController is the delegate of NSApp and as such handles file open\n * requests, application termination, etc.  It sets up a named NSConnection on\n * which it listens to incoming connections from Vim processes.  It also\n * coordinates all MMVimControllers and takes care of the main menu.\n *\n * A new Vim process is started by calling launchVimProcessWithArguments:.\n * When the Vim process is initialized it notifies the app controller by\n * sending a connectBackend:pid: message.  At this point a new MMVimController\n * is allocated.  Afterwards, the Vim process communicates directly with its\n * MMVimController.\n *\n * A Vim process started from the command line connects directly by sending the\n * connectBackend:pid: message (launchVimProcessWithArguments: is never called\n * in this case).\n *\n * The main menu is handled as follows.  Each Vim controller keeps its own main\n * menu.  All menus except the \"MacVim\" menu are controlled by the Vim process.\n * The app controller also keeps a reference to the \"default main menu\" which\n * is set up in MainMenu.nib.  When no editor window is open the default main\n * menu is used.  When a new editor window becomes main its main menu becomes\n * the new main menu, this is done in -[MMAppController setMainMenu:].\n *   NOTE: Certain heuristics are used to find the \"MacVim\", \"Windows\", \"File\",\n * and \"Services\" menu.  If MainMenu.nib changes these heuristics may have to\n * change as well.  For specifics see the find... methods defined in the NSMenu\n * category \"MMExtras\".\n */\n\n#import \"MMAppController.h\"\n#import \"MMPreferenceController.h\"\n#import \"MMVimController.h\"\n#import \"MMVimView.h\"\n#import \"MMWindowController.h\"\n#import \"MMTextView.h\"\n#import \"MMWhatsNewController.h\"\n#import \"Miscellaneous.h\"\n#import <unistd.h>\n#import <CoreServices/CoreServices.h>\n// Need Carbon for TIS...() functions\n#import <Carbon/Carbon.h>\n\n#if !DISABLE_SPARKLE\n#import \"MMSparkle2Delegate.h\"\n#import \"Sparkle.framework/Headers/Sparkle.h\"\n#endif\n\n\n#define MM_HANDLE_XCODE_MOD_EVENT 0\n\n\n\n// Default timeout intervals on all connections.\nstatic NSTimeInterval MMRequestTimeout = 5;\nstatic NSTimeInterval MMReplyTimeout = 5;\n\nstatic NSString *MMWebsiteString = @\"https://macvim-dev.github.io/macvim/\";\n\n// Latency (in s) between FS event occuring and being reported to MacVim.\n// Should be small so that MacVim is notified of changes to the ~/.vim\n// directory more or less immediately.\nstatic CFTimeInterval MMEventStreamLatency = 0.1;\n\nstatic float MMCascadeHorizontalOffset = 21;\nstatic float MMCascadeVerticalOffset = 23;\n\n\n#pragma pack(push,1)\n// The alignment and sizes of these fields are based on trial-and-error.  It\n// may be necessary to adjust them to fit if Xcode ever changes this struct.\ntypedef struct\n{\n    int16_t unused1;      // 0 (not used)\n    int16_t lineNum;      // line to select (< 0 to specify range)\n    int32_t startRange;   // start of selection range (if line < 0)\n    int32_t endRange;     // end of selection range (if line < 0)\n    int32_t unused2;      // 0 (not used)\n    int32_t theDate;      // modification date/time\n} MMXcodeSelectionRange;\n#pragma pack(pop)\n\n\n// This is a private AppKit API gleaned from class-dump.\n@interface NSKeyBindingManager : NSObject\n+ (id)sharedKeyBindingManager;\n- (id)dictionary;\n- (void)setDictionary:(id)arg1;\n@end\n\n\n@interface MMAppController (MMServices)\n- (void)openSelection:(NSPasteboard *)pboard userData:(NSString *)userData\n                error:(NSString **)error;\n- (void)openFile:(NSPasteboard *)pboard userData:(NSString *)userData\n           error:(NSString **)error;\n- (void)newFileHere:(NSPasteboard *)pboard userData:(NSString *)userData\n              error:(NSString **)error;\n@end\n\n\n@interface MMAppController (Private)\n- (void)startUpdaterAndWhatsNewPage;\n\n- (MMVimController *)topmostVimController;\n- (int)launchVimProcessWithArguments:(NSArray *)args\n                    workingDirectory:(NSString *)cwd;\n- (NSArray *)filterFilesAndNotify:(NSArray *)files;\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n               openFilesDict:(NSDictionary **)openFiles;\n#if MM_HANDLE_XCODE_MOD_EVENT\n- (void)handleXcodeModEvent:(NSAppleEventDescriptor *)event\n                 replyEvent:(NSAppleEventDescriptor *)reply;\n#endif\n- (void)handleGetURLEvent:(NSAppleEventDescriptor *)event\n               replyEvent:(NSAppleEventDescriptor *)reply;\n- (NSMutableDictionary *)extractArgumentsFromOdocEvent:\n    (NSAppleEventDescriptor *)desc;\n- (void)scheduleVimControllerPreloadAfterDelay:(NSTimeInterval)delay;\n- (void)cancelVimControllerPreloadRequests;\n- (void)preloadVimController:(id)sender;\n- (int)maxPreloadCacheSize;\n- (MMVimController *)takeVimControllerFromCache;\n- (void)clearPreloadCacheWithCount:(int)count;\n- (void)rebuildPreloadCache;\n- (NSDate *)rcFilesModificationDate;\n- (BOOL)openVimControllerWithArguments:(NSDictionary *)arguments;\n- (void)activateWhenNextWindowOpens;\n- (void)startWatchingVimDir;\n- (void)stopWatchingVimDir;\n- (void)handleFSEvent;\n- (int)executeInLoginShell:(NSString *)path arguments:(NSArray *)args;\n- (void)reapChildProcesses:(id)sender;\n- (void)processInputQueues:(id)sender;\n- (void)addVimController:(MMVimController *)vc;\n- (NSDictionary *)convertVimControllerArguments:(NSDictionary *)args\n                                  toCommandLine:(NSArray **)cmdline;\n- (NSString *)workingDirectoryForArguments:(NSDictionary *)args;\n- (NSScreen *)screenContainingTopLeftPoint:(NSPoint)pt;\n- (void)addInputSourceChangedObserver;\n- (void)removeInputSourceChangedObserver;\n- (void)inputSourceChanged:(NSNotification *)notification;\n@end\n\n\n\n    static void\nfsEventCallback(ConstFSEventStreamRef streamRef,\n                void *clientCallBackInfo,\n                size_t numEvents,\n                void *eventPaths,\n                const FSEventStreamEventFlags eventFlags[],\n                const FSEventStreamEventId eventIds[])\n{\n    [[MMAppController sharedInstance] handleFSEvent];\n}\n\n@implementation MMAppController\n\n+ (void)initialize\n{\n    static BOOL initDone = NO;\n    if (initDone) return;\n    initDone = YES;\n\n    ASLInit();\n\n    // HACK! The following user default must be reset, else Ctrl-q (or\n    // whichever key is specified by the default) will be blocked by the input\n    // manager (interpretKeyEvents: swallows that key).  (We can't use\n    // NSUserDefaults since it only allows us to write to the registration\n    // domain and this preference has \"higher precedence\" than that so such a\n    // change would have no effect.)\n    CFPreferencesSetAppValue(CFSTR(\"NSQuotedKeystrokeBinding\"),\n                             CFSTR(\"\"),\n                             kCFPreferencesCurrentApplication);\n\n    // Also disable NSRepeatCountBinding -- it is not enabled by default, but\n    // it does not make much sense to support it since Vim has its own way of\n    // dealing with repeat counts.\n    CFPreferencesSetAppValue(CFSTR(\"NSRepeatCountBinding\"),\n                             CFSTR(\"\"),\n                             kCFPreferencesCurrentApplication);\n\n    if ([NSWindow respondsToSelector:@selector(setAllowsAutomaticWindowTabbing:)]) {\n        // Disable automatic tabbing on 10.12+. MacVim already has its own\n        // tabbing interface, so we don't want multiple hierarchy of tabs mixing\n        // native and Vim tabs. MacVim also doesn't work well with native tabs\n        // right now since it doesn't respond well to the size change, and it\n        // doesn't show the native menu items (e.g. move tab to new window) in\n        // all the tabs.\n        //\n        // Note: MacVim cannot use macOS native tabs for Vim tabs because Vim\n        // assumes only one tab can be shown at a time, and it would be hard to\n        // handle native tab's \"move tab to a new window\" functionality.\n        [NSWindow setAllowsAutomaticWindowTabbing:NO];\n    }\n\n    int tabMinWidthKey;\n    int tabMaxWidthKey;\n    int tabOptimumWidthKey;\n    if (shouldUseYosemiteTabBarStyle()) {\n        tabMinWidthKey = 120;\n        tabMaxWidthKey = 0;\n        tabOptimumWidthKey = 0;\n    } else {\n        tabMinWidthKey = 64;\n        tabMaxWidthKey = 6*64;\n        tabOptimumWidthKey = 132;\n    }\n\n    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:\n        [NSNumber numberWithBool:NO],     MMNoWindowKey,\n        [NSNumber numberWithInt:tabMinWidthKey],\n                                          MMTabMinWidthKey,\n        [NSNumber numberWithInt:tabMaxWidthKey],\n                                          MMTabMaxWidthKey,\n        [NSNumber numberWithInt:tabOptimumWidthKey],\n                                          MMTabOptimumWidthKey,\n        [NSNumber numberWithBool:YES],    MMShowAddTabButtonKey,\n        [NSNumber numberWithInt:2],       MMTextInsetLeftKey,\n        [NSNumber numberWithInt:1],       MMTextInsetRightKey,\n        [NSNumber numberWithInt:1],       MMTextInsetTopKey,\n        [NSNumber numberWithInt:1],       MMTextInsetBottomKey,\n        @\"MMTypesetter\",                  MMTypesetterKey,\n        [NSNumber numberWithFloat:1],     MMCellWidthMultiplierKey,\n        [NSNumber numberWithFloat:-1],    MMBaselineOffsetKey,\n        [NSNumber numberWithBool:YES],    MMTranslateCtrlClickKey,\n        [NSNumber numberWithInt:0],       MMOpenInCurrentWindowKey,\n        [NSNumber numberWithBool:NO],     MMNoFontSubstitutionKey,\n        [NSNumber numberWithBool:YES],    MMFontPreserveLineSpacingKey,\n        [NSNumber numberWithBool:YES],    MMLoginShellKey,\n        [NSNumber numberWithInt:MMRendererCoreText],\n                                          MMRendererKey,\n        [NSNumber numberWithInt:MMUntitledWindowAlways],\n                                          MMUntitledWindowKey,\n        [NSNumber numberWithBool:NO],     MMNoWindowShadowKey,\n        [NSNumber numberWithBool:NO],     MMZoomBothKey,\n        @\"\",                              MMLoginShellCommandKey,\n        @\"\",                              MMLoginShellArgumentKey,\n        [NSNumber numberWithBool:YES],    MMDialogsTrackPwdKey,\n        [NSNumber numberWithInt:3],       MMOpenLayoutKey,\n        [NSNumber numberWithBool:NO],     MMVerticalSplitKey,\n        [NSNumber numberWithInt:0],       MMPreloadCacheSizeKey,\n        [NSNumber numberWithInt:0],       MMLastWindowClosedBehaviorKey,\n#ifdef INCLUDE_OLD_IM_CODE\n        [NSNumber numberWithBool:YES],    MMUseInlineImKey,\n#endif // INCLUDE_OLD_IM_CODE\n        [NSNumber numberWithBool:NO],     MMSuppressTerminationAlertKey,\n        [NSNumber numberWithBool:YES],    MMNativeFullScreenKey,\n        [NSNumber numberWithDouble:0.0],  MMFullScreenFadeTimeKey,\n        [NSNumber numberWithBool:NO],     MMNonNativeFullScreenShowMenuKey,\n        [NSNumber numberWithInt:0],       MMNonNativeFullScreenSafeAreaBehaviorKey,\n        [NSNumber numberWithBool:YES],    MMShareFindPboardKey,\n        [NSNumber numberWithBool:NO],     MMSmoothResizeKey,\n        [NSNumber numberWithBool:NO],     MMCmdLineAlignBottomKey,\n        [NSNumber numberWithBool:NO],     MMRendererClipToRowKey,\n        [NSNumber numberWithBool:YES],    MMAllowForceClickLookUpKey,\n        [NSNumber numberWithBool:NO],     MMUpdaterPrereleaseChannelKey,\n        @\"\",                              MMLastUsedBundleVersionKey,\n        [NSNumber numberWithBool:YES],    MMShowWhatsNewOnStartupKey,\n        nil];\n\n    [[NSUserDefaults standardUserDefaults] registerDefaults:dict];\n\n    NSArray *types = [NSArray arrayWithObject:NSPasteboardTypeString];\n    [NSApp registerServicesMenuSendTypes:types returnTypes:types];\n\n    // NOTE: Set the current directory to user's home directory, otherwise it\n    // will default to the root directory.  (This matters since new Vim\n    // processes inherit MacVim's environment variables.)\n    [[NSFileManager defaultManager] changeCurrentDirectoryPath:\n            NSHomeDirectory()];\n}\n\n- (id)init\n{\n    if (!(self = [super init])) return nil;\n\n#if (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)\n    // Disable automatic relaunching\n    if ([NSApp respondsToSelector:@selector(disableRelaunchOnLogin)])\n        [NSApp disableRelaunchOnLogin];\n#endif\n\n    vimControllers = [NSMutableArray new];\n    cachedVimControllers = [NSMutableArray new];\n    preloadPid = -1;\n    pidArguments = [NSMutableDictionary new];\n    inputQueues = [NSMutableDictionary new];\n\n    // NOTE: Do not use the default connection since the Logitech Control\n    // Center (LCC) input manager steals and this would cause MacVim to\n    // never open any windows.  (This is a bug in LCC but since they are\n    // unlikely to fix it, we graciously give them the default connection.)\n    connection = [[NSConnection alloc] initWithReceivePort:[NSPort port]\n                                                  sendPort:nil];\n    [connection setRootObject:self];\n    [connection setRequestTimeout:MMRequestTimeout];\n    [connection setReplyTimeout:MMReplyTimeout];\n\n    // NOTE!  If the name of the connection changes here it must also be\n    // updated in MMBackend.m.\n    NSString *name = [NSString stringWithFormat:@\"%@-connection\",\n             [[NSBundle mainBundle] bundlePath]];\n    if (![connection registerName:name]) {\n        ASLogCrit(@\"Failed to register connection with name '%@'\", name);\n        [connection release];  connection = nil;\n    }\n\n    // Register help search handler to support search Vim docs via the Help menu\n    [NSApp registerUserInterfaceItemSearchHandler:self];\n\n#if !DISABLE_SPARKLE\n    // Sparkle is enabled (this is the default). Initialize it. It will\n    // automatically check for update.\n#if USE_SPARKLE_1\n    updater = [[SUUpdater alloc] init];\n#else\n    sparkle2delegate = [[MMSparkle2Delegate alloc] init];\n\n    // We don't immediately start the updater, because if it sees an update\n    // and immediately shows the dialog box it will pop up behind a new MacVim\n    // window. Instead, startUpdaterAndWhatsNewPage will be called later to do so.\n    updater = [[SPUStandardUpdaterController alloc] initWithStartingUpdater:NO updaterDelegate:sparkle2delegate userDriverDelegate:sparkle2delegate];\n#endif\n#endif\n\n    return self;\n}\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    [connection release];  connection = nil;\n    [inputQueues release];  inputQueues = nil;\n    [pidArguments release];  pidArguments = nil;\n    [vimControllers release];  vimControllers = nil;\n    [cachedVimControllers release];  cachedVimControllers = nil;\n    [openSelectionString release];  openSelectionString = nil;\n    [recentFilesMenuItem release];  recentFilesMenuItem = nil;\n    [defaultMainMenu release];  defaultMainMenu = nil;\n    currentMainMenu = nil;\n    [appMenuItemTemplate release];  appMenuItemTemplate = nil;\n#if !DISABLE_SPARKLE\n    [updater release];  updater = nil;\n#if !USE_SPARKLE_1\n    [sparkle2delegate release];  sparkle2delegate = nil;\n#endif\n#endif\n\n    [super dealloc];\n}\n\n- (void)applicationWillFinishLaunching:(NSNotification *)notification\n{\n    // This prevents macOS from injecting \"Enter Full Screen\" menu item.\n    // MacVim already has a separate menu item to do that.\n    // See https://developer.apple.com/library/archive/releasenotes/AppKit/RN-AppKitOlderNotes/index.html#10_11FullScreen\n    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@\"NSFullScreenMenuItemEverywhere\"];\n\n    // Remember the default menu so that it can be restored if the user closes\n    // all editor windows.\n    defaultMainMenu = [[NSApp mainMenu] retain];\n\n    // Store a copy of the default app menu so we can use this as a template\n    // for all other menus.  We make a copy here because the \"Services\" menu\n    // will not yet have been populated at this time.  If we don't we get\n    // problems trying to set key equivalents later on because they might clash\n    // with items on the \"Services\" menu.\n    appMenuItemTemplate = [defaultMainMenu itemAtIndex:0];\n    appMenuItemTemplate = [appMenuItemTemplate copy];\n\n    // Set up the \"Open Recent\" menu. See\n    //   http://lapcatsoftware.com/blog/2007/07/10/\n    //     working-without-a-nib-part-5-open-recent-menu/\n    // and\n    //   http://www.cocoabuilder.com/archive/message/cocoa/2007/8/15/187793\n    // for more information.\n    //\n    // The menu itself is created in MainMenu.nib but we still seem to have to\n    // hack around a bit to get it to work.  (This has to be done in\n    // applicationWillFinishLaunching at the latest, otherwise it doesn't\n    // work.)\n    NSMenu *fileMenu = [defaultMainMenu findFileMenu];\n    if (fileMenu) {\n        int idx = [fileMenu indexOfItemWithAction:@selector(fileOpen:)];\n        if (idx >= 0 && idx+1 < [fileMenu numberOfItems])\n\n        recentFilesMenuItem = [fileMenu itemWithTag:15432];\n        [[recentFilesMenuItem submenu] performSelector:@selector(_setMenuName:)\n                                        withObject:@\"NSRecentDocumentsMenu\"];\n\n        // Note: The \"Recent Files\" menu must be moved around since there is no\n        // -[NSApp setRecentFilesMenu:] method.  We keep a reference to it to\n        // facilitate this move (see setMainMenu: below).\n        [recentFilesMenuItem retain];\n    }\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n    [[NSAppleEventManager sharedAppleEventManager]\n            setEventHandler:self\n                andSelector:@selector(handleXcodeModEvent:replyEvent:)\n              forEventClass:'KAHL'\n                 andEventID:'MOD '];\n#endif\n\n    // Register 'mvim://' URL handler\n    [[NSAppleEventManager sharedAppleEventManager]\n            setEventHandler:self\n                andSelector:@selector(handleGetURLEvent:replyEvent:)\n              forEventClass:kInternetEventClass\n                 andEventID:kAEGetURL];\n\n    // Disable the default Cocoa \"Key Bindings\" since they interfere with the\n    // way Vim handles keyboard input.  Cocoa reads bindings from\n    //     /System/Library/Frameworks/AppKit.framework/Resources/\n    //                                                  StandardKeyBinding.dict\n    // and\n    //     ~/Library/KeyBindings/DefaultKeyBinding.dict\n    // To avoid having the user accidentally break keyboard handling (by\n    // modifying the latter in some unexpected way) in MacVim we load our own\n    // key binding dictionary from Resource/KeyBinding.plist.  We can't disable\n    // the bindings completely since it would break keyboard handling in\n    // dialogs so the our custom dictionary contains all the entries from the\n    // former location.\n    //\n    // It is possible to disable key bindings completely by not calling\n    // interpretKeyEvents: in keyDown: but this also disables key bindings used\n    // by certain input methods.  E.g.  Ctrl-Shift-; would no longer work in\n    // the Kotoeri input manager.\n    //\n    // To solve this problem we access a private API and set the key binding\n    // dictionary to our own custom dictionary here.  At this time Cocoa will\n    // have already read the above mentioned dictionaries so it (hopefully)\n    // won't try to change the key binding dictionary again after this point.\n    NSKeyBindingManager *mgr = [NSKeyBindingManager sharedKeyBindingManager];\n    NSBundle *mainBundle = [NSBundle mainBundle];\n    NSString *path = [mainBundle pathForResource:@\"KeyBinding\"\n                                          ofType:@\"plist\"];\n    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];\n    if (mgr && dict) {\n        [mgr setDictionary:dict];\n    } else {\n        ASLogNotice(@\"Failed to override the Cocoa key bindings.  Keyboard \"\n                \"input may behave strangely as a result (path=%@).\", path);\n    }\n}\n\n- (void)applicationDidFinishLaunching:(NSNotification *)notification\n{\n    [NSApp setServicesProvider:self];\n\n    if ([self maxPreloadCacheSize] > 0) {\n        [self scheduleVimControllerPreloadAfterDelay:2];\n        [self startWatchingVimDir];\n    }\n\n    [self addInputSourceChangedObserver];\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    NSString *lastUsedVersion = [ud stringForKey:MMLastUsedBundleVersionKey];\n    NSString *currentVersion = [[NSBundle mainBundle] objectForInfoDictionaryKey:\n            @\"CFBundleVersion\"];\n    // This will be used for showing a \"What's New\" dialog box in the future. For\n    // now, just update the stored version for future use so later versions will\n    // be able to tell whether to show this dialog box or not.\n    if (currentVersion && currentVersion.length != 0) {\n        if (!lastUsedVersion || [lastUsedVersion length] == 0) {\n            [ud setValue:currentVersion forKey:MMLastUsedBundleVersionKey];\n        } else {\n            // If the current version is larger, set that to be stored. Don't\n            // want to do it otherwise to prevent testing older versions flipping\n            // the stored version back to an old one.\n            NSArray<NSString*> *lastUsedVersionItems = [lastUsedVersion componentsSeparatedByString:@\".\"];\n            NSArray<NSString*> *currentVersionItems = [currentVersion componentsSeparatedByString:@\".\"];\n            // Compare two arrays lexographically. We just assume that version\n            // numbers are also X.Y.Z\u2026 with no \"beta\" etc texts.\n            bool currentVersionLarger = NO;\n            for (int i = 0; i < currentVersionItems.count && i < lastUsedVersionItems.count; i++) {\n                if (i >= currentVersionItems.count) {\n                    currentVersionLarger = NO;\n                    break;\n                }\n                if (i >= lastUsedVersionItems.count) {\n                    currentVersionLarger = YES;\n                    break;\n                }\n                if (currentVersionItems[i].integerValue > lastUsedVersionItems[i].integerValue) {\n                    currentVersionLarger = YES;\n                    break;\n                }\n                else if (currentVersionItems[i].integerValue < lastUsedVersionItems[i].integerValue) {\n                    currentVersionLarger = NO;\n                    break;\n                }\n            }\n\n            if (currentVersionLarger) {\n                [ud setValue:currentVersion forKey:MMLastUsedBundleVersionKey];\n\n                // We have successfully updated to a new version. Show a \"What's\n                // New\" page to the user with latest release notes if the main\n                // release number has increased (we don't count the pre-release\n                // minor revision number for now).\n                if (lastUsedVersionItems[0].integerValue < currentVersionItems[0].integerValue) {\n\n                    BOOL showWhatsNewSetting = [ud boolForKey:MMShowWhatsNewOnStartupKey];\n\n                    shouldShowWhatsNewPage = showWhatsNewSetting;\n                    [MMWhatsNewController setRequestVersionRange:lastUsedVersion\n                                                              to:currentVersion];\n                }\n            }\n        }\n    }\n\n    // Start the Sparkle updater and potentially show \"What's New\". If the user\n    // doesn't want a new untitled MacVim window shown, we immediately do so.\n    // Otherwise we want to do it *after* the untitled window is opened so the\n    // updater / \"What's New\" page can be shown on top of it. We still schedule\n    // a timer to open it as a backup in case something wrong happened with the\n    // Vim window (e.g. a crash in Vim) but we still want the updater to work since\n    // that update may very well be the fix for the crash.\n    const NSInteger untitledWindowFlag = [ud integerForKey:MMUntitledWindowKey];\n    if ((untitledWindowFlag & MMUntitledWindowOnOpen) == 0) {\n        [self startUpdaterAndWhatsNewPage];\n    } else {\n        // Per above, this is just a backup. startUpdaterAndWhatsNewPage will\n        // not do anything if it's called a second time.\n        [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(startUpdaterAndWhatsNewPage) userInfo:nil repeats:NO];\n    }\n\n    ASLogInfo(@\"MacVim finished launching\");\n}\n\n- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender\n{\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    NSAppleEventManager *aem = [NSAppleEventManager sharedAppleEventManager];\n    NSAppleEventDescriptor *desc = [aem currentAppleEvent];\n\n    // The user default MMUntitledWindow can be set to control whether an\n    // untitled window should open on 'Open' and 'Reopen' events.\n    int untitledWindowFlag = [ud integerForKey:MMUntitledWindowKey];\n\n    BOOL isAppOpenEvent = [desc eventID] == kAEOpenApplication;\n    if (isAppOpenEvent && (untitledWindowFlag & MMUntitledWindowOnOpen) == 0)\n        return NO;\n\n    BOOL isAppReopenEvent = [desc eventID] == kAEReopenApplication;\n    if (isAppReopenEvent\n            && (untitledWindowFlag & MMUntitledWindowOnReopen) == 0)\n        return NO;\n\n    // When a process is started from the command line, the 'Open' event may\n    // contain a parameter to surpress the opening of an untitled window.\n    desc = [desc paramDescriptorForKeyword:keyAEPropData];\n    desc = [desc paramDescriptorForKeyword:keyMMUntitledWindow];\n    if (desc && ![desc booleanValue])\n        return NO;\n\n    // Never open an untitled window if there is at least one open window.\n    if ([vimControllers count] > 0)\n        return NO;\n\n    // Don't open an untitled window if there are processes about to launch...\n    NSUInteger numLaunching = [pidArguments count];\n    if (numLaunching > 0) {\n        // ...unless the launching process is being preloaded\n        NSNumber *key = [NSNumber numberWithInt:preloadPid];\n        if (numLaunching != 1 || [pidArguments objectForKey:key] == nil)\n            return NO;\n    }\n\n    // NOTE!  This way it possible to start the app with the command-line\n    // argument '-nowindow yes' and no window will be opened by default but\n    // this argument will only be heeded when the application is opening.\n    if (isAppOpenEvent && [ud boolForKey:MMNoWindowKey] == YES)\n        return NO;\n\n    return YES;\n}\n\n- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender\n{\n    ASLogDebug(@\"Opening untitled window...\");\n    [self newWindow:self];\n    return YES;\n}\n\n- (void)application:(NSApplication *)sender openFiles:(NSArray *)filenames\n{\n    ASLogInfo(@\"Opening files %@\", filenames);\n\n    // Extract ODB/Xcode/Spotlight parameters from the current Apple event,\n    // sort the filenames, and then let openFiles:withArguments: do the heavy\n    // lifting.\n\n    if (!(filenames && [filenames count] > 0))\n        return;\n\n    // Sort filenames since the Finder doesn't take care in preserving the\n    // order in which files are selected anyway (and \"sorted\" is more\n    // predictable than \"random\").\n    if ([filenames count] > 1)\n        filenames = [filenames sortedArrayUsingSelector:\n                @selector(localizedCompare:)];\n\n    // Extract ODB/Xcode/Spotlight parameters from the current Apple event\n    NSMutableDictionary *arguments = [self extractArgumentsFromOdocEvent:\n            [[NSAppleEventManager sharedAppleEventManager] currentAppleEvent]];\n\n    if ([self openFiles:filenames withArguments:arguments]) {\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplySuccess];\n    } else {\n        // TODO: Notify user of failure?\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplyFailure];\n    }\n}\n\n- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender\n{\n    if (!hasShownWindowBefore) {\n        // If we have not opened a window before, never return YES. This can\n        // happen when MacVim is not configured to open window at launch. We\n        // want to give the user a chance to open a window first. Otherwise\n        // just opening the About MacVim or Settings windows could immediately\n        // terminate the app (since those are not proper app windows),\n        // depending if the OS feels like invoking this method.\n        return NO;\n    }\n    return (MMTerminateWhenLastWindowClosed ==\n            [[NSUserDefaults standardUserDefaults]\n                integerForKey:MMLastWindowClosedBehaviorKey]);\n}\n\n- (NSApplicationTerminateReply)applicationShouldTerminate:\n    (NSApplication *)sender\n{\n    // TODO: Follow Apple's guidelines for 'Graceful Application Termination'\n    // (in particular, allow user to review changes and save).\n    int reply = NSTerminateNow;\n    BOOL modifiedBuffers = NO;\n\n    // Go through Vim controllers, checking for modified buffers.\n    NSEnumerator *e = [vimControllers objectEnumerator];\n    id vc;\n    while ((vc = [e nextObject])) {\n        if ([vc hasModifiedBuffer]) {\n            modifiedBuffers = YES;\n            break;\n        }\n    }\n\n    if (modifiedBuffers) {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert setAlertStyle:NSAlertStyleWarning];\n        [alert addButtonWithTitle:NSLocalizedString(@\"Quit\",\n                @\"Dialog button\")];\n        [alert addButtonWithTitle:NSLocalizedString(@\"Cancel\",\n                @\"Dialog button\")];\n        [alert setMessageText:NSLocalizedString(@\"Quit without saving?\",\n                @\"Quit dialog with changed buffers, title\")];\n        [alert setInformativeText:NSLocalizedString(\n                @\"There are modified buffers, \"\n                \"if you quit now all changes will be lost.  Quit anyway?\",\n                @\"Quit dialog with changed buffers, text\")];\n\n        if ([alert runModal] != NSAlertFirstButtonReturn)\n            reply = NSTerminateCancel;\n\n        [alert release];\n    } else if (![[NSUserDefaults standardUserDefaults]\n                                boolForKey:MMSuppressTerminationAlertKey]) {\n        // No unmodified buffers, but give a warning if there are multiple\n        // windows and/or tabs open.\n        int numWindows = [vimControllers count];\n        int numTabs = 0;\n\n        // Count the number of open tabs\n        e = [vimControllers objectEnumerator];\n        while ((vc = [e nextObject]))\n            numTabs += [[vc objectForVimStateKey:@\"numTabs\"] intValue];\n\n        if (numWindows > 1 || numTabs > 1) {\n            NSAlert *alert = [[NSAlert alloc] init];\n            [alert setAlertStyle:NSAlertStyleWarning];\n            [alert addButtonWithTitle:NSLocalizedString(@\"Quit\",\n                    @\"Dialog button\")];\n            [alert addButtonWithTitle:NSLocalizedString(@\"Cancel\",\n                    @\"Dialog button\")];\n            [alert setMessageText:NSLocalizedString(\n                    @\"Are you sure you want to quit MacVim?\",\n                    @\"Quit dialog with no changed buffers, title\")];\n            [alert setShowsSuppressionButton:YES];\n\n            NSString *info = nil;\n            if (numWindows > 1) {\n                if (numTabs > numWindows)\n                    info = [NSString stringWithFormat:NSLocalizedString(\n                            @\"There are %d windows open in MacVim, with a \"\n                            \"total of %d tabs. Do you want to quit anyway?\",\n                            @\"Quit dialog with no changed buffers, text\"),\n                         numWindows, numTabs];\n                else\n                    info = [NSString stringWithFormat:NSLocalizedString(\n                            @\"There are %d windows open in MacVim. \"\n                            \"Do you want to quit anyway?\",\n                            @\"Quit dialog with no changed buffers, text\"),\n                        numWindows];\n\n            } else {\n                info = [NSString stringWithFormat:NSLocalizedString(\n                        @\"There are %d tabs open in MacVim. \"\n                        \"Do you want to quit anyway?\",\n                        @\"Quit dialog with no changed buffers, text\"), \n                     numTabs];\n            }\n\n            [alert setInformativeText:info];\n\n            if ([alert runModal] != NSAlertFirstButtonReturn)\n                reply = NSTerminateCancel;\n\n            if ([[alert suppressionButton] state] == NSControlStateValueOn) {\n                [[NSUserDefaults standardUserDefaults]\n                            setBool:YES forKey:MMSuppressTerminationAlertKey];\n            }\n\n            [alert release];\n        }\n    }\n\n\n    // Tell all Vim processes to terminate now (otherwise they'll leave swap\n    // files behind).\n    if (NSTerminateNow == reply) {\n        e = [vimControllers objectEnumerator];\n        id vc;\n        while ((vc = [e nextObject])) {\n            ASLogDebug(@\"Terminate pid=%d\", [vc pid]);\n            [vc sendMessage:TerminateNowMsgID data:nil];\n        }\n\n        e = [cachedVimControllers objectEnumerator];\n        while ((vc = [e nextObject])) {\n            ASLogDebug(@\"Terminate pid=%d (cached)\", [vc pid]);\n            [vc sendMessage:TerminateNowMsgID data:nil];\n        }\n\n        // If a Vim process is being preloaded as we quit we have to forcibly\n        // kill it since we have not established a connection yet.\n        if (preloadPid > 0) {\n            ASLogDebug(@\"Kill incomplete preloaded process pid=%d\", preloadPid);\n            kill(preloadPid, SIGKILL);\n        }\n\n        // If a Vim process was loading as we quit we also have to kill it.\n        e = [[pidArguments allKeys] objectEnumerator];\n        NSNumber *pidKey;\n        while ((pidKey = [e nextObject])) {\n            ASLogDebug(@\"Kill incomplete process pid=%d\", [pidKey intValue]);\n            kill([pidKey intValue], SIGKILL);\n        }\n\n        // Sleep a little to allow all the Vim processes to exit.\n        usleep(10000);\n    }\n\n    return reply;\n}\n\n- (void)applicationWillTerminate:(NSNotification *)notification\n{\n    ASLogInfo(@\"Terminating MacVim...\");\n\n    [self removeInputSourceChangedObserver];\n\n    [self stopWatchingVimDir];\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n    [[NSAppleEventManager sharedAppleEventManager]\n            removeEventHandlerForEventClass:'KAHL'\n                                 andEventID:'MOD '];\n#endif\n\n    // We are hard shutting down the app here by terminating all Vim processes\n    // and then just quit without cleanly removing each Vim controller. We\n    // don't want the straggler controllers to still interact with the now\n    // invalid connections, so we just mark them as uninitialized.\n    for (NSUInteger i = 0, count = [vimControllers count]; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc uninitialize];\n    }\n\n    // This will invalidate all connections (since they were spawned from this\n    // connection).\n    [connection invalidate];\n\n    [NSApp setDelegate:nil];\n\n    // Try to wait for all child processes to avoid leaving zombies behind (but\n    // don't wait around for too long).\n    NSDate *timeOutDate = [NSDate dateWithTimeIntervalSinceNow:2];\n    while ([timeOutDate timeIntervalSinceNow] > 0) {\n        [self reapChildProcesses:nil];\n        if (numChildProcesses <= 0)\n            break;\n\n        ASLogDebug(@\"%d processes still left, hold on...\", numChildProcesses);\n\n        // Run in NSConnectionReplyMode while waiting instead of calling e.g.\n        // usleep().  Otherwise incoming messages may clog up the DO queues and\n        // the outgoing TerminateNowMsgID sent earlier never reaches the Vim\n        // process.\n        // This has at least one side-effect, namely we may receive the\n        // annoying \"dropping incoming DO message\".  (E.g. this may happen if\n        // you quickly hit Cmd-n several times in a row and then immediately\n        // press Cmd-q, Enter.)\n        while (CFRunLoopRunInMode((CFStringRef)NSConnectionReplyMode,\n                0.05, true) == kCFRunLoopRunHandledSource)\n            ;   // do nothing\n    }\n\n    if (numChildProcesses > 0) {\n        ASLogNotice(@\"%d zombies left behind\", numChildProcesses);\n    }\n}\n\n+ (MMAppController *)sharedInstance\n{\n    // Note: The app controller is a singleton which is instantiated in\n    // MainMenu.nib where it is also connected as the delegate of NSApp.\n    id delegate = [NSApp delegate];\n    return [delegate isKindOfClass:self] ? (MMAppController*)delegate : nil;\n}\n\n- (NSMenu *)defaultMainMenu\n{\n    return defaultMainMenu;\n}\n\n- (NSMenuItem *)appMenuItemTemplate\n{\n    return appMenuItemTemplate;\n}\n\n- (void)removeVimController:(id)controller\n{\n    ASLogDebug(@\"Remove Vim controller pid=%d id=%d (processingFlag=%d)\",\n               [controller pid], [controller vimControllerId], processingFlag);\n\n    NSUInteger idx = [vimControllers indexOfObject:controller];\n    if (NSNotFound == idx) {\n        ASLogDebug(@\"Controller not found, probably due to duplicate removal\");\n        return;\n    }\n\n    [controller retain];\n    [vimControllers removeObjectAtIndex:idx];\n    [controller cleanup];\n    [controller release];\n\n    if (![vimControllers count]) {\n        // The last editor window just closed so restore the main menu back to\n        // its default state (which is defined in MainMenu.nib).\n        [self setMainMenu:defaultMainMenu];\n\n        BOOL hide = (MMHideWhenLastWindowClosed ==\n                    [[NSUserDefaults standardUserDefaults]\n                        integerForKey:MMLastWindowClosedBehaviorKey]);\n        if (hide)\n            [NSApp hide:self];\n    }\n\n    // There is a small delay before the Vim process actually exits so wait a\n    // little before trying to reap the child process.  If the process still\n    // hasn't exited after this wait it won't be reaped until the next time\n    // reapChildProcesses: is called (but this should be harmless).\n    [self performSelector:@selector(reapChildProcesses:)\n               withObject:nil\n               afterDelay:0.1];\n}\n\n- (void)windowControllerWillOpen:(MMWindowController *)windowController\n{\n    NSPoint topLeft = NSZeroPoint;\n    NSWindow *cascadeFrom = [[[self topmostVimController] windowController]\n                                                                    window];\n    NSWindow *win = [windowController window];\n\n    if (!win) return;\n\n    // Heuristic to determine where to position the window:\n    //   1. Use the default top left position (set using :winpos in .[g]vimrc)\n    //   2. Cascade from an existing window\n    //   3. Use autosaved position\n    // If all of the above fail, then the window position is not changed.\n    if ([windowController getDefaultTopLeft:&topLeft]) {\n        // Make sure the window is not cascaded (note that topLeft was set in\n        // the above call).\n        cascadeFrom = nil;\n    } else if (cascadeFrom) {\n        NSRect frame = [cascadeFrom frame];\n        topLeft = NSMakePoint(frame.origin.x, NSMaxY(frame));\n    } else {\n        NSString *topLeftString = [[NSUserDefaults standardUserDefaults]\n            stringForKey:MMTopLeftPointKey];\n        if (topLeftString)\n            topLeft = NSPointFromString(topLeftString);\n    }\n\n    if (!NSEqualPoints(topLeft, NSZeroPoint)) {\n        // Try to tile from the correct screen in case the user has multiple\n        // monitors ([win screen] always seems to return the \"main\" screen).\n        //\n        // TODO: Check for screen _closest_ to top left?\n        NSScreen *screen = [self screenContainingTopLeftPoint:topLeft];\n        if (!screen)\n            screen = [win screen];\n\n        BOOL willSwitchScreens = screen != [win screen];\n        if (cascadeFrom) {\n            // Do manual cascading instead of using\n            // -[MMWindow cascadeTopLeftFromPoint:] since it is rather\n            // unpredictable.\n            topLeft.x += MMCascadeHorizontalOffset;\n            topLeft.y -= MMCascadeVerticalOffset;\n        }\n\n        if (screen) {\n            // Constrain the window so that it is entirely visible on the\n            // screen.  If it sticks out on the right, move it all the way\n            // left.  If it sticks out on the bottom, move it all the way up.\n            // (Assumption: the cascading offsets are positive.)\n            NSRect screenFrame = [screen frame];\n            NSSize winSize = [win frame].size;\n            NSRect winFrame =\n                { { topLeft.x, topLeft.y - winSize.height }, winSize };\n\n            if (NSMaxX(winFrame) > NSMaxX(screenFrame))\n                topLeft.x = NSMinX(screenFrame);\n            if (NSMinY(winFrame) < NSMinY(screenFrame))\n                topLeft.y = NSMaxY(screenFrame);\n        } else {\n            ASLogNotice(@\"Window not on screen, don't constrain position\");\n        }\n\n        // setFrameTopLeftPoint will trigger a resize event if the window is\n        // moved across monitors; at this point such a resize would incorrectly\n        // constrain the window to the default vim dimensions, so a specialized\n        // method is used that will avoid that behavior.\n        if (willSwitchScreens)\n            [windowController moveWindowAcrossScreens:topLeft];\n        else\n            [win setFrameTopLeftPoint:topLeft];\n    }\n\n    if (1 == [vimControllers count]) {\n        // The first window autosaves its position.  (The autosaving\n        // features of Cocoa are not used because we need more control over\n        // what is autosaved and when it is restored.)\n        [windowController setWindowAutosaveKey:MMTopLeftPointKey];\n    }\n\n    if (openSelectionString) {\n        // TODO: Pass this as a parameter instead!  Get rid of\n        // 'openSelectionString' etc.\n        //\n        // There is some text to paste into this window as a result of the\n        // services menu \"Open selection ...\" being used.\n        [[windowController vimController] dropString:openSelectionString];\n        [openSelectionString release];\n        openSelectionString = nil;\n    }\n\n    if (shouldActivateWhenNextWindowOpens) {\n        [NSApp activateIgnoringOtherApps:YES];\n        shouldActivateWhenNextWindowOpens = NO;\n    }\n\n    hasShownWindowBefore = YES;\n\n    // If this is the first untitled window we defer starting updater/what's new\n    // to now to make sure they can be shown on top. Otherwise calling this will\n    // do nothing so it's safe.\n    [self startUpdaterAndWhatsNewPage];\n}\n\n- (void)setMainMenu:(NSMenu *)mainMenu\n{\n    if (currentMainMenu == mainMenu) {\n        return;\n    }\n    currentMainMenu = mainMenu;\n    [self refreshMainMenu];\n}\n\n// Refresh the currently active main menu. This call is necessary when any\n// modification was made to the menu, because refreshMainMenu makes a copy of\n// the main menu, meaning that modifications to the original menu wouldn't be\n// reflected until refreshMainMenu is invoked.\n- (void)markMainMenuDirty:(NSMenu *)mainMenu\n{\n    if (currentMainMenu != mainMenu) {\n        // The menu being updated is not the currently set menu, so just ignore,\n        // as this is likely a background Vim window.\n        return;\n    }\n    if (!mainMenuDirty) {\n        // Mark the main menu as dirty and queue up a refresh. We don't immediately\n        // execute the refresh so that multiple calls would get batched up in one go.\n        mainMenuDirty = YES;\n        [self performSelectorOnMainThread:@selector(refreshMainMenu) withObject:nil waitUntilDone:NO];\n    }\n}\n\n- (void)refreshMainMenu\n{\n    mainMenuDirty = NO;\n\n    // Make a copy of the menu before we pass to AppKit. The main reason is\n    // that setWindowsMenu: below will inject items like \"Tile Window to Left\n    // of Screen\" to the Window menu, and on repeated calls it will keep adding\n    // the same item over and over again, without resolving for duplicates. Using\n    // copies help keep the source menu clean.\n    NSMenu *mainMenu = [[currentMainMenu copy] autorelease];\n\n    // If the new menu has a \"Recent Files\" dummy item, then swap the real item\n    // for the dummy.  We are forced to do this since Cocoa initializes the\n    // \"Recent Files\" menu and there is no way to simply point Cocoa to a new\n    // item each time the menus are swapped.\n    NSMenu *fileMenu = [mainMenu findFileMenu];\n    if (recentFilesMenuItem && fileMenu) {\n        int dummyIdx =\n            [fileMenu indexOfItemWithAction:@selector(recentFilesDummy:)];\n        if (dummyIdx >= 0) {\n            NSMenuItem *dummyItem = [[fileMenu itemAtIndex:dummyIdx] retain];\n            [fileMenu removeItemAtIndex:dummyIdx];\n\n            NSMenu *recentFilesParentMenu = [recentFilesMenuItem menu];\n            int idx = [recentFilesParentMenu indexOfItem:recentFilesMenuItem];\n            if (idx >= 0) {\n                [[recentFilesMenuItem retain] autorelease];\n                [recentFilesParentMenu removeItemAtIndex:idx];\n                [recentFilesParentMenu insertItem:dummyItem atIndex:idx];\n            }\n\n            [fileMenu insertItem:recentFilesMenuItem atIndex:dummyIdx];\n            [dummyItem release];\n        }\n    }\n\n#if DISABLE_SPARKLE\n    NSMenu *appMenu = [mainMenu findApplicationMenu];\n\n    // If Sparkle is disabled, we want to remove the \"Check for Updates\" menu\n    // item since it's no longer useful.\n    NSMenuItem *checkForUpdatesItem = [appMenu itemAtIndex:\n                                       [appMenu indexOfItemWithAction:@selector(checkForUpdates:)]];\n    checkForUpdatesItem.hidden = true;\n#endif\n\n    // Now set the new menu.  Notice that we keep one menu for each editor\n    // window since each editor can have its own set of menus.  When swapping\n    // menus we have to tell Cocoa where the new \"MacVim\", \"Windows\", and\n    // \"Services\" menu are.\n    [NSApp setMainMenu:mainMenu];\n\n    NSMenu *servicesMenu = [mainMenu findServicesMenu];\n    [NSApp setServicesMenu:servicesMenu];\n\n    NSMenu *windowsMenu = [mainMenu findWindowsMenu];\n    [NSApp setWindowsMenu:windowsMenu];\n\n    NSMenu *helpMenu = [mainMenu findHelpMenu];\n    [NSApp setHelpMenu:helpMenu];\n}\n\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n{\n    return [self filterOpenFiles:filenames openFilesDict:nil];\n}\n\n- (BOOL)openFiles:(NSArray *)filenames withArguments:(NSDictionary *)args\n{\n    // Opening files works like this:\n    //  a) filter out any already open files\n    //  b) open any remaining files\n    //\n    // Each launching Vim process has a dictionary of arguments that are passed\n    // to the process when in checks in (via connectBackend:pid:).  The\n    // arguments for each launching process can be looked up by its PID (in the\n    // pidArguments dictionary).\n\n    NSMutableDictionary *arguments = (args ? [[args mutableCopy] autorelease]\n                                           : [NSMutableDictionary dictionary]);\n\n    filenames = normalizeFilenames(filenames);\n\n    //\n    // a) Filter out any already open files\n    //\n    NSString *firstFile = [filenames objectAtIndex:0];\n    NSDictionary *openFilesDict = nil;\n    filenames = [self filterOpenFiles:filenames openFilesDict:&openFilesDict];\n\n    // The meaning of \"layout\" is defined by the WIN_* defines in main.c.\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    int layout = [ud integerForKey:MMOpenLayoutKey];\n    BOOL splitVert = [ud boolForKey:MMVerticalSplitKey];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n\n    if (splitVert && MMLayoutHorizontalSplit == layout)\n        layout = MMLayoutVerticalSplit;\n    if (layout < 0 || (layout > MMLayoutTabs && openInCurrentWindow))\n        layout = MMLayoutTabs;\n\n    // Pass arguments to vim controllers that had files open.\n    id key;\n    NSEnumerator *e = [openFilesDict keyEnumerator];\n\n    // (Indicate that we do not wish to open any files at the moment.)\n    [arguments setObject:[NSNumber numberWithBool:YES] forKey:@\"dontOpen\"];\n\n    while ((key = [e nextObject])) {\n        MMVimController *vc = [key pointerValue];\n        NSArray *files = [openFilesDict objectForKey:key];\n        [arguments setObject:files forKey:@\"filenames\"];\n\n        if ([filenames count] == 0 && [files containsObject:firstFile]) {\n            // Raise the window containing the first file that was already\n            // open, and make sure that the tab containing that file is\n            // selected.  Only do this when there are no more files to open,\n            // otherwise sometimes the window with 'firstFile' will be raised,\n            // other times it might be the window that will open with the files\n            // in the 'filenames' array.\n            //\n            // NOTE: Raise window before passing arguments, otherwise the\n            // selection will be lost when selectionRange is set.\n            NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                                  firstFile, @\"filename\",\n                                  [NSNumber numberWithInt:layout], @\"layout\",\n                                  nil];\n            [vc sendMessage:SelectAndFocusOpenedFileMsgID data:[args dictionaryAsData]];\n        }\n\n        [vc passArguments:arguments];\n    }\n\n    // Add filenames to \"Recent Files\" menu, unless they are being edited\n    // remotely (using ODB).\n    if ([arguments objectForKey:@\"remoteID\"] == nil) {\n        [[NSDocumentController sharedDocumentController]\n                noteNewRecentFilePaths:filenames];\n    }\n\n    if ([filenames count] == 0)\n        return YES; // No files left to open (all were already open)\n\n    //\n    // b) Open any remaining files\n    //\n\n    [arguments setObject:[NSNumber numberWithInt:layout] forKey:@\"layout\"];\n    [arguments setObject:filenames forKey:@\"filenames\"];\n    // (Indicate that files should be opened from now on.)\n    [arguments setObject:[NSNumber numberWithBool:NO] forKey:@\"dontOpen\"];\n\n    MMVimController *vc;\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        // Open files in an already open window.\n        [[[vc windowController] window] makeKeyAndOrderFront:self];\n        [vc passArguments:arguments];\n        return YES;\n    }\n\n    BOOL openOk = YES;\n    int numFiles = [filenames count];\n    if (MMLayoutWindows == layout && numFiles > 1) {\n        // Open one file at a time in a new window, but don't open too many at\n        // once (at most cap+1 windows will open).  If the user has increased\n        // the preload cache size we'll take that as a hint that more windows\n        // should be able to open at once.\n        int cap = [self maxPreloadCacheSize] - 1;\n        if (cap < 4) cap = 4;\n        if (cap > numFiles) cap = numFiles;\n\n        int i;\n        for (i = 0; i < cap; ++i) {\n            NSArray *a = [NSArray arrayWithObject:[filenames objectAtIndex:i]];\n            [arguments setObject:a forKey:@\"filenames\"];\n\n            // NOTE: We have to copy the args since we'll mutate them in the\n            // next loop and the below call may retain the arguments while\n            // waiting for a process to start.\n            NSDictionary *args = [[arguments copy] autorelease];\n\n            openOk = [self openVimControllerWithArguments:args];\n            if (!openOk) break;\n        }\n\n        // Open remaining files in tabs in a new window.\n        if (openOk && numFiles > cap) {\n            NSRange range = { i, numFiles-cap };\n            NSArray *a = [filenames subarrayWithRange:range];\n            [arguments setObject:a forKey:@\"filenames\"];\n            [arguments setObject:[NSNumber numberWithInt:MMLayoutTabs]\n                          forKey:@\"layout\"];\n\n            openOk = [self openVimControllerWithArguments:arguments];\n        }\n    } else {\n        // Open all files at once.\n        openOk = [self openVimControllerWithArguments:arguments];\n    }\n\n    return openOk;\n}\n\n- (void)refreshAllAppearances\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController refreshApperanceMode];\n    }\n}\n\n/// Refresh all Vim text views' fonts.\n- (void)refreshAllFonts\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController refreshFonts];\n    }\n}\n\n/// Refresh all resize constraints based on smooth resize configurations\n/// and resize the windows to match the constraints.\n- (void)refreshAllResizeConstraints\n{\n    const unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController updateResizeConstraints:YES];\n    }\n}\n\n/// Refresh all text views and re-render them, as well as updating their\n/// cmdline alignment properties to make sure they are pinned properly.\n- (void)refreshAllTextViews\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController.vimView.textView updateCmdlineRow];\n        vc.windowController.vimView.textView.needsDisplay = YES;\n    }\n}\n\n- (BOOL)validateMenuItem:(NSMenuItem *)item\n{\n    if ([item action] == @selector(showWhatsNew:)) {\n        return [MMWhatsNewController canOpen];\n    }\n    // For most of the actions defined in this class we do want them to always be\n    // enabled since they are usually app functionality and independent of\n    // each Vim's state.\n    return YES;\n}\n\n- (IBAction)newWindow:(id)sender\n{\n    ASLogDebug(@\"Open new window\");\n\n    // A cached controller requires no loading times and results in the new\n    // window popping up instantaneously.  If the cache is empty it may take\n    // 1-2 seconds to start a new Vim process.\n    MMVimController *vc = [self takeVimControllerFromCache];\n    if (vc) {\n        [[vc backendProxy] acknowledgeConnection];\n    } else {\n        [self launchVimProcessWithArguments:nil workingDirectory:nil];\n    }\n}\n\n- (IBAction)newWindowAndActivate:(id)sender\n{\n    [self activateWhenNextWindowOpens];\n    [self newWindow:sender];\n}\n\n- (IBAction)fileOpen:(id)sender\n{\n    ASLogDebug(@\"Show file open panel\");\n\n    NSString *dir = nil;\n    BOOL trackPwd = [[NSUserDefaults standardUserDefaults]\n            boolForKey:MMDialogsTrackPwdKey];\n    if (trackPwd) {\n        MMVimController *vc = [self keyVimController];\n        if (vc) dir = [vc objectForVimStateKey:@\"pwd\"];\n    }\n\n    NSOpenPanel *panel = [NSOpenPanel openPanel];\n    [panel setAllowsMultipleSelection:YES];\n    [panel setCanChooseDirectories:YES];\n    [panel setAccessoryView:showHiddenFilesView()];\n    dir = [dir stringByExpandingTildeInPath];\n    if (dir) {\n        NSURL *dirURL = [NSURL fileURLWithPath:dir isDirectory:YES];\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n    }\n\n    NSInteger result = [panel runModal];\n\n#if (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10)\n    if (NSModalResponseOK == result)\n#else\n    if (NSOKButton == result)\n#endif\n    {\n        // NOTE: -[NSOpenPanel filenames] is deprecated on 10.7 so use\n        // -[NSOpenPanel URLs] instead.  The downside is that we have to check\n        // that each URL is really a path first.\n        NSMutableArray *filenames = [NSMutableArray array];\n        NSArray *urls = [panel URLs];\n        NSUInteger i, count = [urls count];\n        for (i = 0; i < count; ++i) {\n            NSURL *url = [urls objectAtIndex:i];\n            if ([url isFileURL]) {\n                NSString *path = [url path];\n                if (path)\n                    [filenames addObject:path];\n            }\n        }\n\n        if ([filenames count] > 0)\n            [self application:NSApp openFiles:filenames];\n    }\n}\n\n- (IBAction)selectNextWindow:(id)sender\n{\n    ASLogDebug(@\"Select next window\");\n\n    unsigned i, count = [vimControllers count];\n    if (!count) return;\n\n    NSWindow *keyWindow = [NSApp keyWindow];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isEqual:keyWindow])\n            break;\n    }\n\n    if (i < count) {\n        if (++i >= count)\n            i = 0;\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [[vc windowController] showWindow:self];\n    }\n}\n\n- (IBAction)selectPreviousWindow:(id)sender\n{\n    ASLogDebug(@\"Select previous window\");\n\n    unsigned i, count = [vimControllers count];\n    if (!count) return;\n\n    NSWindow *keyWindow = [NSApp keyWindow];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isEqual:keyWindow])\n            break;\n    }\n\n    if (i < count) {\n        if (i > 0) {\n            --i;\n        } else {\n            i = count - 1;\n        }\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [[vc windowController] showWindow:self];\n    }\n}\n\n- (IBAction)orderFrontPreferencePanel:(id)sender\n{\n    ASLogDebug(@\"Show preferences panel\");\n    [[MMPreferenceController sharedPrefsWindowController] showWindow:self];\n}\n\n- (IBAction)openWebsite:(id)sender\n{\n    ASLogDebug(@\"Open MacVim website\");\n    [[NSWorkspace sharedWorkspace] openURL:\n            [NSURL URLWithString:MMWebsiteString]];\n}\n\n- (IBAction)showWhatsNew:(id)sender\n{\n    ASLogDebug(@\"Open What's New page\");\n    [MMWhatsNewController openSharedInstance];\n}\n\n- (IBAction)showVimHelp:(id)sender withCmd:(NSString *)cmd\n{\n    ASLogDebug(@\"Open window with Vim help\");\n    // Open a new window with only the help window shown.\n    [self launchVimProcessWithArguments:[NSArray arrayWithObjects:\n                                    @\"-c\", cmd, @\"-c\", @\":only\", nil]\n                       workingDirectory:nil];\n}\n\n- (IBAction)showVimHelp:(id)sender\n{\n    [self showVimHelp:sender withCmd:@\":h gui_mac\"];\n}\n\n- (IBAction)checkForUpdates:(id)sender\n{\n#if !DISABLE_SPARKLE\n    // Check for updates for new versions manually.\n    ASLogDebug(@\"Check for software updates\");\n    [updater checkForUpdates:sender];\n#endif\n}\n\n// Note that the zoomAll method does not appear to be called in modern macOS versions\n// as NSApplication just handles it and directly calls each window's zoom:. It's\n// difficult to trace through history to see when that happened as it's not really\n// documented, so we are leaving this method around in case on older macOS\n// versions it's useful.\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_13\n- (IBAction)zoomAll:(id)sender\n{\n    // TODO ychin: check on 10.13 etc. This was depreacated post 10.14.\n    ASLogDebug(@\"Zoom all windows\");\n    [NSApp makeWindowsPerform:@selector(performZoom:) inOrder:YES];\n}\n#endif\n\n- (IBAction)stayInFront:(id)sender\n{\n    ASLogDebug(@\"Stay in Front\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:NSFloatingWindowLevel];\n}\n\n- (IBAction)stayInBack:(id)sender\n{\n    ASLogDebug(@\"Stay in Back\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:kCGDesktopIconWindowLevel +1];\n}\n\n- (IBAction)stayLevelNormal:(id)sender\n{\n    ASLogDebug(@\"Stay level normal\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:NSNormalWindowLevel];\n}\n\n- (IBAction)coreTextButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle CoreText renderer\");\n    NSInteger renderer = MMRendererDefault;\n    BOOL enable = ([sender state] == NSControlStateValueOn);\n\n    if (enable) {\n        renderer = MMRendererCoreText;\n    }\n\n    // Update the user default MMRenderer and synchronize the change so that\n    // any new Vim process will pick up on the changed setting.\n    CFPreferencesSetAppValue(\n            (CFStringRef)MMRendererKey,\n            (CFPropertyListRef)[NSNumber numberWithInt:renderer],\n            kCFPreferencesCurrentApplication);\n    CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);\n\n    ASLogInfo(@\"Use renderer=%ld\", renderer);\n\n    // This action is called when the user clicks the \"use CoreText renderer\"\n    // button in the advanced preferences pane.\n    [self rebuildPreloadCache];\n}\n\n- (IBAction)loginShellButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle login shell option\");\n    // This action is called when the user clicks the \"use login shell\" button\n    // in the advanced preferences pane.\n    [self rebuildPreloadCache];\n}\n\n- (IBAction)quickstartButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle Quickstart option\");\n    if ([self maxPreloadCacheSize] > 0) {\n        [self scheduleVimControllerPreloadAfterDelay:1.0];\n        [self startWatchingVimDir];\n    } else {\n        [self cancelVimControllerPreloadRequests];\n        [self clearPreloadCacheWithCount:-1];\n        [self stopWatchingVimDir];\n    }\n}\n\n- (MMVimController *)keyVimController\n{\n    NSWindow *keyWindow = [NSApp keyWindow];\n    if (keyWindow) {\n        unsigned i, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if ([[[vc windowController] window] isEqual:keyWindow])\n                return vc;\n        }\n    }\n\n    return nil;\n}\n\n- (unsigned)connectBackend:(byref in id <MMBackendProtocol>)proxy pid:(int)pid\n{\n    ASLogDebug(@\"pid=%d\", pid);\n\n    [(NSDistantObject*)proxy setProtocolForProxy:@protocol(MMBackendProtocol)];\n\n    // NOTE: Allocate the vim controller now but don't add it to the list of\n    // controllers since this is a distributed object call and as such can\n    // arrive at unpredictable times (e.g. while iterating the list of vim\n    // controllers).\n    // (What if input arrives before the vim controller is added to the list of\n    // controllers?  This should not be a problem since the input isn't\n    // processed immediately (see processInput:forIdentifier:).)\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    MMVimController *vc = [[MMVimController alloc] initWithBackend:proxy\n                                                               pid:pid];\n    [self performSelectorOnMainThread:@selector(addVimController:)\n                           withObject:vc\n                        waitUntilDone:NO\n                                modes:[NSArray arrayWithObject:\n                                       NSDefaultRunLoopMode]];\n\n    [vc release];\n\n    return [vc vimControllerId];\n}\n\n- (oneway void)processInput:(in bycopy NSArray *)queue\n              forIdentifier:(unsigned)identifier\n{\n    // NOTE: Input is not handled immediately since this is a distributed\n    // object call and as such can arrive at unpredictable times.  Instead,\n    // queue the input and process it when the run loop is updated.\n\n    if (!(queue && identifier)) {\n        ASLogWarn(@\"Bad input for identifier=%d\", identifier);\n        return;\n    }\n\n    ASLogDebug(@\"QUEUE for identifier=%d: <<< %@>>>\", identifier,\n               debugStringForMessageQueue(queue));\n\n    NSNumber *key = [NSNumber numberWithUnsignedInt:identifier];\n    NSArray *q = [inputQueues objectForKey:key];\n    if (q) {\n        q = [q arrayByAddingObjectsFromArray:queue];\n        [inputQueues setObject:q forKey:key];\n    } else {\n        [inputQueues setObject:queue forKey:key];\n    }\n\n    // NOTE: We must use \"event tracking mode\" as well as \"default mode\",\n    // otherwise the input queue will not be processed e.g. during live\n    // resizing.\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    [self performSelectorOnMainThread:@selector(processInputQueues:)\n                           withObject:nil\n                        waitUntilDone:NO\n                                modes:[NSArray arrayWithObjects:\n                                       NSDefaultRunLoopMode,\n                                       NSEventTrackingRunLoopMode, nil]];\n}\n\n- (NSArray *)serverList\n{\n    NSMutableArray *array = [NSMutableArray array];\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *controller = [vimControllers objectAtIndex:i];\n        if ([controller serverName])\n            [array addObject:[controller serverName]];\n    }\n\n    return array;\n}\n\n// Begin NSUserInterfaceItemSearching implementation\n- (NSArray<NSString *> *)localizedTitlesForItem:(id)item\n{\n    return item;\n}\n\n- (void)searchForItemsWithSearchString:(NSString *)searchString\n                           resultLimit:(NSInteger)resultLimit\n                    matchedItemHandler:(void (^)(NSArray *items))handleMatchedItems\n{\n    // Search documentation tags and provide the results in a pair of (file\n    // name, tag name). Currently lazily parse the Vim's doc tags, and reuse\n    // that in future searches.\n    //\n    // Does not support plugins for now, as different Vim instances could have\n    // different plugins loaded. Theoretically it's possible to query the\n    // current Vim instance for what plugins are loaded and the tags associated\n    // with them but it's tricky especially since this function is not invoked\n    // on the main thread. Just providing Vim's builtin docs should be mostly\n    // good enough.\n\n    static BOOL parsed = NO;\n    static NSMutableArray *parsedLineComponents = nil;\n\n    @synchronized (self) {\n        if (!parsed) {\n            parsedLineComponents = [[NSMutableArray alloc]init];\n            \n            NSString *tagsFilePath = [[[NSBundle mainBundle] resourcePath]\n                                      stringByAppendingPathComponent:@\"vim/runtime/doc/tags\"];\n            NSString *fileContent = [NSString stringWithContentsOfFile:tagsFilePath encoding:NSUTF8StringEncoding error:NULL];\n            NSArray *lines = [fileContent componentsSeparatedByString:@\"\\n\"];\n            \n            for (NSString *line in lines) {\n                NSArray<NSString *> *components = [line componentsSeparatedByString:@\"\\t\"];\n                if ([components count] < 2) {\n                    continue;\n                }\n                [parsedLineComponents addObject:components];\n            }\n            \n            parsed = YES;\n        }\n    }\n\n    // Use a simple search algorithm where the string is split by whitespace and each word has to match\n    // substring in the tag. Don't do fuzzy matching or regex for simplicity for now.\n    NSArray<NSString *> *searchStrings = [searchString componentsSeparatedByString:@\" \"];\n\n    NSMutableArray *ret = [[[NSMutableArray alloc]init] autorelease];\n    for (NSArray<NSString *> *line in parsedLineComponents) {\n        BOOL found = YES;\n        for (NSString *curSearchString in searchStrings) {\n            if (![line[0] localizedCaseInsensitiveContainsString:curSearchString]) {\n                found = NO;\n                break;\n            }\n        }\n        if (found) {\n            // We flip the ordering because we want it to look like \"file_name.txt > tag_name\" in the results.\n            NSArray *foundObject = @[line[1], line[0]];\n            \n            if ([searchStrings count] == 1 && [searchString localizedCaseInsensitiveCompare:line[0]] == NSOrderedSame) {\n                // Exact match has highest priority.\n                [ret insertObject:foundObject atIndex:0];\n            }\n            else {\n                // Don't do any other prioritization for now. May add more sophisticated sorting/heuristics\n                // in the future.\n                [ret addObject:foundObject];\n            }\n        }\n    }\n\n    // Return the results to callback.\n    handleMatchedItems(ret);\n}\n\n- (void)performActionForItem:(id)item\n{\n    // When opening a help page, either open a new Vim instance, or reuse the\n    // existing one.\n    MMVimController *vimController = [self keyVimController];\n    if (vimController == nil) {\n        [self showVimHelp:self withCmd:[NSString stringWithFormat:\n                                        @\":help %@\", item[1]]];\n        return;\n    }\n    [vimController addVimInput:[NSString stringWithFormat:\n                                @\"<C-\\\\><C-N>:help %@<CR>\", item[1]]];\n}\n// End NSUserInterfaceItemSearching\n\n@end // MMAppController\n\n\n\n\n@implementation MMAppController (MMServices)\n\n- (void)openSelection:(NSPasteboard *)pboard userData:(NSString *)userData\n                error:(NSString **)error\n{\n    if (![[pboard types] containsObject:NSPasteboardTypeString]) {\n        ASLogNotice(@\"Pasteboard contains no NSPasteboardTypeString\");\n        return;\n    }\n\n    ASLogInfo(@\"Open new window containing current selection\");\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        [vc sendMessage:AddNewTabMsgID data:nil];\n        [vc dropString:[pboard stringForType:NSPasteboardTypeString]];\n    } else {\n        // Save the text, open a new window, and paste the text when the next\n        // window opens.  (If this is called several times in a row, then all\n        // but the last call may be ignored.)\n        if (openSelectionString) [openSelectionString release];\n        openSelectionString = [[pboard stringForType:NSPasteboardTypeString] copy];\n\n        [self newWindow:self];\n    }\n}\n\n- (void)openFile:(NSPasteboard *)pboard userData:(NSString *)userData\n           error:(NSString **)error\n{\n    if (![[pboard types] containsObject:NSPasteboardTypeString]) {\n        ASLogNotice(@\"Pasteboard contains no NSPasteboardTypeString\");\n        return;\n    }\n\n    // TODO: Parse multiple filenames and create array with names.\n    NSString *string = [pboard stringForType:NSPasteboardTypeString];\n    string = [string stringByTrimmingCharactersInSet:\n            [NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    string = [string stringByStandardizingPath];\n\n    ASLogInfo(@\"Open new window with selected file: %@\", string);\n\n    NSArray *filenames = [self filterFilesAndNotify:\n            [NSArray arrayWithObject:string]];\n    if ([filenames count] == 0)\n        return;\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        [vc dropFiles:filenames forceOpen:YES];\n    } else {\n        [self openFiles:filenames withArguments:nil];\n    }\n}\n\n- (void)newFileHere:(NSPasteboard *)pboard userData:(NSString *)userData\n              error:(NSString **)error\n{\n    NSArray<NSString *> *filenames = extractPasteboardFilenames(pboard);\n    if (filenames == nil || filenames.count == 0)\n        return;\n    NSString *path = [filenames lastObject];\n\n    BOOL dirIndicator;\n    if (![[NSFileManager defaultManager] fileExistsAtPath:path\n                                              isDirectory:&dirIndicator]) {\n        ASLogNotice(@\"Invalid path. Cannot open new document at: %@\", path);\n        return;\n    }\n\n    ASLogInfo(@\"Open new file at path=%@\", path);\n\n    if (!dirIndicator)\n        path = [path stringByDeletingLastPathComponent];\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                              path, @\"path\",\n                              nil];\n        [vc sendMessage:NewFileHereMsgID data:[args dictionaryAsData]];\n    } else {\n        [self launchVimProcessWithArguments:nil workingDirectory:path];\n    }\n}\n\n@end // MMAppController (MMServices)\n\n\n\n\n@implementation MMAppController (Private)\n\n/// Initializes the Sparkle updater and show a \"What's New\" page if needed.\n/// Can be called more than once, but later calls will be silently ignored.\n/// This should be called after the initial untitled window is shown to make\n/// sure the updater/\"What's New\" windows can be shown on top of it.\n- (void)startUpdaterAndWhatsNewPage\n{\n    static BOOL started = NO;\n    if (!started) {\n#if !DISABLE_SPARKLE && !USE_SPARKLE_1\n        [updater startUpdater];\n#endif\n\n        if (shouldShowWhatsNewPage) {\n            // Schedule it to be run later to make sure it will show up on top\n            // of the new untitled window.\n            [MMWhatsNewController performSelectorOnMainThread:@selector(openSharedInstance) withObject:nil waitUntilDone:NO];\n        }\n\n        started = YES;\n    }\n}\n\n- (MMVimController *)topmostVimController\n{\n    // Find the topmost visible window which has an associated vim controller\n    // as follows:\n    //\n    // 1. Search through ordered windows as determined by NSApp.  Unfortunately\n    //    this method can fail, e.g. if a full-screen window is on another\n    //    \"Space\" (in this case NSApp returns no windows at all), so we have to\n    //    fall back on ...\n    // 2. Search through all Vim controllers and return the first visible\n    //    window.\n\n    NSEnumerator *e = [[NSApp orderedWindows] objectEnumerator];\n    id window;\n    while ((window = [e nextObject]) && [window isVisible]) {\n        unsigned i, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if ([[[vc windowController] window] isEqual:window])\n                return vc;\n        }\n    }\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isVisible]) {\n            return vc;\n        }\n    }\n\n    return nil;\n}\n\n- (int)launchVimProcessWithArguments:(NSArray *)args\n                    workingDirectory:(NSString *)cwd\n{\n    int pid = -1;\n    NSString *path = [[NSBundle mainBundle] pathForAuxiliaryExecutable:@\"Vim\"];\n\n    if (!path) {\n        ASLogCrit(@\"Vim executable could not be found inside app bundle!\");\n        return -1;\n    }\n\n    // Change current working directory so that the child process picks it up.\n    NSFileManager *fm = [NSFileManager defaultManager];\n    NSString *restoreCwd = nil;\n    if (cwd) {\n        restoreCwd = [fm currentDirectoryPath];\n        [fm changeCurrentDirectoryPath:cwd];\n    }\n\n    NSArray *taskArgs = [NSArray arrayWithObjects:@\"-g\", @\"-f\", nil];\n    if (args)\n        taskArgs = [taskArgs arrayByAddingObjectsFromArray:args];\n\n    BOOL useLoginShell = [[NSUserDefaults standardUserDefaults]\n            boolForKey:MMLoginShellKey];\n    if (useLoginShell) {\n        // Run process with a login shell, roughly:\n        //   echo \"exec Vim -g -f args\" | ARGV0=-`basename $SHELL` $SHELL [-l]\n        pid = [self executeInLoginShell:path arguments:taskArgs];\n    } else {\n        // Run process directly:\n        //   Vim -g -f args\n        NSTask *task = [NSTask launchedTaskWithLaunchPath:path\n                                                arguments:taskArgs];\n        pid = task ? [task processIdentifier] : -1;\n    }\n\n    if (-1 != pid) {\n        // The 'pidArguments' dictionary keeps arguments to be passed to the\n        // process when it connects (this is in contrast to arguments which are\n        // passed on the command line, like '-f' and '-g').\n        // NOTE: If there are no arguments to pass we still add a null object\n        // so that we can use this dictionary to check if there are any\n        // processes loading.\n        NSNumber *pidKey = [NSNumber numberWithInt:pid];\n        if (![pidArguments objectForKey:pidKey])\n            [pidArguments setObject:[NSNull null] forKey:pidKey];\n    } else {\n        ASLogWarn(@\"Failed to launch Vim process: args=%@, useLoginShell=%d\",\n                  args, useLoginShell);\n    }\n\n    // Now that child has launched, restore the current working directory.\n    if (restoreCwd)\n        [fm changeCurrentDirectoryPath:restoreCwd];\n\n    return pid;\n}\n\n- (NSArray *)filterFilesAndNotify:(NSArray *)filenames\n{\n    // Go trough 'filenames' array and make sure each file exists.  Present\n    // warning dialog if some file was missing.\n\n    NSString *firstMissingFile = nil;\n    NSMutableArray *files = [NSMutableArray array];\n    unsigned i, count = [filenames count];\n\n    for (i = 0; i < count; ++i) {\n        NSString *name = [filenames objectAtIndex:i];\n        if ([[NSFileManager defaultManager] fileExistsAtPath:name]) {\n            [files addObject:name];\n        } else if (!firstMissingFile) {\n            firstMissingFile = name;\n        }\n    }\n\n    if (firstMissingFile) {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                @\"Dialog button\")];\n\n        NSString *text;\n        if ([files count] >= count-1) {\n            [alert setMessageText:NSLocalizedString(@\"File not found\",\n                    @\"File not found dialog, title\")];\n            text = [NSString stringWithFormat:NSLocalizedString(\n                    @\"Could not open file with name %@.\",\n                    @\"File not found dialog, text\"), firstMissingFile];\n        } else {\n            [alert setMessageText:NSLocalizedString(@\"Multiple files not found\",\n                    @\"File not found dialog, title\")];\n            text = [NSString stringWithFormat:NSLocalizedString(\n                    @\"Could not open file with name %@, and %u other files.\",\n                    @\"File not found dialog, text\"),\n                firstMissingFile, (unsigned int)(count-[files count]-1)];\n        }\n\n        [alert setInformativeText:text];\n        [alert setAlertStyle:NSAlertStyleWarning];\n\n        [alert runModal];\n        [alert release];\n\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplyFailure];\n    }\n\n    return files;\n}\n\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n               openFilesDict:(NSDictionary **)openFiles\n{\n    // Filter out any files in the 'filenames' array that are open and return\n    // all files that are not already open.  On return, the 'openFiles'\n    // parameter (if non-nil) will point to a dictionary of open files, indexed\n    // by Vim controller.\n\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    NSMutableArray *files = [filenames mutableCopy];\n\n    // TODO: Escape special characters in 'files'?\n    NSString *expr = [NSString stringWithFormat:\n            @\"map([\\\"%@\\\"],\\\"bufloaded(v:val)\\\")\",\n            [files componentsJoinedByString:@\"\\\",\\\"\"]];\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count && [files count] > 0; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n\n        // Query Vim for which files in the 'files' array are open.\n        NSString *eval = [vc evaluateVimExpression:expr];\n        if (!eval) continue;\n\n        NSIndexSet *idxSet = [NSIndexSet indexSetWithVimList:eval];\n        if ([idxSet count] > 0) {\n            [dict setObject:[files objectsAtIndexes:idxSet]\n                     forKey:[NSValue valueWithPointer:vc]];\n\n            // Remove all the files that were open in this Vim process and\n            // create a new expression to evaluate.\n            [files removeObjectsAtIndexes:idxSet];\n            expr = [NSString stringWithFormat:\n                    @\"map([\\\"%@\\\"],\\\"bufloaded(v:val)\\\")\",\n                    [files componentsJoinedByString:@\"\\\",\\\"\"]];\n        }\n    }\n\n    if (openFiles != nil)\n        *openFiles = dict;\n\n    return [files autorelease];\n}\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n- (void)handleXcodeModEvent:(NSAppleEventDescriptor *)event\n                 replyEvent:(NSAppleEventDescriptor *)reply\n{\n#if 0\n    // Xcode sends this event to query MacVim which open files have been\n    // modified.\n    ASLogDebug(@\"reply:%@\", reply);\n    ASLogDebug(@\"event:%@\", event);\n\n    NSEnumerator *e = [vimControllers objectEnumerator];\n    id vc;\n    while ((vc = [e nextObject])) {\n        DescType type = [reply descriptorType];\n        unsigned len = [[type data] length];\n        NSMutableData *data = [NSMutableData data];\n\n        [data appendBytes:&type length:sizeof(DescType)];\n        [data appendBytes:&len length:sizeof(unsigned)];\n        [data appendBytes:[reply data] length:len];\n\n        [vc sendMessage:XcodeModMsgID data:data];\n    }\n#endif\n}\n#endif\n\n- (void)handleGetURLEvent:(NSAppleEventDescriptor *)event\n               replyEvent:(NSAppleEventDescriptor *)reply\n{\n    NSURL *url = [NSURL URLWithString:[[event\n                                        paramDescriptorForKeyword:keyDirectObject]\n                                        stringValue]];\n\n    // We try to be compatible with TextMate's URL scheme here, as documented\n    // at http://blog.macromates.com/2007/the-textmate-url-scheme/ . Currently,\n    // this means that:\n    //\n    // The format is: mvim://open?<arguments> where arguments can be:\n    //\n    // * url \u2014 the actual file to open (i.e. a file://\u2026 URL), if you leave\n    //         out this argument, the frontmost document is implied.\n    // * line \u2014 line number to go to (one based).\n    // * column \u2014 column number to go to (one based).\n    //\n    // Example: mvim://open?url=file:///etc/profile&line=20\n\n    if ([[url host] isEqualToString:@\"open\"]) {\n        NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n        // Parse query (\"url=file://...&line=14\") into a dictionary\n        NSArray *queries = [[url query] componentsSeparatedByString:@\"&\"];\n        NSEnumerator *enumerator = [queries objectEnumerator];\n        NSString *param;\n        while ((param = [enumerator nextObject])) {\n            // query: <field>=<value>\n            NSArray *arr = [param componentsSeparatedByString:@\"=\"];\n            if ([arr count] == 2) {\n                // parse field\n                NSString *f = [arr objectAtIndex:0];\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                f = [f stringByRemovingPercentEncoding];\n#else\n                f = [f stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n#endif\n\n                // parse value\n                NSString *v = [arr objectAtIndex:1];\n\n                // We need to decode the parameters here because most URL\n                // parsers treat the query component as needing to be decoded\n                // instead of treating it as is. It does mean that a link to\n                // open file \"/tmp/file name.txt\" will be\n                // mvim://open?url=file:///tmp/file%2520name.txt to encode a\n                // URL of file:///tmp/file%20name.txt. This double-encoding is\n                // intentional to follow the URL spec.\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                v = [v stringByRemovingPercentEncoding];\n#else\n                v = [v stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n#endif\n\n                if ([f isEqualToString:@\"url\"]) {\n                    // Since the URL scheme uses a double-encoding due to a\n                    // file:// URL encoded in another mvim: one, existing tools\n                    // like iTerm2 could sometimes erroneously only do a single\n                    // encode. To maximize compatiblity, we re-encode invalid\n                    // characters if we detect them as they would not work\n                    // later on when we pass this string to URLWithString.\n                    //\n                    // E.g. mvim://open?uri=file:///foo%20bar => \"file:///foo bar\"\n                    // which is not a valid URL, so we re-encode it to\n                    // file:///foo%20bar here. The only important case is to\n                    // not touch the \"%\" character as it introduces ambiguity\n                    // and the re-encoding is a nice compatibility feature, but\n                    // the canonical form should be double-encoded, i.e.\n                    // mvim://open?uri=file:///foo%2520bar\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                    NSMutableCharacterSet *charSet = [NSMutableCharacterSet characterSetWithCharactersInString:@\"%\"];\n                    [charSet formUnionWithCharacterSet:NSCharacterSet.URLHostAllowedCharacterSet];\n                    [charSet formUnionWithCharacterSet:NSCharacterSet.URLPathAllowedCharacterSet];\n                    v = [v stringByAddingPercentEncodingWithAllowedCharacters:charSet];\n#endif\n                }\n\n                [dict setValue:v forKey:f];\n            }\n        }\n\n        // Actually open the file.\n        NSString *file = [dict objectForKey:@\"url\"];\n        if (file != nil) {\n            NSURL *fileUrl = [NSURL URLWithString:file];\n            if ([fileUrl isFileURL]) {\n                NSString *filePath = [fileUrl path];\n                // Only opens files that already exist.\n                if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) {\n                    NSArray *filenames = [NSArray arrayWithObject:filePath];\n\n                    // Look for the line and column options.\n                    NSDictionary *args = nil;\n                    NSString *line = [dict objectForKey:@\"line\"];\n                    if (line) {\n                        NSString *column = [dict objectForKey:@\"column\"];\n                        if (column)\n                            args = [NSDictionary dictionaryWithObjectsAndKeys:\n                                    line, @\"cursorLine\",\n                                    column, @\"cursorColumn\",\n                                    nil];\n                        else\n                            args = [NSDictionary dictionaryWithObject:line\n                                                               forKey:@\"cursorLine\"];\n                    }\n\n                    [self openFiles:filenames withArguments:args];\n                } else {\n                    NSAlert *alert = [[NSAlert alloc] init];\n                    [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                        @\"Dialog button\")];\n\n                    [alert setMessageText:NSLocalizedString(@\"Bad file path\",\n                        @\"Bad file path dialog, title\")];\n                    [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n                        @\"Cannot open file path \\\"%@\\\"\",\n                        @\"Bad file path dialog, text\"),\n                        filePath]];\n\n                    [alert setAlertStyle:NSAlertStyleWarning];\n                    [alert runModal];\n                    [alert release];\n                }\n            } else {\n                NSAlert *alert = [[NSAlert alloc] init];\n                [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                    @\"Dialog button\")];\n\n                [alert setMessageText:NSLocalizedString(@\"Invalid File URL\",\n                    @\"Unknown Fie URL dialog, title\")];\n                [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n                    @\"Unknown file URL in \\\"%@\\\"\",\n                    @\"Unknown file URL dialog, text\"),\n                    file]];\n\n                [alert setAlertStyle:NSAlertStyleWarning];\n                [alert runModal];\n                [alert release];\n            }\n        }\n    } else {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n            @\"Dialog button\")];\n\n        [alert setMessageText:NSLocalizedString(@\"Unknown URL Scheme\",\n            @\"Unknown URL Scheme dialog, title\")];\n        [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n            @\"This version of MacVim does not support \\\"%@\\\"\"\n            @\" in its URL scheme.\",\n            @\"Unknown URL Scheme dialog, text\"),\n            [url host]]];\n\n        [alert setAlertStyle:NSAlertStyleWarning];\n        [alert runModal];\n        [alert release];\n    }\n}\n\n- (NSMutableDictionary *)extractArgumentsFromOdocEvent:\n    (NSAppleEventDescriptor *)desc\n{\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n    // 1. Extract ODB parameters (if any)\n    NSAppleEventDescriptor *odbdesc = desc;\n    if (![odbdesc paramDescriptorForKeyword:keyFileSender]) {\n        // The ODB paramaters may hide inside the 'keyAEPropData' descriptor.\n        odbdesc = [odbdesc paramDescriptorForKeyword:keyAEPropData];\n        if (![odbdesc paramDescriptorForKeyword:keyFileSender])\n            odbdesc = nil;\n    }\n\n    if (odbdesc) {\n        NSAppleEventDescriptor *p =\n                [odbdesc paramDescriptorForKeyword:keyFileSender];\n        if (p)\n            [dict setObject:[NSNumber numberWithUnsignedInt:[p typeCodeValue]]\n                     forKey:@\"remoteID\"];\n\n        p = [odbdesc paramDescriptorForKeyword:keyFileCustomPath];\n        if (p)\n            [dict setObject:[p stringValue] forKey:@\"remotePath\"];\n\n        p = [odbdesc paramDescriptorForKeyword:keyFileSenderToken];\n        if (p) {\n            [dict setObject:[NSNumber numberWithUnsignedLong:[p descriptorType]]\n                     forKey:@\"remoteTokenDescType\"];\n            [dict setObject:[p data] forKey:@\"remoteTokenData\"];\n        }\n    }\n\n    // 2. Extract Xcode parameters (if any)\n    NSAppleEventDescriptor *xcodedesc =\n            [desc paramDescriptorForKeyword:keyAEPosition];\n    if (xcodedesc) {\n        NSRange range;\n        NSData *data = [xcodedesc data];\n        NSUInteger length = [data length];\n\n        if (length == sizeof(MMXcodeSelectionRange)) {\n            MMXcodeSelectionRange *sr = (MMXcodeSelectionRange*)[data bytes];\n            ASLogDebug(@\"Xcode selection range (%d,%d,%d,%d,%d,%d)\",\n                    sr->unused1, sr->lineNum, sr->startRange, sr->endRange,\n                    sr->unused2, sr->theDate);\n\n            if (sr->lineNum < 0) {\n                // Should select a range of characters.\n                range.location = sr->startRange + 1;\n                range.length = sr->endRange > sr->startRange\n                             ? sr->endRange - sr->startRange : 1;\n            } else {\n                // Should only move cursor to a line.\n                range.location = sr->lineNum + 1;\n                range.length = 0;\n            }\n\n            [dict setObject:NSStringFromRange(range) forKey:@\"selectionRange\"];\n        } else {\n            ASLogErr(@\"Xcode selection range size mismatch! got=%ld \"\n                     \"expected=%ld\", length, sizeof(MMXcodeSelectionRange));\n        }\n    }\n\n    // 3. Extract Spotlight search text (if any)\n    NSAppleEventDescriptor *spotlightdesc = \n            [desc paramDescriptorForKeyword:keyAESearchText];\n    if (spotlightdesc) {\n        NSString *s = [[spotlightdesc stringValue]\n                                            stringBySanitizingSpotlightSearch];\n        if (s && [s length] > 0)\n            [dict setObject:s forKey:@\"searchText\"];\n    }\n\n    return dict;\n}\n\n- (void)scheduleVimControllerPreloadAfterDelay:(NSTimeInterval)delay\n{\n    [self performSelector:@selector(preloadVimController:)\n               withObject:nil\n               afterDelay:delay];\n}\n\n- (void)cancelVimControllerPreloadRequests\n{\n    [NSObject cancelPreviousPerformRequestsWithTarget:self\n            selector:@selector(preloadVimController:)\n              object:nil];\n}\n\n- (void)preloadVimController:(id)sender\n{\n    // We only allow preloading of one Vim process at a time (to avoid hogging\n    // CPU), so schedule another preload in a little while if necessary.\n    if (-1 != preloadPid) {\n        [self scheduleVimControllerPreloadAfterDelay:2];\n        return;\n    }\n\n    if ([cachedVimControllers count] >= [self maxPreloadCacheSize])\n        return;\n\n    preloadPid = [self launchVimProcessWithArguments:\n                                    [NSArray arrayWithObject:@\"--mmwaitforack\"]\n                                    workingDirectory:nil];\n\n    // This method is kicked off via FSEvents, so if MacVim is in the\n    // background, the runloop won't bother flushing the autorelease pool.\n    // Triggering an NSEvent works around this.\n    // http://www.mikeash.com/pyblog/more-fun-with-autorelease.html\n    NSEvent* event = [NSEvent otherEventWithType:NSEventTypeApplicationDefined\n                                        location:NSZeroPoint\n                                   modifierFlags:0\n                                       timestamp:0\n                                    windowNumber:0\n                                         context:nil\n                                         subtype:0\n                                           data1:0\n                                           data2:0];\n    [NSApp postEvent:event atStart:NO];\n}\n\n- (int)maxPreloadCacheSize\n{\n    // The maximum number of Vim processes to keep in the cache can be\n    // controlled via the user default \"MMPreloadCacheSize\".\n    int maxCacheSize = [[NSUserDefaults standardUserDefaults]\n            integerForKey:MMPreloadCacheSizeKey];\n    if (maxCacheSize < 0) maxCacheSize = 0;\n    else if (maxCacheSize > 10) maxCacheSize = 10;\n\n    return maxCacheSize;\n}\n\n- (MMVimController *)takeVimControllerFromCache\n{\n    // NOTE: After calling this message the backend corresponding to the\n    // returned vim controller must be sent an acknowledgeConnection message,\n    // else the vim process will be stuck.\n    //\n    // This method may return nil even though the cache might be non-empty; the\n    // caller should handle this by starting a new Vim process.\n\n    int i, count = [cachedVimControllers count];\n    if (0 == count) return nil;\n\n    // Locate the first Vim controller with up-to-date rc-files sourced.\n    NSDate *rcDate = [self rcFilesModificationDate];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [cachedVimControllers objectAtIndex:i];\n        NSDate *date = [vc creationDate];\n        if ([date compare:rcDate] != NSOrderedAscending)\n            break;\n    }\n\n    if (i > 0) {\n        // Clear out cache entries whose vimrc/gvimrc files were sourced before\n        // the latest modification date for those files.  This ensures that the\n        // latest rc-files are always sourced for new windows.\n        [self clearPreloadCacheWithCount:i];\n    }\n\n    if ([cachedVimControllers count] == 0) {\n        [self scheduleVimControllerPreloadAfterDelay:2.0];\n        return nil;\n    }\n\n    MMVimController *vc = [cachedVimControllers objectAtIndex:0];\n    [vimControllers addObject:vc];\n    [cachedVimControllers removeObjectAtIndex:0];\n    [vc setIsPreloading:NO];\n\n    // If the Vim process has finished loading then the window will displayed\n    // now, otherwise it will be displayed when the OpenWindowMsgID message is\n    // received.\n    [[vc windowController] presentWindow:nil];\n\n    // Since we've taken one controller from the cache we take the opportunity\n    // to preload another.\n    [self scheduleVimControllerPreloadAfterDelay:1];\n\n    return vc;\n}\n\n- (void)clearPreloadCacheWithCount:(int)count\n{\n    // Remove the 'count' first entries in the preload cache.  It is assumed\n    // that objects are added/removed from the cache in a FIFO manner so that\n    // this effectively clears the 'count' oldest entries.\n    // If 'count' is negative, then the entire cache is cleared.\n\n    if ([cachedVimControllers count] == 0 || count == 0)\n        return;\n\n    if (count < 0)\n        count = [cachedVimControllers count];\n\n    // Make sure the preloaded Vim processes get killed or they'll just hang\n    // around being useless until MacVim is terminated.\n    NSEnumerator *e = [cachedVimControllers objectEnumerator];\n    MMVimController *vc;\n    int n = count;\n    while ((vc = [e nextObject]) && n-- > 0) {\n        [[NSNotificationCenter defaultCenter] removeObserver:vc];\n        [vc sendMessage:TerminateNowMsgID data:nil];\n\n        // Since the preloaded processes were killed \"prematurely\" we have to\n        // manually tell them to cleanup (it is not enough to simply release\n        // them since deallocation and cleanup are separated).\n        [vc cleanup];\n    }\n\n    n = count;\n    while (n-- > 0 && [cachedVimControllers count] > 0)\n        [cachedVimControllers removeObjectAtIndex:0];\n\n    // There is a small delay before the Vim process actually exits so wait a\n    // little before trying to reap the child process.  If the process still\n    // hasn't exited after this wait it won't be reaped until the next time\n    // reapChildProcesses: is called (but this should be harmless).\n    [self performSelector:@selector(reapChildProcesses:)\n               withObject:nil\n               afterDelay:0.1];\n}\n\n- (void)rebuildPreloadCache\n{\n    if ([self maxPreloadCacheSize] > 0) {\n        [self clearPreloadCacheWithCount:-1];\n        [self cancelVimControllerPreloadRequests];\n        [self scheduleVimControllerPreloadAfterDelay:1.0];\n    }\n}\n\n- (NSDate *)rcFilesModificationDate\n{\n    // Check modification dates for ~/.vimrc and ~/.gvimrc and return the\n    // latest modification date.  If ~/.vimrc does not exist, check ~/_vimrc\n    // and similarly for gvimrc.\n    // Returns distantPath if no rc files were found.\n\n    NSDate *date = [NSDate distantPast];\n    NSFileManager *fm = [NSFileManager defaultManager];\n\n    NSString *path = [@\"~/.vimrc\" stringByExpandingTildeInPath];\n    NSDictionary *attr = [fm attributesOfItemAtPath:path error:NULL];\n    if (!attr) {\n        path = [@\"~/_vimrc\" stringByExpandingTildeInPath];\n        attr = [fm attributesOfItemAtPath:path error:NULL];\n    }\n    NSDate *modDate = [attr objectForKey:NSFileModificationDate];\n    if (modDate)\n        date = modDate;\n\n    path = [@\"~/.gvimrc\" stringByExpandingTildeInPath];\n    attr = [fm attributesOfItemAtPath:path error:NULL];\n    if (!attr) {\n        path = [@\"~/_gvimrc\" stringByExpandingTildeInPath];\n        attr = [fm attributesOfItemAtPath:path error:NULL];\n    }\n    modDate = [attr objectForKey:NSFileModificationDate];\n    if (modDate)\n        date = [date laterDate:modDate];\n\n    return date;\n}\n\n- (BOOL)openVimControllerWithArguments:(NSDictionary *)arguments\n{\n    MMVimController *vc = [self takeVimControllerFromCache];\n    if (vc) {\n        // Open files in a new window using a cached vim controller.  This\n        // requires virtually no loading time so the new window will pop up\n        // instantaneously.\n        [vc passArguments:arguments];\n        [[vc backendProxy] acknowledgeConnection];\n    } else {\n        NSArray *cmdline = nil;\n        NSString *cwd = [self workingDirectoryForArguments:arguments];\n        arguments = [self convertVimControllerArguments:arguments\n                                          toCommandLine:&cmdline];\n        int pid = [self launchVimProcessWithArguments:cmdline\n                                     workingDirectory:cwd];\n        if (-1 == pid)\n            return NO;\n\n        // TODO: If the Vim process fails to start, or if it changes PID,\n        // then the memory allocated for these parameters will leak.\n        // Ensure that this cannot happen or somehow detect it.\n\n        if ([arguments count] > 0)\n            [pidArguments setObject:arguments\n                             forKey:[NSNumber numberWithInt:pid]];\n    }\n\n    return YES;\n}\n\n- (void)activateWhenNextWindowOpens\n{\n    ASLogDebug(@\"Activate MacVim when next window opens\");\n    shouldActivateWhenNextWindowOpens = YES;\n}\n\n- (void)startWatchingVimDir\n{\n    if (fsEventStream)\n        return;\n\n    NSString *path = [@\"~/.vim\" stringByExpandingTildeInPath];\n    NSArray *pathsToWatch = [NSArray arrayWithObject:path];\n\n    fsEventStream = FSEventStreamCreate(NULL, &fsEventCallback, NULL,\n            (CFArrayRef)pathsToWatch, kFSEventStreamEventIdSinceNow,\n            MMEventStreamLatency, kFSEventStreamCreateFlagNone);\n\n    FSEventStreamScheduleWithRunLoop(fsEventStream,\n            [[NSRunLoop currentRunLoop] getCFRunLoop],\n            kCFRunLoopDefaultMode);\n\n    FSEventStreamStart(fsEventStream);\n    ASLogDebug(@\"Started FS event stream\");\n}\n\n- (void)stopWatchingVimDir\n{\n    if (fsEventStream) {\n        FSEventStreamStop(fsEventStream);\n        FSEventStreamInvalidate(fsEventStream);\n        FSEventStreamRelease(fsEventStream);\n        fsEventStream = NULL;\n        ASLogDebug(@\"Stopped FS event stream\");\n    }\n}\n\n- (void)handleFSEvent\n{\n    [self clearPreloadCacheWithCount:-1];\n\n    // Several FS events may arrive in quick succession so make sure to cancel\n    // any previous preload requests before making a new one.\n    [self cancelVimControllerPreloadRequests];\n    [self scheduleVimControllerPreloadAfterDelay:0.5];\n}\n\n- (int)executeInLoginShell:(NSString *)path arguments:(NSArray *)args\n{\n    // Start a login shell and execute the command 'path' with arguments 'args'\n    // in the shell.  This ensures that user environment variables are set even\n    // when MacVim was started from the Finder.\n\n    int pid = -1;\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    // Determine which shell to use to execute the command.  The user\n    // may decide which shell to use by setting a user default or the\n    // $SHELL environment variable.\n    NSString *shell = [ud stringForKey:MMLoginShellCommandKey];\n    if (!shell || [shell length] == 0)\n        shell = [[[NSProcessInfo processInfo] environment]\n            objectForKey:@\"SHELL\"];\n    if (!shell)\n        shell = @\"/bin/bash\";\n\n    // Bash needs the '-l' flag to launch a login shell.  The user may add\n    // flags by setting a user default.\n    NSString *shellArgument = [ud stringForKey:MMLoginShellArgumentKey];\n    if (!shellArgument || [shellArgument length] == 0) {\n        if ([[shell lastPathComponent] isEqual:@\"bash\"])\n            shellArgument = @\"-l\";\n        else\n            shellArgument = nil;\n    }\n\n    // Build input string to pipe to the login shell.\n    NSMutableString *input = [NSMutableString stringWithFormat:\n            @\"exec \\\"%@\\\"\", path];\n    if (args) {\n        // Append all arguments, making sure they are properly quoted, even\n        // when they contain single quotes.\n        NSEnumerator *e = [args objectEnumerator];\n        id obj;\n\n        while ((obj = [e nextObject])) {\n            NSMutableString *arg = [NSMutableString stringWithString:obj];\n            [arg replaceOccurrencesOfString:@\"'\" withString:@\"'\\\"'\\\"'\"\n                                    options:NSLiteralSearch\n                                      range:NSMakeRange(0, [arg length])];\n            [input appendFormat:@\" '%@'\", arg];\n        }\n    }\n\n    // Build the argument vector used to start the login shell.\n    NSString *shellArg0 = [NSString stringWithFormat:@\"-%@\",\n             [shell lastPathComponent]];\n    char *shellArgv[3] = { (char *)[shellArg0 UTF8String], NULL, NULL };\n    if (shellArgument)\n        shellArgv[1] = (char *)[shellArgument UTF8String];\n\n    // Get the C string representation of the shell path before the fork since\n    // we must not call Foundation functions after a fork.\n    const char *shellPath = [shell fileSystemRepresentation];\n\n    // Fork and execute the process.\n    int ds[2];\n    if (pipe(ds)) return -1;\n\n    pid = fork();\n    if (pid == -1) {\n        return -1;\n    } else if (pid == 0) {\n        // Child process\n\n        if (close(ds[1]) == -1) exit(255);\n        if (dup2(ds[0], 0) == -1) exit(255);\n\n        // Without the following call warning messages like this appear on the\n        // console:\n        //     com.apple.launchd[69] : Stray process with PGID equal to this\n        //                             dead job: PID 1589 PPID 1 Vim\n        setsid();\n\n        execv(shellPath, shellArgv);\n\n        // Never reached unless execv fails\n        exit(255);\n    } else {\n        // Parent process\n        if (close(ds[0]) == -1) return -1;\n\n        // Send input to execute to the child process\n        [input appendString:@\"\\n\"];\n        int bytes = [input lengthOfBytesUsingEncoding:NSUTF8StringEncoding];\n\n        if (write(ds[1], [input UTF8String], bytes) != bytes) return -1;\n        if (close(ds[1]) == -1) return -1;\n\n        ++numChildProcesses;\n        ASLogDebug(@\"new process pid=%d (count=%d)\", pid, numChildProcesses);\n    }\n\n    return pid;\n}\n\n- (void)reapChildProcesses:(id)sender\n{\n    // NOTE: numChildProcesses (currently) only counts the number of Vim\n    // processes that have been started with executeInLoginShell::.  If other\n    // processes are spawned this code may need to be adjusted (or\n    // numChildProcesses needs to be incremented when such a process is\n    // started).\n    while (numChildProcesses > 0) {\n        int status = 0;\n        int pid = waitpid(-1, &status, WNOHANG);\n        if (pid <= 0)\n            break;\n\n        ASLogDebug(@\"Wait for pid=%d complete\", pid);\n        --numChildProcesses;\n    }\n}\n\n- (void)processInputQueues:(id)sender\n{\n    // NOTE: Because we use distributed objects it is quite possible for this\n    // function to be re-entered.  This can cause all sorts of unexpected\n    // problems so we guard against it here so that the rest of the code does\n    // not need to worry about it.\n\n    // The processing flag is > 0 if this function is already on the call\n    // stack; < 0 if this function was also re-entered.\n    if (processingFlag != 0) {\n        ASLogDebug(@\"BUSY!\");\n        processingFlag = -1;\n        return;\n    }\n\n    // NOTE: Be _very_ careful that no exceptions can be raised between here\n    // and the point at which 'processingFlag' is reset.  Otherwise the above\n    // test could end up always failing and no input queues would ever be\n    // processed!\n    processingFlag = 1;\n\n    // NOTE: New input may arrive while we're busy processing; we deal with\n    // this by putting the current queue aside and creating a new input queue\n    // for future input.\n    NSDictionary *queues = inputQueues;\n    inputQueues = [NSMutableDictionary new];\n\n    // Pass each input queue on to the vim controller with matching\n    // identifier (and note that it could be cached).\n    NSEnumerator *e = [queues keyEnumerator];\n    NSNumber *key;\n    while ((key = [e nextObject])) {\n        unsigned ukey = [key unsignedIntValue];\n        int i = 0, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if (ukey == [vc vimControllerId]) {\n                [vc processInputQueue:[queues objectForKey:key]]; // !exceptions\n                break;\n            }\n        }\n\n        if (i < count) continue;\n\n        count = [cachedVimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [cachedVimControllers objectAtIndex:i];\n            if (ukey == [vc vimControllerId]) {\n                [vc processInputQueue:[queues objectForKey:key]]; // !exceptions\n                break;\n            }\n        }\n\n        if (i == count) {\n            ASLogWarn(@\"No Vim controller for identifier=%d\", ukey);\n        }\n    }\n\n    [queues release];\n\n    // If new input arrived while we were processing it would have been\n    // blocked so we have to schedule it to be processed again.\n    if (processingFlag < 0)\n        [self performSelectorOnMainThread:@selector(processInputQueues:)\n                               withObject:nil\n                            waitUntilDone:NO\n                                    modes:[NSArray arrayWithObjects:\n                                           NSDefaultRunLoopMode,\n                                           NSEventTrackingRunLoopMode, nil]];\n\n    processingFlag = 0;\n}\n\n- (void)addVimController:(MMVimController *)vc\n{\n    ASLogDebug(@\"Add Vim controller pid=%d id=%d\",\n            [vc pid], [vc vimControllerId]);\n\n    int pid = [vc pid];\n    NSNumber *pidKey = [NSNumber numberWithInt:pid];\n    id args = [pidArguments objectForKey:pidKey];\n\n    if (preloadPid == pid) {\n        // This controller was preloaded, so add it to the cache and\n        // schedule another vim process to be preloaded.\n        preloadPid = -1;\n        [vc setIsPreloading:YES];\n        [cachedVimControllers addObject:vc];\n        [self scheduleVimControllerPreloadAfterDelay:1];\n    } else {\n        [vimControllers addObject:vc];\n\n        if (args && [NSNull null] != args)\n            [vc passArguments:args];\n\n        // HACK!  MacVim does not get activated if it is launched from the\n        // terminal, so we forcibly activate here.  Note that each process\n        // launched from MacVim has an entry in the pidArguments dictionary,\n        // which is how we detect if the process was launched from the\n        // terminal.\n        if (!args) [self activateWhenNextWindowOpens];\n    }\n\n    if (args)\n        [pidArguments removeObjectForKey:pidKey];\n}\n\n- (NSDictionary *)convertVimControllerArguments:(NSDictionary *)args\n                                  toCommandLine:(NSArray **)cmdline\n{\n    // Take all arguments out of 'args' and put them on an array suitable to\n    // pass as arguments to launchVimProcessWithArguments:.  The untouched\n    // dictionary items are returned in a new autoreleased dictionary.\n\n    if (cmdline)\n        *cmdline = nil;\n\n    NSArray *filenames = [args objectForKey:@\"filenames\"];\n    int numFiles = filenames ? [filenames count] : 0;\n    BOOL openFiles = ![[args objectForKey:@\"dontOpen\"] boolValue];\n\n    if (numFiles <= 0 || !openFiles)\n        return args;\n\n    NSMutableArray *a = [NSMutableArray array];\n    NSMutableDictionary *d = [[args mutableCopy] autorelease];\n\n    // Search for text and highlight it (this Vim script avoids warnings in\n    // case there is no match for the search text).\n    NSString *searchText = [args objectForKey:@\"searchText\"];\n    if (searchText && [searchText length] > 0) {\n        [a addObject:@\"-c\"];\n        NSString *s = [NSString stringWithFormat:@\"if search('\\\\V\\\\c%@','cW')\"\n                \"|let @/='\\\\V\\\\c%@'|set hls|endif\", searchText, searchText];\n        [a addObject:s];\n\n        [d removeObjectForKey:@\"searchText\"];\n    }\n\n    // Position cursor using \"+line\" or \"-c :cal cursor(line,column)\".\n    NSString *lineString = [args objectForKey:@\"cursorLine\"];\n    if (lineString && [lineString intValue] > 0) {\n        NSString *columnString = [args objectForKey:@\"cursorColumn\"];\n        if (columnString && [columnString intValue] > 0) {\n            [a addObject:@\"-c\"];\n            [a addObject:[NSString stringWithFormat:@\":cal cursor(%@,%@)\",\n                          lineString, columnString]];\n\n            [d removeObjectForKey:@\"cursorColumn\"];\n        } else {\n            [a addObject:[NSString stringWithFormat:@\"+%@\", lineString]];\n        }\n\n        [d removeObjectForKey:@\"cursorLine\"];\n    }\n\n    // Set selection using normal mode commands.\n    NSString *rangeString = [args objectForKey:@\"selectionRange\"];\n    if (rangeString) {\n        NSRange r = NSRangeFromString(rangeString);\n        [a addObject:@\"-c\"];\n        if (r.length > 0) {\n            // Select given range of characters.\n            // TODO: This only works for encodings where 1 byte == 1 character\n            [a addObject:[NSString stringWithFormat:@\"norm %ldgov%ldgo\",\n                                                r.location, NSMaxRange(r)-1]];\n        } else {\n            // Position cursor on line at start of range.\n            [a addObject:[NSString stringWithFormat:@\"norm %ldGz.0\",\n                                                                r.location]];\n        }\n\n        [d removeObjectForKey:@\"selectionRange\"];\n    }\n\n    // Choose file layout using \"-[o|O|p]\".\n    int layout = [[args objectForKey:@\"layout\"] intValue];\n    switch (layout) {\n        case MMLayoutHorizontalSplit: [a addObject:@\"-o\"]; break;\n        case MMLayoutVerticalSplit:   [a addObject:@\"-O\"]; break;\n        case MMLayoutTabs:            [a addObject:@\"-p\"]; break;\n    }\n    [d removeObjectForKey:@\"layout\"];\n\n\n    // Last of all add the names of all files to open (DO NOT add more args\n    // after this point).\n    [a addObjectsFromArray:filenames];\n\n    if ([args objectForKey:@\"remoteID\"]) {\n        // These files should be edited remotely so keep the filenames on the\n        // argument list -- they will need to be passed back to Vim when it\n        // checks in.  Also set the 'dontOpen' flag or the files will be\n        // opened twice.\n        [d setObject:[NSNumber numberWithBool:YES] forKey:@\"dontOpen\"];\n    } else {\n        [d removeObjectForKey:@\"dontOpen\"];\n        [d removeObjectForKey:@\"filenames\"];\n    }\n\n    if (cmdline)\n        *cmdline = a;\n\n    return d;\n}\n\n- (NSString *)workingDirectoryForArguments:(NSDictionary *)args\n{\n    // Find the \"filenames\" argument and pick the first path that actually\n    // exists and return it.\n    // TODO: Return common parent directory in the case of multiple files?\n    NSFileManager *fm = [NSFileManager defaultManager];\n    NSArray *filenames = [args objectForKey:@\"filenames\"];\n    NSUInteger i, count = [filenames count];\n    for (i = 0; i < count; ++i) {\n        BOOL isdir;\n        NSString *file = [filenames objectAtIndex:i];\n        if ([fm fileExistsAtPath:file isDirectory:&isdir])\n            return isdir ? file : [file stringByDeletingLastPathComponent];\n    }\n\n    return nil;\n}\n\n- (NSScreen *)screenContainingTopLeftPoint:(NSPoint)pt\n{\n    // NOTE: The top left point has y-coordinate which lies one pixel above the\n    // window which must be taken into consideration (this method used to be\n    // called screenContainingPoint: but that method is \"off by one\" in\n    // y-coordinate).\n\n    NSArray *screens = [NSScreen screens];\n    NSUInteger i, count = [screens count];\n    for (i = 0; i < count; ++i) {\n        NSScreen *screen = [screens objectAtIndex:i];\n        NSRect frame = [screen frame];\n        if (pt.x >= frame.origin.x && pt.x < NSMaxX(frame)\n                // NOTE: inequalities below are correct due to this being a top\n                // left test (see comment above)\n                && pt.y > frame.origin.y && pt.y <= NSMaxY(frame))\n            return screen;\n    }\n\n    return nil;\n}\n\n- (void)addInputSourceChangedObserver\n{\n    id nc = [NSDistributedNotificationCenter defaultCenter];\n    NSString *notifyInputSourceChanged =\n        (NSString *)kTISNotifySelectedKeyboardInputSourceChanged;\n    [nc addObserver:self\n           selector:@selector(inputSourceChanged:)\n               name:notifyInputSourceChanged\n             object:nil];\n}\n\n- (void)removeInputSourceChangedObserver\n{\n    id nc = [NSDistributedNotificationCenter defaultCenter];\n    [nc removeObserver:self];\n}\n\n- (void)inputSourceChanged:(NSNotification *)notification\n{\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *controller = [vimControllers objectAtIndex:i];\n        MMWindowController *wc = [controller windowController];\n        MMTextView *tv = (MMTextView *)[[wc vimView] textView];\n        [tv checkImState];\n    }\n}\n\n@end // MMAppController (Private)\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#import <Foundation/Foundation.h>\n#import \"MacVim.h\"\n#import \"vim.h\"\n\n\n@interface MMBackend : NSObject <MMBackendProtocol, MMVimServerProtocol,\n        MMVimClientProtocol> {\n    NSMutableArray      *outputQueue;\n    NSMutableArray      *inputQueue;\n    NSMutableData       *drawData;\n    NSConnection        *connection;\n    NSConnection        *vimServerConnection;\n    id                  appProxy;\n    unsigned            identifier;\n    NSDictionary        *colorDict;\n    NSDictionary        *sysColorDict;\n    NSDictionary        *actionDict;\n    BOOL                tabBarVisible;\n    unsigned            backgroundColor;\n    unsigned            foregroundColor;\n    unsigned            specialColor;\n    unsigned            defaultBackgroundColor;\n    unsigned            defaultForegroundColor;\n    id                  dialogReturn;\n    NSTimer             *blinkTimer;\n    int                 blinkState;\n    NSTimeInterval      blinkWaitInterval;\n    NSTimeInterval      blinkOnInterval;\n    NSTimeInterval      blinkOffInterval;\n    NSMutableDictionary *connectionNameDict;\n    NSMutableDictionary *clientProxyDict;\n    NSMutableDictionary *serverReplyDict;\n    NSString            *alternateServerName;\n    GuiFont             oldWideFont;\n    BOOL                isTerminating;\n    BOOL                waitForAck;\n    int                 initialWindowLayout;\n    BOOL                flushDisabled;\n    unsigned            numWholeLineChanges;\n    unsigned            offsetForDrawDataPrune;\n    BOOL                imState;\n    int                 winposX;\n    int                 winposY;\n    BOOL                addToFindPboardOverride;\n#ifdef FEAT_BEVAL\n    NSString            *lastToolTip;\n#endif\n}\n\n+ (MMBackend *)sharedInstance;\n\n- (void)setBackgroundColor:(int)color;\n- (void)setForegroundColor:(int)color;\n- (void)setSpecialColor:(int)color;\n- (void)setDefaultColorsBackground:(int)bg foreground:(int)fg;\n- (NSConnection *)connection;\n- (NSDictionary *)actionDict;\n- (int)initialWindowLayout;\n- (void)getWindowPositionX:(int*)x Y:(int*)y;\n- (void)setWindowPositionX:(int)x Y:(int)y;\n\n- (void)queueMessage:(int)msgid properties:(NSDictionary *)props;\n- (BOOL)checkin;\n- (BOOL)openGUIWindow;\n- (void)clearAll;\n- (void)clearBlockFromRow:(int)row1 column:(int)col1\n                    toRow:(int)row2 column:(int)col2;\n- (void)deleteLinesFromRow:(int)row count:(int)count\n              scrollBottom:(int)bottom left:(int)left right:(int)right;\n- (void)drawString:(char_u*)s length:(int)len row:(int)row\n            column:(int)col cells:(int)cells flags:(int)flags;\n- (void)insertLinesFromRow:(int)row count:(int)count\n              scrollBottom:(int)bottom left:(int)left right:(int)right;\n- (void)drawCursorAtRow:(int)row column:(int)col shape:(int)shape\n               fraction:(int)percent color:(int)color;\n- (void)drawInvertedRectAtRow:(int)row column:(int)col numRows:(int)nr\n                   numColumns:(int)nc invert:(int)invert;\n- (void)drawSign:(NSString *)imgName\n           atRow:(int)row\n          column:(int)col\n           width:(int)width\n          height:(int)height;\n- (void)update;\n- (void)flushQueue:(BOOL)force;\n- (BOOL)waitForInput:(int)milliseconds;\n- (void)exit;\n- (void)selectTab:(int)index;\n- (void)updateTabBar;\n- (BOOL)tabBarVisible;\n- (void)showTabBar:(BOOL)enable;\n- (void)setRows:(int)rows columns:(int)cols;\n- (void)resizeView;\n- (void)setWindowTitle:(char *)title;\n- (void)setDocumentFilename:(char *)filename;\n- (char *)browseForFileWithAttributes:(NSDictionary *)attr;\n- (int)showDialogWithAttributes:(NSDictionary *)attr textField:(char *)txtfield;\n- (void)showToolbar:(int)enable flags:(int)flags;\n- (void)createScrollbarWithIdentifier:(int32_t)ident type:(int)type;\n- (void)destroyScrollbarWithIdentifier:(int32_t)ident;\n- (void)showScrollbarWithIdentifier:(int32_t)ident state:(int)visible;\n- (void)setScrollbarPosition:(int)pos length:(int)len identifier:(int32_t)ident;\n- (void)setScrollbarThumbValue:(long)val size:(long)size max:(long)max\n                    identifier:(int32_t)ident;\n- (void)setFont:(GuiFont)font wide:(BOOL)wide;\n- (void)executeActionWithName:(NSString *)name;\n- (void)setMouseShape:(int)shape;\n- (void)setBlinkWait:(int)wait on:(int)on off:(int)off;\n- (void)startBlink;\n- (void)stopBlink:(BOOL)updateCursor;\n- (void)adjustLinespace:(int)linespace;\n- (void)adjustColumnspace:(int)columnspace;\n- (void)activate;\n- (void)setPreEditRow:(int)row column:(int)col;\n\n- (void)showDefinition:(NSString *)text row:(int)row col:(int)col;\n\n- (int)lookupColorWithKey:(NSString *)key;\n- (BOOL)hasSpecialKeyWithValue:(char_u *)value;\n\n- (void)enterFullScreen:(int)fuoptions background:(int)bg;\n- (void)leaveFullScreen;\n- (void)setFullScreenBackgroundColor:(int)color;\n\n- (void)setAntialias:(BOOL)antialias;\n- (void)setLigatures:(BOOL)ligatures;\n- (void)setThinStrokes:(BOOL)thinStrokes;\n- (void)setBlurRadius:(int)radius;\n- (void)setBackground:(int)dark;\n\n- (void)updateModifiedFlag;\n\n- (void)registerServerWithName:(NSString *)name;\n- (BOOL)sendToServer:(NSString *)name string:(NSString *)string\n               reply:(char_u **)reply port:(int *)port expression:(BOOL)expr\n              silent:(BOOL)silent;\n- (NSArray *)serverList;\n- (NSString *)peekForReplyOnPort:(int)port;\n- (NSString *)waitForReplyOnPort:(int)port timeout:(NSTimeInterval)timeout;\n- (BOOL)sendReply:(NSString *)reply toPort:(int)port;\n\n- (BOOL)waitForAck;\n- (void)setWaitForAck:(BOOL)yn;\n- (void)waitForConnectionAcknowledgement;\n\n- (BOOL)addToFindPboardOverride;\n- (void)clearAddToFindPboardOverride;\n\n- (BOOL)imState;\n- (void)setImState:(BOOL)activated;\n\n#ifdef FEAT_BEVAL\n- (void)setLastToolTip:(NSString *)toolTip;\n#endif\n\n- (void)addToMRU:(NSArray *)filenames;\n\n@end\n\n\n\n@interface NSString (VimStrings)\n+ (id)stringWithVimString:(char_u *)s;\n- (char_u *)vimStringSave;\n@end\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#import \"MacVim.h\"\n\n\n@class MMWindowController;\n@class MMTouchBarInfo;\n\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12\n/// Button used for Touch Bar support, with an additional metadata to store the\n/// Vim command it should send.\n@interface MMTouchBarButton : NSButton {\n    NSArray *_desc;\n}\n- (NSArray *)desc;\n- (void)setDesc:(NSArray *)desc;\n@end\n#endif\n\n@interface MMVimController : NSObject<\n    NSToolbarDelegate\n    , NSOpenSavePanelDelegate\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    , NSTouchBarDelegate\n#endif\n    >\n{\n    unsigned            identifier;\n    BOOL                isInitialized;\n    MMWindowController  *windowController;\n    id                  backendProxy;\n    NSMenu              *mainMenu;\n    NSMutableArray      *popupMenuItems;\n\n    // TODO: Move all toolbar code to window controller?\n    NSToolbar           *toolbar;\n    NSMutableDictionary *toolbarItemDict;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    MMTouchBarInfo      *touchbarInfo;\n#endif\n\n    int                 pid;\n    NSString            *serverName;\n    NSDictionary        *vimState;\n    BOOL                isPreloading;\n    NSDate              *creationDate;\n    BOOL                hasModifiedBuffer;\n}\n\n- (id)initWithBackend:(id)backend pid:(int)processIdentifier;\n- (void)uninitialize;\n- (unsigned)vimControllerId;\n- (id)backendProxy;\n- (int)pid;\n- (void)setServerName:(NSString *)name;\n- (NSString *)serverName;\n- (MMWindowController *)windowController;\n- (NSDictionary *)vimState;\n- (id)objectForVimStateKey:(NSString *)key;\n- (NSMenu *)mainMenu;\n- (BOOL)isPreloading;\n- (void)setIsPreloading:(BOOL)yn;\n- (BOOL)hasModifiedBuffer;\n- (NSDate *)creationDate;\n- (void)cleanup;\n- (void)dropFiles:(NSArray *)filenames forceOpen:(BOOL)force;\n- (void)file:(NSString *)filename draggedToTabAtIndex:(NSUInteger)tabIndex;\n- (void)filesDraggedToTabBar:(NSArray *)filenames;\n- (void)dropString:(NSString *)string;\n- (void)appearanceChanged:(int)flag;\n\n- (void)passArguments:(NSDictionary *)args;\n- (void)sendMessage:(int)msgid data:(NSData *)data;\n- (BOOL)sendMessageNow:(int)msgid data:(NSData *)data\n               timeout:(NSTimeInterval)timeout;\n- (void)addVimInput:(NSString *)string;\n- (NSString *)evaluateVimExpression:(NSString *)expr;\n- (id)evaluateVimExpressionCocoa:(NSString *)expr\n                     errorString:(NSString **)errstr;\n- (void)processInputQueue:(NSArray *)queue;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (NSTouchBar *)makeTouchBar;\n#endif\n@end\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * MMVimController\n *\n * Coordinates input/output to/from backend.  A MMVimController sends input\n * directly to a MMBackend, but communication from MMBackend to MMVimController\n * goes via MMAppController so that it can coordinate all incoming distributed\n * object messages.\n *\n * MMVimController does not deal with visual presentation.  Essentially it\n * should be able to run with no window present.\n *\n * Output from the backend is received in processInputQueue: (this message is\n * called from MMAppController so it is not a DO call).  Input is sent to the\n * backend via sendMessage:data: or addVimInput:.  The latter allows execution\n * of arbitrary strings in the Vim process, much like the Vim script function\n * remote_send() does.  The messages that may be passed between frontend and\n * backend are defined in an enum in MacVim.h.\n */\n\n#import \"MMAppController.h\"\n#import \"MMFindReplaceController.h\"\n#import \"MMTextView.h\"\n#import \"MMVimController.h\"\n#import \"MMVimView.h\"\n#import \"MMWindowController.h\"\n#import \"Miscellaneous.h\"\n#import \"MMCoreTextView.h\"\n#import \"MMWindow.h\"\n\n\nstatic NSString * const MMDefaultToolbarImageName = @\"Attention\";\nstatic int MMAlertTextFieldHeight = 22;\n\nstatic NSString * const MMToolbarMenuName = @\"ToolBar\";\nstatic NSString * const MMTouchbarMenuName = @\"TouchBar\";\nstatic NSString * const MMWinBarMenuName = @\"WinBar\";\nstatic NSString * const MMPopUpMenuPrefix = @\"PopUp\";\nstatic NSString * const MMUserPopUpMenuPrefix = @\"]\";\n\n// NOTE: By default a message sent to the backend will be dropped if it cannot\n// be delivered instantly; otherwise there is a possibility that MacVim will\n// 'beachball' while waiting to deliver DO messages to an unresponsive Vim\n// process.  This means that you cannot rely on any message sent with\n// sendMessage: to actually reach Vim.\nstatic NSTimeInterval MMBackendProxyRequestTimeout = 0;\n\n// Timeout used for setDialogReturn:.\nstatic NSTimeInterval MMSetDialogReturnTimeout = 1.0;\n\nstatic unsigned identifierCounter = 1;\n\nstatic BOOL isUnsafeMessage(int msgid);\n\n\n// HACK! AppKit private methods from NSToolTipManager.  As an alternative to\n// using private methods, it would be possible to set the user default\n// NSInitialToolTipDelay (in ms) on app startup, but then it is impossible to\n// change the balloon delay without closing/reopening a window.\n@interface NSObject (NSToolTipManagerPrivateAPI)\n+ (id)sharedToolTipManager;\n- (void)setInitialToolTipDelay:(double)arg1;\n@end\n\n\n@interface MMAlert : NSAlert {\n    NSTextField *textField;\n}\n- (void)setTextFieldString:(NSString *)textFieldString;\n- (NSTextField *)textField;\n- (void)beginSheetModalForWindow:(NSWindow *)window\n                   modalDelegate:(id)delegate;\n@end\n\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_12\n@interface MMTouchBarInfo : NSObject;\n\n@property (readonly) NSTouchBar *touchbar;\n@property (readonly) NSMutableDictionary *itemDict;\n@property (readonly) NSMutableArray *itemOrder;\n\n@end\n\n@interface MMTouchBarItemInfo : NSObject;\n\n@property (readonly) NSTouchBarItem     *touchbarItem;\n@property (readwrite) BOOL              enabled;\n@property (readonly) NSString           *label;\n\n@property (readonly) MMTouchBarInfo     *childTouchbar; // Set when this is a submenu\n\n- (id)initWithItem:(NSTouchBarItem *)item label:(NSString *)label;\n- (void)setTouchBarItem:(NSTouchBarItem *)item;\n- (void)makeChildTouchBar;\n@end\n#endif\n\n@interface MMVimController (Private)\n- (void)doProcessInputQueue:(NSArray *)queue;\n- (void)handleMessage:(int)msgid data:(NSData *)data;\n- (void)savePanelDidEnd:(NSSavePanel *)panel code:(int)code\n                context:(void *)context;\n- (void)alertDidEnd:(MMAlert *)alert code:(int)code context:(void *)context;\n- (NSMenuItem *)menuItemForDescriptor:(NSArray *)desc;\n- (NSMenu *)parentMenuForDescriptor:(NSArray *)desc;\n- (NSMenu *)topLevelMenuForTitle:(NSString *)title;\n- (void)addMenuWithDescriptor:(NSArray *)desc atIndex:(int)index;\n- (void)addMenuItemWithDescriptor:(NSArray *)desc\n                          atIndex:(int)index\n                              tip:(NSString *)tip\n                             icon:(NSString *)icon\n                    keyEquivalent:(NSString *)keyEquivalent\n                     modifierMask:(int)modifierMask\n                           action:(NSString *)action\n                      isAlternate:(BOOL)isAlternate;\n- (void)removeMenuItemWithDescriptor:(NSArray *)desc;\n- (void)enableMenuItemWithDescriptor:(NSArray *)desc state:(BOOL)on;\n- (void)updateMenuItemTooltipWithDescriptor:(NSArray *)desc tip:(NSString *)tip;\n- (NSImage*)findToolbarIcon:(NSString*)icon;\n- (void)addToolbarItemToDictionaryWithLabel:(NSString *)title\n        toolTip:(NSString *)tip icon:(NSString *)icon;\n- (void)addToolbarItemWithLabel:(NSString *)label\n                          tip:(NSString *)tip icon:(NSString *)icon\n                      atIndex:(int)idx;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (void)addTouchbarItemWithLabel:(NSString *)label\n                            icon:(NSString *)icon\n                             tip:(NSString *)tip\n                         atIndex:(int)idx\n                       isSubMenu:(BOOL)submenu\n                            desc:(NSArray *)desc\n                      atTouchBar:(MMTouchBarInfo *)touchbarInfo;\n- (void)updateTouchbarItemLabel:(NSString *)label\n                            tip:(NSString *)tip\n                 atTouchBarItem:(MMTouchBarItemInfo*)item;\n- (BOOL)touchBarItemForDescriptor:(NSArray *)desc\n                         touchBar:(MMTouchBarInfo **)touchBarPtr\n                     touchBarItem:(MMTouchBarItemInfo **)touchBarItemPtr;\n#endif\n- (void)popupMenuWithDescriptor:(NSArray *)desc\n                          atRow:(NSNumber *)row\n                         column:(NSNumber *)col;\n- (void)popupMenuWithAttributes:(NSDictionary *)attrs;\n- (void)connectionDidDie:(NSNotification *)notification;\n- (void)scheduleClose;\n- (void)handleBrowseForFile:(NSDictionary *)attr;\n- (void)handleShowDialog:(NSDictionary *)attr;\n- (void)handleDeleteSign:(NSDictionary *)attr;\n- (void)setToolTipDelay;\n@end\n\n\n\n\n@implementation MMVimController\n\n- (id)initWithBackend:(id)backend pid:(int)processIdentifier\n{\n    if (!(self = [super init]))\n        return nil;\n\n    // TODO: Come up with a better way of creating an identifier.\n    identifier = identifierCounter++;\n\n    windowController =\n        [[MMWindowController alloc] initWithVimController:self];\n    backendProxy = [backend retain];\n    popupMenuItems = [[NSMutableArray alloc] init];\n    toolbarItemDict = [[NSMutableDictionary alloc] init];\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n        touchbarInfo = [[MMTouchBarInfo alloc] init];\n    }\n#endif\n    pid = processIdentifier;\n    creationDate = [[NSDate alloc] init];\n\n    NSConnection *connection = [backendProxy connectionForProxy];\n\n    // TODO: Check that this will not set the timeout for the root proxy\n    // (in MMAppController).\n    [connection setRequestTimeout:MMBackendProxyRequestTimeout];\n\n    [[NSNotificationCenter defaultCenter] addObserver:self\n            selector:@selector(connectionDidDie:)\n                name:NSConnectionDidDieNotification object:connection];\n\n    // Set up a main menu with only a \"MacVim\" menu (copied from a template\n    // which itself is set up in MainMenu.nib).  The main menu is populated\n    // by Vim later on.\n    mainMenu = [[NSMenu alloc] initWithTitle:@\"MainMenu\"];\n    NSMenuItem *appMenuItem = [[MMAppController sharedInstance]\n                                        appMenuItemTemplate];\n    appMenuItem = [[appMenuItem copy] autorelease];\n\n    // Note: If the title of the application menu is anything but what\n    // CFBundleName says then the application menu will not be typeset in\n    // boldface for some reason.  (It should already be set when we copy\n    // from the default main menu, but this is not the case for some\n    // reason.)\n    NSString *appName = [[NSBundle mainBundle]\n            objectForInfoDictionaryKey:@\"CFBundleName\"];\n    [appMenuItem setTitle:appName];\n\n    [mainMenu addItem:appMenuItem];\n\n    [self setToolTipDelay];\n\n    isInitialized = YES;\n\n    // After MMVimController's initialization is completed,\n    // set up the variable `v:os_appearance`.\n    [self appearanceChanged:getCurrentAppearance([windowController vimView].effectiveAppearance)];\n    \n    return self;\n}\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    isInitialized = NO;\n\n    [serverName release];  serverName = nil;\n    [backendProxy release];  backendProxy = nil;\n\n    [toolbarItemDict release];  toolbarItemDict = nil;\n    [toolbar release];  toolbar = nil;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    [touchbarInfo release]; touchbarInfo = nil;\n#endif\n    [popupMenuItems release];  popupMenuItems = nil;\n    [windowController release];  windowController = nil;\n\n    [vimState release];  vimState = nil;\n    [mainMenu release];  mainMenu = nil;\n    [creationDate release];  creationDate = nil;\n\n    [super dealloc];\n}\n\n/// This should only be called by MMAppController when it's doing an app quit.\n/// We just wait for all Vim processes to terminate instad of individually\n/// closing each MMVimController. We simply unset isInitialized to prevent it\n/// from handling and sending messages to now invalid Vim connections.\n- (void)uninitialize\n{\n    isInitialized = NO;\n}\n\n- (unsigned)vimControllerId\n{\n    return identifier;\n}\n\n- (MMWindowController *)windowController\n{\n    return windowController;\n}\n\n- (NSDictionary *)vimState\n{\n    return vimState;\n}\n\n- (id)objectForVimStateKey:(NSString *)key\n{\n    return [vimState objectForKey:key];\n}\n\n- (NSMenu *)mainMenu\n{\n    return mainMenu;\n}\n\n- (BOOL)isPreloading\n{\n    return isPreloading;\n}\n\n- (void)setIsPreloading:(BOOL)yn\n{\n    isPreloading = yn;\n}\n\n- (BOOL)hasModifiedBuffer\n{\n    return hasModifiedBuffer;\n}\n\n- (NSDate *)creationDate\n{\n    return creationDate;\n}\n\n- (void)setServerName:(NSString *)name\n{\n    if (name != serverName) {\n        [serverName release];\n        serverName = [name copy];\n    }\n}\n\n- (NSString *)serverName\n{\n    return serverName;\n}\n\n- (int)pid\n{\n    return pid;\n}\n\n- (void)dropFiles:(NSArray *)filenames forceOpen:(BOOL)force\n{\n    filenames = normalizeFilenames(filenames);\n    ASLogInfo(@\"filenames=%@ force=%d\", filenames, force);\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    // Default to opening in tabs if layout is invalid or set to \"windows\".\n    int layout = [ud integerForKey:MMOpenLayoutKey];\n    if (layout < 0 || layout > MMLayoutTabs)\n        layout = MMLayoutTabs;\n\n    BOOL splitVert = [ud boolForKey:MMVerticalSplitKey];\n    if (splitVert && MMLayoutHorizontalSplit == layout)\n        layout = MMLayoutVerticalSplit;\n\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n            [NSNumber numberWithInt:layout],    @\"layout\",\n            filenames,                          @\"filenames\",\n            [NSNumber numberWithBool:force],    @\"forceOpen\",\n            nil];\n\n    [self sendMessage:DropFilesMsgID data:[args dictionaryAsData]];\n\n    // Add dropped files to the \"Recent Files\" menu.\n    [[NSDocumentController sharedDocumentController]\n                                            noteNewRecentFilePaths:filenames];\n}\n\n// This is called when a file is dragged on top of a tab. We will open the file\n// list similar to drag-and-dropped files.\n- (void)file:(NSString *)filename draggedToTabAtIndex:(NSUInteger)tabIndex\n{\n    filename = normalizeFilename(filename);\n    ASLogInfo(@\"filename=%@ index=%ld\", filename, tabIndex);\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    \n    // This is similar to dropFiles:forceOpen: except we first switch to the\n    // selected tab, and just open the first file (this could be modified in the\n    // future to support multiple files). It also forces layout to be splits\n    // because we specified one tab to receive the file so doesn't make sense to\n    // open another tab.\n    int layout = MMLayoutHorizontalSplit;\n    if ([ud boolForKey:MMVerticalSplitKey])\n        layout = MMLayoutVerticalSplit;\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                          [NSNumber numberWithInt:layout],    @\"layout\",\n                          @[filename],                        @\"filenames\",\n                          [NSNumber numberWithInt:tabIndex + 1],    @\"tabpage\",\n                          nil];\n    \n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n// This is called when a file is dragged on top of the tab bar but not a\n// particular tab (e.g. the new tab button). We will open the file list similar\n// to drag-and-dropped files.\n- (void)filesDraggedToTabBar:(NSArray *)filenames\n{\n    filenames = normalizeFilenames(filenames);\n    ASLogInfo(@\"%@\", filenames);\n    \n    // This is similar to dropFiles:forceOpen: except we just force layout to be\n    // tabs (since the receipient is the tab bar, we assume that's the\n    // intention) instead of loading from user defaults.\n    int layout = MMLayoutTabs;\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                          [NSNumber numberWithInt:layout],    @\"layout\",\n                          filenames,                          @\"filenames\",\n                          nil];\n    \n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n- (void)dropString:(NSString *)string\n{\n    ASLogInfo(@\"%@\", string);\n    int len = [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding] + 1;\n    if (len > 0) {\n        NSMutableData *data = [NSMutableData data];\n\n        [data appendBytes:&len length:sizeof(int)];\n        [data appendBytes:[string UTF8String] length:len];\n\n        [self sendMessage:DropStringMsgID data:data];\n    }\n}\n\n- (void)appearanceChanged:(int)flag\n{\n    [self sendMessage:NotifyAppearanceChangeMsgID\n                 data:[NSData dataWithBytes: &flag\n               length:sizeof(flag)]];\n}\n\n- (void)passArguments:(NSDictionary *)args\n{\n    if (!args) return;\n\n    ASLogDebug(@\"args=%@\", args);\n\n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n- (void)sendMessage:(int)msgid data:(NSData *)data\n{\n    ASLogDebug(@\"msg=%s (isInitialized=%d)\",\n               MMVimMsgIDStrings[msgid], isInitialized);\n\n    if (!isInitialized) return;\n\n    @try {\n        [backendProxy processInput:msgid data:data];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"processInput:data: failed: pid=%d id=%d msg=%s reason=%@\",\n                pid, identifier, MMVimMsgIDStrings[msgid], ex);\n    }\n}\n\n- (BOOL)sendMessageNow:(int)msgid data:(NSData *)data\n               timeout:(NSTimeInterval)timeout\n{\n    // Send a message with a timeout.  USE WITH EXTREME CAUTION!  Sending\n    // messages in rapid succession with a timeout may cause MacVim to beach\n    // ball forever.  In almost all circumstances sendMessage:data: should be\n    // used instead.\n\n    ASLogDebug(@\"msg=%s (isInitialized=%d)\",\n               MMVimMsgIDStrings[msgid], isInitialized);\n\n    if (!isInitialized)\n        return NO;\n\n    if (timeout < 0) timeout = 0;\n\n    BOOL sendOk = YES;\n    NSConnection *conn = [backendProxy connectionForProxy];\n    NSTimeInterval oldTimeout = [conn requestTimeout];\n\n    [conn setRequestTimeout:timeout];\n\n    @try {\n        [backendProxy processInput:msgid data:data];\n    }\n    @catch (NSException *ex) {\n        sendOk = NO;\n        ASLogDebug(@\"processInput:data: failed: pid=%d id=%d msg=%s reason=%@\",\n                pid, identifier, MMVimMsgIDStrings[msgid], ex);\n    }\n    @finally {\n        [conn setRequestTimeout:oldTimeout];\n    }\n\n    return sendOk;\n}\n\n- (void)addVimInput:(NSString *)string\n{\n    ASLogDebug(@\"%@\", string);\n\n    // This is a very general method of adding input to the Vim process.  It is\n    // basically the same as calling remote_send() on the process (see\n    // ':h remote_send').\n    if (string) {\n        NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];\n        [self sendMessage:AddInputMsgID data:data];\n    }\n}\n\n- (NSString *)evaluateVimExpression:(NSString *)expr\n{\n    NSString *eval = nil;\n\n    @try {\n        eval = [backendProxy evaluateExpression:expr];\n        ASLogDebug(@\"eval(%@)=%@\", expr, eval);\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"evaluateExpression: failed: pid=%d id=%d reason=%@\",\n                pid, identifier, ex);\n    }\n\n    return eval;\n}\n\n- (id)evaluateVimExpressionCocoa:(NSString *)expr\n                     errorString:(NSString **)errstr\n{\n    id eval = nil;\n\n    @try {\n        eval = [backendProxy evaluateExpressionCocoa:expr\n                                         errorString:errstr];\n        ASLogDebug(@\"eval(%@)=%@\", expr, eval);\n    } @catch (NSException *ex) {\n        ASLogDebug(@\"evaluateExpressionCocoa: failed: pid=%d id=%d reason=%@\",\n                pid, identifier, ex);\n        *errstr = [ex reason];\n    }\n\n    return eval;\n}\n\n- (id)backendProxy\n{\n    return backendProxy;\n}\n\n- (void)cleanup\n{\n    if (!isInitialized) return;\n\n    // Remove any delayed calls made on this object.\n    [NSObject cancelPreviousPerformRequestsWithTarget:self];\n\n    isInitialized = NO;\n    [toolbar setDelegate:nil];\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    //[[backendProxy connectionForProxy] invalidate];\n    //[windowController close];\n    [windowController cleanup];\n}\n\n- (void)processInputQueue:(NSArray *)queue\n{\n    if (!isInitialized) return;\n\n    // NOTE: This method must not raise any exceptions (see comment in the\n    // calling method).\n    @try {\n        [self doProcessInputQueue:queue];\n        [windowController processInputQueueDidFinish];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"Exception: pid=%d id=%d reason=%@\", pid, identifier, ex);\n    }\n}\n\n- (NSToolbarItem *)toolbar:(NSToolbar *)theToolbar\n    itemForItemIdentifier:(NSString *)itemId\n    willBeInsertedIntoToolbar:(BOOL)flag\n{\n    NSToolbarItem *item = [toolbarItemDict objectForKey:itemId];\n    if (!item) {\n        ASLogWarn(@\"No toolbar item with id '%@'\", itemId);\n    }\n\n    return item;\n}\n\n- (NSArray *)toolbarAllowedItemIdentifiers:(NSToolbar *)theToolbar\n{\n    return nil;\n}\n\n- (NSArray *)toolbarDefaultItemIdentifiers:(NSToolbar *)theToolbar\n{\n    return nil;\n}\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (NSTouchBar *)makeTouchBarOn:(MMTouchBarInfo *)touchbarInfo\n{\n    NSMutableArray *filteredTouchbarItemOrder = [NSMutableArray array];\n    NSMutableSet *filteredItems = [NSMutableSet set];\n    for (NSString *label in touchbarInfo.itemOrder) {\n        MMTouchBarItemInfo *itemInfo = [touchbarInfo.itemDict objectForKey:label];\n        if ([itemInfo enabled]) {\n            [filteredTouchbarItemOrder addObject:[itemInfo label]];\n            \n            if ([itemInfo touchbarItem]) {\n                if ([itemInfo childTouchbar]) {\n                    NSTouchBar *childTouchbar = [self makeTouchBarOn:[itemInfo childTouchbar]];\n                    NSPopoverTouchBarItem *popoverItem = (NSPopoverTouchBarItem *)[itemInfo touchbarItem];\n                    [popoverItem setPopoverTouchBar:childTouchbar];\n                }\n\n                [filteredItems addObject:itemInfo.touchbarItem];\n            }\n        }\n    }\n    [filteredTouchbarItemOrder addObject:NSTouchBarItemIdentifierOtherItemsProxy];\n    \n    touchbarInfo.touchbar.defaultItemIdentifiers = filteredTouchbarItemOrder;\n    touchbarInfo.touchbar.templateItems = filteredItems;\n    return touchbarInfo.touchbar;\n}\n\n- (NSTouchBar *)makeTouchBar\n{\n    return [self makeTouchBarOn:touchbarInfo];\n}\n\n#endif\n\n@end // MMVimController\n\n\n@implementation MMVimController (Private)\n\n- (void)doProcessInputQueue:(NSArray *)queue\n{\n    NSMutableArray *delayQueue = nil;\n\n    unsigned i, count = [queue count];\n    if (count % 2) {\n        ASLogWarn(@\"Uneven number of components (%d) in command queue.  \"\n                  \"Skipping...\", count);\n        return;\n    }\n\n    for (i = 0; i < count; i += 2) {\n        NSData *value = [queue objectAtIndex:i];\n        NSData *data = [queue objectAtIndex:i+1];\n\n        int msgid = *((int*)[value bytes]);\n\n        BOOL inDefaultMode = [[[NSRunLoop currentRunLoop] currentMode]\n                                            isEqual:NSDefaultRunLoopMode];\n        if (!inDefaultMode && isUnsafeMessage(msgid)) {\n            // NOTE: Because we may be listening to DO messages in \"event\n            // tracking mode\" we have to take extra care when doing things\n            // like releasing view items (and other Cocoa objects).\n            // Messages that may be potentially \"unsafe\" are delayed until\n            // the run loop is back to default mode at which time they are\n            // safe to call again.\n            //   A problem with this approach is that it is hard to\n            // classify which messages are unsafe.  As a rule of thumb, if\n            // a message may release an object used by the Cocoa framework\n            // (e.g. views) then the message should be considered unsafe.\n            //   Delaying messages may have undesired side-effects since it\n            // means that messages may not be processed in the order Vim\n            // sent them, so beware.\n            if (!delayQueue)\n                delayQueue = [NSMutableArray array];\n\n            ASLogDebug(@\"Adding unsafe message '%s' to delay queue (mode=%@)\",\n                       MMVimMsgIDStrings[msgid],\n                       [[NSRunLoop currentRunLoop] currentMode]);\n            [delayQueue addObject:value];\n            [delayQueue addObject:data];\n        } else {\n            [self handleMessage:msgid data:data];\n        }\n    }\n\n    if (delayQueue) {\n        ASLogDebug(@\"    Flushing delay queue (%ld items)\",\n                   [delayQueue count]/2);\n        [self performSelector:@selector(processInputQueue:)\n                   withObject:delayQueue\n                   afterDelay:0];\n    }\n}\n\n- (void)handleMessage:(int)msgid data:(NSData *)data\n{\n    switch (msgid) {\n        case OpenWindowMsgID:\n        {\n            [windowController openWindow];\n            if (!isPreloading) {\n                [windowController presentWindow:nil];\n            }\n        }\n        break;\n        case BatchDrawMsgID:\n        {\n            [[[windowController vimView] textView] performBatchDrawWithData:data];\n        }\n        break;\n        case SelectTabMsgID:\n        {\n    #if 0   // NOTE: Tab selection is done inside updateTabsWithData:.\n            const void *bytes = [data bytes];\n            int idx = *((int*)bytes);\n            [windowController selectTabWithIndex:idx];\n    #endif\n        }\n        break;\n        case UpdateTabBarMsgID:\n        {\n            [windowController updateTabsWithData:data];\n        }\n        break;\n        case ShowTabBarMsgID:\n        {\n            [windowController showTabBar:YES];\n            [self sendMessage:BackingPropertiesChangedMsgID data:nil];\n        }\n        break;\n        case HideTabBarMsgID:\n        {\n            [windowController showTabBar:NO];\n            [self sendMessage:BackingPropertiesChangedMsgID data:nil];\n        }\n        break;\n\n        case SetTextDimensionsMsgID:\n        case LiveResizeMsgID:\n        case SetTextDimensionsNoResizeWindowMsgID:\n        case SetTextDimensionsReplyMsgID:\n        {\n            const void *bytes = [data bytes];\n            int rows = *((int*)bytes);  bytes += sizeof(int);\n            int cols = *((int*)bytes);\n\n            // NOTE: When a resize message originated in the frontend, Vim\n            // acknowledges it with a reply message.  When this happens the window\n            // should not move (the frontend would already have moved the window).\n            BOOL onScreen = SetTextDimensionsReplyMsgID!=msgid;\n\n            BOOL keepGUISize = SetTextDimensionsNoResizeWindowMsgID == msgid;\n\n            [windowController setTextDimensionsWithRows:rows\n                                     columns:cols\n                                      isLive:(LiveResizeMsgID==msgid)\n                                keepGUISize:keepGUISize\n                                keepOnScreen:onScreen];\n        }\n        break;\n\n        case ResizeViewMsgID:\n        {\n            [windowController resizeView];\n        }\n        break;\n        case SetWindowTitleMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n\n            NSString *string = [[NSString alloc] initWithBytes:(void*)bytes\n                    length:len encoding:NSUTF8StringEncoding];\n\n            [windowController setTitle:string];\n\n            [string release];\n        }\n        break;\n        case SetDocumentFilenameMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n\n            if (len > 0) {\n                NSString *filename = [[NSString alloc] initWithBytes:(void*)bytes\n                        length:len encoding:NSUTF8StringEncoding];\n\n                [windowController setDocumentFilename:filename];\n\n                [filename release];\n            } else {\n                [windowController setDocumentFilename:@\"\"];\n            }\n        }\n        break;\n        case AddMenuMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self addMenuWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                    atIndex:[[attrs objectForKey:@\"index\"] intValue]];\n        }\n        break;\n        case AddMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self addMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                          atIndex:[[attrs objectForKey:@\"index\"] intValue]\n                              tip:[attrs objectForKey:@\"tip\"]\n                             icon:[attrs objectForKey:@\"icon\"]\n                    keyEquivalent:[attrs objectForKey:@\"keyEquivalent\"]\n                     modifierMask:[[attrs objectForKey:@\"modifierMask\"] intValue]\n                           action:[attrs objectForKey:@\"action\"]\n                      isAlternate:[[attrs objectForKey:@\"isAlternate\"] boolValue]];\n        }\n        break;\n        case RemoveMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self removeMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]];\n        }\n        break;\n        case EnableMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self enableMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                    state:[[attrs objectForKey:@\"enable\"] boolValue]];\n        }\n        break;\n        case UpdateMenuItemTooltipMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self updateMenuItemTooltipWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                                                  tip:[attrs objectForKey:@\"tip\"]];\n        }\n        break;\n        case ShowToolbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int enable = *((int*)bytes);  bytes += sizeof(int);\n            int flags = *((int*)bytes);\n\n            int mode = NSToolbarDisplayModeDefault;\n            if (flags & ToolbarLabelFlag) {\n                mode = flags & ToolbarIconFlag ? NSToolbarDisplayModeIconAndLabel\n                        : NSToolbarDisplayModeLabelOnly;\n            } else if (flags & ToolbarIconFlag) {\n                mode = NSToolbarDisplayModeIconOnly;\n            }\n\n            int size = flags & ToolbarSizeRegularFlag ? NSToolbarSizeModeRegular\n                    : NSToolbarSizeModeSmall;\n\n            [windowController showToolbar:enable size:size mode:mode];\n        }\n        break;\n        case CreateScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int type = *((int*)bytes);\n\n            [windowController createScrollbarWithIdentifier:ident type:type];\n        }\n        break;\n        case DestroyScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);\n\n            [windowController destroyScrollbarWithIdentifier:ident];\n        }\n        break;\n        case ShowScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int visible = *((int*)bytes);\n\n            [windowController showScrollbarWithIdentifier:ident state:visible];\n        }\n        break;\n        case SetScrollbarPositionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int pos = *((int*)bytes);  bytes += sizeof(int);\n            int len = *((int*)bytes);\n\n            [windowController setScrollbarPosition:pos length:len\n                                        identifier:ident];\n        }\n        break;\n        case SetScrollbarThumbMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            float val = *((float*)bytes);  bytes += sizeof(float);\n            float prop = *((float*)bytes);\n\n            [windowController setScrollbarThumbValue:val proportion:prop\n                                          identifier:ident];\n        }\n        break;\n        case SetFontMsgID:\n        {\n            const void *bytes = [data bytes];\n            float size = *((float*)bytes);  bytes += sizeof(float);\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            NSString *name = [[NSString alloc]\n                    initWithBytes:(void*)bytes length:len\n                         encoding:NSUTF8StringEncoding];\n            NSFont *font = [NSFont fontWithName:name size:size];\n            if (!font) {\n                // This should only happen if the system default font has changed\n                // name since MacVim was compiled in which case we fall back on\n                // using the user fixed width font.\n                ASLogInfo(@\"Failed to load font '%@' / %f\", name, size);\n                font = [NSFont userFixedPitchFontOfSize:size];\n            }\n\n            [windowController setFont:font];\n            [name release];\n        }\n        break;\n        case SetWideFontMsgID:\n        {\n            const void *bytes = [data bytes];\n            float size = *((float*)bytes);  bytes += sizeof(float);\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            if (len > 0) {\n                NSString *name = [[NSString alloc]\n                        initWithBytes:(void*)bytes length:len\n                             encoding:NSUTF8StringEncoding];\n                NSFont *font = [NSFont fontWithName:name size:size];\n                [windowController setWideFont:font];\n\n                [name release];\n            } else {\n                [windowController setWideFont:nil];\n            }\n        }\n        break;\n        case SetDefaultColorsMsgID:\n        {\n            const void *bytes = [data bytes];\n            unsigned bg = *((unsigned*)bytes);  bytes += sizeof(unsigned);\n            unsigned fg = *((unsigned*)bytes);\n            NSColor *back = [NSColor colorWithArgbInt:bg];\n            NSColor *fore = [NSColor colorWithRgbInt:fg];\n\n            [windowController setDefaultColorsBackground:back foreground:fore];\n        }\n        break;\n        case ExecuteActionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            NSString *actionName = [[NSString alloc]\n                    initWithBytes:(void*)bytes length:len\n                         encoding:NSUTF8StringEncoding];\n\n            SEL sel = NSSelectorFromString(actionName);\n            [NSApp sendAction:sel to:nil from:self];\n\n            [actionName release];\n        }\n        break;\n        case ShowPopupMenuMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n\n            // The popup menu enters a modal loop so delay this call so that we\n            // don't block inside processInputQueue:.\n            [self performSelector:@selector(popupMenuWithAttributes:)\n                       withObject:attrs\n                       afterDelay:0];\n        }\n        break;\n        case SetMouseShapeMsgID:\n        {\n            const void *bytes = [data bytes];\n            int shape = *((int*)bytes);\n\n            [windowController setMouseShape:shape];\n        }\n        break;\n        case AdjustLinespaceMsgID:\n        {\n            const void *bytes = [data bytes];\n            int linespace = *((int*)bytes);\n\n            [windowController adjustLinespace:linespace];\n        }\n        break;\n        case AdjustColumnspaceMsgID:\n        {\n            const void *bytes = [data bytes];\n            int columnspace = *((int*)bytes);\n\n            [windowController adjustColumnspace:columnspace];\n        }\n        break;\n        case ActivateMsgID:\n        {\n            [NSApp activateIgnoringOtherApps:YES];\n            [[windowController window] makeKeyAndOrderFront:self];\n        }\n        break;\n        case SetServerNameMsgID:\n        {\n            NSString *name = [[NSString alloc] initWithData:data\n                                                   encoding:NSUTF8StringEncoding];\n            [self setServerName:name];\n            [name release];\n        }\n        break;\n        case EnterFullScreenMsgID:\n        {\n            const void *bytes = [data bytes];\n            int fuoptions = *((int*)bytes); bytes += sizeof(int);\n            int bg = *((int*)bytes);\n            NSColor *back = [NSColor colorWithArgbInt:bg];\n\n            [windowController enterFullScreen:fuoptions backgroundColor:back];\n        }\n        break;\n        case LeaveFullScreenMsgID:\n        {\n            [windowController leaveFullScreen];\n        }\n        break;\n        case SetBuffersModifiedMsgID:\n        {\n            const void *bytes = [data bytes];\n            // state < 0  <->  some buffer modified\n            // state > 0  <->  current buffer modified\n            int state = *((int*)bytes);\n\n            // NOTE: The window controller tracks whether current buffer is\n            // modified or not (and greys out the proxy icon as well as putting a\n            // dot in the red \"close button\" if necessary).  The Vim controller\n            // tracks whether any buffer has been modified (used to decide whether\n            // to show a warning or not when quitting).\n            //\n            // TODO: Make 'hasModifiedBuffer' part of the Vim state?\n            [windowController setBufferModified:(state > 0)];\n            hasModifiedBuffer = (state != 0);\n        }\n        break;\n        case SetPreEditPositionMsgID:\n        {\n            const int *dim = (const int*)[data bytes];\n            [[[windowController vimView] textView] setPreEditRow:dim[0]\n                                                          column:dim[1]];\n        }\n        break;\n        case EnableAntialiasMsgID:\n        {\n            [[[windowController vimView] textView] setAntialias:YES];\n        }\n        break;\n        case DisableAntialiasMsgID:\n        {\n            [[[windowController vimView] textView] setAntialias:NO];\n        }\n        break;\n        case EnableLigaturesMsgID:\n        {\n            [[[windowController vimView] textView] setLigatures:YES];\n        }\n        break;\n        case DisableLigaturesMsgID:\n        {\n            [[[windowController vimView] textView] setLigatures:NO];\n        }\n        break;\n        case EnableThinStrokesMsgID:\n        {\n            [[[windowController vimView] textView] setThinStrokes:YES];\n        }\n        break;\n        case DisableThinStrokesMsgID:\n        {\n            [[[windowController vimView] textView] setThinStrokes:NO];\n        }\n        break;\n        case SetVimStateMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict) {\n                [vimState release];\n                vimState = [dict retain];\n            }\n        }\n        break;\n        case CloseWindowMsgID:\n        {\n            [self scheduleClose];\n        }\n        break;\n        case SetFullScreenColorMsgID:\n        {\n            const int *bg = (const int*)[data bytes];\n            NSColor *color = [NSColor colorWithRgbInt:*bg];\n\n            [windowController setFullScreenBackgroundColor:color];\n        }\n        break;\n        case ShowFindReplaceDialogMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict) {\n                [[MMFindReplaceController sharedInstance]\n                    showWithText:[dict objectForKey:@\"text\"]\n                           flags:[[dict objectForKey:@\"flags\"] intValue]];\n            }\n        }\n        break;\n        case ActivateKeyScriptMsgID:\n        {\n            [[[windowController vimView] textView] activateIm:YES];\n        }\n        break;\n        case DeactivateKeyScriptMsgID:\n        {\n            [[[windowController vimView] textView] activateIm:NO];\n        }\n        break;\n        case EnableImControlMsgID:\n        {\n            [[[windowController vimView] textView] setImControl:YES];\n        }\n        break;\n        case DisableImControlMsgID:\n        {\n            [[[windowController vimView] textView] setImControl:NO];\n        }\n        break;\n        case BrowseForFileMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict)\n                [self handleBrowseForFile:dict];\n        }\n        break;\n        case ShowDialogMsgID:\n        {\n            [windowController runAfterWindowPresentedUsingBlock:^{\n                NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n                if (dict)\n                    [self handleShowDialog:dict];\n            }];\n        }\n        break;\n        case DeleteSignMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict)\n                [self handleDeleteSign:dict];\n        }\n        break;\n        case ZoomMsgID:\n        {\n            const void *bytes = [data bytes];\n            int rows = *((int*)bytes);  bytes += sizeof(int);\n            int cols = *((int*)bytes);  bytes += sizeof(int);\n            int state = *((int*)bytes);\n\n            [windowController zoomWithRows:rows\n                                   columns:cols\n                                     state:state];\n        }\n        break;\n        case SetWindowPositionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int x = *((int*)bytes);  bytes += sizeof(int);\n            int y = *((int*)bytes);\n\n            // NOTE: Vim measures Y-coordinates from top of screen.\n            NSRect frame = [[[windowController window] screen] frame];\n            y = NSMaxY(frame) - y;\n\n            [windowController setTopLeft:NSMakePoint(x,y)];\n        }\n        break;\n        case SetTooltipMsgID:\n        {\n            id textView = [[windowController vimView] textView];\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            NSString *toolTip = dict ? [dict objectForKey:@\"toolTip\"] : nil;\n            if (toolTip && [toolTip length] > 0)\n                [textView setToolTipAtMousePoint:toolTip];\n            else\n                [textView setToolTipAtMousePoint:nil];\n        }\n        break;\n        case AddToMRUMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            NSArray *filenames = dict ? [dict objectForKey:@\"filenames\"] : nil;\n            if (filenames)\n                [[NSDocumentController sharedDocumentController]\n                                                noteNewRecentFilePaths:filenames];\n        }\n        break;\n        case SetBackgroundOptionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int dark = *((int*)bytes);\n            [windowController setBackgroundOption:dark];\n        }\n        break;\n        case SetBlurRadiusMsgID:\n        {\n            const void *bytes = [data bytes];\n            int radius = *((int*)bytes);\n            [windowController setBlurRadius:radius];\n        }\n        break;\n\n        case ShowDefinitionMsgID:\n        {\n            const void* bytes = [data bytes];\n            int row = *((int*)bytes);  bytes += sizeof(int);\n            int col = *((int*)bytes);  bytes += sizeof(int);\n            NSUInteger len = *((NSUInteger*)bytes);  bytes += sizeof(NSUInteger);\n            if (len > 0) {\n                NSString *text = [[[NSString alloc] initWithBytes:(void*)bytes\n                                                           length:len\n                                                         encoding:NSUTF8StringEncoding] autorelease];\n\n                // Convert from 1-indexed (Vim-style) to 0-indexed.\n                row -= 1;\n                col -= 1;\n\n                MMTextView *view = [[windowController vimView] textView];\n                [view showDefinitionForCustomString:text row:row col:col];\n            }\n        }\n        break;\n\n        // IMPORTANT: When adding a new message, make sure to update\n        // isUnsafeMessage() if necessary!\n        default:\n        {\n            ASLogWarn(@\"Unknown message received (msgid=%d)\", msgid);\n        }\n    }\n}\n\n- (void)savePanelDidEnd:(NSSavePanel *)panel code:(int)code\n                context:(void *)context\n{\n    NSString *path = nil;\n#if (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10)\n    if (code == NSModalResponseOK)\n#else\n    if (code == NSOKButton)\n#endif\n    {\n        NSURL *url = [panel URL];\n        if ([url isFileURL])\n            path = [url path];\n    }\n    ASLogDebug(@\"Open/save panel path=%@\", path);\n\n    // NOTE!  This causes the sheet animation to run its course BEFORE the rest\n    // of this function is executed.  If we do not wait for the sheet to\n    // disappear before continuing it can happen that the controller is\n    // released from under us (i.e. we'll crash and burn) because this\n    // animation is otherwise performed in the default run loop mode!\n    [panel orderOut:self];\n\n    // NOTE! setDialogReturn: is a synchronous call so set a proper timeout to\n    // avoid waiting forever for it to finish.  We make this a synchronous call\n    // so that we can be fairly certain that Vim doesn't think the dialog box\n    // is still showing when MacVim has in fact already dismissed it.\n    NSConnection *conn = [backendProxy connectionForProxy];\n    NSTimeInterval oldTimeout = [conn requestTimeout];\n    [conn setRequestTimeout:MMSetDialogReturnTimeout];\n\n    @try {\n        [backendProxy setDialogReturn:path];\n\n        // Add file to the \"Recent Files\" menu (this ensures that files that\n        // are opened/saved from a :browse command are added to this menu).\n        if (path)\n            [[NSDocumentController sharedDocumentController]\n                                                noteNewRecentFilePath:path];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"Exception: pid=%d id=%d reason=%@\", pid, identifier, ex);\n    }\n    @finally {\n        [conn setRequestTimeout:oldTimeout];\n    }\n}\n\n- (void)alertDidEnd:(MMAlert *)alert code:(int)code context:(void *)context\n{\n    NSArray *ret = nil;\n\n    code = code - NSAlertFirstButtonReturn + 1;\n\n    if ([alert isKindOfClass:[MMAlert class]] && [alert textField]) {\n        ret = [NSArray arrayWithObjects:[NSNumber numberWithInt:code],\n            [[alert textField] stringValue], nil];\n    } else {\n        ret = [NSArray arrayWithObject:[NSNumber numberWithInt:code]];\n    }\n\n    ASLogDebug(@\"Alert return=%@\", ret);\n\n    // NOTE!  This causes the sheet animation to run its course BEFORE the rest\n    // of this function is executed.  If we do not wait for the sheet to\n    // disappear before continuing it can happen that the controller is\n    // released from under us (i.e. we'll crash and burn) because this\n    // animation is otherwise performed in the default run loop mode!\n    [[alert window] orderOut:self];\n\n    @try {\n        [backendProxy setDialogReturn:ret];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"setDialogReturn: failed: pid=%d id=%d reason=%@\",\n                pid, identifier, ex);\n    }\n}\n\n+ (bool) hasPopupPrefix: (NSString *) menuName\n{\n    return [menuName hasPrefix:MMPopUpMenuPrefix] || [menuName hasPrefix:MMUserPopUpMenuPrefix];\n}\n\n- (NSMenuItem *)menuItemForDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return nil;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    bool popup = [MMVimController hasPopupPrefix:rootName];\n    NSArray *rootItems =  popup ? popupMenuItems\n                                : [mainMenu itemArray];\n\n    NSMenuItem *item = nil;\n    int i, count = [rootItems count];\n    for (i = 0; i < count; ++i) {\n        item = [rootItems objectAtIndex:i];\n        if ([[item title] isEqual:rootName])\n            break;\n    }\n\n    if (i == count) return nil;\n\n    count = [desc count];\n    for (i = 1; i < count; ++i) {\n        item = [[item submenu] itemWithTitle:[desc objectAtIndex:i]];\n        if (!item) return nil;\n    }\n\n    return item;\n}\n\n- (NSMenu *)parentMenuForDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return nil;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    bool popup = [MMVimController hasPopupPrefix:rootName];\n    NSArray *rootItems = popup ? popupMenuItems\n                               : [mainMenu itemArray];\n\n    NSMenu *menu = nil;\n    int i, count = [rootItems count];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [rootItems objectAtIndex:i];\n        if ([[item title] isEqual:rootName]) {\n            menu = [item submenu];\n            break;\n        }\n    }\n\n    if (!menu) return nil;\n\n    count = [desc count] - 1;\n    for (i = 1; i < count; ++i) {\n        NSMenuItem *item = [menu itemWithTitle:[desc objectAtIndex:i]];\n        menu = [item submenu];\n        if (!menu) return nil;\n    }\n\n    return menu;\n}\n\n- (NSMenu *)topLevelMenuForTitle:(NSString *)title\n{\n    // Search only the top-level menus.\n\n    unsigned i, count = [popupMenuItems count];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [popupMenuItems objectAtIndex:i];\n        if ([title isEqual:[item title]])\n            return [item submenu];\n    }\n\n    count = [mainMenu numberOfItems];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [mainMenu itemAtIndex:i];\n        if ([title isEqual:[item title]])\n            return [item submenu];\n    }\n\n    return nil;\n}\n\n- (void)addMenuWithDescriptor:(NSArray *)desc atIndex:(int)idx\n{\n    if (!(desc && [desc count] > 0 && idx >= 0)) return;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        // The toolbar only has one menu, we take this as a hint to create a\n        // toolbar, then we return.\n        if (!toolbar) {\n            // NOTE! Each toolbar must have a unique identifier, else each\n            // window will have the same toolbar.\n            NSString *ident = [NSString stringWithFormat:@\"%d\", identifier];\n            toolbar = [[NSToolbar alloc] initWithIdentifier:ident];\n\n            [toolbar setShowsBaselineSeparator:NO];\n            [toolbar setDelegate:self];\n            [toolbar setDisplayMode:NSToolbarDisplayModeIconOnly];\n            [toolbar setSizeMode:NSToolbarSizeModeSmall];\n\n            [windowController setToolbar:toolbar];\n        }\n\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            if ([desc count] < 2) // Cannot be 1, as we need at least TouchBar.<menu_name>\n                return;\n            if ([desc count] >= 3) // Unfortunately currently Apple does not support nested popover's so we can only do one level nesting\n                return;\n\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n            // Icon is not supported for Touch Bar submenu for now, as \"amenu\" does not have a way of specifying \"icon=<icon_path>\" for submenus.\n            NSString *title = [desc lastObject];\n            [self addTouchbarItemWithLabel:title icon:nil tip:nil atIndex:idx isSubMenu:YES desc:desc atTouchBar:submenuTouchbar];\n        }\n#endif\n        return;\n    }\n\n    if ([rootName isEqual:MMWinBarMenuName]) {\n        // WinBar menus are completed handled within Vim windows. No need for GUI to do anything.\n        return;\n    }\n\n    // This is either a main menu item or a popup menu item.\n    NSString *title = [desc lastObject];\n    NSMenuItem *item = [[NSMenuItem alloc] init];\n    NSMenu *menu = [[NSMenu alloc] initWithTitle:title];\n\n    [item setTitle:title];\n    [item setSubmenu:menu];\n\n    NSMenu *parent = [self parentMenuForDescriptor:desc];\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!parent && isPopup) {\n        if ([popupMenuItems count] <= idx) {\n            [popupMenuItems addObject:item];\n        } else {\n            [popupMenuItems insertObject:item atIndex:idx];\n        }\n    } else {\n        // If descriptor has no parent and its not a popup (or toolbar) menu,\n        // then it must belong to main menu.\n        if (!parent) {\n            parent = mainMenu;\n            idx += 1; // Main menu already has the application menu as the first item, so everything else must be shifted by one.\n        }\n\n        if ([parent numberOfItems] <= idx) {\n            [parent addItem:item];\n        } else {\n            [parent insertItem:item atIndex:idx];\n        }\n    }\n\n    [item release];\n    [menu release];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)addMenuItemWithDescriptor:(NSArray *)desc\n                          atIndex:(int)idx\n                              tip:(NSString *)tip\n                             icon:(NSString *)icon\n                    keyEquivalent:(NSString *)keyEquivalent\n                     modifierMask:(int)modifierMask\n                           action:(NSString *)action\n                      isAlternate:(BOOL)isAlternate\n{\n    if (!(desc && [desc count] > 1 && idx >= 0)) return;\n\n    NSString *title = [desc lastObject];\n    NSString *rootName = [desc objectAtIndex:0];\n\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2)\n            [self addToolbarItemWithLabel:title tip:tip icon:icon atIndex:idx];\n        return;\n    }\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if ([desc count] >= 4) // Unfortunately currently Apple does not support nested popover's so we can only do one level nesting\n            return;\n\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n\n            [self addTouchbarItemWithLabel:title icon:icon tip:tip atIndex:idx isSubMenu:NO desc:desc atTouchBar:submenuTouchbar];\n        }\n#endif\n        return;\n    }\n    if ([rootName isEqual:MMWinBarMenuName]) {\n        // WinBar menus are completed handled within Vim windows. No need for GUI to do anything.\n        return;\n    }\n\n    NSMenu *parent = [self parentMenuForDescriptor:desc];\n    if (!parent) {\n        ASLogWarn(@\"Menu item '%@' has no parent\",\n                  [desc componentsJoinedByString:@\"->\"]);\n        return;\n    }\n\n    NSMenuItem *item = nil;\n    if (0 == [title length]\n            || ([title hasPrefix:@\"-\"] && [title hasSuffix:@\"-\"])) {\n        item = [NSMenuItem separatorItem];\n        [item setTitle:title];\n    } else {\n        item = [[[NSMenuItem alloc] init] autorelease];\n        [item setTitle:title];\n\n        // Note: It is possible to set the action to a message that \"doesn't\n        // exist\" without problems.  We take advantage of this when adding\n        // \"dummy items\" e.g. when dealing with the \"Recent Files\" menu (in\n        // which case a recentFilesDummy: action is set, although it is never\n        // used).\n        if ([action length] > 0)\n            [item setAction:NSSelectorFromString(action)];\n        else\n            [item setAction:@selector(vimMenuItemAction:)];\n        if ([tip length] > 0) [item setToolTip:tip];\n        if ([keyEquivalent length] > 0) {\n            [item setKeyEquivalent:keyEquivalent];\n            [item setKeyEquivalentModifierMask:modifierMask];\n        }\n        [item setAlternate:isAlternate];\n\n        NSImage *img = [self findToolbarIcon:icon];\n        if (img) {\n            [item setImage: img];\n        }\n\n        // The tag is used to indicate whether Vim thinks a menu item should be\n        // enabled or disabled.  By default Vim thinks menu items are enabled.\n        [item setTag:1];\n    }\n\n    if ([parent numberOfItems] <= idx) {\n        [parent addItem:item];\n    } else {\n        [parent insertItem:item atIndex:idx];\n    }\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)removeMenuItemWithDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return;\n\n    NSString *title = [desc lastObject];\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar) {\n            // Only remove toolbar items, never actually remove the toolbar\n            // itself or strange things may happen.\n            if ([desc count] == 2) {\n                NSUInteger idx = [toolbar indexOfItemWithItemIdentifier:title];\n                if (idx != NSNotFound)\n                    [toolbar removeItemAtIndex:idx];\n            }\n        }\n        return;\n    }\n    if ([rootName isEqual:MMTouchbarMenuName]){\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n\n            [[submenuTouchbar itemOrder] removeObject:title];\n            [[submenuTouchbar itemDict] removeObjectForKey:title];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n    NSMenuItem *item = [self menuItemForDescriptor:desc];\n    if (!item) {\n        ASLogWarn(@\"Failed to remove menu item, descriptor not found: %@\",\n                  [desc componentsJoinedByString:@\"->\"]);\n        return;\n    }\n\n    [item retain];\n\n    if ([item menu] == [NSApp mainMenu] || ![item menu]) {\n        // NOTE: To be on the safe side we try to remove the item from\n        // both arrays (it is ok to call removeObject: even if an array\n        // does not contain the object to remove).\n        [popupMenuItems removeObject:item];\n    }\n\n    if ([item menu])\n        [[item menu] removeItem:item];\n\n    [item release];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)enableMenuItemWithDescriptor:(NSArray *)desc state:(BOOL)on\n{\n    if (!(desc && [desc count] > 0)) return;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2) {\n            NSString *title = [desc lastObject];\n            [[toolbar itemWithItemIdentifier:title] setEnabled:on];\n        }\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarItemInfo *touchbarItem = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:nil touchBarItem:&touchbarItem]) {\n                return;\n            }\n            [touchbarItem setEnabled:on];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n\n    // We are using auto-enabling of menu items, where instead of directly\n    // calling setEnabled:, we rely on validateMenuItem: callbacks in each\n    // target to handle whether they want each menu item to be enabled or not.\n    // This allows us to more easily control the enabled states of OS-injected\n    // menu items if we want to. To remember whether we want to enable/disable\n    // a Vim menu, we use item.tag to remember it. See each validateMenuItem:\n    // implementation for details.\n    //\n    // See https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MenuList/Articles/EnablingMenuItems.html\n    [[self menuItemForDescriptor:desc] setTag:on];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n    \n- (void)updateMenuItemTooltipWithDescriptor:(NSArray *)desc\n                                        tip:(NSString *)tip\n{\n    if (!(desc && [desc count] > 0)) return;\n    \n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2) {\n            NSString *title = [desc lastObject];\n            [[toolbar itemWithItemIdentifier:title] setToolTip:tip];\n        }\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarItemInfo *touchbarItem = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:nil touchBarItem:&touchbarItem]) {\n                return;\n            }\n            NSString *title = [desc lastObject];\n            [self updateTouchbarItemLabel:title tip:tip atTouchBarItem:touchbarItem];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n\n    [[self menuItemForDescriptor:desc] setToolTip:tip];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n/// Load an icon image for the provided name. This will try multiple things to find the best image that fits the name.\n/// @param icon Can be an SF Symbol name (with colon-separated formatting strings), named system image, or just a file.\n- (NSImage*)findToolbarIcon:(NSString*)icon\n{\n    if ([icon length] == 0) {\n        return nil;\n    }\n    NSImage *img = nil;\n\n    // Detect whether this is explicitly specified to be a template image, via a \":template\" configuration suffix.\n    BOOL template = NO;\n    if ([icon hasSuffix:@\":template\"]) {\n        icon = [icon substringToIndex:([icon length] - 9)];\n        template = YES;\n    }\n\n    // Attempt 1: Load an SF Symbol image. This is first try because it's what Apple is pushing for and also likely\n    //            what our users are going to want to use. We also allows for customization of the symbol.\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0\n    if (@available(macos 11.0, *)) {\n        // All SF Symbol functionality were introduced in macOS 11.0.\n        NSString *sfSymbolName = icon;\n\n        BOOL monochrome = NO, hierarchical = NO, palette = NO, multicolor = NO;\n        double variableValue = -1;\n\n        if ([sfSymbolName rangeOfString:@\":\"].location != NSNotFound) {\n            // We support using colon-separated strings to customize the symbol. First item is the icon name itself.\n            NSArray<NSString*> *splitComponents = [sfSymbolName componentsSeparatedByString:@\":\"];\n            sfSymbolName = splitComponents[0];\n\n            for (int i = 1, count = splitComponents.count; i < count; i++) {\n                NSString *component = splitComponents[i];\n                if ([component isEqualToString:@\"monochrome\"]) {\n                    monochrome = YES;\n                } else if ([component isEqualToString:@\"hierarchical\"]) {\n                    hierarchical = YES;\n                } else if ([component isEqualToString:@\"palette\"]) {\n                    palette = YES;\n                } else if ([component isEqualToString:@\"multicolor\"]) {\n                    multicolor = YES;\n                } else if ([component hasPrefix:@\"variable-\"]) {\n                    NSString *variableString = [component substringFromIndex:9];\n                    variableValue = [variableString floatValue];\n                }\n            }\n        }\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n        if (@available(macos 13.0, *)) {\n            if (variableValue >= 0.0 && variableValue <= 1.0) {\n                img = [NSImage imageWithSystemSymbolName:sfSymbolName variableValue:variableValue accessibilityDescription:nil];\n            }\n        }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n\n        if (img == nil) {\n            img = [NSImage imageWithSystemSymbolName:sfSymbolName accessibilityDescription:nil];\n        }\n\n        // Apply style customization to the symbol. This feature was added in macOS 12.\n        if (img) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_12_0\n            if (@available(macos 12.0, *)) {\n                NSImageSymbolConfiguration *config = nil;\n                if (monochrome) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n                    if (@available(macos 13.0, *)) {\n                        config = [NSImageSymbolConfiguration configurationPreferringMonochrome];\n                    }\n#endif\n                }\n                if (hierarchical) {\n                    NSImageSymbolConfiguration *config2;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n                    if (@available(macos 13.0, *))\n                    {\n                        // This version is preferred as it seems to set the color up automatically and therefore will use the correct ones.\n                        config2 = [NSImageSymbolConfiguration configurationPreferringHierarchical];\n                    }\n                    else\n#endif\n                    {\n                        // Just guess which color to use. AppKit doesn't really give you a color that you can pick so we just guess one.\n                        config2 = [NSImageSymbolConfiguration configurationWithHierarchicalColor:NSColor.controlTextColor];\n                    }\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n                if (palette) {\n                    // The palette colors aren't completely correct. It doesn't appear for there to be a good way to query the primary colors\n                    // for Touch Bar, tool bar, etc, so we just use controlTextColor. It would be nice if Apple just provides a \"Preferring\"\n                    // version of this API like the other ones.\n                    NSImageSymbolConfiguration *config2 = [NSImageSymbolConfiguration configurationWithPaletteColors:@[NSColor.controlTextColor, NSColor.controlAccentColor]];\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n                if (multicolor) {\n                    NSImageSymbolConfiguration *config2 = [NSImageSymbolConfiguration configurationPreferringMulticolor];\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n\n                if (config) {\n                    NSImage *img2 = [img imageWithSymbolConfiguration:config];\n                    if (img2) {\n                        img = img2;\n                    }\n                }\n            }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_12_0\n\n            // Just mark them as used so compiling on older SDKs won't complain about unused variables.\n            (void)multicolor;\n            (void)hierarchical;\n            (void)palette;\n            (void)variableValue;\n        }\n    }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0\n\n    // Attempt 2: Load a named image.\n    if (!img) {\n        img = [NSImage imageNamed:icon];\n    }\n\n    // Attempt 3: Load from a file.\n    if (!img) {\n        img = [[[NSImage alloc] initByReferencingFile:icon] autorelease];\n        if (!(img && [img isValid]))\n            img = nil;\n    }\n\n    if (img && template) {\n        [img setTemplate:YES];\n    }\n    return img;\n}\n\n- (void)addToolbarItemToDictionaryWithLabel:(NSString *)title\n                                    toolTip:(NSString *)tip\n                                       icon:(NSString *)icon\n{\n    // If the item corresponds to a separator then do nothing, since it is\n    // already defined by Cocoa.\n    if (!title || [title isEqual:NSToolbarSeparatorItemIdentifier]\n               || [title isEqual:NSToolbarSpaceItemIdentifier]\n               || [title isEqual:NSToolbarFlexibleSpaceItemIdentifier])\n        return;\n\n    NSToolbarItem *item = [[NSToolbarItem alloc] initWithItemIdentifier:title];\n    [item setLabel:title];\n    [item setToolTip:tip];\n    [item setAction:@selector(vimToolbarItemAction:)];\n    [item setAutovalidates:NO];\n\n    NSImage *img = [self findToolbarIcon:icon];\n    if (!img) {\n        ASLogNotice(@\"Could not find image with name '%@' to use as toolbar\"\n            \" image for identifier '%@';\"\n            \" using default toolbar icon '%@' instead.\",\n            icon, title, MMDefaultToolbarImageName);\n\n        img = [NSImage imageNamed:MMDefaultToolbarImageName];\n    }\n\n    [item setImage:img];\n\n    [toolbarItemDict setObject:item forKey:title];\n\n    [item release];\n}\n\n- (void)addToolbarItemWithLabel:(NSString *)label\n                            tip:(NSString *)tip\n                           icon:(NSString *)icon\n                        atIndex:(int)idx\n{\n    if (!toolbar) return;\n\n    // Check for separator items.\n    if (!label) {\n        label = NSToolbarSeparatorItemIdentifier;\n    } else if ([label length] >= 2 && [label hasPrefix:@\"-\"]\n                                   && [label hasSuffix:@\"-\"]) {\n        // The label begins and ends with '-'; decided which kind of separator\n        // item it is by looking at the prefix.\n        if ([label hasPrefix:@\"-space\"]) {\n            label = NSToolbarSpaceItemIdentifier;\n        } else if ([label hasPrefix:@\"-flexspace\"]) {\n            label = NSToolbarFlexibleSpaceItemIdentifier;\n        } else {\n            label = NSToolbarSeparatorItemIdentifier;\n        }\n    }\n\n    [self addToolbarItemToDictionaryWithLabel:label toolTip:tip icon:icon];\n\n    int maxIdx = [[toolbar items] count];\n    if (maxIdx < idx) idx = maxIdx;\n\n    [toolbar insertItemWithItemIdentifier:label atIndex:idx];\n}\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (void)addTouchbarItemWithLabel:(NSString *)label\n                            icon:(NSString *)icon\n                             tip:(NSString *)tip\n                         atIndex:(int)idx\n                       isSubMenu:(BOOL)submenu\n                            desc:(NSArray *)desc\n                      atTouchBar:(MMTouchBarInfo *)touchbarInfo\n{\n    NSString *touchbarLabel = label;\n    NSTouchBarItem *touchbarItem = nil;\n\n    // Check for separator / special items first\n    if ([label length] >= 2 && [label hasPrefix:@\"-\"]\n                            && [label hasSuffix:@\"-\"]) {\n        // The label begins and ends with '-'; decided which kind of separator\n        // or special item it is by looking at the prefix.\n        if ([label hasPrefix:@\"-characterpicker\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierCharacterPicker;\n        }\n        else if ([label hasPrefix:@\"-space\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierFixedSpaceSmall;\n        } else if ([label hasPrefix:@\"-flexspace\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierFlexibleSpace;\n        } else {\n            touchbarLabel = NSTouchBarItemIdentifierFixedSpaceLarge;\n        }\n    } else if (submenu) {\n        NSPopoverTouchBarItem *item = [[[NSPopoverTouchBarItem alloc] initWithIdentifier:label] autorelease];\n        // Icons not supported for now until we find a way to send the information in from Vim\n        [item setCollapsedRepresentationLabel:label];\n        touchbarItem = item;\n    } else {\n        BOOL useTip = tip && [tip length] != 0;\n        NSString *buttonTitle = useTip ? tip : label;\n        MMTouchBarButton* button = [MMTouchBarButton buttonWithTitle:buttonTitle target:windowController action:@selector(vimTouchbarItemAction:)];\n        [button setDesc:desc];\n        NSCustomTouchBarItem *item =\n            [[[NSCustomTouchBarItem alloc] initWithIdentifier:label] autorelease];\n\n        NSImage *img = [self findToolbarIcon:icon];;\n        if (img) {\n            [button setImage: img];\n            if (useTip) {\n                // If the user has set a tooltip as label that means they always want to see it, so show both image and tooltip\n                [button setImagePosition:NSImageLeft];\n            } else {\n                [button setImagePosition:NSImageOnly];\n            }\n        }\n\n        [item setView:button];\n        touchbarItem = item;\n    }\n    \n    MMTouchBarItemInfo *touchbarItemInfo = [[[MMTouchBarItemInfo alloc] initWithItem:touchbarItem label:touchbarLabel] autorelease];\n    if (submenu) {\n        [touchbarItemInfo makeChildTouchBar];\n    }\n    [touchbarInfo.itemDict setObject:touchbarItemInfo forKey:label];\n\n    int maxIdx = [touchbarInfo.itemOrder count];\n    if (maxIdx < idx) idx = maxIdx;\n    [touchbarInfo.itemOrder insertObject:label atIndex:idx];\n\n    [windowController setTouchBar:nil];\n}\n\n- (void)updateTouchbarItemLabel:(NSString *)label\n                            tip:(NSString *)tip\n                 atTouchBarItem:(MMTouchBarItemInfo*)item\n{\n    // The logic here should match that in addTouchbarItemWithLabel: as otherwise we will\n    // get weird results when adding/removing tooltips.\n    BOOL useTip = tip && [tip length] != 0;\n    NSString *buttonTitle = useTip ? tip : label;\n    NSCustomTouchBarItem *touchbarItem = (NSCustomTouchBarItem*)item.touchbarItem;\n    MMTouchBarButton *button = (MMTouchBarButton*)touchbarItem.view;\n    [button setTitle:buttonTitle];\n    if (button.image) {\n        if (useTip) {\n            [button setImagePosition:NSImageLeft];\n        } else {\n            [button setImagePosition:NSImageOnly];\n        }\n    } else {\n        [button setImagePosition:NSNoImage];\n    }\n}\n\n- (BOOL)touchBarItemForDescriptor:(NSArray *)desc\n                         touchBar:(MMTouchBarInfo **)touchBarPtr\n                     touchBarItem:(MMTouchBarItemInfo **)touchBarItemPtr\n{\n    MMTouchBarInfo *submenuTouchbar = touchbarInfo;\n    for (int i = 1; i < [desc count] - 1; i++) {\n        NSString *submenuName = [desc objectAtIndex:i];\n        MMTouchBarItemInfo *submenu = [[submenuTouchbar itemDict] objectForKey:submenuName];\n        if ([submenu childTouchbar]) {\n            submenuTouchbar = [submenu childTouchbar];\n        } else {\n            ASLogWarn(@\"No Touch Bar submenu with id '%@'\", submenuName);\n            return NO;\n        }\n    }\n    if (touchBarPtr)\n        *touchBarPtr = submenuTouchbar;\n    if (touchBarItemPtr)\n        *touchBarItemPtr = [[submenuTouchbar itemDict] objectForKey:[desc lastObject]];\n    return YES;\n}\n#endif\n- (void)popupMenuWithDescriptor:(NSArray *)desc\n                          atRow:(NSNumber *)row\n                         column:(NSNumber *)col\n{\n    NSMenu *menu = [[self menuItemForDescriptor:desc] submenu];\n    if (!menu) return;\n\n    id textView = [[windowController vimView] textView];\n    NSPoint pt;\n    if (row && col) {\n        // TODO: Let textView convert (row,col) to NSPoint.\n        int r = [row intValue];\n        int c = [col intValue];\n        NSSize cellSize = [textView cellSize];\n        pt = NSMakePoint((c+1)*cellSize.width, (r+1)*cellSize.height);\n        pt = [textView convertPoint:pt toView:nil];\n    } else {\n        pt = [[windowController window] mouseLocationOutsideOfEventStream];\n    }\n\n    NSEvent *event = [NSEvent mouseEventWithType:NSEventTypeRightMouseDown\n                           location:pt\n                      modifierFlags:0\n                          timestamp:0\n                       windowNumber:[[windowController window] windowNumber]\n                            context:nil\n                        eventNumber:0\n                         clickCount:0\n                           pressure:1.0];\n\n    [NSMenu popUpContextMenu:menu withEvent:event forView:textView];\n}\n\n- (void)popupMenuWithAttributes:(NSDictionary *)attrs\n{\n    if (!attrs) return;\n\n    [self popupMenuWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                            atRow:[attrs objectForKey:@\"row\"]\n                           column:[attrs objectForKey:@\"column\"]];\n}\n\n- (void)connectionDidDie:(NSNotification *)notification\n{\n    ASLogDebug(@\"%@\", notification);\n    [self scheduleClose];\n}\n\n- (void)scheduleClose\n{\n    ASLogDebug(@\"pid=%d id=%d\", pid, identifier);\n\n    // NOTE!  This message can arrive at pretty much anytime, e.g. while\n    // the run loop is the 'event tracking' mode.  This means that Cocoa may\n    // well be in the middle of processing some message while this message is\n    // received.  If we were to remove the vim controller straight away we may\n    // free objects that Cocoa is currently using (e.g. view objects).  The\n    // following call ensures that the vim controller is not released until the\n    // run loop is back in the 'default' mode.\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    [[MMAppController sharedInstance]\n            performSelectorOnMainThread:@selector(removeVimController:)\n                             withObject:self\n                          waitUntilDone:NO\n                                  modes:[NSArray arrayWithObject:\n                                         NSDefaultRunLoopMode]];\n}\n\n// NSSavePanel delegate\n- (void)panel:(id)sender willExpand:(BOOL)expanding\n{\n    // Show or hide the \"show hidden files\" button\n    if (expanding) {\n        [sender setAccessoryView:showHiddenFilesView()];\n    } else {\n        [sender setShowsHiddenFiles:NO];\n        [sender setAccessoryView:nil];\n    }\n}\n\n- (void)handleBrowseForFile:(NSDictionary *)attr\n{\n    if (!isInitialized) return;\n\n    NSString *dir = [attr objectForKey:@\"dir\"];\n    BOOL saving = [[attr objectForKey:@\"saving\"] boolValue];\n    BOOL browsedir = [[attr objectForKey:@\"browsedir\"] boolValue];\n\n    if (!dir) {\n        // 'dir == nil' means: set dir to the pwd of the Vim process, or let\n        // open dialog decide (depending on the below user default).\n        BOOL trackPwd = [[NSUserDefaults standardUserDefaults]\n                boolForKey:MMDialogsTrackPwdKey];\n        if (trackPwd)\n            dir = [vimState objectForKey:@\"pwd\"];\n    }\n\n    dir = [dir stringByExpandingTildeInPath];\n    NSURL *dirURL = dir ? [NSURL fileURLWithPath:dir isDirectory:YES] : nil;\n\n    if (saving) {\n        NSSavePanel *panel = [NSSavePanel savePanel];\n\n        // The delegate will be notified when the panel is expanded at which\n        // time we may hide/show the \"show hidden files\" button (this button is\n        // always visible for the open panel since it is always expanded).\n        [panel setDelegate:self];\n        if ([panel isExpanded])\n            [panel setAccessoryView:showHiddenFilesView()];\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n\n        [panel beginSheetModalForWindow:[windowController window]\n                      completionHandler:^(NSInteger result) {\n            [self savePanelDidEnd:panel code:result context:nil];\n        }];\n    } else {\n        NSOpenPanel *panel = [NSOpenPanel openPanel];\n        [panel setAllowsMultipleSelection:NO];\n        [panel setAccessoryView:showHiddenFilesView()];\n\n        if (browsedir) {\n            [panel setCanChooseDirectories:YES];\n            [panel setCanChooseFiles:NO];\n        }\n\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n\n        [panel beginSheetModalForWindow:[windowController window]\n                      completionHandler:^(NSInteger result) {\n            [self savePanelDidEnd:panel code:result context:nil];\n        }];\n    }\n}\n\n- (void)handleShowDialog:(NSDictionary *)attr\n{\n    if (!isInitialized) return;\n\n    NSArray *buttonTitles = [attr objectForKey:@\"buttonTitles\"];\n    if (!(buttonTitles && [buttonTitles count])) return;\n\n    int style = [[attr objectForKey:@\"alertStyle\"] intValue];\n    NSString *message = [attr objectForKey:@\"messageText\"];\n    NSString *text = [attr objectForKey:@\"informativeText\"];\n    NSString *textFieldString = [attr objectForKey:@\"textFieldString\"];\n    MMAlert *alert = [[MMAlert alloc] init];\n\n    // NOTE! This has to be done before setting the informative text.\n    if (textFieldString)\n        [alert setTextFieldString:textFieldString];\n\n    [alert setAlertStyle:style];\n\n    if (message) {\n        [alert setMessageText:message];\n    } else {\n        // If no message text is specified 'Alert' is used, which we don't\n        // want, so set an empty string as message text.\n        [alert setMessageText:@\"\"];\n    }\n\n    if (text) {\n        [alert setInformativeText:text];\n    } else if (textFieldString) {\n        // Make sure there is always room for the input text field.\n        [alert setInformativeText:@\"\"];\n    }\n\n    unsigned i, count = [buttonTitles count];\n    for (i = 0; i < count; ++i) {\n        NSString *title = [buttonTitles objectAtIndex:i];\n        // NOTE: The title of the button may contain the character '&' to\n        // indicate that the following letter should be the key equivalent\n        // associated with the button.  Extract this letter and lowercase it.\n        NSString *keyEquivalent = nil;\n        NSRange hotkeyRange = [title rangeOfString:@\"&\"];\n        if (NSNotFound != hotkeyRange.location) {\n            if ([title length] > NSMaxRange(hotkeyRange)) {\n                NSRange keyEquivRange = NSMakeRange(hotkeyRange.location+1, 1);\n                keyEquivalent = [[title substringWithRange:keyEquivRange]\n                    lowercaseString];\n            }\n\n            NSMutableString *string = [NSMutableString stringWithString:title];\n            [string deleteCharactersInRange:hotkeyRange];\n            title = string;\n        }\n\n        [alert addButtonWithTitle:title];\n\n        // Set key equivalent for the button, but only if NSAlert hasn't\n        // already done so.  (Check the documentation for\n        // - [NSAlert addButtonWithTitle:] to see what key equivalents are\n        // automatically assigned.)\n        NSButton *btn = [[alert buttons] lastObject];\n        if ([[btn keyEquivalent] length] == 0 && keyEquivalent) {\n            [btn setKeyEquivalent:keyEquivalent];\n        }\n    }\n\n    [alert beginSheetModalForWindow:[windowController window]\n                      modalDelegate:self];\n\n    [alert release];\n}\n\n- (void)handleDeleteSign:(NSDictionary *)attr\n{\n    MMTextView *view = [[windowController vimView] textView];\n    [view deleteSign:[attr objectForKey:@\"imgName\"]];\n}\n\n- (void)setToolTipDelay\n{\n    // HACK! NSToolTipManager is an AppKit private class.\n    static Class TTM = nil;\n    if (!TTM)\n        TTM = NSClassFromString(@\"NSToolTipManager\");\n\n    if (TTM) {\n        [[TTM sharedToolTipManager] setInitialToolTipDelay:1e-6];\n    } else {\n        ASLogNotice(@\"Failed to get NSToolTipManager\");\n    }\n}\n\n@end // MMVimController (Private)\n\n\n\n\n@implementation MMAlert\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    [textField release];  textField = nil;\n    [super dealloc];\n}\n\n- (void)setTextFieldString:(NSString *)textFieldString\n{\n    [textField release];\n    textField = [[NSTextField alloc] init];\n    [textField setStringValue:textFieldString];\n}\n\n- (NSTextField *)textField\n{\n    return textField;\n}\n\n- (void)setInformativeText:(NSString *)text\n{\n    if (textField) {\n        // HACK! Add some space for the text field.\n        [super setInformativeText:[text stringByAppendingString:@\"\\n\\n\\n\"]];\n    } else {\n        [super setInformativeText:text];\n    }\n}\n\n- (void)beginSheetModalForWindow:(NSWindow *)window\n                   modalDelegate:(id)delegate\n{\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10\n    [super beginSheetModalForWindow:window\n                  completionHandler:^(NSModalResponse code) {\n                      [delegate alertDidEnd:self code:code context:NULL];\n                  }];\n#else\n    [super beginSheetModalForWindow:window\n                      modalDelegate:delegate\n                     didEndSelector:@selector(alertDidEnd:code:context:)\n                        contextInfo:NULL];\n#endif\n\n    // HACK! Place the input text field at the bottom of the informative text\n    // (which has been made a bit larger by adding newline characters).\n    NSView *contentView = [[self window] contentView];\n    NSRect rect = [contentView frame];\n    rect.origin.y = rect.size.height;\n\n    NSArray *subviews = [contentView subviews];\n    unsigned i, count = [subviews count];\n    for (i = 0; i < count; ++i) {\n        NSView *view = [subviews objectAtIndex:i];\n        if ([view isKindOfClass:[NSTextField class]]\n                && [view frame].origin.y < rect.origin.y) {\n            // NOTE: The informative text field is the lowest NSTextField in\n            // the alert dialog.\n            rect = [view frame];\n        }\n    }\n\n    rect.size.height = MMAlertTextFieldHeight;\n    [textField setFrame:rect];\n    [contentView addSubview:textField];\n    [textField becomeFirstResponder];\n}\n\n@end // MMAlert\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_12\n    \n@implementation MMTouchBarInfo\n    \n- (id)init\n{\n    if (!(self = [super init])) {\n        return nil;\n    }\n\n    _touchbar = [[NSTouchBar alloc] init];\n    \n    _itemDict = [[NSMutableDictionary alloc] init];\n    _itemOrder = [[NSMutableArray alloc] init];\n    return self;\n}\n    \n- (void)dealloc\n{\n    [_touchbar release];  _touchbar = nil;\n\n    [_itemDict release];  _itemDict = nil;\n    [_itemOrder release];  _itemOrder = nil;\n    [super dealloc];\n}\n    \n@end // MMTouchBarInfo\n\n@implementation MMTouchBarItemInfo\n\n- (void)dealloc\n{\n    [_touchbarItem release];  _touchbarItem = nil;\n    [_label release];  _label = nil;\n    [_childTouchbar release];  _childTouchbar = nil;\n    [super dealloc];\n}\n    \n- (id)initWithItem:(NSTouchBarItem *)item label:(NSString *)label\n{\n    _touchbarItem = [item retain];\n    _enabled = YES;\n    _label = [label retain];\n    return self;\n}\n    \n- (void)setTouchBarItem:(NSTouchBarItem *)item\n{\n    _touchbarItem = item;\n}\n    \n- (void)makeChildTouchBar\n{\n    _childTouchbar = [[MMTouchBarInfo alloc] init];\n}\n\n@end // MMTouchBarItemInfo\n    \n@implementation MMTouchBarButton\n    \n- (void)dealloc\n{\n    [_desc release];  _desc = nil;\n    [super dealloc];\n}\n    \n- (NSArray *)desc\n{\n    return _desc;\n}\n    \n- (void)setDesc:(NSArray *)desc\n{\n    _desc = [desc retain];\n}\n    \n@end // MMTouchBarButton\n    \n#endif\n\n\n    static BOOL\nisUnsafeMessage(int msgid)\n{\n    // Messages that may release Cocoa objects must be added to this list.  For\n    // example, UpdateTabBarMsgID may delete NSTabViewItem objects so it goes\n    // on this list.\n    static int unsafeMessages[] = { // REASON MESSAGE IS ON THIS LIST:\n        //OpenWindowMsgID,            // Changes lots of state\n        UpdateTabBarMsgID,          // May delete NSTabViewItem\n        RemoveMenuItemMsgID,        // Deletes NSMenuItem\n        DestroyScrollbarMsgID,      // Deletes NSScroller\n        ExecuteActionMsgID,         // Impossible to predict\n        ShowPopupMenuMsgID,         // Enters modal loop\n        ActivateMsgID,              // ?\n        EnterFullScreenMsgID,       // Modifies delegate of window controller\n        LeaveFullScreenMsgID,       // Modifies delegate of window controller\n        CloseWindowMsgID,           // See note below\n        BrowseForFileMsgID,         // Enters modal loop\n        ShowDialogMsgID,            // Enters modal loop\n    };\n\n    // NOTE about CloseWindowMsgID: If this arrives at the same time as say\n    // ExecuteActionMsgID, then the \"execute\" message will be lost due to it\n    // being queued and handled after the \"close\" message has caused the\n    // controller to cleanup...UNLESS we add CloseWindowMsgID to the list of\n    // unsafe messages.  This is the _only_ reason it is on this list (since\n    // all that happens in response to it is that we schedule another message\n    // for later handling).\n\n    int i, count = sizeof(unsafeMessages)/sizeof(unsafeMessages[0]);\n    for (i = 0; i < count; ++i)\n        if (msgid == unsafeMessages[i])\n            return YES;\n\n    return NO;\n}\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc fdm=syntax:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n// This file contains root-level commonly used definitions that both Vim and\n// MacVim processes need access to.\n\n#import <Cocoa/Cocoa.h>\n\n#pragma region Backward compatibility defines\n\n// Taken from /usr/include/AvailabilityMacros.h\n#ifndef MAC_OS_X_VERSION_10_7\n# define MAC_OS_X_VERSION_10_7 1070\n#endif\n#ifndef MAC_OS_X_VERSION_10_8\n# define MAC_OS_X_VERSION_10_8 1080\n#endif\n#ifndef MAC_OS_X_VERSION_10_9\n# define MAC_OS_X_VERSION_10_9 1090\n#endif\n#ifndef MAC_OS_X_VERSION_10_10\n# define MAC_OS_X_VERSION_10_10 101000\n#endif\n#ifndef MAC_OS_X_VERSION_10_11\n# define MAC_OS_X_VERSION_10_11 101100\n#endif\n#ifndef MAC_OS_X_VERSION_10_12\n# define MAC_OS_X_VERSION_10_12 101200\n#endif\n#ifndef MAC_OS_X_VERSION_10_12_2\n# define MAC_OS_X_VERSION_10_12_2 101202\n#endif\n#ifndef MAC_OS_X_VERSION_10_13\n# define MAC_OS_X_VERSION_10_13 101300\n#endif\n#ifndef MAC_OS_X_VERSION_10_14\n# define MAC_OS_X_VERSION_10_14 101400\n#endif\n#ifndef MAC_OS_VERSION_11_0\n# define MAC_OS_VERSION_11_0 110000\n#endif\n#ifndef MAC_OS_VERSION_12_0\n# define MAC_OS_VERSION_12_0 120000\n#endif\n#ifndef MAC_OS_VERSION_13_0\n# define MAC_OS_VERSION_13_0 130000\n#endif\n\n#ifndef NSAppKitVersionNumber10_10\n# define NSAppKitVersionNumber10_10 1343\n#endif\n#ifndef NSAppKitVersionNumber10_10_Max\n# define NSAppKitVersionNumber10_10_Max 1349\n#endif\n#ifndef NSAppKitVersionNumber10_12\n# define NSAppKitVersionNumber10_12 1504\n#endif\n#ifndef NSAppKitVersionNumber10_12_2\n# define NSAppKitVersionNumber10_12_2 1504.76\n#endif\n#ifndef NSAppKitVersionNumber10_13\n# define NSAppKitVersionNumber10_13 1561\n#endif\n#ifndef NSAppKitVersionNumber10_14\n# define NSAppKitVersionNumber10_14 1671\n#endif\n#ifndef NSAppKitVersionNumber11_0\n# define NSAppKitVersionNumber11_0 2022\n#endif\n\n// Macro to detect runtime OS version. Ideally, we would just like to use\n// @available to test for this because the compiler can optimize it out\n// depending on your min/max OS configuration. However, it was added in Xcode 9\n// (macOS 10.13 SDK). For any code that we want to be compilable for Xcode 8\n// (macOS 10.12) or below, we need to use the macro below which will\n// selectively use NSAppKitVersionNumber instead.\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_13\n// Xcode 9+, can use @available, which is more efficient.\n# define AVAILABLE_MAC_OS(MAJOR, MINOR) @available(macos MAJOR##.##MINOR, *)\n# define AVAILABLE_MAC_OS_PATCH(MAJOR, MINOR, PATCH) @available(macos MAJOR##.##MINOR##.##PATCH, *)\n#else\n// Xcode 8 or below. Use the old-school NSAppKitVersionNumber check.\n# define AVAILABLE_MAC_OS(MAJOR, MINOR) NSAppKitVersionNumber >= NSAppKitVersionNumber##MAJOR##_##MINOR\n# define AVAILABLE_MAC_OS_PATCH(MAJOR, MINOR, PATCH) NSAppKitVersionNumber >= NSAppKitVersionNumber##MAJOR##_##MINOR##_##PATCH\n#endif\n\n// Deprecated constants. Since these are constants, we just need the compiler,\n// not the runtime to know about them. As such, we can use MAX_ALLOWED to\n// determine if we need to map or not.\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_12\n// Deprecated constants in 10.12 SDK\n# define NSAlertStyleCritical NSCriticalAlertStyle\n# define NSAlertStyleInformational NSInformationalAlertStyle\n# define NSAlertStyleWarning NSWarningAlertStyle\n# define NSButtonTypeSwitch NSSwitchButton\n# define NSCompositingOperationSourceOver NSCompositeSourceOver\n# define NSCompositingOperationDifference NSCompositeDifference\n# define NSControlSizeRegular NSRegularControlSize\n# define NSEventModifierFlagCapsLock NSAlphaShiftKeyMask\n# define NSEventModifierFlagCommand NSCommandKeyMask\n# define NSEventModifierFlagControl NSControlKeyMask\n# define NSEventModifierFlagDeviceIndependentFlagsMask NSDeviceIndependentModifierFlagsMask\n# define NSEventModifierFlagHelp NSHelpKeyMask\n# define NSEventModifierFlagNumericPad NSNumericPadKeyMask\n# define NSEventModifierFlagOption NSAlternateKeyMask\n# define NSEventModifierFlagShift NSShiftKeyMask\n# define NSEventTypeApplicationDefined NSApplicationDefined\n# define NSEventTypeKeyDown NSKeyDown\n# define NSEventTypeKeyUp NSKeyUp\n# define NSEventTypeLeftMouseUp NSLeftMouseUp\n# define NSEventTypeMouseEntered NSMouseEntered\n# define NSEventTypeMouseExited NSMouseExited\n# define NSEventTypeRightMouseDown NSRightMouseDown\n# define NSWindowStyleMaskBorderless NSBorderlessWindowMask\n# define NSWindowStyleMaskClosable NSClosableWindowMask\n# define NSWindowStyleMaskFullScreen NSFullScreenWindowMask\n# define NSWindowStyleMaskMiniaturizable NSMiniaturizableWindowMask\n# define NSWindowStyleMaskResizable NSResizableWindowMask\n# define NSWindowStyleMaskTexturedBackground NSTexturedBackgroundWindowMask\n# define NSWindowStyleMaskTitled NSTitledWindowMask\n# define NSWindowStyleMaskUnifiedTitleAndToolbar NSUnifiedTitleAndToolbarWindowMask\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13\n// Deprecated constants in 10.13 SDK\n#define NSControlStateValueOn NSOnState\n#define NSControlStateValueOff NSOffState\n\n// Newly introduced symbols in 10.13 SDK\ntypedef NSString* NSPasteboardType;\ntypedef NSString* NSAttributedStringKey;\n#endif\n\n// Deprecated runtime values. Since these are runtime values, we need to use the\n// minimum required OS as determining factor. Otherwise it would crash.\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED <  MAC_OS_X_VERSION_10_13\n// Deprecated runtime values in 10.13 SDK.\n# define NSPasteboardNameFind NSFindPboard\n#endif\n\n#pragma endregion\n\n#import <asl.h>\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_12\n# define MM_USE_ASL\n#else\n# import <os/log.h>\n#endif\n\n#pragma region Shared protocols\n\n//\n// This is the protocol MMBackend implements.\n//\n// Only processInput:data: is allowed to cause state changes in Vim; all other\n// messages should only read the Vim state.  (Note that setDialogReturn: is an\n// exception to this rule; there really is no other way to deal with dialogs\n// since they work with callbacks, so we cannot wait for them to return.)\n//\n// Be careful with messages with return type other than 'oneway void' -- there\n// is a reply timeout set in MMAppController, if a message fails to get a\n// response within the given timeout an exception will be thrown.  Use\n// @try/@catch/@finally to deal with timeouts.\n//\n@protocol MMBackendProtocol\n- (oneway void)processInput:(int)msgid data:(in bycopy NSData *)data;\n- (oneway void)setDialogReturn:(in bycopy id)obj;\n- (NSString *)evaluateExpression:(in bycopy NSString *)expr;\n- (id)evaluateExpressionCocoa:(in bycopy NSString *)expr\n                  errorString:(out bycopy NSString **)errstr;\n- (BOOL)selectedTextToPasteboard:(byref NSPasteboard *)pboard;\n- (NSString *)selectedText;\n- (BOOL)mouseScreenposIsSelection:(int)row column:(int)column selRow:(byref int *)startRow selCol:(byref int *)startCol;\n- (oneway void)acknowledgeConnection;\n@end\n\n\n//\n// This is the protocol MMAppController implements.\n//\n// It handles connections between MacVim and Vim and communication from Vim to\n// MacVim.\n//\n// Do not add methods to this interface without a _very_ good reason (if\n// possible, instead add a new message to the *MsgID enum below and pass it via\n// processInput:forIdentifier).  Methods should not modify the state directly\n// but should instead delay any potential modifications (see\n// connectBackend:pid: and processInput:forIdentifier:).\n//\n@protocol MMAppProtocol\n- (unsigned)connectBackend:(byref in id <MMBackendProtocol>)proxy pid:(int)pid;\n- (oneway void)processInput:(in bycopy NSArray *)queue\n              forIdentifier:(unsigned)identifier;\n- (NSArray *)serverList;\n@end\n\n\n@protocol MMVimServerProtocol;\n\n//\n// The Vim client protocol (implemented by MMBackend).\n//\n// The client needs to keep track of server replies.  Take a look at MMBackend\n// if you want to implement this protocol in another program.\n//\n@protocol MMVimClientProtocol\n- (oneway void)addReply:(in bycopy NSString *)reply\n                 server:(in byref id <MMVimServerProtocol>)server;\n@end\n\n\n//\n// The Vim server protocol (implemented by MMBackend).\n//\n// Note that addInput:client: is not asynchronous, because otherwise Vim might\n// quit before the message has been passed (e.g. if --remote was used on the\n// command line).\n//\n@protocol MMVimServerProtocol\n- (void)addInput:(in bycopy NSString *)input\n                 client:(in byref id <MMVimClientProtocol>)client;\n- (NSString *)evaluateExpression:(in bycopy NSString *)expr\n                 client:(in byref id <MMVimClientProtocol>)client;\n@end\n\n#pragma endregion\n\n#pragma region IPC messages\n\n//\n// The following enum lists all messages that are passed between MacVim and\n// Vim.  These can be sent in processInput:data: and in processCommandQueue:.\n//\n\nextern const char * const MMVimMsgIDStrings[];\n\n#define FOREACH_MMVimMsgID(MSG) \\\n    MSG(NullMsgID) \\\n    MSG(OpenWindowMsgID) \\\n    MSG(KeyDownMsgID) \\\n    MSG(BatchDrawMsgID) \\\n    MSG(SelectTabMsgID) \\\n    MSG(CloseTabMsgID) \\\n    MSG(AddNewTabMsgID) \\\n    MSG(DraggedTabMsgID) \\\n    MSG(UpdateTabBarMsgID) \\\n    MSG(ShowTabBarMsgID) \\\n    MSG(HideTabBarMsgID) \\\n    MSG(SetTextRowsMsgID) \\\n    MSG(SetTextColumnsMsgID) \\\n    MSG(SetTextDimensionsMsgID) \\\n    MSG(SetTextDimensionsNoResizeWindowMsgID) \\\n    MSG(LiveResizeMsgID) \\\n    MSG(SetTextDimensionsReplyMsgID) \\\n    MSG(ResizeViewMsgID) \\\n    MSG(SetWindowTitleMsgID) \\\n    MSG(ScrollWheelMsgID) \\\n    MSG(MouseDownMsgID) \\\n    MSG(MouseUpMsgID) \\\n    MSG(MouseDraggedMsgID) \\\n    MSG(FlushQueueMsgID) \\\n    MSG(AddMenuMsgID) \\\n    MSG(AddMenuItemMsgID) \\\n    MSG(RemoveMenuItemMsgID) \\\n    MSG(EnableMenuItemMsgID) \\\n    MSG(ExecuteMenuMsgID) \\\n    MSG(UpdateMenuItemTooltipMsgID) \\\n    MSG(ShowToolbarMsgID) \\\n    MSG(ToggleToolbarMsgID) \\\n    MSG(CreateScrollbarMsgID) \\\n    MSG(DestroyScrollbarMsgID) \\\n    MSG(ShowScrollbarMsgID) \\\n    MSG(SetScrollbarPositionMsgID) \\\n    MSG(SetScrollbarThumbMsgID) \\\n    MSG(ScrollbarEventMsgID) \\\n    MSG(SetFontMsgID) \\\n    MSG(SetWideFontMsgID) \\\n    MSG(VimShouldCloseMsgID) \\\n    MSG(SetDefaultColorsMsgID) \\\n    MSG(ExecuteActionMsgID) \\\n    MSG(DropFilesMsgID) \\\n    MSG(DropStringMsgID) \\\n    MSG(ShowPopupMenuMsgID) \\\n    MSG(GotFocusMsgID) \\\n    MSG(LostFocusMsgID) \\\n    MSG(MouseMovedMsgID) \\\n    MSG(SetMouseShapeMsgID) \\\n    MSG(AdjustLinespaceMsgID) \\\n    MSG(AdjustColumnspaceMsgID) \\\n    MSG(ActivateMsgID) \\\n    MSG(SetServerNameMsgID) \\\n    MSG(EnterFullScreenMsgID) \\\n    MSG(LeaveFullScreenMsgID) \\\n    MSG(SetBuffersModifiedMsgID) \\\n    MSG(AddInputMsgID) \\\n    MSG(SetPreEditPositionMsgID) \\\n    MSG(TerminateNowMsgID) \\\n    MSG(XcodeModMsgID) \\\n    MSG(EnableAntialiasMsgID) \\\n    MSG(DisableAntialiasMsgID) \\\n    MSG(SetVimStateMsgID) \\\n    MSG(SetDocumentFilenameMsgID) \\\n    MSG(OpenWithArgumentsMsgID) \\\n    MSG(SelectAndFocusOpenedFileMsgID) \\\n    MSG(NewFileHereMsgID) \\\n    MSG(CloseWindowMsgID) \\\n    MSG(SetFullScreenColorMsgID) \\\n    MSG(ShowFindReplaceDialogMsgID) \\\n    MSG(FindReplaceMsgID) \\\n    MSG(UseSelectionForFindMsgID) \\\n    MSG(ActivateKeyScriptMsgID) \\\n    MSG(DeactivateKeyScriptMsgID) \\\n    MSG(EnableImControlMsgID) \\\n    MSG(DisableImControlMsgID) \\\n    MSG(ActivatedImMsgID) \\\n    MSG(DeactivatedImMsgID) \\\n    MSG(BrowseForFileMsgID) \\\n    MSG(ShowDialogMsgID) \\\n    MSG(SetMarkedTextMsgID) \\\n    MSG(ZoomMsgID) \\\n    MSG(SetWindowPositionMsgID) \\\n    MSG(DeleteSignMsgID) \\\n    MSG(SetTooltipMsgID) \\\n    MSG(GestureMsgID) \\\n    MSG(AddToMRUMsgID) \\\n    MSG(BackingPropertiesChangedMsgID) \\\n    MSG(SetBlurRadiusMsgID) \\\n    MSG(SetBackgroundOptionMsgID) \\\n    MSG(NotifyAppearanceChangeMsgID) \\\n    MSG(EnableLigaturesMsgID) \\\n    MSG(DisableLigaturesMsgID) \\\n    MSG(EnableThinStrokesMsgID) \\\n    MSG(DisableThinStrokesMsgID) \\\n    MSG(ShowDefinitionMsgID) \\\n    MSG(LastMsgID) \\\n\nenum {\n#define ENUM_ENTRY(X) X,\n    FOREACH_MMVimMsgID(ENUM_ENTRY)\n#undef ENUM_ENTRY\n};\n\n\nenum {\n    ClearAllDrawType = 1,\n    ClearBlockDrawType,\n    DeleteLinesDrawType,\n    DrawStringDrawType,\n    InsertLinesDrawType,\n    DrawCursorDrawType,\n    SetCursorPosDrawType,\n    DrawInvertedRectDrawType,\n    DrawSignDrawType,\n\n    InvalidDrawType = -1\n};\n\nenum {\n    MMInsertionPointBlock,\n    MMInsertionPointHorizontal,\n    MMInsertionPointVertical,\n    MMInsertionPointHollow,\n    MMInsertionPointVerticalRight,\n};\n\n\nenum {\n    ToolbarLabelFlag = 1,\n    ToolbarIconFlag = 2,\n    ToolbarSizeRegularFlag = 4\n};\n\n\nenum {\n    MMTabLabel = 0,\n    MMTabToolTip,\n    MMTabInfoCount\n};\n\nenum {\n    MMGestureSwipeLeft,\n    MMGestureSwipeRight,\n    MMGestureSwipeUp,\n    MMGestureSwipeDown,\n    MMGestureForceClick,\n};\n\n#pragma endregion\n\n\n// Create a string holding the labels of all messages in message queue for\n// debugging purposes (condense some messages since there may typically be LOTS\n// of them on a queue).\nNSString *debugStringForMessageQueue(NSArray *queue);\n\n\n// Shared user defaults (most user defaults are in Miscellaneous.h).\n// Contrary to the user defaults in Miscellaneous.h these defaults are not\n// initialized to any default values.  That is, unless the user sets them\n// these keys will not be present in the user default database.\nextern NSString *MMLogLevelKey;\nextern NSString *MMLogToStdErrKey;\n\n// Argument used to stop MacVim from opening an empty window on startup\n// (technically this is a user default but should not be used as such).\nextern NSString *MMNoWindowKey;\n\n// Argument used to control MacVim sharing search text via the Find Pasteboard.\nextern NSString *MMShareFindPboardKey;\n\nextern NSString *MMAutosaveRowsKey;\nextern NSString *MMAutosaveColumnsKey;\nextern NSString *MMRendererKey; // Deprecated: Non-CoreText renderer\n\nenum {\n    MMRendererDefault = 0,\n    MMRendererCoreText\n};\n\n\nextern NSString *VimFindPboardType;\n\n\n\n\n@interface NSString (MMExtras)\n- (NSString *)stringByRemovingFindPatterns;\n- (NSString *)stringBySanitizingSpotlightSearch;\n@end\n\n\n@interface NSColor (MMExtras)\n@property(readonly) unsigned argbInt;\n+ (NSColor *)colorWithRgbInt:(unsigned)rgb;\n+ (NSColor *)colorWithArgbInt:(unsigned)argb;\n@end\n\n\n@interface NSDictionary (MMExtras)\n+ (id)dictionaryWithData:(NSData *)data;\n- (NSData *)dictionaryAsData;\n@end\n\n@interface NSMutableDictionary (MMExtras)\n+ (id)dictionaryWithData:(NSData *)data;\n@end\n\n\n\n\n// ODB Editor Suite Constants (taken from ODBEditorSuite.h)\n#define\tkeyFileSender\t\t'FSnd'\n#define\tkeyFileSenderToken\t'FTok'\n#define\tkeyFileCustomPath\t'Burl'\n#define\tkODBEditorSuite\t\t'R*ch'\n#define\tkAEModifiedFile\t\t'FMod'\n#define\tkeyNewLocation\t\t'New?'\n#define\tkAEClosedFile\t\t'FCls'\n#define\tkeySenderToken\t\t'Tokn'\n\n\n// MacVim Apple Event Constants\n#define keyMMUntitledWindow       'MMuw'\n\n#pragma region Logging\n\n// Logging related functions and macros.\n//\n// This is a very simplistic logging facility built on top of ASL.  Two user\n// defaults allow for changing the local log filter level (MMLogLevel) and\n// whether logs should be sent to stderr (MMLogToStdErr).  (These user defaults\n// are only checked during startup.)  The default is to block level 6 (info)\n// and 7 (debug) logs and _not_ to send logs to stderr.  Apart from this\n// \"syslog\" (see \"man syslog\") can be used to modify the ASL filters (it is\n// currently not possible to change the local filter at runtime).  For example:\n//   Enable all logs to reach the ASL database (by default 'debug' and 'info'\n//   are filtered out, see \"man syslogd\"):\n//     $ sudo syslog -c syslogd -d\n//   Reset the ASL database filter:\n//     $ sudo syslog -c syslogd off\n//   Change the master filter to block logs less severe than errors:\n//     $ sudo syslog -c 0 -e\n//   Change per-process filter for running MacVim process to block logs less\n//   severe than warnings:\n//     $ syslog -c MacVim -w\n//\n// Note that there are four ASL filters:\n//   1) The ASL database filter (syslog -c syslogd ...)\n//   2) The master filter (syslog -c 0 ...)\n//   3) The per-process filter (syslog -c PID ...)\n//   4) The local filter (MMLogLevel)\n//\n// To view the logs, either use \"Console.app\" or the \"syslog\" command:\n//   $ syslog -w | grep Vim\n// To get the logs to show up in Xcode enable the MMLogToStdErr user default.\n\nextern int ASLogLevel;\n\nvoid ASLInit();\n\n#if defined(MM_USE_ASL)\n\n# define MM_ASL_LEVEL_DEFAULT ASL_LEVEL_NOTICE\n# define ASLog(level, fmt, ...) \\\n    if (level <= ASLogLevel) { \\\n        asl_log(NULL, NULL, level, \"%s@%d: %s\", \\\n            __PRETTY_FUNCTION__, __LINE__, \\\n            [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n    }\n\n// Note: These macros are used like ASLogErr(@\"text num=%d\", 42).  Objective-C\n// style specifiers (%@) are supported.\n# define ASLogCrit(fmt, ...)   ASLog(ASL_LEVEL_CRIT,    fmt, ##__VA_ARGS__)\n# define ASLogErr(fmt, ...)    ASLog(ASL_LEVEL_ERR,     fmt, ##__VA_ARGS__)\n# define ASLogWarn(fmt, ...)   ASLog(ASL_LEVEL_WARNING, fmt, ##__VA_ARGS__)\n# define ASLogNotice(fmt, ...) ASLog(ASL_LEVEL_NOTICE,  fmt, ##__VA_ARGS__)\n# define ASLogInfo(fmt, ...)   ASLog(ASL_LEVEL_INFO,    fmt, ##__VA_ARGS__)\n# define ASLogDebug(fmt, ...)  ASLog(ASL_LEVEL_DEBUG,   fmt, ##__VA_ARGS__)\n# define ASLogTmp(fmt, ...)    ASLog(ASL_LEVEL_NOTICE,  fmt, ##__VA_ARGS__)\n\n#else\n\n# define MM_ASL_LEVEL_DEFAULT OS_LOG_TYPE_DEFAULT\n# define ASLog(level, fmt, ...) \\\n    if (level <= ASLogLevel) { \\\n        if (floor(NSAppKitVersionNumber) >= NSAppKitVersionNumber10_12) { \\\n            os_log_with_type(OS_LOG_DEFAULT, level, \"%s@%d: %s\", \\\n                __PRETTY_FUNCTION__, __LINE__, \\\n                [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n        } else { \\\n            int logLevel; \\\n            switch (level) { \\\n            case OS_LOG_TYPE_FAULT: logLevel = ASL_LEVEL_CRIT; break; \\\n            case OS_LOG_TYPE_ERROR: logLevel = ASL_LEVEL_ERR; break; \\\n            case OS_LOG_TYPE_INFO: logLevel = ASL_LEVEL_INFO; break; \\\n            case OS_LOG_TYPE_DEBUG: logLevel = ASL_LEVEL_DEBUG; break; \\\n            default: logLevel = ASL_LEVEL_NOTICE; break; \\\n            } \\\n            _Pragma(\"clang diagnostic push\") \\\n            _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") \\\n            asl_log(NULL, NULL, logLevel, \"%s@%d: %s\", \\\n                __PRETTY_FUNCTION__, __LINE__, \\\n                [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n            _Pragma(\"clang diagnostic pop\") \\\n        } \\\n    }\n\n# define ASLogCrit(fmt, ...)   ASLog(OS_LOG_TYPE_FAULT,   fmt, ##__VA_ARGS__)\n# define ASLogErr(fmt, ...)    ASLog(OS_LOG_TYPE_ERROR,   fmt, ##__VA_ARGS__)\n# define ASLogWarn(fmt, ...)   ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n# define ASLogNotice(fmt, ...) ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n# define ASLogInfo(fmt, ...)   ASLog(OS_LOG_TYPE_INFO,    fmt, ##__VA_ARGS__)\n# define ASLogDebug(fmt, ...)  ASLog(OS_LOG_TYPE_DEBUG,   fmt, ##__VA_ARGS__)\n# define ASLogTmp(fmt, ...)    ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n\n#endif\n\n#pragma endregion\n", "// !$*UTF8*$!\n{\n\tarchiveVersion = 1;\n\tclasses = {\n\t};\n\tobjectVersion = 47;\n\tobjects = {\n\n/* Begin PBXBuildFile section */\n\t\t0395A8330D71ED7800881434 /* DBPrefsWindowController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0395A8320D71ED7800881434 /* DBPrefsWindowController.m */; };\n\t\t0395A8AA0D72D88B00881434 /* General.png in Resources */ = {isa = PBXBuildFile; fileRef = 0395A8A90D72D88B00881434 /* General.png */; };\n\t\t1D09AB420C6A4D520045497E /* MMTypesetter.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D09AB400C6A4D520045497E /* MMTypesetter.m */; };\n\t\t1D0E051C0BA5F83800B6049E /* Colors.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1D0E051B0BA5F83800B6049E /* Colors.plist */; };\n\t\t1D145C7F0E5227CE00691AA0 /* MMTextViewHelper.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */; };\n\t\t1D1474980C56703C0038FA2B /* MacVim.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474960C56703C0038FA2B /* MacVim.m */; };\n\t\t1D1474A00C5673AE0038FA2B /* MMAppController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D14749E0C5673AE0038FA2B /* MMAppController.m */; };\n\t\t1D1474AA0C5677450038FA2B /* MMTextStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474A80C5677450038FA2B /* MMTextStorage.m */; };\n\t\t1D1474B00C5678370038FA2B /* MMTextView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474AE0C5678370038FA2B /* MMTextView.m */; };\n\t\t1D1474B60C56796D0038FA2B /* MMVimController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474B40C56796D0038FA2B /* MMVimController.m */; };\n\t\t1D1474BC0C567A910038FA2B /* MMWindowController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474BA0C567A910038FA2B /* MMWindowController.m */; };\n\t\t1D22374B0E45DF4800E6FFFF /* Advanced.png in Resources */ = {isa = PBXBuildFile; fileRef = 1D22374A0E45DF4800E6FFFF /* Advanced.png */; };\n\t\t1D384A0E100D671700D3C22F /* KeyBinding.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1D384A0D100D671700D3C22F /* KeyBinding.plist */; };\n\t\t1D44972211FCA9B400B0630F /* MMCoreTextView+ToolTip.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */; };\n\t\t1D493D580C5247BF00AB718C /* Vim in Copy Executables */ = {isa = PBXBuildFile; fileRef = 1D493D570C5247BF00AB718C /* Vim */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t1D493DBA0C52534300AB718C /* PSMTabBarControl.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t1D60088B0E96A0B2003763F0 /* MMFindReplaceController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */; };\n\t\t1D80591F0E1185EA001699D1 /* Miscellaneous.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80591D0E1185EA001699D1 /* Miscellaneous.m */; };\n\t\t1D80FBD40CBBD3B700102A1C /* MMFullScreenWindow.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */; };\n\t\t1D80FBD60CBBD3B700102A1C /* MMVimView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80FBD20CBBD3B700102A1C /* MMVimView.m */; };\n\t\t1D8B5A53104AF9FF002E59D5 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1D8B5A52104AF9FF002E59D5 /* Carbon.framework */; };\n\t\t1D9C60520EF79C0C0034AD44 /* MacVim.icns in Resources */ = {isa = PBXBuildFile; fileRef = 1D9C602E0EF79C0C0034AD44 /* MacVim.icns */; };\n\t\t1DCD00BF0E50B2B700460166 /* Attention.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AA0E50B2B700460166 /* Attention.png */; };\n\t\t1DCD00C00E50B2B700460166 /* Copy.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AB0E50B2B700460166 /* Copy.png */; };\n\t\t1DCD00C10E50B2B700460166 /* Cut.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AC0E50B2B700460166 /* Cut.png */; };\n\t\t1DCD00C20E50B2B700460166 /* FindHelp.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AD0E50B2B700460166 /* FindHelp.png */; };\n\t\t1DCD00C30E50B2B700460166 /* FindNext.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AE0E50B2B700460166 /* FindNext.png */; };\n\t\t1DCD00C40E50B2B700460166 /* FindPrev.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AF0E50B2B700460166 /* FindPrev.png */; };\n\t\t1DCD00C50E50B2B700460166 /* Help.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B00E50B2B700460166 /* Help.png */; };\n\t\t1DCD00C60E50B2B700460166 /* LoadSesn.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B10E50B2B700460166 /* LoadSesn.png */; };\n\t\t1DCD00C70E50B2B700460166 /* Make.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B20E50B2B700460166 /* Make.png */; };\n\t\t1DCD00C80E50B2B700460166 /* Open.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B30E50B2B700460166 /* Open.png */; };\n\t\t1DCD00C90E50B2B700460166 /* Paste.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B40E50B2B700460166 /* Paste.png */; };\n\t\t1DCD00CA0E50B2B700460166 /* Print.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B50E50B2B700460166 /* Print.png */; };\n\t\t1DCD00CB0E50B2B700460166 /* Redo.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B60E50B2B700460166 /* Redo.png */; };\n\t\t1DCD00CC0E50B2B700460166 /* Replace.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B70E50B2B700460166 /* Replace.png */; };\n\t\t1DCD00CD0E50B2B700460166 /* RunCtags.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B80E50B2B700460166 /* RunCtags.png */; };\n\t\t1DCD00CE0E50B2B700460166 /* RunScript.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B90E50B2B700460166 /* RunScript.png */; };\n\t\t1DCD00CF0E50B2B700460166 /* Save.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BA0E50B2B700460166 /* Save.png */; };\n\t\t1DCD00D00E50B2B700460166 /* SaveAll.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BB0E50B2B700460166 /* SaveAll.png */; };\n\t\t1DCD00D10E50B2B700460166 /* SaveSesn.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BC0E50B2B700460166 /* SaveSesn.png */; };\n\t\t1DCD00D20E50B2B700460166 /* TagJump.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BD0E50B2B700460166 /* TagJump.png */; };\n\t\t1DCD00D30E50B2B700460166 /* Undo.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BE0E50B2B700460166 /* Undo.png */; };\n\t\t1DD04DEC0C529C5E006CDC2B /* Credits.rtf in Resources */ = {isa = PBXBuildFile; fileRef = 1DD04DEB0C529C5E006CDC2B /* Credits.rtf */; };\n\t\t1DD0C20C0C60FFB4008CD84A /* gvimrc in Copy default vimrc files */ = {isa = PBXBuildFile; fileRef = 1DD0C20A0C60FF9A008CD84A /* gvimrc */; };\n\t\t1DD3D51E0D82D4C9006E4320 /* ibeam.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DD3D51D0D82D4C9006E4320 /* ibeam.png */; };\n\t\t1DD66ECE0C803D3600EBDAB3 /* MMApplication.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */; };\n\t\t1DD9F5E50C85D60500E8D5A5 /* SystemColors.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */; };\n\t\t1DE3F8EB0D50F84600052B9E /* MMPreferenceController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */; };\n\t\t1DE63FFB0E71820F00959BDB /* MMCoreTextView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */; };\n\t\t1DE8CC620C5E2AAD003F56E3 /* Actions.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1DE8CC610C5E2AAD003F56E3 /* Actions.plist */; };\n\t\t1DE9B9500D341AB8008FEDD4 /* MMWindow.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */; };\n\t\t1DED78600C6DE43D0079945F /* vimrc in Copy default vimrc files */ = {isa = PBXBuildFile; fileRef = 1DED785F0C6DE43D0079945F /* vimrc */; };\n\t\t1DFE25A50C527BC4003000F7 /* PSMTabBarControl.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */; };\n\t\t52818B031C1C08CE00F59085 /* QLStephen.qlgenerator in Copy QuickLookPlugin */ = {isa = PBXBuildFile; fileRef = 52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t528DA66A1426D4F9003380F1 /* macvim-askpass in Copy Scripts */ = {isa = PBXBuildFile; fileRef = 528DA6691426D4EB003380F1 /* macvim-askpass */; };\n\t\t52A364731C4A5789005757EC /* Sparkle.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 52A364721C4A5789005757EC /* Sparkle.framework */; settings = {ATTRIBUTES = (Weak, ); }; };\n\t\t52A364761C4A57C1005757EC /* Sparkle.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 52A364721C4A5789005757EC /* Sparkle.framework */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };\n\t\t8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C165CFE840E0CC02AAC07 /* InfoPlist.strings */; };\n\t\t8D11072D0486CEB800E47090 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = 29B97316FDCFA39411CA2CEA /* main.m */; settings = {ATTRIBUTES = (); }; };\n\t\t8D11072F0486CEB800E47090 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */; };\n\t\t907FF7512521BCE200BADACB /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF74F2521BCE200BADACB /* MainMenu.xib */; };\n\t\t907FF7542521BDA600BADACB /* Preferences.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF7522521BDA600BADACB /* Preferences.xib */; };\n\t\t907FF7572521BDC300BADACB /* FindAndReplace.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF7552521BDC200BADACB /* FindAndReplace.xib */; };\n\t\t909894382A56EB1E007B84A3 /* WhatsNew.xib in Resources */ = {isa = PBXBuildFile; fileRef = 909894362A56EB1E007B84A3 /* WhatsNew.xib */; };\n\t\t9098943C2A56ECF6007B84A3 /* MMWhatsNewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */; };\n\t\t90A33BEA28D563DF003A2E2F /* MMSparkle2Delegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */; };\n\t\t90B9877D2A579F9500FC95D6 /* WebKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 90B9877B2A579F9500FC95D6 /* WebKit.framework */; settings = {ATTRIBUTES = (Weak, ); }; };\n/* End PBXBuildFile section */\n\n/* Begin PBXContainerItemProxy section */\n\t\t1D493DB80C52533B00AB718C /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\tproxyType = 2;\n\t\t\tremoteGlobalIDString = 53DF68FD067E5B5A0090B5B0;\n\t\t\tremoteInfo = PSMTabBarControlFramework;\n\t\t};\n\t\t1D493DCC0C5254A400AB718C /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\tproxyType = 1;\n\t\t\tremoteGlobalIDString = 53DF68FC067E5B5A0090B5B0;\n\t\t\tremoteInfo = PSMTabBarControlFramework;\n\t\t};\n\t\t52818AFE1C1C075300F59085 /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\tproxyType = 2;\n\t\t\tremoteGlobalIDString = 8D576316048677EA00EA77CD;\n\t\t\tremoteInfo = QuickLookStephen;\n\t\t};\n\t\t52818B001C1C084100F59085 /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\tproxyType = 1;\n\t\t\tremoteGlobalIDString = 8D57630D048677EA00EA77CD;\n\t\t\tremoteInfo = QuickLookStephen;\n\t\t};\n/* End PBXContainerItemProxy section */\n\n/* Begin PBXCopyFilesBuildPhase section */\n\t\t1D0DCAD80BA3604D00B6CCFA /* Copy Executables */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 6;\n\t\t\tfiles = (\n\t\t\t\t1D493D580C5247BF00AB718C /* Vim in Copy Executables */,\n\t\t\t);\n\t\t\tname = \"Copy Executables\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t1D9EB2840C366D7B0074B739 /* Copy Frameworks */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 10;\n\t\t\tfiles = (\n\t\t\t\t52A364761C4A57C1005757EC /* Sparkle.framework in Copy Frameworks */,\n\t\t\t\t1D493DBA0C52534300AB718C /* PSMTabBarControl.framework in Copy Frameworks */,\n\t\t\t);\n\t\t\tname = \"Copy Frameworks\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t1DE608B80C58807F0055263D /* Copy default vimrc files */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = vim;\n\t\t\tdstSubfolderSpec = 7;\n\t\t\tfiles = (\n\t\t\t\t1DED78600C6DE43D0079945F /* vimrc in Copy default vimrc files */,\n\t\t\t\t1DD0C20C0C60FFB4008CD84A /* gvimrc in Copy default vimrc files */,\n\t\t\t);\n\t\t\tname = \"Copy default vimrc files\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t52818B021C1C088000F59085 /* Copy QuickLookPlugin */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = ../Library/QuickLook;\n\t\t\tdstSubfolderSpec = 6;\n\t\t\tfiles = (\n\t\t\t\t52818B031C1C08CE00F59085 /* QLStephen.qlgenerator in Copy QuickLookPlugin */,\n\t\t\t);\n\t\t\tname = \"Copy QuickLookPlugin\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t528DA6671426D456003380F1 /* Copy Scripts */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 7;\n\t\t\tfiles = (\n\t\t\t\t528DA66A1426D4F9003380F1 /* macvim-askpass in Copy Scripts */,\n\t\t\t);\n\t\t\tname = \"Copy Scripts\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXCopyFilesBuildPhase section */\n\n/* Begin PBXFileReference section */\n\t\t0395A8310D71ED7800881434 /* DBPrefsWindowController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DBPrefsWindowController.h; sourceTree = \"<group>\"; };\n\t\t0395A8320D71ED7800881434 /* DBPrefsWindowController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DBPrefsWindowController.m; sourceTree = \"<group>\"; };\n\t\t0395A8A90D72D88B00881434 /* General.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = General.png; sourceTree = \"<group>\"; };\n\t\t1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = /System/Library/Frameworks/Cocoa.framework; sourceTree = \"<absolute>\"; };\n\t\t1D09AB3F0C6A4D520045497E /* MMTypesetter.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTypesetter.h; sourceTree = \"<group>\"; };\n\t\t1D09AB400C6A4D520045497E /* MMTypesetter.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTypesetter.m; sourceTree = \"<group>\"; };\n\t\t1D0E051B0BA5F83800B6049E /* Colors.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Colors.plist; sourceTree = \"<group>\"; };\n\t\t1D145C7D0E5227CE00691AA0 /* MMTextViewHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMTextViewHelper.h; sourceTree = \"<group>\"; };\n\t\t1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMTextViewHelper.m; sourceTree = \"<group>\"; };\n\t\t1D1474950C56703C0038FA2B /* MacVim.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MacVim.h; sourceTree = \"<group>\"; };\n\t\t1D1474960C56703C0038FA2B /* MacVim.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MacVim.m; sourceTree = \"<group>\"; };\n\t\t1D14749D0C5673AE0038FA2B /* MMAppController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMAppController.h; sourceTree = \"<group>\"; };\n\t\t1D14749E0C5673AE0038FA2B /* MMAppController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMAppController.m; sourceTree = \"<group>\"; };\n\t\t1D1474A70C5677450038FA2B /* MMTextStorage.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTextStorage.h; sourceTree = \"<group>\"; };\n\t\t1D1474A80C5677450038FA2B /* MMTextStorage.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTextStorage.m; sourceTree = \"<group>\"; };\n\t\t1D1474AD0C5678370038FA2B /* MMTextView.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTextView.h; sourceTree = \"<group>\"; };\n\t\t1D1474AE0C5678370038FA2B /* MMTextView.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTextView.m; sourceTree = \"<group>\"; };\n\t\t1D1474B30C56796D0038FA2B /* MMVimController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMVimController.h; sourceTree = \"<group>\"; };\n\t\t1D1474B40C56796D0038FA2B /* MMVimController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMVimController.m; sourceTree = \"<group>\"; };\n\t\t1D1474B90C567A910038FA2B /* MMWindowController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMWindowController.h; sourceTree = \"<group>\"; };\n\t\t1D1474BA0C567A910038FA2B /* MMWindowController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMWindowController.m; sourceTree = \"<group>\"; };\n\t\t1D22374A0E45DF4800E6FFFF /* Advanced.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = Advanced.png; sourceTree = \"<group>\"; };\n\t\t1D384A0D100D671700D3C22F /* KeyBinding.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = KeyBinding.plist; sourceTree = \"<group>\"; };\n\t\t1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = \"MMCoreTextView+ToolTip.m\"; sourceTree = \"<group>\"; };\n\t\t1D493D570C5247BF00AB718C /* Vim */ = {isa = PBXFileReference; lastKnownFileType = \"compiled.mach-o.executable\"; name = Vim; path = ../Vim; sourceTree = SOURCE_ROOT; };\n\t\t1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = \"wrapper.pb-project\"; name = PSMTabBarControl.xcodeproj; path = PSMTabBarControl/PSMTabBarControl.xcodeproj; sourceTree = \"<group>\"; };\n\t\t1D6008890E96A0B2003763F0 /* MMFindReplaceController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMFindReplaceController.h; sourceTree = \"<group>\"; };\n\t\t1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMFindReplaceController.m; sourceTree = \"<group>\"; };\n\t\t1D80591D0E1185EA001699D1 /* Miscellaneous.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Miscellaneous.m; sourceTree = \"<group>\"; };\n\t\t1D8059220E118663001699D1 /* Miscellaneous.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Miscellaneous.h; sourceTree = \"<group>\"; };\n\t\t1D80FBCF0CBBD3B700102A1C /* MMFullScreenWindow.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMFullScreenWindow.h; sourceTree = \"<group>\"; };\n\t\t1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMFullScreenWindow.m; sourceTree = \"<group>\"; };\n\t\t1D80FBD10CBBD3B700102A1C /* MMVimView.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMVimView.h; sourceTree = \"<group>\"; };\n\t\t1D80FBD20CBBD3B700102A1C /* MMVimView.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMVimView.m; sourceTree = \"<group>\"; };\n\t\t1D8B5A52104AF9FF002E59D5 /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = \"<absolute>\"; };\n\t\t1D9C602E0EF79C0C0034AD44 /* MacVim.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = MacVim.icns; path = icons/MacVim.icns; sourceTree = \"<group>\"; };\n\t\t1DCD00AA0E50B2B700460166 /* Attention.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Attention.png; path = Toolbar/Attention.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AB0E50B2B700460166 /* Copy.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Copy.png; path = Toolbar/Copy.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AC0E50B2B700460166 /* Cut.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Cut.png; path = Toolbar/Cut.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AD0E50B2B700460166 /* FindHelp.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindHelp.png; path = Toolbar/FindHelp.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AE0E50B2B700460166 /* FindNext.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindNext.png; path = Toolbar/FindNext.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AF0E50B2B700460166 /* FindPrev.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindPrev.png; path = Toolbar/FindPrev.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B00E50B2B700460166 /* Help.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Help.png; path = Toolbar/Help.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B10E50B2B700460166 /* LoadSesn.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = LoadSesn.png; path = Toolbar/LoadSesn.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B20E50B2B700460166 /* Make.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Make.png; path = Toolbar/Make.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B30E50B2B700460166 /* Open.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Open.png; path = Toolbar/Open.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B40E50B2B700460166 /* Paste.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Paste.png; path = Toolbar/Paste.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B50E50B2B700460166 /* Print.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Print.png; path = Toolbar/Print.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B60E50B2B700460166 /* Redo.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Redo.png; path = Toolbar/Redo.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B70E50B2B700460166 /* Replace.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Replace.png; path = Toolbar/Replace.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B80E50B2B700460166 /* RunCtags.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = RunCtags.png; path = Toolbar/RunCtags.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B90E50B2B700460166 /* RunScript.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = RunScript.png; path = Toolbar/RunScript.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BA0E50B2B700460166 /* Save.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Save.png; path = Toolbar/Save.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BB0E50B2B700460166 /* SaveAll.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = SaveAll.png; path = Toolbar/SaveAll.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BC0E50B2B700460166 /* SaveSesn.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = SaveSesn.png; path = Toolbar/SaveSesn.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BD0E50B2B700460166 /* TagJump.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = TagJump.png; path = Toolbar/TagJump.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BE0E50B2B700460166 /* Undo.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Undo.png; path = Toolbar/Undo.png; sourceTree = \"<group>\"; };\n\t\t1DD04DEB0C529C5E006CDC2B /* Credits.rtf */ = {isa = PBXFileReference; lastKnownFileType = text.rtf; path = Credits.rtf; sourceTree = \"<group>\"; };\n\t\t1DD0C20A0C60FF9A008CD84A /* gvimrc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = gvimrc; sourceTree = \"<group>\"; };\n\t\t1DD3D51D0D82D4C9006E4320 /* ibeam.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = ibeam.png; sourceTree = \"<group>\"; };\n\t\t1DD66ECB0C803D3600EBDAB3 /* MMApplication.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMApplication.h; sourceTree = \"<group>\"; };\n\t\t1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMApplication.m; sourceTree = \"<group>\"; };\n\t\t1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = SystemColors.plist; sourceTree = \"<group>\"; };\n\t\t1DE3F8E80D50F84600052B9E /* MMPreferenceController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMPreferenceController.h; sourceTree = \"<group>\"; };\n\t\t1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMPreferenceController.m; sourceTree = \"<group>\"; };\n\t\t1DE602470C587FD10055263D /* runtime */ = {isa = PBXFileReference; lastKnownFileType = folder; name = runtime; path = ../../runtime; sourceTree = SOURCE_ROOT; };\n\t\t1DE63FF90E71820F00959BDB /* MMCoreTextView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMCoreTextView.h; sourceTree = \"<group>\"; };\n\t\t1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMCoreTextView.m; sourceTree = \"<group>\"; };\n\t\t1DE8CC610C5E2AAD003F56E3 /* Actions.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Actions.plist; sourceTree = \"<group>\"; };\n\t\t1DE9B94D0D341AB8008FEDD4 /* MMWindow.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMWindow.h; sourceTree = \"<group>\"; };\n\t\t1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMWindow.m; sourceTree = \"<group>\"; };\n\t\t1DED785F0C6DE43D0079945F /* vimrc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = vimrc; sourceTree = \"<group>\"; };\n\t\t29B97316FDCFA39411CA2CEA /* main.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = \"<group>\"; };\n\t\t29B97324FDCFA39411CA2CEA /* AppKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AppKit.framework; path = /System/Library/Frameworks/AppKit.framework; sourceTree = \"<absolute>\"; };\n\t\t29B97325FDCFA39411CA2CEA /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = /System/Library/Frameworks/Foundation.framework; sourceTree = \"<absolute>\"; };\n\t\t32CA4F630368D1EE00C91783 /* MacVim_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MacVim_Prefix.pch; sourceTree = \"<group>\"; };\n\t\t52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = \"wrapper.pb-project\"; name = QuickLookStephen.xcodeproj; path = qlstephen/QuickLookStephen.xcodeproj; sourceTree = \"<group>\"; };\n\t\t528DA6691426D4EB003380F1 /* macvim-askpass */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = \"macvim-askpass\"; sourceTree = \"<group>\"; };\n\t\t52A364721C4A5789005757EC /* Sparkle.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; path = Sparkle.framework; sourceTree = \"<group>\"; };\n\t\t8D1107310486CEB800E47090 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = \"<group>\"; };\n\t\t8D1107320486CEB800E47090 /* MacVim.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = MacVim.app; sourceTree = BUILT_PRODUCTS_DIR; };\n\t\t901C06F42430C8C800797C2A /* map.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = map.c; path = ../map.c; sourceTree = \"<group>\"; };\n\t\t901C06F62430C8C900797C2A /* time.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = time.c; path = ../time.c; sourceTree = \"<group>\"; };\n\t\t901C06F72430C8C900797C2A /* testing.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = testing.c; path = ../testing.c; sourceTree = \"<group>\"; };\n\t\t901C06F82430C8C900797C2A /* cmdhist.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cmdhist.c; path = ../cmdhist.c; sourceTree = \"<group>\"; };\n\t\t901C06F92430C8C900797C2A /* change.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = change.c; path = ../change.c; sourceTree = \"<group>\"; };\n\t\t901C06FA2430C8C900797C2A /* evalwindow.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalwindow.c; path = ../evalwindow.c; sourceTree = \"<group>\"; };\n\t\t901C06FB2430C8C900797C2A /* bufwrite.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = bufwrite.c; path = ../bufwrite.c; sourceTree = \"<group>\"; };\n\t\t901C06FC2430C8CA00797C2A /* evalvars.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalvars.c; path = ../evalvars.c; sourceTree = \"<group>\"; };\n\t\t901C06FD2430C8CA00797C2A /* drawscreen.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = drawscreen.c; path = ../drawscreen.c; sourceTree = \"<group>\"; };\n\t\t901C06FE2430C8CA00797C2A /* debugger.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = debugger.c; path = ../debugger.c; sourceTree = \"<group>\"; };\n\t\t901C06FF2430C8CA00797C2A /* popupmenu.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = popupmenu.c; path = ../popupmenu.c; sourceTree = \"<group>\"; };\n\t\t901C07002430C8CA00797C2A /* cindent.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cindent.c; path = ../cindent.c; sourceTree = \"<group>\"; };\n\t\t901C07012430C8CA00797C2A /* usercmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = usercmd.c; path = ../usercmd.c; sourceTree = \"<group>\"; };\n\t\t901C07022430C8CA00797C2A /* popupwin.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = popupwin.c; path = ../popupwin.c; sourceTree = \"<group>\"; };\n\t\t901C07032430C8CA00797C2A /* drawline.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = drawline.c; path = ../drawline.c; sourceTree = \"<group>\"; };\n\t\t901C07042430C8CA00797C2A /* cmdexpand.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cmdexpand.c; path = ../cmdexpand.c; sourceTree = \"<group>\"; };\n\t\t901C07052430C8CB00797C2A /* scriptfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = scriptfile.c; path = ../scriptfile.c; sourceTree = \"<group>\"; };\n\t\t901C07062430C8CB00797C2A /* register.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = register.c; path = ../register.c; sourceTree = \"<group>\"; };\n\t\t901C07072430C8CB00797C2A /* vim9execute.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9execute.c; path = ../vim9execute.c; sourceTree = \"<group>\"; };\n\t\t901C07082430C8CB00797C2A /* evalbuffer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalbuffer.c; path = ../evalbuffer.c; sourceTree = \"<group>\"; };\n\t\t901C07092430C8CB00797C2A /* spellsuggest.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spellsuggest.c; path = ../spellsuggest.c; sourceTree = \"<group>\"; };\n\t\t901C070A2430C8CB00797C2A /* insexpand.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = insexpand.c; path = ../insexpand.c; sourceTree = \"<group>\"; };\n\t\t901C070B2430C8CB00797C2A /* profiler.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = profiler.c; path = ../profiler.c; sourceTree = \"<group>\"; };\n\t\t901C070C2430C8CB00797C2A /* vim9compile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9compile.c; path = ../vim9compile.c; sourceTree = \"<group>\"; };\n\t\t901C070D2430C8CC00797C2A /* sound.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sound.c; path = ../sound.c; sourceTree = \"<group>\"; };\n\t\t901C070E2430C8CC00797C2A /* vim9.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = vim9.h; path = ../vim9.h; sourceTree = \"<group>\"; };\n\t\t901C070F2430C8CC00797C2A /* arglist.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = arglist.c; path = ../arglist.c; sourceTree = \"<group>\"; };\n\t\t901C07102430C8CC00797C2A /* vim9script.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9script.c; path = ../vim9script.c; sourceTree = \"<group>\"; };\n\t\t901C07112430C8CC00797C2A /* clipboard.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = clipboard.c; path = ../clipboard.c; sourceTree = \"<group>\"; };\n\t\t901C07122430C8CC00797C2A /* highlight.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = highlight.c; path = ../highlight.c; sourceTree = \"<group>\"; };\n\t\t901C07132430C8CC00797C2A /* uninstall.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = uninstall.c; path = ../uninstall.c; sourceTree = \"<group>\"; };\n\t\t901C07142430C8CC00797C2A /* regexp_bt.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp_bt.c; path = ../regexp_bt.c; sourceTree = \"<group>\"; };\n\t\t901C07152430C8CC00797C2A /* mouse.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mouse.c; path = ../mouse.c; sourceTree = \"<group>\"; };\n\t\t901C07162430C8CD00797C2A /* optiondefs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = optiondefs.h; path = ../optiondefs.h; sourceTree = \"<group>\"; };\n\t\t901C07172430C8CD00797C2A /* optionstr.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = optionstr.c; path = ../optionstr.c; sourceTree = \"<group>\"; };\n\t\t901C07182430C8CD00797C2A /* viminfo.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = viminfo.c; path = ../viminfo.c; sourceTree = \"<group>\"; };\n\t\t901C07192430C8CD00797C2A /* filepath.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = filepath.c; path = ../filepath.c; sourceTree = \"<group>\"; };\n\t\t901C071A2430C8CD00797C2A /* session.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = session.c; path = ../session.c; sourceTree = \"<group>\"; };\n\t\t907FF75A2521C09F00BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/FindAndReplace.xib; sourceTree = \"<group>\"; };\n\t\t907FF75B2521C09F00BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/Preferences.xib; sourceTree = \"<group>\"; };\n\t\t907FF75C2521C0A000BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = \"<group>\"; };\n\t\t907FF7622521C2FB00BADACB /* zh-Hant */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"zh-Hant\"; path = \"zh-Hant.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t907FF7632521CBAC00BADACB /* zh-Hans */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"zh-Hans\"; path = \"zh-Hans.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t907FF7642521CBC500BADACB /* ja */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ja; path = ja.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90922A3B221D429500F1E1F4 /* misc2.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = misc2.c; path = ../misc2.c; sourceTree = \"<group>\"; };\n\t\t90922A3C221D429500F1E1F4 /* if_mzsch.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_mzsch.c; path = ../if_mzsch.c; sourceTree = \"<group>\"; };\n\t\t90922A3D221D429500F1E1F4 /* version.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = version.h; path = ../version.h; sourceTree = \"<group>\"; };\n\t\t90922A3E221D429500F1E1F4 /* digraph.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = digraph.c; path = ../digraph.c; sourceTree = \"<group>\"; };\n\t\t90922A40221D429500F1E1F4 /* keymap.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = keymap.h; path = ../keymap.h; sourceTree = \"<group>\"; };\n\t\t90922A41221D429500F1E1F4 /* iscygpty.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = iscygpty.c; path = ../iscygpty.c; sourceTree = \"<group>\"; };\n\t\t90922A42221D429600F1E1F4 /* if_python3.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_python3.c; path = ../if_python3.c; sourceTree = \"<group>\"; };\n\t\t90922A43221D429600F1E1F4 /* dict.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dict.c; path = ../dict.c; sourceTree = \"<group>\"; };\n\t\t90922A45221D429600F1E1F4 /* kword_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = kword_test.c; path = ../kword_test.c; sourceTree = \"<group>\"; };\n\t\t90922A46221D429600F1E1F4 /* if_perlsfio.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_perlsfio.c; path = ../if_perlsfio.c; sourceTree = \"<group>\"; };\n\t\t90922A47221D429600F1E1F4 /* pty.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = pty.c; path = ../pty.c; sourceTree = \"<group>\"; };\n\t\t90922A48221D429600F1E1F4 /* ex_cmdidxs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ex_cmdidxs.h; path = ../ex_cmdidxs.h; sourceTree = \"<group>\"; };\n\t\t90922A49221D429600F1E1F4 /* if_py_both.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_py_both.h; path = ../if_py_both.h; sourceTree = \"<group>\"; };\n\t\t90922A4A221D429600F1E1F4 /* nbdebug.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = nbdebug.c; path = ../nbdebug.c; sourceTree = \"<group>\"; };\n\t\t90922A4B221D429600F1E1F4 /* mark.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mark.c; path = ../mark.c; sourceTree = \"<group>\"; };\n\t\t90922A4C221D429600F1E1F4 /* gui.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui.c; path = ../gui.c; sourceTree = \"<group>\"; };\n\t\t90922A4D221D429600F1E1F4 /* ex_eval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_eval.c; path = ../ex_eval.c; sourceTree = \"<group>\"; };\n\t\t90922A4E221D429600F1E1F4 /* netbeans.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = netbeans.c; path = ../netbeans.c; sourceTree = \"<group>\"; };\n\t\t90922A4F221D429600F1E1F4 /* json_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = json_test.c; path = ../json_test.c; sourceTree = \"<group>\"; };\n\t\t90922A50221D429600F1E1F4 /* hashtab.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = hashtab.c; path = ../hashtab.c; sourceTree = \"<group>\"; };\n\t\t90922A51221D429600F1E1F4 /* memfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memfile.c; path = ../memfile.c; sourceTree = \"<group>\"; };\n\t\t90922A52221D429600F1E1F4 /* iscygpty.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = iscygpty.h; path = ../iscygpty.h; sourceTree = \"<group>\"; };\n\t\t90922A53221D429700F1E1F4 /* ex_cmds2.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_cmds2.c; path = ../ex_cmds2.c; sourceTree = \"<group>\"; };\n\t\t90922A54221D429700F1E1F4 /* arabic.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = arabic.c; path = ../arabic.c; sourceTree = \"<group>\"; };\n\t\t90922A55221D429700F1E1F4 /* gui_beval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui_beval.c; path = ../gui_beval.c; sourceTree = \"<group>\"; };\n\t\t90922A56221D429700F1E1F4 /* crypt_zip.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = crypt_zip.c; path = ../crypt_zip.c; sourceTree = \"<group>\"; };\n\t\t90922A57221D429700F1E1F4 /* hardcopy.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = hardcopy.c; path = ../hardcopy.c; sourceTree = \"<group>\"; };\n\t\t90922A58221D429700F1E1F4 /* list.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = list.c; path = ../list.c; sourceTree = \"<group>\"; };\n\t\t90922A5B221D429700F1E1F4 /* eval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = eval.c; path = ../eval.c; sourceTree = \"<group>\"; };\n\t\t90922A5C221D429700F1E1F4 /* userfunc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = userfunc.c; path = ../userfunc.c; sourceTree = \"<group>\"; };\n\t\t90922A5D221D429700F1E1F4 /* os_mac.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = os_mac.h; path = ../os_mac.h; sourceTree = \"<group>\"; };\n\t\t90922A5E221D429700F1E1F4 /* nbdebug.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nbdebug.h; path = ../nbdebug.h; sourceTree = \"<group>\"; };\n\t\t90922A5F221D429700F1E1F4 /* message_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = message_test.c; path = ../message_test.c; sourceTree = \"<group>\"; };\n\t\t90922A60221D429800F1E1F4 /* tag.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = tag.c; path = ../tag.c; sourceTree = \"<group>\"; };\n\t\t90922A62221D429800F1E1F4 /* blowfish.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = blowfish.c; path = ../blowfish.c; sourceTree = \"<group>\"; };\n\t\t90922A63221D429800F1E1F4 /* message.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = message.c; path = ../message.c; sourceTree = \"<group>\"; };\n\t\t90922A64221D429800F1E1F4 /* termlib.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = termlib.c; path = ../termlib.c; sourceTree = \"<group>\"; };\n\t\t90922A65221D429800F1E1F4 /* beval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = beval.c; path = ../beval.c; sourceTree = \"<group>\"; };\n\t\t90922A66221D429800F1E1F4 /* alloc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = alloc.h; path = ../alloc.h; sourceTree = \"<group>\"; };\n\t\t90922A67221D429800F1E1F4 /* if_python.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_python.c; path = ../if_python.c; sourceTree = \"<group>\"; };\n\t\t90922A68221D429800F1E1F4 /* protodef.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = protodef.h; path = ../protodef.h; sourceTree = \"<group>\"; };\n\t\t90922A69221D429800F1E1F4 /* macros.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = macros.h; path = ../macros.h; sourceTree = \"<group>\"; };\n\t\t90922A6A221D429800F1E1F4 /* if_cscope.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_cscope.c; path = ../if_cscope.c; sourceTree = \"<group>\"; };\n\t\t90922A6C221D429900F1E1F4 /* dosinst.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = dosinst.h; path = ../dosinst.h; sourceTree = \"<group>\"; };\n\t\t90922A6D221D429900F1E1F4 /* memline.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memline.c; path = ../memline.c; sourceTree = \"<group>\"; };\n\t\t90922A6E221D429900F1E1F4 /* proto.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = proto.h; path = ../proto.h; sourceTree = \"<group>\"; };\n\t\t90922A6F221D429900F1E1F4 /* fileio.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = fileio.c; path = ../fileio.c; sourceTree = \"<group>\"; };\n\t\t90922A70221D429900F1E1F4 /* ex_docmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_docmd.c; path = ../ex_docmd.c; sourceTree = \"<group>\"; };\n\t\t90922A71221D429900F1E1F4 /* if_ruby.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_ruby.c; path = ../if_ruby.c; sourceTree = \"<group>\"; };\n\t\t90922A72221D429900F1E1F4 /* dosinst.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dosinst.c; path = ../dosinst.c; sourceTree = \"<group>\"; };\n\t\t90922A73221D429900F1E1F4 /* ops.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ops.c; path = ../ops.c; sourceTree = \"<group>\"; };\n\t\t90922A74221D429900F1E1F4 /* ex_getln.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_getln.c; path = ../ex_getln.c; sourceTree = \"<group>\"; };\n\t\t90922A76221D429900F1E1F4 /* ui.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ui.c; path = ../ui.c; sourceTree = \"<group>\"; };\n\t\t90922A77221D429900F1E1F4 /* fold.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = fold.c; path = ../fold.c; sourceTree = \"<group>\"; };\n\t\t90922A78221D429A00F1E1F4 /* menu.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = menu.c; path = ../menu.c; sourceTree = \"<group>\"; };\n\t\t90922A79221D429A00F1E1F4 /* beval.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = beval.h; path = ../beval.h; sourceTree = \"<group>\"; };\n\t\t90922A7A221D429A00F1E1F4 /* iid_ole.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = iid_ole.c; path = ../iid_ole.c; sourceTree = \"<group>\"; };\n\t\t90922A7B221D429A00F1E1F4 /* spell.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = spell.h; path = ../spell.h; sourceTree = \"<group>\"; };\n\t\t90922A7C221D429A00F1E1F4 /* mbyte.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mbyte.c; path = ../mbyte.c; sourceTree = \"<group>\"; };\n\t\t90922A7D221D429A00F1E1F4 /* edit.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = edit.c; path = ../edit.c; sourceTree = \"<group>\"; };\n\t\t90922A7E221D429A00F1E1F4 /* search.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = search.c; path = ../search.c; sourceTree = \"<group>\"; };\n\t\t90922A7F221D429A00F1E1F4 /* undo.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = undo.c; path = ../undo.c; sourceTree = \"<group>\"; };\n\t\t90922A80221D429A00F1E1F4 /* findfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = findfile.c; path = ../findfile.c; sourceTree = \"<group>\"; };\n\t\t90922A81221D429A00F1E1F4 /* vimrun.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vimrun.c; path = ../vimrun.c; sourceTree = \"<group>\"; };\n\t\t90922A82221D429A00F1E1F4 /* globals.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = globals.h; path = ../globals.h; sourceTree = \"<group>\"; };\n\t\t90922A83221D429A00F1E1F4 /* option.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = option.c; path = ../option.c; sourceTree = \"<group>\"; };\n\t\t90922A84221D429B00F1E1F4 /* term.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = term.c; path = ../term.c; sourceTree = \"<group>\"; };\n\t\t90922A85221D429B00F1E1F4 /* gui.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = gui.h; path = ../gui.h; sourceTree = \"<group>\"; };\n\t\t90922A87221D429B00F1E1F4 /* if_tcl.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_tcl.c; path = ../if_tcl.c; sourceTree = \"<group>\"; };\n\t\t90922A88221D429B00F1E1F4 /* blob.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = blob.c; path = ../blob.c; sourceTree = \"<group>\"; };\n\t\t90922A89221D429B00F1E1F4 /* if_mzsch.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_mzsch.h; path = ../if_mzsch.h; sourceTree = \"<group>\"; };\n\t\t90922A8A221D429B00F1E1F4 /* channel.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = channel.c; path = ../channel.c; sourceTree = \"<group>\"; };\n\t\t90922A8B221D429B00F1E1F4 /* indent.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = indent.c; path = ../indent.c; sourceTree = \"<group>\"; };\n\t\t90922A8C221D429B00F1E1F4 /* os_unix.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = os_unix.h; path = ../os_unix.h; sourceTree = \"<group>\"; };\n\t\t90922A8D221D429B00F1E1F4 /* main.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = main.c; path = ../main.c; sourceTree = \"<group>\"; };\n\t\t90922A8E221D429B00F1E1F4 /* ex_cmds.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ex_cmds.h; path = ../ex_cmds.h; sourceTree = \"<group>\"; };\n\t\t90922A90221D429B00F1E1F4 /* regexp_nfa.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp_nfa.c; path = ../regexp_nfa.c; sourceTree = \"<group>\"; };\n\t\t90922A91221D429B00F1E1F4 /* textprop.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textprop.c; path = ../textprop.c; sourceTree = \"<group>\"; };\n\t\t90922A92221D429B00F1E1F4 /* regexp.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = regexp.h; path = ../regexp.h; sourceTree = \"<group>\"; };\n\t\t90922A93221D429B00F1E1F4 /* charset.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = charset.c; path = ../charset.c; sourceTree = \"<group>\"; };\n\t\t90922A94221D429B00F1E1F4 /* quickfix.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = quickfix.c; path = ../quickfix.c; sourceTree = \"<group>\"; };\n\t\t90922A95221D429B00F1E1F4 /* crypt.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = crypt.c; path = ../crypt.c; sourceTree = \"<group>\"; };\n\t\t90922A96221D429B00F1E1F4 /* vim.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = vim.h; path = ../vim.h; sourceTree = \"<group>\"; };\n\t\t90922A97221D429B00F1E1F4 /* syntax.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = syntax.c; path = ../syntax.c; sourceTree = \"<group>\"; };\n\t\t90922A99221D429B00F1E1F4 /* if_xcmdsrv.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_xcmdsrv.c; path = ../if_xcmdsrv.c; sourceTree = \"<group>\"; };\n\t\t90922A9B221D429C00F1E1F4 /* evalfunc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalfunc.c; path = ../evalfunc.c; sourceTree = \"<group>\"; };\n\t\t90922A9C221D429C00F1E1F4 /* sha256.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sha256.c; path = ../sha256.c; sourceTree = \"<group>\"; };\n\t\t90922A9D221D429C00F1E1F4 /* screen.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = screen.c; path = ../screen.c; sourceTree = \"<group>\"; };\n\t\t90922A9F221D429C00F1E1F4 /* json.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = json.c; path = ../json.c; sourceTree = \"<group>\"; };\n\t\t90922AA0221D429C00F1E1F4 /* getchar.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = getchar.c; path = ../getchar.c; sourceTree = \"<group>\"; };\n\t\t90922AA1221D429C00F1E1F4 /* autocmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = autocmd.c; path = ../autocmd.c; sourceTree = \"<group>\"; };\n\t\t90922AA2221D429C00F1E1F4 /* misc1.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = misc1.c; path = ../misc1.c; sourceTree = \"<group>\"; };\n\t\t90922AA3221D429C00F1E1F4 /* normal.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = normal.c; path = ../normal.c; sourceTree = \"<group>\"; };\n\t\t90922AA4221D429C00F1E1F4 /* if_ole.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_ole.h; path = ../if_ole.h; sourceTree = \"<group>\"; };\n\t\t90922AA6221D429C00F1E1F4 /* move.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = move.c; path = ../move.c; sourceTree = \"<group>\"; };\n\t\t90922AA7221D429C00F1E1F4 /* os_unix.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = os_unix.c; path = ../os_unix.c; sourceTree = \"<group>\"; };\n\t\t90922AA8221D429C00F1E1F4 /* spell.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spell.c; path = ../spell.c; sourceTree = \"<group>\"; };\n\t\t90922AA9221D429C00F1E1F4 /* buffer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = buffer.c; path = ../buffer.c; sourceTree = \"<group>\"; };\n\t\t90922AAA221D429C00F1E1F4 /* window.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = window.c; path = ../window.c; sourceTree = \"<group>\"; };\n\t\t90922AAB221D429C00F1E1F4 /* dlldata.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dlldata.c; path = ../dlldata.c; sourceTree = \"<group>\"; };\n\t\t90922AAC221D429C00F1E1F4 /* sign.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sign.c; path = ../sign.c; sourceTree = \"<group>\"; };\n\t\t90922AAD221D429C00F1E1F4 /* ex_cmds.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_cmds.c; path = ../ex_cmds.c; sourceTree = \"<group>\"; };\n\t\t90922AAE221D429C00F1E1F4 /* feature.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = feature.h; path = ../feature.h; sourceTree = \"<group>\"; };\n\t\t90922AAF221D429C00F1E1F4 /* os_mac_conv.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = os_mac_conv.c; path = ../os_mac_conv.c; sourceTree = \"<group>\"; };\n\t\t90922AB0221D429C00F1E1F4 /* ascii.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ascii.h; path = ../ascii.h; sourceTree = \"<group>\"; };\n\t\t90922AB1221D429C00F1E1F4 /* option.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = option.h; path = ../option.h; sourceTree = \"<group>\"; };\n\t\t90922AB2221D429C00F1E1F4 /* memfile_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memfile_test.c; path = ../memfile_test.c; sourceTree = \"<group>\"; };\n\t\t90922AB3221D429C00F1E1F4 /* spellfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spellfile.c; path = ../spellfile.c; sourceTree = \"<group>\"; };\n\t\t90922AB4221D429C00F1E1F4 /* if_lua.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_lua.c; path = ../if_lua.c; sourceTree = \"<group>\"; };\n\t\t90922AB5221D429D00F1E1F4 /* structs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = structs.h; path = ../structs.h; sourceTree = \"<group>\"; };\n\t\t90922AB6221D429D00F1E1F4 /* diff.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = diff.c; path = ../diff.c; sourceTree = \"<group>\"; };\n\t\t90922AB7221D429D00F1E1F4 /* regexp.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp.c; path = ../regexp.c; sourceTree = \"<group>\"; };\n\t\t90922AB8221D429D00F1E1F4 /* version.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = version.c; path = ../version.c; sourceTree = \"<group>\"; };\n\t\t90922AB9221D429D00F1E1F4 /* terminal.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = terminal.c; path = ../terminal.c; sourceTree = \"<group>\"; };\n\t\t90922ABA221D429D00F1E1F4 /* term.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = term.h; path = ../term.h; sourceTree = \"<group>\"; };\n\t\t90922ABC221D42F700F1E1F4 /* MMBackend.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMBackend.h; sourceTree = \"<group>\"; };\n\t\t90922ABD221D42F700F1E1F4 /* gui_macvim.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = gui_macvim.m; sourceTree = \"<group>\"; };\n\t\t90922ABE221D42F700F1E1F4 /* MMBackend.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMBackend.m; sourceTree = \"<group>\"; };\n\t\t909894372A56EB1E007B84A3 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/WhatsNew.xib; sourceTree = \"<group>\"; };\n\t\t9098943A2A56ECF6007B84A3 /* MMWhatsNewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMWhatsNewController.h; sourceTree = \"<group>\"; };\n\t\t9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMWhatsNewController.m; sourceTree = \"<group>\"; };\n\t\t90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = MMSparkle2Delegate.m; sourceTree = \"<group>\"; };\n\t\t90A33BEC28D56423003A2E2F /* MMSparkle2Delegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = MMSparkle2Delegate.h; sourceTree = \"<group>\"; };\n\t\t90AF83B32AA15BE50046DA2E /* if_perl.xs */ = {isa = PBXFileReference; explicitFileType = sourcecode.c; name = if_perl.xs; path = ../if_perl.xs; sourceTree = \"<group>\"; };\n\t\t90AF83B42AA15C660046DA2E /* nv_cmdidxs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nv_cmdidxs.h; path = ../nv_cmdidxs.h; sourceTree = \"<group>\"; };\n\t\t90AF83B52AA15C660046DA2E /* alloc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = alloc.c; path = ../alloc.c; sourceTree = \"<group>\"; };\n\t\t90AF83B62AA15C660046DA2E /* nv_cmds.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nv_cmds.h; path = ../nv_cmds.h; sourceTree = \"<group>\"; };\n\t\t90AF83B72AA15C660046DA2E /* vim9cmds.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9cmds.c; path = ../vim9cmds.c; sourceTree = \"<group>\"; };\n\t\t90AF83B82AA15C660046DA2E /* termdefs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = termdefs.h; path = ../termdefs.h; sourceTree = \"<group>\"; };\n\t\t90B9877B2A579F9500FC95D6 /* WebKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = WebKit.framework; path = System/Library/Frameworks/WebKit.framework; sourceTree = SDKROOT; };\n\t\t90F84F1E2521F2270000268B /* ko */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ko; path = ko.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F232521F6480000268B /* ca */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ca; path = ca.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F242521F6590000268B /* cs */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = cs; path = cs.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F252521F6670000268B /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F262521F69A0000268B /* de */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = de; path = de.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F272521F6A70000268B /* es */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = es; path = es.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F282521F6B10000268B /* fi */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fi; path = fi.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F292521F6C10000268B /* fr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fr; path = fr.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2A2521F6CB0000268B /* hu */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = hu; path = hu.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2B2521F6D60000268B /* it */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = it; path = it.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2C2521F6E30000268B /* nl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = nl; path = nl.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2D2521F7FC0000268B /* nb */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = nb; path = nb.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2E2521F8550000268B /* pl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = pl; path = pl.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2F2521F8600000268B /* pt-BR */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"pt-BR\"; path = \"pt-BR.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t90F84F302521F8690000268B /* pt-PT */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"pt-PT\"; path = \"pt-PT.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t90F84F312521F8760000268B /* ru */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ru; path = ru.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F322521F87F0000268B /* sv */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = sv; path = sv.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F332521F8880000268B /* tr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = tr; path = tr.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t95241CE12573D587001E3711 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = \"<group>\"; };\n\t\t95241CF025749CC6001E3711 /* vim9type.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9type.c; path = ../vim9type.c; sourceTree = \"<group>\"; };\n\t\t95241CF125749CC6001E3711 /* help.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = help.c; path = ../help.c; sourceTree = \"<group>\"; };\n\t\t95241CF225749CC6001E3711 /* gui_xim.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui_xim.c; path = ../gui_xim.c; sourceTree = \"<group>\"; };\n\t\t95241CF325749CC7001E3711 /* job.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = job.c; path = ../job.c; sourceTree = \"<group>\"; };\n\t\t95241CF425749CC7001E3711 /* textformat.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textformat.c; path = ../textformat.c; sourceTree = \"<group>\"; };\n\t\t95241CF525749CC7001E3711 /* match.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = match.c; path = ../match.c; sourceTree = \"<group>\"; };\n\t\t95241CF625749CC7001E3711 /* locale.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = locale.c; path = ../locale.c; sourceTree = \"<group>\"; };\n\t\t95241CF725749CC7001E3711 /* typval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = typval.c; path = ../typval.c; sourceTree = \"<group>\"; };\n\t\t95241CF825749CC7001E3711 /* clientserver.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = clientserver.c; path = ../clientserver.c; sourceTree = \"<group>\"; };\n\t\t95241CF925749CC7001E3711 /* errors.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = errors.h; path = ../errors.h; sourceTree = \"<group>\"; };\n\t\t95241CFA25749CC7001E3711 /* textobject.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textobject.c; path = ../textobject.c; sourceTree = \"<group>\"; };\n\t\t95241CFB25749D4A001E3711 /* os_macosx.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; name = os_macosx.m; path = ../os_macosx.m; sourceTree = \"<group>\"; };\n/* End PBXFileReference section */\n\n/* Begin PBXFrameworksBuildPhase section */\n\t\t8D11072E0486CEB800E47090 /* Frameworks */ = {\n\t\t\tisa = PBXFrameworksBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t90B9877D2A579F9500FC95D6 /* WebKit.framework in Frameworks */,\n\t\t\t\t1DFE25A50C527BC4003000F7 /* PSMTabBarControl.framework in Frameworks */,\n\t\t\t\t8D11072F0486CEB800E47090 /* Cocoa.framework in Frameworks */,\n\t\t\t\t1D8B5A53104AF9FF002E59D5 /* Carbon.framework in Frameworks */,\n\t\t\t\t52A364731C4A5789005757EC /* Sparkle.framework in Frameworks */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXFrameworksBuildPhase section */\n\n/* Begin PBXGroup section */\n\t\t080E96DDFE201D6D7F000001 /* MacVim Source */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t9098943A2A56ECF6007B84A3 /* MMWhatsNewController.h */,\n\t\t\t\t9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */,\n\t\t\t\t1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */,\n\t\t\t\t1D6008890E96A0B2003763F0 /* MMFindReplaceController.h */,\n\t\t\t\t1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */,\n\t\t\t\t1DE63FF90E71820F00959BDB /* MMCoreTextView.h */,\n\t\t\t\t1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */,\n\t\t\t\t1D145C7D0E5227CE00691AA0 /* MMTextViewHelper.h */,\n\t\t\t\t1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */,\n\t\t\t\t1D8059220E118663001699D1 /* Miscellaneous.h */,\n\t\t\t\t1D80591D0E1185EA001699D1 /* Miscellaneous.m */,\n\t\t\t\t0395A8310D71ED7800881434 /* DBPrefsWindowController.h */,\n\t\t\t\t0395A8320D71ED7800881434 /* DBPrefsWindowController.m */,\n\t\t\t\t1DE3F8E80D50F84600052B9E /* MMPreferenceController.h */,\n\t\t\t\t1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */,\n\t\t\t\t1DE9B94D0D341AB8008FEDD4 /* MMWindow.h */,\n\t\t\t\t1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */,\n\t\t\t\t1D80FBCF0CBBD3B700102A1C /* MMFullScreenWindow.h */,\n\t\t\t\t1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */,\n\t\t\t\t1D80FBD10CBBD3B700102A1C /* MMVimView.h */,\n\t\t\t\t1D80FBD20CBBD3B700102A1C /* MMVimView.m */,\n\t\t\t\t1DD66ECB0C803D3600EBDAB3 /* MMApplication.h */,\n\t\t\t\t1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */,\n\t\t\t\t1D09AB3F0C6A4D520045497E /* MMTypesetter.h */,\n\t\t\t\t1D09AB400C6A4D520045497E /* MMTypesetter.m */,\n\t\t\t\t1D1474B90C567A910038FA2B /* MMWindowController.h */,\n\t\t\t\t1D1474BA0C567A910038FA2B /* MMWindowController.m */,\n\t\t\t\t1D1474B30C56796D0038FA2B /* MMVimController.h */,\n\t\t\t\t1D1474B40C56796D0038FA2B /* MMVimController.m */,\n\t\t\t\t1D1474AD0C5678370038FA2B /* MMTextView.h */,\n\t\t\t\t1D1474AE0C5678370038FA2B /* MMTextView.m */,\n\t\t\t\t1D1474A70C5677450038FA2B /* MMTextStorage.h */,\n\t\t\t\t1D1474A80C5677450038FA2B /* MMTextStorage.m */,\n\t\t\t\t1D14749D0C5673AE0038FA2B /* MMAppController.h */,\n\t\t\t\t1D14749E0C5673AE0038FA2B /* MMAppController.m */,\n\t\t\t\t1D1474950C56703C0038FA2B /* MacVim.h */,\n\t\t\t\t1D1474960C56703C0038FA2B /* MacVim.m */,\n\t\t\t\t32CA4F630368D1EE00C91783 /* MacVim_Prefix.pch */,\n\t\t\t\t29B97316FDCFA39411CA2CEA /* main.m */,\n\t\t\t\t90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */,\n\t\t\t\t90A33BEC28D56423003A2E2F /* MMSparkle2Delegate.h */,\n\t\t\t);\n\t\t\tname = \"MacVim Source\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1058C7A0FEA54F0111CA2CBB /* Linked Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */,\n\t\t\t);\n\t\t\tname = \"Linked Frameworks\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1058C7A2FEA54F0111CA2CBB /* Other Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t29B97324FDCFA39411CA2CEA /* AppKit.framework */,\n\t\t\t\t29B97325FDCFA39411CA2CEA /* Foundation.framework */,\n\t\t\t);\n\t\t\tname = \"Other Frameworks\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t19C28FACFE9D520D11CA2CBB /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t8D1107320486CEB800E47090 /* MacVim.app */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D0F11480D58C77800D5DA09 /* Font */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t);\n\t\t\tname = Font;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D493D640C52482B00AB718C /* Executables */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493D570C5247BF00AB718C /* Vim */,\n\t\t\t);\n\t\t\tname = Executables;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D493DB40C52533B00AB718C /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1DE602460C587F760055263D /* Vim Resources */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1DED785F0C6DE43D0079945F /* vimrc */,\n\t\t\t\t1DD0C20A0C60FF9A008CD84A /* gvimrc */,\n\t\t\t\t1DE602470C587FD10055263D /* runtime */,\n\t\t\t);\n\t\t\tname = \"Vim Resources\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1DE9726C0C48050600F96A9F /* Toolbar */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1DCD00AA0E50B2B700460166 /* Attention.png */,\n\t\t\t\t1DCD00AB0E50B2B700460166 /* Copy.png */,\n\t\t\t\t1DCD00AC0E50B2B700460166 /* Cut.png */,\n\t\t\t\t1DCD00AD0E50B2B700460166 /* FindHelp.png */,\n\t\t\t\t1DCD00AE0E50B2B700460166 /* FindNext.png */,\n\t\t\t\t1DCD00AF0E50B2B700460166 /* FindPrev.png */,\n\t\t\t\t1DCD00B00E50B2B700460166 /* Help.png */,\n\t\t\t\t1DCD00B10E50B2B700460166 /* LoadSesn.png */,\n\t\t\t\t1DCD00B20E50B2B700460166 /* Make.png */,\n\t\t\t\t1DCD00B30E50B2B700460166 /* Open.png */,\n\t\t\t\t1DCD00B40E50B2B700460166 /* Paste.png */,\n\t\t\t\t1DCD00B50E50B2B700460166 /* Print.png */,\n\t\t\t\t1DCD00B60E50B2B700460166 /* Redo.png */,\n\t\t\t\t1DCD00B70E50B2B700460166 /* Replace.png */,\n\t\t\t\t1DCD00B80E50B2B700460166 /* RunCtags.png */,\n\t\t\t\t1DCD00B90E50B2B700460166 /* RunScript.png */,\n\t\t\t\t1DCD00BA0E50B2B700460166 /* Save.png */,\n\t\t\t\t1DCD00BB0E50B2B700460166 /* SaveAll.png */,\n\t\t\t\t1DCD00BC0E50B2B700460166 /* SaveSesn.png */,\n\t\t\t\t1DCD00BD0E50B2B700460166 /* TagJump.png */,\n\t\t\t\t1DCD00BE0E50B2B700460166 /* Undo.png */,\n\t\t\t);\n\t\t\tname = Toolbar;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97314FDCFA39411CA2CEA /* MacVim */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493D640C52482B00AB718C /* Executables */,\n\t\t\t\t080E96DDFE201D6D7F000001 /* MacVim Source */,\n\t\t\t\t29B97317FDCFA39411CA2CEA /* Resources */,\n\t\t\t\t1DE602460C587F760055263D /* Vim Resources */,\n\t\t\t\t90922A3A221D417800F1E1F4 /* Vim Source */,\n\t\t\t\t29B97323FDCFA39411CA2CEA /* Frameworks */,\n\t\t\t\t52818AF81C1C073400F59085 /* QuickLook Plugin */,\n\t\t\t\t19C28FACFE9D520D11CA2CBB /* Products */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97317FDCFA39411CA2CEA /* Resources */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D384A0D100D671700D3C22F /* KeyBinding.plist */,\n\t\t\t\t1D9C602E0EF79C0C0034AD44 /* MacVim.icns */,\n\t\t\t\t0395A8A90D72D88B00881434 /* General.png */,\n\t\t\t\t1D22374A0E45DF4800E6FFFF /* Advanced.png */,\n\t\t\t\t1DD3D51D0D82D4C9006E4320 /* ibeam.png */,\n\t\t\t\t1D0F11480D58C77800D5DA09 /* Font */,\n\t\t\t\t1DE9726C0C48050600F96A9F /* Toolbar */,\n\t\t\t\t1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */,\n\t\t\t\t1DE8CC610C5E2AAD003F56E3 /* Actions.plist */,\n\t\t\t\t1DD04DEB0C529C5E006CDC2B /* Credits.rtf */,\n\t\t\t\t1D0E051B0BA5F83800B6049E /* Colors.plist */,\n\t\t\t\t8D1107310486CEB800E47090 /* Info.plist */,\n\t\t\t\t089C165CFE840E0CC02AAC07 /* InfoPlist.strings */,\n\t\t\t\t528DA6691426D4EB003380F1 /* macvim-askpass */,\n\t\t\t\t907FF7552521BDC200BADACB /* FindAndReplace.xib */,\n\t\t\t\t907FF7522521BDA600BADACB /* Preferences.xib */,\n\t\t\t\t907FF74F2521BCE200BADACB /* MainMenu.xib */,\n\t\t\t\t909894362A56EB1E007B84A3 /* WhatsNew.xib */,\n\t\t\t);\n\t\t\tname = Resources;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97323FDCFA39411CA2CEA /* Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90B9877B2A579F9500FC95D6 /* WebKit.framework */,\n\t\t\t\t52A364721C4A5789005757EC /* Sparkle.framework */,\n\t\t\t\t1D8B5A52104AF9FF002E59D5 /* Carbon.framework */,\n\t\t\t\t1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */,\n\t\t\t\t1058C7A0FEA54F0111CA2CBB /* Linked Frameworks */,\n\t\t\t\t1058C7A2FEA54F0111CA2CBB /* Other Frameworks */,\n\t\t\t);\n\t\t\tname = Frameworks;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t52818AF81C1C073400F59085 /* QuickLook Plugin */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */,\n\t\t\t);\n\t\t\tname = \"QuickLook Plugin\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t52818AFB1C1C075300F59085 /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t90922A3A221D417800F1E1F4 /* Vim Source */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90AF83B52AA15C660046DA2E /* alloc.c */,\n\t\t\t\t90AF83B42AA15C660046DA2E /* nv_cmdidxs.h */,\n\t\t\t\t90AF83B62AA15C660046DA2E /* nv_cmds.h */,\n\t\t\t\t90AF83B82AA15C660046DA2E /* termdefs.h */,\n\t\t\t\t90AF83B72AA15C660046DA2E /* vim9cmds.c */,\n\t\t\t\t90AF83B32AA15BE50046DA2E /* if_perl.xs */,\n\t\t\t\t90922A66221D429800F1E1F4 /* alloc.h */,\n\t\t\t\t90922A54221D429700F1E1F4 /* arabic.c */,\n\t\t\t\t901C070F2430C8CC00797C2A /* arglist.c */,\n\t\t\t\t90922AB0221D429C00F1E1F4 /* ascii.h */,\n\t\t\t\t90922AA1221D429C00F1E1F4 /* autocmd.c */,\n\t\t\t\t90922A65221D429800F1E1F4 /* beval.c */,\n\t\t\t\t90922A79221D429A00F1E1F4 /* beval.h */,\n\t\t\t\t90922A88221D429B00F1E1F4 /* blob.c */,\n\t\t\t\t90922A62221D429800F1E1F4 /* blowfish.c */,\n\t\t\t\t90922AA9221D429C00F1E1F4 /* buffer.c */,\n\t\t\t\t901C06FB2430C8C900797C2A /* bufwrite.c */,\n\t\t\t\t901C06F92430C8C900797C2A /* change.c */,\n\t\t\t\t90922A8A221D429B00F1E1F4 /* channel.c */,\n\t\t\t\t90922A93221D429B00F1E1F4 /* charset.c */,\n\t\t\t\t901C07002430C8CA00797C2A /* cindent.c */,\n\t\t\t\t95241CF825749CC7001E3711 /* clientserver.c */,\n\t\t\t\t901C07112430C8CC00797C2A /* clipboard.c */,\n\t\t\t\t901C07042430C8CA00797C2A /* cmdexpand.c */,\n\t\t\t\t901C06F82430C8C900797C2A /* cmdhist.c */,\n\t\t\t\t90922A56221D429700F1E1F4 /* crypt_zip.c */,\n\t\t\t\t90922A95221D429B00F1E1F4 /* crypt.c */,\n\t\t\t\t901C06FE2430C8CA00797C2A /* debugger.c */,\n\t\t\t\t90922A43221D429600F1E1F4 /* dict.c */,\n\t\t\t\t90922AB6221D429D00F1E1F4 /* diff.c */,\n\t\t\t\t90922A3E221D429500F1E1F4 /* digraph.c */,\n\t\t\t\t90922AAB221D429C00F1E1F4 /* dlldata.c */,\n\t\t\t\t90922A72221D429900F1E1F4 /* dosinst.c */,\n\t\t\t\t90922A6C221D429900F1E1F4 /* dosinst.h */,\n\t\t\t\t901C07032430C8CA00797C2A /* drawline.c */,\n\t\t\t\t901C06FD2430C8CA00797C2A /* drawscreen.c */,\n\t\t\t\t90922A7D221D429A00F1E1F4 /* edit.c */,\n\t\t\t\t95241CF925749CC7001E3711 /* errors.h */,\n\t\t\t\t90922A5B221D429700F1E1F4 /* eval.c */,\n\t\t\t\t901C07082430C8CB00797C2A /* evalbuffer.c */,\n\t\t\t\t90922A9B221D429C00F1E1F4 /* evalfunc.c */,\n\t\t\t\t901C06FC2430C8CA00797C2A /* evalvars.c */,\n\t\t\t\t901C06FA2430C8C900797C2A /* evalwindow.c */,\n\t\t\t\t90922A48221D429600F1E1F4 /* ex_cmdidxs.h */,\n\t\t\t\t90922AAD221D429C00F1E1F4 /* ex_cmds.c */,\n\t\t\t\t90922A8E221D429B00F1E1F4 /* ex_cmds.h */,\n\t\t\t\t90922A53221D429700F1E1F4 /* ex_cmds2.c */,\n\t\t\t\t90922A70221D429900F1E1F4 /* ex_docmd.c */,\n\t\t\t\t90922A4D221D429600F1E1F4 /* ex_eval.c */,\n\t\t\t\t90922A74221D429900F1E1F4 /* ex_getln.c */,\n\t\t\t\t90922AAE221D429C00F1E1F4 /* feature.h */,\n\t\t\t\t90922A6F221D429900F1E1F4 /* fileio.c */,\n\t\t\t\t901C07192430C8CD00797C2A /* filepath.c */,\n\t\t\t\t90922A80221D429A00F1E1F4 /* findfile.c */,\n\t\t\t\t90922A77221D429900F1E1F4 /* fold.c */,\n\t\t\t\t90922AA0221D429C00F1E1F4 /* getchar.c */,\n\t\t\t\t90922A82221D429A00F1E1F4 /* globals.h */,\n\t\t\t\t90922A55221D429700F1E1F4 /* gui_beval.c */,\n\t\t\t\t95241CF225749CC6001E3711 /* gui_xim.c */,\n\t\t\t\t90922A4C221D429600F1E1F4 /* gui.c */,\n\t\t\t\t90922A85221D429B00F1E1F4 /* gui.h */,\n\t\t\t\t90922A57221D429700F1E1F4 /* hardcopy.c */,\n\t\t\t\t90922A50221D429600F1E1F4 /* hashtab.c */,\n\t\t\t\t95241CF125749CC6001E3711 /* help.c */,\n\t\t\t\t901C07122430C8CC00797C2A /* highlight.c */,\n\t\t\t\t90922A6A221D429800F1E1F4 /* if_cscope.c */,\n\t\t\t\t90922AB4221D429C00F1E1F4 /* if_lua.c */,\n\t\t\t\t90922A3C221D429500F1E1F4 /* if_mzsch.c */,\n\t\t\t\t90922A89221D429B00F1E1F4 /* if_mzsch.h */,\n\t\t\t\t90922AA4221D429C00F1E1F4 /* if_ole.h */,\n\t\t\t\t90922A46221D429600F1E1F4 /* if_perlsfio.c */,\n\t\t\t\t90922A49221D429600F1E1F4 /* if_py_both.h */,\n\t\t\t\t90922A67221D429800F1E1F4 /* if_python.c */,\n\t\t\t\t90922A42221D429600F1E1F4 /* if_python3.c */,\n\t\t\t\t90922A71221D429900F1E1F4 /* if_ruby.c */,\n\t\t\t\t90922A87221D429B00F1E1F4 /* if_tcl.c */,\n\t\t\t\t90922A99221D429B00F1E1F4 /* if_xcmdsrv.c */,\n\t\t\t\t90922A7A221D429A00F1E1F4 /* iid_ole.c */,\n\t\t\t\t90922A8B221D429B00F1E1F4 /* indent.c */,\n\t\t\t\t901C070A2430C8CB00797C2A /* insexpand.c */,\n\t\t\t\t90922A41221D429500F1E1F4 /* iscygpty.c */,\n\t\t\t\t90922A52221D429600F1E1F4 /* iscygpty.h */,\n\t\t\t\t95241CF325749CC7001E3711 /* job.c */,\n\t\t\t\t90922A4F221D429600F1E1F4 /* json_test.c */,\n\t\t\t\t90922A9F221D429C00F1E1F4 /* json.c */,\n\t\t\t\t90922A40221D429500F1E1F4 /* keymap.h */,\n\t\t\t\t90922A45221D429600F1E1F4 /* kword_test.c */,\n\t\t\t\t90922A58221D429700F1E1F4 /* list.c */,\n\t\t\t\t95241CF625749CC7001E3711 /* locale.c */,\n\t\t\t\t90922A69221D429800F1E1F4 /* macros.h */,\n\t\t\t\t90922ABB221D42DC00F1E1F4 /* MacVim */,\n\t\t\t\t90922A8D221D429B00F1E1F4 /* main.c */,\n\t\t\t\t901C06F42430C8C800797C2A /* map.c */,\n\t\t\t\t90922A4B221D429600F1E1F4 /* mark.c */,\n\t\t\t\t95241CF525749CC7001E3711 /* match.c */,\n\t\t\t\t90922A7C221D429A00F1E1F4 /* mbyte.c */,\n\t\t\t\t90922AB2221D429C00F1E1F4 /* memfile_test.c */,\n\t\t\t\t90922A51221D429600F1E1F4 /* memfile.c */,\n\t\t\t\t90922A6D221D429900F1E1F4 /* memline.c */,\n\t\t\t\t90922A78221D429A00F1E1F4 /* menu.c */,\n\t\t\t\t90922A5F221D429700F1E1F4 /* message_test.c */,\n\t\t\t\t90922A63221D429800F1E1F4 /* message.c */,\n\t\t\t\t90922AA2221D429C00F1E1F4 /* misc1.c */,\n\t\t\t\t90922A3B221D429500F1E1F4 /* misc2.c */,\n\t\t\t\t901C07152430C8CC00797C2A /* mouse.c */,\n\t\t\t\t90922AA6221D429C00F1E1F4 /* move.c */,\n\t\t\t\t90922A4A221D429600F1E1F4 /* nbdebug.c */,\n\t\t\t\t90922A5E221D429700F1E1F4 /* nbdebug.h */,\n\t\t\t\t90922A4E221D429600F1E1F4 /* netbeans.c */,\n\t\t\t\t90922AA3221D429C00F1E1F4 /* normal.c */,\n\t\t\t\t90922A73221D429900F1E1F4 /* ops.c */,\n\t\t\t\t90922A83221D429A00F1E1F4 /* option.c */,\n\t\t\t\t90922AB1221D429C00F1E1F4 /* option.h */,\n\t\t\t\t901C07162430C8CD00797C2A /* optiondefs.h */,\n\t\t\t\t901C07172430C8CD00797C2A /* optionstr.c */,\n\t\t\t\t90922AAF221D429C00F1E1F4 /* os_mac_conv.c */,\n\t\t\t\t90922A5D221D429700F1E1F4 /* os_mac.h */,\n\t\t\t\t95241CFB25749D4A001E3711 /* os_macosx.m */,\n\t\t\t\t90922AA7221D429C00F1E1F4 /* os_unix.c */,\n\t\t\t\t90922A8C221D429B00F1E1F4 /* os_unix.h */,\n\t\t\t\t901C06FF2430C8CA00797C2A /* popupmenu.c */,\n\t\t\t\t901C07022430C8CA00797C2A /* popupwin.c */,\n\t\t\t\t901C070B2430C8CB00797C2A /* profiler.c */,\n\t\t\t\t90922A6E221D429900F1E1F4 /* proto.h */,\n\t\t\t\t90922A68221D429800F1E1F4 /* protodef.h */,\n\t\t\t\t90922A47221D429600F1E1F4 /* pty.c */,\n\t\t\t\t90922A94221D429B00F1E1F4 /* quickfix.c */,\n\t\t\t\t901C07142430C8CC00797C2A /* regexp_bt.c */,\n\t\t\t\t90922A90221D429B00F1E1F4 /* regexp_nfa.c */,\n\t\t\t\t90922AB7221D429D00F1E1F4 /* regexp.c */,\n\t\t\t\t90922A92221D429B00F1E1F4 /* regexp.h */,\n\t\t\t\t901C07062430C8CB00797C2A /* register.c */,\n\t\t\t\t90922A9D221D429C00F1E1F4 /* screen.c */,\n\t\t\t\t901C07052430C8CB00797C2A /* scriptfile.c */,\n\t\t\t\t90922A7E221D429A00F1E1F4 /* search.c */,\n\t\t\t\t901C071A2430C8CD00797C2A /* session.c */,\n\t\t\t\t90922A9C221D429C00F1E1F4 /* sha256.c */,\n\t\t\t\t90922AAC221D429C00F1E1F4 /* sign.c */,\n\t\t\t\t901C070D2430C8CC00797C2A /* sound.c */,\n\t\t\t\t90922AA8221D429C00F1E1F4 /* spell.c */,\n\t\t\t\t90922A7B221D429A00F1E1F4 /* spell.h */,\n\t\t\t\t90922AB3221D429C00F1E1F4 /* spellfile.c */,\n\t\t\t\t901C07092430C8CB00797C2A /* spellsuggest.c */,\n\t\t\t\t90922AB5221D429D00F1E1F4 /* structs.h */,\n\t\t\t\t90922A97221D429B00F1E1F4 /* syntax.c */,\n\t\t\t\t90922A60221D429800F1E1F4 /* tag.c */,\n\t\t\t\t90922A84221D429B00F1E1F4 /* term.c */,\n\t\t\t\t90922ABA221D429D00F1E1F4 /* term.h */,\n\t\t\t\t90922AB9221D429D00F1E1F4 /* terminal.c */,\n\t\t\t\t90922A64221D429800F1E1F4 /* termlib.c */,\n\t\t\t\t901C06F72430C8C900797C2A /* testing.c */,\n\t\t\t\t95241CF425749CC7001E3711 /* textformat.c */,\n\t\t\t\t95241CFA25749CC7001E3711 /* textobject.c */,\n\t\t\t\t90922A91221D429B00F1E1F4 /* textprop.c */,\n\t\t\t\t901C06F62430C8C900797C2A /* time.c */,\n\t\t\t\t95241CF725749CC7001E3711 /* typval.c */,\n\t\t\t\t90922A76221D429900F1E1F4 /* ui.c */,\n\t\t\t\t90922A7F221D429A00F1E1F4 /* undo.c */,\n\t\t\t\t901C07132430C8CC00797C2A /* uninstall.c */,\n\t\t\t\t901C07012430C8CA00797C2A /* usercmd.c */,\n\t\t\t\t90922A5C221D429700F1E1F4 /* userfunc.c */,\n\t\t\t\t90922AB8221D429D00F1E1F4 /* version.c */,\n\t\t\t\t90922A3D221D429500F1E1F4 /* version.h */,\n\t\t\t\t90922A96221D429B00F1E1F4 /* vim.h */,\n\t\t\t\t901C070E2430C8CC00797C2A /* vim9.h */,\n\t\t\t\t901C070C2430C8CB00797C2A /* vim9compile.c */,\n\t\t\t\t901C07072430C8CB00797C2A /* vim9execute.c */,\n\t\t\t\t901C07102430C8CC00797C2A /* vim9script.c */,\n\t\t\t\t95241CF025749CC6001E3711 /* vim9type.c */,\n\t\t\t\t901C07182430C8CD00797C2A /* viminfo.c */,\n\t\t\t\t90922A81221D429A00F1E1F4 /* vimrun.c */,\n\t\t\t\t90922AAA221D429C00F1E1F4 /* window.c */,\n\t\t\t);\n\t\t\tname = \"Vim Source\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t90922ABB221D42DC00F1E1F4 /* MacVim */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90922ABD221D42F700F1E1F4 /* gui_macvim.m */,\n\t\t\t\t90922ABC221D42F700F1E1F4 /* MMBackend.h */,\n\t\t\t\t90922ABE221D42F700F1E1F4 /* MMBackend.m */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n/* End PBXGroup section */\n\n/* Begin PBXNativeTarget section */\n\t\t8D1107260486CEB800E47090 /* MacVim */ = {\n\t\t\tisa = PBXNativeTarget;\n\t\t\tbuildConfigurationList = C01FCF4A08A954540054247B /* Build configuration list for PBXNativeTarget \"MacVim\" */;\n\t\t\tbuildPhases = (\n\t\t\t\t8D1107290486CEB800E47090 /* Resources */,\n\t\t\t\t8D11072C0486CEB800E47090 /* Sources */,\n\t\t\t\t8D11072E0486CEB800E47090 /* Frameworks */,\n\t\t\t\t1D0DCAD80BA3604D00B6CCFA /* Copy Executables */,\n\t\t\t\t1D9EB2840C366D7B0074B739 /* Copy Frameworks */,\n\t\t\t\t52818B021C1C088000F59085 /* Copy QuickLookPlugin */,\n\t\t\t\t1DE608B80C58807F0055263D /* Copy default vimrc files */,\n\t\t\t\t9050374C2AAEFA2500E9846A /* Generate runtime folder list */,\n\t\t\t\t90BD4EF224E0E8B700BF29F2 /* Copy Vim runtime / localization files */,\n\t\t\t\t1D1C31F00EFFBFD6003FE9A5 /* Make Document Icons */,\n\t\t\t\t528DA6671426D456003380F1 /* Copy Scripts */,\n\t\t\t\t52283AB71EBA200C00A6F6B9 /* Copy mvim scripts */,\n\t\t\t\t90C052E1251E889500E2D81E /* Copy vimtutor */,\n\t\t\t\t9099B3CA2914B272005C9F32 /* Clean up build */,\n\t\t\t);\n\t\t\tbuildRules = (\n\t\t\t);\n\t\t\tdependencies = (\n\t\t\t\t1D493DCD0C5254A400AB718C /* PBXTargetDependency */,\n\t\t\t\t52818B011C1C084100F59085 /* PBXTargetDependency */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tproductInstallPath = \"$(HOME)/Applications\";\n\t\t\tproductName = MacVim;\n\t\t\tproductReference = 8D1107320486CEB800E47090 /* MacVim.app */;\n\t\t\tproductType = \"com.apple.product-type.application\";\n\t\t};\n/* End PBXNativeTarget section */\n\n/* Begin PBXProject section */\n\t\t29B97313FDCFA39411CA2CEA /* Project object */ = {\n\t\t\tisa = PBXProject;\n\t\t\tattributes = {\n\t\t\t\tBuildIndependentTargetsInParallel = YES;\n\t\t\t\tLastUpgradeCheck = 0710;\n\t\t\t};\n\t\t\tbuildConfigurationList = C01FCF4E08A954540054247B /* Build configuration list for PBXProject \"MacVim\" */;\n\t\t\tcompatibilityVersion = \"Xcode 6.3\";\n\t\t\tdevelopmentRegion = en;\n\t\t\thasScannedForEncodings = 1;\n\t\t\tknownRegions = (\n\t\t\t\tBase,\n\t\t\t\t\"zh-Hant\",\n\t\t\t\t\"zh-Hans\",\n\t\t\t\tja,\n\t\t\t\tko,\n\t\t\t\tca,\n\t\t\t\tcs,\n\t\t\t\tda,\n\t\t\t\tde,\n\t\t\t\tes,\n\t\t\t\tfi,\n\t\t\t\tfr,\n\t\t\t\thu,\n\t\t\t\tit,\n\t\t\t\tnl,\n\t\t\t\tnb,\n\t\t\t\tpl,\n\t\t\t\t\"pt-BR\",\n\t\t\t\t\"pt-PT\",\n\t\t\t\tru,\n\t\t\t\tsv,\n\t\t\t\ttr,\n\t\t\t\ten,\n\t\t\t);\n\t\t\tmainGroup = 29B97314FDCFA39411CA2CEA /* MacVim */;\n\t\t\tprojectDirPath = \"\";\n\t\t\tprojectReferences = (\n\t\t\t\t{\n\t\t\t\t\tProductGroup = 1D493DB40C52533B00AB718C /* Products */;\n\t\t\t\t\tProjectRef = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tProductGroup = 52818AFB1C1C075300F59085 /* Products */;\n\t\t\t\t\tProjectRef = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\t\t},\n\t\t\t);\n\t\t\tprojectRoot = \"\";\n\t\t\ttargets = (\n\t\t\t\t8D1107260486CEB800E47090 /* MacVim */,\n\t\t\t);\n\t\t};\n/* End PBXProject section */\n\n/* Begin PBXReferenceProxy section */\n\t\t1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */ = {\n\t\t\tisa = PBXReferenceProxy;\n\t\t\tfileType = wrapper.framework;\n\t\t\tpath = PSMTabBarControl.framework;\n\t\t\tremoteRef = 1D493DB80C52533B00AB718C /* PBXContainerItemProxy */;\n\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n\t\t};\n\t\t52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */ = {\n\t\t\tisa = PBXReferenceProxy;\n\t\t\tfileType = wrapper.cfbundle;\n\t\t\tpath = QLStephen.qlgenerator;\n\t\t\tremoteRef = 52818AFE1C1C075300F59085 /* PBXContainerItemProxy */;\n\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n\t\t};\n/* End PBXReferenceProxy section */\n\n/* Begin PBXResourcesBuildPhase section */\n\t\t8D1107290486CEB800E47090 /* Resources */ = {\n\t\t\tisa = PBXResourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */,\n\t\t\t\t1D0E051C0BA5F83800B6049E /* Colors.plist in Resources */,\n\t\t\t\t1DD04DEC0C529C5E006CDC2B /* Credits.rtf in Resources */,\n\t\t\t\t1DE8CC620C5E2AAD003F56E3 /* Actions.plist in Resources */,\n\t\t\t\t1DD9F5E50C85D60500E8D5A5 /* SystemColors.plist in Resources */,\n\t\t\t\t0395A8AA0D72D88B00881434 /* General.png in Resources */,\n\t\t\t\t1DD3D51E0D82D4C9006E4320 /* ibeam.png in Resources */,\n\t\t\t\t1D22374B0E45DF4800E6FFFF /* Advanced.png in Resources */,\n\t\t\t\t1DCD00BF0E50B2B700460166 /* Attention.png in Resources */,\n\t\t\t\t1DCD00C00E50B2B700460166 /* Copy.png in Resources */,\n\t\t\t\t1DCD00C10E50B2B700460166 /* Cut.png in Resources */,\n\t\t\t\t1DCD00C20E50B2B700460166 /* FindHelp.png in Resources */,\n\t\t\t\t1DCD00C30E50B2B700460166 /* FindNext.png in Resources */,\n\t\t\t\t1DCD00C40E50B2B700460166 /* FindPrev.png in Resources */,\n\t\t\t\t1DCD00C50E50B2B700460166 /* Help.png in Resources */,\n\t\t\t\t1DCD00C60E50B2B700460166 /* LoadSesn.png in Resources */,\n\t\t\t\t1DCD00C70E50B2B700460166 /* Make.png in Resources */,\n\t\t\t\t1DCD00C80E50B2B700460166 /* Open.png in Resources */,\n\t\t\t\t1DCD00C90E50B2B700460166 /* Paste.png in Resources */,\n\t\t\t\t1DCD00CA0E50B2B700460166 /* Print.png in Resources */,\n\t\t\t\t1DCD00CB0E50B2B700460166 /* Redo.png in Resources */,\n\t\t\t\t1DCD00CC0E50B2B700460166 /* Replace.png in Resources */,\n\t\t\t\t1DCD00CD0E50B2B700460166 /* RunCtags.png in Resources */,\n\t\t\t\t1DCD00CE0E50B2B700460166 /* RunScript.png in Resources */,\n\t\t\t\t1DCD00CF0E50B2B700460166 /* Save.png in Resources */,\n\t\t\t\t1DCD00D00E50B2B700460166 /* SaveAll.png in Resources */,\n\t\t\t\t1DCD00D10E50B2B700460166 /* SaveSesn.png in Resources */,\n\t\t\t\t909894382A56EB1E007B84A3 /* WhatsNew.xib in Resources */,\n\t\t\t\t1DCD00D20E50B2B700460166 /* TagJump.png in Resources */,\n\t\t\t\t1DCD00D30E50B2B700460166 /* Undo.png in Resources */,\n\t\t\t\t1D9C60520EF79C0C0034AD44 /* MacVim.icns in Resources */,\n\t\t\t\t1D384A0E100D671700D3C22F /* KeyBinding.plist in Resources */,\n\t\t\t\t907FF7542521BDA600BADACB /* Preferences.xib in Resources */,\n\t\t\t\t907FF7512521BCE200BADACB /* MainMenu.xib in Resources */,\n\t\t\t\t907FF7572521BDC300BADACB /* FindAndReplace.xib in Resources */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXResourcesBuildPhase section */\n\n/* Begin PBXShellScriptBuildPhase section */\n\t\t1D1C31F00EFFBFD6003FE9A5 /* Make Document Icons */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"$(PROJECT_DIR)/icons\",\n\t\t\t);\n\t\t\tname = \"Make Document Icons\";\n\t\t\toutputPaths = (\n\t\t\t\t\"$(TARGET_BUILD_DIR)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH)\",\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# Clear deployment target, else the python script always thinks we're building on Tiger\\nunset MACOSX_DEPLOYMENT_TARGET\\n\\n# Generate the icons (redirect stderr to ignore warnings)\\ncd \\\"$PROJECT_DIR\\\"/icons/\\nmake OUTDIR=\\\"$TARGET_BUILD_DIR\\\"/$UNLOCALIZED_RESOURCES_FOLDER_PATH 2> /dev/null\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t52283AB71EBA200C00A6F6B9 /* Copy mvim scripts */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"${SRCROOT}/mvim\",\n\t\t\t);\n\t\t\tname = \"Copy mvim scripts\";\n\t\t\toutputPaths = (\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/mvim,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"BINPATH=$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin\\nmkdir -p \\\"${BINPATH}\\\"\\ncp -a \\\"${SRCROOT}/mvim\\\" \\\"${BINPATH}/mvim\\\"\\nchmod 755 \\\"${BINPATH}/mvim\\\"\\n(cd \\\"${BINPATH}\\\"; for f in vim vimdiff view gvim gvimdiff gview mvimdiff mview; do ln -fs mvim $f; done)\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t9050374C2AAEFA2500E9846A /* Generate runtime folder list */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\talwaysOutOfDate = 1;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t);\n\t\t\tname = \"Generate runtime folder list\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t\"$(OBJROOT)/runtime_folder_list.xcfilelist\",\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# Generate a list of folders that will affect the runtime folder output, so\\n# that incremental build can use it to only install them if the runtime folders\\n# have changed. The main reason we have to manually generate it is because\\n# Xcode's \\\"Input File Lists\\\" doesn't support recursion/wildcards.\\n\\nfind -s ../../runtime -type d > \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist\\n\\nif cmp -s \\\"${OBJROOT}\\\"/runtime_folder_list.xcfilelist \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist; then\\n    rm \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist\\nelse\\n    mv -f \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist \\\"${OBJROOT}\\\"/runtime_folder_list.xcfilelist\\nfi\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t9099B3CA2914B272005C9F32 /* Clean up build */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\talwaysOutOfDate = 1;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t);\n\t\t\tname = \"Clean up build\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"./scripts/cleanup-after-build \\\"$BUILT_PRODUCTS_DIR/$WRAPPER_NAME\\\" \\\"$REMOVE_SPARKLE\\\"\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t90BD4EF224E0E8B700BF29F2 /* Copy Vim runtime / localization files */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t\t$OBJROOT/runtime_folder_list.xcfilelist,\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"$(SRCROOT)/../xxd/xxd\",\n\t\t\t\t\"$(SRCROOT)/../po\",\n\t\t\t);\n\t\t\tname = \"Copy Vim runtime / localization files\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t$TARGET_BUILD_DIR/$UNLOCALIZED_RESOURCES_FOLDER_PATH/vim/runtime,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/zsh;\n\t\t\tshellScript = \"# Copy the runtime files to the app bundle, under Resources/vim/runtime folder.\\n# We cannot do a direct copy of the runtime folder as it contains misc test\\n# scripts and also man pages and we should use the Vim's defined rules to\\n# install them properly.\\n\\n# Note that this will also install man pages, under a \\\"man\\\" folder. This is\\n# useful if the user really wants to point their man page to MacVim's verison\\n# instead of builtin Vim, using MANPATH=/Applications/MacVim.app/Contents/man).\\n\\n# prefix: Reset to empty as it's set to /Applications for fallback rt-folder\\n# VIMNAME: Use the default \\\"vim\\\" to make sure man pages use that instead of \\\"Vim\\\"\\n# VIMRTDIR: Make sure to use \\\"runtime\\\" as by default it uses a \\\"vim90\\\" style folder which is mostly a relic.\\n\\ncd \\\"${SRCROOT}\\\"/..\\nmake \\\\\\n    DESTDIR=\\\"${TARGET_BUILD_DIR}\\\" \\\\\\n    prefix= \\\\\\n    VIMNAME=vim \\\\\\n    VIMRTDIR=/runtime \\\\\\n    macvim-install-runtime\\n\\n# Also add man pages for \\\"mvim\\\"\\nfor curdir in \\\"$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH\\\"/man/**/man1; do\\n    (cd $curdir; ln -f -s gvim.1 mvim.1)\\ndone\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t90C052E1251E889500E2D81E /* Copy vimtutor */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"${SRCROOT}/../vimtutor\",\n\t\t\t\t\"${SRCROOT}/../gvimtutor\",\n\t\t\t);\n\t\t\tname = \"Copy vimtutor\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/vimtutor,\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/gvimtutor,\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/mvimtutor,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# We could potentially use make installtutorbin installgtutorbin\\n# but this works and we need to do the symlink anyway.\\nBINPATH=$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin\\nmkdir -p \\\"${BINPATH}\\\"\\ncp -a \\\"${SRCROOT}/../vimtutor\\\" \\\"${BINPATH}/vimtutor\\\"\\ncp -a \\\"${SRCROOT}/../gvimtutor\\\" \\\"${BINPATH}/gvimtutor\\\"\\nchmod 755 \\\"${BINPATH}/vimtutor\\\"\\nchmod 755 \\\"${BINPATH}/gvimtutor\\\"\\ncd \\\"${BINPATH}\\\"\\nln -fs gvimtutor mvimtutor \\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n/* End PBXShellScriptBuildPhase section */\n\n/* Begin PBXSourcesBuildPhase section */\n\t\t8D11072C0486CEB800E47090 /* Sources */ = {\n\t\t\tisa = PBXSourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t8D11072D0486CEB800E47090 /* main.m in Sources */,\n\t\t\t\t1D1474980C56703C0038FA2B /* MacVim.m in Sources */,\n\t\t\t\t1D1474A00C5673AE0038FA2B /* MMAppController.m in Sources */,\n\t\t\t\t1D1474AA0C5677450038FA2B /* MMTextStorage.m in Sources */,\n\t\t\t\t1D1474B00C5678370038FA2B /* MMTextView.m in Sources */,\n\t\t\t\t1D1474B60C56796D0038FA2B /* MMVimController.m in Sources */,\n\t\t\t\t1D1474BC0C567A910038FA2B /* MMWindowController.m in Sources */,\n\t\t\t\t1D09AB420C6A4D520045497E /* MMTypesetter.m in Sources */,\n\t\t\t\t90A33BEA28D563DF003A2E2F /* MMSparkle2Delegate.m in Sources */,\n\t\t\t\t1DD66ECE0C803D3600EBDAB3 /* MMApplication.m in Sources */,\n\t\t\t\t1D80FBD40CBBD3B700102A1C /* MMFullScreenWindow.m in Sources */,\n\t\t\t\t1D80FBD60CBBD3B700102A1C /* MMVimView.m in Sources */,\n\t\t\t\t1DE9B9500D341AB8008FEDD4 /* MMWindow.m in Sources */,\n\t\t\t\t1DE3F8EB0D50F84600052B9E /* MMPreferenceController.m in Sources */,\n\t\t\t\t0395A8330D71ED7800881434 /* DBPrefsWindowController.m in Sources */,\n\t\t\t\t1D80591F0E1185EA001699D1 /* Miscellaneous.m in Sources */,\n\t\t\t\t9098943C2A56ECF6007B84A3 /* MMWhatsNewController.m in Sources */,\n\t\t\t\t1D145C7F0E5227CE00691AA0 /* MMTextViewHelper.m in Sources */,\n\t\t\t\t1D60088B0E96A0B2003763F0 /* MMFindReplaceController.m in Sources */,\n\t\t\t\t1DE63FFB0E71820F00959BDB /* MMCoreTextView.m in Sources */,\n\t\t\t\t1D44972211FCA9B400B0630F /* MMCoreTextView+ToolTip.m in Sources */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXSourcesBuildPhase section */\n\n/* Begin PBXTargetDependency section */\n\t\t1D493DCD0C5254A400AB718C /* PBXTargetDependency */ = {\n\t\t\tisa = PBXTargetDependency;\n\t\t\tname = PSMTabBarControlFramework;\n\t\t\ttargetProxy = 1D493DCC0C5254A400AB718C /* PBXContainerItemProxy */;\n\t\t};\n\t\t52818B011C1C084100F59085 /* PBXTargetDependency */ = {\n\t\t\tisa = PBXTargetDependency;\n\t\t\tname = QuickLookStephen;\n\t\t\ttargetProxy = 52818B001C1C084100F59085 /* PBXContainerItemProxy */;\n\t\t};\n/* End PBXTargetDependency section */\n\n/* Begin PBXVariantGroup section */\n\t\t089C165CFE840E0CC02AAC07 /* InfoPlist.strings */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t95241CE12573D587001E3711 /* en */,\n\t\t\t);\n\t\t\tname = InfoPlist.strings;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF74F2521BCE200BADACB /* MainMenu.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75C2521C0A000BADACB /* Base */,\n\t\t\t\t907FF7622521C2FB00BADACB /* zh-Hant */,\n\t\t\t\t907FF7632521CBAC00BADACB /* zh-Hans */,\n\t\t\t\t907FF7642521CBC500BADACB /* ja */,\n\t\t\t\t90F84F1E2521F2270000268B /* ko */,\n\t\t\t\t90F84F232521F6480000268B /* ca */,\n\t\t\t\t90F84F242521F6590000268B /* cs */,\n\t\t\t\t90F84F252521F6670000268B /* da */,\n\t\t\t\t90F84F262521F69A0000268B /* de */,\n\t\t\t\t90F84F272521F6A70000268B /* es */,\n\t\t\t\t90F84F282521F6B10000268B /* fi */,\n\t\t\t\t90F84F292521F6C10000268B /* fr */,\n\t\t\t\t90F84F2A2521F6CB0000268B /* hu */,\n\t\t\t\t90F84F2B2521F6D60000268B /* it */,\n\t\t\t\t90F84F2C2521F6E30000268B /* nl */,\n\t\t\t\t90F84F2D2521F7FC0000268B /* nb */,\n\t\t\t\t90F84F2E2521F8550000268B /* pl */,\n\t\t\t\t90F84F2F2521F8600000268B /* pt-BR */,\n\t\t\t\t90F84F302521F8690000268B /* pt-PT */,\n\t\t\t\t90F84F312521F8760000268B /* ru */,\n\t\t\t\t90F84F322521F87F0000268B /* sv */,\n\t\t\t\t90F84F332521F8880000268B /* tr */,\n\t\t\t);\n\t\t\tname = MainMenu.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF7522521BDA600BADACB /* Preferences.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75B2521C09F00BADACB /* Base */,\n\t\t\t);\n\t\t\tname = Preferences.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF7552521BDC200BADACB /* FindAndReplace.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75A2521C09F00BADACB /* Base */,\n\t\t\t);\n\t\t\tname = FindAndReplace.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t909894362A56EB1E007B84A3 /* WhatsNew.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t909894372A56EB1E007B84A3 /* Base */,\n\t\t\t);\n\t\t\tname = WhatsNew.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n/* End PBXVariantGroup section */\n\n/* Begin XCBuildConfiguration section */\n\t\tC01FCF4B08A954540054247B /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tCOPY_PHASE_STRIP = NO;\n\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n\t\t\t\t\t\"$(inherited)\",\n\t\t\t\t\t\"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)\",\n\t\t\t\t\t\"$(PROJECT_DIR)\",\n\t\t\t\t);\n\t\t\t\tFRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = \"\\\"$(SRCROOT)\\\"\";\n\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n\t\t\t\tGCC_ENABLE_FIX_AND_CONTINUE = YES;\n\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n\t\t\t\tGCC_MODEL_TUNING = G5;\n\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n\t\t\t\tGCC_VERSION = \"\";\n\t\t\t\tGCC_WARN_PEDANTIC = NO;\n\t\t\t\tHEADER_SEARCH_PATHS = \"\";\n\t\t\t\tINFOPLIST_FILE = Info.plist;\n\t\t\t\tINSTALL_PATH = \"$(HOME)/Applications\";\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"@loader_path/../Frameworks\";\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = \"\";\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = org.vim.MacVim;\n\t\t\t\tPRODUCT_NAME = MacVim;\n\t\t\t\tVERSIONING_SYSTEM = \"apple-generic\";\n\t\t\t\tWARNING_CFLAGS = \"-Wall\";\n\t\t\t\tWRAPPER_EXTENSION = app;\n\t\t\t\tZERO_LINK = NO;\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\tC01FCF4C08A954540054247B /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tCOPY_PHASE_STRIP = YES;\n\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n\t\t\t\t\t\"$(inherited)\",\n\t\t\t\t\t\"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)\",\n\t\t\t\t\t\"$(PROJECT_DIR)\",\n\t\t\t\t);\n\t\t\t\tFRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = \"\\\"$(SRCROOT)\\\"\";\n\t\t\t\tGCC_DYNAMIC_NO_PIC = YES;\n\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n\t\t\t\tGCC_GENERATE_DEBUGGING_SYMBOLS = NO;\n\t\t\t\tGCC_MODEL_TUNING = G5;\n\t\t\t\tGCC_OPTIMIZATION_LEVEL = s;\n\t\t\t\tGCC_VERSION = \"\";\n\t\t\t\tHEADER_SEARCH_PATHS = \"\";\n\t\t\t\tINFOPLIST_FILE = Info.plist;\n\t\t\t\tINSTALL_PATH = \"$(HOME)/Applications\";\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"@loader_path/../Frameworks\";\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = \"\";\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = org.vim.MacVim;\n\t\t\t\tPRODUCT_NAME = MacVim;\n\t\t\t\tVERSIONING_SYSTEM = \"apple-generic\";\n\t\t\t\tWRAPPER_EXTENSION = app;\n\t\t\t\tZERO_LINK = NO;\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n\t\tC01FCF4F08A954540054247B /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;\n\t\t\t\tENABLE_TESTABILITY = YES;\n\t\t\t\tGCC_VERSION = 4.2;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPREBINDING = NO;\n\t\t\t\tSYMROOT = \"$(PROJECT_DIR)/build\";\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\tC01FCF5008A954540054247B /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;\n\t\t\t\tGCC_VERSION = 4.2;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPREBINDING = NO;\n\t\t\t\tSYMROOT = \"$(PROJECT_DIR)/build\";\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n/* End XCBuildConfiguration section */\n\n/* Begin XCConfigurationList section */\n\t\tC01FCF4A08A954540054247B /* Build configuration list for PBXNativeTarget \"MacVim\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\tC01FCF4B08A954540054247B /* Debug */,\n\t\t\t\tC01FCF4C08A954540054247B /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n\t\tC01FCF4E08A954540054247B /* Build configuration list for PBXProject \"MacVim\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\tC01FCF4F08A954540054247B /* Debug */,\n\t\t\t\tC01FCF5008A954540054247B /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n/* End XCConfigurationList section */\n\t};\n\trootObject = 29B97313FDCFA39411CA2CEA /* Project object */;\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * MMAppController\n *\n * MMAppController is the delegate of NSApp and as such handles file open\n * requests, application termination, etc.  It sets up a named NSConnection on\n * which it listens to incoming connections from Vim processes.  It also\n * coordinates all MMVimControllers and takes care of the main menu.\n *\n * A new Vim process is started by calling launchVimProcessWithArguments:.\n * When the Vim process is initialized it notifies the app controller by\n * sending a connectBackend:pid: message.  At this point a new MMVimController\n * is allocated.  Afterwards, the Vim process communicates directly with its\n * MMVimController.\n *\n * A Vim process started from the command line connects directly by sending the\n * connectBackend:pid: message (launchVimProcessWithArguments: is never called\n * in this case).\n *\n * The main menu is handled as follows.  Each Vim controller keeps its own main\n * menu.  All menus except the \"MacVim\" menu are controlled by the Vim process.\n * The app controller also keeps a reference to the \"default main menu\" which\n * is set up in MainMenu.nib.  When no editor window is open the default main\n * menu is used.  When a new editor window becomes main its main menu becomes\n * the new main menu, this is done in -[MMAppController setMainMenu:].\n *   NOTE: Certain heuristics are used to find the \"MacVim\", \"Windows\", \"File\",\n * and \"Services\" menu.  If MainMenu.nib changes these heuristics may have to\n * change as well.  For specifics see the find... methods defined in the NSMenu\n * category \"MMExtras\".\n */\n\n#import \"MMAppController.h\"\n#import \"MMPreferenceController.h\"\n#import \"MMVimController.h\"\n#import \"MMVimView.h\"\n#import \"MMWindowController.h\"\n#import \"MMTextView.h\"\n#import \"MMWhatsNewController.h\"\n#import \"Miscellaneous.h\"\n#import <unistd.h>\n#import <CoreServices/CoreServices.h>\n// Need Carbon for TIS...() functions\n#import <Carbon/Carbon.h>\n\n#if !DISABLE_SPARKLE\n#import \"MMSparkle2Delegate.h\"\n#import \"Sparkle.framework/Headers/Sparkle.h\"\n#endif\n\n\n#define MM_HANDLE_XCODE_MOD_EVENT 0\n\n\n\n// Default timeout intervals on all connections.\nstatic NSTimeInterval MMRequestTimeout = 5;\nstatic NSTimeInterval MMReplyTimeout = 5;\n\nstatic NSString *MMWebsiteString = @\"https://macvim-dev.github.io/macvim/\";\n\n// Latency (in s) between FS event occuring and being reported to MacVim.\n// Should be small so that MacVim is notified of changes to the ~/.vim\n// directory more or less immediately.\nstatic CFTimeInterval MMEventStreamLatency = 0.1;\n\nstatic float MMCascadeHorizontalOffset = 21;\nstatic float MMCascadeVerticalOffset = 23;\n\n\n#pragma pack(push,1)\n// The alignment and sizes of these fields are based on trial-and-error.  It\n// may be necessary to adjust them to fit if Xcode ever changes this struct.\ntypedef struct\n{\n    int16_t unused1;      // 0 (not used)\n    int16_t lineNum;      // line to select (< 0 to specify range)\n    int32_t startRange;   // start of selection range (if line < 0)\n    int32_t endRange;     // end of selection range (if line < 0)\n    int32_t unused2;      // 0 (not used)\n    int32_t theDate;      // modification date/time\n} MMXcodeSelectionRange;\n#pragma pack(pop)\n\n\n// This is a private AppKit API gleaned from class-dump.\n@interface NSKeyBindingManager : NSObject\n+ (id)sharedKeyBindingManager;\n- (id)dictionary;\n- (void)setDictionary:(id)arg1;\n@end\n\n\n@interface MMAppController (MMServices)\n- (void)openSelection:(NSPasteboard *)pboard userData:(NSString *)userData\n                error:(NSString **)error;\n- (void)openFile:(NSPasteboard *)pboard userData:(NSString *)userData\n           error:(NSString **)error;\n- (void)newFileHere:(NSPasteboard *)pboard userData:(NSString *)userData\n              error:(NSString **)error;\n@end\n\n\n@interface MMAppController (Private)\n- (void)startUpdaterAndWhatsNewPage;\n\n- (MMVimController *)topmostVimController;\n- (int)launchVimProcessWithArguments:(NSArray *)args\n                    workingDirectory:(NSString *)cwd;\n- (NSArray *)filterFilesAndNotify:(NSArray *)files;\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n               openFilesDict:(NSDictionary **)openFiles;\n#if MM_HANDLE_XCODE_MOD_EVENT\n- (void)handleXcodeModEvent:(NSAppleEventDescriptor *)event\n                 replyEvent:(NSAppleEventDescriptor *)reply;\n#endif\n- (void)handleGetURLEvent:(NSAppleEventDescriptor *)event\n               replyEvent:(NSAppleEventDescriptor *)reply;\n- (NSMutableDictionary *)extractArgumentsFromOdocEvent:\n    (NSAppleEventDescriptor *)desc;\n- (void)scheduleVimControllerPreloadAfterDelay:(NSTimeInterval)delay;\n- (void)cancelVimControllerPreloadRequests;\n- (void)preloadVimController:(id)sender;\n- (int)maxPreloadCacheSize;\n- (MMVimController *)takeVimControllerFromCache;\n- (void)clearPreloadCacheWithCount:(int)count;\n- (void)rebuildPreloadCache;\n- (NSDate *)rcFilesModificationDate;\n- (BOOL)openVimControllerWithArguments:(NSDictionary *)arguments;\n- (void)activateWhenNextWindowOpens;\n- (void)startWatchingVimDir;\n- (void)stopWatchingVimDir;\n- (void)handleFSEvent;\n- (int)executeInLoginShell:(NSString *)path arguments:(NSArray *)args;\n- (void)reapChildProcesses:(id)sender;\n- (void)processInputQueues:(id)sender;\n- (void)addVimController:(MMVimController *)vc;\n- (NSDictionary *)convertVimControllerArguments:(NSDictionary *)args\n                                  toCommandLine:(NSArray **)cmdline;\n- (NSString *)workingDirectoryForArguments:(NSDictionary *)args;\n- (NSScreen *)screenContainingTopLeftPoint:(NSPoint)pt;\n- (void)addInputSourceChangedObserver;\n- (void)removeInputSourceChangedObserver;\n- (void)inputSourceChanged:(NSNotification *)notification;\n@end\n\n\n\n    static void\nfsEventCallback(ConstFSEventStreamRef streamRef,\n                void *clientCallBackInfo,\n                size_t numEvents,\n                void *eventPaths,\n                const FSEventStreamEventFlags eventFlags[],\n                const FSEventStreamEventId eventIds[])\n{\n    [[MMAppController sharedInstance] handleFSEvent];\n}\n\n@implementation MMAppController\n\n+ (void)initialize\n{\n    static BOOL initDone = NO;\n    if (initDone) return;\n    initDone = YES;\n\n    ASLInit();\n\n    // HACK! The following user default must be reset, else Ctrl-q (or\n    // whichever key is specified by the default) will be blocked by the input\n    // manager (interpretKeyEvents: swallows that key).  (We can't use\n    // NSUserDefaults since it only allows us to write to the registration\n    // domain and this preference has \"higher precedence\" than that so such a\n    // change would have no effect.)\n    CFPreferencesSetAppValue(CFSTR(\"NSQuotedKeystrokeBinding\"),\n                             CFSTR(\"\"),\n                             kCFPreferencesCurrentApplication);\n\n    // Also disable NSRepeatCountBinding -- it is not enabled by default, but\n    // it does not make much sense to support it since Vim has its own way of\n    // dealing with repeat counts.\n    CFPreferencesSetAppValue(CFSTR(\"NSRepeatCountBinding\"),\n                             CFSTR(\"\"),\n                             kCFPreferencesCurrentApplication);\n\n    if ([NSWindow respondsToSelector:@selector(setAllowsAutomaticWindowTabbing:)]) {\n        // Disable automatic tabbing on 10.12+. MacVim already has its own\n        // tabbing interface, so we don't want multiple hierarchy of tabs mixing\n        // native and Vim tabs. MacVim also doesn't work well with native tabs\n        // right now since it doesn't respond well to the size change, and it\n        // doesn't show the native menu items (e.g. move tab to new window) in\n        // all the tabs.\n        //\n        // Note: MacVim cannot use macOS native tabs for Vim tabs because Vim\n        // assumes only one tab can be shown at a time, and it would be hard to\n        // handle native tab's \"move tab to a new window\" functionality.\n        [NSWindow setAllowsAutomaticWindowTabbing:NO];\n    }\n\n    int tabMinWidthKey;\n    int tabMaxWidthKey;\n    int tabOptimumWidthKey;\n    if (shouldUseYosemiteTabBarStyle()) {\n        tabMinWidthKey = 120;\n        tabMaxWidthKey = 0;\n        tabOptimumWidthKey = 0;\n    } else {\n        tabMinWidthKey = 64;\n        tabMaxWidthKey = 6*64;\n        tabOptimumWidthKey = 132;\n    }\n\n    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:\n        [NSNumber numberWithBool:NO],     MMNoWindowKey,\n        [NSNumber numberWithInt:tabMinWidthKey],\n                                          MMTabMinWidthKey,\n        [NSNumber numberWithInt:tabMaxWidthKey],\n                                          MMTabMaxWidthKey,\n        [NSNumber numberWithInt:tabOptimumWidthKey],\n                                          MMTabOptimumWidthKey,\n        [NSNumber numberWithBool:YES],    MMShowAddTabButtonKey,\n        [NSNumber numberWithInt:2],       MMTextInsetLeftKey,\n        [NSNumber numberWithInt:1],       MMTextInsetRightKey,\n        [NSNumber numberWithInt:1],       MMTextInsetTopKey,\n        [NSNumber numberWithInt:1],       MMTextInsetBottomKey,\n        @\"MMTypesetter\",                  MMTypesetterKey,\n        [NSNumber numberWithFloat:1],     MMCellWidthMultiplierKey,\n        [NSNumber numberWithFloat:-1],    MMBaselineOffsetKey,\n        [NSNumber numberWithBool:YES],    MMTranslateCtrlClickKey,\n        [NSNumber numberWithInt:0],       MMOpenInCurrentWindowKey,\n        [NSNumber numberWithBool:NO],     MMNoFontSubstitutionKey,\n        [NSNumber numberWithBool:YES],    MMFontPreserveLineSpacingKey,\n        [NSNumber numberWithBool:YES],    MMLoginShellKey,\n        [NSNumber numberWithInt:MMRendererCoreText],\n                                          MMRendererKey,\n        [NSNumber numberWithInt:MMUntitledWindowAlways],\n                                          MMUntitledWindowKey,\n        [NSNumber numberWithBool:NO],     MMNoWindowShadowKey,\n        [NSNumber numberWithBool:NO],     MMZoomBothKey,\n        @\"\",                              MMLoginShellCommandKey,\n        @\"\",                              MMLoginShellArgumentKey,\n        [NSNumber numberWithBool:YES],    MMDialogsTrackPwdKey,\n        [NSNumber numberWithInt:3],       MMOpenLayoutKey,\n        [NSNumber numberWithBool:NO],     MMVerticalSplitKey,\n        [NSNumber numberWithInt:0],       MMPreloadCacheSizeKey,\n        [NSNumber numberWithInt:0],       MMLastWindowClosedBehaviorKey,\n#ifdef INCLUDE_OLD_IM_CODE\n        [NSNumber numberWithBool:YES],    MMUseInlineImKey,\n#endif // INCLUDE_OLD_IM_CODE\n        [NSNumber numberWithBool:NO],     MMSuppressTerminationAlertKey,\n        [NSNumber numberWithBool:YES],    MMNativeFullScreenKey,\n        [NSNumber numberWithDouble:0.0],  MMFullScreenFadeTimeKey,\n        [NSNumber numberWithBool:NO],     MMNonNativeFullScreenShowMenuKey,\n        [NSNumber numberWithInt:0],       MMNonNativeFullScreenSafeAreaBehaviorKey,\n        [NSNumber numberWithBool:YES],    MMShareFindPboardKey,\n        [NSNumber numberWithBool:NO],     MMSmoothResizeKey,\n        [NSNumber numberWithBool:NO],     MMCmdLineAlignBottomKey,\n        [NSNumber numberWithBool:NO],     MMRendererClipToRowKey,\n        [NSNumber numberWithBool:YES],    MMAllowForceClickLookUpKey,\n        [NSNumber numberWithBool:NO],     MMUpdaterPrereleaseChannelKey,\n        @\"\",                              MMLastUsedBundleVersionKey,\n        [NSNumber numberWithBool:YES],    MMShowWhatsNewOnStartupKey,\n        nil];\n\n    [[NSUserDefaults standardUserDefaults] registerDefaults:dict];\n\n    NSArray *types = [NSArray arrayWithObject:NSPasteboardTypeString];\n    [NSApp registerServicesMenuSendTypes:types returnTypes:types];\n\n    // NOTE: Set the current directory to user's home directory, otherwise it\n    // will default to the root directory.  (This matters since new Vim\n    // processes inherit MacVim's environment variables.)\n    [[NSFileManager defaultManager] changeCurrentDirectoryPath:\n            NSHomeDirectory()];\n}\n\n- (id)init\n{\n    if (!(self = [super init])) return nil;\n\n#if (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)\n    // Disable automatic relaunching\n    if ([NSApp respondsToSelector:@selector(disableRelaunchOnLogin)])\n        [NSApp disableRelaunchOnLogin];\n#endif\n\n    vimControllers = [NSMutableArray new];\n    cachedVimControllers = [NSMutableArray new];\n    preloadPid = -1;\n    pidArguments = [NSMutableDictionary new];\n    inputQueues = [NSMutableDictionary new];\n\n    // NOTE: Do not use the default connection since the Logitech Control\n    // Center (LCC) input manager steals and this would cause MacVim to\n    // never open any windows.  (This is a bug in LCC but since they are\n    // unlikely to fix it, we graciously give them the default connection.)\n    connection = [[NSConnection alloc] initWithReceivePort:[NSPort port]\n                                                  sendPort:nil];\n    NSProtocolChecker *rootObject = [NSProtocolChecker protocolCheckerWithTarget:self\n                                                                        protocol:@protocol(MMAppProtocol)];\n    [connection setRootObject:rootObject];\n    [connection setRequestTimeout:MMRequestTimeout];\n    [connection setReplyTimeout:MMReplyTimeout];\n\n    // NOTE!  If the name of the connection changes here it must also be\n    // updated in MMBackend.m.\n    NSString *name = [NSString stringWithFormat:@\"%@-connection\",\n             [[NSBundle mainBundle] bundlePath]];\n    if (![connection registerName:name]) {\n        ASLogCrit(@\"Failed to register connection with name '%@'\", name);\n        [connection release];  connection = nil;\n\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n            @\"Dialog button\")];\n        [alert setMessageText:NSLocalizedString(@\"MacVim cannot be opened\",\n            @\"MacVim cannot be opened, title\")];\n        [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n            @\"MacVim could not set up its connection. It's likely you already have MacVim opened elsewhere.\",\n            @\"MacVim already opened, text\")]];\n        [alert setAlertStyle:NSAlertStyleCritical];\n        [alert runModal];\n        [alert release];\n\n        [[NSApplication sharedApplication] terminate:nil];\n    }\n\n    // Register help search handler to support search Vim docs via the Help menu\n    [NSApp registerUserInterfaceItemSearchHandler:self];\n\n#if !DISABLE_SPARKLE\n    // Sparkle is enabled (this is the default). Initialize it. It will\n    // automatically check for update.\n#if USE_SPARKLE_1\n    updater = [[SUUpdater alloc] init];\n#else\n    sparkle2delegate = [[MMSparkle2Delegate alloc] init];\n\n    // We don't immediately start the updater, because if it sees an update\n    // and immediately shows the dialog box it will pop up behind a new MacVim\n    // window. Instead, startUpdaterAndWhatsNewPage will be called later to do so.\n    updater = [[SPUStandardUpdaterController alloc] initWithStartingUpdater:NO updaterDelegate:sparkle2delegate userDriverDelegate:sparkle2delegate];\n#endif\n#endif\n\n    return self;\n}\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    [connection release];  connection = nil;\n    [inputQueues release];  inputQueues = nil;\n    [pidArguments release];  pidArguments = nil;\n    [vimControllers release];  vimControllers = nil;\n    [cachedVimControllers release];  cachedVimControllers = nil;\n    [openSelectionString release];  openSelectionString = nil;\n    [recentFilesMenuItem release];  recentFilesMenuItem = nil;\n    [defaultMainMenu release];  defaultMainMenu = nil;\n    currentMainMenu = nil;\n    [appMenuItemTemplate release];  appMenuItemTemplate = nil;\n#if !DISABLE_SPARKLE\n    [updater release];  updater = nil;\n#if !USE_SPARKLE_1\n    [sparkle2delegate release];  sparkle2delegate = nil;\n#endif\n#endif\n\n    [super dealloc];\n}\n\n- (void)applicationWillFinishLaunching:(NSNotification *)notification\n{\n    // This prevents macOS from injecting \"Enter Full Screen\" menu item.\n    // MacVim already has a separate menu item to do that.\n    // See https://developer.apple.com/library/archive/releasenotes/AppKit/RN-AppKitOlderNotes/index.html#10_11FullScreen\n    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@\"NSFullScreenMenuItemEverywhere\"];\n\n    // Remember the default menu so that it can be restored if the user closes\n    // all editor windows.\n    defaultMainMenu = [[NSApp mainMenu] retain];\n\n    // Store a copy of the default app menu so we can use this as a template\n    // for all other menus.  We make a copy here because the \"Services\" menu\n    // will not yet have been populated at this time.  If we don't we get\n    // problems trying to set key equivalents later on because they might clash\n    // with items on the \"Services\" menu.\n    appMenuItemTemplate = [defaultMainMenu itemAtIndex:0];\n    appMenuItemTemplate = [appMenuItemTemplate copy];\n\n    // Set up the \"Open Recent\" menu. See\n    //   http://lapcatsoftware.com/blog/2007/07/10/\n    //     working-without-a-nib-part-5-open-recent-menu/\n    // and\n    //   http://www.cocoabuilder.com/archive/message/cocoa/2007/8/15/187793\n    // for more information.\n    //\n    // The menu itself is created in MainMenu.nib but we still seem to have to\n    // hack around a bit to get it to work.  (This has to be done in\n    // applicationWillFinishLaunching at the latest, otherwise it doesn't\n    // work.)\n    NSMenu *fileMenu = [defaultMainMenu findFileMenu];\n    if (fileMenu) {\n        int idx = [fileMenu indexOfItemWithAction:@selector(fileOpen:)];\n        if (idx >= 0 && idx+1 < [fileMenu numberOfItems])\n\n        recentFilesMenuItem = [fileMenu itemWithTag:15432];\n        [[recentFilesMenuItem submenu] performSelector:@selector(_setMenuName:)\n                                        withObject:@\"NSRecentDocumentsMenu\"];\n\n        // Note: The \"Recent Files\" menu must be moved around since there is no\n        // -[NSApp setRecentFilesMenu:] method.  We keep a reference to it to\n        // facilitate this move (see setMainMenu: below).\n        [recentFilesMenuItem retain];\n    }\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n    [[NSAppleEventManager sharedAppleEventManager]\n            setEventHandler:self\n                andSelector:@selector(handleXcodeModEvent:replyEvent:)\n              forEventClass:'KAHL'\n                 andEventID:'MOD '];\n#endif\n\n    // Register 'mvim://' URL handler\n    [[NSAppleEventManager sharedAppleEventManager]\n            setEventHandler:self\n                andSelector:@selector(handleGetURLEvent:replyEvent:)\n              forEventClass:kInternetEventClass\n                 andEventID:kAEGetURL];\n\n    // Disable the default Cocoa \"Key Bindings\" since they interfere with the\n    // way Vim handles keyboard input.  Cocoa reads bindings from\n    //     /System/Library/Frameworks/AppKit.framework/Resources/\n    //                                                  StandardKeyBinding.dict\n    // and\n    //     ~/Library/KeyBindings/DefaultKeyBinding.dict\n    // To avoid having the user accidentally break keyboard handling (by\n    // modifying the latter in some unexpected way) in MacVim we load our own\n    // key binding dictionary from Resource/KeyBinding.plist.  We can't disable\n    // the bindings completely since it would break keyboard handling in\n    // dialogs so the our custom dictionary contains all the entries from the\n    // former location.\n    //\n    // It is possible to disable key bindings completely by not calling\n    // interpretKeyEvents: in keyDown: but this also disables key bindings used\n    // by certain input methods.  E.g.  Ctrl-Shift-; would no longer work in\n    // the Kotoeri input manager.\n    //\n    // To solve this problem we access a private API and set the key binding\n    // dictionary to our own custom dictionary here.  At this time Cocoa will\n    // have already read the above mentioned dictionaries so it (hopefully)\n    // won't try to change the key binding dictionary again after this point.\n    NSKeyBindingManager *mgr = [NSKeyBindingManager sharedKeyBindingManager];\n    NSBundle *mainBundle = [NSBundle mainBundle];\n    NSString *path = [mainBundle pathForResource:@\"KeyBinding\"\n                                          ofType:@\"plist\"];\n    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];\n    if (mgr && dict) {\n        [mgr setDictionary:dict];\n    } else {\n        ASLogNotice(@\"Failed to override the Cocoa key bindings.  Keyboard \"\n                \"input may behave strangely as a result (path=%@).\", path);\n    }\n}\n\n- (void)applicationDidFinishLaunching:(NSNotification *)notification\n{\n    [NSApp setServicesProvider:self];\n\n    if ([self maxPreloadCacheSize] > 0) {\n        [self scheduleVimControllerPreloadAfterDelay:2];\n        [self startWatchingVimDir];\n    }\n\n    [self addInputSourceChangedObserver];\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    NSString *lastUsedVersion = [ud stringForKey:MMLastUsedBundleVersionKey];\n    NSString *currentVersion = [[NSBundle mainBundle] objectForInfoDictionaryKey:\n            @\"CFBundleVersion\"];\n    // This will be used for showing a \"What's New\" dialog box in the future. For\n    // now, just update the stored version for future use so later versions will\n    // be able to tell whether to show this dialog box or not.\n    if (currentVersion && currentVersion.length != 0) {\n        if (!lastUsedVersion || [lastUsedVersion length] == 0) {\n            [ud setValue:currentVersion forKey:MMLastUsedBundleVersionKey];\n        } else {\n            // If the current version is larger, set that to be stored. Don't\n            // want to do it otherwise to prevent testing older versions flipping\n            // the stored version back to an old one.\n            NSArray<NSString*> *lastUsedVersionItems = [lastUsedVersion componentsSeparatedByString:@\".\"];\n            NSArray<NSString*> *currentVersionItems = [currentVersion componentsSeparatedByString:@\".\"];\n            // Compare two arrays lexographically. We just assume that version\n            // numbers are also X.Y.Z\u2026 with no \"beta\" etc texts.\n            bool currentVersionLarger = NO;\n            for (int i = 0; i < currentVersionItems.count && i < lastUsedVersionItems.count; i++) {\n                if (i >= currentVersionItems.count) {\n                    currentVersionLarger = NO;\n                    break;\n                }\n                if (i >= lastUsedVersionItems.count) {\n                    currentVersionLarger = YES;\n                    break;\n                }\n                if (currentVersionItems[i].integerValue > lastUsedVersionItems[i].integerValue) {\n                    currentVersionLarger = YES;\n                    break;\n                }\n                else if (currentVersionItems[i].integerValue < lastUsedVersionItems[i].integerValue) {\n                    currentVersionLarger = NO;\n                    break;\n                }\n            }\n\n            if (currentVersionLarger) {\n                [ud setValue:currentVersion forKey:MMLastUsedBundleVersionKey];\n\n                // We have successfully updated to a new version. Show a \"What's\n                // New\" page to the user with latest release notes if the main\n                // release number has increased (we don't count the pre-release\n                // minor revision number for now).\n                if (lastUsedVersionItems[0].integerValue < currentVersionItems[0].integerValue) {\n\n                    BOOL showWhatsNewSetting = [ud boolForKey:MMShowWhatsNewOnStartupKey];\n\n                    shouldShowWhatsNewPage = showWhatsNewSetting;\n                    [MMWhatsNewController setRequestVersionRange:lastUsedVersion\n                                                              to:currentVersion];\n                }\n            }\n        }\n    }\n\n    // Start the Sparkle updater and potentially show \"What's New\". If the user\n    // doesn't want a new untitled MacVim window shown, we immediately do so.\n    // Otherwise we want to do it *after* the untitled window is opened so the\n    // updater / \"What's New\" page can be shown on top of it. We still schedule\n    // a timer to open it as a backup in case something wrong happened with the\n    // Vim window (e.g. a crash in Vim) but we still want the updater to work since\n    // that update may very well be the fix for the crash.\n    const NSInteger untitledWindowFlag = [ud integerForKey:MMUntitledWindowKey];\n    if ((untitledWindowFlag & MMUntitledWindowOnOpen) == 0) {\n        [self startUpdaterAndWhatsNewPage];\n    } else {\n        // Per above, this is just a backup. startUpdaterAndWhatsNewPage will\n        // not do anything if it's called a second time.\n        [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(startUpdaterAndWhatsNewPage) userInfo:nil repeats:NO];\n    }\n\n    ASLogInfo(@\"MacVim finished launching\");\n}\n\n- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender\n{\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    NSAppleEventManager *aem = [NSAppleEventManager sharedAppleEventManager];\n    NSAppleEventDescriptor *desc = [aem currentAppleEvent];\n\n    // The user default MMUntitledWindow can be set to control whether an\n    // untitled window should open on 'Open' and 'Reopen' events.\n    int untitledWindowFlag = [ud integerForKey:MMUntitledWindowKey];\n\n    BOOL isAppOpenEvent = [desc eventID] == kAEOpenApplication;\n    if (isAppOpenEvent && (untitledWindowFlag & MMUntitledWindowOnOpen) == 0)\n        return NO;\n\n    BOOL isAppReopenEvent = [desc eventID] == kAEReopenApplication;\n    if (isAppReopenEvent\n            && (untitledWindowFlag & MMUntitledWindowOnReopen) == 0)\n        return NO;\n\n    // When a process is started from the command line, the 'Open' event may\n    // contain a parameter to surpress the opening of an untitled window.\n    desc = [desc paramDescriptorForKeyword:keyAEPropData];\n    desc = [desc paramDescriptorForKeyword:keyMMUntitledWindow];\n    if (desc && ![desc booleanValue])\n        return NO;\n\n    // Never open an untitled window if there is at least one open window.\n    if ([vimControllers count] > 0)\n        return NO;\n\n    // Don't open an untitled window if there are processes about to launch...\n    NSUInteger numLaunching = [pidArguments count];\n    if (numLaunching > 0) {\n        // ...unless the launching process is being preloaded\n        NSNumber *key = [NSNumber numberWithInt:preloadPid];\n        if (numLaunching != 1 || [pidArguments objectForKey:key] == nil)\n            return NO;\n    }\n\n    // NOTE!  This way it possible to start the app with the command-line\n    // argument '-nowindow yes' and no window will be opened by default but\n    // this argument will only be heeded when the application is opening.\n    if (isAppOpenEvent && [ud boolForKey:MMNoWindowKey] == YES)\n        return NO;\n\n    return YES;\n}\n\n- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender\n{\n    ASLogDebug(@\"Opening untitled window...\");\n    [self newWindow:self];\n    return YES;\n}\n\n- (void)application:(NSApplication *)sender openFiles:(NSArray *)filenames\n{\n    ASLogInfo(@\"Opening files %@\", filenames);\n\n    // Extract ODB/Xcode/Spotlight parameters from the current Apple event,\n    // sort the filenames, and then let openFiles:withArguments: do the heavy\n    // lifting.\n\n    if (!(filenames && [filenames count] > 0))\n        return;\n\n    // Sort filenames since the Finder doesn't take care in preserving the\n    // order in which files are selected anyway (and \"sorted\" is more\n    // predictable than \"random\").\n    if ([filenames count] > 1)\n        filenames = [filenames sortedArrayUsingSelector:\n                @selector(localizedCompare:)];\n\n    // Extract ODB/Xcode/Spotlight parameters from the current Apple event\n    NSMutableDictionary *arguments = [self extractArgumentsFromOdocEvent:\n            [[NSAppleEventManager sharedAppleEventManager] currentAppleEvent]];\n\n    if ([self openFiles:filenames withArguments:arguments]) {\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplySuccess];\n    } else {\n        // TODO: Notify user of failure?\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplyFailure];\n    }\n}\n\n- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender\n{\n    if (!hasShownWindowBefore) {\n        // If we have not opened a window before, never return YES. This can\n        // happen when MacVim is not configured to open window at launch. We\n        // want to give the user a chance to open a window first. Otherwise\n        // just opening the About MacVim or Settings windows could immediately\n        // terminate the app (since those are not proper app windows),\n        // depending if the OS feels like invoking this method.\n        return NO;\n    }\n    return (MMTerminateWhenLastWindowClosed ==\n            [[NSUserDefaults standardUserDefaults]\n                integerForKey:MMLastWindowClosedBehaviorKey]);\n}\n\n- (NSApplicationTerminateReply)applicationShouldTerminate:\n    (NSApplication *)sender\n{\n    // TODO: Follow Apple's guidelines for 'Graceful Application Termination'\n    // (in particular, allow user to review changes and save).\n    int reply = NSTerminateNow;\n    BOOL modifiedBuffers = NO;\n\n    // Go through Vim controllers, checking for modified buffers.\n    NSEnumerator *e = [vimControllers objectEnumerator];\n    id vc;\n    while ((vc = [e nextObject])) {\n        if ([vc hasModifiedBuffer]) {\n            modifiedBuffers = YES;\n            break;\n        }\n    }\n\n    if (modifiedBuffers) {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert setAlertStyle:NSAlertStyleWarning];\n        [alert addButtonWithTitle:NSLocalizedString(@\"Quit\",\n                @\"Dialog button\")];\n        [alert addButtonWithTitle:NSLocalizedString(@\"Cancel\",\n                @\"Dialog button\")];\n        [alert setMessageText:NSLocalizedString(@\"Quit without saving?\",\n                @\"Quit dialog with changed buffers, title\")];\n        [alert setInformativeText:NSLocalizedString(\n                @\"There are modified buffers, \"\n                \"if you quit now all changes will be lost.  Quit anyway?\",\n                @\"Quit dialog with changed buffers, text\")];\n\n        if ([alert runModal] != NSAlertFirstButtonReturn)\n            reply = NSTerminateCancel;\n\n        [alert release];\n    } else if (![[NSUserDefaults standardUserDefaults]\n                                boolForKey:MMSuppressTerminationAlertKey]) {\n        // No unmodified buffers, but give a warning if there are multiple\n        // windows and/or tabs open.\n        int numWindows = [vimControllers count];\n        int numTabs = 0;\n\n        // Count the number of open tabs\n        e = [vimControllers objectEnumerator];\n        while ((vc = [e nextObject]))\n            numTabs += [[vc objectForVimStateKey:@\"numTabs\"] intValue];\n\n        if (numWindows > 1 || numTabs > 1) {\n            NSAlert *alert = [[NSAlert alloc] init];\n            [alert setAlertStyle:NSAlertStyleWarning];\n            [alert addButtonWithTitle:NSLocalizedString(@\"Quit\",\n                    @\"Dialog button\")];\n            [alert addButtonWithTitle:NSLocalizedString(@\"Cancel\",\n                    @\"Dialog button\")];\n            [alert setMessageText:NSLocalizedString(\n                    @\"Are you sure you want to quit MacVim?\",\n                    @\"Quit dialog with no changed buffers, title\")];\n            [alert setShowsSuppressionButton:YES];\n\n            NSString *info = nil;\n            if (numWindows > 1) {\n                if (numTabs > numWindows)\n                    info = [NSString stringWithFormat:NSLocalizedString(\n                            @\"There are %d windows open in MacVim, with a \"\n                            \"total of %d tabs. Do you want to quit anyway?\",\n                            @\"Quit dialog with no changed buffers, text\"),\n                         numWindows, numTabs];\n                else\n                    info = [NSString stringWithFormat:NSLocalizedString(\n                            @\"There are %d windows open in MacVim. \"\n                            \"Do you want to quit anyway?\",\n                            @\"Quit dialog with no changed buffers, text\"),\n                        numWindows];\n\n            } else {\n                info = [NSString stringWithFormat:NSLocalizedString(\n                        @\"There are %d tabs open in MacVim. \"\n                        \"Do you want to quit anyway?\",\n                        @\"Quit dialog with no changed buffers, text\"), \n                     numTabs];\n            }\n\n            [alert setInformativeText:info];\n\n            if ([alert runModal] != NSAlertFirstButtonReturn)\n                reply = NSTerminateCancel;\n\n            if ([[alert suppressionButton] state] == NSControlStateValueOn) {\n                [[NSUserDefaults standardUserDefaults]\n                            setBool:YES forKey:MMSuppressTerminationAlertKey];\n            }\n\n            [alert release];\n        }\n    }\n\n\n    // Tell all Vim processes to terminate now (otherwise they'll leave swap\n    // files behind).\n    if (NSTerminateNow == reply) {\n        e = [vimControllers objectEnumerator];\n        id vc;\n        while ((vc = [e nextObject])) {\n            ASLogDebug(@\"Terminate pid=%d\", [vc pid]);\n            [vc sendMessage:TerminateNowMsgID data:nil];\n        }\n\n        e = [cachedVimControllers objectEnumerator];\n        while ((vc = [e nextObject])) {\n            ASLogDebug(@\"Terminate pid=%d (cached)\", [vc pid]);\n            [vc sendMessage:TerminateNowMsgID data:nil];\n        }\n\n        // If a Vim process is being preloaded as we quit we have to forcibly\n        // kill it since we have not established a connection yet.\n        if (preloadPid > 0) {\n            ASLogDebug(@\"Kill incomplete preloaded process pid=%d\", preloadPid);\n            kill(preloadPid, SIGKILL);\n        }\n\n        // If a Vim process was loading as we quit we also have to kill it.\n        e = [[pidArguments allKeys] objectEnumerator];\n        NSNumber *pidKey;\n        while ((pidKey = [e nextObject])) {\n            ASLogDebug(@\"Kill incomplete process pid=%d\", [pidKey intValue]);\n            kill([pidKey intValue], SIGKILL);\n        }\n\n        // Sleep a little to allow all the Vim processes to exit.\n        usleep(10000);\n    }\n\n    return reply;\n}\n\n- (void)applicationWillTerminate:(NSNotification *)notification\n{\n    ASLogInfo(@\"Terminating MacVim...\");\n\n    [self removeInputSourceChangedObserver];\n\n    [self stopWatchingVimDir];\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n    [[NSAppleEventManager sharedAppleEventManager]\n            removeEventHandlerForEventClass:'KAHL'\n                                 andEventID:'MOD '];\n#endif\n\n    // We are hard shutting down the app here by terminating all Vim processes\n    // and then just quit without cleanly removing each Vim controller. We\n    // don't want the straggler controllers to still interact with the now\n    // invalid connections, so we just mark them as uninitialized.\n    for (NSUInteger i = 0, count = [vimControllers count]; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc uninitialize];\n    }\n\n    // This will invalidate all connections (since they were spawned from this\n    // connection).\n    [connection invalidate];\n\n    [NSApp setDelegate:nil];\n\n    // Try to wait for all child processes to avoid leaving zombies behind (but\n    // don't wait around for too long).\n    NSDate *timeOutDate = [NSDate dateWithTimeIntervalSinceNow:2];\n    while ([timeOutDate timeIntervalSinceNow] > 0) {\n        [self reapChildProcesses:nil];\n        if (numChildProcesses <= 0)\n            break;\n\n        ASLogDebug(@\"%d processes still left, hold on...\", numChildProcesses);\n\n        // Run in NSConnectionReplyMode while waiting instead of calling e.g.\n        // usleep().  Otherwise incoming messages may clog up the DO queues and\n        // the outgoing TerminateNowMsgID sent earlier never reaches the Vim\n        // process.\n        // This has at least one side-effect, namely we may receive the\n        // annoying \"dropping incoming DO message\".  (E.g. this may happen if\n        // you quickly hit Cmd-n several times in a row and then immediately\n        // press Cmd-q, Enter.)\n        while (CFRunLoopRunInMode((CFStringRef)NSConnectionReplyMode,\n                0.05, true) == kCFRunLoopRunHandledSource)\n            ;   // do nothing\n    }\n\n    if (numChildProcesses > 0) {\n        ASLogNotice(@\"%d zombies left behind\", numChildProcesses);\n    }\n}\n\n+ (MMAppController *)sharedInstance\n{\n    // Note: The app controller is a singleton which is instantiated in\n    // MainMenu.nib where it is also connected as the delegate of NSApp.\n    id delegate = [NSApp delegate];\n    return [delegate isKindOfClass:self] ? (MMAppController*)delegate : nil;\n}\n\n- (NSMenu *)defaultMainMenu\n{\n    return defaultMainMenu;\n}\n\n- (NSMenuItem *)appMenuItemTemplate\n{\n    return appMenuItemTemplate;\n}\n\n- (void)removeVimController:(id)controller\n{\n    ASLogDebug(@\"Remove Vim controller pid=%d id=%lu (processingFlag=%d)\",\n               [controller pid], [controller vimControllerId], processingFlag);\n\n    NSUInteger idx = [vimControllers indexOfObject:controller];\n    if (NSNotFound == idx) {\n        ASLogDebug(@\"Controller not found, probably due to duplicate removal\");\n        return;\n    }\n\n    [controller retain];\n    [vimControllers removeObjectAtIndex:idx];\n    [controller cleanup];\n    [controller release];\n\n    if (![vimControllers count]) {\n        // The last editor window just closed so restore the main menu back to\n        // its default state (which is defined in MainMenu.nib).\n        [self setMainMenu:defaultMainMenu];\n\n        BOOL hide = (MMHideWhenLastWindowClosed ==\n                    [[NSUserDefaults standardUserDefaults]\n                        integerForKey:MMLastWindowClosedBehaviorKey]);\n        if (hide)\n            [NSApp hide:self];\n    }\n\n    // There is a small delay before the Vim process actually exits so wait a\n    // little before trying to reap the child process.  If the process still\n    // hasn't exited after this wait it won't be reaped until the next time\n    // reapChildProcesses: is called (but this should be harmless).\n    [self performSelector:@selector(reapChildProcesses:)\n               withObject:nil\n               afterDelay:0.1];\n}\n\n- (void)windowControllerWillOpen:(MMWindowController *)windowController\n{\n    NSPoint topLeft = NSZeroPoint;\n    NSWindow *cascadeFrom = [[[self topmostVimController] windowController]\n                                                                    window];\n    NSWindow *win = [windowController window];\n\n    if (!win) return;\n\n    // Heuristic to determine where to position the window:\n    //   1. Use the default top left position (set using :winpos in .[g]vimrc)\n    //   2. Cascade from an existing window\n    //   3. Use autosaved position\n    // If all of the above fail, then the window position is not changed.\n    if ([windowController getDefaultTopLeft:&topLeft]) {\n        // Make sure the window is not cascaded (note that topLeft was set in\n        // the above call).\n        cascadeFrom = nil;\n    } else if (cascadeFrom) {\n        NSRect frame = [cascadeFrom frame];\n        topLeft = NSMakePoint(frame.origin.x, NSMaxY(frame));\n    } else {\n        NSString *topLeftString = [[NSUserDefaults standardUserDefaults]\n            stringForKey:MMTopLeftPointKey];\n        if (topLeftString)\n            topLeft = NSPointFromString(topLeftString);\n    }\n\n    if (!NSEqualPoints(topLeft, NSZeroPoint)) {\n        // Try to tile from the correct screen in case the user has multiple\n        // monitors ([win screen] always seems to return the \"main\" screen).\n        //\n        // TODO: Check for screen _closest_ to top left?\n        NSScreen *screen = [self screenContainingTopLeftPoint:topLeft];\n        if (!screen)\n            screen = [win screen];\n\n        BOOL willSwitchScreens = screen != [win screen];\n        if (cascadeFrom) {\n            // Do manual cascading instead of using\n            // -[MMWindow cascadeTopLeftFromPoint:] since it is rather\n            // unpredictable.\n            topLeft.x += MMCascadeHorizontalOffset;\n            topLeft.y -= MMCascadeVerticalOffset;\n        }\n\n        if (screen) {\n            // Constrain the window so that it is entirely visible on the\n            // screen.  If it sticks out on the right, move it all the way\n            // left.  If it sticks out on the bottom, move it all the way up.\n            // (Assumption: the cascading offsets are positive.)\n            NSRect screenFrame = [screen frame];\n            NSSize winSize = [win frame].size;\n            NSRect winFrame =\n                { { topLeft.x, topLeft.y - winSize.height }, winSize };\n\n            if (NSMaxX(winFrame) > NSMaxX(screenFrame))\n                topLeft.x = NSMinX(screenFrame);\n            if (NSMinY(winFrame) < NSMinY(screenFrame))\n                topLeft.y = NSMaxY(screenFrame);\n        } else {\n            ASLogNotice(@\"Window not on screen, don't constrain position\");\n        }\n\n        // setFrameTopLeftPoint will trigger a resize event if the window is\n        // moved across monitors; at this point such a resize would incorrectly\n        // constrain the window to the default vim dimensions, so a specialized\n        // method is used that will avoid that behavior.\n        if (willSwitchScreens)\n            [windowController moveWindowAcrossScreens:topLeft];\n        else\n            [win setFrameTopLeftPoint:topLeft];\n    }\n\n    if (1 == [vimControllers count]) {\n        // The first window autosaves its position.  (The autosaving\n        // features of Cocoa are not used because we need more control over\n        // what is autosaved and when it is restored.)\n        [windowController setWindowAutosaveKey:MMTopLeftPointKey];\n    }\n\n    if (openSelectionString) {\n        // TODO: Pass this as a parameter instead!  Get rid of\n        // 'openSelectionString' etc.\n        //\n        // There is some text to paste into this window as a result of the\n        // services menu \"Open selection ...\" being used.\n        [[windowController vimController] dropString:openSelectionString];\n        [openSelectionString release];\n        openSelectionString = nil;\n    }\n\n    if (shouldActivateWhenNextWindowOpens) {\n        [NSApp activateIgnoringOtherApps:YES];\n        shouldActivateWhenNextWindowOpens = NO;\n    }\n\n    hasShownWindowBefore = YES;\n\n    // If this is the first untitled window we defer starting updater/what's new\n    // to now to make sure they can be shown on top. Otherwise calling this will\n    // do nothing so it's safe.\n    [self startUpdaterAndWhatsNewPage];\n}\n\n- (void)setMainMenu:(NSMenu *)mainMenu\n{\n    if (currentMainMenu == mainMenu) {\n        return;\n    }\n    currentMainMenu = mainMenu;\n    [self refreshMainMenu];\n}\n\n// Refresh the currently active main menu. This call is necessary when any\n// modification was made to the menu, because refreshMainMenu makes a copy of\n// the main menu, meaning that modifications to the original menu wouldn't be\n// reflected until refreshMainMenu is invoked.\n- (void)markMainMenuDirty:(NSMenu *)mainMenu\n{\n    if (currentMainMenu != mainMenu) {\n        // The menu being updated is not the currently set menu, so just ignore,\n        // as this is likely a background Vim window.\n        return;\n    }\n    if (!mainMenuDirty) {\n        // Mark the main menu as dirty and queue up a refresh. We don't immediately\n        // execute the refresh so that multiple calls would get batched up in one go.\n        mainMenuDirty = YES;\n        [self performSelectorOnMainThread:@selector(refreshMainMenu) withObject:nil waitUntilDone:NO];\n    }\n}\n\n- (void)refreshMainMenu\n{\n    mainMenuDirty = NO;\n\n    // Make a copy of the menu before we pass to AppKit. The main reason is\n    // that setWindowsMenu: below will inject items like \"Tile Window to Left\n    // of Screen\" to the Window menu, and on repeated calls it will keep adding\n    // the same item over and over again, without resolving for duplicates. Using\n    // copies help keep the source menu clean.\n    NSMenu *mainMenu = [[currentMainMenu copy] autorelease];\n\n    // If the new menu has a \"Recent Files\" dummy item, then swap the real item\n    // for the dummy.  We are forced to do this since Cocoa initializes the\n    // \"Recent Files\" menu and there is no way to simply point Cocoa to a new\n    // item each time the menus are swapped.\n    NSMenu *fileMenu = [mainMenu findFileMenu];\n    if (recentFilesMenuItem && fileMenu) {\n        int dummyIdx =\n            [fileMenu indexOfItemWithAction:@selector(recentFilesDummy:)];\n        if (dummyIdx >= 0) {\n            NSMenuItem *dummyItem = [[fileMenu itemAtIndex:dummyIdx] retain];\n            [fileMenu removeItemAtIndex:dummyIdx];\n\n            NSMenu *recentFilesParentMenu = [recentFilesMenuItem menu];\n            int idx = [recentFilesParentMenu indexOfItem:recentFilesMenuItem];\n            if (idx >= 0) {\n                [[recentFilesMenuItem retain] autorelease];\n                [recentFilesParentMenu removeItemAtIndex:idx];\n                [recentFilesParentMenu insertItem:dummyItem atIndex:idx];\n            }\n\n            [fileMenu insertItem:recentFilesMenuItem atIndex:dummyIdx];\n            [dummyItem release];\n        }\n    }\n\n#if DISABLE_SPARKLE\n    NSMenu *appMenu = [mainMenu findApplicationMenu];\n\n    // If Sparkle is disabled, we want to remove the \"Check for Updates\" menu\n    // item since it's no longer useful.\n    NSMenuItem *checkForUpdatesItem = [appMenu itemAtIndex:\n                                       [appMenu indexOfItemWithAction:@selector(checkForUpdates:)]];\n    checkForUpdatesItem.hidden = true;\n#endif\n\n    // Now set the new menu.  Notice that we keep one menu for each editor\n    // window since each editor can have its own set of menus.  When swapping\n    // menus we have to tell Cocoa where the new \"MacVim\", \"Windows\", and\n    // \"Services\" menu are.\n    [NSApp setMainMenu:mainMenu];\n\n    NSMenu *servicesMenu = [mainMenu findServicesMenu];\n    [NSApp setServicesMenu:servicesMenu];\n\n    NSMenu *windowsMenu = [mainMenu findWindowsMenu];\n    [NSApp setWindowsMenu:windowsMenu];\n\n    NSMenu *helpMenu = [mainMenu findHelpMenu];\n    [NSApp setHelpMenu:helpMenu];\n}\n\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n{\n    return [self filterOpenFiles:filenames openFilesDict:nil];\n}\n\n- (BOOL)openFiles:(NSArray *)filenames withArguments:(NSDictionary *)args\n{\n    // Opening files works like this:\n    //  a) filter out any already open files\n    //  b) open any remaining files\n    //\n    // Each launching Vim process has a dictionary of arguments that are passed\n    // to the process when in checks in (via connectBackend:pid:).  The\n    // arguments for each launching process can be looked up by its PID (in the\n    // pidArguments dictionary).\n\n    NSMutableDictionary *arguments = (args ? [[args mutableCopy] autorelease]\n                                           : [NSMutableDictionary dictionary]);\n\n    filenames = normalizeFilenames(filenames);\n\n    //\n    // a) Filter out any already open files\n    //\n    NSString *firstFile = [filenames objectAtIndex:0];\n    NSDictionary *openFilesDict = nil;\n    filenames = [self filterOpenFiles:filenames openFilesDict:&openFilesDict];\n\n    // The meaning of \"layout\" is defined by the WIN_* defines in main.c.\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    int layout = [ud integerForKey:MMOpenLayoutKey];\n    BOOL splitVert = [ud boolForKey:MMVerticalSplitKey];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n\n    if (splitVert && MMLayoutHorizontalSplit == layout)\n        layout = MMLayoutVerticalSplit;\n    if (layout < 0 || (layout > MMLayoutTabs && openInCurrentWindow))\n        layout = MMLayoutTabs;\n\n    // Pass arguments to vim controllers that had files open.\n    id key;\n    NSEnumerator *e = [openFilesDict keyEnumerator];\n\n    // (Indicate that we do not wish to open any files at the moment.)\n    [arguments setObject:[NSNumber numberWithBool:YES] forKey:@\"dontOpen\"];\n\n    while ((key = [e nextObject])) {\n        MMVimController *vc = [key pointerValue];\n        NSArray *files = [openFilesDict objectForKey:key];\n        [arguments setObject:files forKey:@\"filenames\"];\n\n        if ([filenames count] == 0 && [files containsObject:firstFile]) {\n            // Raise the window containing the first file that was already\n            // open, and make sure that the tab containing that file is\n            // selected.  Only do this when there are no more files to open,\n            // otherwise sometimes the window with 'firstFile' will be raised,\n            // other times it might be the window that will open with the files\n            // in the 'filenames' array.\n            //\n            // NOTE: Raise window before passing arguments, otherwise the\n            // selection will be lost when selectionRange is set.\n            NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                                  firstFile, @\"filename\",\n                                  [NSNumber numberWithInt:layout], @\"layout\",\n                                  nil];\n            [vc sendMessage:SelectAndFocusOpenedFileMsgID data:[args dictionaryAsData]];\n        }\n\n        [vc passArguments:arguments];\n    }\n\n    // Add filenames to \"Recent Files\" menu, unless they are being edited\n    // remotely (using ODB).\n    if ([arguments objectForKey:@\"remoteID\"] == nil) {\n        [[NSDocumentController sharedDocumentController]\n                noteNewRecentFilePaths:filenames];\n    }\n\n    if ([filenames count] == 0)\n        return YES; // No files left to open (all were already open)\n\n    //\n    // b) Open any remaining files\n    //\n\n    [arguments setObject:[NSNumber numberWithInt:layout] forKey:@\"layout\"];\n    [arguments setObject:filenames forKey:@\"filenames\"];\n    // (Indicate that files should be opened from now on.)\n    [arguments setObject:[NSNumber numberWithBool:NO] forKey:@\"dontOpen\"];\n\n    MMVimController *vc;\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        // Open files in an already open window.\n        [[[vc windowController] window] makeKeyAndOrderFront:self];\n        [vc passArguments:arguments];\n        return YES;\n    }\n\n    BOOL openOk = YES;\n    int numFiles = [filenames count];\n    if (MMLayoutWindows == layout && numFiles > 1) {\n        // Open one file at a time in a new window, but don't open too many at\n        // once (at most cap+1 windows will open).  If the user has increased\n        // the preload cache size we'll take that as a hint that more windows\n        // should be able to open at once.\n        int cap = [self maxPreloadCacheSize] - 1;\n        if (cap < 4) cap = 4;\n        if (cap > numFiles) cap = numFiles;\n\n        int i;\n        for (i = 0; i < cap; ++i) {\n            NSArray *a = [NSArray arrayWithObject:[filenames objectAtIndex:i]];\n            [arguments setObject:a forKey:@\"filenames\"];\n\n            // NOTE: We have to copy the args since we'll mutate them in the\n            // next loop and the below call may retain the arguments while\n            // waiting for a process to start.\n            NSDictionary *args = [[arguments copy] autorelease];\n\n            openOk = [self openVimControllerWithArguments:args];\n            if (!openOk) break;\n        }\n\n        // Open remaining files in tabs in a new window.\n        if (openOk && numFiles > cap) {\n            NSRange range = { i, numFiles-cap };\n            NSArray *a = [filenames subarrayWithRange:range];\n            [arguments setObject:a forKey:@\"filenames\"];\n            [arguments setObject:[NSNumber numberWithInt:MMLayoutTabs]\n                          forKey:@\"layout\"];\n\n            openOk = [self openVimControllerWithArguments:arguments];\n        }\n    } else {\n        // Open all files at once.\n        openOk = [self openVimControllerWithArguments:arguments];\n    }\n\n    return openOk;\n}\n\n- (void)refreshAllAppearances\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController refreshApperanceMode];\n    }\n}\n\n/// Refresh all Vim text views' fonts.\n- (void)refreshAllFonts\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController refreshFonts];\n    }\n}\n\n/// Refresh all resize constraints based on smooth resize configurations\n/// and resize the windows to match the constraints.\n- (void)refreshAllResizeConstraints\n{\n    const unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController updateResizeConstraints:YES];\n    }\n}\n\n/// Refresh all text views and re-render them, as well as updating their\n/// cmdline alignment properties to make sure they are pinned properly.\n- (void)refreshAllTextViews\n{\n    unsigned count = [vimControllers count];\n    for (unsigned i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [vc.windowController.vimView.textView updateCmdlineRow];\n        vc.windowController.vimView.textView.needsDisplay = YES;\n    }\n}\n\n- (BOOL)validateMenuItem:(NSMenuItem *)item\n{\n    if ([item action] == @selector(showWhatsNew:)) {\n        return [MMWhatsNewController canOpen];\n    }\n    // For most of the actions defined in this class we do want them to always be\n    // enabled since they are usually app functionality and independent of\n    // each Vim's state.\n    return YES;\n}\n\n- (IBAction)newWindow:(id)sender\n{\n    ASLogDebug(@\"Open new window\");\n\n    // A cached controller requires no loading times and results in the new\n    // window popping up instantaneously.  If the cache is empty it may take\n    // 1-2 seconds to start a new Vim process.\n    MMVimController *vc = [self takeVimControllerFromCache];\n    if (vc) {\n        [[vc backendProxy] acknowledgeConnection];\n    } else {\n        [self launchVimProcessWithArguments:nil workingDirectory:nil];\n    }\n}\n\n- (IBAction)newWindowAndActivate:(id)sender\n{\n    [self activateWhenNextWindowOpens];\n    [self newWindow:sender];\n}\n\n- (IBAction)fileOpen:(id)sender\n{\n    ASLogDebug(@\"Show file open panel\");\n\n    NSString *dir = nil;\n    BOOL trackPwd = [[NSUserDefaults standardUserDefaults]\n            boolForKey:MMDialogsTrackPwdKey];\n    if (trackPwd) {\n        MMVimController *vc = [self keyVimController];\n        if (vc) dir = [vc objectForVimStateKey:@\"pwd\"];\n    }\n\n    NSOpenPanel *panel = [NSOpenPanel openPanel];\n    [panel setAllowsMultipleSelection:YES];\n    [panel setCanChooseDirectories:YES];\n    [panel setAccessoryView:showHiddenFilesView()];\n    dir = [dir stringByExpandingTildeInPath];\n    if (dir) {\n        NSURL *dirURL = [NSURL fileURLWithPath:dir isDirectory:YES];\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n    }\n\n    NSInteger result = [panel runModal];\n\n#if (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10)\n    if (NSModalResponseOK == result)\n#else\n    if (NSOKButton == result)\n#endif\n    {\n        // NOTE: -[NSOpenPanel filenames] is deprecated on 10.7 so use\n        // -[NSOpenPanel URLs] instead.  The downside is that we have to check\n        // that each URL is really a path first.\n        NSMutableArray *filenames = [NSMutableArray array];\n        NSArray *urls = [panel URLs];\n        NSUInteger i, count = [urls count];\n        for (i = 0; i < count; ++i) {\n            NSURL *url = [urls objectAtIndex:i];\n            if ([url isFileURL]) {\n                NSString *path = [url path];\n                if (path)\n                    [filenames addObject:path];\n            }\n        }\n\n        if ([filenames count] > 0)\n            [self application:NSApp openFiles:filenames];\n    }\n}\n\n- (IBAction)selectNextWindow:(id)sender\n{\n    ASLogDebug(@\"Select next window\");\n\n    unsigned i, count = [vimControllers count];\n    if (!count) return;\n\n    NSWindow *keyWindow = [NSApp keyWindow];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isEqual:keyWindow])\n            break;\n    }\n\n    if (i < count) {\n        if (++i >= count)\n            i = 0;\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [[vc windowController] showWindow:self];\n    }\n}\n\n- (IBAction)selectPreviousWindow:(id)sender\n{\n    ASLogDebug(@\"Select previous window\");\n\n    unsigned i, count = [vimControllers count];\n    if (!count) return;\n\n    NSWindow *keyWindow = [NSApp keyWindow];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isEqual:keyWindow])\n            break;\n    }\n\n    if (i < count) {\n        if (i > 0) {\n            --i;\n        } else {\n            i = count - 1;\n        }\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        [[vc windowController] showWindow:self];\n    }\n}\n\n- (IBAction)orderFrontPreferencePanel:(id)sender\n{\n    ASLogDebug(@\"Show preferences panel\");\n    [[MMPreferenceController sharedPrefsWindowController] showWindow:self];\n}\n\n- (IBAction)openWebsite:(id)sender\n{\n    ASLogDebug(@\"Open MacVim website\");\n    [[NSWorkspace sharedWorkspace] openURL:\n            [NSURL URLWithString:MMWebsiteString]];\n}\n\n- (IBAction)showWhatsNew:(id)sender\n{\n    ASLogDebug(@\"Open What's New page\");\n    [MMWhatsNewController openSharedInstance];\n}\n\n- (IBAction)showVimHelp:(id)sender withCmd:(NSString *)cmd\n{\n    ASLogDebug(@\"Open window with Vim help\");\n    // Open a new window with only the help window shown.\n    [self launchVimProcessWithArguments:[NSArray arrayWithObjects:\n                                    @\"-c\", cmd, @\"-c\", @\":only\", nil]\n                       workingDirectory:nil];\n}\n\n- (IBAction)showVimHelp:(id)sender\n{\n    [self showVimHelp:sender withCmd:@\":h gui_mac\"];\n}\n\n- (IBAction)checkForUpdates:(id)sender\n{\n#if !DISABLE_SPARKLE\n    // Check for updates for new versions manually.\n    ASLogDebug(@\"Check for software updates\");\n    [updater checkForUpdates:sender];\n#endif\n}\n\n// Note that the zoomAll method does not appear to be called in modern macOS versions\n// as NSApplication just handles it and directly calls each window's zoom:. It's\n// difficult to trace through history to see when that happened as it's not really\n// documented, so we are leaving this method around in case on older macOS\n// versions it's useful.\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_13\n- (IBAction)zoomAll:(id)sender\n{\n    // TODO ychin: check on 10.13 etc. This was depreacated post 10.14.\n    ASLogDebug(@\"Zoom all windows\");\n    [NSApp makeWindowsPerform:@selector(performZoom:) inOrder:YES];\n}\n#endif\n\n- (IBAction)stayInFront:(id)sender\n{\n    ASLogDebug(@\"Stay in Front\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:NSFloatingWindowLevel];\n}\n\n- (IBAction)stayInBack:(id)sender\n{\n    ASLogDebug(@\"Stay in Back\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:kCGDesktopIconWindowLevel +1];\n}\n\n- (IBAction)stayLevelNormal:(id)sender\n{\n    ASLogDebug(@\"Stay level normal\");\n    NSWindow *keyWindow = [NSApp keyWindow];\n    [keyWindow setLevel:NSNormalWindowLevel];\n}\n\n- (IBAction)coreTextButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle CoreText renderer\");\n    NSInteger renderer = MMRendererDefault;\n    BOOL enable = ([sender state] == NSControlStateValueOn);\n\n    if (enable) {\n        renderer = MMRendererCoreText;\n    }\n\n    // Update the user default MMRenderer and synchronize the change so that\n    // any new Vim process will pick up on the changed setting.\n    CFPreferencesSetAppValue(\n            (CFStringRef)MMRendererKey,\n            (CFPropertyListRef)[NSNumber numberWithInt:renderer],\n            kCFPreferencesCurrentApplication);\n    CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);\n\n    ASLogInfo(@\"Use renderer=%ld\", renderer);\n\n    // This action is called when the user clicks the \"use CoreText renderer\"\n    // button in the advanced preferences pane.\n    [self rebuildPreloadCache];\n}\n\n- (IBAction)loginShellButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle login shell option\");\n    // This action is called when the user clicks the \"use login shell\" button\n    // in the advanced preferences pane.\n    [self rebuildPreloadCache];\n}\n\n- (IBAction)quickstartButtonClicked:(id)sender\n{\n    ASLogDebug(@\"Toggle Quickstart option\");\n    if ([self maxPreloadCacheSize] > 0) {\n        [self scheduleVimControllerPreloadAfterDelay:1.0];\n        [self startWatchingVimDir];\n    } else {\n        [self cancelVimControllerPreloadRequests];\n        [self clearPreloadCacheWithCount:-1];\n        [self stopWatchingVimDir];\n    }\n}\n\n- (MMVimController *)keyVimController\n{\n    NSWindow *keyWindow = [NSApp keyWindow];\n    if (keyWindow) {\n        unsigned i, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if ([[[vc windowController] window] isEqual:keyWindow])\n                return vc;\n        }\n    }\n\n    return nil;\n}\n\n- (unsigned long)connectBackend:(byref in id <MMBackendProtocol>)proxy pid:(int)pid\n{\n    ASLogDebug(@\"pid=%d\", pid);\n\n    [(NSDistantObject*)proxy setProtocolForProxy:@protocol(MMBackendProtocol)];\n\n    // NOTE: Allocate the vim controller now but don't add it to the list of\n    // controllers since this is a distributed object call and as such can\n    // arrive at unpredictable times (e.g. while iterating the list of vim\n    // controllers).\n    // (What if input arrives before the vim controller is added to the list of\n    // controllers?  This should not be a problem since the input isn't\n    // processed immediately (see processInput:forIdentifier:).)\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    MMVimController *vc = [[MMVimController alloc] initWithBackend:proxy\n                                                               pid:pid];\n    [self performSelectorOnMainThread:@selector(addVimController:)\n                           withObject:vc\n                        waitUntilDone:NO\n                                modes:[NSArray arrayWithObject:\n                                       NSDefaultRunLoopMode]];\n\n    [vc release];\n\n    return [vc vimControllerId];\n}\n\n- (oneway void)processInput:(in bycopy NSArray *)queue\n              forIdentifier:(unsigned long)identifier\n{\n    // NOTE: Input is not handled immediately since this is a distributed\n    // object call and as such can arrive at unpredictable times.  Instead,\n    // queue the input and process it when the run loop is updated.\n\n    if (!(queue && identifier)) {\n        ASLogWarn(@\"Bad input for identifier=%lu\", identifier);\n        return;\n    }\n\n    ASLogDebug(@\"QUEUE for identifier=%lu: <<< %@>>>\", identifier,\n               debugStringForMessageQueue(queue));\n\n    NSNumber *key = [NSNumber numberWithUnsignedLong:identifier];\n    NSArray *q = [inputQueues objectForKey:key];\n    if (q) {\n        q = [q arrayByAddingObjectsFromArray:queue];\n        [inputQueues setObject:q forKey:key];\n    } else {\n        [inputQueues setObject:queue forKey:key];\n    }\n\n    // NOTE: We must use \"event tracking mode\" as well as \"default mode\",\n    // otherwise the input queue will not be processed e.g. during live\n    // resizing.\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    [self performSelectorOnMainThread:@selector(processInputQueues:)\n                           withObject:nil\n                        waitUntilDone:NO\n                                modes:[NSArray arrayWithObjects:\n                                       NSDefaultRunLoopMode,\n                                       NSEventTrackingRunLoopMode, nil]];\n}\n\n- (NSArray *)serverList\n{\n    NSMutableArray *array = [NSMutableArray array];\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *controller = [vimControllers objectAtIndex:i];\n        if ([controller serverName])\n            [array addObject:[controller serverName]];\n    }\n\n    return array;\n}\n\n// Begin NSUserInterfaceItemSearching implementation\n- (NSArray<NSString *> *)localizedTitlesForItem:(id)item\n{\n    return item;\n}\n\n- (void)searchForItemsWithSearchString:(NSString *)searchString\n                           resultLimit:(NSInteger)resultLimit\n                    matchedItemHandler:(void (^)(NSArray *items))handleMatchedItems\n{\n    // Search documentation tags and provide the results in a pair of (file\n    // name, tag name). Currently lazily parse the Vim's doc tags, and reuse\n    // that in future searches.\n    //\n    // Does not support plugins for now, as different Vim instances could have\n    // different plugins loaded. Theoretically it's possible to query the\n    // current Vim instance for what plugins are loaded and the tags associated\n    // with them but it's tricky especially since this function is not invoked\n    // on the main thread. Just providing Vim's builtin docs should be mostly\n    // good enough.\n\n    static BOOL parsed = NO;\n    static NSMutableArray *parsedLineComponents = nil;\n\n    @synchronized (self) {\n        if (!parsed) {\n            parsedLineComponents = [[NSMutableArray alloc]init];\n            \n            NSString *tagsFilePath = [[[NSBundle mainBundle] resourcePath]\n                                      stringByAppendingPathComponent:@\"vim/runtime/doc/tags\"];\n            NSString *fileContent = [NSString stringWithContentsOfFile:tagsFilePath encoding:NSUTF8StringEncoding error:NULL];\n            NSArray *lines = [fileContent componentsSeparatedByString:@\"\\n\"];\n            \n            for (NSString *line in lines) {\n                NSArray<NSString *> *components = [line componentsSeparatedByString:@\"\\t\"];\n                if ([components count] < 2) {\n                    continue;\n                }\n                [parsedLineComponents addObject:components];\n            }\n            \n            parsed = YES;\n        }\n    }\n\n    // Use a simple search algorithm where the string is split by whitespace and each word has to match\n    // substring in the tag. Don't do fuzzy matching or regex for simplicity for now.\n    NSArray<NSString *> *searchStrings = [searchString componentsSeparatedByString:@\" \"];\n\n    NSMutableArray *ret = [[[NSMutableArray alloc]init] autorelease];\n    for (NSArray<NSString *> *line in parsedLineComponents) {\n        BOOL found = YES;\n        for (NSString *curSearchString in searchStrings) {\n            if (![line[0] localizedCaseInsensitiveContainsString:curSearchString]) {\n                found = NO;\n                break;\n            }\n        }\n        if (found) {\n            // We flip the ordering because we want it to look like \"file_name.txt > tag_name\" in the results.\n            NSArray *foundObject = @[line[1], line[0]];\n            \n            if ([searchStrings count] == 1 && [searchString localizedCaseInsensitiveCompare:line[0]] == NSOrderedSame) {\n                // Exact match has highest priority.\n                [ret insertObject:foundObject atIndex:0];\n            }\n            else {\n                // Don't do any other prioritization for now. May add more sophisticated sorting/heuristics\n                // in the future.\n                [ret addObject:foundObject];\n            }\n        }\n    }\n\n    // Return the results to callback.\n    handleMatchedItems(ret);\n}\n\n- (void)performActionForItem:(id)item\n{\n    // When opening a help page, either open a new Vim instance, or reuse the\n    // existing one.\n    MMVimController *vimController = [self keyVimController];\n    if (vimController == nil) {\n        [self showVimHelp:self withCmd:[NSString stringWithFormat:\n                                        @\":help %@\", item[1]]];\n        return;\n    }\n    [vimController addVimInput:[NSString stringWithFormat:\n                                @\"<C-\\\\><C-N>:help %@<CR>\", item[1]]];\n}\n// End NSUserInterfaceItemSearching\n\n@end // MMAppController\n\n\n\n\n@implementation MMAppController (MMServices)\n\n- (void)openSelection:(NSPasteboard *)pboard userData:(NSString *)userData\n                error:(NSString **)error\n{\n    if (![[pboard types] containsObject:NSPasteboardTypeString]) {\n        ASLogNotice(@\"Pasteboard contains no NSPasteboardTypeString\");\n        return;\n    }\n\n    ASLogInfo(@\"Open new window containing current selection\");\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        [vc sendMessage:AddNewTabMsgID data:nil];\n        [vc dropString:[pboard stringForType:NSPasteboardTypeString]];\n    } else {\n        // Save the text, open a new window, and paste the text when the next\n        // window opens.  (If this is called several times in a row, then all\n        // but the last call may be ignored.)\n        if (openSelectionString) [openSelectionString release];\n        openSelectionString = [[pboard stringForType:NSPasteboardTypeString] copy];\n\n        [self newWindow:self];\n    }\n}\n\n- (void)openFile:(NSPasteboard *)pboard userData:(NSString *)userData\n           error:(NSString **)error\n{\n    if (![[pboard types] containsObject:NSPasteboardTypeString]) {\n        ASLogNotice(@\"Pasteboard contains no NSPasteboardTypeString\");\n        return;\n    }\n\n    // TODO: Parse multiple filenames and create array with names.\n    NSString *string = [pboard stringForType:NSPasteboardTypeString];\n    string = [string stringByTrimmingCharactersInSet:\n            [NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    string = [string stringByStandardizingPath];\n\n    ASLogInfo(@\"Open new window with selected file: %@\", string);\n\n    NSArray *filenames = [self filterFilesAndNotify:\n            [NSArray arrayWithObject:string]];\n    if ([filenames count] == 0)\n        return;\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        [vc dropFiles:filenames forceOpen:YES];\n    } else {\n        [self openFiles:filenames withArguments:nil];\n    }\n}\n\n- (void)newFileHere:(NSPasteboard *)pboard userData:(NSString *)userData\n              error:(NSString **)error\n{\n    NSArray<NSString *> *filenames = extractPasteboardFilenames(pboard);\n    if (filenames == nil || filenames.count == 0)\n        return;\n    NSString *path = [filenames lastObject];\n\n    BOOL dirIndicator;\n    if (![[NSFileManager defaultManager] fileExistsAtPath:path\n                                              isDirectory:&dirIndicator]) {\n        ASLogNotice(@\"Invalid path. Cannot open new document at: %@\", path);\n        return;\n    }\n\n    ASLogInfo(@\"Open new file at path=%@\", path);\n\n    if (!dirIndicator)\n        path = [path stringByDeletingLastPathComponent];\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    BOOL openInCurrentWindow = [ud boolForKey:MMOpenInCurrentWindowKey];\n    MMVimController *vc;\n\n    if (openInCurrentWindow && (vc = [self topmostVimController])) {\n        NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                              path, @\"path\",\n                              nil];\n        [vc sendMessage:NewFileHereMsgID data:[args dictionaryAsData]];\n    } else {\n        [self launchVimProcessWithArguments:nil workingDirectory:path];\n    }\n}\n\n@end // MMAppController (MMServices)\n\n\n\n\n@implementation MMAppController (Private)\n\n/// Initializes the Sparkle updater and show a \"What's New\" page if needed.\n/// Can be called more than once, but later calls will be silently ignored.\n/// This should be called after the initial untitled window is shown to make\n/// sure the updater/\"What's New\" windows can be shown on top of it.\n- (void)startUpdaterAndWhatsNewPage\n{\n    static BOOL started = NO;\n    if (!started) {\n#if !DISABLE_SPARKLE && !USE_SPARKLE_1\n        [updater startUpdater];\n#endif\n\n        if (shouldShowWhatsNewPage) {\n            // Schedule it to be run later to make sure it will show up on top\n            // of the new untitled window.\n            [MMWhatsNewController performSelectorOnMainThread:@selector(openSharedInstance) withObject:nil waitUntilDone:NO];\n        }\n\n        started = YES;\n    }\n}\n\n- (MMVimController *)topmostVimController\n{\n    // Find the topmost visible window which has an associated vim controller\n    // as follows:\n    //\n    // 1. Search through ordered windows as determined by NSApp.  Unfortunately\n    //    this method can fail, e.g. if a full-screen window is on another\n    //    \"Space\" (in this case NSApp returns no windows at all), so we have to\n    //    fall back on ...\n    // 2. Search through all Vim controllers and return the first visible\n    //    window.\n\n    NSEnumerator *e = [[NSApp orderedWindows] objectEnumerator];\n    id window;\n    while ((window = [e nextObject]) && [window isVisible]) {\n        unsigned i, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if ([[[vc windowController] window] isEqual:window])\n                return vc;\n        }\n    }\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n        if ([[[vc windowController] window] isVisible]) {\n            return vc;\n        }\n    }\n\n    return nil;\n}\n\n- (int)launchVimProcessWithArguments:(NSArray *)args\n                    workingDirectory:(NSString *)cwd\n{\n    int pid = -1;\n    NSString *path = [[NSBundle mainBundle] pathForAuxiliaryExecutable:@\"Vim\"];\n\n    if (!path) {\n        ASLogCrit(@\"Vim executable could not be found inside app bundle!\");\n        return -1;\n    }\n\n    // Change current working directory so that the child process picks it up.\n    NSFileManager *fm = [NSFileManager defaultManager];\n    NSString *restoreCwd = nil;\n    if (cwd) {\n        restoreCwd = [fm currentDirectoryPath];\n        [fm changeCurrentDirectoryPath:cwd];\n    }\n\n    NSArray *taskArgs = [NSArray arrayWithObjects:@\"-g\", @\"-f\", nil];\n    if (args)\n        taskArgs = [taskArgs arrayByAddingObjectsFromArray:args];\n\n    BOOL useLoginShell = [[NSUserDefaults standardUserDefaults]\n            boolForKey:MMLoginShellKey];\n    if (useLoginShell) {\n        // Run process with a login shell, roughly:\n        //   echo \"exec Vim -g -f args\" | ARGV0=-`basename $SHELL` $SHELL [-l]\n        pid = [self executeInLoginShell:path arguments:taskArgs];\n    } else {\n        // Run process directly:\n        //   Vim -g -f args\n        NSTask *task = [NSTask launchedTaskWithLaunchPath:path\n                                                arguments:taskArgs];\n        pid = task ? [task processIdentifier] : -1;\n    }\n\n    if (-1 != pid) {\n        // The 'pidArguments' dictionary keeps arguments to be passed to the\n        // process when it connects (this is in contrast to arguments which are\n        // passed on the command line, like '-f' and '-g').\n        // NOTE: If there are no arguments to pass we still add a null object\n        // so that we can use this dictionary to check if there are any\n        // processes loading.\n        NSNumber *pidKey = [NSNumber numberWithInt:pid];\n        if (![pidArguments objectForKey:pidKey])\n            [pidArguments setObject:[NSNull null] forKey:pidKey];\n    } else {\n        ASLogWarn(@\"Failed to launch Vim process: args=%@, useLoginShell=%d\",\n                  args, useLoginShell);\n    }\n\n    // Now that child has launched, restore the current working directory.\n    if (restoreCwd)\n        [fm changeCurrentDirectoryPath:restoreCwd];\n\n    return pid;\n}\n\n- (NSArray *)filterFilesAndNotify:(NSArray *)filenames\n{\n    // Go trough 'filenames' array and make sure each file exists.  Present\n    // warning dialog if some file was missing.\n\n    NSString *firstMissingFile = nil;\n    NSMutableArray *files = [NSMutableArray array];\n    unsigned i, count = [filenames count];\n\n    for (i = 0; i < count; ++i) {\n        NSString *name = [filenames objectAtIndex:i];\n        if ([[NSFileManager defaultManager] fileExistsAtPath:name]) {\n            [files addObject:name];\n        } else if (!firstMissingFile) {\n            firstMissingFile = name;\n        }\n    }\n\n    if (firstMissingFile) {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                @\"Dialog button\")];\n\n        NSString *text;\n        if ([files count] >= count-1) {\n            [alert setMessageText:NSLocalizedString(@\"File not found\",\n                    @\"File not found dialog, title\")];\n            text = [NSString stringWithFormat:NSLocalizedString(\n                    @\"Could not open file with name %@.\",\n                    @\"File not found dialog, text\"), firstMissingFile];\n        } else {\n            [alert setMessageText:NSLocalizedString(@\"Multiple files not found\",\n                    @\"File not found dialog, title\")];\n            text = [NSString stringWithFormat:NSLocalizedString(\n                    @\"Could not open file with name %@, and %u other files.\",\n                    @\"File not found dialog, text\"),\n                firstMissingFile, (unsigned int)(count-[files count]-1)];\n        }\n\n        [alert setInformativeText:text];\n        [alert setAlertStyle:NSAlertStyleWarning];\n\n        [alert runModal];\n        [alert release];\n\n        [NSApp replyToOpenOrPrint:NSApplicationDelegateReplyFailure];\n    }\n\n    return files;\n}\n\n- (NSArray *)filterOpenFiles:(NSArray *)filenames\n               openFilesDict:(NSDictionary **)openFiles\n{\n    // Filter out any files in the 'filenames' array that are open and return\n    // all files that are not already open.  On return, the 'openFiles'\n    // parameter (if non-nil) will point to a dictionary of open files, indexed\n    // by Vim controller.\n\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    NSMutableArray *files = [filenames mutableCopy];\n\n    // TODO: Escape special characters in 'files'?\n    NSString *expr = [NSString stringWithFormat:\n            @\"map([\\\"%@\\\"],\\\"bufloaded(v:val)\\\")\",\n            [files componentsJoinedByString:@\"\\\",\\\"\"]];\n\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count && [files count] > 0; ++i) {\n        MMVimController *vc = [vimControllers objectAtIndex:i];\n\n        // Query Vim for which files in the 'files' array are open.\n        NSString *eval = [vc evaluateVimExpression:expr];\n        if (!eval) continue;\n\n        NSIndexSet *idxSet = [NSIndexSet indexSetWithVimList:eval];\n        if ([idxSet count] > 0) {\n            [dict setObject:[files objectsAtIndexes:idxSet]\n                     forKey:[NSValue valueWithPointer:vc]];\n\n            // Remove all the files that were open in this Vim process and\n            // create a new expression to evaluate.\n            [files removeObjectsAtIndexes:idxSet];\n            expr = [NSString stringWithFormat:\n                    @\"map([\\\"%@\\\"],\\\"bufloaded(v:val)\\\")\",\n                    [files componentsJoinedByString:@\"\\\",\\\"\"]];\n        }\n    }\n\n    if (openFiles != nil)\n        *openFiles = dict;\n\n    return [files autorelease];\n}\n\n#if MM_HANDLE_XCODE_MOD_EVENT\n- (void)handleXcodeModEvent:(NSAppleEventDescriptor *)event\n                 replyEvent:(NSAppleEventDescriptor *)reply\n{\n#if 0\n    // Xcode sends this event to query MacVim which open files have been\n    // modified.\n    ASLogDebug(@\"reply:%@\", reply);\n    ASLogDebug(@\"event:%@\", event);\n\n    NSEnumerator *e = [vimControllers objectEnumerator];\n    id vc;\n    while ((vc = [e nextObject])) {\n        DescType type = [reply descriptorType];\n        unsigned len = [[type data] length];\n        NSMutableData *data = [NSMutableData data];\n\n        [data appendBytes:&type length:sizeof(DescType)];\n        [data appendBytes:&len length:sizeof(unsigned)];\n        [data appendBytes:[reply data] length:len];\n\n        [vc sendMessage:XcodeModMsgID data:data];\n    }\n#endif\n}\n#endif\n\n- (void)handleGetURLEvent:(NSAppleEventDescriptor *)event\n               replyEvent:(NSAppleEventDescriptor *)reply\n{\n    NSURL *url = [NSURL URLWithString:[[event\n                                        paramDescriptorForKeyword:keyDirectObject]\n                                        stringValue]];\n\n    // We try to be compatible with TextMate's URL scheme here, as documented\n    // at http://blog.macromates.com/2007/the-textmate-url-scheme/ . Currently,\n    // this means that:\n    //\n    // The format is: mvim://open?<arguments> where arguments can be:\n    //\n    // * url \u2014 the actual file to open (i.e. a file://\u2026 URL), if you leave\n    //         out this argument, the frontmost document is implied.\n    // * line \u2014 line number to go to (one based).\n    // * column \u2014 column number to go to (one based).\n    //\n    // Example: mvim://open?url=file:///etc/profile&line=20\n\n    if ([[url host] isEqualToString:@\"open\"]) {\n        NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n        // Parse query (\"url=file://...&line=14\") into a dictionary\n        NSArray *queries = [[url query] componentsSeparatedByString:@\"&\"];\n        NSEnumerator *enumerator = [queries objectEnumerator];\n        NSString *param;\n        while ((param = [enumerator nextObject])) {\n            // query: <field>=<value>\n            NSArray *arr = [param componentsSeparatedByString:@\"=\"];\n            if ([arr count] == 2) {\n                // parse field\n                NSString *f = [arr objectAtIndex:0];\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                f = [f stringByRemovingPercentEncoding];\n#else\n                f = [f stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n#endif\n\n                // parse value\n                NSString *v = [arr objectAtIndex:1];\n\n                // We need to decode the parameters here because most URL\n                // parsers treat the query component as needing to be decoded\n                // instead of treating it as is. It does mean that a link to\n                // open file \"/tmp/file name.txt\" will be\n                // mvim://open?url=file:///tmp/file%2520name.txt to encode a\n                // URL of file:///tmp/file%20name.txt. This double-encoding is\n                // intentional to follow the URL spec.\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                v = [v stringByRemovingPercentEncoding];\n#else\n                v = [v stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n#endif\n\n                if ([f isEqualToString:@\"url\"]) {\n                    // Since the URL scheme uses a double-encoding due to a\n                    // file:// URL encoded in another mvim: one, existing tools\n                    // like iTerm2 could sometimes erroneously only do a single\n                    // encode. To maximize compatiblity, we re-encode invalid\n                    // characters if we detect them as they would not work\n                    // later on when we pass this string to URLWithString.\n                    //\n                    // E.g. mvim://open?uri=file:///foo%20bar => \"file:///foo bar\"\n                    // which is not a valid URL, so we re-encode it to\n                    // file:///foo%20bar here. The only important case is to\n                    // not touch the \"%\" character as it introduces ambiguity\n                    // and the re-encoding is a nice compatibility feature, but\n                    // the canonical form should be double-encoded, i.e.\n                    // mvim://open?uri=file:///foo%2520bar\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11\n                    NSMutableCharacterSet *charSet = [NSMutableCharacterSet characterSetWithCharactersInString:@\"%\"];\n                    [charSet formUnionWithCharacterSet:NSCharacterSet.URLHostAllowedCharacterSet];\n                    [charSet formUnionWithCharacterSet:NSCharacterSet.URLPathAllowedCharacterSet];\n                    v = [v stringByAddingPercentEncodingWithAllowedCharacters:charSet];\n#endif\n                }\n\n                [dict setValue:v forKey:f];\n            }\n        }\n\n        // Actually open the file.\n        NSString *file = [dict objectForKey:@\"url\"];\n        if (file != nil) {\n            NSURL *fileUrl = [NSURL URLWithString:file];\n            if ([fileUrl isFileURL]) {\n                NSString *filePath = [fileUrl path];\n                // Only opens files that already exist.\n                if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) {\n                    NSArray *filenames = [NSArray arrayWithObject:filePath];\n\n                    // Look for the line and column options.\n                    NSDictionary *args = nil;\n                    NSString *line = [dict objectForKey:@\"line\"];\n                    if (line) {\n                        NSString *column = [dict objectForKey:@\"column\"];\n                        if (column)\n                            args = [NSDictionary dictionaryWithObjectsAndKeys:\n                                    line, @\"cursorLine\",\n                                    column, @\"cursorColumn\",\n                                    nil];\n                        else\n                            args = [NSDictionary dictionaryWithObject:line\n                                                               forKey:@\"cursorLine\"];\n                    }\n\n                    [self openFiles:filenames withArguments:args];\n                } else {\n                    NSAlert *alert = [[NSAlert alloc] init];\n                    [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                        @\"Dialog button\")];\n\n                    [alert setMessageText:NSLocalizedString(@\"Bad file path\",\n                        @\"Bad file path dialog, title\")];\n                    [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n                        @\"Cannot open file path \\\"%@\\\"\",\n                        @\"Bad file path dialog, text\"),\n                        filePath]];\n\n                    [alert setAlertStyle:NSAlertStyleWarning];\n                    [alert runModal];\n                    [alert release];\n                }\n            } else {\n                NSAlert *alert = [[NSAlert alloc] init];\n                [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n                    @\"Dialog button\")];\n\n                [alert setMessageText:NSLocalizedString(@\"Invalid File URL\",\n                    @\"Unknown Fie URL dialog, title\")];\n                [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n                    @\"Unknown file URL in \\\"%@\\\"\",\n                    @\"Unknown file URL dialog, text\"),\n                    file]];\n\n                [alert setAlertStyle:NSAlertStyleWarning];\n                [alert runModal];\n                [alert release];\n            }\n        }\n    } else {\n        NSAlert *alert = [[NSAlert alloc] init];\n        [alert addButtonWithTitle:NSLocalizedString(@\"OK\",\n            @\"Dialog button\")];\n\n        [alert setMessageText:NSLocalizedString(@\"Unknown URL Scheme\",\n            @\"Unknown URL Scheme dialog, title\")];\n        [alert setInformativeText:[NSString stringWithFormat:NSLocalizedString(\n            @\"This version of MacVim does not support \\\"%@\\\"\"\n            @\" in its URL scheme.\",\n            @\"Unknown URL Scheme dialog, text\"),\n            [url host]]];\n\n        [alert setAlertStyle:NSAlertStyleWarning];\n        [alert runModal];\n        [alert release];\n    }\n}\n\n- (NSMutableDictionary *)extractArgumentsFromOdocEvent:\n    (NSAppleEventDescriptor *)desc\n{\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n    // 1. Extract ODB parameters (if any)\n    NSAppleEventDescriptor *odbdesc = desc;\n    if (![odbdesc paramDescriptorForKeyword:keyFileSender]) {\n        // The ODB paramaters may hide inside the 'keyAEPropData' descriptor.\n        odbdesc = [odbdesc paramDescriptorForKeyword:keyAEPropData];\n        if (![odbdesc paramDescriptorForKeyword:keyFileSender])\n            odbdesc = nil;\n    }\n\n    if (odbdesc) {\n        NSAppleEventDescriptor *p =\n                [odbdesc paramDescriptorForKeyword:keyFileSender];\n        if (p)\n            [dict setObject:[NSNumber numberWithUnsignedInt:[p typeCodeValue]]\n                     forKey:@\"remoteID\"];\n\n        p = [odbdesc paramDescriptorForKeyword:keyFileCustomPath];\n        if (p)\n            [dict setObject:[p stringValue] forKey:@\"remotePath\"];\n\n        p = [odbdesc paramDescriptorForKeyword:keyFileSenderToken];\n        if (p) {\n            [dict setObject:[NSNumber numberWithUnsignedLong:[p descriptorType]]\n                     forKey:@\"remoteTokenDescType\"];\n            [dict setObject:[p data] forKey:@\"remoteTokenData\"];\n        }\n    }\n\n    // 2. Extract Xcode parameters (if any)\n    NSAppleEventDescriptor *xcodedesc =\n            [desc paramDescriptorForKeyword:keyAEPosition];\n    if (xcodedesc) {\n        NSRange range;\n        NSData *data = [xcodedesc data];\n        NSUInteger length = [data length];\n\n        if (length == sizeof(MMXcodeSelectionRange)) {\n            MMXcodeSelectionRange *sr = (MMXcodeSelectionRange*)[data bytes];\n            ASLogDebug(@\"Xcode selection range (%d,%d,%d,%d,%d,%d)\",\n                    sr->unused1, sr->lineNum, sr->startRange, sr->endRange,\n                    sr->unused2, sr->theDate);\n\n            if (sr->lineNum < 0) {\n                // Should select a range of characters.\n                range.location = sr->startRange + 1;\n                range.length = sr->endRange > sr->startRange\n                             ? sr->endRange - sr->startRange : 1;\n            } else {\n                // Should only move cursor to a line.\n                range.location = sr->lineNum + 1;\n                range.length = 0;\n            }\n\n            [dict setObject:NSStringFromRange(range) forKey:@\"selectionRange\"];\n        } else {\n            ASLogErr(@\"Xcode selection range size mismatch! got=%ld \"\n                     \"expected=%ld\", length, sizeof(MMXcodeSelectionRange));\n        }\n    }\n\n    // 3. Extract Spotlight search text (if any)\n    NSAppleEventDescriptor *spotlightdesc = \n            [desc paramDescriptorForKeyword:keyAESearchText];\n    if (spotlightdesc) {\n        NSString *s = [[spotlightdesc stringValue]\n                                            stringBySanitizingSpotlightSearch];\n        if (s && [s length] > 0)\n            [dict setObject:s forKey:@\"searchText\"];\n    }\n\n    return dict;\n}\n\n- (void)scheduleVimControllerPreloadAfterDelay:(NSTimeInterval)delay\n{\n    [self performSelector:@selector(preloadVimController:)\n               withObject:nil\n               afterDelay:delay];\n}\n\n- (void)cancelVimControllerPreloadRequests\n{\n    [NSObject cancelPreviousPerformRequestsWithTarget:self\n            selector:@selector(preloadVimController:)\n              object:nil];\n}\n\n- (void)preloadVimController:(id)sender\n{\n    // We only allow preloading of one Vim process at a time (to avoid hogging\n    // CPU), so schedule another preload in a little while if necessary.\n    if (-1 != preloadPid) {\n        [self scheduleVimControllerPreloadAfterDelay:2];\n        return;\n    }\n\n    if ([cachedVimControllers count] >= [self maxPreloadCacheSize])\n        return;\n\n    preloadPid = [self launchVimProcessWithArguments:\n                                    [NSArray arrayWithObject:@\"--mmwaitforack\"]\n                                    workingDirectory:nil];\n\n    // This method is kicked off via FSEvents, so if MacVim is in the\n    // background, the runloop won't bother flushing the autorelease pool.\n    // Triggering an NSEvent works around this.\n    // http://www.mikeash.com/pyblog/more-fun-with-autorelease.html\n    NSEvent* event = [NSEvent otherEventWithType:NSEventTypeApplicationDefined\n                                        location:NSZeroPoint\n                                   modifierFlags:0\n                                       timestamp:0\n                                    windowNumber:0\n                                         context:nil\n                                         subtype:0\n                                           data1:0\n                                           data2:0];\n    [NSApp postEvent:event atStart:NO];\n}\n\n- (int)maxPreloadCacheSize\n{\n    // The maximum number of Vim processes to keep in the cache can be\n    // controlled via the user default \"MMPreloadCacheSize\".\n    int maxCacheSize = [[NSUserDefaults standardUserDefaults]\n            integerForKey:MMPreloadCacheSizeKey];\n    if (maxCacheSize < 0) maxCacheSize = 0;\n    else if (maxCacheSize > 10) maxCacheSize = 10;\n\n    return maxCacheSize;\n}\n\n- (MMVimController *)takeVimControllerFromCache\n{\n    // NOTE: After calling this message the backend corresponding to the\n    // returned vim controller must be sent an acknowledgeConnection message,\n    // else the vim process will be stuck.\n    //\n    // This method may return nil even though the cache might be non-empty; the\n    // caller should handle this by starting a new Vim process.\n\n    int i, count = [cachedVimControllers count];\n    if (0 == count) return nil;\n\n    // Locate the first Vim controller with up-to-date rc-files sourced.\n    NSDate *rcDate = [self rcFilesModificationDate];\n    for (i = 0; i < count; ++i) {\n        MMVimController *vc = [cachedVimControllers objectAtIndex:i];\n        NSDate *date = [vc creationDate];\n        if ([date compare:rcDate] != NSOrderedAscending)\n            break;\n    }\n\n    if (i > 0) {\n        // Clear out cache entries whose vimrc/gvimrc files were sourced before\n        // the latest modification date for those files.  This ensures that the\n        // latest rc-files are always sourced for new windows.\n        [self clearPreloadCacheWithCount:i];\n    }\n\n    if ([cachedVimControllers count] == 0) {\n        [self scheduleVimControllerPreloadAfterDelay:2.0];\n        return nil;\n    }\n\n    MMVimController *vc = [cachedVimControllers objectAtIndex:0];\n    [vimControllers addObject:vc];\n    [cachedVimControllers removeObjectAtIndex:0];\n    [vc setIsPreloading:NO];\n\n    // If the Vim process has finished loading then the window will displayed\n    // now, otherwise it will be displayed when the OpenWindowMsgID message is\n    // received.\n    [[vc windowController] presentWindow:nil];\n\n    // Since we've taken one controller from the cache we take the opportunity\n    // to preload another.\n    [self scheduleVimControllerPreloadAfterDelay:1];\n\n    return vc;\n}\n\n- (void)clearPreloadCacheWithCount:(int)count\n{\n    // Remove the 'count' first entries in the preload cache.  It is assumed\n    // that objects are added/removed from the cache in a FIFO manner so that\n    // this effectively clears the 'count' oldest entries.\n    // If 'count' is negative, then the entire cache is cleared.\n\n    if ([cachedVimControllers count] == 0 || count == 0)\n        return;\n\n    if (count < 0)\n        count = [cachedVimControllers count];\n\n    // Make sure the preloaded Vim processes get killed or they'll just hang\n    // around being useless until MacVim is terminated.\n    NSEnumerator *e = [cachedVimControllers objectEnumerator];\n    MMVimController *vc;\n    int n = count;\n    while ((vc = [e nextObject]) && n-- > 0) {\n        [[NSNotificationCenter defaultCenter] removeObserver:vc];\n        [vc sendMessage:TerminateNowMsgID data:nil];\n\n        // Since the preloaded processes were killed \"prematurely\" we have to\n        // manually tell them to cleanup (it is not enough to simply release\n        // them since deallocation and cleanup are separated).\n        [vc cleanup];\n    }\n\n    n = count;\n    while (n-- > 0 && [cachedVimControllers count] > 0)\n        [cachedVimControllers removeObjectAtIndex:0];\n\n    // There is a small delay before the Vim process actually exits so wait a\n    // little before trying to reap the child process.  If the process still\n    // hasn't exited after this wait it won't be reaped until the next time\n    // reapChildProcesses: is called (but this should be harmless).\n    [self performSelector:@selector(reapChildProcesses:)\n               withObject:nil\n               afterDelay:0.1];\n}\n\n- (void)rebuildPreloadCache\n{\n    if ([self maxPreloadCacheSize] > 0) {\n        [self clearPreloadCacheWithCount:-1];\n        [self cancelVimControllerPreloadRequests];\n        [self scheduleVimControllerPreloadAfterDelay:1.0];\n    }\n}\n\n- (NSDate *)rcFilesModificationDate\n{\n    // Check modification dates for ~/.vimrc and ~/.gvimrc and return the\n    // latest modification date.  If ~/.vimrc does not exist, check ~/_vimrc\n    // and similarly for gvimrc.\n    // Returns distantPath if no rc files were found.\n\n    NSDate *date = [NSDate distantPast];\n    NSFileManager *fm = [NSFileManager defaultManager];\n\n    NSString *path = [@\"~/.vimrc\" stringByExpandingTildeInPath];\n    NSDictionary *attr = [fm attributesOfItemAtPath:path error:NULL];\n    if (!attr) {\n        path = [@\"~/_vimrc\" stringByExpandingTildeInPath];\n        attr = [fm attributesOfItemAtPath:path error:NULL];\n    }\n    NSDate *modDate = [attr objectForKey:NSFileModificationDate];\n    if (modDate)\n        date = modDate;\n\n    path = [@\"~/.gvimrc\" stringByExpandingTildeInPath];\n    attr = [fm attributesOfItemAtPath:path error:NULL];\n    if (!attr) {\n        path = [@\"~/_gvimrc\" stringByExpandingTildeInPath];\n        attr = [fm attributesOfItemAtPath:path error:NULL];\n    }\n    modDate = [attr objectForKey:NSFileModificationDate];\n    if (modDate)\n        date = [date laterDate:modDate];\n\n    return date;\n}\n\n- (BOOL)openVimControllerWithArguments:(NSDictionary *)arguments\n{\n    MMVimController *vc = [self takeVimControllerFromCache];\n    if (vc) {\n        // Open files in a new window using a cached vim controller.  This\n        // requires virtually no loading time so the new window will pop up\n        // instantaneously.\n        [vc passArguments:arguments];\n        [[vc backendProxy] acknowledgeConnection];\n    } else {\n        NSArray *cmdline = nil;\n        NSString *cwd = [self workingDirectoryForArguments:arguments];\n        arguments = [self convertVimControllerArguments:arguments\n                                          toCommandLine:&cmdline];\n        int pid = [self launchVimProcessWithArguments:cmdline\n                                     workingDirectory:cwd];\n        if (-1 == pid)\n            return NO;\n\n        // TODO: If the Vim process fails to start, or if it changes PID,\n        // then the memory allocated for these parameters will leak.\n        // Ensure that this cannot happen or somehow detect it.\n\n        if ([arguments count] > 0)\n            [pidArguments setObject:arguments\n                             forKey:[NSNumber numberWithInt:pid]];\n    }\n\n    return YES;\n}\n\n- (void)activateWhenNextWindowOpens\n{\n    ASLogDebug(@\"Activate MacVim when next window opens\");\n    shouldActivateWhenNextWindowOpens = YES;\n}\n\n- (void)startWatchingVimDir\n{\n    if (fsEventStream)\n        return;\n\n    NSString *path = [@\"~/.vim\" stringByExpandingTildeInPath];\n    NSArray *pathsToWatch = [NSArray arrayWithObject:path];\n\n    fsEventStream = FSEventStreamCreate(NULL, &fsEventCallback, NULL,\n            (CFArrayRef)pathsToWatch, kFSEventStreamEventIdSinceNow,\n            MMEventStreamLatency, kFSEventStreamCreateFlagNone);\n\n    FSEventStreamScheduleWithRunLoop(fsEventStream,\n            [[NSRunLoop currentRunLoop] getCFRunLoop],\n            kCFRunLoopDefaultMode);\n\n    FSEventStreamStart(fsEventStream);\n    ASLogDebug(@\"Started FS event stream\");\n}\n\n- (void)stopWatchingVimDir\n{\n    if (fsEventStream) {\n        FSEventStreamStop(fsEventStream);\n        FSEventStreamInvalidate(fsEventStream);\n        FSEventStreamRelease(fsEventStream);\n        fsEventStream = NULL;\n        ASLogDebug(@\"Stopped FS event stream\");\n    }\n}\n\n- (void)handleFSEvent\n{\n    [self clearPreloadCacheWithCount:-1];\n\n    // Several FS events may arrive in quick succession so make sure to cancel\n    // any previous preload requests before making a new one.\n    [self cancelVimControllerPreloadRequests];\n    [self scheduleVimControllerPreloadAfterDelay:0.5];\n}\n\n- (int)executeInLoginShell:(NSString *)path arguments:(NSArray *)args\n{\n    // Start a login shell and execute the command 'path' with arguments 'args'\n    // in the shell.  This ensures that user environment variables are set even\n    // when MacVim was started from the Finder.\n\n    int pid = -1;\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    // Determine which shell to use to execute the command.  The user\n    // may decide which shell to use by setting a user default or the\n    // $SHELL environment variable.\n    NSString *shell = [ud stringForKey:MMLoginShellCommandKey];\n    if (!shell || [shell length] == 0)\n        shell = [[[NSProcessInfo processInfo] environment]\n            objectForKey:@\"SHELL\"];\n    if (!shell)\n        shell = @\"/bin/bash\";\n\n    // Bash needs the '-l' flag to launch a login shell.  The user may add\n    // flags by setting a user default.\n    NSString *shellArgument = [ud stringForKey:MMLoginShellArgumentKey];\n    if (!shellArgument || [shellArgument length] == 0) {\n        if ([[shell lastPathComponent] isEqual:@\"bash\"])\n            shellArgument = @\"-l\";\n        else\n            shellArgument = nil;\n    }\n\n    // Build input string to pipe to the login shell.\n    NSMutableString *input = [NSMutableString stringWithFormat:\n            @\"exec \\\"%@\\\"\", path];\n    if (args) {\n        // Append all arguments, making sure they are properly quoted, even\n        // when they contain single quotes.\n        NSEnumerator *e = [args objectEnumerator];\n        id obj;\n\n        while ((obj = [e nextObject])) {\n            NSMutableString *arg = [NSMutableString stringWithString:obj];\n            [arg replaceOccurrencesOfString:@\"'\" withString:@\"'\\\"'\\\"'\"\n                                    options:NSLiteralSearch\n                                      range:NSMakeRange(0, [arg length])];\n            [input appendFormat:@\" '%@'\", arg];\n        }\n    }\n\n    // Build the argument vector used to start the login shell.\n    NSString *shellArg0 = [NSString stringWithFormat:@\"-%@\",\n             [shell lastPathComponent]];\n    char *shellArgv[3] = { (char *)[shellArg0 UTF8String], NULL, NULL };\n    if (shellArgument)\n        shellArgv[1] = (char *)[shellArgument UTF8String];\n\n    // Get the C string representation of the shell path before the fork since\n    // we must not call Foundation functions after a fork.\n    const char *shellPath = [shell fileSystemRepresentation];\n\n    // Fork and execute the process.\n    int ds[2];\n    if (pipe(ds)) return -1;\n\n    pid = fork();\n    if (pid == -1) {\n        return -1;\n    } else if (pid == 0) {\n        // Child process\n\n        if (close(ds[1]) == -1) exit(255);\n        if (dup2(ds[0], 0) == -1) exit(255);\n\n        // Without the following call warning messages like this appear on the\n        // console:\n        //     com.apple.launchd[69] : Stray process with PGID equal to this\n        //                             dead job: PID 1589 PPID 1 Vim\n        setsid();\n\n        execv(shellPath, shellArgv);\n\n        // Never reached unless execv fails\n        exit(255);\n    } else {\n        // Parent process\n        if (close(ds[0]) == -1) return -1;\n\n        // Send input to execute to the child process\n        [input appendString:@\"\\n\"];\n        int bytes = [input lengthOfBytesUsingEncoding:NSUTF8StringEncoding];\n\n        if (write(ds[1], [input UTF8String], bytes) != bytes) return -1;\n        if (close(ds[1]) == -1) return -1;\n\n        ++numChildProcesses;\n        ASLogDebug(@\"new process pid=%d (count=%d)\", pid, numChildProcesses);\n    }\n\n    return pid;\n}\n\n- (void)reapChildProcesses:(id)sender\n{\n    // NOTE: numChildProcesses (currently) only counts the number of Vim\n    // processes that have been started with executeInLoginShell::.  If other\n    // processes are spawned this code may need to be adjusted (or\n    // numChildProcesses needs to be incremented when such a process is\n    // started).\n    while (numChildProcesses > 0) {\n        int status = 0;\n        int pid = waitpid(-1, &status, WNOHANG);\n        if (pid <= 0)\n            break;\n\n        ASLogDebug(@\"Wait for pid=%d complete\", pid);\n        --numChildProcesses;\n    }\n}\n\n- (void)processInputQueues:(id)sender\n{\n    // NOTE: Because we use distributed objects it is quite possible for this\n    // function to be re-entered.  This can cause all sorts of unexpected\n    // problems so we guard against it here so that the rest of the code does\n    // not need to worry about it.\n\n    // The processing flag is > 0 if this function is already on the call\n    // stack; < 0 if this function was also re-entered.\n    if (processingFlag != 0) {\n        ASLogDebug(@\"BUSY!\");\n        processingFlag = -1;\n        return;\n    }\n\n    // NOTE: Be _very_ careful that no exceptions can be raised between here\n    // and the point at which 'processingFlag' is reset.  Otherwise the above\n    // test could end up always failing and no input queues would ever be\n    // processed!\n    processingFlag = 1;\n\n    // NOTE: New input may arrive while we're busy processing; we deal with\n    // this by putting the current queue aside and creating a new input queue\n    // for future input.\n    NSDictionary *queues = inputQueues;\n    inputQueues = [NSMutableDictionary new];\n\n    // Pass each input queue on to the vim controller with matching\n    // identifier (and note that it could be cached).\n    NSEnumerator *e = [queues keyEnumerator];\n    NSNumber *key;\n    while ((key = [e nextObject])) {\n        unsigned long ukey = [key unsignedLongValue];\n        int i = 0, count = [vimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [vimControllers objectAtIndex:i];\n            if (ukey == [vc vimControllerId]) {\n                [vc processInputQueue:[queues objectForKey:key]]; // !exceptions\n                break;\n            }\n        }\n\n        if (i < count) continue;\n\n        count = [cachedVimControllers count];\n        for (i = 0; i < count; ++i) {\n            MMVimController *vc = [cachedVimControllers objectAtIndex:i];\n            if (ukey == [vc vimControllerId]) {\n                [vc processInputQueue:[queues objectForKey:key]]; // !exceptions\n                break;\n            }\n        }\n\n        if (i == count) {\n            ASLogWarn(@\"No Vim controller for identifier=%lu\", ukey);\n        }\n    }\n\n    [queues release];\n\n    // If new input arrived while we were processing it would have been\n    // blocked so we have to schedule it to be processed again.\n    if (processingFlag < 0)\n        [self performSelectorOnMainThread:@selector(processInputQueues:)\n                               withObject:nil\n                            waitUntilDone:NO\n                                    modes:[NSArray arrayWithObjects:\n                                           NSDefaultRunLoopMode,\n                                           NSEventTrackingRunLoopMode, nil]];\n\n    processingFlag = 0;\n}\n\n- (void)addVimController:(MMVimController *)vc\n{\n    ASLogDebug(@\"Add Vim controller pid=%d id=%lu\",\n            [vc pid], [vc vimControllerId]);\n\n    int pid = [vc pid];\n    NSNumber *pidKey = [NSNumber numberWithInt:pid];\n    id args = [pidArguments objectForKey:pidKey];\n\n    if (preloadPid == pid) {\n        // This controller was preloaded, so add it to the cache and\n        // schedule another vim process to be preloaded.\n        preloadPid = -1;\n        [vc setIsPreloading:YES];\n        [cachedVimControllers addObject:vc];\n        [self scheduleVimControllerPreloadAfterDelay:1];\n    } else {\n        [vimControllers addObject:vc];\n\n        if (args && [NSNull null] != args)\n            [vc passArguments:args];\n\n        // HACK!  MacVim does not get activated if it is launched from the\n        // terminal, so we forcibly activate here.  Note that each process\n        // launched from MacVim has an entry in the pidArguments dictionary,\n        // which is how we detect if the process was launched from the\n        // terminal.\n        if (!args) [self activateWhenNextWindowOpens];\n    }\n\n    if (args)\n        [pidArguments removeObjectForKey:pidKey];\n}\n\n- (NSDictionary *)convertVimControllerArguments:(NSDictionary *)args\n                                  toCommandLine:(NSArray **)cmdline\n{\n    // Take all arguments out of 'args' and put them on an array suitable to\n    // pass as arguments to launchVimProcessWithArguments:.  The untouched\n    // dictionary items are returned in a new autoreleased dictionary.\n\n    if (cmdline)\n        *cmdline = nil;\n\n    NSArray *filenames = [args objectForKey:@\"filenames\"];\n    int numFiles = filenames ? [filenames count] : 0;\n    BOOL openFiles = ![[args objectForKey:@\"dontOpen\"] boolValue];\n\n    if (numFiles <= 0 || !openFiles)\n        return args;\n\n    NSMutableArray *a = [NSMutableArray array];\n    NSMutableDictionary *d = [[args mutableCopy] autorelease];\n\n    // Search for text and highlight it (this Vim script avoids warnings in\n    // case there is no match for the search text).\n    NSString *searchText = [args objectForKey:@\"searchText\"];\n    if (searchText && [searchText length] > 0) {\n        [a addObject:@\"-c\"];\n        NSString *s = [NSString stringWithFormat:@\"if search('\\\\V\\\\c%@','cW')\"\n                \"|let @/='\\\\V\\\\c%@'|set hls|endif\", searchText, searchText];\n        [a addObject:s];\n\n        [d removeObjectForKey:@\"searchText\"];\n    }\n\n    // Position cursor using \"+line\" or \"-c :cal cursor(line,column)\".\n    NSString *lineString = [args objectForKey:@\"cursorLine\"];\n    if (lineString && [lineString intValue] > 0) {\n        NSString *columnString = [args objectForKey:@\"cursorColumn\"];\n        if (columnString && [columnString intValue] > 0) {\n            [a addObject:@\"-c\"];\n            [a addObject:[NSString stringWithFormat:@\":cal cursor(%@,%@)\",\n                          lineString, columnString]];\n\n            [d removeObjectForKey:@\"cursorColumn\"];\n        } else {\n            [a addObject:[NSString stringWithFormat:@\"+%@\", lineString]];\n        }\n\n        [d removeObjectForKey:@\"cursorLine\"];\n    }\n\n    // Set selection using normal mode commands.\n    NSString *rangeString = [args objectForKey:@\"selectionRange\"];\n    if (rangeString) {\n        NSRange r = NSRangeFromString(rangeString);\n        [a addObject:@\"-c\"];\n        if (r.length > 0) {\n            // Select given range of characters.\n            // TODO: This only works for encodings where 1 byte == 1 character\n            [a addObject:[NSString stringWithFormat:@\"norm %ldgov%ldgo\",\n                                                r.location, NSMaxRange(r)-1]];\n        } else {\n            // Position cursor on line at start of range.\n            [a addObject:[NSString stringWithFormat:@\"norm %ldGz.0\",\n                                                                r.location]];\n        }\n\n        [d removeObjectForKey:@\"selectionRange\"];\n    }\n\n    // Choose file layout using \"-[o|O|p]\".\n    int layout = [[args objectForKey:@\"layout\"] intValue];\n    switch (layout) {\n        case MMLayoutHorizontalSplit: [a addObject:@\"-o\"]; break;\n        case MMLayoutVerticalSplit:   [a addObject:@\"-O\"]; break;\n        case MMLayoutTabs:            [a addObject:@\"-p\"]; break;\n    }\n    [d removeObjectForKey:@\"layout\"];\n\n\n    // Last of all add the names of all files to open (DO NOT add more args\n    // after this point).\n    [a addObjectsFromArray:filenames];\n\n    if ([args objectForKey:@\"remoteID\"]) {\n        // These files should be edited remotely so keep the filenames on the\n        // argument list -- they will need to be passed back to Vim when it\n        // checks in.  Also set the 'dontOpen' flag or the files will be\n        // opened twice.\n        [d setObject:[NSNumber numberWithBool:YES] forKey:@\"dontOpen\"];\n    } else {\n        [d removeObjectForKey:@\"dontOpen\"];\n        [d removeObjectForKey:@\"filenames\"];\n    }\n\n    if (cmdline)\n        *cmdline = a;\n\n    return d;\n}\n\n- (NSString *)workingDirectoryForArguments:(NSDictionary *)args\n{\n    // Find the \"filenames\" argument and pick the first path that actually\n    // exists and return it.\n    // TODO: Return common parent directory in the case of multiple files?\n    NSFileManager *fm = [NSFileManager defaultManager];\n    NSArray *filenames = [args objectForKey:@\"filenames\"];\n    NSUInteger i, count = [filenames count];\n    for (i = 0; i < count; ++i) {\n        BOOL isdir;\n        NSString *file = [filenames objectAtIndex:i];\n        if ([fm fileExistsAtPath:file isDirectory:&isdir])\n            return isdir ? file : [file stringByDeletingLastPathComponent];\n    }\n\n    return nil;\n}\n\n- (NSScreen *)screenContainingTopLeftPoint:(NSPoint)pt\n{\n    // NOTE: The top left point has y-coordinate which lies one pixel above the\n    // window which must be taken into consideration (this method used to be\n    // called screenContainingPoint: but that method is \"off by one\" in\n    // y-coordinate).\n\n    NSArray *screens = [NSScreen screens];\n    NSUInteger i, count = [screens count];\n    for (i = 0; i < count; ++i) {\n        NSScreen *screen = [screens objectAtIndex:i];\n        NSRect frame = [screen frame];\n        if (pt.x >= frame.origin.x && pt.x < NSMaxX(frame)\n                // NOTE: inequalities below are correct due to this being a top\n                // left test (see comment above)\n                && pt.y > frame.origin.y && pt.y <= NSMaxY(frame))\n            return screen;\n    }\n\n    return nil;\n}\n\n- (void)addInputSourceChangedObserver\n{\n    id nc = [NSDistributedNotificationCenter defaultCenter];\n    NSString *notifyInputSourceChanged =\n        (NSString *)kTISNotifySelectedKeyboardInputSourceChanged;\n    [nc addObserver:self\n           selector:@selector(inputSourceChanged:)\n               name:notifyInputSourceChanged\n             object:nil];\n}\n\n- (void)removeInputSourceChangedObserver\n{\n    id nc = [NSDistributedNotificationCenter defaultCenter];\n    [nc removeObserver:self];\n}\n\n- (void)inputSourceChanged:(NSNotification *)notification\n{\n    unsigned i, count = [vimControllers count];\n    for (i = 0; i < count; ++i) {\n        MMVimController *controller = [vimControllers objectAtIndex:i];\n        MMWindowController *wc = [controller windowController];\n        MMTextView *tv = (MMTextView *)[[wc vimView] textView];\n        [tv checkImState];\n    }\n}\n\n@end // MMAppController (Private)\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#import <Foundation/Foundation.h>\n#import \"MacVim.h\"\n#import \"vim.h\"\n\n\n@interface MMBackend : NSObject <MMBackendProtocol, MMVimServerProtocol,\n        MMVimClientProtocol> {\n    NSMutableArray      *outputQueue;\n    NSMutableArray      *inputQueue;\n    NSMutableData       *drawData;\n    NSConnection        *connection;\n    NSConnection        *vimServerConnection;\n    id                  appProxy;\n    unsigned long       identifier;\n    NSDictionary        *colorDict;\n    NSDictionary        *sysColorDict;\n    NSDictionary        *actionDict;\n    BOOL                tabBarVisible;\n    unsigned            backgroundColor;\n    unsigned            foregroundColor;\n    unsigned            specialColor;\n    unsigned            defaultBackgroundColor;\n    unsigned            defaultForegroundColor;\n    id                  dialogReturn;\n    NSTimer             *blinkTimer;\n    int                 blinkState;\n    NSTimeInterval      blinkWaitInterval;\n    NSTimeInterval      blinkOnInterval;\n    NSTimeInterval      blinkOffInterval;\n    NSMutableDictionary *connectionNameDict;\n    NSMutableDictionary *clientProxyDict;\n    NSMutableDictionary *serverReplyDict;\n    NSString            *alternateServerName;\n    GuiFont             oldWideFont;\n    BOOL                isTerminating;\n    BOOL                waitForAck;\n    int                 initialWindowLayout;\n    BOOL                flushDisabled;\n    unsigned            numWholeLineChanges;\n    unsigned            offsetForDrawDataPrune;\n    BOOL                imState;\n    int                 winposX;\n    int                 winposY;\n    BOOL                addToFindPboardOverride;\n#ifdef FEAT_BEVAL\n    NSString            *lastToolTip;\n#endif\n}\n\n+ (MMBackend *)sharedInstance;\n\n- (void)setBackgroundColor:(int)color;\n- (void)setForegroundColor:(int)color;\n- (void)setSpecialColor:(int)color;\n- (void)setDefaultColorsBackground:(int)bg foreground:(int)fg;\n- (NSConnection *)connection;\n- (NSDictionary *)actionDict;\n- (int)initialWindowLayout;\n- (void)getWindowPositionX:(int*)x Y:(int*)y;\n- (void)setWindowPositionX:(int)x Y:(int)y;\n\n- (void)queueMessage:(int)msgid properties:(NSDictionary *)props;\n- (BOOL)checkin;\n- (BOOL)openGUIWindow;\n- (void)clearAll;\n- (void)clearBlockFromRow:(int)row1 column:(int)col1\n                    toRow:(int)row2 column:(int)col2;\n- (void)deleteLinesFromRow:(int)row count:(int)count\n              scrollBottom:(int)bottom left:(int)left right:(int)right;\n- (void)drawString:(char_u*)s length:(int)len row:(int)row\n            column:(int)col cells:(int)cells flags:(int)flags;\n- (void)insertLinesFromRow:(int)row count:(int)count\n              scrollBottom:(int)bottom left:(int)left right:(int)right;\n- (void)drawCursorAtRow:(int)row column:(int)col shape:(int)shape\n               fraction:(int)percent color:(int)color;\n- (void)drawInvertedRectAtRow:(int)row column:(int)col numRows:(int)nr\n                   numColumns:(int)nc invert:(int)invert;\n- (void)drawSign:(NSString *)imgName\n           atRow:(int)row\n          column:(int)col\n           width:(int)width\n          height:(int)height;\n- (void)update;\n- (void)flushQueue:(BOOL)force;\n- (BOOL)waitForInput:(int)milliseconds;\n- (void)exit;\n- (void)selectTab:(int)index;\n- (void)updateTabBar;\n- (BOOL)tabBarVisible;\n- (void)showTabBar:(BOOL)enable;\n- (void)setRows:(int)rows columns:(int)cols;\n- (void)resizeView;\n- (void)setWindowTitle:(char *)title;\n- (void)setDocumentFilename:(char *)filename;\n- (char *)browseForFileWithAttributes:(NSDictionary *)attr;\n- (int)showDialogWithAttributes:(NSDictionary *)attr textField:(char *)txtfield;\n- (void)showToolbar:(int)enable flags:(int)flags;\n- (void)createScrollbarWithIdentifier:(int32_t)ident type:(int)type;\n- (void)destroyScrollbarWithIdentifier:(int32_t)ident;\n- (void)showScrollbarWithIdentifier:(int32_t)ident state:(int)visible;\n- (void)setScrollbarPosition:(int)pos length:(int)len identifier:(int32_t)ident;\n- (void)setScrollbarThumbValue:(long)val size:(long)size max:(long)max\n                    identifier:(int32_t)ident;\n- (void)setFont:(GuiFont)font wide:(BOOL)wide;\n- (void)executeActionWithName:(NSString *)name;\n- (void)setMouseShape:(int)shape;\n- (void)setBlinkWait:(int)wait on:(int)on off:(int)off;\n- (void)startBlink;\n- (void)stopBlink:(BOOL)updateCursor;\n- (void)adjustLinespace:(int)linespace;\n- (void)adjustColumnspace:(int)columnspace;\n- (void)activate;\n- (void)setPreEditRow:(int)row column:(int)col;\n\n- (void)showDefinition:(NSString *)text row:(int)row col:(int)col;\n\n- (int)lookupColorWithKey:(NSString *)key;\n- (BOOL)hasSpecialKeyWithValue:(char_u *)value;\n\n- (void)enterFullScreen:(int)fuoptions background:(int)bg;\n- (void)leaveFullScreen;\n- (void)setFullScreenBackgroundColor:(int)color;\n\n- (void)setAntialias:(BOOL)antialias;\n- (void)setLigatures:(BOOL)ligatures;\n- (void)setThinStrokes:(BOOL)thinStrokes;\n- (void)setBlurRadius:(int)radius;\n- (void)setBackground:(int)dark;\n\n- (void)updateModifiedFlag;\n\n- (void)registerServerWithName:(NSString *)name;\n- (BOOL)sendToServer:(NSString *)name string:(NSString *)string\n               reply:(char_u **)reply port:(int *)port expression:(BOOL)expr\n              silent:(BOOL)silent;\n- (NSArray *)serverList;\n- (NSString *)peekForReplyOnPort:(int)port;\n- (NSString *)waitForReplyOnPort:(int)port timeout:(NSTimeInterval)timeout;\n- (BOOL)sendReply:(NSString *)reply toPort:(int)port;\n\n- (BOOL)waitForAck;\n- (void)setWaitForAck:(BOOL)yn;\n- (void)waitForConnectionAcknowledgement;\n\n- (BOOL)addToFindPboardOverride;\n- (void)clearAddToFindPboardOverride;\n\n- (BOOL)imState;\n- (void)setImState:(BOOL)activated;\n\n#ifdef FEAT_BEVAL\n- (void)setLastToolTip:(NSString *)toolTip;\n#endif\n\n- (void)addToMRU:(NSArray *)filenames;\n\n@end\n\n\n\n@interface NSString (VimStrings)\n+ (id)stringWithVimString:(char_u *)s;\n- (char_u *)vimStringSave;\n@end\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#import \"MacVim.h\"\n\n\n@class MMWindowController;\n@class MMTouchBarInfo;\n\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12\n/// Button used for Touch Bar support, with an additional metadata to store the\n/// Vim command it should send.\n@interface MMTouchBarButton : NSButton {\n    NSArray *_desc;\n}\n- (NSArray *)desc;\n- (void)setDesc:(NSArray *)desc;\n@end\n#endif\n\n@interface MMVimController : NSObject<\n    NSToolbarDelegate\n    , NSOpenSavePanelDelegate\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    , NSTouchBarDelegate\n#endif\n    >\n{\n    unsigned long       identifier;\n    BOOL                isInitialized;\n    MMWindowController  *windowController;\n    id                  backendProxy;\n    NSMenu              *mainMenu;\n    NSMutableArray      *popupMenuItems;\n\n    // TODO: Move all toolbar code to window controller?\n    NSToolbar           *toolbar;\n    NSMutableDictionary *toolbarItemDict;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    MMTouchBarInfo      *touchbarInfo;\n#endif\n\n    int                 pid;\n    NSString            *serverName;\n    NSDictionary        *vimState;\n    BOOL                isPreloading;\n    NSDate              *creationDate;\n    BOOL                hasModifiedBuffer;\n}\n\n- (id)initWithBackend:(id)backend pid:(int)processIdentifier;\n- (void)uninitialize;\n- (unsigned long)vimControllerId;\n- (id)backendProxy;\n- (int)pid;\n- (void)setServerName:(NSString *)name;\n- (NSString *)serverName;\n- (MMWindowController *)windowController;\n- (NSDictionary *)vimState;\n- (id)objectForVimStateKey:(NSString *)key;\n- (NSMenu *)mainMenu;\n- (BOOL)isPreloading;\n- (void)setIsPreloading:(BOOL)yn;\n- (BOOL)hasModifiedBuffer;\n- (NSDate *)creationDate;\n- (void)cleanup;\n- (void)dropFiles:(NSArray *)filenames forceOpen:(BOOL)force;\n- (void)file:(NSString *)filename draggedToTabAtIndex:(NSUInteger)tabIndex;\n- (void)filesDraggedToTabBar:(NSArray *)filenames;\n- (void)dropString:(NSString *)string;\n- (void)appearanceChanged:(int)flag;\n\n- (void)passArguments:(NSDictionary *)args;\n- (void)sendMessage:(int)msgid data:(NSData *)data;\n- (BOOL)sendMessageNow:(int)msgid data:(NSData *)data\n               timeout:(NSTimeInterval)timeout;\n- (void)addVimInput:(NSString *)string;\n- (NSString *)evaluateVimExpression:(NSString *)expr;\n- (id)evaluateVimExpressionCocoa:(NSString *)expr\n                     errorString:(NSString **)errstr;\n- (void)processInputQueue:(NSArray *)queue;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (NSTouchBar *)makeTouchBar;\n#endif\n@end\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * MMVimController\n *\n * Coordinates input/output to/from backend.  A MMVimController sends input\n * directly to a MMBackend, but communication from MMBackend to MMVimController\n * goes via MMAppController so that it can coordinate all incoming distributed\n * object messages.\n *\n * MMVimController does not deal with visual presentation.  Essentially it\n * should be able to run with no window present.\n *\n * Output from the backend is received in processInputQueue: (this message is\n * called from MMAppController so it is not a DO call).  Input is sent to the\n * backend via sendMessage:data: or addVimInput:.  The latter allows execution\n * of arbitrary strings in the Vim process, much like the Vim script function\n * remote_send() does.  The messages that may be passed between frontend and\n * backend are defined in an enum in MacVim.h.\n */\n\n#import \"MMAppController.h\"\n#import \"MMFindReplaceController.h\"\n#import \"MMTextView.h\"\n#import \"MMVimController.h\"\n#import \"MMVimView.h\"\n#import \"MMWindowController.h\"\n#import \"Miscellaneous.h\"\n#import \"MMCoreTextView.h\"\n#import \"MMWindow.h\"\n\n\nstatic NSString * const MMDefaultToolbarImageName = @\"Attention\";\nstatic int MMAlertTextFieldHeight = 22;\n\nstatic NSString * const MMToolbarMenuName = @\"ToolBar\";\nstatic NSString * const MMTouchbarMenuName = @\"TouchBar\";\nstatic NSString * const MMWinBarMenuName = @\"WinBar\";\nstatic NSString * const MMPopUpMenuPrefix = @\"PopUp\";\nstatic NSString * const MMUserPopUpMenuPrefix = @\"]\";\n\n// NOTE: By default a message sent to the backend will be dropped if it cannot\n// be delivered instantly; otherwise there is a possibility that MacVim will\n// 'beachball' while waiting to deliver DO messages to an unresponsive Vim\n// process.  This means that you cannot rely on any message sent with\n// sendMessage: to actually reach Vim.\nstatic NSTimeInterval MMBackendProxyRequestTimeout = 0;\n\n// Timeout used for setDialogReturn:.\nstatic NSTimeInterval MMSetDialogReturnTimeout = 1.0;\n\nstatic BOOL isUnsafeMessage(int msgid);\n\n\n// HACK! AppKit private methods from NSToolTipManager.  As an alternative to\n// using private methods, it would be possible to set the user default\n// NSInitialToolTipDelay (in ms) on app startup, but then it is impossible to\n// change the balloon delay without closing/reopening a window.\n@interface NSObject (NSToolTipManagerPrivateAPI)\n+ (id)sharedToolTipManager;\n- (void)setInitialToolTipDelay:(double)arg1;\n@end\n\n\n@interface MMAlert : NSAlert {\n    NSTextField *textField;\n}\n- (void)setTextFieldString:(NSString *)textFieldString;\n- (NSTextField *)textField;\n- (void)beginSheetModalForWindow:(NSWindow *)window\n                   modalDelegate:(id)delegate;\n@end\n\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_12\n@interface MMTouchBarInfo : NSObject;\n\n@property (readonly) NSTouchBar *touchbar;\n@property (readonly) NSMutableDictionary *itemDict;\n@property (readonly) NSMutableArray *itemOrder;\n\n@end\n\n@interface MMTouchBarItemInfo : NSObject;\n\n@property (readonly) NSTouchBarItem     *touchbarItem;\n@property (readwrite) BOOL              enabled;\n@property (readonly) NSString           *label;\n\n@property (readonly) MMTouchBarInfo     *childTouchbar; // Set when this is a submenu\n\n- (id)initWithItem:(NSTouchBarItem *)item label:(NSString *)label;\n- (void)setTouchBarItem:(NSTouchBarItem *)item;\n- (void)makeChildTouchBar;\n@end\n#endif\n\n@interface MMVimController (Private)\n- (void)doProcessInputQueue:(NSArray *)queue;\n- (void)handleMessage:(int)msgid data:(NSData *)data;\n- (void)savePanelDidEnd:(NSSavePanel *)panel code:(int)code\n                context:(void *)context;\n- (void)alertDidEnd:(MMAlert *)alert code:(int)code context:(void *)context;\n- (NSMenuItem *)menuItemForDescriptor:(NSArray *)desc;\n- (NSMenu *)parentMenuForDescriptor:(NSArray *)desc;\n- (NSMenu *)topLevelMenuForTitle:(NSString *)title;\n- (void)addMenuWithDescriptor:(NSArray *)desc atIndex:(int)index;\n- (void)addMenuItemWithDescriptor:(NSArray *)desc\n                          atIndex:(int)index\n                              tip:(NSString *)tip\n                             icon:(NSString *)icon\n                    keyEquivalent:(NSString *)keyEquivalent\n                     modifierMask:(int)modifierMask\n                           action:(NSString *)action\n                      isAlternate:(BOOL)isAlternate;\n- (void)removeMenuItemWithDescriptor:(NSArray *)desc;\n- (void)enableMenuItemWithDescriptor:(NSArray *)desc state:(BOOL)on;\n- (void)updateMenuItemTooltipWithDescriptor:(NSArray *)desc tip:(NSString *)tip;\n- (NSImage*)findToolbarIcon:(NSString*)icon;\n- (void)addToolbarItemToDictionaryWithLabel:(NSString *)title\n        toolTip:(NSString *)tip icon:(NSString *)icon;\n- (void)addToolbarItemWithLabel:(NSString *)label\n                          tip:(NSString *)tip icon:(NSString *)icon\n                      atIndex:(int)idx;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (void)addTouchbarItemWithLabel:(NSString *)label\n                            icon:(NSString *)icon\n                             tip:(NSString *)tip\n                         atIndex:(int)idx\n                       isSubMenu:(BOOL)submenu\n                            desc:(NSArray *)desc\n                      atTouchBar:(MMTouchBarInfo *)touchbarInfo;\n- (void)updateTouchbarItemLabel:(NSString *)label\n                            tip:(NSString *)tip\n                 atTouchBarItem:(MMTouchBarItemInfo*)item;\n- (BOOL)touchBarItemForDescriptor:(NSArray *)desc\n                         touchBar:(MMTouchBarInfo **)touchBarPtr\n                     touchBarItem:(MMTouchBarItemInfo **)touchBarItemPtr;\n#endif\n- (void)popupMenuWithDescriptor:(NSArray *)desc\n                          atRow:(NSNumber *)row\n                         column:(NSNumber *)col;\n- (void)popupMenuWithAttributes:(NSDictionary *)attrs;\n- (void)connectionDidDie:(NSNotification *)notification;\n- (void)scheduleClose;\n- (void)handleBrowseForFile:(NSDictionary *)attr;\n- (void)handleShowDialog:(NSDictionary *)attr;\n- (void)handleDeleteSign:(NSDictionary *)attr;\n- (void)setToolTipDelay;\n@end\n\n\n\n\n@implementation MMVimController\n\n- (id)initWithBackend:(id)backend pid:(int)processIdentifier\n{\n    if (!(self = [super init]))\n        return nil;\n\n    // Use a random identifier. Currently, MMBackend connects using a public\n    // NSConnection, which has security implications. Using random identifiers\n    // make it much harder for third-party attacker to spoof.\n    int secSuccess = SecRandomCopyBytes(kSecRandomDefault, sizeof(identifier), &identifier);\n    if (secSuccess != errSecSuccess) {\n        // Don't know what concrete reasons secure random would fail, but just\n        // as a failsafe, use a less secure option.\n        identifier = ((unsigned long)arc4random()) << 32 | (unsigned long)arc4random();\n    }\n\n    windowController =\n        [[MMWindowController alloc] initWithVimController:self];\n    backendProxy = [backend retain];\n    popupMenuItems = [[NSMutableArray alloc] init];\n    toolbarItemDict = [[NSMutableDictionary alloc] init];\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n        touchbarInfo = [[MMTouchBarInfo alloc] init];\n    }\n#endif\n    pid = processIdentifier;\n    creationDate = [[NSDate alloc] init];\n\n    NSConnection *connection = [backendProxy connectionForProxy];\n\n    // TODO: Check that this will not set the timeout for the root proxy\n    // (in MMAppController).\n    [connection setRequestTimeout:MMBackendProxyRequestTimeout];\n\n    [[NSNotificationCenter defaultCenter] addObserver:self\n            selector:@selector(connectionDidDie:)\n                name:NSConnectionDidDieNotification object:connection];\n\n    // Set up a main menu with only a \"MacVim\" menu (copied from a template\n    // which itself is set up in MainMenu.nib).  The main menu is populated\n    // by Vim later on.\n    mainMenu = [[NSMenu alloc] initWithTitle:@\"MainMenu\"];\n    NSMenuItem *appMenuItem = [[MMAppController sharedInstance]\n                                        appMenuItemTemplate];\n    appMenuItem = [[appMenuItem copy] autorelease];\n\n    // Note: If the title of the application menu is anything but what\n    // CFBundleName says then the application menu will not be typeset in\n    // boldface for some reason.  (It should already be set when we copy\n    // from the default main menu, but this is not the case for some\n    // reason.)\n    NSString *appName = [[NSBundle mainBundle]\n            objectForInfoDictionaryKey:@\"CFBundleName\"];\n    [appMenuItem setTitle:appName];\n\n    [mainMenu addItem:appMenuItem];\n\n    [self setToolTipDelay];\n\n    isInitialized = YES;\n\n    // After MMVimController's initialization is completed,\n    // set up the variable `v:os_appearance`.\n    [self appearanceChanged:getCurrentAppearance([windowController vimView].effectiveAppearance)];\n    \n    return self;\n}\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    isInitialized = NO;\n\n    [serverName release];  serverName = nil;\n    [backendProxy release];  backendProxy = nil;\n\n    [toolbarItemDict release];  toolbarItemDict = nil;\n    [toolbar release];  toolbar = nil;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n    [touchbarInfo release]; touchbarInfo = nil;\n#endif\n    [popupMenuItems release];  popupMenuItems = nil;\n    [windowController release];  windowController = nil;\n\n    [vimState release];  vimState = nil;\n    [mainMenu release];  mainMenu = nil;\n    [creationDate release];  creationDate = nil;\n\n    [super dealloc];\n}\n\n/// This should only be called by MMAppController when it's doing an app quit.\n/// We just wait for all Vim processes to terminate instad of individually\n/// closing each MMVimController. We simply unset isInitialized to prevent it\n/// from handling and sending messages to now invalid Vim connections.\n- (void)uninitialize\n{\n    isInitialized = NO;\n}\n\n- (unsigned long)vimControllerId\n{\n    return identifier;\n}\n\n- (MMWindowController *)windowController\n{\n    return windowController;\n}\n\n- (NSDictionary *)vimState\n{\n    return vimState;\n}\n\n- (id)objectForVimStateKey:(NSString *)key\n{\n    return [vimState objectForKey:key];\n}\n\n- (NSMenu *)mainMenu\n{\n    return mainMenu;\n}\n\n- (BOOL)isPreloading\n{\n    return isPreloading;\n}\n\n- (void)setIsPreloading:(BOOL)yn\n{\n    isPreloading = yn;\n}\n\n- (BOOL)hasModifiedBuffer\n{\n    return hasModifiedBuffer;\n}\n\n- (NSDate *)creationDate\n{\n    return creationDate;\n}\n\n- (void)setServerName:(NSString *)name\n{\n    if (name != serverName) {\n        [serverName release];\n        serverName = [name copy];\n    }\n}\n\n- (NSString *)serverName\n{\n    return serverName;\n}\n\n- (int)pid\n{\n    return pid;\n}\n\n- (void)dropFiles:(NSArray *)filenames forceOpen:(BOOL)force\n{\n    filenames = normalizeFilenames(filenames);\n    ASLogInfo(@\"filenames=%@ force=%d\", filenames, force);\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n\n    // Default to opening in tabs if layout is invalid or set to \"windows\".\n    int layout = [ud integerForKey:MMOpenLayoutKey];\n    if (layout < 0 || layout > MMLayoutTabs)\n        layout = MMLayoutTabs;\n\n    BOOL splitVert = [ud boolForKey:MMVerticalSplitKey];\n    if (splitVert && MMLayoutHorizontalSplit == layout)\n        layout = MMLayoutVerticalSplit;\n\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n            [NSNumber numberWithInt:layout],    @\"layout\",\n            filenames,                          @\"filenames\",\n            [NSNumber numberWithBool:force],    @\"forceOpen\",\n            nil];\n\n    [self sendMessage:DropFilesMsgID data:[args dictionaryAsData]];\n\n    // Add dropped files to the \"Recent Files\" menu.\n    [[NSDocumentController sharedDocumentController]\n                                            noteNewRecentFilePaths:filenames];\n}\n\n// This is called when a file is dragged on top of a tab. We will open the file\n// list similar to drag-and-dropped files.\n- (void)file:(NSString *)filename draggedToTabAtIndex:(NSUInteger)tabIndex\n{\n    filename = normalizeFilename(filename);\n    ASLogInfo(@\"filename=%@ index=%ld\", filename, tabIndex);\n\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    \n    // This is similar to dropFiles:forceOpen: except we first switch to the\n    // selected tab, and just open the first file (this could be modified in the\n    // future to support multiple files). It also forces layout to be splits\n    // because we specified one tab to receive the file so doesn't make sense to\n    // open another tab.\n    int layout = MMLayoutHorizontalSplit;\n    if ([ud boolForKey:MMVerticalSplitKey])\n        layout = MMLayoutVerticalSplit;\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                          [NSNumber numberWithInt:layout],    @\"layout\",\n                          @[filename],                        @\"filenames\",\n                          [NSNumber numberWithInt:tabIndex + 1],    @\"tabpage\",\n                          nil];\n    \n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n// This is called when a file is dragged on top of the tab bar but not a\n// particular tab (e.g. the new tab button). We will open the file list similar\n// to drag-and-dropped files.\n- (void)filesDraggedToTabBar:(NSArray *)filenames\n{\n    filenames = normalizeFilenames(filenames);\n    ASLogInfo(@\"%@\", filenames);\n    \n    // This is similar to dropFiles:forceOpen: except we just force layout to be\n    // tabs (since the receipient is the tab bar, we assume that's the\n    // intention) instead of loading from user defaults.\n    int layout = MMLayoutTabs;\n    NSDictionary *args = [NSDictionary dictionaryWithObjectsAndKeys:\n                          [NSNumber numberWithInt:layout],    @\"layout\",\n                          filenames,                          @\"filenames\",\n                          nil];\n    \n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n- (void)dropString:(NSString *)string\n{\n    ASLogInfo(@\"%@\", string);\n    int len = [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding] + 1;\n    if (len > 0) {\n        NSMutableData *data = [NSMutableData data];\n\n        [data appendBytes:&len length:sizeof(int)];\n        [data appendBytes:[string UTF8String] length:len];\n\n        [self sendMessage:DropStringMsgID data:data];\n    }\n}\n\n- (void)appearanceChanged:(int)flag\n{\n    [self sendMessage:NotifyAppearanceChangeMsgID\n                 data:[NSData dataWithBytes: &flag\n               length:sizeof(flag)]];\n}\n\n- (void)passArguments:(NSDictionary *)args\n{\n    if (!args) return;\n\n    ASLogDebug(@\"args=%@\", args);\n\n    [self sendMessage:OpenWithArgumentsMsgID data:[args dictionaryAsData]];\n}\n\n- (void)sendMessage:(int)msgid data:(NSData *)data\n{\n    ASLogDebug(@\"msg=%s (isInitialized=%d)\",\n               MMVimMsgIDStrings[msgid], isInitialized);\n\n    if (!isInitialized) return;\n\n    @try {\n        [backendProxy processInput:msgid data:data];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"processInput:data: failed: pid=%d id=%lu msg=%s reason=%@\",\n                pid, identifier, MMVimMsgIDStrings[msgid], ex);\n    }\n}\n\n- (BOOL)sendMessageNow:(int)msgid data:(NSData *)data\n               timeout:(NSTimeInterval)timeout\n{\n    // Send a message with a timeout.  USE WITH EXTREME CAUTION!  Sending\n    // messages in rapid succession with a timeout may cause MacVim to beach\n    // ball forever.  In almost all circumstances sendMessage:data: should be\n    // used instead.\n\n    ASLogDebug(@\"msg=%s (isInitialized=%d)\",\n               MMVimMsgIDStrings[msgid], isInitialized);\n\n    if (!isInitialized)\n        return NO;\n\n    if (timeout < 0) timeout = 0;\n\n    BOOL sendOk = YES;\n    NSConnection *conn = [backendProxy connectionForProxy];\n    NSTimeInterval oldTimeout = [conn requestTimeout];\n\n    [conn setRequestTimeout:timeout];\n\n    @try {\n        [backendProxy processInput:msgid data:data];\n    }\n    @catch (NSException *ex) {\n        sendOk = NO;\n        ASLogDebug(@\"processInput:data: failed: pid=%d id=%lu msg=%s reason=%@\",\n                pid, identifier, MMVimMsgIDStrings[msgid], ex);\n    }\n    @finally {\n        [conn setRequestTimeout:oldTimeout];\n    }\n\n    return sendOk;\n}\n\n- (void)addVimInput:(NSString *)string\n{\n    ASLogDebug(@\"%@\", string);\n\n    // This is a very general method of adding input to the Vim process.  It is\n    // basically the same as calling remote_send() on the process (see\n    // ':h remote_send').\n    if (string) {\n        NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];\n        [self sendMessage:AddInputMsgID data:data];\n    }\n}\n\n- (NSString *)evaluateVimExpression:(NSString *)expr\n{\n    NSString *eval = nil;\n\n    @try {\n        eval = [backendProxy evaluateExpression:expr];\n        ASLogDebug(@\"eval(%@)=%@\", expr, eval);\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"evaluateExpression: failed: pid=%d id=%lu reason=%@\",\n                pid, identifier, ex);\n    }\n\n    return eval;\n}\n\n- (id)evaluateVimExpressionCocoa:(NSString *)expr\n                     errorString:(NSString **)errstr\n{\n    id eval = nil;\n\n    @try {\n        eval = [backendProxy evaluateExpressionCocoa:expr\n                                         errorString:errstr];\n        ASLogDebug(@\"eval(%@)=%@\", expr, eval);\n    } @catch (NSException *ex) {\n        ASLogDebug(@\"evaluateExpressionCocoa: failed: pid=%d id=%lu reason=%@\",\n                pid, identifier, ex);\n        *errstr = [ex reason];\n    }\n\n    return eval;\n}\n\n- (id)backendProxy\n{\n    return backendProxy;\n}\n\n- (void)cleanup\n{\n    if (!isInitialized) return;\n\n    // Remove any delayed calls made on this object.\n    [NSObject cancelPreviousPerformRequestsWithTarget:self];\n\n    isInitialized = NO;\n    [toolbar setDelegate:nil];\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    //[[backendProxy connectionForProxy] invalidate];\n    //[windowController close];\n    [windowController cleanup];\n}\n\n- (void)processInputQueue:(NSArray *)queue\n{\n    if (!isInitialized) return;\n\n    // NOTE: This method must not raise any exceptions (see comment in the\n    // calling method).\n    @try {\n        [self doProcessInputQueue:queue];\n        [windowController processInputQueueDidFinish];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"Exception: pid=%d id=%lu reason=%@\", pid, identifier, ex);\n    }\n}\n\n- (NSToolbarItem *)toolbar:(NSToolbar *)theToolbar\n    itemForItemIdentifier:(NSString *)itemId\n    willBeInsertedIntoToolbar:(BOOL)flag\n{\n    NSToolbarItem *item = [toolbarItemDict objectForKey:itemId];\n    if (!item) {\n        ASLogWarn(@\"No toolbar item with id '%@'\", itemId);\n    }\n\n    return item;\n}\n\n- (NSArray *)toolbarAllowedItemIdentifiers:(NSToolbar *)theToolbar\n{\n    return nil;\n}\n\n- (NSArray *)toolbarDefaultItemIdentifiers:(NSToolbar *)theToolbar\n{\n    return nil;\n}\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (NSTouchBar *)makeTouchBarOn:(MMTouchBarInfo *)touchbarInfo\n{\n    NSMutableArray *filteredTouchbarItemOrder = [NSMutableArray array];\n    NSMutableSet *filteredItems = [NSMutableSet set];\n    for (NSString *label in touchbarInfo.itemOrder) {\n        MMTouchBarItemInfo *itemInfo = [touchbarInfo.itemDict objectForKey:label];\n        if ([itemInfo enabled]) {\n            [filteredTouchbarItemOrder addObject:[itemInfo label]];\n            \n            if ([itemInfo touchbarItem]) {\n                if ([itemInfo childTouchbar]) {\n                    NSTouchBar *childTouchbar = [self makeTouchBarOn:[itemInfo childTouchbar]];\n                    NSPopoverTouchBarItem *popoverItem = (NSPopoverTouchBarItem *)[itemInfo touchbarItem];\n                    [popoverItem setPopoverTouchBar:childTouchbar];\n                }\n\n                [filteredItems addObject:itemInfo.touchbarItem];\n            }\n        }\n    }\n    [filteredTouchbarItemOrder addObject:NSTouchBarItemIdentifierOtherItemsProxy];\n    \n    touchbarInfo.touchbar.defaultItemIdentifiers = filteredTouchbarItemOrder;\n    touchbarInfo.touchbar.templateItems = filteredItems;\n    return touchbarInfo.touchbar;\n}\n\n- (NSTouchBar *)makeTouchBar\n{\n    return [self makeTouchBarOn:touchbarInfo];\n}\n\n#endif\n\n@end // MMVimController\n\n\n@implementation MMVimController (Private)\n\n- (void)doProcessInputQueue:(NSArray *)queue\n{\n    NSMutableArray *delayQueue = nil;\n\n    unsigned i, count = [queue count];\n    if (count % 2) {\n        ASLogWarn(@\"Uneven number of components (%d) in command queue.  \"\n                  \"Skipping...\", count);\n        return;\n    }\n\n    for (i = 0; i < count; i += 2) {\n        NSData *value = [queue objectAtIndex:i];\n        NSData *data = [queue objectAtIndex:i+1];\n\n        int msgid = *((int*)[value bytes]);\n\n        BOOL inDefaultMode = [[[NSRunLoop currentRunLoop] currentMode]\n                                            isEqual:NSDefaultRunLoopMode];\n        if (!inDefaultMode && isUnsafeMessage(msgid)) {\n            // NOTE: Because we may be listening to DO messages in \"event\n            // tracking mode\" we have to take extra care when doing things\n            // like releasing view items (and other Cocoa objects).\n            // Messages that may be potentially \"unsafe\" are delayed until\n            // the run loop is back to default mode at which time they are\n            // safe to call again.\n            //   A problem with this approach is that it is hard to\n            // classify which messages are unsafe.  As a rule of thumb, if\n            // a message may release an object used by the Cocoa framework\n            // (e.g. views) then the message should be considered unsafe.\n            //   Delaying messages may have undesired side-effects since it\n            // means that messages may not be processed in the order Vim\n            // sent them, so beware.\n            if (!delayQueue)\n                delayQueue = [NSMutableArray array];\n\n            ASLogDebug(@\"Adding unsafe message '%s' to delay queue (mode=%@)\",\n                       MMVimMsgIDStrings[msgid],\n                       [[NSRunLoop currentRunLoop] currentMode]);\n            [delayQueue addObject:value];\n            [delayQueue addObject:data];\n        } else {\n            [self handleMessage:msgid data:data];\n        }\n    }\n\n    if (delayQueue) {\n        ASLogDebug(@\"    Flushing delay queue (%ld items)\",\n                   [delayQueue count]/2);\n        [self performSelector:@selector(processInputQueue:)\n                   withObject:delayQueue\n                   afterDelay:0];\n    }\n}\n\n- (void)handleMessage:(int)msgid data:(NSData *)data\n{\n    switch (msgid) {\n        case OpenWindowMsgID:\n        {\n            [windowController openWindow];\n            if (!isPreloading) {\n                [windowController presentWindow:nil];\n            }\n        }\n        break;\n        case BatchDrawMsgID:\n        {\n            [[[windowController vimView] textView] performBatchDrawWithData:data];\n        }\n        break;\n        case SelectTabMsgID:\n        {\n    #if 0   // NOTE: Tab selection is done inside updateTabsWithData:.\n            const void *bytes = [data bytes];\n            int idx = *((int*)bytes);\n            [windowController selectTabWithIndex:idx];\n    #endif\n        }\n        break;\n        case UpdateTabBarMsgID:\n        {\n            [windowController updateTabsWithData:data];\n        }\n        break;\n        case ShowTabBarMsgID:\n        {\n            [windowController showTabBar:YES];\n            [self sendMessage:BackingPropertiesChangedMsgID data:nil];\n        }\n        break;\n        case HideTabBarMsgID:\n        {\n            [windowController showTabBar:NO];\n            [self sendMessage:BackingPropertiesChangedMsgID data:nil];\n        }\n        break;\n\n        case SetTextDimensionsMsgID:\n        case LiveResizeMsgID:\n        case SetTextDimensionsNoResizeWindowMsgID:\n        case SetTextDimensionsReplyMsgID:\n        {\n            const void *bytes = [data bytes];\n            int rows = *((int*)bytes);  bytes += sizeof(int);\n            int cols = *((int*)bytes);\n\n            // NOTE: When a resize message originated in the frontend, Vim\n            // acknowledges it with a reply message.  When this happens the window\n            // should not move (the frontend would already have moved the window).\n            BOOL onScreen = SetTextDimensionsReplyMsgID!=msgid;\n\n            BOOL keepGUISize = SetTextDimensionsNoResizeWindowMsgID == msgid;\n\n            [windowController setTextDimensionsWithRows:rows\n                                     columns:cols\n                                      isLive:(LiveResizeMsgID==msgid)\n                                keepGUISize:keepGUISize\n                                keepOnScreen:onScreen];\n        }\n        break;\n\n        case ResizeViewMsgID:\n        {\n            [windowController resizeView];\n        }\n        break;\n        case SetWindowTitleMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n\n            NSString *string = [[NSString alloc] initWithBytes:(void*)bytes\n                    length:len encoding:NSUTF8StringEncoding];\n\n            [windowController setTitle:string];\n\n            [string release];\n        }\n        break;\n        case SetDocumentFilenameMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n\n            if (len > 0) {\n                NSString *filename = [[NSString alloc] initWithBytes:(void*)bytes\n                        length:len encoding:NSUTF8StringEncoding];\n\n                [windowController setDocumentFilename:filename];\n\n                [filename release];\n            } else {\n                [windowController setDocumentFilename:@\"\"];\n            }\n        }\n        break;\n        case AddMenuMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self addMenuWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                    atIndex:[[attrs objectForKey:@\"index\"] intValue]];\n        }\n        break;\n        case AddMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self addMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                          atIndex:[[attrs objectForKey:@\"index\"] intValue]\n                              tip:[attrs objectForKey:@\"tip\"]\n                             icon:[attrs objectForKey:@\"icon\"]\n                    keyEquivalent:[attrs objectForKey:@\"keyEquivalent\"]\n                     modifierMask:[[attrs objectForKey:@\"modifierMask\"] intValue]\n                           action:[attrs objectForKey:@\"action\"]\n                      isAlternate:[[attrs objectForKey:@\"isAlternate\"] boolValue]];\n        }\n        break;\n        case RemoveMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self removeMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]];\n        }\n        break;\n        case EnableMenuItemMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self enableMenuItemWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                    state:[[attrs objectForKey:@\"enable\"] boolValue]];\n        }\n        break;\n        case UpdateMenuItemTooltipMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n            [self updateMenuItemTooltipWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                                                  tip:[attrs objectForKey:@\"tip\"]];\n        }\n        break;\n        case ShowToolbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int enable = *((int*)bytes);  bytes += sizeof(int);\n            int flags = *((int*)bytes);\n\n            int mode = NSToolbarDisplayModeDefault;\n            if (flags & ToolbarLabelFlag) {\n                mode = flags & ToolbarIconFlag ? NSToolbarDisplayModeIconAndLabel\n                        : NSToolbarDisplayModeLabelOnly;\n            } else if (flags & ToolbarIconFlag) {\n                mode = NSToolbarDisplayModeIconOnly;\n            }\n\n            int size = flags & ToolbarSizeRegularFlag ? NSToolbarSizeModeRegular\n                    : NSToolbarSizeModeSmall;\n\n            [windowController showToolbar:enable size:size mode:mode];\n        }\n        break;\n        case CreateScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int type = *((int*)bytes);\n\n            [windowController createScrollbarWithIdentifier:ident type:type];\n        }\n        break;\n        case DestroyScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);\n\n            [windowController destroyScrollbarWithIdentifier:ident];\n        }\n        break;\n        case ShowScrollbarMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int visible = *((int*)bytes);\n\n            [windowController showScrollbarWithIdentifier:ident state:visible];\n        }\n        break;\n        case SetScrollbarPositionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            int pos = *((int*)bytes);  bytes += sizeof(int);\n            int len = *((int*)bytes);\n\n            [windowController setScrollbarPosition:pos length:len\n                                        identifier:ident];\n        }\n        break;\n        case SetScrollbarThumbMsgID:\n        {\n            const void *bytes = [data bytes];\n            int32_t ident = *((int32_t*)bytes);  bytes += sizeof(int32_t);\n            float val = *((float*)bytes);  bytes += sizeof(float);\n            float prop = *((float*)bytes);\n\n            [windowController setScrollbarThumbValue:val proportion:prop\n                                          identifier:ident];\n        }\n        break;\n        case SetFontMsgID:\n        {\n            const void *bytes = [data bytes];\n            float size = *((float*)bytes);  bytes += sizeof(float);\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            NSString *name = [[NSString alloc]\n                    initWithBytes:(void*)bytes length:len\n                         encoding:NSUTF8StringEncoding];\n            NSFont *font = [NSFont fontWithName:name size:size];\n            if (!font) {\n                // This should only happen if the system default font has changed\n                // name since MacVim was compiled in which case we fall back on\n                // using the user fixed width font.\n                ASLogInfo(@\"Failed to load font '%@' / %f\", name, size);\n                font = [NSFont userFixedPitchFontOfSize:size];\n            }\n\n            [windowController setFont:font];\n            [name release];\n        }\n        break;\n        case SetWideFontMsgID:\n        {\n            const void *bytes = [data bytes];\n            float size = *((float*)bytes);  bytes += sizeof(float);\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            if (len > 0) {\n                NSString *name = [[NSString alloc]\n                        initWithBytes:(void*)bytes length:len\n                             encoding:NSUTF8StringEncoding];\n                NSFont *font = [NSFont fontWithName:name size:size];\n                [windowController setWideFont:font];\n\n                [name release];\n            } else {\n                [windowController setWideFont:nil];\n            }\n        }\n        break;\n        case SetDefaultColorsMsgID:\n        {\n            const void *bytes = [data bytes];\n            unsigned bg = *((unsigned*)bytes);  bytes += sizeof(unsigned);\n            unsigned fg = *((unsigned*)bytes);\n            NSColor *back = [NSColor colorWithArgbInt:bg];\n            NSColor *fore = [NSColor colorWithRgbInt:fg];\n\n            [windowController setDefaultColorsBackground:back foreground:fore];\n        }\n        break;\n        case ExecuteActionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int len = *((int*)bytes);  bytes += sizeof(int);\n            NSString *actionName = [[NSString alloc]\n                    initWithBytes:(void*)bytes length:len\n                         encoding:NSUTF8StringEncoding];\n\n            SEL sel = NSSelectorFromString(actionName);\n            [NSApp sendAction:sel to:nil from:self];\n\n            [actionName release];\n        }\n        break;\n        case ShowPopupMenuMsgID:\n        {\n            NSDictionary *attrs = [NSDictionary dictionaryWithData:data];\n\n            // The popup menu enters a modal loop so delay this call so that we\n            // don't block inside processInputQueue:.\n            [self performSelector:@selector(popupMenuWithAttributes:)\n                       withObject:attrs\n                       afterDelay:0];\n        }\n        break;\n        case SetMouseShapeMsgID:\n        {\n            const void *bytes = [data bytes];\n            int shape = *((int*)bytes);\n\n            [windowController setMouseShape:shape];\n        }\n        break;\n        case AdjustLinespaceMsgID:\n        {\n            const void *bytes = [data bytes];\n            int linespace = *((int*)bytes);\n\n            [windowController adjustLinespace:linespace];\n        }\n        break;\n        case AdjustColumnspaceMsgID:\n        {\n            const void *bytes = [data bytes];\n            int columnspace = *((int*)bytes);\n\n            [windowController adjustColumnspace:columnspace];\n        }\n        break;\n        case ActivateMsgID:\n        {\n            [NSApp activateIgnoringOtherApps:YES];\n            [[windowController window] makeKeyAndOrderFront:self];\n        }\n        break;\n        case SetServerNameMsgID:\n        {\n            NSString *name = [[NSString alloc] initWithData:data\n                                                   encoding:NSUTF8StringEncoding];\n            [self setServerName:name];\n            [name release];\n        }\n        break;\n        case EnterFullScreenMsgID:\n        {\n            const void *bytes = [data bytes];\n            int fuoptions = *((int*)bytes); bytes += sizeof(int);\n            int bg = *((int*)bytes);\n            NSColor *back = [NSColor colorWithArgbInt:bg];\n\n            [windowController enterFullScreen:fuoptions backgroundColor:back];\n        }\n        break;\n        case LeaveFullScreenMsgID:\n        {\n            [windowController leaveFullScreen];\n        }\n        break;\n        case SetBuffersModifiedMsgID:\n        {\n            const void *bytes = [data bytes];\n            // state < 0  <->  some buffer modified\n            // state > 0  <->  current buffer modified\n            int state = *((int*)bytes);\n\n            // NOTE: The window controller tracks whether current buffer is\n            // modified or not (and greys out the proxy icon as well as putting a\n            // dot in the red \"close button\" if necessary).  The Vim controller\n            // tracks whether any buffer has been modified (used to decide whether\n            // to show a warning or not when quitting).\n            //\n            // TODO: Make 'hasModifiedBuffer' part of the Vim state?\n            [windowController setBufferModified:(state > 0)];\n            hasModifiedBuffer = (state != 0);\n        }\n        break;\n        case SetPreEditPositionMsgID:\n        {\n            const int *dim = (const int*)[data bytes];\n            [[[windowController vimView] textView] setPreEditRow:dim[0]\n                                                          column:dim[1]];\n        }\n        break;\n        case EnableAntialiasMsgID:\n        {\n            [[[windowController vimView] textView] setAntialias:YES];\n        }\n        break;\n        case DisableAntialiasMsgID:\n        {\n            [[[windowController vimView] textView] setAntialias:NO];\n        }\n        break;\n        case EnableLigaturesMsgID:\n        {\n            [[[windowController vimView] textView] setLigatures:YES];\n        }\n        break;\n        case DisableLigaturesMsgID:\n        {\n            [[[windowController vimView] textView] setLigatures:NO];\n        }\n        break;\n        case EnableThinStrokesMsgID:\n        {\n            [[[windowController vimView] textView] setThinStrokes:YES];\n        }\n        break;\n        case DisableThinStrokesMsgID:\n        {\n            [[[windowController vimView] textView] setThinStrokes:NO];\n        }\n        break;\n        case SetVimStateMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict) {\n                [vimState release];\n                vimState = [dict retain];\n            }\n        }\n        break;\n        case CloseWindowMsgID:\n        {\n            [self scheduleClose];\n        }\n        break;\n        case SetFullScreenColorMsgID:\n        {\n            const int *bg = (const int*)[data bytes];\n            NSColor *color = [NSColor colorWithRgbInt:*bg];\n\n            [windowController setFullScreenBackgroundColor:color];\n        }\n        break;\n        case ShowFindReplaceDialogMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict) {\n                [[MMFindReplaceController sharedInstance]\n                    showWithText:[dict objectForKey:@\"text\"]\n                           flags:[[dict objectForKey:@\"flags\"] intValue]];\n            }\n        }\n        break;\n        case ActivateKeyScriptMsgID:\n        {\n            [[[windowController vimView] textView] activateIm:YES];\n        }\n        break;\n        case DeactivateKeyScriptMsgID:\n        {\n            [[[windowController vimView] textView] activateIm:NO];\n        }\n        break;\n        case EnableImControlMsgID:\n        {\n            [[[windowController vimView] textView] setImControl:YES];\n        }\n        break;\n        case DisableImControlMsgID:\n        {\n            [[[windowController vimView] textView] setImControl:NO];\n        }\n        break;\n        case BrowseForFileMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict)\n                [self handleBrowseForFile:dict];\n        }\n        break;\n        case ShowDialogMsgID:\n        {\n            [windowController runAfterWindowPresentedUsingBlock:^{\n                NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n                if (dict)\n                    [self handleShowDialog:dict];\n            }];\n        }\n        break;\n        case DeleteSignMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            if (dict)\n                [self handleDeleteSign:dict];\n        }\n        break;\n        case ZoomMsgID:\n        {\n            const void *bytes = [data bytes];\n            int rows = *((int*)bytes);  bytes += sizeof(int);\n            int cols = *((int*)bytes);  bytes += sizeof(int);\n            int state = *((int*)bytes);\n\n            [windowController zoomWithRows:rows\n                                   columns:cols\n                                     state:state];\n        }\n        break;\n        case SetWindowPositionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int x = *((int*)bytes);  bytes += sizeof(int);\n            int y = *((int*)bytes);\n\n            // NOTE: Vim measures Y-coordinates from top of screen.\n            NSRect frame = [[[windowController window] screen] frame];\n            y = NSMaxY(frame) - y;\n\n            [windowController setTopLeft:NSMakePoint(x,y)];\n        }\n        break;\n        case SetTooltipMsgID:\n        {\n            id textView = [[windowController vimView] textView];\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            NSString *toolTip = dict ? [dict objectForKey:@\"toolTip\"] : nil;\n            if (toolTip && [toolTip length] > 0)\n                [textView setToolTipAtMousePoint:toolTip];\n            else\n                [textView setToolTipAtMousePoint:nil];\n        }\n        break;\n        case AddToMRUMsgID:\n        {\n            NSDictionary *dict = [NSDictionary dictionaryWithData:data];\n            NSArray *filenames = dict ? [dict objectForKey:@\"filenames\"] : nil;\n            if (filenames)\n                [[NSDocumentController sharedDocumentController]\n                                                noteNewRecentFilePaths:filenames];\n        }\n        break;\n        case SetBackgroundOptionMsgID:\n        {\n            const void *bytes = [data bytes];\n            int dark = *((int*)bytes);\n            [windowController setBackgroundOption:dark];\n        }\n        break;\n        case SetBlurRadiusMsgID:\n        {\n            const void *bytes = [data bytes];\n            int radius = *((int*)bytes);\n            [windowController setBlurRadius:radius];\n        }\n        break;\n\n        case ShowDefinitionMsgID:\n        {\n            const void* bytes = [data bytes];\n            int row = *((int*)bytes);  bytes += sizeof(int);\n            int col = *((int*)bytes);  bytes += sizeof(int);\n            NSUInteger len = *((NSUInteger*)bytes);  bytes += sizeof(NSUInteger);\n            if (len > 0) {\n                NSString *text = [[[NSString alloc] initWithBytes:(void*)bytes\n                                                           length:len\n                                                         encoding:NSUTF8StringEncoding] autorelease];\n\n                // Convert from 1-indexed (Vim-style) to 0-indexed.\n                row -= 1;\n                col -= 1;\n\n                MMTextView *view = [[windowController vimView] textView];\n                [view showDefinitionForCustomString:text row:row col:col];\n            }\n        }\n        break;\n\n        // IMPORTANT: When adding a new message, make sure to update\n        // isUnsafeMessage() if necessary!\n        default:\n        {\n            ASLogWarn(@\"Unknown message received (msgid=%d)\", msgid);\n        }\n    }\n}\n\n- (void)savePanelDidEnd:(NSSavePanel *)panel code:(int)code\n                context:(void *)context\n{\n    NSString *path = nil;\n#if (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10)\n    if (code == NSModalResponseOK)\n#else\n    if (code == NSOKButton)\n#endif\n    {\n        NSURL *url = [panel URL];\n        if ([url isFileURL])\n            path = [url path];\n    }\n    ASLogDebug(@\"Open/save panel path=%@\", path);\n\n    // NOTE!  This causes the sheet animation to run its course BEFORE the rest\n    // of this function is executed.  If we do not wait for the sheet to\n    // disappear before continuing it can happen that the controller is\n    // released from under us (i.e. we'll crash and burn) because this\n    // animation is otherwise performed in the default run loop mode!\n    [panel orderOut:self];\n\n    // NOTE! setDialogReturn: is a synchronous call so set a proper timeout to\n    // avoid waiting forever for it to finish.  We make this a synchronous call\n    // so that we can be fairly certain that Vim doesn't think the dialog box\n    // is still showing when MacVim has in fact already dismissed it.\n    NSConnection *conn = [backendProxy connectionForProxy];\n    NSTimeInterval oldTimeout = [conn requestTimeout];\n    [conn setRequestTimeout:MMSetDialogReturnTimeout];\n\n    @try {\n        [backendProxy setDialogReturn:path];\n\n        // Add file to the \"Recent Files\" menu (this ensures that files that\n        // are opened/saved from a :browse command are added to this menu).\n        if (path)\n            [[NSDocumentController sharedDocumentController]\n                                                noteNewRecentFilePath:path];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"Exception: pid=%d id=%lu reason=%@\", pid, identifier, ex);\n    }\n    @finally {\n        [conn setRequestTimeout:oldTimeout];\n    }\n}\n\n- (void)alertDidEnd:(MMAlert *)alert code:(int)code context:(void *)context\n{\n    NSArray *ret = nil;\n\n    code = code - NSAlertFirstButtonReturn + 1;\n\n    if ([alert isKindOfClass:[MMAlert class]] && [alert textField]) {\n        ret = [NSArray arrayWithObjects:[NSNumber numberWithInt:code],\n            [[alert textField] stringValue], nil];\n    } else {\n        ret = [NSArray arrayWithObject:[NSNumber numberWithInt:code]];\n    }\n\n    ASLogDebug(@\"Alert return=%@\", ret);\n\n    // NOTE!  This causes the sheet animation to run its course BEFORE the rest\n    // of this function is executed.  If we do not wait for the sheet to\n    // disappear before continuing it can happen that the controller is\n    // released from under us (i.e. we'll crash and burn) because this\n    // animation is otherwise performed in the default run loop mode!\n    [[alert window] orderOut:self];\n\n    @try {\n        [backendProxy setDialogReturn:ret];\n    }\n    @catch (NSException *ex) {\n        ASLogDebug(@\"setDialogReturn: failed: pid=%d id=%lu reason=%@\",\n                pid, identifier, ex);\n    }\n}\n\n+ (bool) hasPopupPrefix: (NSString *) menuName\n{\n    return [menuName hasPrefix:MMPopUpMenuPrefix] || [menuName hasPrefix:MMUserPopUpMenuPrefix];\n}\n\n- (NSMenuItem *)menuItemForDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return nil;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    bool popup = [MMVimController hasPopupPrefix:rootName];\n    NSArray *rootItems =  popup ? popupMenuItems\n                                : [mainMenu itemArray];\n\n    NSMenuItem *item = nil;\n    int i, count = [rootItems count];\n    for (i = 0; i < count; ++i) {\n        item = [rootItems objectAtIndex:i];\n        if ([[item title] isEqual:rootName])\n            break;\n    }\n\n    if (i == count) return nil;\n\n    count = [desc count];\n    for (i = 1; i < count; ++i) {\n        item = [[item submenu] itemWithTitle:[desc objectAtIndex:i]];\n        if (!item) return nil;\n    }\n\n    return item;\n}\n\n- (NSMenu *)parentMenuForDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return nil;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    bool popup = [MMVimController hasPopupPrefix:rootName];\n    NSArray *rootItems = popup ? popupMenuItems\n                               : [mainMenu itemArray];\n\n    NSMenu *menu = nil;\n    int i, count = [rootItems count];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [rootItems objectAtIndex:i];\n        if ([[item title] isEqual:rootName]) {\n            menu = [item submenu];\n            break;\n        }\n    }\n\n    if (!menu) return nil;\n\n    count = [desc count] - 1;\n    for (i = 1; i < count; ++i) {\n        NSMenuItem *item = [menu itemWithTitle:[desc objectAtIndex:i]];\n        menu = [item submenu];\n        if (!menu) return nil;\n    }\n\n    return menu;\n}\n\n- (NSMenu *)topLevelMenuForTitle:(NSString *)title\n{\n    // Search only the top-level menus.\n\n    unsigned i, count = [popupMenuItems count];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [popupMenuItems objectAtIndex:i];\n        if ([title isEqual:[item title]])\n            return [item submenu];\n    }\n\n    count = [mainMenu numberOfItems];\n    for (i = 0; i < count; ++i) {\n        NSMenuItem *item = [mainMenu itemAtIndex:i];\n        if ([title isEqual:[item title]])\n            return [item submenu];\n    }\n\n    return nil;\n}\n\n- (void)addMenuWithDescriptor:(NSArray *)desc atIndex:(int)idx\n{\n    if (!(desc && [desc count] > 0 && idx >= 0)) return;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        // The toolbar only has one menu, we take this as a hint to create a\n        // toolbar, then we return.\n        if (!toolbar) {\n            // NOTE! Each toolbar must have a unique identifier, else each\n            // window will have the same toolbar.\n            NSString *ident = [NSString stringWithFormat:@\"%d\", identifier];\n            toolbar = [[NSToolbar alloc] initWithIdentifier:ident];\n\n            [toolbar setShowsBaselineSeparator:NO];\n            [toolbar setDelegate:self];\n            [toolbar setDisplayMode:NSToolbarDisplayModeIconOnly];\n            [toolbar setSizeMode:NSToolbarSizeModeSmall];\n\n            [windowController setToolbar:toolbar];\n        }\n\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            if ([desc count] < 2) // Cannot be 1, as we need at least TouchBar.<menu_name>\n                return;\n            if ([desc count] >= 3) // Unfortunately currently Apple does not support nested popover's so we can only do one level nesting\n                return;\n\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n            // Icon is not supported for Touch Bar submenu for now, as \"amenu\" does not have a way of specifying \"icon=<icon_path>\" for submenus.\n            NSString *title = [desc lastObject];\n            [self addTouchbarItemWithLabel:title icon:nil tip:nil atIndex:idx isSubMenu:YES desc:desc atTouchBar:submenuTouchbar];\n        }\n#endif\n        return;\n    }\n\n    if ([rootName isEqual:MMWinBarMenuName]) {\n        // WinBar menus are completed handled within Vim windows. No need for GUI to do anything.\n        return;\n    }\n\n    // This is either a main menu item or a popup menu item.\n    NSString *title = [desc lastObject];\n    NSMenuItem *item = [[NSMenuItem alloc] init];\n    NSMenu *menu = [[NSMenu alloc] initWithTitle:title];\n\n    [item setTitle:title];\n    [item setSubmenu:menu];\n\n    NSMenu *parent = [self parentMenuForDescriptor:desc];\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!parent && isPopup) {\n        if ([popupMenuItems count] <= idx) {\n            [popupMenuItems addObject:item];\n        } else {\n            [popupMenuItems insertObject:item atIndex:idx];\n        }\n    } else {\n        // If descriptor has no parent and its not a popup (or toolbar) menu,\n        // then it must belong to main menu.\n        if (!parent) {\n            parent = mainMenu;\n            idx += 1; // Main menu already has the application menu as the first item, so everything else must be shifted by one.\n        }\n\n        if ([parent numberOfItems] <= idx) {\n            [parent addItem:item];\n        } else {\n            [parent insertItem:item atIndex:idx];\n        }\n    }\n\n    [item release];\n    [menu release];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)addMenuItemWithDescriptor:(NSArray *)desc\n                          atIndex:(int)idx\n                              tip:(NSString *)tip\n                             icon:(NSString *)icon\n                    keyEquivalent:(NSString *)keyEquivalent\n                     modifierMask:(int)modifierMask\n                           action:(NSString *)action\n                      isAlternate:(BOOL)isAlternate\n{\n    if (!(desc && [desc count] > 1 && idx >= 0)) return;\n\n    NSString *title = [desc lastObject];\n    NSString *rootName = [desc objectAtIndex:0];\n\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2)\n            [self addToolbarItemWithLabel:title tip:tip icon:icon atIndex:idx];\n        return;\n    }\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if ([desc count] >= 4) // Unfortunately currently Apple does not support nested popover's so we can only do one level nesting\n            return;\n\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n\n            [self addTouchbarItemWithLabel:title icon:icon tip:tip atIndex:idx isSubMenu:NO desc:desc atTouchBar:submenuTouchbar];\n        }\n#endif\n        return;\n    }\n    if ([rootName isEqual:MMWinBarMenuName]) {\n        // WinBar menus are completed handled within Vim windows. No need for GUI to do anything.\n        return;\n    }\n\n    NSMenu *parent = [self parentMenuForDescriptor:desc];\n    if (!parent) {\n        ASLogWarn(@\"Menu item '%@' has no parent\",\n                  [desc componentsJoinedByString:@\"->\"]);\n        return;\n    }\n\n    NSMenuItem *item = nil;\n    if (0 == [title length]\n            || ([title hasPrefix:@\"-\"] && [title hasSuffix:@\"-\"])) {\n        item = [NSMenuItem separatorItem];\n        [item setTitle:title];\n    } else {\n        item = [[[NSMenuItem alloc] init] autorelease];\n        [item setTitle:title];\n\n        // Note: It is possible to set the action to a message that \"doesn't\n        // exist\" without problems.  We take advantage of this when adding\n        // \"dummy items\" e.g. when dealing with the \"Recent Files\" menu (in\n        // which case a recentFilesDummy: action is set, although it is never\n        // used).\n        if ([action length] > 0)\n            [item setAction:NSSelectorFromString(action)];\n        else\n            [item setAction:@selector(vimMenuItemAction:)];\n        if ([tip length] > 0) [item setToolTip:tip];\n        if ([keyEquivalent length] > 0) {\n            [item setKeyEquivalent:keyEquivalent];\n            [item setKeyEquivalentModifierMask:modifierMask];\n        }\n        [item setAlternate:isAlternate];\n\n        NSImage *img = [self findToolbarIcon:icon];\n        if (img) {\n            [item setImage: img];\n        }\n\n        // The tag is used to indicate whether Vim thinks a menu item should be\n        // enabled or disabled.  By default Vim thinks menu items are enabled.\n        [item setTag:1];\n    }\n\n    if ([parent numberOfItems] <= idx) {\n        [parent addItem:item];\n    } else {\n        [parent insertItem:item atIndex:idx];\n    }\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)removeMenuItemWithDescriptor:(NSArray *)desc\n{\n    if (!(desc && [desc count] > 0)) return;\n\n    NSString *title = [desc lastObject];\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar) {\n            // Only remove toolbar items, never actually remove the toolbar\n            // itself or strange things may happen.\n            if ([desc count] == 2) {\n                NSUInteger idx = [toolbar indexOfItemWithItemIdentifier:title];\n                if (idx != NSNotFound)\n                    [toolbar removeItemAtIndex:idx];\n            }\n        }\n        return;\n    }\n    if ([rootName isEqual:MMTouchbarMenuName]){\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarInfo *submenuTouchbar = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:&submenuTouchbar touchBarItem:nil]) {\n                return;\n            }\n\n            [[submenuTouchbar itemOrder] removeObject:title];\n            [[submenuTouchbar itemDict] removeObjectForKey:title];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n    NSMenuItem *item = [self menuItemForDescriptor:desc];\n    if (!item) {\n        ASLogWarn(@\"Failed to remove menu item, descriptor not found: %@\",\n                  [desc componentsJoinedByString:@\"->\"]);\n        return;\n    }\n\n    [item retain];\n\n    if ([item menu] == [NSApp mainMenu] || ![item menu]) {\n        // NOTE: To be on the safe side we try to remove the item from\n        // both arrays (it is ok to call removeObject: even if an array\n        // does not contain the object to remove).\n        [popupMenuItems removeObject:item];\n    }\n\n    if ([item menu])\n        [[item menu] removeItem:item];\n\n    [item release];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n- (void)enableMenuItemWithDescriptor:(NSArray *)desc state:(BOOL)on\n{\n    if (!(desc && [desc count] > 0)) return;\n\n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2) {\n            NSString *title = [desc lastObject];\n            [[toolbar itemWithItemIdentifier:title] setEnabled:on];\n        }\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarItemInfo *touchbarItem = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:nil touchBarItem:&touchbarItem]) {\n                return;\n            }\n            [touchbarItem setEnabled:on];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n\n    // We are using auto-enabling of menu items, where instead of directly\n    // calling setEnabled:, we rely on validateMenuItem: callbacks in each\n    // target to handle whether they want each menu item to be enabled or not.\n    // This allows us to more easily control the enabled states of OS-injected\n    // menu items if we want to. To remember whether we want to enable/disable\n    // a Vim menu, we use item.tag to remember it. See each validateMenuItem:\n    // implementation for details.\n    //\n    // See https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MenuList/Articles/EnablingMenuItems.html\n    [[self menuItemForDescriptor:desc] setTag:on];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n    \n- (void)updateMenuItemTooltipWithDescriptor:(NSArray *)desc\n                                        tip:(NSString *)tip\n{\n    if (!(desc && [desc count] > 0)) return;\n    \n    NSString *rootName = [desc objectAtIndex:0];\n    if ([rootName isEqual:MMToolbarMenuName]) {\n        if (toolbar && [desc count] == 2) {\n            NSString *title = [desc lastObject];\n            [[toolbar itemWithItemIdentifier:title] setToolTip:tip];\n        }\n        return;\n    }\n\n    if ([rootName isEqual:MMTouchbarMenuName]) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n        if (AVAILABLE_MAC_OS_PATCH(10, 12, 2)) {\n            MMTouchBarItemInfo *touchbarItem = nil;\n            if (![self touchBarItemForDescriptor:desc touchBar:nil touchBarItem:&touchbarItem]) {\n                return;\n            }\n            NSString *title = [desc lastObject];\n            [self updateTouchbarItemLabel:title tip:tip atTouchBarItem:touchbarItem];\n            [windowController setTouchBar:nil];\n        }\n#endif\n        return;\n    }\n\n    [[self menuItemForDescriptor:desc] setToolTip:tip];\n\n    const BOOL isPopup = [MMVimController hasPopupPrefix:rootName];\n    if (!isPopup)\n        [[MMAppController sharedInstance] markMainMenuDirty:mainMenu];\n}\n\n/// Load an icon image for the provided name. This will try multiple things to find the best image that fits the name.\n/// @param icon Can be an SF Symbol name (with colon-separated formatting strings), named system image, or just a file.\n- (NSImage*)findToolbarIcon:(NSString*)icon\n{\n    if ([icon length] == 0) {\n        return nil;\n    }\n    NSImage *img = nil;\n\n    // Detect whether this is explicitly specified to be a template image, via a \":template\" configuration suffix.\n    BOOL template = NO;\n    if ([icon hasSuffix:@\":template\"]) {\n        icon = [icon substringToIndex:([icon length] - 9)];\n        template = YES;\n    }\n\n    // Attempt 1: Load an SF Symbol image. This is first try because it's what Apple is pushing for and also likely\n    //            what our users are going to want to use. We also allows for customization of the symbol.\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0\n    if (@available(macos 11.0, *)) {\n        // All SF Symbol functionality were introduced in macOS 11.0.\n        NSString *sfSymbolName = icon;\n\n        BOOL monochrome = NO, hierarchical = NO, palette = NO, multicolor = NO;\n        double variableValue = -1;\n\n        if ([sfSymbolName rangeOfString:@\":\"].location != NSNotFound) {\n            // We support using colon-separated strings to customize the symbol. First item is the icon name itself.\n            NSArray<NSString*> *splitComponents = [sfSymbolName componentsSeparatedByString:@\":\"];\n            sfSymbolName = splitComponents[0];\n\n            for (int i = 1, count = splitComponents.count; i < count; i++) {\n                NSString *component = splitComponents[i];\n                if ([component isEqualToString:@\"monochrome\"]) {\n                    monochrome = YES;\n                } else if ([component isEqualToString:@\"hierarchical\"]) {\n                    hierarchical = YES;\n                } else if ([component isEqualToString:@\"palette\"]) {\n                    palette = YES;\n                } else if ([component isEqualToString:@\"multicolor\"]) {\n                    multicolor = YES;\n                } else if ([component hasPrefix:@\"variable-\"]) {\n                    NSString *variableString = [component substringFromIndex:9];\n                    variableValue = [variableString floatValue];\n                }\n            }\n        }\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n        if (@available(macos 13.0, *)) {\n            if (variableValue >= 0.0 && variableValue <= 1.0) {\n                img = [NSImage imageWithSystemSymbolName:sfSymbolName variableValue:variableValue accessibilityDescription:nil];\n            }\n        }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n\n        if (img == nil) {\n            img = [NSImage imageWithSystemSymbolName:sfSymbolName accessibilityDescription:nil];\n        }\n\n        // Apply style customization to the symbol. This feature was added in macOS 12.\n        if (img) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_12_0\n            if (@available(macos 12.0, *)) {\n                NSImageSymbolConfiguration *config = nil;\n                if (monochrome) {\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n                    if (@available(macos 13.0, *)) {\n                        config = [NSImageSymbolConfiguration configurationPreferringMonochrome];\n                    }\n#endif\n                }\n                if (hierarchical) {\n                    NSImageSymbolConfiguration *config2;\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_13_0\n                    if (@available(macos 13.0, *))\n                    {\n                        // This version is preferred as it seems to set the color up automatically and therefore will use the correct ones.\n                        config2 = [NSImageSymbolConfiguration configurationPreferringHierarchical];\n                    }\n                    else\n#endif\n                    {\n                        // Just guess which color to use. AppKit doesn't really give you a color that you can pick so we just guess one.\n                        config2 = [NSImageSymbolConfiguration configurationWithHierarchicalColor:NSColor.controlTextColor];\n                    }\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n                if (palette) {\n                    // The palette colors aren't completely correct. It doesn't appear for there to be a good way to query the primary colors\n                    // for Touch Bar, tool bar, etc, so we just use controlTextColor. It would be nice if Apple just provides a \"Preferring\"\n                    // version of this API like the other ones.\n                    NSImageSymbolConfiguration *config2 = [NSImageSymbolConfiguration configurationWithPaletteColors:@[NSColor.controlTextColor, NSColor.controlAccentColor]];\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n                if (multicolor) {\n                    NSImageSymbolConfiguration *config2 = [NSImageSymbolConfiguration configurationPreferringMulticolor];\n                    if (config) {\n                        config = [config configurationByApplyingConfiguration:config2];\n                    } else {\n                        config = config2;\n                    }\n                }\n\n                if (config) {\n                    NSImage *img2 = [img imageWithSymbolConfiguration:config];\n                    if (img2) {\n                        img = img2;\n                    }\n                }\n            }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_12_0\n\n            // Just mark them as used so compiling on older SDKs won't complain about unused variables.\n            (void)multicolor;\n            (void)hierarchical;\n            (void)palette;\n            (void)variableValue;\n        }\n    }\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_VERSION_11_0\n\n    // Attempt 2: Load a named image.\n    if (!img) {\n        img = [NSImage imageNamed:icon];\n    }\n\n    // Attempt 3: Load from a file.\n    if (!img) {\n        img = [[[NSImage alloc] initByReferencingFile:icon] autorelease];\n        if (!(img && [img isValid]))\n            img = nil;\n    }\n\n    if (img && template) {\n        [img setTemplate:YES];\n    }\n    return img;\n}\n\n- (void)addToolbarItemToDictionaryWithLabel:(NSString *)title\n                                    toolTip:(NSString *)tip\n                                       icon:(NSString *)icon\n{\n    // If the item corresponds to a separator then do nothing, since it is\n    // already defined by Cocoa.\n    if (!title || [title isEqual:NSToolbarSeparatorItemIdentifier]\n               || [title isEqual:NSToolbarSpaceItemIdentifier]\n               || [title isEqual:NSToolbarFlexibleSpaceItemIdentifier])\n        return;\n\n    NSToolbarItem *item = [[NSToolbarItem alloc] initWithItemIdentifier:title];\n    [item setLabel:title];\n    [item setToolTip:tip];\n    [item setAction:@selector(vimToolbarItemAction:)];\n    [item setAutovalidates:NO];\n\n    NSImage *img = [self findToolbarIcon:icon];\n    if (!img) {\n        ASLogNotice(@\"Could not find image with name '%@' to use as toolbar\"\n            \" image for identifier '%@';\"\n            \" using default toolbar icon '%@' instead.\",\n            icon, title, MMDefaultToolbarImageName);\n\n        img = [NSImage imageNamed:MMDefaultToolbarImageName];\n    }\n\n    [item setImage:img];\n\n    [toolbarItemDict setObject:item forKey:title];\n\n    [item release];\n}\n\n- (void)addToolbarItemWithLabel:(NSString *)label\n                            tip:(NSString *)tip\n                           icon:(NSString *)icon\n                        atIndex:(int)idx\n{\n    if (!toolbar) return;\n\n    // Check for separator items.\n    if (!label) {\n        label = NSToolbarSeparatorItemIdentifier;\n    } else if ([label length] >= 2 && [label hasPrefix:@\"-\"]\n                                   && [label hasSuffix:@\"-\"]) {\n        // The label begins and ends with '-'; decided which kind of separator\n        // item it is by looking at the prefix.\n        if ([label hasPrefix:@\"-space\"]) {\n            label = NSToolbarSpaceItemIdentifier;\n        } else if ([label hasPrefix:@\"-flexspace\"]) {\n            label = NSToolbarFlexibleSpaceItemIdentifier;\n        } else {\n            label = NSToolbarSeparatorItemIdentifier;\n        }\n    }\n\n    [self addToolbarItemToDictionaryWithLabel:label toolTip:tip icon:icon];\n\n    int maxIdx = [[toolbar items] count];\n    if (maxIdx < idx) idx = maxIdx;\n\n    [toolbar insertItemWithItemIdentifier:label atIndex:idx];\n}\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_12_2\n- (void)addTouchbarItemWithLabel:(NSString *)label\n                            icon:(NSString *)icon\n                             tip:(NSString *)tip\n                         atIndex:(int)idx\n                       isSubMenu:(BOOL)submenu\n                            desc:(NSArray *)desc\n                      atTouchBar:(MMTouchBarInfo *)touchbarInfo\n{\n    NSString *touchbarLabel = label;\n    NSTouchBarItem *touchbarItem = nil;\n\n    // Check for separator / special items first\n    if ([label length] >= 2 && [label hasPrefix:@\"-\"]\n                            && [label hasSuffix:@\"-\"]) {\n        // The label begins and ends with '-'; decided which kind of separator\n        // or special item it is by looking at the prefix.\n        if ([label hasPrefix:@\"-characterpicker\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierCharacterPicker;\n        }\n        else if ([label hasPrefix:@\"-space\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierFixedSpaceSmall;\n        } else if ([label hasPrefix:@\"-flexspace\"]) {\n            touchbarLabel = NSTouchBarItemIdentifierFlexibleSpace;\n        } else {\n            touchbarLabel = NSTouchBarItemIdentifierFixedSpaceLarge;\n        }\n    } else if (submenu) {\n        NSPopoverTouchBarItem *item = [[[NSPopoverTouchBarItem alloc] initWithIdentifier:label] autorelease];\n        // Icons not supported for now until we find a way to send the information in from Vim\n        [item setCollapsedRepresentationLabel:label];\n        touchbarItem = item;\n    } else {\n        BOOL useTip = tip && [tip length] != 0;\n        NSString *buttonTitle = useTip ? tip : label;\n        MMTouchBarButton* button = [MMTouchBarButton buttonWithTitle:buttonTitle target:windowController action:@selector(vimTouchbarItemAction:)];\n        [button setDesc:desc];\n        NSCustomTouchBarItem *item =\n            [[[NSCustomTouchBarItem alloc] initWithIdentifier:label] autorelease];\n\n        NSImage *img = [self findToolbarIcon:icon];;\n        if (img) {\n            [button setImage: img];\n            if (useTip) {\n                // If the user has set a tooltip as label that means they always want to see it, so show both image and tooltip\n                [button setImagePosition:NSImageLeft];\n            } else {\n                [button setImagePosition:NSImageOnly];\n            }\n        }\n\n        [item setView:button];\n        touchbarItem = item;\n    }\n    \n    MMTouchBarItemInfo *touchbarItemInfo = [[[MMTouchBarItemInfo alloc] initWithItem:touchbarItem label:touchbarLabel] autorelease];\n    if (submenu) {\n        [touchbarItemInfo makeChildTouchBar];\n    }\n    [touchbarInfo.itemDict setObject:touchbarItemInfo forKey:label];\n\n    int maxIdx = [touchbarInfo.itemOrder count];\n    if (maxIdx < idx) idx = maxIdx;\n    [touchbarInfo.itemOrder insertObject:label atIndex:idx];\n\n    [windowController setTouchBar:nil];\n}\n\n- (void)updateTouchbarItemLabel:(NSString *)label\n                            tip:(NSString *)tip\n                 atTouchBarItem:(MMTouchBarItemInfo*)item\n{\n    // The logic here should match that in addTouchbarItemWithLabel: as otherwise we will\n    // get weird results when adding/removing tooltips.\n    BOOL useTip = tip && [tip length] != 0;\n    NSString *buttonTitle = useTip ? tip : label;\n    NSCustomTouchBarItem *touchbarItem = (NSCustomTouchBarItem*)item.touchbarItem;\n    MMTouchBarButton *button = (MMTouchBarButton*)touchbarItem.view;\n    [button setTitle:buttonTitle];\n    if (button.image) {\n        if (useTip) {\n            [button setImagePosition:NSImageLeft];\n        } else {\n            [button setImagePosition:NSImageOnly];\n        }\n    } else {\n        [button setImagePosition:NSNoImage];\n    }\n}\n\n- (BOOL)touchBarItemForDescriptor:(NSArray *)desc\n                         touchBar:(MMTouchBarInfo **)touchBarPtr\n                     touchBarItem:(MMTouchBarItemInfo **)touchBarItemPtr\n{\n    MMTouchBarInfo *submenuTouchbar = touchbarInfo;\n    for (int i = 1; i < [desc count] - 1; i++) {\n        NSString *submenuName = [desc objectAtIndex:i];\n        MMTouchBarItemInfo *submenu = [[submenuTouchbar itemDict] objectForKey:submenuName];\n        if ([submenu childTouchbar]) {\n            submenuTouchbar = [submenu childTouchbar];\n        } else {\n            ASLogWarn(@\"No Touch Bar submenu with id '%@'\", submenuName);\n            return NO;\n        }\n    }\n    if (touchBarPtr)\n        *touchBarPtr = submenuTouchbar;\n    if (touchBarItemPtr)\n        *touchBarItemPtr = [[submenuTouchbar itemDict] objectForKey:[desc lastObject]];\n    return YES;\n}\n#endif\n- (void)popupMenuWithDescriptor:(NSArray *)desc\n                          atRow:(NSNumber *)row\n                         column:(NSNumber *)col\n{\n    NSMenu *menu = [[self menuItemForDescriptor:desc] submenu];\n    if (!menu) return;\n\n    id textView = [[windowController vimView] textView];\n    NSPoint pt;\n    if (row && col) {\n        // TODO: Let textView convert (row,col) to NSPoint.\n        int r = [row intValue];\n        int c = [col intValue];\n        NSSize cellSize = [textView cellSize];\n        pt = NSMakePoint((c+1)*cellSize.width, (r+1)*cellSize.height);\n        pt = [textView convertPoint:pt toView:nil];\n    } else {\n        pt = [[windowController window] mouseLocationOutsideOfEventStream];\n    }\n\n    NSEvent *event = [NSEvent mouseEventWithType:NSEventTypeRightMouseDown\n                           location:pt\n                      modifierFlags:0\n                          timestamp:0\n                       windowNumber:[[windowController window] windowNumber]\n                            context:nil\n                        eventNumber:0\n                         clickCount:0\n                           pressure:1.0];\n\n    [NSMenu popUpContextMenu:menu withEvent:event forView:textView];\n}\n\n- (void)popupMenuWithAttributes:(NSDictionary *)attrs\n{\n    if (!attrs) return;\n\n    [self popupMenuWithDescriptor:[attrs objectForKey:@\"descriptor\"]\n                            atRow:[attrs objectForKey:@\"row\"]\n                           column:[attrs objectForKey:@\"column\"]];\n}\n\n- (void)connectionDidDie:(NSNotification *)notification\n{\n    ASLogDebug(@\"%@\", notification);\n    [self scheduleClose];\n}\n\n- (void)scheduleClose\n{\n    ASLogDebug(@\"pid=%d id=%lu\", pid, identifier);\n\n    // NOTE!  This message can arrive at pretty much anytime, e.g. while\n    // the run loop is the 'event tracking' mode.  This means that Cocoa may\n    // well be in the middle of processing some message while this message is\n    // received.  If we were to remove the vim controller straight away we may\n    // free objects that Cocoa is currently using (e.g. view objects).  The\n    // following call ensures that the vim controller is not released until the\n    // run loop is back in the 'default' mode.\n    // Also, since the app may be multithreaded (e.g. as a result of showing\n    // the open panel) we have to ensure this call happens on the main thread,\n    // else there is a race condition that may lead to a crash.\n    [[MMAppController sharedInstance]\n            performSelectorOnMainThread:@selector(removeVimController:)\n                             withObject:self\n                          waitUntilDone:NO\n                                  modes:[NSArray arrayWithObject:\n                                         NSDefaultRunLoopMode]];\n}\n\n// NSSavePanel delegate\n- (void)panel:(id)sender willExpand:(BOOL)expanding\n{\n    // Show or hide the \"show hidden files\" button\n    if (expanding) {\n        [sender setAccessoryView:showHiddenFilesView()];\n    } else {\n        [sender setShowsHiddenFiles:NO];\n        [sender setAccessoryView:nil];\n    }\n}\n\n- (void)handleBrowseForFile:(NSDictionary *)attr\n{\n    if (!isInitialized) return;\n\n    NSString *dir = [attr objectForKey:@\"dir\"];\n    BOOL saving = [[attr objectForKey:@\"saving\"] boolValue];\n    BOOL browsedir = [[attr objectForKey:@\"browsedir\"] boolValue];\n\n    if (!dir) {\n        // 'dir == nil' means: set dir to the pwd of the Vim process, or let\n        // open dialog decide (depending on the below user default).\n        BOOL trackPwd = [[NSUserDefaults standardUserDefaults]\n                boolForKey:MMDialogsTrackPwdKey];\n        if (trackPwd)\n            dir = [vimState objectForKey:@\"pwd\"];\n    }\n\n    dir = [dir stringByExpandingTildeInPath];\n    NSURL *dirURL = dir ? [NSURL fileURLWithPath:dir isDirectory:YES] : nil;\n\n    if (saving) {\n        NSSavePanel *panel = [NSSavePanel savePanel];\n\n        // The delegate will be notified when the panel is expanded at which\n        // time we may hide/show the \"show hidden files\" button (this button is\n        // always visible for the open panel since it is always expanded).\n        [panel setDelegate:self];\n        if ([panel isExpanded])\n            [panel setAccessoryView:showHiddenFilesView()];\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n\n        [panel beginSheetModalForWindow:[windowController window]\n                      completionHandler:^(NSInteger result) {\n            [self savePanelDidEnd:panel code:result context:nil];\n        }];\n    } else {\n        NSOpenPanel *panel = [NSOpenPanel openPanel];\n        [panel setAllowsMultipleSelection:NO];\n        [panel setAccessoryView:showHiddenFilesView()];\n\n        if (browsedir) {\n            [panel setCanChooseDirectories:YES];\n            [panel setCanChooseFiles:NO];\n        }\n\n        if (dirURL)\n            [panel setDirectoryURL:dirURL];\n\n        [panel beginSheetModalForWindow:[windowController window]\n                      completionHandler:^(NSInteger result) {\n            [self savePanelDidEnd:panel code:result context:nil];\n        }];\n    }\n}\n\n- (void)handleShowDialog:(NSDictionary *)attr\n{\n    if (!isInitialized) return;\n\n    NSArray *buttonTitles = [attr objectForKey:@\"buttonTitles\"];\n    if (!(buttonTitles && [buttonTitles count])) return;\n\n    int style = [[attr objectForKey:@\"alertStyle\"] intValue];\n    NSString *message = [attr objectForKey:@\"messageText\"];\n    NSString *text = [attr objectForKey:@\"informativeText\"];\n    NSString *textFieldString = [attr objectForKey:@\"textFieldString\"];\n    MMAlert *alert = [[MMAlert alloc] init];\n\n    // NOTE! This has to be done before setting the informative text.\n    if (textFieldString)\n        [alert setTextFieldString:textFieldString];\n\n    [alert setAlertStyle:style];\n\n    if (message) {\n        [alert setMessageText:message];\n    } else {\n        // If no message text is specified 'Alert' is used, which we don't\n        // want, so set an empty string as message text.\n        [alert setMessageText:@\"\"];\n    }\n\n    if (text) {\n        [alert setInformativeText:text];\n    } else if (textFieldString) {\n        // Make sure there is always room for the input text field.\n        [alert setInformativeText:@\"\"];\n    }\n\n    unsigned i, count = [buttonTitles count];\n    for (i = 0; i < count; ++i) {\n        NSString *title = [buttonTitles objectAtIndex:i];\n        // NOTE: The title of the button may contain the character '&' to\n        // indicate that the following letter should be the key equivalent\n        // associated with the button.  Extract this letter and lowercase it.\n        NSString *keyEquivalent = nil;\n        NSRange hotkeyRange = [title rangeOfString:@\"&\"];\n        if (NSNotFound != hotkeyRange.location) {\n            if ([title length] > NSMaxRange(hotkeyRange)) {\n                NSRange keyEquivRange = NSMakeRange(hotkeyRange.location+1, 1);\n                keyEquivalent = [[title substringWithRange:keyEquivRange]\n                    lowercaseString];\n            }\n\n            NSMutableString *string = [NSMutableString stringWithString:title];\n            [string deleteCharactersInRange:hotkeyRange];\n            title = string;\n        }\n\n        [alert addButtonWithTitle:title];\n\n        // Set key equivalent for the button, but only if NSAlert hasn't\n        // already done so.  (Check the documentation for\n        // - [NSAlert addButtonWithTitle:] to see what key equivalents are\n        // automatically assigned.)\n        NSButton *btn = [[alert buttons] lastObject];\n        if ([[btn keyEquivalent] length] == 0 && keyEquivalent) {\n            [btn setKeyEquivalent:keyEquivalent];\n        }\n    }\n\n    [alert beginSheetModalForWindow:[windowController window]\n                      modalDelegate:self];\n\n    [alert release];\n}\n\n- (void)handleDeleteSign:(NSDictionary *)attr\n{\n    MMTextView *view = [[windowController vimView] textView];\n    [view deleteSign:[attr objectForKey:@\"imgName\"]];\n}\n\n- (void)setToolTipDelay\n{\n    // HACK! NSToolTipManager is an AppKit private class.\n    static Class TTM = nil;\n    if (!TTM)\n        TTM = NSClassFromString(@\"NSToolTipManager\");\n\n    if (TTM) {\n        [[TTM sharedToolTipManager] setInitialToolTipDelay:1e-6];\n    } else {\n        ASLogNotice(@\"Failed to get NSToolTipManager\");\n    }\n}\n\n@end // MMVimController (Private)\n\n\n\n\n@implementation MMAlert\n\n- (void)dealloc\n{\n    ASLogDebug(@\"\");\n\n    [textField release];  textField = nil;\n    [super dealloc];\n}\n\n- (void)setTextFieldString:(NSString *)textFieldString\n{\n    [textField release];\n    textField = [[NSTextField alloc] init];\n    [textField setStringValue:textFieldString];\n}\n\n- (NSTextField *)textField\n{\n    return textField;\n}\n\n- (void)setInformativeText:(NSString *)text\n{\n    if (textField) {\n        // HACK! Add some space for the text field.\n        [super setInformativeText:[text stringByAppendingString:@\"\\n\\n\\n\"]];\n    } else {\n        [super setInformativeText:text];\n    }\n}\n\n- (void)beginSheetModalForWindow:(NSWindow *)window\n                   modalDelegate:(id)delegate\n{\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10\n    [super beginSheetModalForWindow:window\n                  completionHandler:^(NSModalResponse code) {\n                      [delegate alertDidEnd:self code:code context:NULL];\n                  }];\n#else\n    [super beginSheetModalForWindow:window\n                      modalDelegate:delegate\n                     didEndSelector:@selector(alertDidEnd:code:context:)\n                        contextInfo:NULL];\n#endif\n\n    // HACK! Place the input text field at the bottom of the informative text\n    // (which has been made a bit larger by adding newline characters).\n    NSView *contentView = [[self window] contentView];\n    NSRect rect = [contentView frame];\n    rect.origin.y = rect.size.height;\n\n    NSArray *subviews = [contentView subviews];\n    unsigned i, count = [subviews count];\n    for (i = 0; i < count; ++i) {\n        NSView *view = [subviews objectAtIndex:i];\n        if ([view isKindOfClass:[NSTextField class]]\n                && [view frame].origin.y < rect.origin.y) {\n            // NOTE: The informative text field is the lowest NSTextField in\n            // the alert dialog.\n            rect = [view frame];\n        }\n    }\n\n    rect.size.height = MMAlertTextFieldHeight;\n    [textField setFrame:rect];\n    [contentView addSubview:textField];\n    [textField becomeFirstResponder];\n}\n\n@end // MMAlert\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_12\n    \n@implementation MMTouchBarInfo\n    \n- (id)init\n{\n    if (!(self = [super init])) {\n        return nil;\n    }\n\n    _touchbar = [[NSTouchBar alloc] init];\n    \n    _itemDict = [[NSMutableDictionary alloc] init];\n    _itemOrder = [[NSMutableArray alloc] init];\n    return self;\n}\n    \n- (void)dealloc\n{\n    [_touchbar release];  _touchbar = nil;\n\n    [_itemDict release];  _itemDict = nil;\n    [_itemOrder release];  _itemOrder = nil;\n    [super dealloc];\n}\n    \n@end // MMTouchBarInfo\n\n@implementation MMTouchBarItemInfo\n\n- (void)dealloc\n{\n    [_touchbarItem release];  _touchbarItem = nil;\n    [_label release];  _label = nil;\n    [_childTouchbar release];  _childTouchbar = nil;\n    [super dealloc];\n}\n    \n- (id)initWithItem:(NSTouchBarItem *)item label:(NSString *)label\n{\n    _touchbarItem = [item retain];\n    _enabled = YES;\n    _label = [label retain];\n    return self;\n}\n    \n- (void)setTouchBarItem:(NSTouchBarItem *)item\n{\n    _touchbarItem = item;\n}\n    \n- (void)makeChildTouchBar\n{\n    _childTouchbar = [[MMTouchBarInfo alloc] init];\n}\n\n@end // MMTouchBarItemInfo\n    \n@implementation MMTouchBarButton\n    \n- (void)dealloc\n{\n    [_desc release];  _desc = nil;\n    [super dealloc];\n}\n    \n- (NSArray *)desc\n{\n    return _desc;\n}\n    \n- (void)setDesc:(NSArray *)desc\n{\n    _desc = [desc retain];\n}\n    \n@end // MMTouchBarButton\n    \n#endif\n\n\n    static BOOL\nisUnsafeMessage(int msgid)\n{\n    // Messages that may release Cocoa objects must be added to this list.  For\n    // example, UpdateTabBarMsgID may delete NSTabViewItem objects so it goes\n    // on this list.\n    static int unsafeMessages[] = { // REASON MESSAGE IS ON THIS LIST:\n        //OpenWindowMsgID,            // Changes lots of state\n        UpdateTabBarMsgID,          // May delete NSTabViewItem\n        RemoveMenuItemMsgID,        // Deletes NSMenuItem\n        DestroyScrollbarMsgID,      // Deletes NSScroller\n        ExecuteActionMsgID,         // Impossible to predict\n        ShowPopupMenuMsgID,         // Enters modal loop\n        ActivateMsgID,              // ?\n        EnterFullScreenMsgID,       // Modifies delegate of window controller\n        LeaveFullScreenMsgID,       // Modifies delegate of window controller\n        CloseWindowMsgID,           // See note below\n        BrowseForFileMsgID,         // Enters modal loop\n        ShowDialogMsgID,            // Enters modal loop\n    };\n\n    // NOTE about CloseWindowMsgID: If this arrives at the same time as say\n    // ExecuteActionMsgID, then the \"execute\" message will be lost due to it\n    // being queued and handled after the \"close\" message has caused the\n    // controller to cleanup...UNLESS we add CloseWindowMsgID to the list of\n    // unsafe messages.  This is the _only_ reason it is on this list (since\n    // all that happens in response to it is that we schedule another message\n    // for later handling).\n\n    int i, count = sizeof(unsafeMessages)/sizeof(unsafeMessages[0]);\n    for (i = 0; i < count; ++i)\n        if (msgid == unsafeMessages[i])\n            return YES;\n\n    return NO;\n}\n", "/* vi:set ts=8 sts=4 sw=4 ft=objc fdm=syntax:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tMacVim GUI port by Bjorn Winckler\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n// This file contains root-level commonly used definitions that both Vim and\n// MacVim processes need access to.\n\n#import <Cocoa/Cocoa.h>\n\n#pragma region Backward compatibility defines\n\n// Taken from /usr/include/AvailabilityMacros.h\n#ifndef MAC_OS_X_VERSION_10_7\n# define MAC_OS_X_VERSION_10_7 1070\n#endif\n#ifndef MAC_OS_X_VERSION_10_8\n# define MAC_OS_X_VERSION_10_8 1080\n#endif\n#ifndef MAC_OS_X_VERSION_10_9\n# define MAC_OS_X_VERSION_10_9 1090\n#endif\n#ifndef MAC_OS_X_VERSION_10_10\n# define MAC_OS_X_VERSION_10_10 101000\n#endif\n#ifndef MAC_OS_X_VERSION_10_11\n# define MAC_OS_X_VERSION_10_11 101100\n#endif\n#ifndef MAC_OS_X_VERSION_10_12\n# define MAC_OS_X_VERSION_10_12 101200\n#endif\n#ifndef MAC_OS_X_VERSION_10_12_2\n# define MAC_OS_X_VERSION_10_12_2 101202\n#endif\n#ifndef MAC_OS_X_VERSION_10_13\n# define MAC_OS_X_VERSION_10_13 101300\n#endif\n#ifndef MAC_OS_X_VERSION_10_14\n# define MAC_OS_X_VERSION_10_14 101400\n#endif\n#ifndef MAC_OS_VERSION_11_0\n# define MAC_OS_VERSION_11_0 110000\n#endif\n#ifndef MAC_OS_VERSION_12_0\n# define MAC_OS_VERSION_12_0 120000\n#endif\n#ifndef MAC_OS_VERSION_13_0\n# define MAC_OS_VERSION_13_0 130000\n#endif\n\n#ifndef NSAppKitVersionNumber10_10\n# define NSAppKitVersionNumber10_10 1343\n#endif\n#ifndef NSAppKitVersionNumber10_10_Max\n# define NSAppKitVersionNumber10_10_Max 1349\n#endif\n#ifndef NSAppKitVersionNumber10_12\n# define NSAppKitVersionNumber10_12 1504\n#endif\n#ifndef NSAppKitVersionNumber10_12_2\n# define NSAppKitVersionNumber10_12_2 1504.76\n#endif\n#ifndef NSAppKitVersionNumber10_13\n# define NSAppKitVersionNumber10_13 1561\n#endif\n#ifndef NSAppKitVersionNumber10_14\n# define NSAppKitVersionNumber10_14 1671\n#endif\n#ifndef NSAppKitVersionNumber11_0\n# define NSAppKitVersionNumber11_0 2022\n#endif\n\n// Macro to detect runtime OS version. Ideally, we would just like to use\n// @available to test for this because the compiler can optimize it out\n// depending on your min/max OS configuration. However, it was added in Xcode 9\n// (macOS 10.13 SDK). For any code that we want to be compilable for Xcode 8\n// (macOS 10.12) or below, we need to use the macro below which will\n// selectively use NSAppKitVersionNumber instead.\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_13\n// Xcode 9+, can use @available, which is more efficient.\n# define AVAILABLE_MAC_OS(MAJOR, MINOR) @available(macos MAJOR##.##MINOR, *)\n# define AVAILABLE_MAC_OS_PATCH(MAJOR, MINOR, PATCH) @available(macos MAJOR##.##MINOR##.##PATCH, *)\n#else\n// Xcode 8 or below. Use the old-school NSAppKitVersionNumber check.\n# define AVAILABLE_MAC_OS(MAJOR, MINOR) NSAppKitVersionNumber >= NSAppKitVersionNumber##MAJOR##_##MINOR\n# define AVAILABLE_MAC_OS_PATCH(MAJOR, MINOR, PATCH) NSAppKitVersionNumber >= NSAppKitVersionNumber##MAJOR##_##MINOR##_##PATCH\n#endif\n\n// Deprecated constants. Since these are constants, we just need the compiler,\n// not the runtime to know about them. As such, we can use MAX_ALLOWED to\n// determine if we need to map or not.\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_12\n// Deprecated constants in 10.12 SDK\n# define NSAlertStyleCritical NSCriticalAlertStyle\n# define NSAlertStyleInformational NSInformationalAlertStyle\n# define NSAlertStyleWarning NSWarningAlertStyle\n# define NSButtonTypeSwitch NSSwitchButton\n# define NSCompositingOperationSourceOver NSCompositeSourceOver\n# define NSCompositingOperationDifference NSCompositeDifference\n# define NSControlSizeRegular NSRegularControlSize\n# define NSEventModifierFlagCapsLock NSAlphaShiftKeyMask\n# define NSEventModifierFlagCommand NSCommandKeyMask\n# define NSEventModifierFlagControl NSControlKeyMask\n# define NSEventModifierFlagDeviceIndependentFlagsMask NSDeviceIndependentModifierFlagsMask\n# define NSEventModifierFlagHelp NSHelpKeyMask\n# define NSEventModifierFlagNumericPad NSNumericPadKeyMask\n# define NSEventModifierFlagOption NSAlternateKeyMask\n# define NSEventModifierFlagShift NSShiftKeyMask\n# define NSEventTypeApplicationDefined NSApplicationDefined\n# define NSEventTypeKeyDown NSKeyDown\n# define NSEventTypeKeyUp NSKeyUp\n# define NSEventTypeLeftMouseUp NSLeftMouseUp\n# define NSEventTypeMouseEntered NSMouseEntered\n# define NSEventTypeMouseExited NSMouseExited\n# define NSEventTypeRightMouseDown NSRightMouseDown\n# define NSWindowStyleMaskBorderless NSBorderlessWindowMask\n# define NSWindowStyleMaskClosable NSClosableWindowMask\n# define NSWindowStyleMaskFullScreen NSFullScreenWindowMask\n# define NSWindowStyleMaskMiniaturizable NSMiniaturizableWindowMask\n# define NSWindowStyleMaskResizable NSResizableWindowMask\n# define NSWindowStyleMaskTexturedBackground NSTexturedBackgroundWindowMask\n# define NSWindowStyleMaskTitled NSTitledWindowMask\n# define NSWindowStyleMaskUnifiedTitleAndToolbar NSUnifiedTitleAndToolbarWindowMask\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_13\n// Deprecated constants in 10.13 SDK\n#define NSControlStateValueOn NSOnState\n#define NSControlStateValueOff NSOffState\n\n// Newly introduced symbols in 10.13 SDK\ntypedef NSString* NSPasteboardType;\ntypedef NSString* NSAttributedStringKey;\n#endif\n\n// Deprecated runtime values. Since these are runtime values, we need to use the\n// minimum required OS as determining factor. Otherwise it would crash.\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED <  MAC_OS_X_VERSION_10_13\n// Deprecated runtime values in 10.13 SDK.\n# define NSPasteboardNameFind NSFindPboard\n#endif\n\n#pragma endregion\n\n#import <asl.h>\n#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_12\n# define MM_USE_ASL\n#else\n# import <os/log.h>\n#endif\n\n#pragma region Shared protocols\n\n//\n// This is the protocol MMBackend implements.\n//\n// Only processInput:data: is allowed to cause state changes in Vim; all other\n// messages should only read the Vim state.  (Note that setDialogReturn: is an\n// exception to this rule; there really is no other way to deal with dialogs\n// since they work with callbacks, so we cannot wait for them to return.)\n//\n// Be careful with messages with return type other than 'oneway void' -- there\n// is a reply timeout set in MMAppController, if a message fails to get a\n// response within the given timeout an exception will be thrown.  Use\n// @try/@catch/@finally to deal with timeouts.\n//\n@protocol MMBackendProtocol\n- (oneway void)processInput:(int)msgid data:(in bycopy NSData *)data;\n- (oneway void)setDialogReturn:(in bycopy id)obj;\n- (NSString *)evaluateExpression:(in bycopy NSString *)expr;\n- (id)evaluateExpressionCocoa:(in bycopy NSString *)expr\n                  errorString:(out bycopy NSString **)errstr;\n- (BOOL)selectedTextToPasteboard:(byref NSPasteboard *)pboard;\n- (NSString *)selectedText;\n- (BOOL)mouseScreenposIsSelection:(int)row column:(int)column selRow:(byref int *)startRow selCol:(byref int *)startCol;\n- (oneway void)acknowledgeConnection;\n@end\n\n\n//\n// This is the protocol MMAppController implements.\n//\n// It handles connections between MacVim and Vim and communication from Vim to\n// MacVim.\n//\n// Do not add methods to this interface without a _very_ good reason (if\n// possible, instead add a new message to the *MsgID enum below and pass it via\n// processInput:forIdentifier).  Methods should not modify the state directly\n// but should instead delay any potential modifications (see\n// connectBackend:pid: and processInput:forIdentifier:).\n//\n@protocol MMAppProtocol\n- (unsigned long)connectBackend:(byref in id <MMBackendProtocol>)proxy pid:(int)pid;\n- (oneway void)processInput:(in bycopy NSArray *)queue\n              forIdentifier:(unsigned long)identifier;\n- (NSArray *)serverList;\n@end\n\n\n@protocol MMVimServerProtocol;\n\n//\n// The Vim client protocol (implemented by MMBackend).\n//\n// The client needs to keep track of server replies.  Take a look at MMBackend\n// if you want to implement this protocol in another program.\n//\n@protocol MMVimClientProtocol\n- (oneway void)addReply:(in bycopy NSString *)reply\n                 server:(in byref id <MMVimServerProtocol>)server;\n@end\n\n\n//\n// The Vim server protocol (implemented by MMBackend).\n//\n// Note that addInput:client: is not asynchronous, because otherwise Vim might\n// quit before the message has been passed (e.g. if --remote was used on the\n// command line).\n//\n@protocol MMVimServerProtocol\n- (void)addInput:(in bycopy NSString *)input\n                 client:(in byref id <MMVimClientProtocol>)client;\n- (NSString *)evaluateExpression:(in bycopy NSString *)expr\n                 client:(in byref id <MMVimClientProtocol>)client;\n@end\n\n#pragma endregion\n\n#pragma region IPC messages\n\n//\n// The following enum lists all messages that are passed between MacVim and\n// Vim.  These can be sent in processInput:data: and in processCommandQueue:.\n//\n\nextern const char * const MMVimMsgIDStrings[];\n\n#define FOREACH_MMVimMsgID(MSG) \\\n    MSG(NullMsgID) \\\n    MSG(OpenWindowMsgID) \\\n    MSG(KeyDownMsgID) \\\n    MSG(BatchDrawMsgID) \\\n    MSG(SelectTabMsgID) \\\n    MSG(CloseTabMsgID) \\\n    MSG(AddNewTabMsgID) \\\n    MSG(DraggedTabMsgID) \\\n    MSG(UpdateTabBarMsgID) \\\n    MSG(ShowTabBarMsgID) \\\n    MSG(HideTabBarMsgID) \\\n    MSG(SetTextRowsMsgID) \\\n    MSG(SetTextColumnsMsgID) \\\n    MSG(SetTextDimensionsMsgID) \\\n    MSG(SetTextDimensionsNoResizeWindowMsgID) \\\n    MSG(LiveResizeMsgID) \\\n    MSG(SetTextDimensionsReplyMsgID) \\\n    MSG(ResizeViewMsgID) \\\n    MSG(SetWindowTitleMsgID) \\\n    MSG(ScrollWheelMsgID) \\\n    MSG(MouseDownMsgID) \\\n    MSG(MouseUpMsgID) \\\n    MSG(MouseDraggedMsgID) \\\n    MSG(FlushQueueMsgID) \\\n    MSG(AddMenuMsgID) \\\n    MSG(AddMenuItemMsgID) \\\n    MSG(RemoveMenuItemMsgID) \\\n    MSG(EnableMenuItemMsgID) \\\n    MSG(ExecuteMenuMsgID) \\\n    MSG(UpdateMenuItemTooltipMsgID) \\\n    MSG(ShowToolbarMsgID) \\\n    MSG(ToggleToolbarMsgID) \\\n    MSG(CreateScrollbarMsgID) \\\n    MSG(DestroyScrollbarMsgID) \\\n    MSG(ShowScrollbarMsgID) \\\n    MSG(SetScrollbarPositionMsgID) \\\n    MSG(SetScrollbarThumbMsgID) \\\n    MSG(ScrollbarEventMsgID) \\\n    MSG(SetFontMsgID) \\\n    MSG(SetWideFontMsgID) \\\n    MSG(VimShouldCloseMsgID) \\\n    MSG(SetDefaultColorsMsgID) \\\n    MSG(ExecuteActionMsgID) \\\n    MSG(DropFilesMsgID) \\\n    MSG(DropStringMsgID) \\\n    MSG(ShowPopupMenuMsgID) \\\n    MSG(GotFocusMsgID) \\\n    MSG(LostFocusMsgID) \\\n    MSG(MouseMovedMsgID) \\\n    MSG(SetMouseShapeMsgID) \\\n    MSG(AdjustLinespaceMsgID) \\\n    MSG(AdjustColumnspaceMsgID) \\\n    MSG(ActivateMsgID) \\\n    MSG(SetServerNameMsgID) \\\n    MSG(EnterFullScreenMsgID) \\\n    MSG(LeaveFullScreenMsgID) \\\n    MSG(SetBuffersModifiedMsgID) \\\n    MSG(AddInputMsgID) \\\n    MSG(SetPreEditPositionMsgID) \\\n    MSG(TerminateNowMsgID) \\\n    MSG(XcodeModMsgID) \\\n    MSG(EnableAntialiasMsgID) \\\n    MSG(DisableAntialiasMsgID) \\\n    MSG(SetVimStateMsgID) \\\n    MSG(SetDocumentFilenameMsgID) \\\n    MSG(OpenWithArgumentsMsgID) \\\n    MSG(SelectAndFocusOpenedFileMsgID) \\\n    MSG(NewFileHereMsgID) \\\n    MSG(CloseWindowMsgID) \\\n    MSG(SetFullScreenColorMsgID) \\\n    MSG(ShowFindReplaceDialogMsgID) \\\n    MSG(FindReplaceMsgID) \\\n    MSG(UseSelectionForFindMsgID) \\\n    MSG(ActivateKeyScriptMsgID) \\\n    MSG(DeactivateKeyScriptMsgID) \\\n    MSG(EnableImControlMsgID) \\\n    MSG(DisableImControlMsgID) \\\n    MSG(ActivatedImMsgID) \\\n    MSG(DeactivatedImMsgID) \\\n    MSG(BrowseForFileMsgID) \\\n    MSG(ShowDialogMsgID) \\\n    MSG(SetMarkedTextMsgID) \\\n    MSG(ZoomMsgID) \\\n    MSG(SetWindowPositionMsgID) \\\n    MSG(DeleteSignMsgID) \\\n    MSG(SetTooltipMsgID) \\\n    MSG(GestureMsgID) \\\n    MSG(AddToMRUMsgID) \\\n    MSG(BackingPropertiesChangedMsgID) \\\n    MSG(SetBlurRadiusMsgID) \\\n    MSG(SetBackgroundOptionMsgID) \\\n    MSG(NotifyAppearanceChangeMsgID) \\\n    MSG(EnableLigaturesMsgID) \\\n    MSG(DisableLigaturesMsgID) \\\n    MSG(EnableThinStrokesMsgID) \\\n    MSG(DisableThinStrokesMsgID) \\\n    MSG(ShowDefinitionMsgID) \\\n    MSG(LastMsgID) \\\n\nenum {\n#define ENUM_ENTRY(X) X,\n    FOREACH_MMVimMsgID(ENUM_ENTRY)\n#undef ENUM_ENTRY\n};\n\n\nenum {\n    ClearAllDrawType = 1,\n    ClearBlockDrawType,\n    DeleteLinesDrawType,\n    DrawStringDrawType,\n    InsertLinesDrawType,\n    DrawCursorDrawType,\n    SetCursorPosDrawType,\n    DrawInvertedRectDrawType,\n    DrawSignDrawType,\n\n    InvalidDrawType = -1\n};\n\nenum {\n    MMInsertionPointBlock,\n    MMInsertionPointHorizontal,\n    MMInsertionPointVertical,\n    MMInsertionPointHollow,\n    MMInsertionPointVerticalRight,\n};\n\n\nenum {\n    ToolbarLabelFlag = 1,\n    ToolbarIconFlag = 2,\n    ToolbarSizeRegularFlag = 4\n};\n\n\nenum {\n    MMTabLabel = 0,\n    MMTabToolTip,\n    MMTabInfoCount\n};\n\nenum {\n    MMGestureSwipeLeft,\n    MMGestureSwipeRight,\n    MMGestureSwipeUp,\n    MMGestureSwipeDown,\n    MMGestureForceClick,\n};\n\n#pragma endregion\n\n\n// Create a string holding the labels of all messages in message queue for\n// debugging purposes (condense some messages since there may typically be LOTS\n// of them on a queue).\nNSString *debugStringForMessageQueue(NSArray *queue);\n\n\n// Shared user defaults (most user defaults are in Miscellaneous.h).\n// Contrary to the user defaults in Miscellaneous.h these defaults are not\n// initialized to any default values.  That is, unless the user sets them\n// these keys will not be present in the user default database.\nextern NSString *MMLogLevelKey;\nextern NSString *MMLogToStdErrKey;\n\n// Argument used to stop MacVim from opening an empty window on startup\n// (technically this is a user default but should not be used as such).\nextern NSString *MMNoWindowKey;\n\n// Argument used to control MacVim sharing search text via the Find Pasteboard.\nextern NSString *MMShareFindPboardKey;\n\nextern NSString *MMAutosaveRowsKey;\nextern NSString *MMAutosaveColumnsKey;\nextern NSString *MMRendererKey; // Deprecated: Non-CoreText renderer\n\nenum {\n    MMRendererDefault = 0,\n    MMRendererCoreText\n};\n\n\nextern NSString *VimFindPboardType;\n\n\n\n\n@interface NSString (MMExtras)\n- (NSString *)stringByRemovingFindPatterns;\n- (NSString *)stringBySanitizingSpotlightSearch;\n@end\n\n\n@interface NSColor (MMExtras)\n@property(readonly) unsigned argbInt;\n+ (NSColor *)colorWithRgbInt:(unsigned)rgb;\n+ (NSColor *)colorWithArgbInt:(unsigned)argb;\n@end\n\n\n@interface NSDictionary (MMExtras)\n+ (id)dictionaryWithData:(NSData *)data;\n- (NSData *)dictionaryAsData;\n@end\n\n@interface NSMutableDictionary (MMExtras)\n+ (id)dictionaryWithData:(NSData *)data;\n@end\n\n\n\n\n// ODB Editor Suite Constants (taken from ODBEditorSuite.h)\n#define\tkeyFileSender\t\t'FSnd'\n#define\tkeyFileSenderToken\t'FTok'\n#define\tkeyFileCustomPath\t'Burl'\n#define\tkODBEditorSuite\t\t'R*ch'\n#define\tkAEModifiedFile\t\t'FMod'\n#define\tkeyNewLocation\t\t'New?'\n#define\tkAEClosedFile\t\t'FCls'\n#define\tkeySenderToken\t\t'Tokn'\n\n\n// MacVim Apple Event Constants\n#define keyMMUntitledWindow       'MMuw'\n\n#pragma region Logging\n\n// Logging related functions and macros.\n//\n// This is a very simplistic logging facility built on top of ASL.  Two user\n// defaults allow for changing the local log filter level (MMLogLevel) and\n// whether logs should be sent to stderr (MMLogToStdErr).  (These user defaults\n// are only checked during startup.)  The default is to block level 6 (info)\n// and 7 (debug) logs and _not_ to send logs to stderr.  Apart from this\n// \"syslog\" (see \"man syslog\") can be used to modify the ASL filters (it is\n// currently not possible to change the local filter at runtime).  For example:\n//   Enable all logs to reach the ASL database (by default 'debug' and 'info'\n//   are filtered out, see \"man syslogd\"):\n//     $ sudo syslog -c syslogd -d\n//   Reset the ASL database filter:\n//     $ sudo syslog -c syslogd off\n//   Change the master filter to block logs less severe than errors:\n//     $ sudo syslog -c 0 -e\n//   Change per-process filter for running MacVim process to block logs less\n//   severe than warnings:\n//     $ syslog -c MacVim -w\n//\n// Note that there are four ASL filters:\n//   1) The ASL database filter (syslog -c syslogd ...)\n//   2) The master filter (syslog -c 0 ...)\n//   3) The per-process filter (syslog -c PID ...)\n//   4) The local filter (MMLogLevel)\n//\n// To view the logs, either use \"Console.app\" or the \"syslog\" command:\n//   $ syslog -w | grep Vim\n// To get the logs to show up in Xcode enable the MMLogToStdErr user default.\n\nextern int ASLogLevel;\n\nvoid ASLInit();\n\n#if defined(MM_USE_ASL)\n\n# define MM_ASL_LEVEL_DEFAULT ASL_LEVEL_NOTICE\n# define ASLog(level, fmt, ...) \\\n    if (level <= ASLogLevel) { \\\n        asl_log(NULL, NULL, level, \"%s@%d: %s\", \\\n            __PRETTY_FUNCTION__, __LINE__, \\\n            [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n    }\n\n// Note: These macros are used like ASLogErr(@\"text num=%d\", 42).  Objective-C\n// style specifiers (%@) are supported.\n# define ASLogCrit(fmt, ...)   ASLog(ASL_LEVEL_CRIT,    fmt, ##__VA_ARGS__)\n# define ASLogErr(fmt, ...)    ASLog(ASL_LEVEL_ERR,     fmt, ##__VA_ARGS__)\n# define ASLogWarn(fmt, ...)   ASLog(ASL_LEVEL_WARNING, fmt, ##__VA_ARGS__)\n# define ASLogNotice(fmt, ...) ASLog(ASL_LEVEL_NOTICE,  fmt, ##__VA_ARGS__)\n# define ASLogInfo(fmt, ...)   ASLog(ASL_LEVEL_INFO,    fmt, ##__VA_ARGS__)\n# define ASLogDebug(fmt, ...)  ASLog(ASL_LEVEL_DEBUG,   fmt, ##__VA_ARGS__)\n# define ASLogTmp(fmt, ...)    ASLog(ASL_LEVEL_NOTICE,  fmt, ##__VA_ARGS__)\n\n#else\n\n# define MM_ASL_LEVEL_DEFAULT OS_LOG_TYPE_DEFAULT\n# define ASLog(level, fmt, ...) \\\n    if (level <= ASLogLevel) { \\\n        if (floor(NSAppKitVersionNumber) >= NSAppKitVersionNumber10_12) { \\\n            os_log_with_type(OS_LOG_DEFAULT, level, \"%s@%d: %s\", \\\n                __PRETTY_FUNCTION__, __LINE__, \\\n                [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n        } else { \\\n            int logLevel; \\\n            switch (level) { \\\n            case OS_LOG_TYPE_FAULT: logLevel = ASL_LEVEL_CRIT; break; \\\n            case OS_LOG_TYPE_ERROR: logLevel = ASL_LEVEL_ERR; break; \\\n            case OS_LOG_TYPE_INFO: logLevel = ASL_LEVEL_INFO; break; \\\n            case OS_LOG_TYPE_DEBUG: logLevel = ASL_LEVEL_DEBUG; break; \\\n            default: logLevel = ASL_LEVEL_NOTICE; break; \\\n            } \\\n            _Pragma(\"clang diagnostic push\") \\\n            _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") \\\n            asl_log(NULL, NULL, logLevel, \"%s@%d: %s\", \\\n                __PRETTY_FUNCTION__, __LINE__, \\\n                [[NSString stringWithFormat:fmt, ##__VA_ARGS__] UTF8String]); \\\n            _Pragma(\"clang diagnostic pop\") \\\n        } \\\n    }\n\n# define ASLogCrit(fmt, ...)   ASLog(OS_LOG_TYPE_FAULT,   fmt, ##__VA_ARGS__)\n# define ASLogErr(fmt, ...)    ASLog(OS_LOG_TYPE_ERROR,   fmt, ##__VA_ARGS__)\n# define ASLogWarn(fmt, ...)   ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n# define ASLogNotice(fmt, ...) ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n# define ASLogInfo(fmt, ...)   ASLog(OS_LOG_TYPE_INFO,    fmt, ##__VA_ARGS__)\n# define ASLogDebug(fmt, ...)  ASLog(OS_LOG_TYPE_DEBUG,   fmt, ##__VA_ARGS__)\n# define ASLogTmp(fmt, ...)    ASLog(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)\n\n#endif\n\n#pragma endregion\n", "// !$*UTF8*$!\n{\n\tarchiveVersion = 1;\n\tclasses = {\n\t};\n\tobjectVersion = 47;\n\tobjects = {\n\n/* Begin PBXBuildFile section */\n\t\t0395A8330D71ED7800881434 /* DBPrefsWindowController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0395A8320D71ED7800881434 /* DBPrefsWindowController.m */; };\n\t\t0395A8AA0D72D88B00881434 /* General.png in Resources */ = {isa = PBXBuildFile; fileRef = 0395A8A90D72D88B00881434 /* General.png */; };\n\t\t1D09AB420C6A4D520045497E /* MMTypesetter.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D09AB400C6A4D520045497E /* MMTypesetter.m */; };\n\t\t1D0E051C0BA5F83800B6049E /* Colors.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1D0E051B0BA5F83800B6049E /* Colors.plist */; };\n\t\t1D145C7F0E5227CE00691AA0 /* MMTextViewHelper.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */; };\n\t\t1D1474980C56703C0038FA2B /* MacVim.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474960C56703C0038FA2B /* MacVim.m */; };\n\t\t1D1474A00C5673AE0038FA2B /* MMAppController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D14749E0C5673AE0038FA2B /* MMAppController.m */; };\n\t\t1D1474AA0C5677450038FA2B /* MMTextStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474A80C5677450038FA2B /* MMTextStorage.m */; };\n\t\t1D1474B00C5678370038FA2B /* MMTextView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474AE0C5678370038FA2B /* MMTextView.m */; };\n\t\t1D1474B60C56796D0038FA2B /* MMVimController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474B40C56796D0038FA2B /* MMVimController.m */; };\n\t\t1D1474BC0C567A910038FA2B /* MMWindowController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D1474BA0C567A910038FA2B /* MMWindowController.m */; };\n\t\t1D22374B0E45DF4800E6FFFF /* Advanced.png in Resources */ = {isa = PBXBuildFile; fileRef = 1D22374A0E45DF4800E6FFFF /* Advanced.png */; };\n\t\t1D384A0E100D671700D3C22F /* KeyBinding.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1D384A0D100D671700D3C22F /* KeyBinding.plist */; };\n\t\t1D44972211FCA9B400B0630F /* MMCoreTextView+ToolTip.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */; };\n\t\t1D493D580C5247BF00AB718C /* Vim in Copy Executables */ = {isa = PBXBuildFile; fileRef = 1D493D570C5247BF00AB718C /* Vim */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t1D493DBA0C52534300AB718C /* PSMTabBarControl.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t1D60088B0E96A0B2003763F0 /* MMFindReplaceController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */; };\n\t\t1D80591F0E1185EA001699D1 /* Miscellaneous.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80591D0E1185EA001699D1 /* Miscellaneous.m */; };\n\t\t1D80FBD40CBBD3B700102A1C /* MMFullScreenWindow.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */; };\n\t\t1D80FBD60CBBD3B700102A1C /* MMVimView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D80FBD20CBBD3B700102A1C /* MMVimView.m */; };\n\t\t1D8B5A53104AF9FF002E59D5 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1D8B5A52104AF9FF002E59D5 /* Carbon.framework */; };\n\t\t1D9C60520EF79C0C0034AD44 /* MacVim.icns in Resources */ = {isa = PBXBuildFile; fileRef = 1D9C602E0EF79C0C0034AD44 /* MacVim.icns */; };\n\t\t1DCD00BF0E50B2B700460166 /* Attention.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AA0E50B2B700460166 /* Attention.png */; };\n\t\t1DCD00C00E50B2B700460166 /* Copy.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AB0E50B2B700460166 /* Copy.png */; };\n\t\t1DCD00C10E50B2B700460166 /* Cut.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AC0E50B2B700460166 /* Cut.png */; };\n\t\t1DCD00C20E50B2B700460166 /* FindHelp.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AD0E50B2B700460166 /* FindHelp.png */; };\n\t\t1DCD00C30E50B2B700460166 /* FindNext.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AE0E50B2B700460166 /* FindNext.png */; };\n\t\t1DCD00C40E50B2B700460166 /* FindPrev.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00AF0E50B2B700460166 /* FindPrev.png */; };\n\t\t1DCD00C50E50B2B700460166 /* Help.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B00E50B2B700460166 /* Help.png */; };\n\t\t1DCD00C60E50B2B700460166 /* LoadSesn.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B10E50B2B700460166 /* LoadSesn.png */; };\n\t\t1DCD00C70E50B2B700460166 /* Make.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B20E50B2B700460166 /* Make.png */; };\n\t\t1DCD00C80E50B2B700460166 /* Open.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B30E50B2B700460166 /* Open.png */; };\n\t\t1DCD00C90E50B2B700460166 /* Paste.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B40E50B2B700460166 /* Paste.png */; };\n\t\t1DCD00CA0E50B2B700460166 /* Print.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B50E50B2B700460166 /* Print.png */; };\n\t\t1DCD00CB0E50B2B700460166 /* Redo.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B60E50B2B700460166 /* Redo.png */; };\n\t\t1DCD00CC0E50B2B700460166 /* Replace.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B70E50B2B700460166 /* Replace.png */; };\n\t\t1DCD00CD0E50B2B700460166 /* RunCtags.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B80E50B2B700460166 /* RunCtags.png */; };\n\t\t1DCD00CE0E50B2B700460166 /* RunScript.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00B90E50B2B700460166 /* RunScript.png */; };\n\t\t1DCD00CF0E50B2B700460166 /* Save.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BA0E50B2B700460166 /* Save.png */; };\n\t\t1DCD00D00E50B2B700460166 /* SaveAll.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BB0E50B2B700460166 /* SaveAll.png */; };\n\t\t1DCD00D10E50B2B700460166 /* SaveSesn.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BC0E50B2B700460166 /* SaveSesn.png */; };\n\t\t1DCD00D20E50B2B700460166 /* TagJump.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BD0E50B2B700460166 /* TagJump.png */; };\n\t\t1DCD00D30E50B2B700460166 /* Undo.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DCD00BE0E50B2B700460166 /* Undo.png */; };\n\t\t1DD04DEC0C529C5E006CDC2B /* Credits.rtf in Resources */ = {isa = PBXBuildFile; fileRef = 1DD04DEB0C529C5E006CDC2B /* Credits.rtf */; };\n\t\t1DD0C20C0C60FFB4008CD84A /* gvimrc in Copy default vimrc files */ = {isa = PBXBuildFile; fileRef = 1DD0C20A0C60FF9A008CD84A /* gvimrc */; };\n\t\t1DD3D51E0D82D4C9006E4320 /* ibeam.png in Resources */ = {isa = PBXBuildFile; fileRef = 1DD3D51D0D82D4C9006E4320 /* ibeam.png */; };\n\t\t1DD66ECE0C803D3600EBDAB3 /* MMApplication.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */; };\n\t\t1DD9F5E50C85D60500E8D5A5 /* SystemColors.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */; };\n\t\t1DE3F8EB0D50F84600052B9E /* MMPreferenceController.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */; };\n\t\t1DE63FFB0E71820F00959BDB /* MMCoreTextView.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */; };\n\t\t1DE8CC620C5E2AAD003F56E3 /* Actions.plist in Resources */ = {isa = PBXBuildFile; fileRef = 1DE8CC610C5E2AAD003F56E3 /* Actions.plist */; };\n\t\t1DE9B9500D341AB8008FEDD4 /* MMWindow.m in Sources */ = {isa = PBXBuildFile; fileRef = 1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */; };\n\t\t1DED78600C6DE43D0079945F /* vimrc in Copy default vimrc files */ = {isa = PBXBuildFile; fileRef = 1DED785F0C6DE43D0079945F /* vimrc */; };\n\t\t1DFE25A50C527BC4003000F7 /* PSMTabBarControl.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */; };\n\t\t52818B031C1C08CE00F59085 /* QLStephen.qlgenerator in Copy QuickLookPlugin */ = {isa = PBXBuildFile; fileRef = 52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };\n\t\t528DA66A1426D4F9003380F1 /* macvim-askpass in Copy Scripts */ = {isa = PBXBuildFile; fileRef = 528DA6691426D4EB003380F1 /* macvim-askpass */; };\n\t\t52A364731C4A5789005757EC /* Sparkle.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 52A364721C4A5789005757EC /* Sparkle.framework */; settings = {ATTRIBUTES = (Weak, ); }; };\n\t\t52A364761C4A57C1005757EC /* Sparkle.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 52A364721C4A5789005757EC /* Sparkle.framework */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };\n\t\t8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C165CFE840E0CC02AAC07 /* InfoPlist.strings */; };\n\t\t8D11072D0486CEB800E47090 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = 29B97316FDCFA39411CA2CEA /* main.m */; settings = {ATTRIBUTES = (); }; };\n\t\t8D11072F0486CEB800E47090 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */; };\n\t\t907FF7512521BCE200BADACB /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF74F2521BCE200BADACB /* MainMenu.xib */; };\n\t\t907FF7542521BDA600BADACB /* Preferences.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF7522521BDA600BADACB /* Preferences.xib */; };\n\t\t907FF7572521BDC300BADACB /* FindAndReplace.xib in Resources */ = {isa = PBXBuildFile; fileRef = 907FF7552521BDC200BADACB /* FindAndReplace.xib */; };\n\t\t909894382A56EB1E007B84A3 /* WhatsNew.xib in Resources */ = {isa = PBXBuildFile; fileRef = 909894362A56EB1E007B84A3 /* WhatsNew.xib */; };\n\t\t9098943C2A56ECF6007B84A3 /* MMWhatsNewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */; };\n\t\t90A33BEA28D563DF003A2E2F /* MMSparkle2Delegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */; };\n\t\t90AF83AB2A8C37F70046DA2E /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 90AF83A92A8C37F70046DA2E /* Security.framework */; };\n\t\t90B9877D2A579F9500FC95D6 /* WebKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 90B9877B2A579F9500FC95D6 /* WebKit.framework */; settings = {ATTRIBUTES = (Weak, ); }; };\n/* End PBXBuildFile section */\n\n/* Begin PBXContainerItemProxy section */\n\t\t1D493DB80C52533B00AB718C /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\tproxyType = 2;\n\t\t\tremoteGlobalIDString = 53DF68FD067E5B5A0090B5B0;\n\t\t\tremoteInfo = PSMTabBarControlFramework;\n\t\t};\n\t\t1D493DCC0C5254A400AB718C /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\tproxyType = 1;\n\t\t\tremoteGlobalIDString = 53DF68FC067E5B5A0090B5B0;\n\t\t\tremoteInfo = PSMTabBarControlFramework;\n\t\t};\n\t\t52818AFE1C1C075300F59085 /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\tproxyType = 2;\n\t\t\tremoteGlobalIDString = 8D576316048677EA00EA77CD;\n\t\t\tremoteInfo = QuickLookStephen;\n\t\t};\n\t\t52818B001C1C084100F59085 /* PBXContainerItemProxy */ = {\n\t\t\tisa = PBXContainerItemProxy;\n\t\t\tcontainerPortal = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\tproxyType = 1;\n\t\t\tremoteGlobalIDString = 8D57630D048677EA00EA77CD;\n\t\t\tremoteInfo = QuickLookStephen;\n\t\t};\n/* End PBXContainerItemProxy section */\n\n/* Begin PBXCopyFilesBuildPhase section */\n\t\t1D0DCAD80BA3604D00B6CCFA /* Copy Executables */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 6;\n\t\t\tfiles = (\n\t\t\t\t1D493D580C5247BF00AB718C /* Vim in Copy Executables */,\n\t\t\t);\n\t\t\tname = \"Copy Executables\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t1D9EB2840C366D7B0074B739 /* Copy Frameworks */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 10;\n\t\t\tfiles = (\n\t\t\t\t52A364761C4A57C1005757EC /* Sparkle.framework in Copy Frameworks */,\n\t\t\t\t1D493DBA0C52534300AB718C /* PSMTabBarControl.framework in Copy Frameworks */,\n\t\t\t);\n\t\t\tname = \"Copy Frameworks\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t1DE608B80C58807F0055263D /* Copy default vimrc files */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = vim;\n\t\t\tdstSubfolderSpec = 7;\n\t\t\tfiles = (\n\t\t\t\t1DED78600C6DE43D0079945F /* vimrc in Copy default vimrc files */,\n\t\t\t\t1DD0C20C0C60FFB4008CD84A /* gvimrc in Copy default vimrc files */,\n\t\t\t);\n\t\t\tname = \"Copy default vimrc files\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t52818B021C1C088000F59085 /* Copy QuickLookPlugin */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = ../Library/QuickLook;\n\t\t\tdstSubfolderSpec = 6;\n\t\t\tfiles = (\n\t\t\t\t52818B031C1C08CE00F59085 /* QLStephen.qlgenerator in Copy QuickLookPlugin */,\n\t\t\t);\n\t\t\tname = \"Copy QuickLookPlugin\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n\t\t528DA6671426D456003380F1 /* Copy Scripts */ = {\n\t\t\tisa = PBXCopyFilesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tdstPath = \"\";\n\t\t\tdstSubfolderSpec = 7;\n\t\t\tfiles = (\n\t\t\t\t528DA66A1426D4F9003380F1 /* macvim-askpass in Copy Scripts */,\n\t\t\t);\n\t\t\tname = \"Copy Scripts\";\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXCopyFilesBuildPhase section */\n\n/* Begin PBXFileReference section */\n\t\t0395A8310D71ED7800881434 /* DBPrefsWindowController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DBPrefsWindowController.h; sourceTree = \"<group>\"; };\n\t\t0395A8320D71ED7800881434 /* DBPrefsWindowController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DBPrefsWindowController.m; sourceTree = \"<group>\"; };\n\t\t0395A8A90D72D88B00881434 /* General.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = General.png; sourceTree = \"<group>\"; };\n\t\t1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = /System/Library/Frameworks/Cocoa.framework; sourceTree = \"<absolute>\"; };\n\t\t1D09AB3F0C6A4D520045497E /* MMTypesetter.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTypesetter.h; sourceTree = \"<group>\"; };\n\t\t1D09AB400C6A4D520045497E /* MMTypesetter.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTypesetter.m; sourceTree = \"<group>\"; };\n\t\t1D0E051B0BA5F83800B6049E /* Colors.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Colors.plist; sourceTree = \"<group>\"; };\n\t\t1D145C7D0E5227CE00691AA0 /* MMTextViewHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMTextViewHelper.h; sourceTree = \"<group>\"; };\n\t\t1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMTextViewHelper.m; sourceTree = \"<group>\"; };\n\t\t1D1474950C56703C0038FA2B /* MacVim.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MacVim.h; sourceTree = \"<group>\"; };\n\t\t1D1474960C56703C0038FA2B /* MacVim.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MacVim.m; sourceTree = \"<group>\"; };\n\t\t1D14749D0C5673AE0038FA2B /* MMAppController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMAppController.h; sourceTree = \"<group>\"; };\n\t\t1D14749E0C5673AE0038FA2B /* MMAppController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMAppController.m; sourceTree = \"<group>\"; };\n\t\t1D1474A70C5677450038FA2B /* MMTextStorage.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTextStorage.h; sourceTree = \"<group>\"; };\n\t\t1D1474A80C5677450038FA2B /* MMTextStorage.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTextStorage.m; sourceTree = \"<group>\"; };\n\t\t1D1474AD0C5678370038FA2B /* MMTextView.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMTextView.h; sourceTree = \"<group>\"; };\n\t\t1D1474AE0C5678370038FA2B /* MMTextView.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMTextView.m; sourceTree = \"<group>\"; };\n\t\t1D1474B30C56796D0038FA2B /* MMVimController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMVimController.h; sourceTree = \"<group>\"; };\n\t\t1D1474B40C56796D0038FA2B /* MMVimController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMVimController.m; sourceTree = \"<group>\"; };\n\t\t1D1474B90C567A910038FA2B /* MMWindowController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMWindowController.h; sourceTree = \"<group>\"; };\n\t\t1D1474BA0C567A910038FA2B /* MMWindowController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMWindowController.m; sourceTree = \"<group>\"; };\n\t\t1D22374A0E45DF4800E6FFFF /* Advanced.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = Advanced.png; sourceTree = \"<group>\"; };\n\t\t1D384A0D100D671700D3C22F /* KeyBinding.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = KeyBinding.plist; sourceTree = \"<group>\"; };\n\t\t1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = \"MMCoreTextView+ToolTip.m\"; sourceTree = \"<group>\"; };\n\t\t1D493D570C5247BF00AB718C /* Vim */ = {isa = PBXFileReference; lastKnownFileType = \"compiled.mach-o.executable\"; name = Vim; path = ../Vim; sourceTree = SOURCE_ROOT; };\n\t\t1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = \"wrapper.pb-project\"; name = PSMTabBarControl.xcodeproj; path = PSMTabBarControl/PSMTabBarControl.xcodeproj; sourceTree = \"<group>\"; };\n\t\t1D6008890E96A0B2003763F0 /* MMFindReplaceController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMFindReplaceController.h; sourceTree = \"<group>\"; };\n\t\t1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMFindReplaceController.m; sourceTree = \"<group>\"; };\n\t\t1D80591D0E1185EA001699D1 /* Miscellaneous.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Miscellaneous.m; sourceTree = \"<group>\"; };\n\t\t1D8059220E118663001699D1 /* Miscellaneous.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Miscellaneous.h; sourceTree = \"<group>\"; };\n\t\t1D80FBCF0CBBD3B700102A1C /* MMFullScreenWindow.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMFullScreenWindow.h; sourceTree = \"<group>\"; };\n\t\t1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMFullScreenWindow.m; sourceTree = \"<group>\"; };\n\t\t1D80FBD10CBBD3B700102A1C /* MMVimView.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMVimView.h; sourceTree = \"<group>\"; };\n\t\t1D80FBD20CBBD3B700102A1C /* MMVimView.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMVimView.m; sourceTree = \"<group>\"; };\n\t\t1D8B5A52104AF9FF002E59D5 /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = \"<absolute>\"; };\n\t\t1D9C602E0EF79C0C0034AD44 /* MacVim.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = MacVim.icns; path = icons/MacVim.icns; sourceTree = \"<group>\"; };\n\t\t1DCD00AA0E50B2B700460166 /* Attention.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Attention.png; path = Toolbar/Attention.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AB0E50B2B700460166 /* Copy.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Copy.png; path = Toolbar/Copy.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AC0E50B2B700460166 /* Cut.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Cut.png; path = Toolbar/Cut.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AD0E50B2B700460166 /* FindHelp.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindHelp.png; path = Toolbar/FindHelp.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AE0E50B2B700460166 /* FindNext.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindNext.png; path = Toolbar/FindNext.png; sourceTree = \"<group>\"; };\n\t\t1DCD00AF0E50B2B700460166 /* FindPrev.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = FindPrev.png; path = Toolbar/FindPrev.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B00E50B2B700460166 /* Help.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Help.png; path = Toolbar/Help.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B10E50B2B700460166 /* LoadSesn.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = LoadSesn.png; path = Toolbar/LoadSesn.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B20E50B2B700460166 /* Make.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Make.png; path = Toolbar/Make.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B30E50B2B700460166 /* Open.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Open.png; path = Toolbar/Open.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B40E50B2B700460166 /* Paste.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Paste.png; path = Toolbar/Paste.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B50E50B2B700460166 /* Print.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Print.png; path = Toolbar/Print.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B60E50B2B700460166 /* Redo.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Redo.png; path = Toolbar/Redo.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B70E50B2B700460166 /* Replace.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Replace.png; path = Toolbar/Replace.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B80E50B2B700460166 /* RunCtags.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = RunCtags.png; path = Toolbar/RunCtags.png; sourceTree = \"<group>\"; };\n\t\t1DCD00B90E50B2B700460166 /* RunScript.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = RunScript.png; path = Toolbar/RunScript.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BA0E50B2B700460166 /* Save.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Save.png; path = Toolbar/Save.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BB0E50B2B700460166 /* SaveAll.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = SaveAll.png; path = Toolbar/SaveAll.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BC0E50B2B700460166 /* SaveSesn.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = SaveSesn.png; path = Toolbar/SaveSesn.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BD0E50B2B700460166 /* TagJump.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = TagJump.png; path = Toolbar/TagJump.png; sourceTree = \"<group>\"; };\n\t\t1DCD00BE0E50B2B700460166 /* Undo.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = Undo.png; path = Toolbar/Undo.png; sourceTree = \"<group>\"; };\n\t\t1DD04DEB0C529C5E006CDC2B /* Credits.rtf */ = {isa = PBXFileReference; lastKnownFileType = text.rtf; path = Credits.rtf; sourceTree = \"<group>\"; };\n\t\t1DD0C20A0C60FF9A008CD84A /* gvimrc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = gvimrc; sourceTree = \"<group>\"; };\n\t\t1DD3D51D0D82D4C9006E4320 /* ibeam.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = ibeam.png; sourceTree = \"<group>\"; };\n\t\t1DD66ECB0C803D3600EBDAB3 /* MMApplication.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMApplication.h; sourceTree = \"<group>\"; };\n\t\t1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMApplication.m; sourceTree = \"<group>\"; };\n\t\t1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = SystemColors.plist; sourceTree = \"<group>\"; };\n\t\t1DE3F8E80D50F84600052B9E /* MMPreferenceController.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMPreferenceController.h; sourceTree = \"<group>\"; };\n\t\t1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMPreferenceController.m; sourceTree = \"<group>\"; };\n\t\t1DE602470C587FD10055263D /* runtime */ = {isa = PBXFileReference; lastKnownFileType = folder; name = runtime; path = ../../runtime; sourceTree = SOURCE_ROOT; };\n\t\t1DE63FF90E71820F00959BDB /* MMCoreTextView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMCoreTextView.h; sourceTree = \"<group>\"; };\n\t\t1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMCoreTextView.m; sourceTree = \"<group>\"; };\n\t\t1DE8CC610C5E2AAD003F56E3 /* Actions.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Actions.plist; sourceTree = \"<group>\"; };\n\t\t1DE9B94D0D341AB8008FEDD4 /* MMWindow.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = MMWindow.h; sourceTree = \"<group>\"; };\n\t\t1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = MMWindow.m; sourceTree = \"<group>\"; };\n\t\t1DED785F0C6DE43D0079945F /* vimrc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = vimrc; sourceTree = \"<group>\"; };\n\t\t29B97316FDCFA39411CA2CEA /* main.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = \"<group>\"; };\n\t\t29B97324FDCFA39411CA2CEA /* AppKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AppKit.framework; path = /System/Library/Frameworks/AppKit.framework; sourceTree = \"<absolute>\"; };\n\t\t29B97325FDCFA39411CA2CEA /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = /System/Library/Frameworks/Foundation.framework; sourceTree = \"<absolute>\"; };\n\t\t32CA4F630368D1EE00C91783 /* MacVim_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MacVim_Prefix.pch; sourceTree = \"<group>\"; };\n\t\t52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = \"wrapper.pb-project\"; name = QuickLookStephen.xcodeproj; path = qlstephen/QuickLookStephen.xcodeproj; sourceTree = \"<group>\"; };\n\t\t528DA6691426D4EB003380F1 /* macvim-askpass */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = \"macvim-askpass\"; sourceTree = \"<group>\"; };\n\t\t52A364721C4A5789005757EC /* Sparkle.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; path = Sparkle.framework; sourceTree = \"<group>\"; };\n\t\t8D1107310486CEB800E47090 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = \"<group>\"; };\n\t\t8D1107320486CEB800E47090 /* MacVim.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = MacVim.app; sourceTree = BUILT_PRODUCTS_DIR; };\n\t\t901C06F42430C8C800797C2A /* map.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = map.c; path = ../map.c; sourceTree = \"<group>\"; };\n\t\t901C06F62430C8C900797C2A /* time.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = time.c; path = ../time.c; sourceTree = \"<group>\"; };\n\t\t901C06F72430C8C900797C2A /* testing.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = testing.c; path = ../testing.c; sourceTree = \"<group>\"; };\n\t\t901C06F82430C8C900797C2A /* cmdhist.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cmdhist.c; path = ../cmdhist.c; sourceTree = \"<group>\"; };\n\t\t901C06F92430C8C900797C2A /* change.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = change.c; path = ../change.c; sourceTree = \"<group>\"; };\n\t\t901C06FA2430C8C900797C2A /* evalwindow.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalwindow.c; path = ../evalwindow.c; sourceTree = \"<group>\"; };\n\t\t901C06FB2430C8C900797C2A /* bufwrite.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = bufwrite.c; path = ../bufwrite.c; sourceTree = \"<group>\"; };\n\t\t901C06FC2430C8CA00797C2A /* evalvars.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalvars.c; path = ../evalvars.c; sourceTree = \"<group>\"; };\n\t\t901C06FD2430C8CA00797C2A /* drawscreen.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = drawscreen.c; path = ../drawscreen.c; sourceTree = \"<group>\"; };\n\t\t901C06FE2430C8CA00797C2A /* debugger.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = debugger.c; path = ../debugger.c; sourceTree = \"<group>\"; };\n\t\t901C06FF2430C8CA00797C2A /* popupmenu.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = popupmenu.c; path = ../popupmenu.c; sourceTree = \"<group>\"; };\n\t\t901C07002430C8CA00797C2A /* cindent.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cindent.c; path = ../cindent.c; sourceTree = \"<group>\"; };\n\t\t901C07012430C8CA00797C2A /* usercmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = usercmd.c; path = ../usercmd.c; sourceTree = \"<group>\"; };\n\t\t901C07022430C8CA00797C2A /* popupwin.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = popupwin.c; path = ../popupwin.c; sourceTree = \"<group>\"; };\n\t\t901C07032430C8CA00797C2A /* drawline.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = drawline.c; path = ../drawline.c; sourceTree = \"<group>\"; };\n\t\t901C07042430C8CA00797C2A /* cmdexpand.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cmdexpand.c; path = ../cmdexpand.c; sourceTree = \"<group>\"; };\n\t\t901C07052430C8CB00797C2A /* scriptfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = scriptfile.c; path = ../scriptfile.c; sourceTree = \"<group>\"; };\n\t\t901C07062430C8CB00797C2A /* register.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = register.c; path = ../register.c; sourceTree = \"<group>\"; };\n\t\t901C07072430C8CB00797C2A /* vim9execute.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9execute.c; path = ../vim9execute.c; sourceTree = \"<group>\"; };\n\t\t901C07082430C8CB00797C2A /* evalbuffer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalbuffer.c; path = ../evalbuffer.c; sourceTree = \"<group>\"; };\n\t\t901C07092430C8CB00797C2A /* spellsuggest.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spellsuggest.c; path = ../spellsuggest.c; sourceTree = \"<group>\"; };\n\t\t901C070A2430C8CB00797C2A /* insexpand.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = insexpand.c; path = ../insexpand.c; sourceTree = \"<group>\"; };\n\t\t901C070B2430C8CB00797C2A /* profiler.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = profiler.c; path = ../profiler.c; sourceTree = \"<group>\"; };\n\t\t901C070C2430C8CB00797C2A /* vim9compile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9compile.c; path = ../vim9compile.c; sourceTree = \"<group>\"; };\n\t\t901C070D2430C8CC00797C2A /* sound.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sound.c; path = ../sound.c; sourceTree = \"<group>\"; };\n\t\t901C070E2430C8CC00797C2A /* vim9.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = vim9.h; path = ../vim9.h; sourceTree = \"<group>\"; };\n\t\t901C070F2430C8CC00797C2A /* arglist.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = arglist.c; path = ../arglist.c; sourceTree = \"<group>\"; };\n\t\t901C07102430C8CC00797C2A /* vim9script.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9script.c; path = ../vim9script.c; sourceTree = \"<group>\"; };\n\t\t901C07112430C8CC00797C2A /* clipboard.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = clipboard.c; path = ../clipboard.c; sourceTree = \"<group>\"; };\n\t\t901C07122430C8CC00797C2A /* highlight.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = highlight.c; path = ../highlight.c; sourceTree = \"<group>\"; };\n\t\t901C07132430C8CC00797C2A /* uninstall.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = uninstall.c; path = ../uninstall.c; sourceTree = \"<group>\"; };\n\t\t901C07142430C8CC00797C2A /* regexp_bt.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp_bt.c; path = ../regexp_bt.c; sourceTree = \"<group>\"; };\n\t\t901C07152430C8CC00797C2A /* mouse.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mouse.c; path = ../mouse.c; sourceTree = \"<group>\"; };\n\t\t901C07162430C8CD00797C2A /* optiondefs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = optiondefs.h; path = ../optiondefs.h; sourceTree = \"<group>\"; };\n\t\t901C07172430C8CD00797C2A /* optionstr.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = optionstr.c; path = ../optionstr.c; sourceTree = \"<group>\"; };\n\t\t901C07182430C8CD00797C2A /* viminfo.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = viminfo.c; path = ../viminfo.c; sourceTree = \"<group>\"; };\n\t\t901C07192430C8CD00797C2A /* filepath.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = filepath.c; path = ../filepath.c; sourceTree = \"<group>\"; };\n\t\t901C071A2430C8CD00797C2A /* session.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = session.c; path = ../session.c; sourceTree = \"<group>\"; };\n\t\t907FF75A2521C09F00BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/FindAndReplace.xib; sourceTree = \"<group>\"; };\n\t\t907FF75B2521C09F00BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/Preferences.xib; sourceTree = \"<group>\"; };\n\t\t907FF75C2521C0A000BADACB /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = \"<group>\"; };\n\t\t907FF7622521C2FB00BADACB /* zh-Hant */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"zh-Hant\"; path = \"zh-Hant.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t907FF7632521CBAC00BADACB /* zh-Hans */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"zh-Hans\"; path = \"zh-Hans.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t907FF7642521CBC500BADACB /* ja */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ja; path = ja.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90922A3B221D429500F1E1F4 /* misc2.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = misc2.c; path = ../misc2.c; sourceTree = \"<group>\"; };\n\t\t90922A3C221D429500F1E1F4 /* if_mzsch.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_mzsch.c; path = ../if_mzsch.c; sourceTree = \"<group>\"; };\n\t\t90922A3D221D429500F1E1F4 /* version.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = version.h; path = ../version.h; sourceTree = \"<group>\"; };\n\t\t90922A3E221D429500F1E1F4 /* digraph.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = digraph.c; path = ../digraph.c; sourceTree = \"<group>\"; };\n\t\t90922A40221D429500F1E1F4 /* keymap.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = keymap.h; path = ../keymap.h; sourceTree = \"<group>\"; };\n\t\t90922A41221D429500F1E1F4 /* iscygpty.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = iscygpty.c; path = ../iscygpty.c; sourceTree = \"<group>\"; };\n\t\t90922A42221D429600F1E1F4 /* if_python3.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_python3.c; path = ../if_python3.c; sourceTree = \"<group>\"; };\n\t\t90922A43221D429600F1E1F4 /* dict.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dict.c; path = ../dict.c; sourceTree = \"<group>\"; };\n\t\t90922A45221D429600F1E1F4 /* kword_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = kword_test.c; path = ../kword_test.c; sourceTree = \"<group>\"; };\n\t\t90922A46221D429600F1E1F4 /* if_perlsfio.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_perlsfio.c; path = ../if_perlsfio.c; sourceTree = \"<group>\"; };\n\t\t90922A47221D429600F1E1F4 /* pty.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = pty.c; path = ../pty.c; sourceTree = \"<group>\"; };\n\t\t90922A48221D429600F1E1F4 /* ex_cmdidxs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ex_cmdidxs.h; path = ../ex_cmdidxs.h; sourceTree = \"<group>\"; };\n\t\t90922A49221D429600F1E1F4 /* if_py_both.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_py_both.h; path = ../if_py_both.h; sourceTree = \"<group>\"; };\n\t\t90922A4A221D429600F1E1F4 /* nbdebug.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = nbdebug.c; path = ../nbdebug.c; sourceTree = \"<group>\"; };\n\t\t90922A4B221D429600F1E1F4 /* mark.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mark.c; path = ../mark.c; sourceTree = \"<group>\"; };\n\t\t90922A4C221D429600F1E1F4 /* gui.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui.c; path = ../gui.c; sourceTree = \"<group>\"; };\n\t\t90922A4D221D429600F1E1F4 /* ex_eval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_eval.c; path = ../ex_eval.c; sourceTree = \"<group>\"; };\n\t\t90922A4E221D429600F1E1F4 /* netbeans.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = netbeans.c; path = ../netbeans.c; sourceTree = \"<group>\"; };\n\t\t90922A4F221D429600F1E1F4 /* json_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = json_test.c; path = ../json_test.c; sourceTree = \"<group>\"; };\n\t\t90922A50221D429600F1E1F4 /* hashtab.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = hashtab.c; path = ../hashtab.c; sourceTree = \"<group>\"; };\n\t\t90922A51221D429600F1E1F4 /* memfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memfile.c; path = ../memfile.c; sourceTree = \"<group>\"; };\n\t\t90922A52221D429600F1E1F4 /* iscygpty.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = iscygpty.h; path = ../iscygpty.h; sourceTree = \"<group>\"; };\n\t\t90922A53221D429700F1E1F4 /* ex_cmds2.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_cmds2.c; path = ../ex_cmds2.c; sourceTree = \"<group>\"; };\n\t\t90922A54221D429700F1E1F4 /* arabic.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = arabic.c; path = ../arabic.c; sourceTree = \"<group>\"; };\n\t\t90922A55221D429700F1E1F4 /* gui_beval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui_beval.c; path = ../gui_beval.c; sourceTree = \"<group>\"; };\n\t\t90922A56221D429700F1E1F4 /* crypt_zip.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = crypt_zip.c; path = ../crypt_zip.c; sourceTree = \"<group>\"; };\n\t\t90922A57221D429700F1E1F4 /* hardcopy.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = hardcopy.c; path = ../hardcopy.c; sourceTree = \"<group>\"; };\n\t\t90922A58221D429700F1E1F4 /* list.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = list.c; path = ../list.c; sourceTree = \"<group>\"; };\n\t\t90922A5B221D429700F1E1F4 /* eval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = eval.c; path = ../eval.c; sourceTree = \"<group>\"; };\n\t\t90922A5C221D429700F1E1F4 /* userfunc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = userfunc.c; path = ../userfunc.c; sourceTree = \"<group>\"; };\n\t\t90922A5D221D429700F1E1F4 /* os_mac.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = os_mac.h; path = ../os_mac.h; sourceTree = \"<group>\"; };\n\t\t90922A5E221D429700F1E1F4 /* nbdebug.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nbdebug.h; path = ../nbdebug.h; sourceTree = \"<group>\"; };\n\t\t90922A5F221D429700F1E1F4 /* message_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = message_test.c; path = ../message_test.c; sourceTree = \"<group>\"; };\n\t\t90922A60221D429800F1E1F4 /* tag.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = tag.c; path = ../tag.c; sourceTree = \"<group>\"; };\n\t\t90922A62221D429800F1E1F4 /* blowfish.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = blowfish.c; path = ../blowfish.c; sourceTree = \"<group>\"; };\n\t\t90922A63221D429800F1E1F4 /* message.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = message.c; path = ../message.c; sourceTree = \"<group>\"; };\n\t\t90922A64221D429800F1E1F4 /* termlib.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = termlib.c; path = ../termlib.c; sourceTree = \"<group>\"; };\n\t\t90922A65221D429800F1E1F4 /* beval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = beval.c; path = ../beval.c; sourceTree = \"<group>\"; };\n\t\t90922A66221D429800F1E1F4 /* alloc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = alloc.h; path = ../alloc.h; sourceTree = \"<group>\"; };\n\t\t90922A67221D429800F1E1F4 /* if_python.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_python.c; path = ../if_python.c; sourceTree = \"<group>\"; };\n\t\t90922A68221D429800F1E1F4 /* protodef.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = protodef.h; path = ../protodef.h; sourceTree = \"<group>\"; };\n\t\t90922A69221D429800F1E1F4 /* macros.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = macros.h; path = ../macros.h; sourceTree = \"<group>\"; };\n\t\t90922A6A221D429800F1E1F4 /* if_cscope.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_cscope.c; path = ../if_cscope.c; sourceTree = \"<group>\"; };\n\t\t90922A6C221D429900F1E1F4 /* dosinst.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = dosinst.h; path = ../dosinst.h; sourceTree = \"<group>\"; };\n\t\t90922A6D221D429900F1E1F4 /* memline.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memline.c; path = ../memline.c; sourceTree = \"<group>\"; };\n\t\t90922A6E221D429900F1E1F4 /* proto.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = proto.h; path = ../proto.h; sourceTree = \"<group>\"; };\n\t\t90922A6F221D429900F1E1F4 /* fileio.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = fileio.c; path = ../fileio.c; sourceTree = \"<group>\"; };\n\t\t90922A70221D429900F1E1F4 /* ex_docmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_docmd.c; path = ../ex_docmd.c; sourceTree = \"<group>\"; };\n\t\t90922A71221D429900F1E1F4 /* if_ruby.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_ruby.c; path = ../if_ruby.c; sourceTree = \"<group>\"; };\n\t\t90922A72221D429900F1E1F4 /* dosinst.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dosinst.c; path = ../dosinst.c; sourceTree = \"<group>\"; };\n\t\t90922A73221D429900F1E1F4 /* ops.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ops.c; path = ../ops.c; sourceTree = \"<group>\"; };\n\t\t90922A74221D429900F1E1F4 /* ex_getln.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_getln.c; path = ../ex_getln.c; sourceTree = \"<group>\"; };\n\t\t90922A76221D429900F1E1F4 /* ui.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ui.c; path = ../ui.c; sourceTree = \"<group>\"; };\n\t\t90922A77221D429900F1E1F4 /* fold.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = fold.c; path = ../fold.c; sourceTree = \"<group>\"; };\n\t\t90922A78221D429A00F1E1F4 /* menu.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = menu.c; path = ../menu.c; sourceTree = \"<group>\"; };\n\t\t90922A79221D429A00F1E1F4 /* beval.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = beval.h; path = ../beval.h; sourceTree = \"<group>\"; };\n\t\t90922A7A221D429A00F1E1F4 /* iid_ole.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = iid_ole.c; path = ../iid_ole.c; sourceTree = \"<group>\"; };\n\t\t90922A7B221D429A00F1E1F4 /* spell.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = spell.h; path = ../spell.h; sourceTree = \"<group>\"; };\n\t\t90922A7C221D429A00F1E1F4 /* mbyte.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = mbyte.c; path = ../mbyte.c; sourceTree = \"<group>\"; };\n\t\t90922A7D221D429A00F1E1F4 /* edit.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = edit.c; path = ../edit.c; sourceTree = \"<group>\"; };\n\t\t90922A7E221D429A00F1E1F4 /* search.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = search.c; path = ../search.c; sourceTree = \"<group>\"; };\n\t\t90922A7F221D429A00F1E1F4 /* undo.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = undo.c; path = ../undo.c; sourceTree = \"<group>\"; };\n\t\t90922A80221D429A00F1E1F4 /* findfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = findfile.c; path = ../findfile.c; sourceTree = \"<group>\"; };\n\t\t90922A81221D429A00F1E1F4 /* vimrun.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vimrun.c; path = ../vimrun.c; sourceTree = \"<group>\"; };\n\t\t90922A82221D429A00F1E1F4 /* globals.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = globals.h; path = ../globals.h; sourceTree = \"<group>\"; };\n\t\t90922A83221D429A00F1E1F4 /* option.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = option.c; path = ../option.c; sourceTree = \"<group>\"; };\n\t\t90922A84221D429B00F1E1F4 /* term.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = term.c; path = ../term.c; sourceTree = \"<group>\"; };\n\t\t90922A85221D429B00F1E1F4 /* gui.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = gui.h; path = ../gui.h; sourceTree = \"<group>\"; };\n\t\t90922A87221D429B00F1E1F4 /* if_tcl.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_tcl.c; path = ../if_tcl.c; sourceTree = \"<group>\"; };\n\t\t90922A88221D429B00F1E1F4 /* blob.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = blob.c; path = ../blob.c; sourceTree = \"<group>\"; };\n\t\t90922A89221D429B00F1E1F4 /* if_mzsch.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_mzsch.h; path = ../if_mzsch.h; sourceTree = \"<group>\"; };\n\t\t90922A8A221D429B00F1E1F4 /* channel.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = channel.c; path = ../channel.c; sourceTree = \"<group>\"; };\n\t\t90922A8B221D429B00F1E1F4 /* indent.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = indent.c; path = ../indent.c; sourceTree = \"<group>\"; };\n\t\t90922A8C221D429B00F1E1F4 /* os_unix.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = os_unix.h; path = ../os_unix.h; sourceTree = \"<group>\"; };\n\t\t90922A8D221D429B00F1E1F4 /* main.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = main.c; path = ../main.c; sourceTree = \"<group>\"; };\n\t\t90922A8E221D429B00F1E1F4 /* ex_cmds.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ex_cmds.h; path = ../ex_cmds.h; sourceTree = \"<group>\"; };\n\t\t90922A90221D429B00F1E1F4 /* regexp_nfa.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp_nfa.c; path = ../regexp_nfa.c; sourceTree = \"<group>\"; };\n\t\t90922A91221D429B00F1E1F4 /* textprop.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textprop.c; path = ../textprop.c; sourceTree = \"<group>\"; };\n\t\t90922A92221D429B00F1E1F4 /* regexp.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = regexp.h; path = ../regexp.h; sourceTree = \"<group>\"; };\n\t\t90922A93221D429B00F1E1F4 /* charset.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = charset.c; path = ../charset.c; sourceTree = \"<group>\"; };\n\t\t90922A94221D429B00F1E1F4 /* quickfix.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = quickfix.c; path = ../quickfix.c; sourceTree = \"<group>\"; };\n\t\t90922A95221D429B00F1E1F4 /* crypt.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = crypt.c; path = ../crypt.c; sourceTree = \"<group>\"; };\n\t\t90922A96221D429B00F1E1F4 /* vim.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = vim.h; path = ../vim.h; sourceTree = \"<group>\"; };\n\t\t90922A97221D429B00F1E1F4 /* syntax.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = syntax.c; path = ../syntax.c; sourceTree = \"<group>\"; };\n\t\t90922A99221D429B00F1E1F4 /* if_xcmdsrv.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_xcmdsrv.c; path = ../if_xcmdsrv.c; sourceTree = \"<group>\"; };\n\t\t90922A9B221D429C00F1E1F4 /* evalfunc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = evalfunc.c; path = ../evalfunc.c; sourceTree = \"<group>\"; };\n\t\t90922A9C221D429C00F1E1F4 /* sha256.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sha256.c; path = ../sha256.c; sourceTree = \"<group>\"; };\n\t\t90922A9D221D429C00F1E1F4 /* screen.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = screen.c; path = ../screen.c; sourceTree = \"<group>\"; };\n\t\t90922A9F221D429C00F1E1F4 /* json.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = json.c; path = ../json.c; sourceTree = \"<group>\"; };\n\t\t90922AA0221D429C00F1E1F4 /* getchar.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = getchar.c; path = ../getchar.c; sourceTree = \"<group>\"; };\n\t\t90922AA1221D429C00F1E1F4 /* autocmd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = autocmd.c; path = ../autocmd.c; sourceTree = \"<group>\"; };\n\t\t90922AA2221D429C00F1E1F4 /* misc1.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = misc1.c; path = ../misc1.c; sourceTree = \"<group>\"; };\n\t\t90922AA3221D429C00F1E1F4 /* normal.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = normal.c; path = ../normal.c; sourceTree = \"<group>\"; };\n\t\t90922AA4221D429C00F1E1F4 /* if_ole.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = if_ole.h; path = ../if_ole.h; sourceTree = \"<group>\"; };\n\t\t90922AA6221D429C00F1E1F4 /* move.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = move.c; path = ../move.c; sourceTree = \"<group>\"; };\n\t\t90922AA7221D429C00F1E1F4 /* os_unix.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = os_unix.c; path = ../os_unix.c; sourceTree = \"<group>\"; };\n\t\t90922AA8221D429C00F1E1F4 /* spell.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spell.c; path = ../spell.c; sourceTree = \"<group>\"; };\n\t\t90922AA9221D429C00F1E1F4 /* buffer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = buffer.c; path = ../buffer.c; sourceTree = \"<group>\"; };\n\t\t90922AAA221D429C00F1E1F4 /* window.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = window.c; path = ../window.c; sourceTree = \"<group>\"; };\n\t\t90922AAB221D429C00F1E1F4 /* dlldata.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dlldata.c; path = ../dlldata.c; sourceTree = \"<group>\"; };\n\t\t90922AAC221D429C00F1E1F4 /* sign.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = sign.c; path = ../sign.c; sourceTree = \"<group>\"; };\n\t\t90922AAD221D429C00F1E1F4 /* ex_cmds.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = ex_cmds.c; path = ../ex_cmds.c; sourceTree = \"<group>\"; };\n\t\t90922AAE221D429C00F1E1F4 /* feature.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = feature.h; path = ../feature.h; sourceTree = \"<group>\"; };\n\t\t90922AAF221D429C00F1E1F4 /* os_mac_conv.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = os_mac_conv.c; path = ../os_mac_conv.c; sourceTree = \"<group>\"; };\n\t\t90922AB0221D429C00F1E1F4 /* ascii.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = ascii.h; path = ../ascii.h; sourceTree = \"<group>\"; };\n\t\t90922AB1221D429C00F1E1F4 /* option.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = option.h; path = ../option.h; sourceTree = \"<group>\"; };\n\t\t90922AB2221D429C00F1E1F4 /* memfile_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = memfile_test.c; path = ../memfile_test.c; sourceTree = \"<group>\"; };\n\t\t90922AB3221D429C00F1E1F4 /* spellfile.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = spellfile.c; path = ../spellfile.c; sourceTree = \"<group>\"; };\n\t\t90922AB4221D429C00F1E1F4 /* if_lua.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = if_lua.c; path = ../if_lua.c; sourceTree = \"<group>\"; };\n\t\t90922AB5221D429D00F1E1F4 /* structs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = structs.h; path = ../structs.h; sourceTree = \"<group>\"; };\n\t\t90922AB6221D429D00F1E1F4 /* diff.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = diff.c; path = ../diff.c; sourceTree = \"<group>\"; };\n\t\t90922AB7221D429D00F1E1F4 /* regexp.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = regexp.c; path = ../regexp.c; sourceTree = \"<group>\"; };\n\t\t90922AB8221D429D00F1E1F4 /* version.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = version.c; path = ../version.c; sourceTree = \"<group>\"; };\n\t\t90922AB9221D429D00F1E1F4 /* terminal.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = terminal.c; path = ../terminal.c; sourceTree = \"<group>\"; };\n\t\t90922ABA221D429D00F1E1F4 /* term.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = term.h; path = ../term.h; sourceTree = \"<group>\"; };\n\t\t90922ABC221D42F700F1E1F4 /* MMBackend.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMBackend.h; sourceTree = \"<group>\"; };\n\t\t90922ABD221D42F700F1E1F4 /* gui_macvim.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = gui_macvim.m; sourceTree = \"<group>\"; };\n\t\t90922ABE221D42F700F1E1F4 /* MMBackend.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMBackend.m; sourceTree = \"<group>\"; };\n\t\t909894372A56EB1E007B84A3 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/WhatsNew.xib; sourceTree = \"<group>\"; };\n\t\t9098943A2A56ECF6007B84A3 /* MMWhatsNewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MMWhatsNewController.h; sourceTree = \"<group>\"; };\n\t\t9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MMWhatsNewController.m; sourceTree = \"<group>\"; };\n\t\t90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = MMSparkle2Delegate.m; sourceTree = \"<group>\"; };\n\t\t90A33BEC28D56423003A2E2F /* MMSparkle2Delegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = MMSparkle2Delegate.h; sourceTree = \"<group>\"; };\n\t\t90AF83B32AA15BE50046DA2E /* if_perl.xs */ = {isa = PBXFileReference; explicitFileType = sourcecode.c; name = if_perl.xs; path = ../if_perl.xs; sourceTree = \"<group>\"; };\n\t\t90AF83B42AA15C660046DA2E /* nv_cmdidxs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nv_cmdidxs.h; path = ../nv_cmdidxs.h; sourceTree = \"<group>\"; };\n\t\t90AF83B52AA15C660046DA2E /* alloc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = alloc.c; path = ../alloc.c; sourceTree = \"<group>\"; };\n\t\t90AF83B62AA15C660046DA2E /* nv_cmds.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = nv_cmds.h; path = ../nv_cmds.h; sourceTree = \"<group>\"; };\n\t\t90AF83B72AA15C660046DA2E /* vim9cmds.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9cmds.c; path = ../vim9cmds.c; sourceTree = \"<group>\"; };\n\t\t90AF83B82AA15C660046DA2E /* termdefs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = termdefs.h; path = ../termdefs.h; sourceTree = \"<group>\"; };\n\t\t90AF83A92A8C37F70046DA2E /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = System/Library/Frameworks/Security.framework; sourceTree = SDKROOT; };\n\t\t90B9877B2A579F9500FC95D6 /* WebKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = WebKit.framework; path = System/Library/Frameworks/WebKit.framework; sourceTree = SDKROOT; };\n\t\t90F84F1E2521F2270000268B /* ko */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ko; path = ko.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F232521F6480000268B /* ca */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ca; path = ca.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F242521F6590000268B /* cs */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = cs; path = cs.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F252521F6670000268B /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F262521F69A0000268B /* de */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = de; path = de.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F272521F6A70000268B /* es */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = es; path = es.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F282521F6B10000268B /* fi */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fi; path = fi.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F292521F6C10000268B /* fr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fr; path = fr.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2A2521F6CB0000268B /* hu */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = hu; path = hu.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2B2521F6D60000268B /* it */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = it; path = it.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2C2521F6E30000268B /* nl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = nl; path = nl.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2D2521F7FC0000268B /* nb */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = nb; path = nb.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2E2521F8550000268B /* pl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = pl; path = pl.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F2F2521F8600000268B /* pt-BR */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"pt-BR\"; path = \"pt-BR.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t90F84F302521F8690000268B /* pt-PT */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = \"pt-PT\"; path = \"pt-PT.lproj/MainMenu.strings\"; sourceTree = \"<group>\"; };\n\t\t90F84F312521F8760000268B /* ru */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ru; path = ru.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F322521F87F0000268B /* sv */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = sv; path = sv.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t90F84F332521F8880000268B /* tr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = tr; path = tr.lproj/MainMenu.strings; sourceTree = \"<group>\"; };\n\t\t95241CE12573D587001E3711 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = \"<group>\"; };\n\t\t95241CF025749CC6001E3711 /* vim9type.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = vim9type.c; path = ../vim9type.c; sourceTree = \"<group>\"; };\n\t\t95241CF125749CC6001E3711 /* help.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = help.c; path = ../help.c; sourceTree = \"<group>\"; };\n\t\t95241CF225749CC6001E3711 /* gui_xim.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = gui_xim.c; path = ../gui_xim.c; sourceTree = \"<group>\"; };\n\t\t95241CF325749CC7001E3711 /* job.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = job.c; path = ../job.c; sourceTree = \"<group>\"; };\n\t\t95241CF425749CC7001E3711 /* textformat.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textformat.c; path = ../textformat.c; sourceTree = \"<group>\"; };\n\t\t95241CF525749CC7001E3711 /* match.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = match.c; path = ../match.c; sourceTree = \"<group>\"; };\n\t\t95241CF625749CC7001E3711 /* locale.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = locale.c; path = ../locale.c; sourceTree = \"<group>\"; };\n\t\t95241CF725749CC7001E3711 /* typval.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = typval.c; path = ../typval.c; sourceTree = \"<group>\"; };\n\t\t95241CF825749CC7001E3711 /* clientserver.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = clientserver.c; path = ../clientserver.c; sourceTree = \"<group>\"; };\n\t\t95241CF925749CC7001E3711 /* errors.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = errors.h; path = ../errors.h; sourceTree = \"<group>\"; };\n\t\t95241CFA25749CC7001E3711 /* textobject.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = textobject.c; path = ../textobject.c; sourceTree = \"<group>\"; };\n\t\t95241CFB25749D4A001E3711 /* os_macosx.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; name = os_macosx.m; path = ../os_macosx.m; sourceTree = \"<group>\"; };\n/* End PBXFileReference section */\n\n/* Begin PBXFrameworksBuildPhase section */\n\t\t8D11072E0486CEB800E47090 /* Frameworks */ = {\n\t\t\tisa = PBXFrameworksBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t90AF83AB2A8C37F70046DA2E /* Security.framework in Frameworks */,\n\t\t\t\t90B9877D2A579F9500FC95D6 /* WebKit.framework in Frameworks */,\n\t\t\t\t1DFE25A50C527BC4003000F7 /* PSMTabBarControl.framework in Frameworks */,\n\t\t\t\t8D11072F0486CEB800E47090 /* Cocoa.framework in Frameworks */,\n\t\t\t\t1D8B5A53104AF9FF002E59D5 /* Carbon.framework in Frameworks */,\n\t\t\t\t52A364731C4A5789005757EC /* Sparkle.framework in Frameworks */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXFrameworksBuildPhase section */\n\n/* Begin PBXGroup section */\n\t\t080E96DDFE201D6D7F000001 /* MacVim Source */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t9098943A2A56ECF6007B84A3 /* MMWhatsNewController.h */,\n\t\t\t\t9098943B2A56ECF6007B84A3 /* MMWhatsNewController.m */,\n\t\t\t\t1D44972111FCA9B400B0630F /* MMCoreTextView+ToolTip.m */,\n\t\t\t\t1D6008890E96A0B2003763F0 /* MMFindReplaceController.h */,\n\t\t\t\t1D60088A0E96A0B2003763F0 /* MMFindReplaceController.m */,\n\t\t\t\t1DE63FF90E71820F00959BDB /* MMCoreTextView.h */,\n\t\t\t\t1DE63FFA0E71820F00959BDB /* MMCoreTextView.m */,\n\t\t\t\t1D145C7D0E5227CE00691AA0 /* MMTextViewHelper.h */,\n\t\t\t\t1D145C7E0E5227CE00691AA0 /* MMTextViewHelper.m */,\n\t\t\t\t1D8059220E118663001699D1 /* Miscellaneous.h */,\n\t\t\t\t1D80591D0E1185EA001699D1 /* Miscellaneous.m */,\n\t\t\t\t0395A8310D71ED7800881434 /* DBPrefsWindowController.h */,\n\t\t\t\t0395A8320D71ED7800881434 /* DBPrefsWindowController.m */,\n\t\t\t\t1DE3F8E80D50F84600052B9E /* MMPreferenceController.h */,\n\t\t\t\t1DE3F8E90D50F84600052B9E /* MMPreferenceController.m */,\n\t\t\t\t1DE9B94D0D341AB8008FEDD4 /* MMWindow.h */,\n\t\t\t\t1DE9B94E0D341AB8008FEDD4 /* MMWindow.m */,\n\t\t\t\t1D80FBCF0CBBD3B700102A1C /* MMFullScreenWindow.h */,\n\t\t\t\t1D80FBD00CBBD3B700102A1C /* MMFullScreenWindow.m */,\n\t\t\t\t1D80FBD10CBBD3B700102A1C /* MMVimView.h */,\n\t\t\t\t1D80FBD20CBBD3B700102A1C /* MMVimView.m */,\n\t\t\t\t1DD66ECB0C803D3600EBDAB3 /* MMApplication.h */,\n\t\t\t\t1DD66ECC0C803D3600EBDAB3 /* MMApplication.m */,\n\t\t\t\t1D09AB3F0C6A4D520045497E /* MMTypesetter.h */,\n\t\t\t\t1D09AB400C6A4D520045497E /* MMTypesetter.m */,\n\t\t\t\t1D1474B90C567A910038FA2B /* MMWindowController.h */,\n\t\t\t\t1D1474BA0C567A910038FA2B /* MMWindowController.m */,\n\t\t\t\t1D1474B30C56796D0038FA2B /* MMVimController.h */,\n\t\t\t\t1D1474B40C56796D0038FA2B /* MMVimController.m */,\n\t\t\t\t1D1474AD0C5678370038FA2B /* MMTextView.h */,\n\t\t\t\t1D1474AE0C5678370038FA2B /* MMTextView.m */,\n\t\t\t\t1D1474A70C5677450038FA2B /* MMTextStorage.h */,\n\t\t\t\t1D1474A80C5677450038FA2B /* MMTextStorage.m */,\n\t\t\t\t1D14749D0C5673AE0038FA2B /* MMAppController.h */,\n\t\t\t\t1D14749E0C5673AE0038FA2B /* MMAppController.m */,\n\t\t\t\t1D1474950C56703C0038FA2B /* MacVim.h */,\n\t\t\t\t1D1474960C56703C0038FA2B /* MacVim.m */,\n\t\t\t\t32CA4F630368D1EE00C91783 /* MacVim_Prefix.pch */,\n\t\t\t\t29B97316FDCFA39411CA2CEA /* main.m */,\n\t\t\t\t90A33BE928D563DF003A2E2F /* MMSparkle2Delegate.m */,\n\t\t\t\t90A33BEC28D56423003A2E2F /* MMSparkle2Delegate.h */,\n\t\t\t);\n\t\t\tname = \"MacVim Source\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1058C7A0FEA54F0111CA2CBB /* Linked Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */,\n\t\t\t);\n\t\t\tname = \"Linked Frameworks\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1058C7A2FEA54F0111CA2CBB /* Other Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t29B97324FDCFA39411CA2CEA /* AppKit.framework */,\n\t\t\t\t29B97325FDCFA39411CA2CEA /* Foundation.framework */,\n\t\t\t);\n\t\t\tname = \"Other Frameworks\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t19C28FACFE9D520D11CA2CBB /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t8D1107320486CEB800E47090 /* MacVim.app */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D0F11480D58C77800D5DA09 /* Font */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t);\n\t\t\tname = Font;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D493D640C52482B00AB718C /* Executables */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493D570C5247BF00AB718C /* Vim */,\n\t\t\t);\n\t\t\tname = Executables;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1D493DB40C52533B00AB718C /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1DE602460C587F760055263D /* Vim Resources */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1DED785F0C6DE43D0079945F /* vimrc */,\n\t\t\t\t1DD0C20A0C60FF9A008CD84A /* gvimrc */,\n\t\t\t\t1DE602470C587FD10055263D /* runtime */,\n\t\t\t);\n\t\t\tname = \"Vim Resources\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t1DE9726C0C48050600F96A9F /* Toolbar */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1DCD00AA0E50B2B700460166 /* Attention.png */,\n\t\t\t\t1DCD00AB0E50B2B700460166 /* Copy.png */,\n\t\t\t\t1DCD00AC0E50B2B700460166 /* Cut.png */,\n\t\t\t\t1DCD00AD0E50B2B700460166 /* FindHelp.png */,\n\t\t\t\t1DCD00AE0E50B2B700460166 /* FindNext.png */,\n\t\t\t\t1DCD00AF0E50B2B700460166 /* FindPrev.png */,\n\t\t\t\t1DCD00B00E50B2B700460166 /* Help.png */,\n\t\t\t\t1DCD00B10E50B2B700460166 /* LoadSesn.png */,\n\t\t\t\t1DCD00B20E50B2B700460166 /* Make.png */,\n\t\t\t\t1DCD00B30E50B2B700460166 /* Open.png */,\n\t\t\t\t1DCD00B40E50B2B700460166 /* Paste.png */,\n\t\t\t\t1DCD00B50E50B2B700460166 /* Print.png */,\n\t\t\t\t1DCD00B60E50B2B700460166 /* Redo.png */,\n\t\t\t\t1DCD00B70E50B2B700460166 /* Replace.png */,\n\t\t\t\t1DCD00B80E50B2B700460166 /* RunCtags.png */,\n\t\t\t\t1DCD00B90E50B2B700460166 /* RunScript.png */,\n\t\t\t\t1DCD00BA0E50B2B700460166 /* Save.png */,\n\t\t\t\t1DCD00BB0E50B2B700460166 /* SaveAll.png */,\n\t\t\t\t1DCD00BC0E50B2B700460166 /* SaveSesn.png */,\n\t\t\t\t1DCD00BD0E50B2B700460166 /* TagJump.png */,\n\t\t\t\t1DCD00BE0E50B2B700460166 /* Undo.png */,\n\t\t\t);\n\t\t\tname = Toolbar;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97314FDCFA39411CA2CEA /* MacVim */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D493D640C52482B00AB718C /* Executables */,\n\t\t\t\t080E96DDFE201D6D7F000001 /* MacVim Source */,\n\t\t\t\t29B97317FDCFA39411CA2CEA /* Resources */,\n\t\t\t\t1DE602460C587F760055263D /* Vim Resources */,\n\t\t\t\t90922A3A221D417800F1E1F4 /* Vim Source */,\n\t\t\t\t29B97323FDCFA39411CA2CEA /* Frameworks */,\n\t\t\t\t52818AF81C1C073400F59085 /* QuickLook Plugin */,\n\t\t\t\t19C28FACFE9D520D11CA2CBB /* Products */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97317FDCFA39411CA2CEA /* Resources */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t1D384A0D100D671700D3C22F /* KeyBinding.plist */,\n\t\t\t\t1D9C602E0EF79C0C0034AD44 /* MacVim.icns */,\n\t\t\t\t0395A8A90D72D88B00881434 /* General.png */,\n\t\t\t\t1D22374A0E45DF4800E6FFFF /* Advanced.png */,\n\t\t\t\t1DD3D51D0D82D4C9006E4320 /* ibeam.png */,\n\t\t\t\t1D0F11480D58C77800D5DA09 /* Font */,\n\t\t\t\t1DE9726C0C48050600F96A9F /* Toolbar */,\n\t\t\t\t1DD9F5E40C85D60500E8D5A5 /* SystemColors.plist */,\n\t\t\t\t1DE8CC610C5E2AAD003F56E3 /* Actions.plist */,\n\t\t\t\t1DD04DEB0C529C5E006CDC2B /* Credits.rtf */,\n\t\t\t\t1D0E051B0BA5F83800B6049E /* Colors.plist */,\n\t\t\t\t8D1107310486CEB800E47090 /* Info.plist */,\n\t\t\t\t089C165CFE840E0CC02AAC07 /* InfoPlist.strings */,\n\t\t\t\t528DA6691426D4EB003380F1 /* macvim-askpass */,\n\t\t\t\t907FF7552521BDC200BADACB /* FindAndReplace.xib */,\n\t\t\t\t907FF7522521BDA600BADACB /* Preferences.xib */,\n\t\t\t\t907FF74F2521BCE200BADACB /* MainMenu.xib */,\n\t\t\t\t909894362A56EB1E007B84A3 /* WhatsNew.xib */,\n\t\t\t);\n\t\t\tname = Resources;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t29B97323FDCFA39411CA2CEA /* Frameworks */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90AF83A92A8C37F70046DA2E /* Security.framework */,\n\t\t\t\t90B9877B2A579F9500FC95D6 /* WebKit.framework */,\n\t\t\t\t52A364721C4A5789005757EC /* Sparkle.framework */,\n\t\t\t\t1D8B5A52104AF9FF002E59D5 /* Carbon.framework */,\n\t\t\t\t1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */,\n\t\t\t\t1058C7A0FEA54F0111CA2CBB /* Linked Frameworks */,\n\t\t\t\t1058C7A2FEA54F0111CA2CBB /* Other Frameworks */,\n\t\t\t);\n\t\t\tname = Frameworks;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t52818AF81C1C073400F59085 /* QuickLook Plugin */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */,\n\t\t\t);\n\t\t\tname = \"QuickLook Plugin\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t52818AFB1C1C075300F59085 /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t90922A3A221D417800F1E1F4 /* Vim Source */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90AF83B52AA15C660046DA2E /* alloc.c */,\n\t\t\t\t90AF83B42AA15C660046DA2E /* nv_cmdidxs.h */,\n\t\t\t\t90AF83B62AA15C660046DA2E /* nv_cmds.h */,\n\t\t\t\t90AF83B82AA15C660046DA2E /* termdefs.h */,\n\t\t\t\t90AF83B72AA15C660046DA2E /* vim9cmds.c */,\n\t\t\t\t90AF83B32AA15BE50046DA2E /* if_perl.xs */,\n\t\t\t\t90922A66221D429800F1E1F4 /* alloc.h */,\n\t\t\t\t90922A54221D429700F1E1F4 /* arabic.c */,\n\t\t\t\t901C070F2430C8CC00797C2A /* arglist.c */,\n\t\t\t\t90922AB0221D429C00F1E1F4 /* ascii.h */,\n\t\t\t\t90922AA1221D429C00F1E1F4 /* autocmd.c */,\n\t\t\t\t90922A65221D429800F1E1F4 /* beval.c */,\n\t\t\t\t90922A79221D429A00F1E1F4 /* beval.h */,\n\t\t\t\t90922A88221D429B00F1E1F4 /* blob.c */,\n\t\t\t\t90922A62221D429800F1E1F4 /* blowfish.c */,\n\t\t\t\t90922AA9221D429C00F1E1F4 /* buffer.c */,\n\t\t\t\t901C06FB2430C8C900797C2A /* bufwrite.c */,\n\t\t\t\t901C06F92430C8C900797C2A /* change.c */,\n\t\t\t\t90922A8A221D429B00F1E1F4 /* channel.c */,\n\t\t\t\t90922A93221D429B00F1E1F4 /* charset.c */,\n\t\t\t\t901C07002430C8CA00797C2A /* cindent.c */,\n\t\t\t\t95241CF825749CC7001E3711 /* clientserver.c */,\n\t\t\t\t901C07112430C8CC00797C2A /* clipboard.c */,\n\t\t\t\t901C07042430C8CA00797C2A /* cmdexpand.c */,\n\t\t\t\t901C06F82430C8C900797C2A /* cmdhist.c */,\n\t\t\t\t90922A56221D429700F1E1F4 /* crypt_zip.c */,\n\t\t\t\t90922A95221D429B00F1E1F4 /* crypt.c */,\n\t\t\t\t901C06FE2430C8CA00797C2A /* debugger.c */,\n\t\t\t\t90922A43221D429600F1E1F4 /* dict.c */,\n\t\t\t\t90922AB6221D429D00F1E1F4 /* diff.c */,\n\t\t\t\t90922A3E221D429500F1E1F4 /* digraph.c */,\n\t\t\t\t90922AAB221D429C00F1E1F4 /* dlldata.c */,\n\t\t\t\t90922A72221D429900F1E1F4 /* dosinst.c */,\n\t\t\t\t90922A6C221D429900F1E1F4 /* dosinst.h */,\n\t\t\t\t901C07032430C8CA00797C2A /* drawline.c */,\n\t\t\t\t901C06FD2430C8CA00797C2A /* drawscreen.c */,\n\t\t\t\t90922A7D221D429A00F1E1F4 /* edit.c */,\n\t\t\t\t95241CF925749CC7001E3711 /* errors.h */,\n\t\t\t\t90922A5B221D429700F1E1F4 /* eval.c */,\n\t\t\t\t901C07082430C8CB00797C2A /* evalbuffer.c */,\n\t\t\t\t90922A9B221D429C00F1E1F4 /* evalfunc.c */,\n\t\t\t\t901C06FC2430C8CA00797C2A /* evalvars.c */,\n\t\t\t\t901C06FA2430C8C900797C2A /* evalwindow.c */,\n\t\t\t\t90922A48221D429600F1E1F4 /* ex_cmdidxs.h */,\n\t\t\t\t90922AAD221D429C00F1E1F4 /* ex_cmds.c */,\n\t\t\t\t90922A8E221D429B00F1E1F4 /* ex_cmds.h */,\n\t\t\t\t90922A53221D429700F1E1F4 /* ex_cmds2.c */,\n\t\t\t\t90922A70221D429900F1E1F4 /* ex_docmd.c */,\n\t\t\t\t90922A4D221D429600F1E1F4 /* ex_eval.c */,\n\t\t\t\t90922A74221D429900F1E1F4 /* ex_getln.c */,\n\t\t\t\t90922AAE221D429C00F1E1F4 /* feature.h */,\n\t\t\t\t90922A6F221D429900F1E1F4 /* fileio.c */,\n\t\t\t\t901C07192430C8CD00797C2A /* filepath.c */,\n\t\t\t\t90922A80221D429A00F1E1F4 /* findfile.c */,\n\t\t\t\t90922A77221D429900F1E1F4 /* fold.c */,\n\t\t\t\t90922AA0221D429C00F1E1F4 /* getchar.c */,\n\t\t\t\t90922A82221D429A00F1E1F4 /* globals.h */,\n\t\t\t\t90922A55221D429700F1E1F4 /* gui_beval.c */,\n\t\t\t\t95241CF225749CC6001E3711 /* gui_xim.c */,\n\t\t\t\t90922A4C221D429600F1E1F4 /* gui.c */,\n\t\t\t\t90922A85221D429B00F1E1F4 /* gui.h */,\n\t\t\t\t90922A57221D429700F1E1F4 /* hardcopy.c */,\n\t\t\t\t90922A50221D429600F1E1F4 /* hashtab.c */,\n\t\t\t\t95241CF125749CC6001E3711 /* help.c */,\n\t\t\t\t901C07122430C8CC00797C2A /* highlight.c */,\n\t\t\t\t90922A6A221D429800F1E1F4 /* if_cscope.c */,\n\t\t\t\t90922AB4221D429C00F1E1F4 /* if_lua.c */,\n\t\t\t\t90922A3C221D429500F1E1F4 /* if_mzsch.c */,\n\t\t\t\t90922A89221D429B00F1E1F4 /* if_mzsch.h */,\n\t\t\t\t90922AA4221D429C00F1E1F4 /* if_ole.h */,\n\t\t\t\t90922A46221D429600F1E1F4 /* if_perlsfio.c */,\n\t\t\t\t90922A49221D429600F1E1F4 /* if_py_both.h */,\n\t\t\t\t90922A67221D429800F1E1F4 /* if_python.c */,\n\t\t\t\t90922A42221D429600F1E1F4 /* if_python3.c */,\n\t\t\t\t90922A71221D429900F1E1F4 /* if_ruby.c */,\n\t\t\t\t90922A87221D429B00F1E1F4 /* if_tcl.c */,\n\t\t\t\t90922A99221D429B00F1E1F4 /* if_xcmdsrv.c */,\n\t\t\t\t90922A7A221D429A00F1E1F4 /* iid_ole.c */,\n\t\t\t\t90922A8B221D429B00F1E1F4 /* indent.c */,\n\t\t\t\t901C070A2430C8CB00797C2A /* insexpand.c */,\n\t\t\t\t90922A41221D429500F1E1F4 /* iscygpty.c */,\n\t\t\t\t90922A52221D429600F1E1F4 /* iscygpty.h */,\n\t\t\t\t95241CF325749CC7001E3711 /* job.c */,\n\t\t\t\t90922A4F221D429600F1E1F4 /* json_test.c */,\n\t\t\t\t90922A9F221D429C00F1E1F4 /* json.c */,\n\t\t\t\t90922A40221D429500F1E1F4 /* keymap.h */,\n\t\t\t\t90922A45221D429600F1E1F4 /* kword_test.c */,\n\t\t\t\t90922A58221D429700F1E1F4 /* list.c */,\n\t\t\t\t95241CF625749CC7001E3711 /* locale.c */,\n\t\t\t\t90922A69221D429800F1E1F4 /* macros.h */,\n\t\t\t\t90922ABB221D42DC00F1E1F4 /* MacVim */,\n\t\t\t\t90922A8D221D429B00F1E1F4 /* main.c */,\n\t\t\t\t901C06F42430C8C800797C2A /* map.c */,\n\t\t\t\t90922A4B221D429600F1E1F4 /* mark.c */,\n\t\t\t\t95241CF525749CC7001E3711 /* match.c */,\n\t\t\t\t90922A7C221D429A00F1E1F4 /* mbyte.c */,\n\t\t\t\t90922AB2221D429C00F1E1F4 /* memfile_test.c */,\n\t\t\t\t90922A51221D429600F1E1F4 /* memfile.c */,\n\t\t\t\t90922A6D221D429900F1E1F4 /* memline.c */,\n\t\t\t\t90922A78221D429A00F1E1F4 /* menu.c */,\n\t\t\t\t90922A5F221D429700F1E1F4 /* message_test.c */,\n\t\t\t\t90922A63221D429800F1E1F4 /* message.c */,\n\t\t\t\t90922AA2221D429C00F1E1F4 /* misc1.c */,\n\t\t\t\t90922A3B221D429500F1E1F4 /* misc2.c */,\n\t\t\t\t901C07152430C8CC00797C2A /* mouse.c */,\n\t\t\t\t90922AA6221D429C00F1E1F4 /* move.c */,\n\t\t\t\t90922A4A221D429600F1E1F4 /* nbdebug.c */,\n\t\t\t\t90922A5E221D429700F1E1F4 /* nbdebug.h */,\n\t\t\t\t90922A4E221D429600F1E1F4 /* netbeans.c */,\n\t\t\t\t90922AA3221D429C00F1E1F4 /* normal.c */,\n\t\t\t\t90922A73221D429900F1E1F4 /* ops.c */,\n\t\t\t\t90922A83221D429A00F1E1F4 /* option.c */,\n\t\t\t\t90922AB1221D429C00F1E1F4 /* option.h */,\n\t\t\t\t901C07162430C8CD00797C2A /* optiondefs.h */,\n\t\t\t\t901C07172430C8CD00797C2A /* optionstr.c */,\n\t\t\t\t90922AAF221D429C00F1E1F4 /* os_mac_conv.c */,\n\t\t\t\t90922A5D221D429700F1E1F4 /* os_mac.h */,\n\t\t\t\t95241CFB25749D4A001E3711 /* os_macosx.m */,\n\t\t\t\t90922AA7221D429C00F1E1F4 /* os_unix.c */,\n\t\t\t\t90922A8C221D429B00F1E1F4 /* os_unix.h */,\n\t\t\t\t901C06FF2430C8CA00797C2A /* popupmenu.c */,\n\t\t\t\t901C07022430C8CA00797C2A /* popupwin.c */,\n\t\t\t\t901C070B2430C8CB00797C2A /* profiler.c */,\n\t\t\t\t90922A6E221D429900F1E1F4 /* proto.h */,\n\t\t\t\t90922A68221D429800F1E1F4 /* protodef.h */,\n\t\t\t\t90922A47221D429600F1E1F4 /* pty.c */,\n\t\t\t\t90922A94221D429B00F1E1F4 /* quickfix.c */,\n\t\t\t\t901C07142430C8CC00797C2A /* regexp_bt.c */,\n\t\t\t\t90922A90221D429B00F1E1F4 /* regexp_nfa.c */,\n\t\t\t\t90922AB7221D429D00F1E1F4 /* regexp.c */,\n\t\t\t\t90922A92221D429B00F1E1F4 /* regexp.h */,\n\t\t\t\t901C07062430C8CB00797C2A /* register.c */,\n\t\t\t\t90922A9D221D429C00F1E1F4 /* screen.c */,\n\t\t\t\t901C07052430C8CB00797C2A /* scriptfile.c */,\n\t\t\t\t90922A7E221D429A00F1E1F4 /* search.c */,\n\t\t\t\t901C071A2430C8CD00797C2A /* session.c */,\n\t\t\t\t90922A9C221D429C00F1E1F4 /* sha256.c */,\n\t\t\t\t90922AAC221D429C00F1E1F4 /* sign.c */,\n\t\t\t\t901C070D2430C8CC00797C2A /* sound.c */,\n\t\t\t\t90922AA8221D429C00F1E1F4 /* spell.c */,\n\t\t\t\t90922A7B221D429A00F1E1F4 /* spell.h */,\n\t\t\t\t90922AB3221D429C00F1E1F4 /* spellfile.c */,\n\t\t\t\t901C07092430C8CB00797C2A /* spellsuggest.c */,\n\t\t\t\t90922AB5221D429D00F1E1F4 /* structs.h */,\n\t\t\t\t90922A97221D429B00F1E1F4 /* syntax.c */,\n\t\t\t\t90922A60221D429800F1E1F4 /* tag.c */,\n\t\t\t\t90922A84221D429B00F1E1F4 /* term.c */,\n\t\t\t\t90922ABA221D429D00F1E1F4 /* term.h */,\n\t\t\t\t90922AB9221D429D00F1E1F4 /* terminal.c */,\n\t\t\t\t90922A64221D429800F1E1F4 /* termlib.c */,\n\t\t\t\t901C06F72430C8C900797C2A /* testing.c */,\n\t\t\t\t95241CF425749CC7001E3711 /* textformat.c */,\n\t\t\t\t95241CFA25749CC7001E3711 /* textobject.c */,\n\t\t\t\t90922A91221D429B00F1E1F4 /* textprop.c */,\n\t\t\t\t901C06F62430C8C900797C2A /* time.c */,\n\t\t\t\t95241CF725749CC7001E3711 /* typval.c */,\n\t\t\t\t90922A76221D429900F1E1F4 /* ui.c */,\n\t\t\t\t90922A7F221D429A00F1E1F4 /* undo.c */,\n\t\t\t\t901C07132430C8CC00797C2A /* uninstall.c */,\n\t\t\t\t901C07012430C8CA00797C2A /* usercmd.c */,\n\t\t\t\t90922A5C221D429700F1E1F4 /* userfunc.c */,\n\t\t\t\t90922AB8221D429D00F1E1F4 /* version.c */,\n\t\t\t\t90922A3D221D429500F1E1F4 /* version.h */,\n\t\t\t\t90922A96221D429B00F1E1F4 /* vim.h */,\n\t\t\t\t901C070E2430C8CC00797C2A /* vim9.h */,\n\t\t\t\t901C070C2430C8CB00797C2A /* vim9compile.c */,\n\t\t\t\t901C07072430C8CB00797C2A /* vim9execute.c */,\n\t\t\t\t901C07102430C8CC00797C2A /* vim9script.c */,\n\t\t\t\t95241CF025749CC6001E3711 /* vim9type.c */,\n\t\t\t\t901C07182430C8CD00797C2A /* viminfo.c */,\n\t\t\t\t90922A81221D429A00F1E1F4 /* vimrun.c */,\n\t\t\t\t90922AAA221D429C00F1E1F4 /* window.c */,\n\t\t\t);\n\t\t\tname = \"Vim Source\";\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t90922ABB221D42DC00F1E1F4 /* MacVim */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t90922ABD221D42F700F1E1F4 /* gui_macvim.m */,\n\t\t\t\t90922ABC221D42F700F1E1F4 /* MMBackend.h */,\n\t\t\t\t90922ABE221D42F700F1E1F4 /* MMBackend.m */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n/* End PBXGroup section */\n\n/* Begin PBXNativeTarget section */\n\t\t8D1107260486CEB800E47090 /* MacVim */ = {\n\t\t\tisa = PBXNativeTarget;\n\t\t\tbuildConfigurationList = C01FCF4A08A954540054247B /* Build configuration list for PBXNativeTarget \"MacVim\" */;\n\t\t\tbuildPhases = (\n\t\t\t\t8D1107290486CEB800E47090 /* Resources */,\n\t\t\t\t8D11072C0486CEB800E47090 /* Sources */,\n\t\t\t\t8D11072E0486CEB800E47090 /* Frameworks */,\n\t\t\t\t1D0DCAD80BA3604D00B6CCFA /* Copy Executables */,\n\t\t\t\t1D9EB2840C366D7B0074B739 /* Copy Frameworks */,\n\t\t\t\t52818B021C1C088000F59085 /* Copy QuickLookPlugin */,\n\t\t\t\t1DE608B80C58807F0055263D /* Copy default vimrc files */,\n\t\t\t\t9050374C2AAEFA2500E9846A /* Generate runtime folder list */,\n\t\t\t\t90BD4EF224E0E8B700BF29F2 /* Copy Vim runtime / localization files */,\n\t\t\t\t1D1C31F00EFFBFD6003FE9A5 /* Make Document Icons */,\n\t\t\t\t528DA6671426D456003380F1 /* Copy Scripts */,\n\t\t\t\t52283AB71EBA200C00A6F6B9 /* Copy mvim scripts */,\n\t\t\t\t90C052E1251E889500E2D81E /* Copy vimtutor */,\n\t\t\t\t9099B3CA2914B272005C9F32 /* Clean up build */,\n\t\t\t);\n\t\t\tbuildRules = (\n\t\t\t);\n\t\t\tdependencies = (\n\t\t\t\t1D493DCD0C5254A400AB718C /* PBXTargetDependency */,\n\t\t\t\t52818B011C1C084100F59085 /* PBXTargetDependency */,\n\t\t\t);\n\t\t\tname = MacVim;\n\t\t\tproductInstallPath = \"$(HOME)/Applications\";\n\t\t\tproductName = MacVim;\n\t\t\tproductReference = 8D1107320486CEB800E47090 /* MacVim.app */;\n\t\t\tproductType = \"com.apple.product-type.application\";\n\t\t};\n/* End PBXNativeTarget section */\n\n/* Begin PBXProject section */\n\t\t29B97313FDCFA39411CA2CEA /* Project object */ = {\n\t\t\tisa = PBXProject;\n\t\t\tattributes = {\n\t\t\t\tBuildIndependentTargetsInParallel = YES;\n\t\t\t\tLastUpgradeCheck = 0710;\n\t\t\t};\n\t\t\tbuildConfigurationList = C01FCF4E08A954540054247B /* Build configuration list for PBXProject \"MacVim\" */;\n\t\t\tcompatibilityVersion = \"Xcode 6.3\";\n\t\t\tdevelopmentRegion = en;\n\t\t\thasScannedForEncodings = 1;\n\t\t\tknownRegions = (\n\t\t\t\tBase,\n\t\t\t\t\"zh-Hant\",\n\t\t\t\t\"zh-Hans\",\n\t\t\t\tja,\n\t\t\t\tko,\n\t\t\t\tca,\n\t\t\t\tcs,\n\t\t\t\tda,\n\t\t\t\tde,\n\t\t\t\tes,\n\t\t\t\tfi,\n\t\t\t\tfr,\n\t\t\t\thu,\n\t\t\t\tit,\n\t\t\t\tnl,\n\t\t\t\tnb,\n\t\t\t\tpl,\n\t\t\t\t\"pt-BR\",\n\t\t\t\t\"pt-PT\",\n\t\t\t\tru,\n\t\t\t\tsv,\n\t\t\t\ttr,\n\t\t\t\ten,\n\t\t\t);\n\t\t\tmainGroup = 29B97314FDCFA39411CA2CEA /* MacVim */;\n\t\t\tprojectDirPath = \"\";\n\t\t\tprojectReferences = (\n\t\t\t\t{\n\t\t\t\t\tProductGroup = 1D493DB40C52533B00AB718C /* Products */;\n\t\t\t\t\tProjectRef = 1D493DB30C52533B00AB718C /* PSMTabBarControl.xcodeproj */;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tProductGroup = 52818AFB1C1C075300F59085 /* Products */;\n\t\t\t\t\tProjectRef = 52818AFA1C1C075300F59085 /* QuickLookStephen.xcodeproj */;\n\t\t\t\t},\n\t\t\t);\n\t\t\tprojectRoot = \"\";\n\t\t\ttargets = (\n\t\t\t\t8D1107260486CEB800E47090 /* MacVim */,\n\t\t\t);\n\t\t};\n/* End PBXProject section */\n\n/* Begin PBXReferenceProxy section */\n\t\t1D493DB90C52533B00AB718C /* PSMTabBarControl.framework */ = {\n\t\t\tisa = PBXReferenceProxy;\n\t\t\tfileType = wrapper.framework;\n\t\t\tpath = PSMTabBarControl.framework;\n\t\t\tremoteRef = 1D493DB80C52533B00AB718C /* PBXContainerItemProxy */;\n\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n\t\t};\n\t\t52818AFF1C1C075300F59085 /* QLStephen.qlgenerator */ = {\n\t\t\tisa = PBXReferenceProxy;\n\t\t\tfileType = wrapper.cfbundle;\n\t\t\tpath = QLStephen.qlgenerator;\n\t\t\tremoteRef = 52818AFE1C1C075300F59085 /* PBXContainerItemProxy */;\n\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n\t\t};\n/* End PBXReferenceProxy section */\n\n/* Begin PBXResourcesBuildPhase section */\n\t\t8D1107290486CEB800E47090 /* Resources */ = {\n\t\t\tisa = PBXResourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */,\n\t\t\t\t1D0E051C0BA5F83800B6049E /* Colors.plist in Resources */,\n\t\t\t\t1DD04DEC0C529C5E006CDC2B /* Credits.rtf in Resources */,\n\t\t\t\t1DE8CC620C5E2AAD003F56E3 /* Actions.plist in Resources */,\n\t\t\t\t1DD9F5E50C85D60500E8D5A5 /* SystemColors.plist in Resources */,\n\t\t\t\t0395A8AA0D72D88B00881434 /* General.png in Resources */,\n\t\t\t\t1DD3D51E0D82D4C9006E4320 /* ibeam.png in Resources */,\n\t\t\t\t1D22374B0E45DF4800E6FFFF /* Advanced.png in Resources */,\n\t\t\t\t1DCD00BF0E50B2B700460166 /* Attention.png in Resources */,\n\t\t\t\t1DCD00C00E50B2B700460166 /* Copy.png in Resources */,\n\t\t\t\t1DCD00C10E50B2B700460166 /* Cut.png in Resources */,\n\t\t\t\t1DCD00C20E50B2B700460166 /* FindHelp.png in Resources */,\n\t\t\t\t1DCD00C30E50B2B700460166 /* FindNext.png in Resources */,\n\t\t\t\t1DCD00C40E50B2B700460166 /* FindPrev.png in Resources */,\n\t\t\t\t1DCD00C50E50B2B700460166 /* Help.png in Resources */,\n\t\t\t\t1DCD00C60E50B2B700460166 /* LoadSesn.png in Resources */,\n\t\t\t\t1DCD00C70E50B2B700460166 /* Make.png in Resources */,\n\t\t\t\t1DCD00C80E50B2B700460166 /* Open.png in Resources */,\n\t\t\t\t1DCD00C90E50B2B700460166 /* Paste.png in Resources */,\n\t\t\t\t1DCD00CA0E50B2B700460166 /* Print.png in Resources */,\n\t\t\t\t1DCD00CB0E50B2B700460166 /* Redo.png in Resources */,\n\t\t\t\t1DCD00CC0E50B2B700460166 /* Replace.png in Resources */,\n\t\t\t\t1DCD00CD0E50B2B700460166 /* RunCtags.png in Resources */,\n\t\t\t\t1DCD00CE0E50B2B700460166 /* RunScript.png in Resources */,\n\t\t\t\t1DCD00CF0E50B2B700460166 /* Save.png in Resources */,\n\t\t\t\t1DCD00D00E50B2B700460166 /* SaveAll.png in Resources */,\n\t\t\t\t1DCD00D10E50B2B700460166 /* SaveSesn.png in Resources */,\n\t\t\t\t909894382A56EB1E007B84A3 /* WhatsNew.xib in Resources */,\n\t\t\t\t1DCD00D20E50B2B700460166 /* TagJump.png in Resources */,\n\t\t\t\t1DCD00D30E50B2B700460166 /* Undo.png in Resources */,\n\t\t\t\t1D9C60520EF79C0C0034AD44 /* MacVim.icns in Resources */,\n\t\t\t\t1D384A0E100D671700D3C22F /* KeyBinding.plist in Resources */,\n\t\t\t\t907FF7542521BDA600BADACB /* Preferences.xib in Resources */,\n\t\t\t\t907FF7512521BCE200BADACB /* MainMenu.xib in Resources */,\n\t\t\t\t907FF7572521BDC300BADACB /* FindAndReplace.xib in Resources */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXResourcesBuildPhase section */\n\n/* Begin PBXShellScriptBuildPhase section */\n\t\t1D1C31F00EFFBFD6003FE9A5 /* Make Document Icons */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"$(PROJECT_DIR)/icons\",\n\t\t\t);\n\t\t\tname = \"Make Document Icons\";\n\t\t\toutputPaths = (\n\t\t\t\t\"$(TARGET_BUILD_DIR)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH)\",\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# Clear deployment target, else the python script always thinks we're building on Tiger\\nunset MACOSX_DEPLOYMENT_TARGET\\n\\n# Generate the icons (redirect stderr to ignore warnings)\\ncd \\\"$PROJECT_DIR\\\"/icons/\\nmake OUTDIR=\\\"$TARGET_BUILD_DIR\\\"/$UNLOCALIZED_RESOURCES_FOLDER_PATH 2> /dev/null\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t52283AB71EBA200C00A6F6B9 /* Copy mvim scripts */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"${SRCROOT}/mvim\",\n\t\t\t);\n\t\t\tname = \"Copy mvim scripts\";\n\t\t\toutputPaths = (\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/mvim,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"BINPATH=$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin\\nmkdir -p \\\"${BINPATH}\\\"\\ncp -a \\\"${SRCROOT}/mvim\\\" \\\"${BINPATH}/mvim\\\"\\nchmod 755 \\\"${BINPATH}/mvim\\\"\\n(cd \\\"${BINPATH}\\\"; for f in vim vimdiff view gvim gvimdiff gview mvimdiff mview; do ln -fs mvim $f; done)\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t9050374C2AAEFA2500E9846A /* Generate runtime folder list */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\talwaysOutOfDate = 1;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t);\n\t\t\tname = \"Generate runtime folder list\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t\"$(OBJROOT)/runtime_folder_list.xcfilelist\",\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# Generate a list of folders that will affect the runtime folder output, so\\n# that incremental build can use it to only install them if the runtime folders\\n# have changed. The main reason we have to manually generate it is because\\n# Xcode's \\\"Input File Lists\\\" doesn't support recursion/wildcards.\\n\\nfind -s ../../runtime -type d > \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist\\n\\nif cmp -s \\\"${OBJROOT}\\\"/runtime_folder_list.xcfilelist \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist; then\\n    rm \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist\\nelse\\n    mv -f \\\"${OBJROOT}\\\"/runtime_folder_list_new.xcfilelist \\\"${OBJROOT}\\\"/runtime_folder_list.xcfilelist\\nfi\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t9099B3CA2914B272005C9F32 /* Clean up build */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\talwaysOutOfDate = 1;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t);\n\t\t\tname = \"Clean up build\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"./scripts/cleanup-after-build \\\"$BUILT_PRODUCTS_DIR/$WRAPPER_NAME\\\" \\\"$REMOVE_SPARKLE\\\"\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t90BD4EF224E0E8B700BF29F2 /* Copy Vim runtime / localization files */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t\t$OBJROOT/runtime_folder_list.xcfilelist,\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"$(SRCROOT)/../xxd/xxd\",\n\t\t\t\t\"$(SRCROOT)/../po\",\n\t\t\t);\n\t\t\tname = \"Copy Vim runtime / localization files\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t$TARGET_BUILD_DIR/$UNLOCALIZED_RESOURCES_FOLDER_PATH/vim/runtime,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/zsh;\n\t\t\tshellScript = \"# Copy the runtime files to the app bundle, under Resources/vim/runtime folder.\\n# We cannot do a direct copy of the runtime folder as it contains misc test\\n# scripts and also man pages and we should use the Vim's defined rules to\\n# install them properly.\\n\\n# Note that this will also install man pages, under a \\\"man\\\" folder. This is\\n# useful if the user really wants to point their man page to MacVim's verison\\n# instead of builtin Vim, using MANPATH=/Applications/MacVim.app/Contents/man).\\n\\n# prefix: Reset to empty as it's set to /Applications for fallback rt-folder\\n# VIMNAME: Use the default \\\"vim\\\" to make sure man pages use that instead of \\\"Vim\\\"\\n# VIMRTDIR: Make sure to use \\\"runtime\\\" as by default it uses a \\\"vim90\\\" style folder which is mostly a relic.\\n\\ncd \\\"${SRCROOT}\\\"/..\\nmake \\\\\\n    DESTDIR=\\\"${TARGET_BUILD_DIR}\\\" \\\\\\n    prefix= \\\\\\n    VIMNAME=vim \\\\\\n    VIMRTDIR=/runtime \\\\\\n    macvim-install-runtime\\n\\n# Also add man pages for \\\"mvim\\\"\\nfor curdir in \\\"$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH\\\"/man/**/man1; do\\n    (cd $curdir; ln -f -s gvim.1 mvim.1)\\ndone\\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n\t\t90C052E1251E889500E2D81E /* Copy vimtutor */ = {\n\t\t\tisa = PBXShellScriptBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\tinputFileListPaths = (\n\t\t\t);\n\t\t\tinputPaths = (\n\t\t\t\t\"${SRCROOT}/../vimtutor\",\n\t\t\t\t\"${SRCROOT}/../gvimtutor\",\n\t\t\t);\n\t\t\tname = \"Copy vimtutor\";\n\t\t\toutputFileListPaths = (\n\t\t\t);\n\t\t\toutputPaths = (\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/vimtutor,\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/gvimtutor,\n\t\t\t\t$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin/mvimtutor,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t\tshellPath = /bin/sh;\n\t\t\tshellScript = \"# We could potentially use make installtutorbin installgtutorbin\\n# but this works and we need to do the symlink anyway.\\nBINPATH=$BUILT_PRODUCTS_DIR/$CONTENTS_FOLDER_PATH/bin\\nmkdir -p \\\"${BINPATH}\\\"\\ncp -a \\\"${SRCROOT}/../vimtutor\\\" \\\"${BINPATH}/vimtutor\\\"\\ncp -a \\\"${SRCROOT}/../gvimtutor\\\" \\\"${BINPATH}/gvimtutor\\\"\\nchmod 755 \\\"${BINPATH}/vimtutor\\\"\\nchmod 755 \\\"${BINPATH}/gvimtutor\\\"\\ncd \\\"${BINPATH}\\\"\\nln -fs gvimtutor mvimtutor \\n\";\n\t\t\tshowEnvVarsInLog = 0;\n\t\t};\n/* End PBXShellScriptBuildPhase section */\n\n/* Begin PBXSourcesBuildPhase section */\n\t\t8D11072C0486CEB800E47090 /* Sources */ = {\n\t\t\tisa = PBXSourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t8D11072D0486CEB800E47090 /* main.m in Sources */,\n\t\t\t\t1D1474980C56703C0038FA2B /* MacVim.m in Sources */,\n\t\t\t\t1D1474A00C5673AE0038FA2B /* MMAppController.m in Sources */,\n\t\t\t\t1D1474AA0C5677450038FA2B /* MMTextStorage.m in Sources */,\n\t\t\t\t1D1474B00C5678370038FA2B /* MMTextView.m in Sources */,\n\t\t\t\t1D1474B60C56796D0038FA2B /* MMVimController.m in Sources */,\n\t\t\t\t1D1474BC0C567A910038FA2B /* MMWindowController.m in Sources */,\n\t\t\t\t1D09AB420C6A4D520045497E /* MMTypesetter.m in Sources */,\n\t\t\t\t90A33BEA28D563DF003A2E2F /* MMSparkle2Delegate.m in Sources */,\n\t\t\t\t1DD66ECE0C803D3600EBDAB3 /* MMApplication.m in Sources */,\n\t\t\t\t1D80FBD40CBBD3B700102A1C /* MMFullScreenWindow.m in Sources */,\n\t\t\t\t1D80FBD60CBBD3B700102A1C /* MMVimView.m in Sources */,\n\t\t\t\t1DE9B9500D341AB8008FEDD4 /* MMWindow.m in Sources */,\n\t\t\t\t1DE3F8EB0D50F84600052B9E /* MMPreferenceController.m in Sources */,\n\t\t\t\t0395A8330D71ED7800881434 /* DBPrefsWindowController.m in Sources */,\n\t\t\t\t1D80591F0E1185EA001699D1 /* Miscellaneous.m in Sources */,\n\t\t\t\t9098943C2A56ECF6007B84A3 /* MMWhatsNewController.m in Sources */,\n\t\t\t\t1D145C7F0E5227CE00691AA0 /* MMTextViewHelper.m in Sources */,\n\t\t\t\t1D60088B0E96A0B2003763F0 /* MMFindReplaceController.m in Sources */,\n\t\t\t\t1DE63FFB0E71820F00959BDB /* MMCoreTextView.m in Sources */,\n\t\t\t\t1D44972211FCA9B400B0630F /* MMCoreTextView+ToolTip.m in Sources */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXSourcesBuildPhase section */\n\n/* Begin PBXTargetDependency section */\n\t\t1D493DCD0C5254A400AB718C /* PBXTargetDependency */ = {\n\t\t\tisa = PBXTargetDependency;\n\t\t\tname = PSMTabBarControlFramework;\n\t\t\ttargetProxy = 1D493DCC0C5254A400AB718C /* PBXContainerItemProxy */;\n\t\t};\n\t\t52818B011C1C084100F59085 /* PBXTargetDependency */ = {\n\t\t\tisa = PBXTargetDependency;\n\t\t\tname = QuickLookStephen;\n\t\t\ttargetProxy = 52818B001C1C084100F59085 /* PBXContainerItemProxy */;\n\t\t};\n/* End PBXTargetDependency section */\n\n/* Begin PBXVariantGroup section */\n\t\t089C165CFE840E0CC02AAC07 /* InfoPlist.strings */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t95241CE12573D587001E3711 /* en */,\n\t\t\t);\n\t\t\tname = InfoPlist.strings;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF74F2521BCE200BADACB /* MainMenu.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75C2521C0A000BADACB /* Base */,\n\t\t\t\t907FF7622521C2FB00BADACB /* zh-Hant */,\n\t\t\t\t907FF7632521CBAC00BADACB /* zh-Hans */,\n\t\t\t\t907FF7642521CBC500BADACB /* ja */,\n\t\t\t\t90F84F1E2521F2270000268B /* ko */,\n\t\t\t\t90F84F232521F6480000268B /* ca */,\n\t\t\t\t90F84F242521F6590000268B /* cs */,\n\t\t\t\t90F84F252521F6670000268B /* da */,\n\t\t\t\t90F84F262521F69A0000268B /* de */,\n\t\t\t\t90F84F272521F6A70000268B /* es */,\n\t\t\t\t90F84F282521F6B10000268B /* fi */,\n\t\t\t\t90F84F292521F6C10000268B /* fr */,\n\t\t\t\t90F84F2A2521F6CB0000268B /* hu */,\n\t\t\t\t90F84F2B2521F6D60000268B /* it */,\n\t\t\t\t90F84F2C2521F6E30000268B /* nl */,\n\t\t\t\t90F84F2D2521F7FC0000268B /* nb */,\n\t\t\t\t90F84F2E2521F8550000268B /* pl */,\n\t\t\t\t90F84F2F2521F8600000268B /* pt-BR */,\n\t\t\t\t90F84F302521F8690000268B /* pt-PT */,\n\t\t\t\t90F84F312521F8760000268B /* ru */,\n\t\t\t\t90F84F322521F87F0000268B /* sv */,\n\t\t\t\t90F84F332521F8880000268B /* tr */,\n\t\t\t);\n\t\t\tname = MainMenu.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF7522521BDA600BADACB /* Preferences.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75B2521C09F00BADACB /* Base */,\n\t\t\t);\n\t\t\tname = Preferences.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t907FF7552521BDC200BADACB /* FindAndReplace.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t907FF75A2521C09F00BADACB /* Base */,\n\t\t\t);\n\t\t\tname = FindAndReplace.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t909894362A56EB1E007B84A3 /* WhatsNew.xib */ = {\n\t\t\tisa = PBXVariantGroup;\n\t\t\tchildren = (\n\t\t\t\t909894372A56EB1E007B84A3 /* Base */,\n\t\t\t);\n\t\t\tname = WhatsNew.xib;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n/* End PBXVariantGroup section */\n\n/* Begin XCBuildConfiguration section */\n\t\tC01FCF4B08A954540054247B /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tCOPY_PHASE_STRIP = NO;\n\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n\t\t\t\t\t\"$(inherited)\",\n\t\t\t\t\t\"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)\",\n\t\t\t\t\t\"$(PROJECT_DIR)\",\n\t\t\t\t);\n\t\t\t\tFRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = \"\\\"$(SRCROOT)\\\"\";\n\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n\t\t\t\tGCC_ENABLE_FIX_AND_CONTINUE = YES;\n\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n\t\t\t\tGCC_MODEL_TUNING = G5;\n\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n\t\t\t\tGCC_VERSION = \"\";\n\t\t\t\tGCC_WARN_PEDANTIC = NO;\n\t\t\t\tHEADER_SEARCH_PATHS = \"\";\n\t\t\t\tINFOPLIST_FILE = Info.plist;\n\t\t\t\tINSTALL_PATH = \"$(HOME)/Applications\";\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"@loader_path/../Frameworks\";\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = \"\";\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = org.vim.MacVim;\n\t\t\t\tPRODUCT_NAME = MacVim;\n\t\t\t\tVERSIONING_SYSTEM = \"apple-generic\";\n\t\t\t\tWARNING_CFLAGS = \"-Wall\";\n\t\t\t\tWRAPPER_EXTENSION = app;\n\t\t\t\tZERO_LINK = NO;\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\tC01FCF4C08A954540054247B /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tCOPY_PHASE_STRIP = YES;\n\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n\t\t\t\t\t\"$(inherited)\",\n\t\t\t\t\t\"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)\",\n\t\t\t\t\t\"$(PROJECT_DIR)\",\n\t\t\t\t);\n\t\t\t\tFRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = \"\\\"$(SRCROOT)\\\"\";\n\t\t\t\tGCC_DYNAMIC_NO_PIC = YES;\n\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n\t\t\t\tGCC_GENERATE_DEBUGGING_SYMBOLS = NO;\n\t\t\t\tGCC_MODEL_TUNING = G5;\n\t\t\t\tGCC_OPTIMIZATION_LEVEL = s;\n\t\t\t\tGCC_VERSION = \"\";\n\t\t\t\tHEADER_SEARCH_PATHS = \"\";\n\t\t\t\tINFOPLIST_FILE = Info.plist;\n\t\t\t\tINSTALL_PATH = \"$(HOME)/Applications\";\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"@loader_path/../Frameworks\";\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = \"\";\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = org.vim.MacVim;\n\t\t\t\tPRODUCT_NAME = MacVim;\n\t\t\t\tVERSIONING_SYSTEM = \"apple-generic\";\n\t\t\t\tWRAPPER_EXTENSION = app;\n\t\t\t\tZERO_LINK = NO;\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n\t\tC01FCF4F08A954540054247B /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;\n\t\t\t\tENABLE_TESTABILITY = YES;\n\t\t\t\tGCC_VERSION = 4.2;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPREBINDING = NO;\n\t\t\t\tSYMROOT = \"$(PROJECT_DIR)/build\";\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\tC01FCF5008A954540054247B /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;\n\t\t\t\tGCC_VERSION = 4.2;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tPREBINDING = NO;\n\t\t\t\tSYMROOT = \"$(PROJECT_DIR)/build\";\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n/* End XCBuildConfiguration section */\n\n/* Begin XCConfigurationList section */\n\t\tC01FCF4A08A954540054247B /* Build configuration list for PBXNativeTarget \"MacVim\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\tC01FCF4B08A954540054247B /* Debug */,\n\t\t\t\tC01FCF4C08A954540054247B /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n\t\tC01FCF4E08A954540054247B /* Build configuration list for PBXProject \"MacVim\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\tC01FCF4F08A954540054247B /* Debug */,\n\t\t\t\tC01FCF5008A954540054247B /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n/* End XCConfigurationList section */\n\t};\n\trootObject = 29B97313FDCFA39411CA2CEA /* Project object */;\n}\n"], "filenames": ["src/MacVim/MMAppController.m", "src/MacVim/MMBackend.h", "src/MacVim/MMVimController.h", "src/MacVim/MMVimController.m", "src/MacVim/MacVim.h", "src/MacVim/MacVim.xcodeproj/project.pbxproj"], "buggy_code_start_loc": [307, 24, 37, 58, 200, 76], "buggy_code_end_loc": [2762, 25, 62, 2093, 203, 652], "fixing_code_start_loc": [307, 24, 37, 57, 200, 77], "fixing_code_end_loc": [2778, 25, 62, 2098, 203, 657], "type": "CWE-269", "message": "Macvim is a text editor for MacOS. Prior to version 178, Macvim makes use of an insecure interprocess communication (IPC) mechanism which could lead to a privilege escalation. Distributed objects are a concept introduced by Apple which allow one program to vend an interface to another program. What is not made clear in the documentation is that this service can vend this interface to any other program on the machine. The impact of exploitation is a privilege escalation to root - this is likely to affect anyone who is not careful about the software they download and use MacVim to edit files that would require root privileges. Version 178 contains a fix for this issue.", "other": {"cve": {"id": "CVE-2023-41036", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-07T04:20:50.427", "lastModified": "2023-11-14T18:41:48.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Macvim is a text editor for MacOS. Prior to version 178, Macvim makes use of an insecure interprocess communication (IPC) mechanism which could lead to a privilege escalation. Distributed objects are a concept introduced by Apple which allow one program to vend an interface to another program. What is not made clear in the documentation is that this service can vend this interface to any other program on the machine. The impact of exploitation is a privilege escalation to root - this is likely to affect anyone who is not careful about the software they download and use MacVim to edit files that would require root privileges. Version 178 contains a fix for this issue."}, {"lang": "es", "value": "Macvim es un editor de texto para MacOS. Antes de la versi\u00f3n 178, Macvim utiliza un mecanismo de Insecure Interprocess Communication (IPC) que podr\u00eda provocar una escalada de privilegios. Los objetos distribuidos son un concepto introducido por Apple que permite que un programa proporcione una interfaz a otro programa. Lo que no queda claro en la documentaci\u00f3n es que este servicio puede vender esta interfaz a cualquier otro programa en la m\u00e1quina. El impacto de la explotaci\u00f3n es una escalada de privilegios a root; esto probablemente afectar\u00e1 a cualquiera que no tenga cuidado con el software que descarga y use MacVim para editar archivos que requerir\u00edan privilegios de root. La versi\u00f3n 178 contiene una soluci\u00f3n para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:macvim:macvim:*:*:*:*:*:macos:*:*", "versionEndExcluding": "178", "matchCriteriaId": "3F7AD145-4C39-41D1-9400-48E0213E4EA8"}]}]}], "references": [{"url": "https://github.com/macvim-dev/macvim/blob/d9de087dddadbfd82fcb5dc9734380a2f829bd0a/src/MacVim/MMAppController.h#L28", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/macvim-dev/macvim/commit/399b43e9e1dbf656a1780e87344f4d3c875e4cda", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/macvim-dev/macvim/security/advisories/GHSA-9jgj-jfwg-99fv", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "ttps://github.com/macvim-dev/macvim/blob/d9de087dddadbfd82fcb5dc9734380a2f829bd0a/src/MacVim/MMBackend.h", "source": "security-advisories@github.com", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/macvim-dev/macvim/commit/399b43e9e1dbf656a1780e87344f4d3c875e4cda"}}