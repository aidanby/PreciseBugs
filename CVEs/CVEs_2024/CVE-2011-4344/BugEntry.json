{"buggy_code": ["/*\n * Copyright 2003-2006 Rick Knowles <winstone-devel at lists sourceforge net>\n * Distributed under the terms of either:\n * - the common development and distribution license (CDDL), v1.0; or\n * - the GNU Lesser General Public License, v2.1 or later\n */\npackage winstone;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Date;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServlet;\n\n/**\n * A simple servlet that writes out the body of the error \n * \n * @author <a href=\"mailto:rick_knowles@hotmail.com\">Rick Knowles</a>\n * @version $Id: ErrorServlet.java,v 1.3 2006/02/28 07:32:47 rickknowles Exp $\n */\npublic class ErrorServlet extends HttpServlet {\n    \n    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {\n        \n        Integer sc = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);\n        String msg = (String) request.getAttribute(RequestDispatcher.ERROR_MESSAGE);\n        Throwable err = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);\n        \n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        if (err != null) {\n            err.printStackTrace(pw);\n        } else {\n            pw.println(\"(none)\");\n        }\n        pw.flush();\n         \n        // If we are here there was no error servlet, so show the default error page\n        String output = Launcher.RESOURCES.getString(\"WinstoneResponse.ErrorPage\",\n                new String[] { sc + \"\", (msg == null ? \"\" : msg), sw.toString(),\n                Launcher.RESOURCES.getString(\"ServerVersion\"),\n                        \"\" + new Date() });\n        response.setContentLength(output.getBytes(response.getCharacterEncoding()).length);\n        Writer out = response.getWriter();\n        out.write(output);\n        out.flush();\n    }\n}\n", "package winstone;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class URIUtil {\n    /**\n     * Eliminates \".\" and \"..\" in the path.\n     * So that this method can be used for any string that looks like an URI,\n     * this method preserves the leading and trailing '/'.\n     */\n    static String canonicalPath(String path) {\n        List r = new ArrayList(Arrays.asList(path.split(\"/+\")));\n        for (int i=0; i<r.size(); ) {\n            String cur = (String)r.get(i);\n            if (cur.length()==0 || cur.equals(\".\")) {\n                // empty token occurs for example, \"\".split(\"/+\") is [\"\"]\n                r.remove(i);\n            } else\n            if (cur.equals(\"..\")) {\n                // i==0 means this is a broken URI.\n                r.remove(i);\n                if (i>0) {\n                    r.remove(i-1);\n                    i--;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        StringBuilder buf = new StringBuilder();\n        if (path.startsWith(\"/\"))\n            buf.append('/');\n        boolean first = true;\n        for (Iterator itr = r.iterator(); itr.hasNext();) {\n            String token = (String) itr.next();\n            if (!first)     buf.append('/');\n            else            first = false;\n            buf.append(token);\n        }\n        // translation: if (path.endsWith(\"/\") && !buf.endsWith(\"/\"))\n        if (path.endsWith(\"/\") && (buf.length()==0 || buf.charAt(buf.length()-1)!='/'))\n            buf.append('/');\n        return buf.toString();\n    }\n\n}\n", "/*\n * Copyright 2003-2006 Rick Knowles <winstone-devel at lists sourceforge net>\n * Distributed under the terms of either:\n * - the common development and distribution license (CDDL), v1.0; or\n * - the GNU Lesser General Public License, v2.1 or later\n */\npackage winstone;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TimeZone;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Response for servlet\n * \n * @author <a href=\"mailto:rick_knowles@hotmail.com\">Rick Knowles</a>\n * @version $Id: WinstoneResponse.java,v 1.28 2005/04/19 07:33:41 rickknowles\n *          Exp $\n */\npublic class WinstoneResponse implements HttpServletResponse {\n    private static final DateFormat HTTP_DF = new SimpleDateFormat(\n            \"EEE, dd MMM yyyy HH:mm:ss z\", Locale.US);\n    private static final DateFormat VERSION0_DF = new SimpleDateFormat(\n            \"EEE, dd-MMM-yy HH:mm:ss z\", Locale.US);\n    static {\n        HTTP_DF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n        VERSION0_DF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n\n    static final String CONTENT_LENGTH_HEADER = \"Content-Length\";\n    static final String CONTENT_TYPE_HEADER = \"Content-Type\";\n\n    // Response header constants\n    private static final String CONTENT_LANGUAGE_HEADER = \"Content-Language\";\n    private static final String KEEP_ALIVE_HEADER = \"Connection\";\n    private static final String KEEP_ALIVE_OPEN = \"Keep-Alive\";\n    private static final String KEEP_ALIVE_CLOSE = \"Close\";\n    private static final String DATE_HEADER = \"Date\";\n    private static final String LOCATION_HEADER = \"Location\";\n    private static final String OUT_COOKIE_HEADER1 = \"Set-Cookie\";\n    private static final String X_POWERED_BY_HEADER = \"X-Powered-By\";\n    private static final String X_POWERED_BY_HEADER_VALUE = Launcher.RESOURCES.getString(\"PoweredByHeader\");\n\n    private int statusCode;\n    private WinstoneRequest req;\n    private WebAppConfiguration webAppConfig;\n    private WinstoneOutputStream outputStream;\n    private PrintWriter outputWriter;\n    \n    private List headers;\n    private String explicitEncoding;\n    private String implicitEncoding;\n    private List cookies;\n    \n    private Locale locale;\n    private String protocol;\n    private String reqKeepAliveHeader;\n    private Integer errorStatusCode;\n    \n    /**\n     * Constructor\n     */\n    public WinstoneResponse() {\n        \n        this.headers = new ArrayList();\n        this.cookies = new ArrayList();\n\n        this.statusCode = SC_OK;\n        this.locale = null; //Locale.getDefault();\n        this.explicitEncoding = null;\n        this.protocol = null;\n        this.reqKeepAliveHeader = null;\n    }\n\n    /**\n     * Resets the request to be reused\n     */\n    public void cleanUp() {\n        this.req = null;\n        this.webAppConfig = null;\n        this.outputStream = null;\n        this.outputWriter = null;\n        this.headers.clear();\n        this.cookies.clear();\n        this.protocol = null;\n        this.reqKeepAliveHeader = null;\n\n        this.statusCode = SC_OK;\n        this.errorStatusCode = null;\n        this.locale = null; //Locale.getDefault();\n        this.explicitEncoding = null;\n        this.implicitEncoding = null;\n    }\n\n    private String getEncodingFromLocale(Locale loc) {\n        String localeString = loc.getLanguage() + \"_\" + loc.getCountry();\n        Map encMap = this.webAppConfig.getLocaleEncodingMap();\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                \"WinstoneResponse.LookForLocaleEncoding\",\n                new String[] {localeString, encMap + \"\"});\n\n        String fullMatch = (String) encMap.get(localeString);\n        if (fullMatch != null) {\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                    \"WinstoneResponse.FoundLocaleEncoding\", fullMatch);\n            return fullMatch;\n        } else {\n            localeString = loc.getLanguage();\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                    \"WinstoneResponse.LookForLocaleEncoding\",\n                    new String[] {localeString, encMap + \"\"});\n            String match = (String) encMap.get(localeString);\n            if (match != null) {\n                Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                        \"WinstoneResponse.FoundLocaleEncoding\", match);\n            }\n            return match;\n        }\n    }\n\n    public void setErrorStatusCode(int statusCode) {\n        this.errorStatusCode = new Integer(statusCode);\n        this.statusCode = statusCode;\n    }\n    \n    public WinstoneOutputStream getWinstoneOutputStream() {\n        return this.outputStream;\n    }\n    \n    public void setOutputStream(WinstoneOutputStream outData) {\n        this.outputStream = outData;\n    }\n\n    public void setWebAppConfig(WebAppConfiguration webAppConfig) {\n        this.webAppConfig = webAppConfig;\n    }\n\n    public String getProtocol() {\n        return this.protocol;\n    }\n\n    public void setProtocol(String protocol) {\n        this.protocol = protocol;\n    }\n\n    public void extractRequestKeepAliveHeader(WinstoneRequest req) {\n        this.reqKeepAliveHeader = req.getHeader(KEEP_ALIVE_HEADER);\n    }\n\n    public List getHeaders() {\n        return this.headers;\n    }\n\n    public List getCookies() {\n        return this.cookies;\n    }\n\n    public WinstoneRequest getRequest() {\n        return this.req;\n    }\n\n    public void setRequest(WinstoneRequest req) {\n        this.req = req;\n    }\n    \n    public void startIncludeBuffer() {\n        this.outputStream.startIncludeBuffer();\n    }\n    \n    public void finishIncludeBuffer() throws IOException {\n        if (isIncluding()) {\n            if (this.outputWriter != null) {\n                this.outputWriter.flush();\n            }\n            this.outputStream.finishIncludeBuffer();\n        }\n    }\n    \n    public void clearIncludeStackForForward() throws IOException {\n        this.outputStream.clearIncludeStackForForward();\n    }\n\n    protected static String getCharsetFromContentTypeHeader(String type, StringBuffer remainder) {\n        if (type == null) {\n            return null;\n        }\n        // Parse type to set encoding if needed\n        StringTokenizer st = new StringTokenizer(type, \";\");\n        String localEncoding = null;\n        while (st.hasMoreTokens()) {\n            String clause = st.nextToken().trim();\n            if (clause.startsWith(\"charset=\"))\n                localEncoding = clause.substring(8);\n            else {\n                if (remainder.length() > 0) {\n                    remainder.append(\";\");\n                }\n                remainder.append(clause);\n            }\n        }\n        if ((localEncoding == null) || \n                !localEncoding.startsWith(\"\\\"\") || \n                !localEncoding.endsWith(\"\\\"\")) {\n            return localEncoding;\n        } else {\n            return localEncoding.substring(1, localEncoding.length() - 1);\n        }\n    } \n\n    /**\n     * This ensures the bare minimum correct http headers are present\n     */\n    public void validateHeaders() {        \n        // Need this block for WebDAV support. \"Connection:close\" header is ignored\n        String lengthHeader = getHeader(CONTENT_LENGTH_HEADER);\n        if ((lengthHeader == null) && (this.statusCode >= 300)) {\n            int bodyBytes = this.outputStream.getOutputStreamLength();\n            if (getBufferSize() > bodyBytes) {\n                Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                        \"WinstoneResponse.ForcingContentLength\", \"\" + bodyBytes);\n                forceHeader(CONTENT_LENGTH_HEADER, \"\" + bodyBytes);\n                lengthHeader = getHeader(CONTENT_LENGTH_HEADER);\n            }\n        }\n        \n        forceHeader(KEEP_ALIVE_HEADER, !closeAfterRequest() ? KEEP_ALIVE_OPEN : KEEP_ALIVE_CLOSE);\n        String contentType = getHeader(CONTENT_TYPE_HEADER);\n        if (this.statusCode != SC_MOVED_TEMPORARILY) {\n            if (contentType == null) {\n                // Bypass normal encoding\n                forceHeader(CONTENT_TYPE_HEADER, \"text/html;charset=\" + getCharacterEncoding());\n            } else if (contentType.startsWith(\"text/\")) {\n                // replace charset in content\n                StringBuffer remainder = new StringBuffer();\n                getCharsetFromContentTypeHeader(contentType, remainder);\n                forceHeader(CONTENT_TYPE_HEADER, remainder.toString() + \";charset=\" + getCharacterEncoding());\n            }\n        }\n        if (getHeader(DATE_HEADER) == null) {\n            forceHeader(DATE_HEADER, formatHeaderDate(new Date()));\n        }\n        if (getHeader(X_POWERED_BY_HEADER) == null) {\n            forceHeader(X_POWERED_BY_HEADER, X_POWERED_BY_HEADER_VALUE);\n        }\n        if (this.locale != null) {\n            String lang = this.locale.getLanguage();\n            if ((this.locale.getCountry() != null) && !this.locale.getCountry().equals(\"\")) {\n                lang = lang + \"-\" + this.locale.getCountry();\n            }\n            forceHeader(CONTENT_LANGUAGE_HEADER, lang);\n        }\n        \n        // If we don't have a webappConfig, exit here, cause we definitely don't\n        // have a session\n        if (req.getWebAppConfig() == null) {\n            return;\n        }\n        // Write out the new session cookie if it's present\n        HostConfiguration hostConfig = req.getHostGroup().getHostByName(req.getServerName());\n        for (Iterator i = req.getCurrentSessionIds().keySet().iterator(); i.hasNext(); ) {\n            String prefix = (String) i.next();\n            String sessionId = (String) req.getCurrentSessionIds().get(prefix);\n            WebAppConfiguration ownerContext = hostConfig.getWebAppByURI(prefix);\n            if (ownerContext != null) {\n                WinstoneSession session = ownerContext.getSessionById(sessionId, true);\n                if ((session != null) && session.isNew()) {\n                    session.setIsNew(false);\n                    Cookie cookie = new Cookie(WinstoneSession.SESSION_COOKIE_NAME, session.getId());\n                    cookie.setMaxAge(-1);\n                    cookie.setSecure(req.isSecure());\n                    cookie.setVersion(0); //req.isSecure() ? 1 : 0);\n                    cookie.setPath(req.getWebAppConfig().getContextPath().equals(\"\") ? \"/\"\n                                    : req.getWebAppConfig().getContextPath());\n                    this.cookies.add(cookie); // don't call addCookie because we might be including\n                }\n            }\n        }\n        \n        // Look for expired sessions: ie ones where the requested and current ids are different\n        for (Iterator i = req.getRequestedSessionIds().keySet().iterator(); i.hasNext(); ) {\n            String prefix = (String) i.next();\n            String sessionId = (String) req.getRequestedSessionIds().get(prefix);\n            if (!req.getCurrentSessionIds().containsKey(prefix)) {\n                Cookie cookie = new Cookie(WinstoneSession.SESSION_COOKIE_NAME, sessionId);\n                cookie.setMaxAge(0); // explicitly expire this cookie\n                cookie.setSecure(req.isSecure());\n                cookie.setVersion(0); //req.isSecure() ? 1 : 0);\n                cookie.setPath(prefix.equals(\"\") ? \"/\" : prefix);\n                this.cookies.add(cookie); // don't call addCookie because we might be including\n            }\n        }\n        \n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeadersPreCommit\",\n                this.headers + \"\");\n    }\n\n    /**\n     * Writes out the http header for a single cookie\n     */\n    public String writeCookie(Cookie cookie) throws IOException {\n        \n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.WritingCookie\", cookie + \"\");\n        StringBuffer out = new StringBuffer();\n\n        // Set-Cookie or Set-Cookie2\n        if (cookie.getVersion() >= 1)\n            out.append(OUT_COOKIE_HEADER1).append(\": \"); // TCK doesn't like set-cookie2\n        else\n            out.append(OUT_COOKIE_HEADER1).append(\": \");\n\n        // name/value pair\n        if (cookie.getVersion() == 0)\n            out.append(cookie.getName()).append(\"=\").append(cookie.getValue());\n        else {\n            out.append(cookie.getName()).append(\"=\");\n            quote(cookie.getValue(), out);\n        }\n\n        if (cookie.getVersion() >= 1) {\n            out.append(\"; Version=1\");\n            if (cookie.getDomain() != null) {\n                out.append(\"; Domain=\");\n                quote(cookie.getDomain(), out);\n            }\n            if (cookie.getSecure())\n                out.append(\"; Secure\");\n\n            if (cookie.getMaxAge() >= 0)\n                out.append(\"; Max-Age=\").append(cookie.getMaxAge());\n            else\n                out.append(\"; Discard\");\n            if (cookie.getPath() != null) {\n                out.append(\"; Path=\");\n                quote(cookie.getPath(), out);\n            }\n        } else {\n            if (cookie.getDomain() != null) {\n                out.append(\"; Domain=\");\n                out.append(cookie.getDomain());\n            }\n            if (cookie.getMaxAge() > 0) {\n                long expiryMS = System.currentTimeMillis()\n                        + (1000 * (long) cookie.getMaxAge());\n                String expiryDate = null;\n                synchronized (VERSION0_DF) {\n                    expiryDate = VERSION0_DF.format(new Date(expiryMS));\n                }\n                out.append(\"; Expires=\").append(expiryDate);\n            } else if (cookie.getMaxAge() == 0) {\n                String expiryDate = null;\n                synchronized (VERSION0_DF) {\n                    expiryDate = VERSION0_DF.format(new Date(5000));\n                }\n                out.append(\"; Expires=\").append(expiryDate);\n            }\n            if (cookie.getPath() != null)\n                out.append(\"; Path=\").append(cookie.getPath());\n            if (cookie.getSecure())\n                out.append(\"; Secure\");\n        }\n        return out.toString();\n    }\n\n    private static String formatHeaderDate(Date dateIn) {\n        String date = null;\n        synchronized (HTTP_DF) {\n            date = HTTP_DF.format(dateIn);\n        }\n        return date;\n    }\n    \n    /**\n     * Quotes the necessary strings in a cookie header. The quoting is only\n     * applied if the string contains special characters.\n     */\n    protected static void quote(String value, StringBuffer out) {\n        if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n            out.append(value);\n        } else {\n            boolean containsSpecial = false;\n            for (int n = 0; n < value.length(); n++) {\n                char thisChar = value.charAt(n);\n                if ((thisChar < 32) || (thisChar >= 127)\n                        || (specialCharacters.indexOf(thisChar) != -1)) {\n                    containsSpecial = true;\n                    break;\n                }\n            }\n            if (containsSpecial)\n                out.append('\"').append(value).append('\"');\n            else\n                out.append(value);\n        }\n    }\n\n    private static final String specialCharacters = \"()<>@,;:\\\\\\\"/[]?={} \\t\";\n\n    /**\n     * Based on request/response headers and the protocol, determine whether or\n     * not this connection should operate in keep-alive mode.\n     */\n    public boolean closeAfterRequest() {\n        String inKeepAliveHeader = this.reqKeepAliveHeader;\n        String outKeepAliveHeader = getHeader(KEEP_ALIVE_HEADER);\n        boolean hasContentLength = (getHeader(CONTENT_LENGTH_HEADER) != null);\n        if (this.protocol.startsWith(\"HTTP/0\"))\n            return true;\n        else if ((inKeepAliveHeader == null) && (outKeepAliveHeader == null))\n            return this.protocol.equals(\"HTTP/1.0\") ? true : !hasContentLength;\n        else if (outKeepAliveHeader != null)\n            return outKeepAliveHeader.equalsIgnoreCase(KEEP_ALIVE_CLOSE) || !hasContentLength;\n        else if (inKeepAliveHeader != null)\n            return inKeepAliveHeader.equalsIgnoreCase(KEEP_ALIVE_CLOSE) || !hasContentLength;\n        else\n            return false;\n    }\n    \n    // ServletResponse interface methods\n    public void flushBuffer() throws IOException {\n        if (this.outputWriter != null) {\n            this.outputWriter.flush();\n        }\n        try {\n            this.outputStream.flush();\n        } catch (ClientSocketException e) {\n            // ignore this error as it's not interesting enough to log\n        }\n    }\n\n    public void setBufferSize(int size) {\n        this.outputStream.setBufferSize(size);\n    }\n\n    public int getBufferSize() {\n        return this.outputStream.getBufferSize();\n    }\n\n    public String getCharacterEncoding() {\n        String enc = getCurrentEncoding();\n        return (enc == null ? \"ISO-8859-1\" : enc);\n    }\n\n    public void setCharacterEncoding(String encoding) {\n        if ((this.outputWriter == null) && !isCommitted()) {\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.SettingEncoding\", encoding);\n            this.explicitEncoding = encoding;\n            correctContentTypeHeaderEncoding(encoding);\n        }\n    }\n\n    private void correctContentTypeHeaderEncoding(String encoding) {\n        String contentType = getContentType();\n        if (contentType != null) {\n            StringBuffer remainderHeader = new StringBuffer();\n            getCharsetFromContentTypeHeader(contentType, remainderHeader);\n            if (remainderHeader.length() != 0) {\n                forceHeader(CONTENT_TYPE_HEADER, remainderHeader + \";charset=\" + encoding);\n            }\n        }\n    }\n    \n    public String getContentType() {\n        return getHeader(CONTENT_TYPE_HEADER);\n    }\n\n    public void setContentType(String type) {\n        setHeader(CONTENT_TYPE_HEADER, type);\n    }\n\n    public Locale getLocale() {\n        return this.locale == null ? Locale.getDefault() : this.locale;\n    }\n\n    private boolean isIncluding() {\n        return this.outputStream.isIncluding();\n    }\n    \n    public void setLocale(Locale loc) {\n        if (isIncluding()) {\n            return;\n        } else if (isCommitted()) {\n            Logger.log(Logger.WARNING, Launcher.RESOURCES,\n                    \"WinstoneResponse.SetLocaleTooLate\");\n        } else {\n            if ((this.outputWriter == null) && (this.explicitEncoding == null)) {\n                String localeEncoding = getEncodingFromLocale(loc);\n                if (localeEncoding != null) {\n                    this.implicitEncoding = localeEncoding;\n                    correctContentTypeHeaderEncoding(localeEncoding);\n                }\n            }\n            this.locale = loc;\n        }\n    }\n\n    public ServletOutputStream getOutputStream() throws IOException {\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.GetOutputStream\");\n        return this.outputStream;\n    }\n\n    public PrintWriter getWriter() throws IOException {\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.GetWriter\");\n        if (this.outputWriter != null)\n            return this.outputWriter;\n        else {\n            this.outputWriter = new WinstoneResponseWriter(this.outputStream, this);\n            return this.outputWriter;\n        }\n    }\n\n    public boolean isCommitted() {\n        return this.outputStream.isCommitted();\n    }\n\n    public void reset() {\n        if (!isIncluding()) {\n            resetBuffer();\n            this.statusCode = SC_OK;\n            this.headers.clear();\n            this.cookies.clear();\n        }\n    }\n\n    public void resetBuffer() {\n        if (!isIncluding()) {\n            if (isCommitted())\n                throw new IllegalStateException(Launcher.RESOURCES\n                        .getString(\"WinstoneResponse.ResponseCommitted\"));\n            \n            // Disregard any output temporarily while we flush\n            this.outputStream.setDisregardMode(true);\n            \n            if (this.outputWriter != null) {\n                this.outputWriter.flush();\n            }\n            \n            this.outputStream.setDisregardMode(false);\n            this.outputStream.reset();\n        }\n    }\n\n    public void setContentLength(int len) {\n        setIntHeader(CONTENT_LENGTH_HEADER, len);\n    }\n\n    // HttpServletResponse interface methods\n    public void addCookie(Cookie cookie) {\n        if (!isIncluding()) {\n            this.cookies.add(cookie);\n        }\n    }\n\n    public boolean containsHeader(String name) {\n        for (int n = 0; n < this.headers.size(); n++)\n            if (((String) this.headers.get(n)).startsWith(name))\n                return true;\n        return false;\n    }\n\n    public void addDateHeader(String name, long date) {\n        addHeader(name, formatHeaderDate(new Date(date)));\n    } // df.format(new Date(date)));}\n\n    public void addIntHeader(String name, int value) {\n        addHeader(name, \"\" + value);\n    }\n\n    public void addHeader(String name, String value) {\n        if (isIncluding()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderInInclude\", \n                    new String[] {name, value});  \n        } else if (isCommitted()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderAfterCommitted\", \n                    new String[] {name, value});  \n        } else if (value != null) {\n            if (name.equals(CONTENT_TYPE_HEADER)) {\n                StringBuffer remainderHeader = new StringBuffer();\n                String headerEncoding = getCharsetFromContentTypeHeader(value, remainderHeader);\n                if (this.outputWriter != null) {\n                    value = remainderHeader + \";charset=\" + getCharacterEncoding();\n                } else if (headerEncoding != null) {\n                    this.explicitEncoding = headerEncoding;\n                }\n            }\n            this.headers.add(name + \": \" + value);\n        }\n    }\n\n    public void setDateHeader(String name, long date) {\n        setHeader(name, formatHeaderDate(new Date(date)));\n    }\n\n    public void setIntHeader(String name, int value) {\n        setHeader(name, \"\" + value);\n    }\n\n    public void setHeader(String name, String value) {\n        if (isIncluding()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderInInclude\", \n                    new String[] {name, value});  \n        } else if (isCommitted()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderAfterCommitted\", \n                    new String[] {name, value});\n        } else {\n            boolean found = false;\n            for (int n = 0; (n < this.headers.size()); n++) {\n                String header = (String) this.headers.get(n);\n                if (header.startsWith(name + \": \")) {\n                    if (found) {\n                        this.headers.remove(n);\n                        continue;\n                    }\n                    if (name.equals(CONTENT_TYPE_HEADER)) {\n                        if (value != null) {\n                            StringBuffer remainderHeader = new StringBuffer();\n                            String headerEncoding = getCharsetFromContentTypeHeader(\n                                    value, remainderHeader);\n                            if (this.outputWriter != null) {\n                                value = remainderHeader + \";charset=\" + getCharacterEncoding();\n                            } else if (headerEncoding != null) {\n                                this.explicitEncoding = headerEncoding;\n                            }\n                        }\n                    }\n\n                    if (value != null) {\n                        this.headers.set(n, name + \": \" + value);\n                    } else {\n                        this.headers.remove(n);\n                    }\n                    found = true;\n                }\n            }\n            if (!found) {\n                addHeader(name, value);\n            }\n        }\n    }\n\n    private void forceHeader(String name, String value) {\n        boolean found = false;\n        for (int n = 0; (n < this.headers.size()); n++) {\n            String header = (String) this.headers.get(n);\n            if (header.startsWith(name + \": \")) {\n                found = true;\n                this.headers.set(n, name + \": \" + value);\n            }\n        }\n        if (!found) {\n            this.headers.add(name + \": \" + value);\n        }\n    }\n    \n    private String getCurrentEncoding() {\n        if (this.explicitEncoding != null) {\n            return this.explicitEncoding;\n        } else if (this.implicitEncoding != null) {\n            return this.implicitEncoding;\n        } else if ((this.req != null) && (this.req.getCharacterEncoding() != null)) {\n            try {\n                \"0\".getBytes(this.req.getCharacterEncoding());\n                return this.req.getCharacterEncoding();\n            } catch (UnsupportedEncodingException err) {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    \n    public String getHeader(String name) {\n        for (int n = 0; n < this.headers.size(); n++) {\n            String header = (String) this.headers.get(n);\n            if (header.startsWith(name + \": \"))\n                return header.substring(name.length() + 2);\n        }\n        return null;\n    }\n\n    public String encodeRedirectURL(String url) {\n        return url;\n    }\n\n    public String encodeURL(String url) {\n        return url;\n    }\n\n    public int getStatus() {\n        return this.statusCode;\n    }\n\n    public Integer getErrorStatusCode() {\n        return this.errorStatusCode;\n    }\n\n    public void setStatus(int sc) {\n        if (!isIncluding() && (this.errorStatusCode == null)) {\n//        if (!isIncluding()) {\n            this.statusCode = sc;\n//            if (this.errorStatusCode != null) {\n//                this.errorStatusCode = new Integer(sc);\n//            }\n        }\n    }\n\n    public void sendRedirect(String location) throws IOException {\n        if (isIncluding()) {\n            Logger.log(Logger.ERROR, Launcher.RESOURCES, \"IncludeResponse.Redirect\",\n                    location);\n            return;\n        } else if (isCommitted()) {\n            throw new IllegalStateException(Launcher.RESOURCES.getString(\"WinstoneOutputStream.AlreadyCommitted\"));\n        }\n        resetBuffer();\n        \n        // Build location\n        StringBuffer fullLocation = new StringBuffer();\n        if (location.startsWith(\"http://\") || location.startsWith(\"https://\")) {\n            fullLocation.append(location);\n        } else {\n            if (location.trim().equals(\".\")) {\n                location = \"\";\n            }\n            \n            fullLocation.append(this.req.getScheme()).append(\"://\");\n            fullLocation.append(this.req.getServerName());\n            if (!((this.req.getServerPort() == 80) && this.req.getScheme().equals(\"http\"))\n                    && !((this.req.getServerPort() == 443) && this.req.getScheme().equals(\"https\")))\n                fullLocation.append(':').append(this.req.getServerPort());\n            if (location.startsWith(\"/\")) {\n                fullLocation.append(location);\n            } else {\n                fullLocation.append(this.req.getRequestURI());\n                int questionPos = fullLocation.toString().indexOf(\"?\"); \n                if (questionPos != -1) {\n                    fullLocation.delete(questionPos, fullLocation.length());\n                }\n                fullLocation.delete(\n                        fullLocation.toString().lastIndexOf(\"/\") + 1,\n                        fullLocation.length());\n                fullLocation.append(location);\n            }\n        }\n        if (this.req != null) {\n            this.req.discardRequestBody();\n        }\n        this.statusCode = HttpServletResponse.SC_MOVED_TEMPORARILY;\n        setHeader(LOCATION_HEADER, fullLocation.toString());\n        setContentLength(0);\n        getWriter().flush();\n    }\n\n    public void sendError(int sc) throws IOException {\n        sendError(sc, null);\n    }\n\n    public void sendError(int sc, String msg) throws IOException {\n        if (isIncluding()) {\n            Logger.log(Logger.ERROR, Launcher.RESOURCES, \"IncludeResponse.Error\",\n                    new String[] { \"\" + sc, msg });\n            return;\n        }\n        \n        Logger.log(Logger.DEBUG, Launcher.RESOURCES,\n                \"WinstoneResponse.SendingError\", new String[] { \"\" + sc, msg });\n\n        if ((this.webAppConfig != null) && (this.req != null)) {\n            \n            RequestDispatcher rd = this.webAppConfig\n                    .getErrorDispatcherByCode(req.getRequestURI(), sc, msg, null);\n            if (rd != null) {\n                try {\n                    rd.forward(this.req, this);\n                    return;\n                } catch (IllegalStateException err) {\n                    throw err;\n                } catch (IOException err) {\n                    throw err;\n                } catch (Throwable err) {\n                    Logger.log(Logger.WARNING, Launcher.RESOURCES,\n                            \"WinstoneResponse.ErrorInErrorPage\", new String[] {\n                                    rd.getName(), sc + \"\" }, err);\n                    return;\n                }\n            }\n        }\n        // If we are here there was no webapp and/or no request object, so \n        // show the default error page\n        if (this.errorStatusCode == null) {\n            this.statusCode = sc;\n        }\n        String output = Launcher.RESOURCES.getString(\"WinstoneResponse.ErrorPage\",\n                new String[] { sc + \"\", (msg == null ? \"\" : msg), \"\",\n                        Launcher.RESOURCES.getString(\"ServerVersion\"),\n                        \"\" + new Date() });\n        setContentLength(output.getBytes(getCharacterEncoding()).length);\n        Writer out = getWriter();\n        out.write(output);\n        out.flush();\n    }\n\n    /**\n     * @deprecated\n     */\n    public String encodeRedirectUrl(String url) {\n        return encodeRedirectURL(url);\n    }\n\n    /**\n     * @deprecated\n     */\n    public String encodeUrl(String url) {\n        return encodeURL(url);\n    }\n\n    /**\n     * @deprecated\n     */\n    public void setStatus(int sc, String sm) {\n        setStatus(sc);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2003-2006 Rick Knowles <winstone-devel at lists sourceforge net>\n * Distributed under the terms of either:\n * - the common development and distribution license (CDDL), v1.0; or\n * - the GNU Lesser General Public License, v2.1 or later\n */\npackage winstone;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Date;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServlet;\n\n/**\n * A simple servlet that writes out the body of the error \n * \n * @author <a href=\"mailto:rick_knowles@hotmail.com\">Rick Knowles</a>\n * @version $Id: ErrorServlet.java,v 1.3 2006/02/28 07:32:47 rickknowles Exp $\n */\npublic class ErrorServlet extends HttpServlet {\n    \n    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {\n        \n        Integer sc = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);\n        String msg = (String) request.getAttribute(RequestDispatcher.ERROR_MESSAGE);\n        Throwable err = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);\n        \n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        if (err != null) {\n            err.printStackTrace(pw);\n        } else {\n            pw.println(\"(none)\");\n        }\n        pw.flush();\n         \n        // If we are here there was no error servlet, so show the default error page\n        String output = Launcher.RESOURCES.getString(\"WinstoneResponse.ErrorPage\",\n                new String[] { sc + \"\", URIUtil.htmlEscape(msg == null ? \"\" : msg), URIUtil.htmlEscape(sw.toString()),\n                Launcher.RESOURCES.getString(\"ServerVersion\"),\n                        \"\" + new Date() });\n        response.setContentLength(output.getBytes(response.getCharacterEncoding()).length);\n        Writer out = response.getWriter();\n        out.write(output);\n        out.flush();\n    }\n}\n", "package winstone;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class URIUtil {\n    /**\n     * Eliminates \".\" and \"..\" in the path.\n     * So that this method can be used for any string that looks like an URI,\n     * this method preserves the leading and trailing '/'.\n     */\n    static String canonicalPath(String path) {\n        List r = new ArrayList(Arrays.asList(path.split(\"/+\")));\n        for (int i=0; i<r.size(); ) {\n            String cur = (String)r.get(i);\n            if (cur.length()==0 || cur.equals(\".\")) {\n                // empty token occurs for example, \"\".split(\"/+\") is [\"\"]\n                r.remove(i);\n            } else\n            if (cur.equals(\"..\")) {\n                // i==0 means this is a broken URI.\n                r.remove(i);\n                if (i>0) {\n                    r.remove(i-1);\n                    i--;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        StringBuilder buf = new StringBuilder();\n        if (path.startsWith(\"/\"))\n            buf.append('/');\n        boolean first = true;\n        for (Iterator itr = r.iterator(); itr.hasNext();) {\n            String token = (String) itr.next();\n            if (!first)     buf.append('/');\n            else            first = false;\n            buf.append(token);\n        }\n        // translation: if (path.endsWith(\"/\") && !buf.endsWith(\"/\"))\n        if (path.endsWith(\"/\") && (buf.length()==0 || buf.charAt(buf.length()-1)!='/'))\n            buf.append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Performs necessary escaping to render arbitrary plain text as plain text without any markup.\n     */\n    public static String htmlEscape(String text) {\n        StringBuilder buf = new StringBuilder(text.length()+64);\n        for( int i=0; i<text.length(); i++ ) {\n            char ch = text.charAt(i);\n            if(ch=='<')\n                buf.append(\"&lt;\");\n            else\n            if(ch=='&')\n                buf.append(\"&amp;\");\n            else\n                buf.append(ch);\n        }\n        return buf.toString();\n    }\n}\n", "/*\n * Copyright 2003-2006 Rick Knowles <winstone-devel at lists sourceforge net>\n * Distributed under the terms of either:\n * - the common development and distribution license (CDDL), v1.0; or\n * - the GNU Lesser General Public License, v2.1 or later\n */\npackage winstone;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TimeZone;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Response for servlet\n * \n * @author <a href=\"mailto:rick_knowles@hotmail.com\">Rick Knowles</a>\n * @version $Id: WinstoneResponse.java,v 1.28 2005/04/19 07:33:41 rickknowles\n *          Exp $\n */\npublic class WinstoneResponse implements HttpServletResponse {\n    private static final DateFormat HTTP_DF = new SimpleDateFormat(\n            \"EEE, dd MMM yyyy HH:mm:ss z\", Locale.US);\n    private static final DateFormat VERSION0_DF = new SimpleDateFormat(\n            \"EEE, dd-MMM-yy HH:mm:ss z\", Locale.US);\n    static {\n        HTTP_DF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n        VERSION0_DF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n\n    static final String CONTENT_LENGTH_HEADER = \"Content-Length\";\n    static final String CONTENT_TYPE_HEADER = \"Content-Type\";\n\n    // Response header constants\n    private static final String CONTENT_LANGUAGE_HEADER = \"Content-Language\";\n    private static final String KEEP_ALIVE_HEADER = \"Connection\";\n    private static final String KEEP_ALIVE_OPEN = \"Keep-Alive\";\n    private static final String KEEP_ALIVE_CLOSE = \"Close\";\n    private static final String DATE_HEADER = \"Date\";\n    private static final String LOCATION_HEADER = \"Location\";\n    private static final String OUT_COOKIE_HEADER1 = \"Set-Cookie\";\n    private static final String X_POWERED_BY_HEADER = \"X-Powered-By\";\n    private static final String X_POWERED_BY_HEADER_VALUE = Launcher.RESOURCES.getString(\"PoweredByHeader\");\n\n    private int statusCode;\n    private WinstoneRequest req;\n    private WebAppConfiguration webAppConfig;\n    private WinstoneOutputStream outputStream;\n    private PrintWriter outputWriter;\n    \n    private List headers;\n    private String explicitEncoding;\n    private String implicitEncoding;\n    private List cookies;\n    \n    private Locale locale;\n    private String protocol;\n    private String reqKeepAliveHeader;\n    private Integer errorStatusCode;\n    \n    /**\n     * Constructor\n     */\n    public WinstoneResponse() {\n        \n        this.headers = new ArrayList();\n        this.cookies = new ArrayList();\n\n        this.statusCode = SC_OK;\n        this.locale = null; //Locale.getDefault();\n        this.explicitEncoding = null;\n        this.protocol = null;\n        this.reqKeepAliveHeader = null;\n    }\n\n    /**\n     * Resets the request to be reused\n     */\n    public void cleanUp() {\n        this.req = null;\n        this.webAppConfig = null;\n        this.outputStream = null;\n        this.outputWriter = null;\n        this.headers.clear();\n        this.cookies.clear();\n        this.protocol = null;\n        this.reqKeepAliveHeader = null;\n\n        this.statusCode = SC_OK;\n        this.errorStatusCode = null;\n        this.locale = null; //Locale.getDefault();\n        this.explicitEncoding = null;\n        this.implicitEncoding = null;\n    }\n\n    private String getEncodingFromLocale(Locale loc) {\n        String localeString = loc.getLanguage() + \"_\" + loc.getCountry();\n        Map encMap = this.webAppConfig.getLocaleEncodingMap();\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                \"WinstoneResponse.LookForLocaleEncoding\",\n                new String[] {localeString, encMap + \"\"});\n\n        String fullMatch = (String) encMap.get(localeString);\n        if (fullMatch != null) {\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                    \"WinstoneResponse.FoundLocaleEncoding\", fullMatch);\n            return fullMatch;\n        } else {\n            localeString = loc.getLanguage();\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                    \"WinstoneResponse.LookForLocaleEncoding\",\n                    new String[] {localeString, encMap + \"\"});\n            String match = (String) encMap.get(localeString);\n            if (match != null) {\n                Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                        \"WinstoneResponse.FoundLocaleEncoding\", match);\n            }\n            return match;\n        }\n    }\n\n    public void setErrorStatusCode(int statusCode) {\n        this.errorStatusCode = new Integer(statusCode);\n        this.statusCode = statusCode;\n    }\n    \n    public WinstoneOutputStream getWinstoneOutputStream() {\n        return this.outputStream;\n    }\n    \n    public void setOutputStream(WinstoneOutputStream outData) {\n        this.outputStream = outData;\n    }\n\n    public void setWebAppConfig(WebAppConfiguration webAppConfig) {\n        this.webAppConfig = webAppConfig;\n    }\n\n    public String getProtocol() {\n        return this.protocol;\n    }\n\n    public void setProtocol(String protocol) {\n        this.protocol = protocol;\n    }\n\n    public void extractRequestKeepAliveHeader(WinstoneRequest req) {\n        this.reqKeepAliveHeader = req.getHeader(KEEP_ALIVE_HEADER);\n    }\n\n    public List getHeaders() {\n        return this.headers;\n    }\n\n    public List getCookies() {\n        return this.cookies;\n    }\n\n    public WinstoneRequest getRequest() {\n        return this.req;\n    }\n\n    public void setRequest(WinstoneRequest req) {\n        this.req = req;\n    }\n    \n    public void startIncludeBuffer() {\n        this.outputStream.startIncludeBuffer();\n    }\n    \n    public void finishIncludeBuffer() throws IOException {\n        if (isIncluding()) {\n            if (this.outputWriter != null) {\n                this.outputWriter.flush();\n            }\n            this.outputStream.finishIncludeBuffer();\n        }\n    }\n    \n    public void clearIncludeStackForForward() throws IOException {\n        this.outputStream.clearIncludeStackForForward();\n    }\n\n    protected static String getCharsetFromContentTypeHeader(String type, StringBuffer remainder) {\n        if (type == null) {\n            return null;\n        }\n        // Parse type to set encoding if needed\n        StringTokenizer st = new StringTokenizer(type, \";\");\n        String localEncoding = null;\n        while (st.hasMoreTokens()) {\n            String clause = st.nextToken().trim();\n            if (clause.startsWith(\"charset=\"))\n                localEncoding = clause.substring(8);\n            else {\n                if (remainder.length() > 0) {\n                    remainder.append(\";\");\n                }\n                remainder.append(clause);\n            }\n        }\n        if ((localEncoding == null) || \n                !localEncoding.startsWith(\"\\\"\") || \n                !localEncoding.endsWith(\"\\\"\")) {\n            return localEncoding;\n        } else {\n            return localEncoding.substring(1, localEncoding.length() - 1);\n        }\n    } \n\n    /**\n     * This ensures the bare minimum correct http headers are present\n     */\n    public void validateHeaders() {        \n        // Need this block for WebDAV support. \"Connection:close\" header is ignored\n        String lengthHeader = getHeader(CONTENT_LENGTH_HEADER);\n        if ((lengthHeader == null) && (this.statusCode >= 300)) {\n            int bodyBytes = this.outputStream.getOutputStreamLength();\n            if (getBufferSize() > bodyBytes) {\n                Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \n                        \"WinstoneResponse.ForcingContentLength\", \"\" + bodyBytes);\n                forceHeader(CONTENT_LENGTH_HEADER, \"\" + bodyBytes);\n                lengthHeader = getHeader(CONTENT_LENGTH_HEADER);\n            }\n        }\n        \n        forceHeader(KEEP_ALIVE_HEADER, !closeAfterRequest() ? KEEP_ALIVE_OPEN : KEEP_ALIVE_CLOSE);\n        String contentType = getHeader(CONTENT_TYPE_HEADER);\n        if (this.statusCode != SC_MOVED_TEMPORARILY) {\n            if (contentType == null) {\n                // Bypass normal encoding\n                forceHeader(CONTENT_TYPE_HEADER, \"text/html;charset=\" + getCharacterEncoding());\n            } else if (contentType.startsWith(\"text/\")) {\n                // replace charset in content\n                StringBuffer remainder = new StringBuffer();\n                getCharsetFromContentTypeHeader(contentType, remainder);\n                forceHeader(CONTENT_TYPE_HEADER, remainder.toString() + \";charset=\" + getCharacterEncoding());\n            }\n        }\n        if (getHeader(DATE_HEADER) == null) {\n            forceHeader(DATE_HEADER, formatHeaderDate(new Date()));\n        }\n        if (getHeader(X_POWERED_BY_HEADER) == null) {\n            forceHeader(X_POWERED_BY_HEADER, X_POWERED_BY_HEADER_VALUE);\n        }\n        if (this.locale != null) {\n            String lang = this.locale.getLanguage();\n            if ((this.locale.getCountry() != null) && !this.locale.getCountry().equals(\"\")) {\n                lang = lang + \"-\" + this.locale.getCountry();\n            }\n            forceHeader(CONTENT_LANGUAGE_HEADER, lang);\n        }\n        \n        // If we don't have a webappConfig, exit here, cause we definitely don't\n        // have a session\n        if (req.getWebAppConfig() == null) {\n            return;\n        }\n        // Write out the new session cookie if it's present\n        HostConfiguration hostConfig = req.getHostGroup().getHostByName(req.getServerName());\n        for (Iterator i = req.getCurrentSessionIds().keySet().iterator(); i.hasNext(); ) {\n            String prefix = (String) i.next();\n            String sessionId = (String) req.getCurrentSessionIds().get(prefix);\n            WebAppConfiguration ownerContext = hostConfig.getWebAppByURI(prefix);\n            if (ownerContext != null) {\n                WinstoneSession session = ownerContext.getSessionById(sessionId, true);\n                if ((session != null) && session.isNew()) {\n                    session.setIsNew(false);\n                    Cookie cookie = new Cookie(WinstoneSession.SESSION_COOKIE_NAME, session.getId());\n                    cookie.setMaxAge(-1);\n                    cookie.setSecure(req.isSecure());\n                    cookie.setVersion(0); //req.isSecure() ? 1 : 0);\n                    cookie.setPath(req.getWebAppConfig().getContextPath().equals(\"\") ? \"/\"\n                                    : req.getWebAppConfig().getContextPath());\n                    this.cookies.add(cookie); // don't call addCookie because we might be including\n                }\n            }\n        }\n        \n        // Look for expired sessions: ie ones where the requested and current ids are different\n        for (Iterator i = req.getRequestedSessionIds().keySet().iterator(); i.hasNext(); ) {\n            String prefix = (String) i.next();\n            String sessionId = (String) req.getRequestedSessionIds().get(prefix);\n            if (!req.getCurrentSessionIds().containsKey(prefix)) {\n                Cookie cookie = new Cookie(WinstoneSession.SESSION_COOKIE_NAME, sessionId);\n                cookie.setMaxAge(0); // explicitly expire this cookie\n                cookie.setSecure(req.isSecure());\n                cookie.setVersion(0); //req.isSecure() ? 1 : 0);\n                cookie.setPath(prefix.equals(\"\") ? \"/\" : prefix);\n                this.cookies.add(cookie); // don't call addCookie because we might be including\n            }\n        }\n        \n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeadersPreCommit\",\n                this.headers + \"\");\n    }\n\n    /**\n     * Writes out the http header for a single cookie\n     */\n    public String writeCookie(Cookie cookie) throws IOException {\n        \n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.WritingCookie\", cookie + \"\");\n        StringBuffer out = new StringBuffer();\n\n        // Set-Cookie or Set-Cookie2\n        if (cookie.getVersion() >= 1)\n            out.append(OUT_COOKIE_HEADER1).append(\": \"); // TCK doesn't like set-cookie2\n        else\n            out.append(OUT_COOKIE_HEADER1).append(\": \");\n\n        // name/value pair\n        if (cookie.getVersion() == 0)\n            out.append(cookie.getName()).append(\"=\").append(cookie.getValue());\n        else {\n            out.append(cookie.getName()).append(\"=\");\n            quote(cookie.getValue(), out);\n        }\n\n        if (cookie.getVersion() >= 1) {\n            out.append(\"; Version=1\");\n            if (cookie.getDomain() != null) {\n                out.append(\"; Domain=\");\n                quote(cookie.getDomain(), out);\n            }\n            if (cookie.getSecure())\n                out.append(\"; Secure\");\n\n            if (cookie.getMaxAge() >= 0)\n                out.append(\"; Max-Age=\").append(cookie.getMaxAge());\n            else\n                out.append(\"; Discard\");\n            if (cookie.getPath() != null) {\n                out.append(\"; Path=\");\n                quote(cookie.getPath(), out);\n            }\n        } else {\n            if (cookie.getDomain() != null) {\n                out.append(\"; Domain=\");\n                out.append(cookie.getDomain());\n            }\n            if (cookie.getMaxAge() > 0) {\n                long expiryMS = System.currentTimeMillis()\n                        + (1000 * (long) cookie.getMaxAge());\n                String expiryDate = null;\n                synchronized (VERSION0_DF) {\n                    expiryDate = VERSION0_DF.format(new Date(expiryMS));\n                }\n                out.append(\"; Expires=\").append(expiryDate);\n            } else if (cookie.getMaxAge() == 0) {\n                String expiryDate = null;\n                synchronized (VERSION0_DF) {\n                    expiryDate = VERSION0_DF.format(new Date(5000));\n                }\n                out.append(\"; Expires=\").append(expiryDate);\n            }\n            if (cookie.getPath() != null)\n                out.append(\"; Path=\").append(cookie.getPath());\n            if (cookie.getSecure())\n                out.append(\"; Secure\");\n        }\n        return out.toString();\n    }\n\n    private static String formatHeaderDate(Date dateIn) {\n        String date = null;\n        synchronized (HTTP_DF) {\n            date = HTTP_DF.format(dateIn);\n        }\n        return date;\n    }\n    \n    /**\n     * Quotes the necessary strings in a cookie header. The quoting is only\n     * applied if the string contains special characters.\n     */\n    protected static void quote(String value, StringBuffer out) {\n        if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n            out.append(value);\n        } else {\n            boolean containsSpecial = false;\n            for (int n = 0; n < value.length(); n++) {\n                char thisChar = value.charAt(n);\n                if ((thisChar < 32) || (thisChar >= 127)\n                        || (specialCharacters.indexOf(thisChar) != -1)) {\n                    containsSpecial = true;\n                    break;\n                }\n            }\n            if (containsSpecial)\n                out.append('\"').append(value).append('\"');\n            else\n                out.append(value);\n        }\n    }\n\n    private static final String specialCharacters = \"()<>@,;:\\\\\\\"/[]?={} \\t\";\n\n    /**\n     * Based on request/response headers and the protocol, determine whether or\n     * not this connection should operate in keep-alive mode.\n     */\n    public boolean closeAfterRequest() {\n        String inKeepAliveHeader = this.reqKeepAliveHeader;\n        String outKeepAliveHeader = getHeader(KEEP_ALIVE_HEADER);\n        boolean hasContentLength = (getHeader(CONTENT_LENGTH_HEADER) != null);\n        if (this.protocol.startsWith(\"HTTP/0\"))\n            return true;\n        else if ((inKeepAliveHeader == null) && (outKeepAliveHeader == null))\n            return this.protocol.equals(\"HTTP/1.0\") ? true : !hasContentLength;\n        else if (outKeepAliveHeader != null)\n            return outKeepAliveHeader.equalsIgnoreCase(KEEP_ALIVE_CLOSE) || !hasContentLength;\n        else if (inKeepAliveHeader != null)\n            return inKeepAliveHeader.equalsIgnoreCase(KEEP_ALIVE_CLOSE) || !hasContentLength;\n        else\n            return false;\n    }\n    \n    // ServletResponse interface methods\n    public void flushBuffer() throws IOException {\n        if (this.outputWriter != null) {\n            this.outputWriter.flush();\n        }\n        try {\n            this.outputStream.flush();\n        } catch (ClientSocketException e) {\n            // ignore this error as it's not interesting enough to log\n        }\n    }\n\n    public void setBufferSize(int size) {\n        this.outputStream.setBufferSize(size);\n    }\n\n    public int getBufferSize() {\n        return this.outputStream.getBufferSize();\n    }\n\n    public String getCharacterEncoding() {\n        String enc = getCurrentEncoding();\n        return (enc == null ? \"ISO-8859-1\" : enc);\n    }\n\n    public void setCharacterEncoding(String encoding) {\n        if ((this.outputWriter == null) && !isCommitted()) {\n            Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.SettingEncoding\", encoding);\n            this.explicitEncoding = encoding;\n            correctContentTypeHeaderEncoding(encoding);\n        }\n    }\n\n    private void correctContentTypeHeaderEncoding(String encoding) {\n        String contentType = getContentType();\n        if (contentType != null) {\n            StringBuffer remainderHeader = new StringBuffer();\n            getCharsetFromContentTypeHeader(contentType, remainderHeader);\n            if (remainderHeader.length() != 0) {\n                forceHeader(CONTENT_TYPE_HEADER, remainderHeader + \";charset=\" + encoding);\n            }\n        }\n    }\n    \n    public String getContentType() {\n        return getHeader(CONTENT_TYPE_HEADER);\n    }\n\n    public void setContentType(String type) {\n        setHeader(CONTENT_TYPE_HEADER, type);\n    }\n\n    public Locale getLocale() {\n        return this.locale == null ? Locale.getDefault() : this.locale;\n    }\n\n    private boolean isIncluding() {\n        return this.outputStream.isIncluding();\n    }\n    \n    public void setLocale(Locale loc) {\n        if (isIncluding()) {\n            return;\n        } else if (isCommitted()) {\n            Logger.log(Logger.WARNING, Launcher.RESOURCES,\n                    \"WinstoneResponse.SetLocaleTooLate\");\n        } else {\n            if ((this.outputWriter == null) && (this.explicitEncoding == null)) {\n                String localeEncoding = getEncodingFromLocale(loc);\n                if (localeEncoding != null) {\n                    this.implicitEncoding = localeEncoding;\n                    correctContentTypeHeaderEncoding(localeEncoding);\n                }\n            }\n            this.locale = loc;\n        }\n    }\n\n    public ServletOutputStream getOutputStream() throws IOException {\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.GetOutputStream\");\n        return this.outputStream;\n    }\n\n    public PrintWriter getWriter() throws IOException {\n        Logger.log(Logger.FULL_DEBUG, Launcher.RESOURCES, \"WinstoneResponse.GetWriter\");\n        if (this.outputWriter != null)\n            return this.outputWriter;\n        else {\n            this.outputWriter = new WinstoneResponseWriter(this.outputStream, this);\n            return this.outputWriter;\n        }\n    }\n\n    public boolean isCommitted() {\n        return this.outputStream.isCommitted();\n    }\n\n    public void reset() {\n        if (!isIncluding()) {\n            resetBuffer();\n            this.statusCode = SC_OK;\n            this.headers.clear();\n            this.cookies.clear();\n        }\n    }\n\n    public void resetBuffer() {\n        if (!isIncluding()) {\n            if (isCommitted())\n                throw new IllegalStateException(Launcher.RESOURCES\n                        .getString(\"WinstoneResponse.ResponseCommitted\"));\n            \n            // Disregard any output temporarily while we flush\n            this.outputStream.setDisregardMode(true);\n            \n            if (this.outputWriter != null) {\n                this.outputWriter.flush();\n            }\n            \n            this.outputStream.setDisregardMode(false);\n            this.outputStream.reset();\n        }\n    }\n\n    public void setContentLength(int len) {\n        setIntHeader(CONTENT_LENGTH_HEADER, len);\n    }\n\n    // HttpServletResponse interface methods\n    public void addCookie(Cookie cookie) {\n        if (!isIncluding()) {\n            this.cookies.add(cookie);\n        }\n    }\n\n    public boolean containsHeader(String name) {\n        for (int n = 0; n < this.headers.size(); n++)\n            if (((String) this.headers.get(n)).startsWith(name))\n                return true;\n        return false;\n    }\n\n    public void addDateHeader(String name, long date) {\n        addHeader(name, formatHeaderDate(new Date(date)));\n    } // df.format(new Date(date)));}\n\n    public void addIntHeader(String name, int value) {\n        addHeader(name, \"\" + value);\n    }\n\n    public void addHeader(String name, String value) {\n        if (isIncluding()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderInInclude\", \n                    new String[] {name, value});  \n        } else if (isCommitted()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderAfterCommitted\", \n                    new String[] {name, value});  \n        } else if (value != null) {\n            if (name.equals(CONTENT_TYPE_HEADER)) {\n                StringBuffer remainderHeader = new StringBuffer();\n                String headerEncoding = getCharsetFromContentTypeHeader(value, remainderHeader);\n                if (this.outputWriter != null) {\n                    value = remainderHeader + \";charset=\" + getCharacterEncoding();\n                } else if (headerEncoding != null) {\n                    this.explicitEncoding = headerEncoding;\n                }\n            }\n            this.headers.add(name + \": \" + value);\n        }\n    }\n\n    public void setDateHeader(String name, long date) {\n        setHeader(name, formatHeaderDate(new Date(date)));\n    }\n\n    public void setIntHeader(String name, int value) {\n        setHeader(name, \"\" + value);\n    }\n\n    public void setHeader(String name, String value) {\n        if (isIncluding()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderInInclude\", \n                    new String[] {name, value});  \n        } else if (isCommitted()) {\n            Logger.log(Logger.DEBUG, Launcher.RESOURCES, \"WinstoneResponse.HeaderAfterCommitted\", \n                    new String[] {name, value});\n        } else {\n            boolean found = false;\n            for (int n = 0; (n < this.headers.size()); n++) {\n                String header = (String) this.headers.get(n);\n                if (header.startsWith(name + \": \")) {\n                    if (found) {\n                        this.headers.remove(n);\n                        continue;\n                    }\n                    if (name.equals(CONTENT_TYPE_HEADER)) {\n                        if (value != null) {\n                            StringBuffer remainderHeader = new StringBuffer();\n                            String headerEncoding = getCharsetFromContentTypeHeader(\n                                    value, remainderHeader);\n                            if (this.outputWriter != null) {\n                                value = remainderHeader + \";charset=\" + getCharacterEncoding();\n                            } else if (headerEncoding != null) {\n                                this.explicitEncoding = headerEncoding;\n                            }\n                        }\n                    }\n\n                    if (value != null) {\n                        this.headers.set(n, name + \": \" + value);\n                    } else {\n                        this.headers.remove(n);\n                    }\n                    found = true;\n                }\n            }\n            if (!found) {\n                addHeader(name, value);\n            }\n        }\n    }\n\n    private void forceHeader(String name, String value) {\n        boolean found = false;\n        for (int n = 0; (n < this.headers.size()); n++) {\n            String header = (String) this.headers.get(n);\n            if (header.startsWith(name + \": \")) {\n                found = true;\n                this.headers.set(n, name + \": \" + value);\n            }\n        }\n        if (!found) {\n            this.headers.add(name + \": \" + value);\n        }\n    }\n    \n    private String getCurrentEncoding() {\n        if (this.explicitEncoding != null) {\n            return this.explicitEncoding;\n        } else if (this.implicitEncoding != null) {\n            return this.implicitEncoding;\n        } else if ((this.req != null) && (this.req.getCharacterEncoding() != null)) {\n            try {\n                \"0\".getBytes(this.req.getCharacterEncoding());\n                return this.req.getCharacterEncoding();\n            } catch (UnsupportedEncodingException err) {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    \n    public String getHeader(String name) {\n        for (int n = 0; n < this.headers.size(); n++) {\n            String header = (String) this.headers.get(n);\n            if (header.startsWith(name + \": \"))\n                return header.substring(name.length() + 2);\n        }\n        return null;\n    }\n\n    public String encodeRedirectURL(String url) {\n        return url;\n    }\n\n    public String encodeURL(String url) {\n        return url;\n    }\n\n    public int getStatus() {\n        return this.statusCode;\n    }\n\n    public Integer getErrorStatusCode() {\n        return this.errorStatusCode;\n    }\n\n    public void setStatus(int sc) {\n        if (!isIncluding() && (this.errorStatusCode == null)) {\n//        if (!isIncluding()) {\n            this.statusCode = sc;\n//            if (this.errorStatusCode != null) {\n//                this.errorStatusCode = new Integer(sc);\n//            }\n        }\n    }\n\n    public void sendRedirect(String location) throws IOException {\n        if (isIncluding()) {\n            Logger.log(Logger.ERROR, Launcher.RESOURCES, \"IncludeResponse.Redirect\",\n                    location);\n            return;\n        } else if (isCommitted()) {\n            throw new IllegalStateException(Launcher.RESOURCES.getString(\"WinstoneOutputStream.AlreadyCommitted\"));\n        }\n        resetBuffer();\n        \n        // Build location\n        StringBuffer fullLocation = new StringBuffer();\n        if (location.startsWith(\"http://\") || location.startsWith(\"https://\")) {\n            fullLocation.append(location);\n        } else {\n            if (location.trim().equals(\".\")) {\n                location = \"\";\n            }\n            \n            fullLocation.append(this.req.getScheme()).append(\"://\");\n            fullLocation.append(this.req.getServerName());\n            if (!((this.req.getServerPort() == 80) && this.req.getScheme().equals(\"http\"))\n                    && !((this.req.getServerPort() == 443) && this.req.getScheme().equals(\"https\")))\n                fullLocation.append(':').append(this.req.getServerPort());\n            if (location.startsWith(\"/\")) {\n                fullLocation.append(location);\n            } else {\n                fullLocation.append(this.req.getRequestURI());\n                int questionPos = fullLocation.toString().indexOf(\"?\"); \n                if (questionPos != -1) {\n                    fullLocation.delete(questionPos, fullLocation.length());\n                }\n                fullLocation.delete(\n                        fullLocation.toString().lastIndexOf(\"/\") + 1,\n                        fullLocation.length());\n                fullLocation.append(location);\n            }\n        }\n        if (this.req != null) {\n            this.req.discardRequestBody();\n        }\n        this.statusCode = HttpServletResponse.SC_MOVED_TEMPORARILY;\n        setHeader(LOCATION_HEADER, fullLocation.toString());\n        setContentLength(0);\n        getWriter().flush();\n    }\n\n    public void sendError(int sc) throws IOException {\n        sendError(sc, null);\n    }\n\n    public void sendError(int sc, String msg) throws IOException {\n        if (isIncluding()) {\n            Logger.log(Logger.ERROR, Launcher.RESOURCES, \"IncludeResponse.Error\",\n                    new String[] { \"\" + sc, msg });\n            return;\n        }\n        \n        Logger.log(Logger.DEBUG, Launcher.RESOURCES,\n                \"WinstoneResponse.SendingError\", new String[] { \"\" + sc, msg });\n\n        if ((this.webAppConfig != null) && (this.req != null)) {\n            \n            RequestDispatcher rd = this.webAppConfig\n                    .getErrorDispatcherByCode(req.getRequestURI(), sc, msg, null);\n            if (rd != null) {\n                try {\n                    rd.forward(this.req, this);\n                    return;\n                } catch (IllegalStateException err) {\n                    throw err;\n                } catch (IOException err) {\n                    throw err;\n                } catch (Throwable err) {\n                    Logger.log(Logger.WARNING, Launcher.RESOURCES,\n                            \"WinstoneResponse.ErrorInErrorPage\", new String[] {\n                                    rd.getName(), sc + \"\" }, err);\n                    return;\n                }\n            }\n        }\n        // If we are here there was no webapp and/or no request object, so \n        // show the default error page\n        if (this.errorStatusCode == null) {\n            this.statusCode = sc;\n        }\n        String output = Launcher.RESOURCES.getString(\"WinstoneResponse.ErrorPage\",\n                new String[] { sc + \"\", URIUtil.htmlEscape(msg == null ? \"\" : msg), \"\",\n                        Launcher.RESOURCES.getString(\"ServerVersion\"),\n                        \"\" + new Date() });\n        setContentLength(output.getBytes(getCharacterEncoding()).length);\n        Writer out = getWriter();\n        out.write(output);\n        out.flush();\n    }\n\n    /**\n     * @deprecated\n     */\n    public String encodeRedirectUrl(String url) {\n        return encodeRedirectURL(url);\n    }\n\n    /**\n     * @deprecated\n     */\n    public String encodeUrl(String url) {\n        return encodeURL(url);\n    }\n\n    /**\n     * @deprecated\n     */\n    public void setStatus(int sc, String sm) {\n        setStatus(sc);\n    }\n}\n"], "filenames": ["src/java/winstone/ErrorServlet.java", "src/java/winstone/URIUtil.java", "src/java/winstone/WinstoneResponse.java"], "buggy_code_start_loc": [45, 52, 808], "buggy_code_end_loc": [46, 52, 809], "fixing_code_start_loc": [45, 53, 808], "fixing_code_end_loc": [46, 70, 809], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in Jenkins Core in Jenkins before 1.438, and 1.409 LTS before 1.409.3 LTS, when a stand-alone container is used, allows remote attackers to inject arbitrary web script or HTML via vectors related to error messages.", "other": {"cve": {"id": "CVE-2011-4344", "sourceIdentifier": "secalert@redhat.com", "published": "2011-12-01T11:55:07.317", "lastModified": "2016-06-13T15:28:30.720", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in Jenkins Core in Jenkins before 1.438, and 1.409 LTS before 1.409.3 LTS, when a stand-alone container is used, allows remote attackers to inject arbitrary web script or HTML via vectors related to error messages."}, {"lang": "es", "value": "Vulnerabilidad de XSS en Jenkins Core en Jenkins en versiones anteriores a 1.438 y 1.409 LTS en versiones anteriores a 1.409.3 LTS, cuando se utiliza un contenedor independiente, permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de vectores relacionados con mensajes de error."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:1.409.1:*:*:*:lts:*:*:*", "matchCriteriaId": "79D19A52-2867-4042-9E84-E47B3AE992A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:1.409.2:*:*:*:lts:*:*:*", "matchCriteriaId": "3075E508-B294-4922-86A1-6ECFAAE5C0C6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.437", "matchCriteriaId": "F7BF2D8B-40F4-48D3-BE8C-D4D2C563A0F5"}]}]}], "references": [{"url": "http://groups.google.com/group/jenkinsci-advisories/msg/1b94588f90f876b5?dmode=source&output=gplain", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/11/23/5", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/11/23/6", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.cloudbees.com/jenkins-advisory/jenkins-security-advisory-2011-11-08.cb", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/50786", "source": "secalert@redhat.com"}, {"url": "https://github.com/jenkinsci/winstone/commit/410ed3001d51c689cf59085b7417466caa2ded7b.patch", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/jenkinsci/winstone/commit/410ed3001d51c689cf59085b7417466caa2ded7b.patch"}}