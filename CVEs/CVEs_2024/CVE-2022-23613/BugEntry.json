{"buggy_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file sesman.c\n * @brief Main program file\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include <stdarg.h>\n\n#include \"sesman.h\"\n#include \"xrdp_configure_options.h\"\n#include \"string_calls.h\"\n\n/**\n * Maximum number of short-lived connections to sesman\n *\n * At the moment, all connections to sesman are short-lived. This may change\n * in the future\n */\n#define MAX_SHORT_LIVED_CONNECTIONS 16\n\nstruct sesman_startup_params\n{\n    const char *sesman_ini;\n    int kill;\n    int no_daemon;\n    int help;\n    int version;\n    int dump_config;\n};\n\nint g_pid;\nunsigned char g_fixedkey[8] = { 23, 82, 107, 6, 35, 78, 88, 7 };\nstruct config_sesman *g_cfg; /* defined in config.h */\n\ntintptr g_term_event = 0;\n\n/**\n * Items stored on the g_con_list\n */\nstruct sesman_con\n{\n    struct trans *t;\n    struct SCP_SESSION *s;\n};\n\nstatic struct trans *g_list_trans = NULL;\nstatic struct list *g_con_list = NULL;\n\n/*****************************************************************************/\n/**\n * @brief looks for a case-insensitive match of a string in a list\n * @param candidate  String to match\n * @param ... NULL-terminated list of strings to compare the candidate with\n * @return !=0 if the candidate is found in the list\n */\nstatic int nocase_matches(const char *candidate, ...)\n{\n    va_list vl;\n    const char *member;\n    int result = 0;\n\n    va_start(vl, candidate);\n    while ((member = va_arg(vl, const char *)) != NULL)\n    {\n        if (g_strcasecmp(candidate, member) == 0)\n        {\n            result = 1;\n            break;\n        }\n    }\n\n    va_end(vl);\n    return result;\n}\n\n/**\n * Allocates a sesman_con struct\n *\n * @param trans Pointer to  newly-allocated transport\n * @return struct sesman_con pointer\n */\nstatic struct sesman_con *\nalloc_connection(struct trans *t)\n{\n    struct sesman_con *result;\n    struct SCP_SESSION *s;\n\n    if ((result = g_new(struct sesman_con, 1)) != NULL)\n    {\n        if ((s = scp_session_create()) != NULL)\n        {\n            result->t = t;\n            result->s = s;\n            /* Ensure we can find the connection easily from a callback */\n            t->callback_data = (void *)result;\n        }\n        else\n        {\n            g_free(result);\n            result = NULL;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Deletes a sesman_con struct, freeing resources\n *\n * After this call, the passed-in pointer is invalid and must not be\n * referenced.\n *\n * @param sc struct to de-allocate\n */\nstatic void\ndelete_connection(struct sesman_con *sc)\n{\n    trans_delete(sc->t);\n    scp_session_destroy(sc->s);\n    g_free(sc);\n}\n\n\n/*****************************************************************************/\n/**\n *\n * @brief  Command line argument parser\n * @param[in] argc number of command line arguments\n * @param[in] argv pointer array of commandline arguments\n * @param[out] sesman_startup_params Returned startup parameters\n * @return 0 on success, n on nth argument is unknown\n *\n */\nstatic int\nsesman_process_params(int argc, char **argv,\n                      struct sesman_startup_params *startup_params)\n{\n    int index;\n    const char *option;\n    const char *value;\n\n    index = 1;\n\n    while (index < argc)\n    {\n        option = argv[index];\n\n        if (index + 1 < argc)\n        {\n            value = argv[index + 1];\n        }\n        else\n        {\n            value = \"\";\n        }\n\n        if (nocase_matches(option, \"-help\", \"--help\", \"-h\", NULL))\n        {\n            startup_params->help = 1;\n        }\n        else if (nocase_matches(option, \"-kill\", \"--kill\", \"-k\", NULL))\n        {\n            startup_params->kill = 1;\n        }\n        else if (nocase_matches(option, \"-nodaemon\", \"--nodaemon\", \"-n\",\n                                \"-nd\", \"--nd\", \"-ns\", \"--ns\", NULL))\n        {\n            startup_params->no_daemon = 1;\n        }\n        else if (nocase_matches(option, \"-v\", \"--version\", NULL))\n        {\n            startup_params->version = 1;\n        }\n        else if (nocase_matches(option, \"--dump-config\", NULL))\n        {\n            startup_params->dump_config = 1;\n        }\n        else if (nocase_matches(option, \"-c\", \"--config\", NULL))\n        {\n            index++;\n            startup_params->sesman_ini = value;\n        }\n        else /* unknown option */\n        {\n            return index;\n        }\n\n        index++;\n    }\n\n    return 0;\n}\n\n/******************************************************************************/\nstatic int sesman_listen_test(struct config_sesman *cfg)\n{\n    int error;\n    int sck;\n    int rv = 0;\n\n    sck = g_tcp_socket();\n    if (sck < 0)\n    {\n        return 1;\n    }\n\n    LOG(LOG_LEVEL_DEBUG, \"Testing if xrdp-sesman can listen on %s port %s.\",\n        cfg->listen_address, cfg->listen_port);\n    g_tcp_set_non_blocking(sck);\n    error = scp_tcp_bind(sck, cfg->listen_address, cfg->listen_port);\n    if (error == 0)\n    {\n        /* try to listen */\n        error = g_tcp_listen(sck);\n\n        if (error == 0)\n        {\n            /* if listen succeeded, stop listen immediately */\n            g_sck_close(sck);\n        }\n        else\n        {\n            rv = 1;\n        }\n    }\n    else\n    {\n        rv = 1;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\nint\nsesman_close_all(void)\n{\n    int index;\n    struct sesman_con *sc;\n\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"sesman_close_all:\");\n    trans_delete(g_list_trans);\n    for (index = 0; index < g_con_list->count; index++)\n    {\n        sc = (struct sesman_con *) list_get_item(g_con_list, index);\n        delete_connection(sc);\n    }\n    return 0;\n}\n\n/******************************************************************************/\nstatic int\nsesman_data_in(struct trans *self)\n{\n    int version;\n    int size;\n\n    if (self->extra_flags == 0)\n    {\n        in_uint32_be(self->in_s, version);\n        in_uint32_be(self->in_s, size);\n        if (size > self->in_s->size)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_data_in: bad message size\");\n            return 1;\n        }\n        self->header_size = size;\n        self->extra_flags = 1;\n    }\n    else\n    {\n        /* process message */\n        struct sesman_con *sc = (struct sesman_con *)self->callback_data;\n        self->in_s->p = self->in_s->data;\n        if (scp_process(self, sc->s) != SCP_SERVER_STATE_OK)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_data_in: scp_process_msg failed\");\n            return 1;\n        }\n        /* reset for next message */\n        self->header_size = 8;\n        self->extra_flags = 0;\n        init_stream(self->in_s, 0); /* Reset input stream pointers */\n    }\n    return 0;\n}\n\n/******************************************************************************/\nstatic int\nsesman_listen_conn_in(struct trans *self, struct trans *new_self)\n{\n    struct sesman_con *sc;\n    if (g_con_list->count >= MAX_SHORT_LIVED_CONNECTIONS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_data_in: error, too many \"\n            \"connections, rejecting\");\n        trans_delete(new_self);\n    }\n    else if ((sc = alloc_connection(new_self)) == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_data_in: No memory to allocate \"\n            \"new connection\");\n        trans_delete(new_self);\n    }\n    else\n    {\n        new_self->header_size = 8;\n        new_self->trans_data_in = sesman_data_in;\n        new_self->no_stream_init_on_data_in = 1;\n        new_self->extra_flags = 0;\n        list_add_item(g_con_list, (intptr_t) sc);\n    }\n\n    return 0;\n}\n\n/******************************************************************************/\n/**\n *\n * @brief Starts sesman main loop\n *\n */\nstatic int\nsesman_main_loop(void)\n{\n    int error;\n    int robjs_count;\n    int wobjs_count;\n    int cont;\n    int timeout;\n    int index;\n    intptr_t robjs[32];\n    intptr_t wobjs[32];\n    struct sesman_con *scon;\n\n    g_con_list = list_create();\n    if (g_con_list == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: list_create failed\");\n        return 1;\n    }\n    g_list_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);\n    if (g_list_trans == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: trans_create failed\");\n        list_delete(g_con_list);\n        return 1;\n    }\n\n    LOG(LOG_LEVEL_DEBUG, \"sesman_main_loop: address %s port %s\",\n        g_cfg->listen_address, g_cfg->listen_port);\n    error = trans_listen_address(g_list_trans, g_cfg->listen_port,\n                                 g_cfg->listen_address);\n    if (error != 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: trans_listen_address \"\n            \"failed\");\n        trans_delete(g_list_trans);\n        list_delete(g_con_list);\n        return 1;\n    }\n    g_list_trans->trans_conn_in = sesman_listen_conn_in;\n    cont = 1;\n    while (cont)\n    {\n        timeout = -1;\n        robjs_count = 0;\n        robjs[robjs_count++] = g_term_event;\n        wobjs_count = 0;\n        for (index = 0; index < g_con_list->count; index++)\n        {\n            scon = (struct sesman_con *)list_get_item(g_con_list, index);\n            if (scon != NULL)\n            {\n                error = trans_get_wait_objs_rw(scon->t,\n                                               robjs, &robjs_count,\n                                               wobjs, &wobjs_count, &timeout);\n                if (error != 0)\n                {\n                    LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                        \"trans_get_wait_objs_rw failed\");\n                    break;\n                }\n            }\n        }\n        if (error != 0)\n        {\n            break;\n        }\n        error = trans_get_wait_objs_rw(g_list_trans, robjs, &robjs_count,\n                                       wobjs, &wobjs_count, &timeout);\n        if (error != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                \"trans_get_wait_objs_rw failed\");\n            break;\n        }\n\n        error = g_obj_wait(robjs, robjs_count, wobjs, wobjs_count, timeout);\n        if (error != 0)\n        {\n            /* error, should not get here */\n            g_sleep(100);\n        }\n\n        if (g_is_wait_obj_set(g_term_event)) /* term */\n        {\n            break;\n        }\n\n        for (index = 0; index < g_con_list->count; index++)\n        {\n            scon = (struct sesman_con *)list_get_item(g_con_list, index);\n            if (scon != NULL)\n            {\n                error = trans_check_wait_objs(scon->t);\n                if (error != 0)\n                {\n                    LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                        \"trans_check_wait_objs failed, removing trans\");\n                    delete_connection(scon);\n                    list_remove_item(g_con_list, index);\n                    index--;\n                    continue;\n                }\n            }\n        }\n        error = trans_check_wait_objs(g_list_trans);\n        if (error != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                \"trans_check_wait_objs failed\");\n            break;\n        }\n    }\n    for (index = 0; index < g_con_list->count; index++)\n    {\n        scon = (struct sesman_con *) list_get_item(g_con_list, index);\n        delete_connection(scon);\n    }\n    list_delete(g_con_list);\n    trans_delete(g_list_trans);\n    return 0;\n}\n\n/*****************************************************************************/\nstatic void\nprint_version(void)\n{\n    g_writeln(\"xrdp-sesman %s\", PACKAGE_VERSION);\n    g_writeln(\"  The xrdp session manager\");\n    g_writeln(\"  Copyright (C) 2004-2020 Jay Sorg, \"\n              \"Neutrino Labs, and all contributors.\");\n    g_writeln(\"  See https://github.com/neutrinolabs/xrdp for more information.\");\n    g_writeln(\"%s\", \"\");\n\n#if defined(XRDP_CONFIGURE_OPTIONS)\n    g_writeln(\"  Configure options:\");\n    g_writeln(\"%s\", XRDP_CONFIGURE_OPTIONS);\n#endif\n}\n\n/******************************************************************************/\nstatic void\nprint_help(void)\n{\n    g_printf(\"Usage: xrdp-sesman [options]\\n\");\n    g_printf(\"   -k, --kill        shut down xrdp-sesman\\n\");\n    g_printf(\"   -h, --help        show help\\n\");\n    g_printf(\"   -v, --version     show version\\n\");\n    g_printf(\"   -n, --nodaemon    don't fork into background\\n\");\n    g_printf(\"   -c, --config      specify new path to sesman.ini\\n\");\n    g_writeln(\"      --dump-config display config on stdout on startup\");\n    g_deinit();\n}\n\n/******************************************************************************/\nstatic int\nkill_running_sesman(const char *pid_file)\n{\n    int error;\n    int fd;\n    int pid;\n    char pid_s[32] = {0};\n\n    /* check if sesman is running */\n    if (!g_file_exist(pid_file))\n    {\n        g_printf(\"sesman is not running (pid file not found - %s)\\n\", pid_file);\n        g_deinit();\n        return 1;\n    }\n\n    fd = g_file_open(pid_file);\n\n    if (-1 == fd)\n    {\n        g_printf(\"error opening pid file[%s]: %s\\n\", pid_file, g_get_strerror());\n        return 1;\n    }\n\n    error = g_file_read(fd, pid_s, sizeof(pid_s) - 1);\n\n    if (-1 == error)\n    {\n        g_printf(\"error reading pid file: %s\\n\", g_get_strerror());\n        g_file_close(fd);\n        g_deinit();\n        return 1;\n    }\n\n    g_file_close(fd);\n    pid = g_atoi(pid_s);\n\n    error = g_sigterm(pid);\n\n    if (0 != error)\n    {\n        g_printf(\"error killing sesman: %s\\n\", g_get_strerror());\n    }\n    else\n    {\n        g_file_delete(pid_file);\n    }\n\n    g_deinit();\n    return error;\n}\n/******************************************************************************/\nint\nmain(int argc, char **argv)\n{\n    int error;\n    enum logReturns log_error;\n    char text[256];\n    char pid_file[256];\n    char default_sesman_ini[256];\n    struct sesman_startup_params startup_params = {0};\n    int errored_argc;\n    int daemon;\n\n    g_init(\"xrdp-sesman\");\n    g_snprintf(pid_file, 255, \"%s/xrdp-sesman.pid\", XRDP_PID_PATH);\n    g_snprintf(default_sesman_ini, 255, \"%s/sesman.ini\", XRDP_CFG_PATH);\n\n    startup_params.sesman_ini = default_sesman_ini;\n\n    errored_argc = sesman_process_params(argc, argv, &startup_params);\n    if (errored_argc > 0)\n    {\n        print_version();\n        g_writeln(\"%s\", \"\");\n        print_help();\n        g_writeln(\"%s\", \"\");\n\n        g_writeln(\"Unknown option: %s\", argv[errored_argc]);\n        g_deinit();\n        g_exit(1);\n    }\n\n    if (startup_params.help)\n    {\n        print_help();\n        g_exit(0);\n    }\n\n    if (startup_params.version)\n    {\n        print_version();\n        g_exit(0);\n    }\n\n\n    if (startup_params.kill)\n    {\n        g_exit(kill_running_sesman(pid_file));\n    }\n\n    if (g_file_exist(pid_file))\n    {\n        g_printf(\"xrdp-sesman is already running.\\n\");\n        g_printf(\"if it's not running, try removing \");\n        g_printf(\"%s\", pid_file);\n        g_printf(\"\\n\");\n        g_deinit();\n        g_exit(1);\n    }\n\n    /* reading config */\n    if ((g_cfg = config_read(startup_params.sesman_ini)) == NULL)\n    {\n        g_printf(\"error reading config %s: %s\\nquitting.\\n\",\n                 startup_params.sesman_ini, g_get_strerror());\n        g_deinit();\n        g_exit(1);\n    }\n\n    if (startup_params.dump_config)\n    {\n        config_dump(g_cfg);\n    }\n\n    /* starting logging subsystem */\n    log_error = log_start(startup_params.sesman_ini, \"xrdp-sesman\",\n                          startup_params.dump_config);\n\n    if (log_error != LOG_STARTUP_OK)\n    {\n        switch (log_error)\n        {\n            case LOG_ERROR_MALLOC:\n                g_writeln(\"error on malloc. cannot start logging. quitting.\");\n                break;\n            case LOG_ERROR_FILE_OPEN:\n                g_writeln(\"error opening log file [%s]. quitting.\",\n                          getLogFile(text, 255));\n                break;\n            default:\n                g_writeln(\"error\");\n                break;\n        }\n\n        config_free(g_cfg);\n        g_deinit();\n        g_exit(1);\n    }\n\n    LOG(LOG_LEVEL_TRACE, \"config loaded in %s at %s:%d\", __func__, __FILE__, __LINE__);\n    LOG(LOG_LEVEL_TRACE, \"    sesman_ini        = %s\", g_cfg->sesman_ini);\n    LOG(LOG_LEVEL_TRACE, \"    listen_address    = %s\", g_cfg->listen_address);\n    LOG(LOG_LEVEL_TRACE, \"    listen_port       = %s\", g_cfg->listen_port);\n    LOG(LOG_LEVEL_TRACE, \"    enable_user_wm    = %d\", g_cfg->enable_user_wm);\n    LOG(LOG_LEVEL_TRACE, \"    default_wm        = %s\", g_cfg->default_wm);\n    LOG(LOG_LEVEL_TRACE, \"    user_wm           = %s\", g_cfg->user_wm);\n    LOG(LOG_LEVEL_TRACE, \"    reconnect_sh      = %s\", g_cfg->reconnect_sh);\n    LOG(LOG_LEVEL_TRACE, \"    auth_file_path    = %s\", g_cfg->auth_file_path);\n\n    daemon = !startup_params.no_daemon;\n    if (daemon)\n    {\n        /* not to spit on the console, shut up stdout/stderr before anything's logged */\n        g_file_close(0);\n        g_file_close(1);\n        g_file_close(2);\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n    }\n\n    /* libscp initialization */\n    scp_init();\n\n\n    if (daemon)\n    {\n        /* start of daemonizing code */\n        if (sesman_listen_test(g_cfg) != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Failed to start xrdp-sesman daemon, \"\n                \"possibly address already in use.\");\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(1);\n        }\n\n        if (0 != g_fork())\n        {\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(0);\n        }\n\n    }\n\n    /* signal handling */\n    g_pid = g_getpid();\n    /* old style signal handling is now managed synchronously by a\n     * separate thread. uncomment this block if you need old style\n     * signal handling and comment out thread_sighandler_start()\n     * going back to old style for the time being\n     * problem with the sigaddset functions in sig.c - jts */\n#if 1\n    g_signal_hang_up(sig_sesman_reload_cfg); /* SIGHUP  */\n    g_signal_user_interrupt(sig_sesman_shutdown); /* SIGINT  */\n    g_signal_terminate(sig_sesman_shutdown); /* SIGTERM */\n    g_signal_child_stop(sig_sesman_session_end); /* SIGCHLD */\n#endif\n#if 0\n    thread_sighandler_start();\n#endif\n\n    if (daemon)\n    {\n        /* writing pid file */\n        char pid_s[32];\n        int fd = g_file_open(pid_file);\n\n        if (-1 == fd)\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"error opening pid file[%s]: %s\",\n                pid_file, g_get_strerror());\n            log_end();\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(1);\n        }\n\n        g_sprintf(pid_s, \"%d\", g_pid);\n        g_file_write(fd, pid_s, g_strlen(pid_s));\n        g_file_close(fd);\n    }\n\n    /* start program main loop */\n    LOG(LOG_LEVEL_INFO,\n        \"starting xrdp-sesman with pid %d\", g_pid);\n\n    /* make sure the socket directory exists */\n    g_mk_socket_path(\"xrdp-sesman\");\n\n    /* make sure the /tmp/.X11-unix directory exists */\n    if (!g_directory_exist(\"/tmp/.X11-unix\"))\n    {\n        if (!g_create_dir(\"/tmp/.X11-unix\"))\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"sesman.c: error creating dir /tmp/.X11-unix\");\n        }\n        g_chmod_hex(\"/tmp/.X11-unix\", 0x1777);\n    }\n\n    g_snprintf(text, 255, \"xrdp_sesman_%8.8x_main_term\", g_pid);\n    g_term_event = g_create_wait_obj(text);\n\n    error = sesman_main_loop();\n\n    /* clean up PID file on exit */\n    if (daemon)\n    {\n        g_file_delete(pid_file);\n    }\n\n    g_delete_wait_obj(g_term_event);\n\n    if (!daemon)\n    {\n        log_end();\n    }\n\n    config_free(g_cfg);\n    g_deinit();\n    g_exit(error);\n    return 0;\n}\n"], "fixing_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file sesman.c\n * @brief Main program file\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include <stdarg.h>\n\n#include \"sesman.h\"\n#include \"xrdp_configure_options.h\"\n#include \"string_calls.h\"\n\n/**\n * Maximum number of short-lived connections to sesman\n *\n * At the moment, all connections to sesman are short-lived. This may change\n * in the future\n */\n#define MAX_SHORT_LIVED_CONNECTIONS 16\n\nstruct sesman_startup_params\n{\n    const char *sesman_ini;\n    int kill;\n    int no_daemon;\n    int help;\n    int version;\n    int dump_config;\n};\n\nint g_pid;\nunsigned char g_fixedkey[8] = { 23, 82, 107, 6, 35, 78, 88, 7 };\nstruct config_sesman *g_cfg; /* defined in config.h */\n\ntintptr g_term_event = 0;\n\n/**\n * Items stored on the g_con_list\n */\nstruct sesman_con\n{\n    struct trans *t;\n    struct SCP_SESSION *s;\n};\n\nstatic struct trans *g_list_trans = NULL;\nstatic struct list *g_con_list = NULL;\n\n/*****************************************************************************/\n/**\n * @brief looks for a case-insensitive match of a string in a list\n * @param candidate  String to match\n * @param ... NULL-terminated list of strings to compare the candidate with\n * @return !=0 if the candidate is found in the list\n */\nstatic int nocase_matches(const char *candidate, ...)\n{\n    va_list vl;\n    const char *member;\n    int result = 0;\n\n    va_start(vl, candidate);\n    while ((member = va_arg(vl, const char *)) != NULL)\n    {\n        if (g_strcasecmp(candidate, member) == 0)\n        {\n            result = 1;\n            break;\n        }\n    }\n\n    va_end(vl);\n    return result;\n}\n\n/**\n * Allocates a sesman_con struct\n *\n * @param trans Pointer to  newly-allocated transport\n * @return struct sesman_con pointer\n */\nstatic struct sesman_con *\nalloc_connection(struct trans *t)\n{\n    struct sesman_con *result;\n    struct SCP_SESSION *s;\n\n    if ((result = g_new(struct sesman_con, 1)) != NULL)\n    {\n        if ((s = scp_session_create()) != NULL)\n        {\n            result->t = t;\n            result->s = s;\n            /* Ensure we can find the connection easily from a callback */\n            t->callback_data = (void *)result;\n        }\n        else\n        {\n            g_free(result);\n            result = NULL;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Deletes a sesman_con struct, freeing resources\n *\n * After this call, the passed-in pointer is invalid and must not be\n * referenced.\n *\n * @param sc struct to de-allocate\n */\nstatic void\ndelete_connection(struct sesman_con *sc)\n{\n    trans_delete(sc->t);\n    scp_session_destroy(sc->s);\n    g_free(sc);\n}\n\n\n/*****************************************************************************/\n/**\n *\n * @brief  Command line argument parser\n * @param[in] argc number of command line arguments\n * @param[in] argv pointer array of commandline arguments\n * @param[out] sesman_startup_params Returned startup parameters\n * @return 0 on success, n on nth argument is unknown\n *\n */\nstatic int\nsesman_process_params(int argc, char **argv,\n                      struct sesman_startup_params *startup_params)\n{\n    int index;\n    const char *option;\n    const char *value;\n\n    index = 1;\n\n    while (index < argc)\n    {\n        option = argv[index];\n\n        if (index + 1 < argc)\n        {\n            value = argv[index + 1];\n        }\n        else\n        {\n            value = \"\";\n        }\n\n        if (nocase_matches(option, \"-help\", \"--help\", \"-h\", NULL))\n        {\n            startup_params->help = 1;\n        }\n        else if (nocase_matches(option, \"-kill\", \"--kill\", \"-k\", NULL))\n        {\n            startup_params->kill = 1;\n        }\n        else if (nocase_matches(option, \"-nodaemon\", \"--nodaemon\", \"-n\",\n                                \"-nd\", \"--nd\", \"-ns\", \"--ns\", NULL))\n        {\n            startup_params->no_daemon = 1;\n        }\n        else if (nocase_matches(option, \"-v\", \"--version\", NULL))\n        {\n            startup_params->version = 1;\n        }\n        else if (nocase_matches(option, \"--dump-config\", NULL))\n        {\n            startup_params->dump_config = 1;\n        }\n        else if (nocase_matches(option, \"-c\", \"--config\", NULL))\n        {\n            index++;\n            startup_params->sesman_ini = value;\n        }\n        else /* unknown option */\n        {\n            return index;\n        }\n\n        index++;\n    }\n\n    return 0;\n}\n\n/******************************************************************************/\nstatic int sesman_listen_test(struct config_sesman *cfg)\n{\n    int error;\n    int sck;\n    int rv = 0;\n\n    sck = g_tcp_socket();\n    if (sck < 0)\n    {\n        return 1;\n    }\n\n    LOG(LOG_LEVEL_DEBUG, \"Testing if xrdp-sesman can listen on %s port %s.\",\n        cfg->listen_address, cfg->listen_port);\n    g_tcp_set_non_blocking(sck);\n    error = scp_tcp_bind(sck, cfg->listen_address, cfg->listen_port);\n    if (error == 0)\n    {\n        /* try to listen */\n        error = g_tcp_listen(sck);\n\n        if (error == 0)\n        {\n            /* if listen succeeded, stop listen immediately */\n            g_sck_close(sck);\n        }\n        else\n        {\n            rv = 1;\n        }\n    }\n    else\n    {\n        rv = 1;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\nint\nsesman_close_all(void)\n{\n    int index;\n    struct sesman_con *sc;\n\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"sesman_close_all:\");\n    trans_delete(g_list_trans);\n    for (index = 0; index < g_con_list->count; index++)\n    {\n        sc = (struct sesman_con *) list_get_item(g_con_list, index);\n        delete_connection(sc);\n    }\n    return 0;\n}\n\n/******************************************************************************/\nstatic int\nsesman_data_in(struct trans *self)\n{\n#define HEADER_SIZE 8\n    int version;\n    int size;\n\n    if (self->extra_flags == 0)\n    {\n        in_uint32_be(self->in_s, version);\n        in_uint32_be(self->in_s, size);\n        if (size < HEADER_SIZE || size > self->in_s->size)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_data_in: bad message size %d\", size);\n            return 1;\n        }\n        self->header_size = size;\n        self->extra_flags = 1;\n    }\n    else\n    {\n        /* process message */\n        struct sesman_con *sc = (struct sesman_con *)self->callback_data;\n        self->in_s->p = self->in_s->data;\n        if (scp_process(self, sc->s) != SCP_SERVER_STATE_OK)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_data_in: scp_process_msg failed\");\n            return 1;\n        }\n        /* reset for next message */\n        self->header_size = HEADER_SIZE;\n        self->extra_flags = 0;\n        init_stream(self->in_s, 0); /* Reset input stream pointers */\n    }\n    return 0;\n#undef HEADER_SIZE\n}\n\n/******************************************************************************/\nstatic int\nsesman_listen_conn_in(struct trans *self, struct trans *new_self)\n{\n    struct sesman_con *sc;\n    if (g_con_list->count >= MAX_SHORT_LIVED_CONNECTIONS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_data_in: error, too many \"\n            \"connections, rejecting\");\n        trans_delete(new_self);\n    }\n    else if ((sc = alloc_connection(new_self)) == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_data_in: No memory to allocate \"\n            \"new connection\");\n        trans_delete(new_self);\n    }\n    else\n    {\n        new_self->header_size = 8;\n        new_self->trans_data_in = sesman_data_in;\n        new_self->no_stream_init_on_data_in = 1;\n        new_self->extra_flags = 0;\n        list_add_item(g_con_list, (intptr_t) sc);\n    }\n\n    return 0;\n}\n\n/******************************************************************************/\n/**\n *\n * @brief Starts sesman main loop\n *\n */\nstatic int\nsesman_main_loop(void)\n{\n    int error;\n    int robjs_count;\n    int wobjs_count;\n    int cont;\n    int timeout;\n    int index;\n    intptr_t robjs[32];\n    intptr_t wobjs[32];\n    struct sesman_con *scon;\n\n    g_con_list = list_create();\n    if (g_con_list == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: list_create failed\");\n        return 1;\n    }\n    g_list_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);\n    if (g_list_trans == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: trans_create failed\");\n        list_delete(g_con_list);\n        return 1;\n    }\n\n    LOG(LOG_LEVEL_DEBUG, \"sesman_main_loop: address %s port %s\",\n        g_cfg->listen_address, g_cfg->listen_port);\n    error = trans_listen_address(g_list_trans, g_cfg->listen_port,\n                                 g_cfg->listen_address);\n    if (error != 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: trans_listen_address \"\n            \"failed\");\n        trans_delete(g_list_trans);\n        list_delete(g_con_list);\n        return 1;\n    }\n    g_list_trans->trans_conn_in = sesman_listen_conn_in;\n    cont = 1;\n    while (cont)\n    {\n        timeout = -1;\n        robjs_count = 0;\n        robjs[robjs_count++] = g_term_event;\n        wobjs_count = 0;\n        for (index = 0; index < g_con_list->count; index++)\n        {\n            scon = (struct sesman_con *)list_get_item(g_con_list, index);\n            if (scon != NULL)\n            {\n                error = trans_get_wait_objs_rw(scon->t,\n                                               robjs, &robjs_count,\n                                               wobjs, &wobjs_count, &timeout);\n                if (error != 0)\n                {\n                    LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                        \"trans_get_wait_objs_rw failed\");\n                    break;\n                }\n            }\n        }\n        if (error != 0)\n        {\n            break;\n        }\n        error = trans_get_wait_objs_rw(g_list_trans, robjs, &robjs_count,\n                                       wobjs, &wobjs_count, &timeout);\n        if (error != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                \"trans_get_wait_objs_rw failed\");\n            break;\n        }\n\n        error = g_obj_wait(robjs, robjs_count, wobjs, wobjs_count, timeout);\n        if (error != 0)\n        {\n            /* error, should not get here */\n            g_sleep(100);\n        }\n\n        if (g_is_wait_obj_set(g_term_event)) /* term */\n        {\n            break;\n        }\n\n        for (index = 0; index < g_con_list->count; index++)\n        {\n            scon = (struct sesman_con *)list_get_item(g_con_list, index);\n            if (scon != NULL)\n            {\n                error = trans_check_wait_objs(scon->t);\n                if (error != 0)\n                {\n                    LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                        \"trans_check_wait_objs failed, removing trans\");\n                    delete_connection(scon);\n                    list_remove_item(g_con_list, index);\n                    index--;\n                    continue;\n                }\n            }\n        }\n        error = trans_check_wait_objs(g_list_trans);\n        if (error != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"sesman_main_loop: \"\n                \"trans_check_wait_objs failed\");\n            break;\n        }\n    }\n    for (index = 0; index < g_con_list->count; index++)\n    {\n        scon = (struct sesman_con *) list_get_item(g_con_list, index);\n        delete_connection(scon);\n    }\n    list_delete(g_con_list);\n    trans_delete(g_list_trans);\n    return 0;\n}\n\n/*****************************************************************************/\nstatic void\nprint_version(void)\n{\n    g_writeln(\"xrdp-sesman %s\", PACKAGE_VERSION);\n    g_writeln(\"  The xrdp session manager\");\n    g_writeln(\"  Copyright (C) 2004-2020 Jay Sorg, \"\n              \"Neutrino Labs, and all contributors.\");\n    g_writeln(\"  See https://github.com/neutrinolabs/xrdp for more information.\");\n    g_writeln(\"%s\", \"\");\n\n#if defined(XRDP_CONFIGURE_OPTIONS)\n    g_writeln(\"  Configure options:\");\n    g_writeln(\"%s\", XRDP_CONFIGURE_OPTIONS);\n#endif\n}\n\n/******************************************************************************/\nstatic void\nprint_help(void)\n{\n    g_printf(\"Usage: xrdp-sesman [options]\\n\");\n    g_printf(\"   -k, --kill        shut down xrdp-sesman\\n\");\n    g_printf(\"   -h, --help        show help\\n\");\n    g_printf(\"   -v, --version     show version\\n\");\n    g_printf(\"   -n, --nodaemon    don't fork into background\\n\");\n    g_printf(\"   -c, --config      specify new path to sesman.ini\\n\");\n    g_writeln(\"      --dump-config display config on stdout on startup\");\n    g_deinit();\n}\n\n/******************************************************************************/\nstatic int\nkill_running_sesman(const char *pid_file)\n{\n    int error;\n    int fd;\n    int pid;\n    char pid_s[32] = {0};\n\n    /* check if sesman is running */\n    if (!g_file_exist(pid_file))\n    {\n        g_printf(\"sesman is not running (pid file not found - %s)\\n\", pid_file);\n        g_deinit();\n        return 1;\n    }\n\n    fd = g_file_open(pid_file);\n\n    if (-1 == fd)\n    {\n        g_printf(\"error opening pid file[%s]: %s\\n\", pid_file, g_get_strerror());\n        return 1;\n    }\n\n    error = g_file_read(fd, pid_s, sizeof(pid_s) - 1);\n\n    if (-1 == error)\n    {\n        g_printf(\"error reading pid file: %s\\n\", g_get_strerror());\n        g_file_close(fd);\n        g_deinit();\n        return 1;\n    }\n\n    g_file_close(fd);\n    pid = g_atoi(pid_s);\n\n    error = g_sigterm(pid);\n\n    if (0 != error)\n    {\n        g_printf(\"error killing sesman: %s\\n\", g_get_strerror());\n    }\n    else\n    {\n        g_file_delete(pid_file);\n    }\n\n    g_deinit();\n    return error;\n}\n/******************************************************************************/\nint\nmain(int argc, char **argv)\n{\n    int error;\n    enum logReturns log_error;\n    char text[256];\n    char pid_file[256];\n    char default_sesman_ini[256];\n    struct sesman_startup_params startup_params = {0};\n    int errored_argc;\n    int daemon;\n\n    g_init(\"xrdp-sesman\");\n    g_snprintf(pid_file, 255, \"%s/xrdp-sesman.pid\", XRDP_PID_PATH);\n    g_snprintf(default_sesman_ini, 255, \"%s/sesman.ini\", XRDP_CFG_PATH);\n\n    startup_params.sesman_ini = default_sesman_ini;\n\n    errored_argc = sesman_process_params(argc, argv, &startup_params);\n    if (errored_argc > 0)\n    {\n        print_version();\n        g_writeln(\"%s\", \"\");\n        print_help();\n        g_writeln(\"%s\", \"\");\n\n        g_writeln(\"Unknown option: %s\", argv[errored_argc]);\n        g_deinit();\n        g_exit(1);\n    }\n\n    if (startup_params.help)\n    {\n        print_help();\n        g_exit(0);\n    }\n\n    if (startup_params.version)\n    {\n        print_version();\n        g_exit(0);\n    }\n\n\n    if (startup_params.kill)\n    {\n        g_exit(kill_running_sesman(pid_file));\n    }\n\n    if (g_file_exist(pid_file))\n    {\n        g_printf(\"xrdp-sesman is already running.\\n\");\n        g_printf(\"if it's not running, try removing \");\n        g_printf(\"%s\", pid_file);\n        g_printf(\"\\n\");\n        g_deinit();\n        g_exit(1);\n    }\n\n    /* reading config */\n    if ((g_cfg = config_read(startup_params.sesman_ini)) == NULL)\n    {\n        g_printf(\"error reading config %s: %s\\nquitting.\\n\",\n                 startup_params.sesman_ini, g_get_strerror());\n        g_deinit();\n        g_exit(1);\n    }\n\n    if (startup_params.dump_config)\n    {\n        config_dump(g_cfg);\n    }\n\n    /* starting logging subsystem */\n    log_error = log_start(startup_params.sesman_ini, \"xrdp-sesman\",\n                          startup_params.dump_config);\n\n    if (log_error != LOG_STARTUP_OK)\n    {\n        switch (log_error)\n        {\n            case LOG_ERROR_MALLOC:\n                g_writeln(\"error on malloc. cannot start logging. quitting.\");\n                break;\n            case LOG_ERROR_FILE_OPEN:\n                g_writeln(\"error opening log file [%s]. quitting.\",\n                          getLogFile(text, 255));\n                break;\n            default:\n                g_writeln(\"error\");\n                break;\n        }\n\n        config_free(g_cfg);\n        g_deinit();\n        g_exit(1);\n    }\n\n    LOG(LOG_LEVEL_TRACE, \"config loaded in %s at %s:%d\", __func__, __FILE__, __LINE__);\n    LOG(LOG_LEVEL_TRACE, \"    sesman_ini        = %s\", g_cfg->sesman_ini);\n    LOG(LOG_LEVEL_TRACE, \"    listen_address    = %s\", g_cfg->listen_address);\n    LOG(LOG_LEVEL_TRACE, \"    listen_port       = %s\", g_cfg->listen_port);\n    LOG(LOG_LEVEL_TRACE, \"    enable_user_wm    = %d\", g_cfg->enable_user_wm);\n    LOG(LOG_LEVEL_TRACE, \"    default_wm        = %s\", g_cfg->default_wm);\n    LOG(LOG_LEVEL_TRACE, \"    user_wm           = %s\", g_cfg->user_wm);\n    LOG(LOG_LEVEL_TRACE, \"    reconnect_sh      = %s\", g_cfg->reconnect_sh);\n    LOG(LOG_LEVEL_TRACE, \"    auth_file_path    = %s\", g_cfg->auth_file_path);\n\n    daemon = !startup_params.no_daemon;\n    if (daemon)\n    {\n        /* not to spit on the console, shut up stdout/stderr before anything's logged */\n        g_file_close(0);\n        g_file_close(1);\n        g_file_close(2);\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n\n        if (g_file_open(\"/dev/null\") < 0)\n        {\n        }\n    }\n\n    /* libscp initialization */\n    scp_init();\n\n\n    if (daemon)\n    {\n        /* start of daemonizing code */\n        if (sesman_listen_test(g_cfg) != 0)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Failed to start xrdp-sesman daemon, \"\n                \"possibly address already in use.\");\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(1);\n        }\n\n        if (0 != g_fork())\n        {\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(0);\n        }\n\n    }\n\n    /* signal handling */\n    g_pid = g_getpid();\n    /* old style signal handling is now managed synchronously by a\n     * separate thread. uncomment this block if you need old style\n     * signal handling and comment out thread_sighandler_start()\n     * going back to old style for the time being\n     * problem with the sigaddset functions in sig.c - jts */\n#if 1\n    g_signal_hang_up(sig_sesman_reload_cfg); /* SIGHUP  */\n    g_signal_user_interrupt(sig_sesman_shutdown); /* SIGINT  */\n    g_signal_terminate(sig_sesman_shutdown); /* SIGTERM */\n    g_signal_child_stop(sig_sesman_session_end); /* SIGCHLD */\n#endif\n#if 0\n    thread_sighandler_start();\n#endif\n\n    if (daemon)\n    {\n        /* writing pid file */\n        char pid_s[32];\n        int fd = g_file_open(pid_file);\n\n        if (-1 == fd)\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"error opening pid file[%s]: %s\",\n                pid_file, g_get_strerror());\n            log_end();\n            config_free(g_cfg);\n            g_deinit();\n            g_exit(1);\n        }\n\n        g_sprintf(pid_s, \"%d\", g_pid);\n        g_file_write(fd, pid_s, g_strlen(pid_s));\n        g_file_close(fd);\n    }\n\n    /* start program main loop */\n    LOG(LOG_LEVEL_INFO,\n        \"starting xrdp-sesman with pid %d\", g_pid);\n\n    /* make sure the socket directory exists */\n    g_mk_socket_path(\"xrdp-sesman\");\n\n    /* make sure the /tmp/.X11-unix directory exists */\n    if (!g_directory_exist(\"/tmp/.X11-unix\"))\n    {\n        if (!g_create_dir(\"/tmp/.X11-unix\"))\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"sesman.c: error creating dir /tmp/.X11-unix\");\n        }\n        g_chmod_hex(\"/tmp/.X11-unix\", 0x1777);\n    }\n\n    g_snprintf(text, 255, \"xrdp_sesman_%8.8x_main_term\", g_pid);\n    g_term_event = g_create_wait_obj(text);\n\n    error = sesman_main_loop();\n\n    /* clean up PID file on exit */\n    if (daemon)\n    {\n        g_file_delete(pid_file);\n    }\n\n    g_delete_wait_obj(g_term_event);\n\n    if (!daemon)\n    {\n        log_end();\n    }\n\n    config_free(g_cfg);\n    g_deinit();\n    g_exit(error);\n    return 0;\n}\n"], "filenames": ["sesman/sesman.c"], "buggy_code_start_loc": [278], "buggy_code_end_loc": [309], "fixing_code_start_loc": [279], "fixing_code_end_loc": [312], "type": "CWE-191", "message": "xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-23613", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-07T22:15:08.650", "lastModified": "2022-03-15T16:39:57.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds."}, {"lang": "es", "value": "xrdp es un servidor de protocolo de escritorio remoto (RDP) de c\u00f3digo abierto. En las versiones afectadas, un desbordamiento de enteros que conlleva a un desbordamiento de pila en el servidor sesman permite a cualquier atacante no autenticado que sea capaz de acceder localmente a un servidor sesman ejecutar c\u00f3digo como root. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 0.9.18.1 y superiores. Es aconsejado a usuarios que se actualicen. No hay medidas de mitigaci\u00f3n adicionales conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neutrinolabs:xrdp:0.9.17:*:*:*:*:*:*:*", "matchCriteriaId": "91A6EB2F-2CE5-4A90-A90E-EE327FD2CD7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neutrinolabs:xrdp:0.9.18:*:*:*:*:*:*:*", "matchCriteriaId": "B45B087F-A5FE-4816-9675-3E858A8B72BF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-8h98-h426-xf32", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/K5ONRGARKHGFU2CIEQ7E6M6VJZEM5XWW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U3XGFJNQMNXHBD3J7CBM4YURYEDXROWZ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa"}}