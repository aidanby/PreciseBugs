{"buggy_code": ["module Rails\n  module Html\n    # === Rails::Html::PermitScrubber\n    #\n    # +Rails::Html::PermitScrubber+ allows you to permit only your own tags and/or attributes.\n    #\n    # +Rails::Html::PermitScrubber+ can be subclassed to determine:\n    # - When a node should be skipped via +skip_node?+.\n    # - When a node is allowed via +allowed_node?+.\n    # - When an attribute should be scrubbed via +scrub_attribute?+.\n    #\n    # Subclasses don't need to worry if tags or attributes are set or not.\n    # If tags or attributes are not set, Loofah's behavior will be used.\n    # If you override +allowed_node?+ and no tags are set, it will not be called.\n    # Instead Loofahs behavior will be used.\n    # Likewise for +scrub_attribute?+ and attributes respectively.\n    #\n    # Text and CDATA nodes are skipped by default.\n    # Unallowed elements will be stripped, i.e. element is removed but its subtree kept.\n    # Supplied tags and attributes should be Enumerables.\n    #\n    # +tags=+\n    # If set, elements excluded will be stripped.\n    # If not, elements are stripped based on Loofahs +HTML5::Scrub.allowed_element?+.\n    #\n    # +attributes=+\n    # If set, attributes excluded will be removed.\n    # If not, attributes are removed based on Loofahs +HTML5::Scrub.scrub_attributes+.\n    #\n    #  class CommentScrubber < Html::PermitScrubber\n    #    def initialize\n    #      super\n    #      self.tags = %w(form script comment blockquote)\n    #    end\n    #\n    #    def skip_node?(node)\n    #      node.text?\n    #    end\n    #\n    #    def scrub_attribute?(name)\n    #      name == \"style\"\n    #    end\n    #  end\n    #\n    # See the documentation for +Nokogiri::XML::Node+ to understand what's possible\n    # with nodes: https://nokogiri.org/rdoc/Nokogiri/XML/Node.html\n    class PermitScrubber < Loofah::Scrubber\n      attr_reader :tags, :attributes, :prune\n\n      def initialize(prune: false)\n        @prune = prune\n        @direction = @prune ? :top_down : :bottom_up\n        @tags, @attributes = nil, nil\n      end\n\n      def tags=(tags)\n        @tags = validate!(tags, :tags)\n      end\n\n      def attributes=(attributes)\n        @attributes = validate!(attributes, :attributes)\n      end\n\n      def scrub(node)\n        if node.cdata?\n          text = node.document.create_text_node node.text\n          node.replace text\n          return CONTINUE\n        end\n        return CONTINUE if skip_node?(node)\n\n        unless (node.element? || node.comment?) && keep_node?(node)\n          return STOP if scrub_node(node) == STOP\n        end\n\n        scrub_attributes(node)\n      end\n\n      protected\n\n      def allowed_node?(node)\n        @tags.include?(node.name)\n      end\n\n      def skip_node?(node)\n        node.text?\n      end\n\n      def scrub_attribute?(name)\n        !@attributes.include?(name)\n      end\n\n      def keep_node?(node)\n        if @tags\n          allowed_node?(node)\n        else\n          Loofah::HTML5::Scrub.allowed_element?(node.name)\n        end\n      end\n\n      def scrub_node(node)\n        node.before(node.children) unless prune # strip\n        node.remove\n      end\n\n      def scrub_attributes(node)\n        if @attributes\n          node.attribute_nodes.each do |attr|\n            attr.remove if scrub_attribute?(attr.name)\n            scrub_attribute(node, attr)\n          end\n\n          scrub_css_attribute(node)\n        else\n          Loofah::HTML5::Scrub.scrub_attributes(node)\n        end\n      end\n\n      def scrub_css_attribute(node)\n        if Loofah::HTML5::Scrub.respond_to?(:scrub_css_attribute)\n          Loofah::HTML5::Scrub.scrub_css_attribute(node)\n        else\n          style = node.attributes['style']\n          style.value = Loofah::HTML5::Scrub.scrub_css(style.value) if style\n        end\n      end\n\n      def validate!(var, name)\n        if var && !var.is_a?(Enumerable)\n          raise ArgumentError, \"You should pass :#{name} as an Enumerable\"\n        end\n        var\n      end\n\n      def scrub_attribute(node, attr_node)\n        attr_name = if attr_node.namespace\n                      \"#{attr_node.namespace.prefix}:#{attr_node.node_name}\"\n                    else\n                      attr_node.node_name\n                    end\n\n        if Loofah::HTML5::SafeList::ATTR_VAL_IS_URI.include?(attr_name)\n          # this block lifted nearly verbatim from HTML5 sanitization\n          val_unescaped = CGI.unescapeHTML(attr_node.value).gsub(Loofah::HTML5::Scrub::CONTROL_CHARACTERS,'').downcase\n          if val_unescaped =~ /^[a-z0-9][-+.a-z0-9]*:/ && ! Loofah::HTML5::SafeList::ALLOWED_PROTOCOLS.include?(val_unescaped.split(Loofah::HTML5::SafeList::PROTOCOL_SEPARATOR)[0])\n            attr_node.remove\n          end\n        end\n        if Loofah::HTML5::SafeList::SVG_ATTR_VAL_ALLOWS_REF.include?(attr_name)\n          attr_node.value = attr_node.value.gsub(/url\\s*\\(\\s*[^#\\s][^)]+?\\)/m, ' ') if attr_node.value\n        end\n        if Loofah::HTML5::SafeList::SVG_ALLOW_LOCAL_HREF.include?(node.name) && attr_name == 'xlink:href' && attr_node.value =~ /^\\s*[^#\\s].*/m\n          attr_node.remove\n        end\n\n        node.remove_attribute(attr_node.name) if attr_name == 'src' && attr_node.value !~ /[^[:space:]]/\n\n        Loofah::HTML5::Scrub.force_correct_attribute_escaping! node\n      end\n    end\n\n    # === Rails::Html::TargetScrubber\n    #\n    # Where +Rails::Html::PermitScrubber+ picks out tags and attributes to permit in\n    # sanitization, +Rails::Html::TargetScrubber+ targets them for removal.\n    #\n    # +tags=+\n    # If set, elements included will be stripped.\n    #\n    # +attributes=+\n    # If set, attributes included will be removed.\n    class TargetScrubber < PermitScrubber\n      def allowed_node?(node)\n        !super\n      end\n\n      def scrub_attribute?(name)\n        !super\n      end\n    end\n\n    # === Rails::Html::TextOnlyScrubber\n    #\n    # +Rails::Html::TextOnlyScrubber+ allows you to permit text nodes.\n    #\n    # Unallowed elements will be stripped, i.e. element is removed but its subtree kept.\n    class TextOnlyScrubber < Loofah::Scrubber\n      def initialize\n        @direction = :bottom_up\n      end\n\n      def scrub(node)\n        if node.text?\n          CONTINUE\n        else\n          node.before node.children\n          node.remove\n        end\n      end\n    end\n  end\nend\n", "require \"minitest/autorun\"\nrequire \"rails-html-sanitizer\"\nrequire \"rails/dom/testing/assertions/dom_assertions\"\n\nputs Nokogiri::VERSION_INFO\n\nclass SanitizersTest < Minitest::Test\n  include Rails::Dom::Testing::Assertions::DomAssertions\n\n  def test_sanitizer_sanitize_raises_not_implemented_error\n    assert_raises NotImplementedError do\n      Rails::Html::Sanitizer.new.sanitize('')\n    end\n  end\n\n  def test_sanitize_nested_script\n    assert_equal '&lt;script&gt;alert(\"XSS\");&lt;/script&gt;', safe_list_sanitize('<script><script></script>alert(\"XSS\");<script><</script>/</script><script>script></script>', tags: %w(em))\n  end\n\n  def test_sanitize_nested_script_in_style\n    assert_equal '&lt;script&gt;alert(\"XSS\");&lt;/script&gt;', safe_list_sanitize('<style><script></style>alert(\"XSS\");<style><</style>/</style><style>script></style>', tags: %w(em))\n  end\n\n  class XpathRemovalTestSanitizer < Rails::Html::Sanitizer\n    def sanitize(html, options = {})\n      fragment = Loofah.fragment(html)\n      remove_xpaths(fragment, options[:xpaths]).to_s\n    end\n  end\n\n  def test_remove_xpaths_removes_an_xpath\n    html = %(<h1>hello <script>code!</script></h1>)\n    assert_equal %(<h1>hello </h1>), xpath_sanitize(html, xpaths: %w(.//script))\n  end\n\n  def test_remove_xpaths_removes_all_occurrences_of_xpath\n    html = %(<section><header><script>code!</script></header><p>hello <script>code!</script></p></section>)\n    assert_equal %(<section><header></header><p>hello </p></section>), xpath_sanitize(html, xpaths: %w(.//script))\n  end\n\n  def test_remove_xpaths_called_with_faulty_xpath\n    assert_raises Nokogiri::XML::XPath::SyntaxError do\n      xpath_sanitize('<h1>hello<h1>', xpaths: %w(..faulty_xpath))\n    end\n  end\n\n  def test_remove_xpaths_called_with_xpath_string\n    assert_equal '', xpath_sanitize('<a></a>', xpaths: './/a')\n  end\n\n  def test_remove_xpaths_called_with_enumerable_xpaths\n    assert_equal '', xpath_sanitize('<a><span></span></a>', xpaths: %w(.//a .//span))\n  end\n\n  def test_strip_tags_with_quote\n    input = '<\" <img src=\"trollface.gif\" onload=\"alert(1)\"> hi'\n    expected = libxml_2_9_14_recovery_lt? ? %{&lt;\"  hi} : %{ hi}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_invalid_html\n    assert_equal \"&lt;&lt;\", full_sanitize(\"<<<bad html\")\n  end\n\n  def test_strip_nested_tags\n    expected = \"Wei&lt;a onclick='alert(document.cookie);'/&gt;rdos\"\n    input = \"Wei<<a>a onclick='alert(document.cookie);'</a>/>rdos\"\n    assert_equal expected, full_sanitize(input)\n  end\n\n  def test_strip_tags_multiline\n    expected = %{This is a test.\\n\\n\\n\\nIt no longer contains any HTML.\\n}\n    input = %{<title>This is <b>a <a href=\"\" target=\"_blank\">test</a></b>.</title>\\n\\n<!-- it has a comment -->\\n\\n<p>It no <b>longer <strong>contains <em>any <strike>HTML</strike></em>.</strong></b></p>\\n}\n\n    assert_equal expected, full_sanitize(input)\n  end\n\n  def test_remove_unclosed_tags\n    input = \"This is <-- not\\n a comment here.\"\n    expected = libxml_2_9_14_recovery_lt? ? %{This is &lt;-- not\\n a comment here.} : %{This is }\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_cdata\n    input = \"This has a <![CDATA[<section>]]> here.\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{This has a &lt;![CDATA[]]&gt; here.} : %{This has a ]]&gt; here.}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_unclosed_cdata\n    input = \"This has an unclosed <![CDATA[<section>]] here...\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{This has an unclosed &lt;![CDATA[]] here...} : %{This has an unclosed ]] here...}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_blank_string\n    assert_nil full_sanitize(nil)\n    assert_equal \"\", full_sanitize(\"\")\n    assert_equal \"   \", full_sanitize(\"   \")\n  end\n\n  def test_strip_tags_with_plaintext\n    assert_equal \"Don't touch me\", full_sanitize(\"Don't touch me\")\n  end\n\n  def test_strip_tags_with_tags\n    assert_equal \"This is a test.\", full_sanitize(\"<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>\")\n  end\n\n  def test_escape_tags_with_many_open_quotes\n    assert_equal \"&lt;&lt;\", full_sanitize(\"<<<bad html>\")\n  end\n\n  def test_strip_tags_with_sentence\n    assert_equal \"This is a test.\", full_sanitize(\"This is a test.\")\n  end\n\n  def test_strip_tags_with_comment\n    assert_equal \"This has a  here.\", full_sanitize(\"This has a <!-- comment --> here.\")\n  end\n\n  def test_strip_tags_with_frozen_string\n    assert_equal \"Frozen string with no tags\", full_sanitize(\"Frozen string with no tags\".freeze)\n  end\n\n  def test_full_sanitize_respect_html_escaping_of_the_given_string\n    assert_equal 'test\\r\\nstring', full_sanitize('test\\r\\nstring')\n    assert_equal '&amp;', full_sanitize('&')\n    assert_equal '&amp;', full_sanitize('&amp;')\n    assert_equal '&amp;amp;', full_sanitize('&amp;amp;')\n    assert_equal 'omg &lt;script&gt;BOM&lt;/script&gt;', full_sanitize('omg &lt;script&gt;BOM&lt;/script&gt;')\n  end\n\n  def test_strip_links_with_tags_in_tags\n    expected = \"&lt;a href='hello'&gt;all <b>day</b> long&lt;/a&gt;\"\n    input = \"<<a>a href='hello'>all <b>day</b> long<</A>/a>\"\n    assert_equal expected, link_sanitize(input)\n  end\n\n  def test_strip_links_with_unclosed_tags\n    assert_equal \"\", link_sanitize(\"<a<a\")\n  end\n\n  def test_strip_links_with_plaintext\n    assert_equal \"Don't touch me\", link_sanitize(\"Don't touch me\")\n  end\n\n  def test_strip_links_with_line_feed_and_uppercase_tag\n    assert_equal \"on my mind\\nall day long\", link_sanitize(\"<a href='almost'>on my mind</a>\\n<A href='almost'>all day long</A>\")\n  end\n\n  def test_strip_links_leaves_nonlink_tags\n    assert_equal \"My mind\\nall <b>day</b> long\", link_sanitize(\"<a href='almost'>My mind</a>\\n<A href='almost'>all <b>day</b> long</A>\")\n  end\n\n  def test_strip_links_with_links\n    assert_equal \"0wn3d\", link_sanitize(\"<a href='http://www.rubyonrails.com/'><a href='http://www.rubyonrails.com/' onlclick='steal()'>0wn3d</a></a>\")\n  end\n\n  def test_strip_links_with_linkception\n    assert_equal \"Magic\", link_sanitize(\"<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic\")\n  end\n\n  def test_sanitize_form\n    assert_sanitized \"<form action=\\\"/foo/bar\\\" method=\\\"post\\\"><input></form>\", ''\n  end\n\n  def test_sanitize_plaintext\n    assert_sanitized \"<plaintext><span>foo</span></plaintext>\", \"<span>foo</span>\"\n  end\n\n  def test_sanitize_script\n    assert_sanitized \"a b c<script language=\\\"Javascript\\\">blah blah blah</script>d e f\", \"a b cblah blah blahd e f\"\n  end\n\n  def test_sanitize_js_handlers\n    raw = %{onthis=\"do that\" <a href=\"#\" onclick=\"hello\" name=\"foo\" onbogus=\"remove me\">hello</a>}\n    assert_sanitized raw, %{onthis=\"do that\" <a href=\"#\" name=\"foo\">hello</a>}\n  end\n\n  def test_sanitize_javascript_href\n    raw = %{href=\"javascript:bang\" <a href=\"javascript:bang\" name=\"hello\">foo</a>, <span href=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{href=\"javascript:bang\" <a name=\"hello\">foo</a>, <span>bar</span>}\n  end\n\n  def test_sanitize_image_src\n    raw = %{src=\"javascript:bang\" <img src=\"javascript:bang\" width=\"5\">foo</img>, <span src=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{src=\"javascript:bang\" <img width=\"5\">foo</img>, <span>bar</span>}\n  end\n\n  tags = Loofah::HTML5::SafeList::ALLOWED_ELEMENTS - %w(script form)\n  tags.each do |tag_name|\n    define_method \"test_should_allow_#{tag_name}_tag\" do\n      scope_allowed_tags(tags) do\n        assert_sanitized \"start <#{tag_name} title=\\\"1\\\" onclick=\\\"foo\\\">foo <bad>bar</bad> baz</#{tag_name}> end\", %(start <#{tag_name} title=\"1\">foo bar baz</#{tag_name}> end)\n      end\n    end\n  end\n\n  def test_should_allow_anchors\n    assert_sanitized %(<a href=\"foo\" onclick=\"bar\"><script>baz</script></a>), %(<a href=\\\"foo\\\">baz</a>)\n  end\n\n  def test_video_poster_sanitization\n    scope_allowed_tags(%w(video)) do\n      scope_allowed_attributes %w(src poster) do\n        assert_sanitized %(<video src=\"videofile.ogg\" autoplay  poster=\"posterimage.jpg\"></video>), %(<video src=\"videofile.ogg\" poster=\"posterimage.jpg\"></video>)\n        assert_sanitized %(<video src=\"videofile.ogg\" poster=javascript:alert(1)></video>), %(<video src=\"videofile.ogg\"></video>)\n      end\n    end\n  end\n\n  # RFC 3986, sec 4.2\n  def test_allow_colons_in_path_component\n    assert_sanitized \"<a href=\\\"./this:that\\\">foo</a>\"\n  end\n\n  %w(src width height alt).each do |img_attr|\n    define_method \"test_should_allow_image_#{img_attr}_attribute\" do\n      assert_sanitized %(<img #{img_attr}=\"foo\" onclick=\"bar\" />), %(<img #{img_attr}=\"foo\" />)\n    end\n  end\n\n  def test_should_handle_non_html\n    assert_sanitized 'abc'\n  end\n\n  def test_should_handle_blank_text\n    [nil, '', '   '].each { |blank| assert_sanitized blank }\n  end\n\n  def test_setting_allowed_tags_affects_sanitization\n    scope_allowed_tags %w(u) do |sanitizer|\n      assert_equal '<u></u>', sanitizer.sanitize('<a><u></u></a>')\n    end\n  end\n\n  def test_setting_allowed_attributes_affects_sanitization\n    scope_allowed_attributes %w(foo) do |sanitizer|\n      input = '<a foo=\"hello\" bar=\"world\"></a>'\n      assert_equal '<a foo=\"hello\"></a>', sanitizer.sanitize(input)\n    end\n  end\n\n  def test_custom_tags_overrides_allowed_tags\n    scope_allowed_tags %(u) do |sanitizer|\n      input = '<a><u></u></a>'\n      assert_equal '<a></a>', sanitizer.sanitize(input, tags: %w(a))\n    end\n  end\n\n  def test_custom_attributes_overrides_allowed_attributes\n    scope_allowed_attributes %(foo) do |sanitizer|\n      input = '<a foo=\"hello\" bar=\"world\"></a>'\n      assert_equal '<a bar=\"world\"></a>', sanitizer.sanitize(input, attributes: %w(bar))\n    end\n  end\n\n  def test_should_allow_prune\n    sanitizer = Rails::Html::SafeListSanitizer.new(prune: true)\n    text = '<u>leave me <b>now</b></u>'\n    assert_equal \"<u>leave me </u>\", sanitizer.sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_custom_tags\n    text = \"<u>foo</u>\"\n    assert_equal text, safe_list_sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_only_custom_tags\n    text = \"<u>foo</u> with <i>bar</i>\"\n    assert_equal \"<u>foo</u> with bar\", safe_list_sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_custom_tags_with_attributes\n    text = %(<blockquote cite=\"http://example.com/\">foo</blockquote>)\n    assert_equal text, safe_list_sanitize(text)\n  end\n\n  def test_should_allow_custom_tags_with_custom_attributes\n    text = %(<blockquote foo=\"bar\">Lorem ipsum</blockquote>)\n    assert_equal text, safe_list_sanitize(text, attributes: ['foo'])\n  end\n\n  def test_scrub_style_if_style_attribute_option_is_passed\n    input = '<p style=\"color: #000; background-image: url(http://www.ragingplatypus.com/i/cam-full.jpg);\"></p>'\n    actual = safe_list_sanitize(input, attributes: %w(style))\n    assert_includes(['<p style=\"color: #000;\"></p>', '<p style=\"color:#000;\"></p>'], actual)\n  end\n\n  def test_should_raise_argument_error_if_tags_is_not_enumerable\n    assert_raises ArgumentError do\n      safe_list_sanitize('<a>some html</a>', tags: 'foo')\n    end\n  end\n\n  def test_should_raise_argument_error_if_attributes_is_not_enumerable\n    assert_raises ArgumentError do\n      safe_list_sanitize('<a>some html</a>', attributes: 'foo')\n    end\n  end\n\n  def test_should_not_accept_non_loofah_inheriting_scrubber\n    scrubber = Object.new\n    def scrubber.scrub(node); node.name = 'h1'; end\n\n    assert_raises Loofah::ScrubberNotFound do\n      safe_list_sanitize('<a>some html</a>', scrubber: scrubber)\n    end\n  end\n\n  def test_should_accept_loofah_inheriting_scrubber\n    scrubber = Loofah::Scrubber.new\n    def scrubber.scrub(node); node.name = 'h1'; end\n\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber)\n  end\n\n  def test_should_accept_loofah_scrubber_that_wraps_a_block\n    scrubber = Loofah::Scrubber.new { |node| node.name = 'h1' }\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber)\n  end\n\n  def test_custom_scrubber_takes_precedence_over_other_options\n    scrubber = Loofah::Scrubber.new { |node| node.name = 'h1' }\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber, tags: ['foo'])\n  end\n\n  [%w(img src), %w(a href)].each do |(tag, attr)|\n    define_method \"test_should_strip_#{attr}_attribute_in_#{tag}_with_bad_protocols\" do\n      assert_sanitized %(<#{tag} #{attr}=\"javascript:bang\" title=\"1\">boo</#{tag}>), %(<#{tag} title=\"1\">boo</#{tag}>)\n    end\n  end\n\n  def test_should_block_script_tag\n    assert_sanitized %(<SCRIPT\\nSRC=http://ha.ckers.org/xss.js></SCRIPT>), \"\"\n  end\n\n  def test_should_not_fall_for_xss_image_hack_with_uppercase_tags\n    assert_sanitized %(<IMG \"\"\"><SCRIPT>alert(\"XSS\")</SCRIPT>\">), %(<img>alert(\"XSS\")\"&gt;)\n  end\n\n  [%(<IMG SRC=\"javascript:alert('XSS');\">),\n   %(<IMG SRC=javascript:alert('XSS')>),\n   %(<IMG SRC=JaVaScRiPt:alert('XSS')>),\n   %(<IMG SRC=javascript:alert(&quot;XSS&quot;)>),\n   %(<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>),\n   %(<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>),\n   %(<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>),\n   %(<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>),\n   %(<IMG SRC=\"jav\\tascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x09;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0A;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0D;ascript:alert('XSS');\">),\n   %(<IMG SRC=\" &#14;  javascript:alert('XSS');\">),\n   %(<IMG SRC=\"javascript&#x3a;alert('XSS');\">),\n   %(<IMG SRC=`javascript:alert(\"RSnake says, 'XSS'\")`>)].each do |img_hack|\n    define_method \"test_should_not_fall_for_xss_image_hack_#{img_hack}\" do\n      assert_sanitized img_hack, \"<img>\"\n    end\n  end\n\n  def test_should_sanitize_tag_broken_up_by_null\n    assert_sanitized %(<SCR\\0IPT>alert(\\\"XSS\\\")</SCR\\0IPT>), \"\"\n  end\n\n  def test_should_sanitize_invalid_script_tag\n    assert_sanitized %(<SCRIPT/XSS SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>), \"\"\n  end\n\n  def test_should_sanitize_script_tag_with_multiple_open_brackets\n    assert_sanitized %(<<SCRIPT>alert(\"XSS\");//<</SCRIPT>), \"&lt;alert(\\\"XSS\\\");//&lt;\"\n    assert_sanitized %(<iframe src=http://ha.ckers.org/scriptlet.html\\n<a), \"\"\n  end\n\n  def test_should_sanitize_unclosed_script\n    assert_sanitized %(<SCRIPT SRC=http://ha.ckers.org/xss.js?<B>), \"\"\n  end\n\n  def test_should_sanitize_half_open_scripts\n    assert_sanitized %(<IMG SRC=\"javascript:alert('XSS')\"), \"<img>\"\n  end\n\n  def test_should_not_fall_for_ridiculous_hack\n    img_hack = %(<IMG\\nSRC\\n=\\n\"\\nj\\na\\nv\\na\\ns\\nc\\nr\\ni\\np\\nt\\n:\\na\\nl\\ne\\nr\\nt\\n(\\n'\\nX\\nS\\nS\\n'\\n)\\n\"\\n>)\n    assert_sanitized img_hack, \"<img>\"\n  end\n\n  def test_should_sanitize_attributes\n    assert_sanitized %(<SPAN title=\"'><script>alert()</script>\">blah</SPAN>), %(<span title=\"#{CGI.escapeHTML \"'><script>alert()</script>\"}\">blah</span>)\n  end\n\n  def test_should_sanitize_illegal_style_properties\n    raw      = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;)\n    expected = %(display:block;width:100%;height:100%;background-color:black;background-x:center;background-y:center;)\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_with_trailing_space\n    raw = \"display:block; \"\n    expected = \"display:block;\"\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_xul_style_attributes\n    raw = %(-moz-binding:url('http://ha.ckers.org/xssmoz.xml#xss'))\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_invalid_tag_names\n    assert_sanitized(%(a b c<script/XSS src=\"http://ha.ckers.org/xss.js\"></script>d e f), \"a b cd e f\")\n  end\n\n  def test_should_sanitize_non_alpha_and_non_digit_characters_in_tags\n    assert_sanitized('<a onclick!#$%&()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")>foo</a>', \"<a>foo</a>\")\n  end\n\n  def test_should_sanitize_invalid_tag_names_in_single_tags\n    assert_sanitized('<img/src=\"http://ha.ckers.org/xss.js\"/>', \"<img />\")\n  end\n\n  def test_should_sanitize_img_dynsrc_lowsrc\n    assert_sanitized(%(<img lowsrc=\"javascript:alert('XSS')\" />), \"<img />\")\n  end\n\n  def test_should_sanitize_div_background_image_unicode_encoded\n    [\n      convert_to_css_hex(\"url(javascript:alert(1))\", false),\n      convert_to_css_hex(\"url(javascript:alert(1))\", true),\n      convert_to_css_hex(\"url(https://example.com)\", false),\n      convert_to_css_hex(\"url(https://example.com)\", true),\n    ].each do |propval|\n      raw = \"background-image:\" + propval\n      assert_empty(sanitize_css(raw))\n    end\n  end\n\n  def test_should_allow_div_background_image_unicode_encoded_safe_functions\n    [\n      convert_to_css_hex(\"rgb(255,0,0)\", false),\n      convert_to_css_hex(\"rgb(255,0,0)\", true),\n    ].each do |propval|\n      raw = \"background-image:\" + propval\n      assert_includes(sanitize_css(raw), \"background-image\")\n    end\n  end\n\n  def test_should_sanitize_div_style_expression\n    raw = %(width: expression(alert('XSS'));)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_across_newlines\n    raw = %(\\nwidth:\\nexpression(alert('XSS'));\\n)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_img_vbscript\n    assert_sanitized %(<img src='vbscript:msgbox(\"XSS\")' />), '<img />'\n  end\n\n  def test_should_sanitize_cdata_section\n    input = \"<![CDATA[<span>section</span>]]>\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{&lt;![CDATA[<span>section</span>]]&gt;} : %{section]]&gt;}\n    assert_sanitized(input, expected)\n  end\n\n  def test_should_sanitize_unterminated_cdata_section\n    input = \"<![CDATA[<span>neverending...\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{&lt;![CDATA[<span>neverending...</span>} : %{neverending...}\n    assert_sanitized(input, expected)\n  end\n\n  def test_should_not_mangle_urls_with_ampersand\n     assert_sanitized %{<a href=\\\"http://www.domain.com?var1=1&amp;var2=2\\\">my link</a>}\n  end\n\n  def test_should_sanitize_neverending_attribute\n    assert_sanitized \"<span class=\\\"\\\\\", \"<span class=\\\"\\\\\\\">\"\n  end\n\n  [\n    %(<a href=\"javascript&#x3a;alert('XSS');\">),\n    %(<a href=\"javascript&#x003a;alert('XSS');\">),\n    %(<a href=\"javascript&#x3A;alert('XSS');\">),\n    %(<a href=\"javascript&#x003A;alert('XSS');\">)\n  ].each_with_index do |enc_hack, i|\n    define_method \"test_x03a_handling_#{i+1}\" do\n      assert_sanitized enc_hack, \"<a>\"\n    end\n  end\n\n  def test_x03a_legitimate\n    assert_sanitized %(<a href=\"http&#x3a;//legit\">), %(<a href=\"http://legit\">)\n    assert_sanitized %(<a href=\"http&#x3A;//legit\">), %(<a href=\"http://legit\">)\n  end\n\n  def test_sanitize_ascii_8bit_string\n    safe_list_sanitize('<a>hello</a>'.encode('ASCII-8BIT')).tap do |sanitized|\n      assert_equal '<a>hello</a>', sanitized\n      assert_equal Encoding::UTF_8, sanitized.encoding\n    end\n  end\n\n  def test_sanitize_data_attributes\n    assert_sanitized %(<a href=\"/blah\" data-method=\"post\">foo</a>), %(<a href=\"/blah\">foo</a>)\n    assert_sanitized %(<a data-remote=\"true\" data-type=\"script\" data-method=\"get\" data-cross-domain=\"true\" href=\"attack.js\">Launch the missiles</a>), %(<a href=\"attack.js\">Launch the missiles</a>)\n  end\n\n  def test_allow_data_attribute_if_requested\n    text = %(<a data-foo=\"foo\">foo</a>)\n    assert_equal %(<a data-foo=\"foo\">foo</a>), safe_list_sanitize(text, attributes: ['data-foo'])\n  end\n\n  def test_uri_escaping_of_href_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a href='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a href=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/ system libxml2\n      %{<a href=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_src_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a src='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a src=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a src=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_name_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a name='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a name=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a name=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_name_action_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a action='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html, attributes: ['action'])\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a action=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a action=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_exclude_node_type_processing_instructions\n    assert_equal(\"<div>text</div><b>text</b>\", safe_list_sanitize(\"<div>text</div><?div content><b>text</b>\"))\n  end\n\n  def test_exclude_node_type_comment\n    assert_equal(\"<div>text</div><b>text</b>\", safe_list_sanitize(\"<div>text</div><!-- comment --><b>text</b>\"))\n  end\n\n  def test_disallow_the_dangerous_safelist_combination_of_select_and_style\n    input = \"<select><style><script>alert(1)</script></style></select>\"\n    tags = [\"select\", \"style\"]\n    warning = /WARNING: Rails::Html::SafeListSanitizer: removing 'style' from safelist/\n    sanitized = nil\n    invocation = Proc.new { sanitized = safe_list_sanitize(input, tags: tags) }\n\n    if html5_mode?\n      # if Loofah is using an HTML5 parser,\n      #   then \"style\" should be removed by the parser as an invalid child of \"select\"\n      assert_silent(&invocation)\n    else\n      # if Loofah is using an HTML4 parser,\n      #   then SafeListSanitizer should remove \"style\" from the safelist\n      assert_output(nil, warning, &invocation)\n    end\n    refute_includes(sanitized, \"style\")\n  end\n\nprotected\n\n  def xpath_sanitize(input, options = {})\n    XpathRemovalTestSanitizer.new.sanitize(input, options)\n  end\n\n  def full_sanitize(input, options = {})\n    Rails::Html::FullSanitizer.new.sanitize(input, options)\n  end\n\n  def link_sanitize(input, options = {})\n    Rails::Html::LinkSanitizer.new.sanitize(input, options)\n  end\n\n  def safe_list_sanitize(input, options = {})\n    Rails::Html::SafeListSanitizer.new.sanitize(input, options)\n  end\n\n  def assert_sanitized(input, expected = nil)\n    if input\n      assert_dom_equal expected || input, safe_list_sanitize(input)\n    else\n      assert_nil safe_list_sanitize(input)\n    end\n  end\n\n  def sanitize_css(input)\n    Rails::Html::SafeListSanitizer.new.sanitize_css(input)\n  end\n\n  def scope_allowed_tags(tags)\n    old_tags = Rails::Html::SafeListSanitizer.allowed_tags\n    Rails::Html::SafeListSanitizer.allowed_tags = tags\n    yield Rails::Html::SafeListSanitizer.new\n  ensure\n    Rails::Html::SafeListSanitizer.allowed_tags = old_tags\n  end\n\n  def scope_allowed_attributes(attributes)\n    old_attributes = Rails::Html::SafeListSanitizer.allowed_attributes\n    Rails::Html::SafeListSanitizer.allowed_attributes = attributes\n    yield Rails::Html::SafeListSanitizer.new\n  ensure\n    Rails::Html::SafeListSanitizer.allowed_attributes = old_attributes\n  end\n\n  # note that this is used for testing CSS hex encoding: \\\\[0-9a-f]{1,6}\n  def convert_to_css_hex(string, escape_parens=false)\n    string.chars.map do |c|\n      if !escape_parens && (c == \"(\" || c == \")\")\n        c\n      else\n        format('\\00%02X', c.ord)\n      end\n    end.join\n  end\n\n  def libxml_2_9_14_recovery_lt?\n    # changed in 2.9.14, see https://github.com/sparklemotion/nokogiri/releases/tag/v1.13.5\n    Nokogiri.method(:uses_libxml?).arity == -1 && Nokogiri.uses_libxml?(\">= 2.9.14\")\n  end\n\n  def libxml_2_9_14_recovery_lt_bang?\n    # changed in 2.9.14, see https://github.com/sparklemotion/nokogiri/releases/tag/v1.13.5\n    # then reverted in 2.10.0, see https://gitlab.gnome.org/GNOME/libxml2/-/issues/380\n    Nokogiri.method(:uses_libxml?).arity == -1 && Nokogiri.uses_libxml?(\"= 2.9.14\")\n  end\n\n  def html5_mode?\n    ::Loofah.respond_to?(:html5_mode?) && ::Loofah.html5_mode?\n  end\nend\n"], "fixing_code": ["module Rails\n  module Html\n    # === Rails::Html::PermitScrubber\n    #\n    # +Rails::Html::PermitScrubber+ allows you to permit only your own tags and/or attributes.\n    #\n    # +Rails::Html::PermitScrubber+ can be subclassed to determine:\n    # - When a node should be skipped via +skip_node?+.\n    # - When a node is allowed via +allowed_node?+.\n    # - When an attribute should be scrubbed via +scrub_attribute?+.\n    #\n    # Subclasses don't need to worry if tags or attributes are set or not.\n    # If tags or attributes are not set, Loofah's behavior will be used.\n    # If you override +allowed_node?+ and no tags are set, it will not be called.\n    # Instead Loofahs behavior will be used.\n    # Likewise for +scrub_attribute?+ and attributes respectively.\n    #\n    # Text and CDATA nodes are skipped by default.\n    # Unallowed elements will be stripped, i.e. element is removed but its subtree kept.\n    # Supplied tags and attributes should be Enumerables.\n    #\n    # +tags=+\n    # If set, elements excluded will be stripped.\n    # If not, elements are stripped based on Loofahs +HTML5::Scrub.allowed_element?+.\n    #\n    # +attributes=+\n    # If set, attributes excluded will be removed.\n    # If not, attributes are removed based on Loofahs +HTML5::Scrub.scrub_attributes+.\n    #\n    #  class CommentScrubber < Html::PermitScrubber\n    #    def initialize\n    #      super\n    #      self.tags = %w(form script comment blockquote)\n    #    end\n    #\n    #    def skip_node?(node)\n    #      node.text?\n    #    end\n    #\n    #    def scrub_attribute?(name)\n    #      name == \"style\"\n    #    end\n    #  end\n    #\n    # See the documentation for +Nokogiri::XML::Node+ to understand what's possible\n    # with nodes: https://nokogiri.org/rdoc/Nokogiri/XML/Node.html\n    class PermitScrubber < Loofah::Scrubber\n      attr_reader :tags, :attributes, :prune\n\n      def initialize(prune: false)\n        @prune = prune\n        @direction = @prune ? :top_down : :bottom_up\n        @tags, @attributes = nil, nil\n      end\n\n      def tags=(tags)\n        @tags = validate!(tags, :tags)\n      end\n\n      def attributes=(attributes)\n        @attributes = validate!(attributes, :attributes)\n      end\n\n      def scrub(node)\n        if node.cdata?\n          text = node.document.create_text_node node.text\n          node.replace text\n          return CONTINUE\n        end\n        return CONTINUE if skip_node?(node)\n\n        unless (node.element? || node.comment?) && keep_node?(node)\n          return STOP if scrub_node(node) == STOP\n        end\n\n        scrub_attributes(node)\n      end\n\n      protected\n\n      def allowed_node?(node)\n        @tags.include?(node.name)\n      end\n\n      def skip_node?(node)\n        node.text?\n      end\n\n      def scrub_attribute?(name)\n        !@attributes.include?(name)\n      end\n\n      def keep_node?(node)\n        if @tags\n          allowed_node?(node)\n        else\n          Loofah::HTML5::Scrub.allowed_element?(node.name)\n        end\n      end\n\n      def scrub_node(node)\n        node.before(node.children) unless prune # strip\n        node.remove\n      end\n\n      def scrub_attributes(node)\n        if @attributes\n          node.attribute_nodes.each do |attr|\n            attr.remove if scrub_attribute?(attr.name)\n            scrub_attribute(node, attr)\n          end\n\n          scrub_css_attribute(node)\n        else\n          Loofah::HTML5::Scrub.scrub_attributes(node)\n        end\n      end\n\n      def scrub_css_attribute(node)\n        if Loofah::HTML5::Scrub.respond_to?(:scrub_css_attribute)\n          Loofah::HTML5::Scrub.scrub_css_attribute(node)\n        else\n          style = node.attributes['style']\n          style.value = Loofah::HTML5::Scrub.scrub_css(style.value) if style\n        end\n      end\n\n      def validate!(var, name)\n        if var && !var.is_a?(Enumerable)\n          raise ArgumentError, \"You should pass :#{name} as an Enumerable\"\n        end\n        var\n      end\n\n      def scrub_attribute(node, attr_node)\n        attr_name = if attr_node.namespace\n                      \"#{attr_node.namespace.prefix}:#{attr_node.node_name}\"\n                    else\n                      attr_node.node_name\n                    end\n\n        if Loofah::HTML5::SafeList::ATTR_VAL_IS_URI.include?(attr_name)\n          # this block lifted nearly verbatim from HTML5 sanitization\n          val_unescaped = CGI.unescapeHTML(attr_node.value).gsub(Loofah::HTML5::Scrub::CONTROL_CHARACTERS,'').downcase\n          if val_unescaped =~ /^[a-z0-9][-+.a-z0-9]*:/ && ! Loofah::HTML5::SafeList::ALLOWED_PROTOCOLS.include?(val_unescaped.split(Loofah::HTML5::SafeList::PROTOCOL_SEPARATOR)[0])\n            attr_node.remove\n          end\n        end\n\n        if Loofah::HTML5::SafeList::SVG_ATTR_VAL_ALLOWS_REF.include?(attr_name)\n          Loofah::HTML5::Scrub.scrub_attribute_that_allows_local_ref(attr_node)\n        end\n\n        if Loofah::HTML5::SafeList::SVG_ALLOW_LOCAL_HREF.include?(node.name) && attr_name == 'xlink:href' && attr_node.value =~ /^\\s*[^#\\s].*/m\n          attr_node.remove\n        end\n\n        node.remove_attribute(attr_node.name) if attr_name == 'src' && attr_node.value !~ /[^[:space:]]/\n\n        Loofah::HTML5::Scrub.force_correct_attribute_escaping! node\n      end\n    end\n\n    # === Rails::Html::TargetScrubber\n    #\n    # Where +Rails::Html::PermitScrubber+ picks out tags and attributes to permit in\n    # sanitization, +Rails::Html::TargetScrubber+ targets them for removal.\n    #\n    # +tags=+\n    # If set, elements included will be stripped.\n    #\n    # +attributes=+\n    # If set, attributes included will be removed.\n    class TargetScrubber < PermitScrubber\n      def allowed_node?(node)\n        !super\n      end\n\n      def scrub_attribute?(name)\n        !super\n      end\n    end\n\n    # === Rails::Html::TextOnlyScrubber\n    #\n    # +Rails::Html::TextOnlyScrubber+ allows you to permit text nodes.\n    #\n    # Unallowed elements will be stripped, i.e. element is removed but its subtree kept.\n    class TextOnlyScrubber < Loofah::Scrubber\n      def initialize\n        @direction = :bottom_up\n      end\n\n      def scrub(node)\n        if node.text?\n          CONTINUE\n        else\n          node.before node.children\n          node.remove\n        end\n      end\n    end\n  end\nend\n", "require \"minitest/autorun\"\nrequire \"rails-html-sanitizer\"\nrequire \"rails/dom/testing/assertions/dom_assertions\"\n\nputs Nokogiri::VERSION_INFO\n\nclass SanitizersTest < Minitest::Test\n  include Rails::Dom::Testing::Assertions::DomAssertions\n\n  def test_sanitizer_sanitize_raises_not_implemented_error\n    assert_raises NotImplementedError do\n      Rails::Html::Sanitizer.new.sanitize('')\n    end\n  end\n\n  def test_sanitize_nested_script\n    assert_equal '&lt;script&gt;alert(\"XSS\");&lt;/script&gt;', safe_list_sanitize('<script><script></script>alert(\"XSS\");<script><</script>/</script><script>script></script>', tags: %w(em))\n  end\n\n  def test_sanitize_nested_script_in_style\n    assert_equal '&lt;script&gt;alert(\"XSS\");&lt;/script&gt;', safe_list_sanitize('<style><script></style>alert(\"XSS\");<style><</style>/</style><style>script></style>', tags: %w(em))\n  end\n\n  class XpathRemovalTestSanitizer < Rails::Html::Sanitizer\n    def sanitize(html, options = {})\n      fragment = Loofah.fragment(html)\n      remove_xpaths(fragment, options[:xpaths]).to_s\n    end\n  end\n\n  def test_remove_xpaths_removes_an_xpath\n    html = %(<h1>hello <script>code!</script></h1>)\n    assert_equal %(<h1>hello </h1>), xpath_sanitize(html, xpaths: %w(.//script))\n  end\n\n  def test_remove_xpaths_removes_all_occurrences_of_xpath\n    html = %(<section><header><script>code!</script></header><p>hello <script>code!</script></p></section>)\n    assert_equal %(<section><header></header><p>hello </p></section>), xpath_sanitize(html, xpaths: %w(.//script))\n  end\n\n  def test_remove_xpaths_called_with_faulty_xpath\n    assert_raises Nokogiri::XML::XPath::SyntaxError do\n      xpath_sanitize('<h1>hello<h1>', xpaths: %w(..faulty_xpath))\n    end\n  end\n\n  def test_remove_xpaths_called_with_xpath_string\n    assert_equal '', xpath_sanitize('<a></a>', xpaths: './/a')\n  end\n\n  def test_remove_xpaths_called_with_enumerable_xpaths\n    assert_equal '', xpath_sanitize('<a><span></span></a>', xpaths: %w(.//a .//span))\n  end\n\n  def test_strip_tags_with_quote\n    input = '<\" <img src=\"trollface.gif\" onload=\"alert(1)\"> hi'\n    expected = libxml_2_9_14_recovery_lt? ? %{&lt;\"  hi} : %{ hi}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_invalid_html\n    assert_equal \"&lt;&lt;\", full_sanitize(\"<<<bad html\")\n  end\n\n  def test_strip_nested_tags\n    expected = \"Wei&lt;a onclick='alert(document.cookie);'/&gt;rdos\"\n    input = \"Wei<<a>a onclick='alert(document.cookie);'</a>/>rdos\"\n    assert_equal expected, full_sanitize(input)\n  end\n\n  def test_strip_tags_multiline\n    expected = %{This is a test.\\n\\n\\n\\nIt no longer contains any HTML.\\n}\n    input = %{<title>This is <b>a <a href=\"\" target=\"_blank\">test</a></b>.</title>\\n\\n<!-- it has a comment -->\\n\\n<p>It no <b>longer <strong>contains <em>any <strike>HTML</strike></em>.</strong></b></p>\\n}\n\n    assert_equal expected, full_sanitize(input)\n  end\n\n  def test_remove_unclosed_tags\n    input = \"This is <-- not\\n a comment here.\"\n    expected = libxml_2_9_14_recovery_lt? ? %{This is &lt;-- not\\n a comment here.} : %{This is }\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_cdata\n    input = \"This has a <![CDATA[<section>]]> here.\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{This has a &lt;![CDATA[]]&gt; here.} : %{This has a ]]&gt; here.}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_unclosed_cdata\n    input = \"This has an unclosed <![CDATA[<section>]] here...\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{This has an unclosed &lt;![CDATA[]] here...} : %{This has an unclosed ]] here...}\n    assert_equal(expected, full_sanitize(input))\n  end\n\n  def test_strip_blank_string\n    assert_nil full_sanitize(nil)\n    assert_equal \"\", full_sanitize(\"\")\n    assert_equal \"   \", full_sanitize(\"   \")\n  end\n\n  def test_strip_tags_with_plaintext\n    assert_equal \"Don't touch me\", full_sanitize(\"Don't touch me\")\n  end\n\n  def test_strip_tags_with_tags\n    assert_equal \"This is a test.\", full_sanitize(\"<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>\")\n  end\n\n  def test_escape_tags_with_many_open_quotes\n    assert_equal \"&lt;&lt;\", full_sanitize(\"<<<bad html>\")\n  end\n\n  def test_strip_tags_with_sentence\n    assert_equal \"This is a test.\", full_sanitize(\"This is a test.\")\n  end\n\n  def test_strip_tags_with_comment\n    assert_equal \"This has a  here.\", full_sanitize(\"This has a <!-- comment --> here.\")\n  end\n\n  def test_strip_tags_with_frozen_string\n    assert_equal \"Frozen string with no tags\", full_sanitize(\"Frozen string with no tags\".freeze)\n  end\n\n  def test_full_sanitize_respect_html_escaping_of_the_given_string\n    assert_equal 'test\\r\\nstring', full_sanitize('test\\r\\nstring')\n    assert_equal '&amp;', full_sanitize('&')\n    assert_equal '&amp;', full_sanitize('&amp;')\n    assert_equal '&amp;amp;', full_sanitize('&amp;amp;')\n    assert_equal 'omg &lt;script&gt;BOM&lt;/script&gt;', full_sanitize('omg &lt;script&gt;BOM&lt;/script&gt;')\n  end\n\n  def test_strip_links_with_tags_in_tags\n    expected = \"&lt;a href='hello'&gt;all <b>day</b> long&lt;/a&gt;\"\n    input = \"<<a>a href='hello'>all <b>day</b> long<</A>/a>\"\n    assert_equal expected, link_sanitize(input)\n  end\n\n  def test_strip_links_with_unclosed_tags\n    assert_equal \"\", link_sanitize(\"<a<a\")\n  end\n\n  def test_strip_links_with_plaintext\n    assert_equal \"Don't touch me\", link_sanitize(\"Don't touch me\")\n  end\n\n  def test_strip_links_with_line_feed_and_uppercase_tag\n    assert_equal \"on my mind\\nall day long\", link_sanitize(\"<a href='almost'>on my mind</a>\\n<A href='almost'>all day long</A>\")\n  end\n\n  def test_strip_links_leaves_nonlink_tags\n    assert_equal \"My mind\\nall <b>day</b> long\", link_sanitize(\"<a href='almost'>My mind</a>\\n<A href='almost'>all <b>day</b> long</A>\")\n  end\n\n  def test_strip_links_with_links\n    assert_equal \"0wn3d\", link_sanitize(\"<a href='http://www.rubyonrails.com/'><a href='http://www.rubyonrails.com/' onlclick='steal()'>0wn3d</a></a>\")\n  end\n\n  def test_strip_links_with_linkception\n    assert_equal \"Magic\", link_sanitize(\"<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic\")\n  end\n\n  def test_sanitize_form\n    assert_sanitized \"<form action=\\\"/foo/bar\\\" method=\\\"post\\\"><input></form>\", ''\n  end\n\n  def test_sanitize_plaintext\n    assert_sanitized \"<plaintext><span>foo</span></plaintext>\", \"<span>foo</span>\"\n  end\n\n  def test_sanitize_script\n    assert_sanitized \"a b c<script language=\\\"Javascript\\\">blah blah blah</script>d e f\", \"a b cblah blah blahd e f\"\n  end\n\n  def test_sanitize_js_handlers\n    raw = %{onthis=\"do that\" <a href=\"#\" onclick=\"hello\" name=\"foo\" onbogus=\"remove me\">hello</a>}\n    assert_sanitized raw, %{onthis=\"do that\" <a href=\"#\" name=\"foo\">hello</a>}\n  end\n\n  def test_sanitize_javascript_href\n    raw = %{href=\"javascript:bang\" <a href=\"javascript:bang\" name=\"hello\">foo</a>, <span href=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{href=\"javascript:bang\" <a name=\"hello\">foo</a>, <span>bar</span>}\n  end\n\n  def test_sanitize_image_src\n    raw = %{src=\"javascript:bang\" <img src=\"javascript:bang\" width=\"5\">foo</img>, <span src=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{src=\"javascript:bang\" <img width=\"5\">foo</img>, <span>bar</span>}\n  end\n\n  tags = Loofah::HTML5::SafeList::ALLOWED_ELEMENTS - %w(script form)\n  tags.each do |tag_name|\n    define_method \"test_should_allow_#{tag_name}_tag\" do\n      scope_allowed_tags(tags) do\n        assert_sanitized \"start <#{tag_name} title=\\\"1\\\" onclick=\\\"foo\\\">foo <bad>bar</bad> baz</#{tag_name}> end\", %(start <#{tag_name} title=\"1\">foo bar baz</#{tag_name}> end)\n      end\n    end\n  end\n\n  def test_should_allow_anchors\n    assert_sanitized %(<a href=\"foo\" onclick=\"bar\"><script>baz</script></a>), %(<a href=\\\"foo\\\">baz</a>)\n  end\n\n  def test_video_poster_sanitization\n    scope_allowed_tags(%w(video)) do\n      scope_allowed_attributes %w(src poster) do\n        assert_sanitized %(<video src=\"videofile.ogg\" autoplay  poster=\"posterimage.jpg\"></video>), %(<video src=\"videofile.ogg\" poster=\"posterimage.jpg\"></video>)\n        assert_sanitized %(<video src=\"videofile.ogg\" poster=javascript:alert(1)></video>), %(<video src=\"videofile.ogg\"></video>)\n      end\n    end\n  end\n\n  # RFC 3986, sec 4.2\n  def test_allow_colons_in_path_component\n    assert_sanitized \"<a href=\\\"./this:that\\\">foo</a>\"\n  end\n\n  %w(src width height alt).each do |img_attr|\n    define_method \"test_should_allow_image_#{img_attr}_attribute\" do\n      assert_sanitized %(<img #{img_attr}=\"foo\" onclick=\"bar\" />), %(<img #{img_attr}=\"foo\" />)\n    end\n  end\n\n  def test_should_handle_non_html\n    assert_sanitized 'abc'\n  end\n\n  def test_should_handle_blank_text\n    [nil, '', '   '].each { |blank| assert_sanitized blank }\n  end\n\n  def test_setting_allowed_tags_affects_sanitization\n    scope_allowed_tags %w(u) do |sanitizer|\n      assert_equal '<u></u>', sanitizer.sanitize('<a><u></u></a>')\n    end\n  end\n\n  def test_setting_allowed_attributes_affects_sanitization\n    scope_allowed_attributes %w(foo) do |sanitizer|\n      input = '<a foo=\"hello\" bar=\"world\"></a>'\n      assert_equal '<a foo=\"hello\"></a>', sanitizer.sanitize(input)\n    end\n  end\n\n  def test_custom_tags_overrides_allowed_tags\n    scope_allowed_tags %(u) do |sanitizer|\n      input = '<a><u></u></a>'\n      assert_equal '<a></a>', sanitizer.sanitize(input, tags: %w(a))\n    end\n  end\n\n  def test_custom_attributes_overrides_allowed_attributes\n    scope_allowed_attributes %(foo) do |sanitizer|\n      input = '<a foo=\"hello\" bar=\"world\"></a>'\n      assert_equal '<a bar=\"world\"></a>', sanitizer.sanitize(input, attributes: %w(bar))\n    end\n  end\n\n  def test_should_allow_prune\n    sanitizer = Rails::Html::SafeListSanitizer.new(prune: true)\n    text = '<u>leave me <b>now</b></u>'\n    assert_equal \"<u>leave me </u>\", sanitizer.sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_custom_tags\n    text = \"<u>foo</u>\"\n    assert_equal text, safe_list_sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_only_custom_tags\n    text = \"<u>foo</u> with <i>bar</i>\"\n    assert_equal \"<u>foo</u> with bar\", safe_list_sanitize(text, tags: %w(u))\n  end\n\n  def test_should_allow_custom_tags_with_attributes\n    text = %(<blockquote cite=\"http://example.com/\">foo</blockquote>)\n    assert_equal text, safe_list_sanitize(text)\n  end\n\n  def test_should_allow_custom_tags_with_custom_attributes\n    text = %(<blockquote foo=\"bar\">Lorem ipsum</blockquote>)\n    assert_equal text, safe_list_sanitize(text, attributes: ['foo'])\n  end\n\n  def test_scrub_style_if_style_attribute_option_is_passed\n    input = '<p style=\"color: #000; background-image: url(http://www.ragingplatypus.com/i/cam-full.jpg);\"></p>'\n    actual = safe_list_sanitize(input, attributes: %w(style))\n    assert_includes(['<p style=\"color: #000;\"></p>', '<p style=\"color:#000;\"></p>'], actual)\n  end\n\n  def test_should_raise_argument_error_if_tags_is_not_enumerable\n    assert_raises ArgumentError do\n      safe_list_sanitize('<a>some html</a>', tags: 'foo')\n    end\n  end\n\n  def test_should_raise_argument_error_if_attributes_is_not_enumerable\n    assert_raises ArgumentError do\n      safe_list_sanitize('<a>some html</a>', attributes: 'foo')\n    end\n  end\n\n  def test_should_not_accept_non_loofah_inheriting_scrubber\n    scrubber = Object.new\n    def scrubber.scrub(node); node.name = 'h1'; end\n\n    assert_raises Loofah::ScrubberNotFound do\n      safe_list_sanitize('<a>some html</a>', scrubber: scrubber)\n    end\n  end\n\n  def test_should_accept_loofah_inheriting_scrubber\n    scrubber = Loofah::Scrubber.new\n    def scrubber.scrub(node); node.name = 'h1'; end\n\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber)\n  end\n\n  def test_should_accept_loofah_scrubber_that_wraps_a_block\n    scrubber = Loofah::Scrubber.new { |node| node.name = 'h1' }\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber)\n  end\n\n  def test_custom_scrubber_takes_precedence_over_other_options\n    scrubber = Loofah::Scrubber.new { |node| node.name = 'h1' }\n    html = \"<script>hello!</script>\"\n    assert_equal \"<h1>hello!</h1>\", safe_list_sanitize(html, scrubber: scrubber, tags: ['foo'])\n  end\n\n  [%w(img src), %w(a href)].each do |(tag, attr)|\n    define_method \"test_should_strip_#{attr}_attribute_in_#{tag}_with_bad_protocols\" do\n      assert_sanitized %(<#{tag} #{attr}=\"javascript:bang\" title=\"1\">boo</#{tag}>), %(<#{tag} title=\"1\">boo</#{tag}>)\n    end\n  end\n\n  def test_should_block_script_tag\n    assert_sanitized %(<SCRIPT\\nSRC=http://ha.ckers.org/xss.js></SCRIPT>), \"\"\n  end\n\n  def test_should_not_fall_for_xss_image_hack_with_uppercase_tags\n    assert_sanitized %(<IMG \"\"\"><SCRIPT>alert(\"XSS\")</SCRIPT>\">), %(<img>alert(\"XSS\")\"&gt;)\n  end\n\n  [%(<IMG SRC=\"javascript:alert('XSS');\">),\n   %(<IMG SRC=javascript:alert('XSS')>),\n   %(<IMG SRC=JaVaScRiPt:alert('XSS')>),\n   %(<IMG SRC=javascript:alert(&quot;XSS&quot;)>),\n   %(<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>),\n   %(<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>),\n   %(<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>),\n   %(<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>),\n   %(<IMG SRC=\"jav\\tascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x09;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0A;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0D;ascript:alert('XSS');\">),\n   %(<IMG SRC=\" &#14;  javascript:alert('XSS');\">),\n   %(<IMG SRC=\"javascript&#x3a;alert('XSS');\">),\n   %(<IMG SRC=`javascript:alert(\"RSnake says, 'XSS'\")`>)].each do |img_hack|\n    define_method \"test_should_not_fall_for_xss_image_hack_#{img_hack}\" do\n      assert_sanitized img_hack, \"<img>\"\n    end\n  end\n\n  def test_should_sanitize_tag_broken_up_by_null\n    assert_sanitized %(<SCR\\0IPT>alert(\\\"XSS\\\")</SCR\\0IPT>), \"\"\n  end\n\n  def test_should_sanitize_invalid_script_tag\n    assert_sanitized %(<SCRIPT/XSS SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>), \"\"\n  end\n\n  def test_should_sanitize_script_tag_with_multiple_open_brackets\n    assert_sanitized %(<<SCRIPT>alert(\"XSS\");//<</SCRIPT>), \"&lt;alert(\\\"XSS\\\");//&lt;\"\n    assert_sanitized %(<iframe src=http://ha.ckers.org/scriptlet.html\\n<a), \"\"\n  end\n\n  def test_should_sanitize_unclosed_script\n    assert_sanitized %(<SCRIPT SRC=http://ha.ckers.org/xss.js?<B>), \"\"\n  end\n\n  def test_should_sanitize_half_open_scripts\n    assert_sanitized %(<IMG SRC=\"javascript:alert('XSS')\"), \"<img>\"\n  end\n\n  def test_should_not_fall_for_ridiculous_hack\n    img_hack = %(<IMG\\nSRC\\n=\\n\"\\nj\\na\\nv\\na\\ns\\nc\\nr\\ni\\np\\nt\\n:\\na\\nl\\ne\\nr\\nt\\n(\\n'\\nX\\nS\\nS\\n'\\n)\\n\"\\n>)\n    assert_sanitized img_hack, \"<img>\"\n  end\n\n  def test_should_sanitize_attributes\n    assert_sanitized %(<SPAN title=\"'><script>alert()</script>\">blah</SPAN>), %(<span title=\"#{CGI.escapeHTML \"'><script>alert()</script>\"}\">blah</span>)\n  end\n\n  def test_should_sanitize_illegal_style_properties\n    raw      = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;)\n    expected = %(display:block;width:100%;height:100%;background-color:black;background-x:center;background-y:center;)\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_with_trailing_space\n    raw = \"display:block; \"\n    expected = \"display:block;\"\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_xul_style_attributes\n    raw = %(-moz-binding:url('http://ha.ckers.org/xssmoz.xml#xss'))\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_invalid_tag_names\n    assert_sanitized(%(a b c<script/XSS src=\"http://ha.ckers.org/xss.js\"></script>d e f), \"a b cd e f\")\n  end\n\n  def test_should_sanitize_non_alpha_and_non_digit_characters_in_tags\n    assert_sanitized('<a onclick!#$%&()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")>foo</a>', \"<a>foo</a>\")\n  end\n\n  def test_should_sanitize_invalid_tag_names_in_single_tags\n    assert_sanitized('<img/src=\"http://ha.ckers.org/xss.js\"/>', \"<img />\")\n  end\n\n  def test_should_sanitize_img_dynsrc_lowsrc\n    assert_sanitized(%(<img lowsrc=\"javascript:alert('XSS')\" />), \"<img />\")\n  end\n\n  def test_should_sanitize_div_background_image_unicode_encoded\n    [\n      convert_to_css_hex(\"url(javascript:alert(1))\", false),\n      convert_to_css_hex(\"url(javascript:alert(1))\", true),\n      convert_to_css_hex(\"url(https://example.com)\", false),\n      convert_to_css_hex(\"url(https://example.com)\", true),\n    ].each do |propval|\n      raw = \"background-image:\" + propval\n      assert_empty(sanitize_css(raw))\n    end\n  end\n\n  def test_should_allow_div_background_image_unicode_encoded_safe_functions\n    [\n      convert_to_css_hex(\"rgb(255,0,0)\", false),\n      convert_to_css_hex(\"rgb(255,0,0)\", true),\n    ].each do |propval|\n      raw = \"background-image:\" + propval\n      assert_includes(sanitize_css(raw), \"background-image\")\n    end\n  end\n\n  def test_should_sanitize_div_style_expression\n    raw = %(width: expression(alert('XSS'));)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_across_newlines\n    raw = %(\\nwidth:\\nexpression(alert('XSS'));\\n)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_img_vbscript\n    assert_sanitized %(<img src='vbscript:msgbox(\"XSS\")' />), '<img />'\n  end\n\n  def test_should_sanitize_cdata_section\n    input = \"<![CDATA[<span>section</span>]]>\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{&lt;![CDATA[<span>section</span>]]&gt;} : %{section]]&gt;}\n    assert_sanitized(input, expected)\n  end\n\n  def test_should_sanitize_unterminated_cdata_section\n    input = \"<![CDATA[<span>neverending...\"\n    expected = libxml_2_9_14_recovery_lt_bang? ? %{&lt;![CDATA[<span>neverending...</span>} : %{neverending...}\n    assert_sanitized(input, expected)\n  end\n\n  def test_should_not_mangle_urls_with_ampersand\n     assert_sanitized %{<a href=\\\"http://www.domain.com?var1=1&amp;var2=2\\\">my link</a>}\n  end\n\n  def test_should_sanitize_neverending_attribute\n    assert_sanitized \"<span class=\\\"\\\\\", \"<span class=\\\"\\\\\\\">\"\n  end\n\n  [\n    %(<a href=\"javascript&#x3a;alert('XSS');\">),\n    %(<a href=\"javascript&#x003a;alert('XSS');\">),\n    %(<a href=\"javascript&#x3A;alert('XSS');\">),\n    %(<a href=\"javascript&#x003A;alert('XSS');\">)\n  ].each_with_index do |enc_hack, i|\n    define_method \"test_x03a_handling_#{i+1}\" do\n      assert_sanitized enc_hack, \"<a>\"\n    end\n  end\n\n  def test_x03a_legitimate\n    assert_sanitized %(<a href=\"http&#x3a;//legit\">), %(<a href=\"http://legit\">)\n    assert_sanitized %(<a href=\"http&#x3A;//legit\">), %(<a href=\"http://legit\">)\n  end\n\n  def test_sanitize_ascii_8bit_string\n    safe_list_sanitize('<a>hello</a>'.encode('ASCII-8BIT')).tap do |sanitized|\n      assert_equal '<a>hello</a>', sanitized\n      assert_equal Encoding::UTF_8, sanitized.encoding\n    end\n  end\n\n  def test_sanitize_data_attributes\n    assert_sanitized %(<a href=\"/blah\" data-method=\"post\">foo</a>), %(<a href=\"/blah\">foo</a>)\n    assert_sanitized %(<a data-remote=\"true\" data-type=\"script\" data-method=\"get\" data-cross-domain=\"true\" href=\"attack.js\">Launch the missiles</a>), %(<a href=\"attack.js\">Launch the missiles</a>)\n  end\n\n  def test_allow_data_attribute_if_requested\n    text = %(<a data-foo=\"foo\">foo</a>)\n    assert_equal %(<a data-foo=\"foo\">foo</a>), safe_list_sanitize(text, attributes: ['data-foo'])\n  end\n\n  def test_uri_escaping_of_href_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a href='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a href=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/ system libxml2\n      %{<a href=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_src_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a src='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a src=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a src=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_name_attr_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a name='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html)\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a name=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a name=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_uri_escaping_of_name_action_in_a_tag_in_safe_list_sanitizer\n    skip if RUBY_VERSION < \"2.3\"\n\n    html = %{<a action='examp<!--\" unsafeattr=foo()>-->le.com'>test</a>}\n\n    text = safe_list_sanitize(html, attributes: ['action'])\n\n    acceptable_results = [\n      # nokogiri w/vendored+patched libxml2\n      %{<a action=\"examp&lt;!--%22%20unsafeattr=foo()&gt;--&gt;le.com\">test</a>},\n      # nokogiri w/system libxml2\n      %{<a action=\"examp<!--%22%20unsafeattr=foo()>-->le.com\">test</a>},\n    ]\n    assert_includes(acceptable_results, text)\n  end\n\n  def test_exclude_node_type_processing_instructions\n    assert_equal(\"<div>text</div><b>text</b>\", safe_list_sanitize(\"<div>text</div><?div content><b>text</b>\"))\n  end\n\n  def test_exclude_node_type_comment\n    assert_equal(\"<div>text</div><b>text</b>\", safe_list_sanitize(\"<div>text</div><!-- comment --><b>text</b>\"))\n  end\n\n  def test_disallow_the_dangerous_safelist_combination_of_select_and_style\n    input = \"<select><style><script>alert(1)</script></style></select>\"\n    tags = [\"select\", \"style\"]\n    warning = /WARNING: Rails::Html::SafeListSanitizer: removing 'style' from safelist/\n    sanitized = nil\n    invocation = Proc.new { sanitized = safe_list_sanitize(input, tags: tags) }\n\n    if html5_mode?\n      # if Loofah is using an HTML5 parser,\n      #   then \"style\" should be removed by the parser as an invalid child of \"select\"\n      assert_silent(&invocation)\n    else\n      # if Loofah is using an HTML4 parser,\n      #   then SafeListSanitizer should remove \"style\" from the safelist\n      assert_output(nil, warning, &invocation)\n    end\n    refute_includes(sanitized, \"style\")\n  end\n\n  def test_scrubbing_svg_attr_values_that_allow_ref\n    input = %Q(<div fill=\"yellow url(http://bad.com/) #fff\">hey</div>)\n    expected = %Q(<div fill=\"yellow #fff\">hey</div>)\n    actual = scope_allowed_attributes %w(fill) do\n      safe_list_sanitize(input)\n    end\n\n    assert_equal(expected, actual)\n  end\n\nprotected\n\n  def xpath_sanitize(input, options = {})\n    XpathRemovalTestSanitizer.new.sanitize(input, options)\n  end\n\n  def full_sanitize(input, options = {})\n    Rails::Html::FullSanitizer.new.sanitize(input, options)\n  end\n\n  def link_sanitize(input, options = {})\n    Rails::Html::LinkSanitizer.new.sanitize(input, options)\n  end\n\n  def safe_list_sanitize(input, options = {})\n    Rails::Html::SafeListSanitizer.new.sanitize(input, options)\n  end\n\n  def assert_sanitized(input, expected = nil)\n    if input\n      assert_dom_equal expected || input, safe_list_sanitize(input)\n    else\n      assert_nil safe_list_sanitize(input)\n    end\n  end\n\n  def sanitize_css(input)\n    Rails::Html::SafeListSanitizer.new.sanitize_css(input)\n  end\n\n  def scope_allowed_tags(tags)\n    old_tags = Rails::Html::SafeListSanitizer.allowed_tags\n    Rails::Html::SafeListSanitizer.allowed_tags = tags\n    yield Rails::Html::SafeListSanitizer.new\n  ensure\n    Rails::Html::SafeListSanitizer.allowed_tags = old_tags\n  end\n\n  def scope_allowed_attributes(attributes)\n    old_attributes = Rails::Html::SafeListSanitizer.allowed_attributes\n    Rails::Html::SafeListSanitizer.allowed_attributes = attributes\n    yield Rails::Html::SafeListSanitizer.new\n  ensure\n    Rails::Html::SafeListSanitizer.allowed_attributes = old_attributes\n  end\n\n  # note that this is used for testing CSS hex encoding: \\\\[0-9a-f]{1,6}\n  def convert_to_css_hex(string, escape_parens=false)\n    string.chars.map do |c|\n      if !escape_parens && (c == \"(\" || c == \")\")\n        c\n      else\n        format('\\00%02X', c.ord)\n      end\n    end.join\n  end\n\n  def libxml_2_9_14_recovery_lt?\n    # changed in 2.9.14, see https://github.com/sparklemotion/nokogiri/releases/tag/v1.13.5\n    Nokogiri.method(:uses_libxml?).arity == -1 && Nokogiri.uses_libxml?(\">= 2.9.14\")\n  end\n\n  def libxml_2_9_14_recovery_lt_bang?\n    # changed in 2.9.14, see https://github.com/sparklemotion/nokogiri/releases/tag/v1.13.5\n    # then reverted in 2.10.0, see https://gitlab.gnome.org/GNOME/libxml2/-/issues/380\n    Nokogiri.method(:uses_libxml?).arity == -1 && Nokogiri.uses_libxml?(\"= 2.9.14\")\n  end\n\n  def html5_mode?\n    ::Loofah.respond_to?(:html5_mode?) && ::Loofah.html5_mode?\n  end\nend\n"], "filenames": ["lib/rails/html/scrubbers.rb", "test/sanitizer_test.rb"], "buggy_code_start_loc": [148, 608], "buggy_code_end_loc": [152, 608], "fixing_code_start_loc": [149, 609], "fixing_code_end_loc": [154, 619], "type": "CWE-1333", "message": "rails-html-sanitizer is responsible for sanitizing HTML fragments in Rails applications. Certain configurations of rails-html-sanitizer < 1.4.4 use an inefficient regular expression that is susceptible to excessive backtracking when attempting to sanitize certain SVG attributes. This may lead to a denial of service through CPU resource consumption. This issue has been patched in version 1.4.4.", "other": {"cve": {"id": "CVE-2022-23517", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-14T17:15:10.130", "lastModified": "2022-12-16T19:13:24.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rails-html-sanitizer is responsible for sanitizing HTML fragments in Rails applications. Certain configurations of rails-html-sanitizer < 1.4.4 use an inefficient regular expression that is susceptible to excessive backtracking when attempting to sanitize certain SVG attributes. This may lead to a denial of service through CPU resource consumption. This issue has been patched in version 1.4.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rails_html_sanitizer_project:rails_html_sanitizer:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.4.4", "matchCriteriaId": "0C395888-2086-4AE6-9F41-2A80E43DCB01"}]}]}], "references": [{"url": "https://github.com/rails/rails-html-sanitizer/commit/56c61c0cebd1e493e8ad7bca2a0191609a4a6979", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rails/rails-html-sanitizer/security/advisories/GHSA-5x79-w82f-gw8w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1684163", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rails/rails-html-sanitizer/commit/56c61c0cebd1e493e8ad7bca2a0191609a4a6979"}}