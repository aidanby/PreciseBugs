{"buggy_code": ["package org.bouncycastle.crypto.agreement;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.generators.DHKeyPairGenerator;\nimport org.bouncycastle.crypto.params.DHKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * a Diffie-Hellman key exchange engine.\n * <p>\n * note: This uses MTI/A0 key agreement in order to make the key agreement\n * secure against passive attacks. If you're doing Diffie-Hellman and both\n * parties have long term public keys you should look at using this. For\n * further information have a look at RFC 2631.\n * <p>\n * It's possible to extend this to more than two parties as well, for the moment\n * that is left as an exercise for the reader.\n */\npublic class DHAgreement\n{\n    private DHPrivateKeyParameters  key;\n    private DHParameters            dhParams;\n    private BigInteger              privateValue;\n    private SecureRandom            random;\n\n    public void init(\n        CipherParameters    param)\n    {\n        AsymmetricKeyParameter  kParam;\n\n        if (param instanceof ParametersWithRandom)\n        {\n            ParametersWithRandom    rParam = (ParametersWithRandom)param;\n\n            this.random = rParam.getRandom();\n            kParam = (AsymmetricKeyParameter)rParam.getParameters();\n        }\n        else\n        {\n            this.random = new SecureRandom();\n            kParam = (AsymmetricKeyParameter)param;\n        }\n\n        \n        if (!(kParam instanceof DHPrivateKeyParameters))\n        {\n            throw new IllegalArgumentException(\"DHEngine expects DHPrivateKeyParameters\");\n        }\n\n        this.key = (DHPrivateKeyParameters)kParam;\n        this.dhParams = key.getParameters();\n    }\n\n    /**\n     * calculate our initial message.\n     */\n    public BigInteger calculateMessage()\n    {\n        DHKeyPairGenerator dhGen = new DHKeyPairGenerator();\n        dhGen.init(new DHKeyGenerationParameters(random, dhParams));\n        AsymmetricCipherKeyPair dhPair = dhGen.generateKeyPair();\n\n        this.privateValue = ((DHPrivateKeyParameters)dhPair.getPrivate()).getX();\n\n        return ((DHPublicKeyParameters)dhPair.getPublic()).getY();\n    }\n\n    /**\n     * given a message from a given party and the corresponding public key,\n     * calculate the next message in the agreement sequence. In this case\n     * this will represent the shared secret.\n     */\n    public BigInteger calculateAgreement(\n        DHPublicKeyParameters   pub,\n        BigInteger              message)\n    {\n        if (!pub.getParameters().equals(dhParams))\n        {\n            throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\n        }\n\n        BigInteger p = dhParams.getP();\n\n        return message.modPow(key.getX(), p).multiply(pub.getY().modPow(privateValue, p)).mod(p);\n    }\n}\n", "package org.bouncycastle.crypto.agreement;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * a Diffie-Hellman key agreement class.\n * <p>\n * note: This is only the basic algorithm, it doesn't take advantage of\n * long term public keys if they are available. See the DHAgreement class\n * for a \"better\" implementation.\n */\npublic class DHBasicAgreement\n    implements BasicAgreement\n{\n    private DHPrivateKeyParameters  key;\n    private DHParameters            dhParams;\n\n    public void init(\n        CipherParameters    param)\n    {\n        AsymmetricKeyParameter  kParam;\n\n        if (param instanceof ParametersWithRandom)\n        {\n            ParametersWithRandom rParam = (ParametersWithRandom)param;\n            kParam = (AsymmetricKeyParameter)rParam.getParameters();\n        }\n        else\n        {\n            kParam = (AsymmetricKeyParameter)param;\n        }\n\n        if (!(kParam instanceof DHPrivateKeyParameters))\n        {\n            throw new IllegalArgumentException(\"DHEngine expects DHPrivateKeyParameters\");\n        }\n\n        this.key = (DHPrivateKeyParameters)kParam;\n        this.dhParams = key.getParameters();\n    }\n\n    public int getFieldSize()\n    {\n        return (key.getParameters().getP().bitLength() + 7) / 8;\n    }\n\n    /**\n     * given a short term public key from a given party calculate the next\n     * message in the agreement sequence. \n     */\n    public BigInteger calculateAgreement(\n        CipherParameters   pubKey)\n    {\n        DHPublicKeyParameters   pub = (DHPublicKeyParameters)pubKey;\n\n        if (!pub.getParameters().equals(dhParams))\n        {\n            throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\n        }\n\n        return pub.getY().modPow(key.getX(), dhParams.getP());\n    }\n}\n", "package org.bouncycastle.crypto.engines;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.EphemeralKeyPair;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyParser;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.IESParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.KDFParameters;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Pack;\n\n/**\n * Support class for constructing integrated encryption ciphers\n * for doing basic message exchanges on top of key agreement ciphers.\n * Follows the description given in IEEE Std 1363a.\n */\npublic class IESEngine\n{\n    BasicAgreement agree;\n    DerivationFunction kdf;\n    Mac mac;\n    BufferedBlockCipher cipher;\n    byte[] macBuf;\n\n    boolean forEncryption;\n    CipherParameters privParam, pubParam;\n    IESParameters param;\n\n    byte[] V;\n    private EphemeralKeyPairGenerator keyPairGenerator;\n    private KeyParser keyParser;\n    private byte[] IV;\n\n    /**\n     * set up for use with stream mode, where the key derivation function\n     * is used to provide a stream of bytes to xor with the message.\n     *\n     * @param agree the key agreement used as the basis for the encryption\n     * @param kdf   the key derivation function used for byte generation\n     * @param mac   the message authentication code generator for the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = null;\n    }\n\n\n    /**\n     * Set up for use in conjunction with a block cipher to handle the\n     * message.It is <b>strongly</b> recommended that the cipher is not in ECB mode.\n     *\n     * @param agree  the key agreement used as the basis for the encryption\n     * @param kdf    the key derivation function used for byte generation\n     * @param mac    the message authentication code generator for the message\n     * @param cipher the cipher to used for encrypting the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac,\n        BufferedBlockCipher cipher)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = cipher;\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param forEncryption whether or not this is encryption/decryption.\n     * @param privParam     our private key parameters\n     * @param pubParam      the recipient's/sender's public key parameters\n     * @param params        encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     */\n    public void init(\n        boolean forEncryption,\n        CipherParameters privParam,\n        CipherParameters pubParam,\n        CipherParameters params)\n    {\n        this.forEncryption = forEncryption;\n        this.privParam = privParam;\n        this.pubParam = pubParam;\n        this.V = new byte[0];\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the decryptor.\n     *\n     * @param publicKey      the recipient's/sender's public key parameters\n     * @param params         encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param ephemeralKeyPairGenerator             the ephemeral key pair generator to use.\n     */\n    public void init(AsymmetricKeyParameter publicKey, CipherParameters params, EphemeralKeyPairGenerator ephemeralKeyPairGenerator)\n    {\n        this.forEncryption = true;\n        this.pubParam = publicKey;\n        this.keyPairGenerator = ephemeralKeyPairGenerator;\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param privateKey      the recipient's private key.\n     * @param params          encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param publicKeyParser the parser for reading the ephemeral public key.\n     */\n    public void init(AsymmetricKeyParameter privateKey, CipherParameters params, KeyParser publicKeyParser)\n    {\n        this.forEncryption = false;\n        this.privParam = privateKey;\n        this.keyParser = publicKeyParser;\n\n        extractParams(params);\n    }\n\n    private void extractParams(CipherParameters params)\n    {\n        if (params instanceof ParametersWithIV)\n        {\n            this.IV = ((ParametersWithIV)params).getIV();\n            this.param = (IESParameters)((ParametersWithIV)params).getParameters();\n        }\n        else\n        {\n            this.IV = null;\n            this.param = (IESParameters)params;\n        }\n    }\n\n    public BufferedBlockCipher getCipher()\n    {\n        return cipher;\n    }\n\n    public Mac getMac()\n    {\n        return mac;\n    }\n\n    private byte[] encryptBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] C = null, K = null, K1 = null, K2 = null;\n        int len;\n\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, inLen, K2, 0, K2.length);\n            }\n\n            C = new byte[inLen];\n\n            for (int i = 0; i != inLen; i++)\n            {\n                C[i] = (byte)(in[inOff + i] ^ K1[i]);\n            }\n            len = inLen;\n        }\n        else\n        {\n            // Block cipher mode.\n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If iv provided use it to initialise the cipher\n            if (IV != null)\n            {\n                cipher.init(true, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(true, new KeyParameter(K1));    \n            }\n            \n            C = new byte[cipher.getOutputSize(inLen)];\n            len = cipher.processBytes(in, inOff, inLen, C, 0);\n            len += cipher.doFinal(C, len);\n        }\n\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n\n        // Apply the MAC.\n        byte[] T = new byte[mac.getMacSize()];\n\n        mac.init(new KeyParameter(K2));\n        mac.update(C, 0, C.length);\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T, 0);\n\n\n        // Output the triple (V,C,T).\n        byte[] Output = new byte[V.length + len + T.length];\n        System.arraycopy(V, 0, Output, 0, V.length);\n        System.arraycopy(C, 0, Output, V.length, len);\n        System.arraycopy(T, 0, Output, V.length + len, T.length);\n        return Output;\n    }\n\n    private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M, K, K1, K2;\n        int len = 0;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            // process the message\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));\n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n\n            // do initial processing\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n        }\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"invalid MAC\");\n        }\n\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n    }\n\n\n    public byte[] processBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        if (forEncryption)\n        {\n            if (keyPairGenerator != null)\n            {\n                EphemeralKeyPair ephKeyPair = keyPairGenerator.generate();\n\n                this.privParam = ephKeyPair.getKeyPair().getPrivate();\n                this.V = ephKeyPair.getEncodedPublicKey();\n            }\n        }\n        else\n        {\n            if (keyParser != null)\n            {\n                ByteArrayInputStream bIn = new ByteArrayInputStream(in, inOff, inLen);\n\n                try\n                {\n                    this.pubParam = keyParser.readKey(bIn);\n                }\n                catch (IOException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n\n                int encLength = (inLen - bIn.available());\n                this.V = Arrays.copyOfRange(in, inOff, inOff + encLength);\n            }\n        }\n\n        // Compute the common value and convert to byte array. \n        agree.init(privParam);\n        BigInteger z = agree.calculateAgreement(pubParam);\n        byte[] Z = BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z);\n\n        // Create input to KDF.  \n        if (V.length != 0)\n        {\n            byte[] VZ = Arrays.concatenate(V, Z);\n            Arrays.fill(Z, (byte)0);\n            Z = VZ;\n        }\n\n        try\n        {\n            // Initialise the KDF.\n            KDFParameters kdfParam = new KDFParameters(Z, param.getDerivationV());\n            kdf.init(kdfParam);\n\n            return forEncryption\n                ? encryptBlock(in, inOff, inLen)\n                : decryptBlock(in, inOff, inLen);\n        }\n        finally\n        {\n            Arrays.fill(Z, (byte)0);\n        }\n    }\n\n    // as described in Shroup's paper and P1363a\n    protected byte[] getLengthTag(byte[] p2)\n    {\n        byte[] L2 = new byte[8];\n        if (p2 != null)\n        {\n            Pack.longToBigEndian(p2.length * 8L, L2, 0);\n        }\n        return L2;\n    }\n}\n", "package org.bouncycastle.crypto.params;\n\nimport java.math.BigInteger;\n\npublic class DHPublicKeyParameters\n    extends DHKeyParameters\n{\n    private BigInteger      y;\n\n    public DHPublicKeyParameters(\n        BigInteger      y,\n        DHParameters    params)\n    {\n        super(false, params);\n\n        this.y = validate(y, params);\n    }   \n\n    private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (dhParams.getQ() != null)\n        {\n            if (BigInteger.ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            return y;         // we can't validate without Q.\n        }\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public int hashCode()\n    {\n        return y.hashCode() ^ super.hashCode();\n    }\n\n    public boolean equals(\n        Object  obj)\n    {\n        if (!(obj instanceof DHPublicKeyParameters))\n        {\n            return false;\n        }\n\n        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;\n\n        return other.getY().equals(y) && super.equals(obj);\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.math.BigInteger;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.agreement.kdf.DHKEKGenerator;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.BaseAgreementSpi;\nimport org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec;\n\n/**\n * Diffie-Hellman key agreement. There's actually a better way of doing this\n * if you are using long term public keys, see the light-weight version for\n * details.\n */\npublic class KeyAgreementSpi\n    extends BaseAgreementSpi\n{\n    private BigInteger      x;\n    private BigInteger      p;\n    private BigInteger      g;\n\n    private BigInteger     result;\n\n    public KeyAgreementSpi()\n    {\n        super(\"Diffie-Hellman\", null);\n    }\n\n    public KeyAgreementSpi(\n        String kaAlgorithm,\n        DerivationFunction kdf)\n    {\n        super(kaAlgorithm, kdf);\n    }\n\n    protected byte[] bigIntToBytes(\n        BigInteger    r)\n    {\n        //\n        // RFC 2631 (2.1.2) specifies that the secret should be padded with leading zeros if necessary\n        // must be the same length as p\n        //\n        int expectedLength = (p.bitLength() + 7) / 8;\n\n        byte[]    tmp = r.toByteArray();\n\n        if (tmp.length == expectedLength)\n        {\n            return tmp;\n        }\n\n        if (tmp[0] == 0 && tmp.length == expectedLength + 1)\n        {\n            byte[]    rv = new byte[tmp.length - 1];\n            \n            System.arraycopy(tmp, 1, rv, 0, rv.length);\n            return rv;\n        }\n\n        // tmp must be shorter than expectedLength\n        // pad to the left with zeros.\n        byte[]    rv = new byte[expectedLength];\n\n        System.arraycopy(tmp, 0, rv, rv.length - tmp.length, tmp.length);\n\n        return rv;\n    }\n    \n    protected Key engineDoPhase(\n        Key     key,\n        boolean lastPhase) \n        throws InvalidKeyException, IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        if (!(key instanceof DHPublicKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement doPhase requires DHPublicKey\");\n        }\n        DHPublicKey pubKey = (DHPublicKey)key;\n\n        if (!pubKey.getParams().getG().equals(g) || !pubKey.getParams().getP().equals(p))\n        {\n            throw new InvalidKeyException(\"DHPublicKey not for this KeyAgreement!\");\n        }\n\n        if (lastPhase)\n        {\n            result = ((DHPublicKey)key).getY().modPow(x, p);\n            return null;\n        }\n        else\n        {\n            result = ((DHPublicKey)key).getY().modPow(x, p);\n        }\n\n        return new BCDHPublicKey(result, pubKey.getParams());\n    }\n\n    protected byte[] engineGenerateSecret() \n        throws IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        return super.engineGenerateSecret();\n    }\n\n    protected int engineGenerateSecret(\n        byte[]  sharedSecret,\n        int     offset) \n        throws IllegalStateException, ShortBufferException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        return super.engineGenerateSecret(sharedSecret, offset);\n    }\n\n    protected SecretKey engineGenerateSecret(\n        String algorithm)\n        throws NoSuchAlgorithmException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        byte[] res = bigIntToBytes(result);\n\n        // for JSSE compatibility\n        if (algorithm.equals(\"TlsPremasterSecret\"))\n        {\n            return new SecretKeySpec(trimZeroes(res), algorithm);\n        }\n\n        return super.engineGenerateSecret(algorithm);\n    }\n\n    protected void engineInit(\n        Key                     key,\n        AlgorithmParameterSpec  params,\n        SecureRandom            random) \n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        if (!(key instanceof DHPrivateKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement requires DHPrivateKey for initialisation\");\n        }\n        DHPrivateKey    privKey = (DHPrivateKey)key;\n\n        if (params != null)\n        {\n            if (params instanceof DHParameterSpec)    // p, g override.\n            {\n                DHParameterSpec p = (DHParameterSpec)params;\n\n                this.p = p.getP();\n                this.g = p.getG();\n            }\n            else if (params instanceof UserKeyingMaterialSpec)\n            {\n                this.p = privKey.getParams().getP();\n                this.g = privKey.getParams().getG();\n                this.ukmParameters = ((UserKeyingMaterialSpec)params).getUserKeyingMaterial();\n            }\n            else\n            {\n                throw new InvalidAlgorithmParameterException(\"DHKeyAgreement only accepts DHParameterSpec\");\n            }\n        }\n        else\n        {\n            this.p = privKey.getParams().getP();\n            this.g = privKey.getParams().getG();\n        }\n\n        this.x = this.result = privKey.getX();\n    }\n\n    protected void engineInit(\n        Key             key,\n        SecureRandom    random) \n        throws InvalidKeyException\n    {\n        if (!(key instanceof DHPrivateKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement requires DHPrivateKey\");\n        }\n\n        DHPrivateKey    privKey = (DHPrivateKey)key;\n\n        this.p = privKey.getParams().getP();\n        this.g = privKey.getParams().getG();\n        this.x = this.result = privKey.getX();\n    }\n\n    protected byte[] calcSecret()\n    {\n        return bigIntToBytes(result);\n    }\n\n    public static class DHwithRFC2631KDF\n        extends KeyAgreementSpi\n    {\n        public DHwithRFC2631KDF()\n        {\n            super(\"DHwithRFC2631KDF\", new DHKEKGenerator(new SHA1Digest()));\n        }\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.crypto.agreement;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.generators.DHKeyPairGenerator;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * a Diffie-Hellman key exchange engine.\n * <p>\n * note: This uses MTI/A0 key agreement in order to make the key agreement\n * secure against passive attacks. If you're doing Diffie-Hellman and both\n * parties have long term public keys you should look at using this. For\n * further information have a look at RFC 2631.\n * <p>\n * It's possible to extend this to more than two parties as well, for the moment\n * that is left as an exercise for the reader.\n */\npublic class DHAgreement\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n\n    private DHPrivateKeyParameters  key;\n    private DHParameters            dhParams;\n    private BigInteger              privateValue;\n    private SecureRandom            random;\n\n    public void init(\n        CipherParameters    param)\n    {\n        AsymmetricKeyParameter  kParam;\n\n        if (param instanceof ParametersWithRandom)\n        {\n            ParametersWithRandom    rParam = (ParametersWithRandom)param;\n\n            this.random = rParam.getRandom();\n            kParam = (AsymmetricKeyParameter)rParam.getParameters();\n        }\n        else\n        {\n            this.random = new SecureRandom();\n            kParam = (AsymmetricKeyParameter)param;\n        }\n\n        \n        if (!(kParam instanceof DHPrivateKeyParameters))\n        {\n            throw new IllegalArgumentException(\"DHEngine expects DHPrivateKeyParameters\");\n        }\n\n        this.key = (DHPrivateKeyParameters)kParam;\n        this.dhParams = key.getParameters();\n    }\n\n    /**\n     * calculate our initial message.\n     */\n    public BigInteger calculateMessage()\n    {\n        DHKeyPairGenerator dhGen = new DHKeyPairGenerator();\n        dhGen.init(new DHKeyGenerationParameters(random, dhParams));\n        AsymmetricCipherKeyPair dhPair = dhGen.generateKeyPair();\n\n        this.privateValue = ((DHPrivateKeyParameters)dhPair.getPrivate()).getX();\n\n        return ((DHPublicKeyParameters)dhPair.getPublic()).getY();\n    }\n\n    /**\n     * given a message from a given party and the corresponding public key,\n     * calculate the next message in the agreement sequence. In this case\n     * this will represent the shared secret.\n     */\n    public BigInteger calculateAgreement(\n        DHPublicKeyParameters   pub,\n        BigInteger              message)\n    {\n        if (!pub.getParameters().equals(dhParams))\n        {\n            throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\n        }\n\n        BigInteger p = dhParams.getP();\n\n        BigInteger result = pub.getY().modPow(privateValue, p);\n        if (result.compareTo(ONE) == 0)\n        {\n            throw new IllegalStateException(\"Shared key can't be 1\");\n        }\n\n        return message.modPow(key.getX(), p).multiply(result).mod(p);\n    }\n}\n", "package org.bouncycastle.crypto.agreement;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\n\n/**\n * a Diffie-Hellman key agreement class.\n * <p>\n * note: This is only the basic algorithm, it doesn't take advantage of\n * long term public keys if they are available. See the DHAgreement class\n * for a \"better\" implementation.\n */\npublic class DHBasicAgreement\n    implements BasicAgreement\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n\n    private DHPrivateKeyParameters  key;\n    private DHParameters            dhParams;\n\n    public void init(\n        CipherParameters    param)\n    {\n        AsymmetricKeyParameter  kParam;\n\n        if (param instanceof ParametersWithRandom)\n        {\n            ParametersWithRandom rParam = (ParametersWithRandom)param;\n            kParam = (AsymmetricKeyParameter)rParam.getParameters();\n        }\n        else\n        {\n            kParam = (AsymmetricKeyParameter)param;\n        }\n\n        if (!(kParam instanceof DHPrivateKeyParameters))\n        {\n            throw new IllegalArgumentException(\"DHEngine expects DHPrivateKeyParameters\");\n        }\n\n        this.key = (DHPrivateKeyParameters)kParam;\n        this.dhParams = key.getParameters();\n    }\n\n    public int getFieldSize()\n    {\n        return (key.getParameters().getP().bitLength() + 7) / 8;\n    }\n\n    /**\n     * given a short term public key from a given party calculate the next\n     * message in the agreement sequence. \n     */\n    public BigInteger calculateAgreement(\n        CipherParameters   pubKey)\n    {\n        DHPublicKeyParameters   pub = (DHPublicKeyParameters)pubKey;\n\n        if (!pub.getParameters().equals(dhParams))\n        {\n            throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\n        }\n\n        BigInteger result = pub.getY().modPow(key.getX(), dhParams.getP());\n        if (result.compareTo(ONE) == 0)\n        {\n            throw new IllegalStateException(\"Shared key can't be 1\");\n        }\n\n        return result;\n    }\n}\n", "package org.bouncycastle.crypto.engines;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.EphemeralKeyPair;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyParser;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.IESParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.KDFParameters;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Pack;\n\n/**\n * Support class for constructing integrated encryption ciphers\n * for doing basic message exchanges on top of key agreement ciphers.\n * Follows the description given in IEEE Std 1363a.\n */\npublic class IESEngine\n{\n    BasicAgreement agree;\n    DerivationFunction kdf;\n    Mac mac;\n    BufferedBlockCipher cipher;\n    byte[] macBuf;\n\n    boolean forEncryption;\n    CipherParameters privParam, pubParam;\n    IESParameters param;\n\n    byte[] V;\n    private EphemeralKeyPairGenerator keyPairGenerator;\n    private KeyParser keyParser;\n    private byte[] IV;\n\n    /**\n     * set up for use with stream mode, where the key derivation function\n     * is used to provide a stream of bytes to xor with the message.\n     *\n     * @param agree the key agreement used as the basis for the encryption\n     * @param kdf   the key derivation function used for byte generation\n     * @param mac   the message authentication code generator for the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = null;\n    }\n\n\n    /**\n     * Set up for use in conjunction with a block cipher to handle the\n     * message.It is <b>strongly</b> recommended that the cipher is not in ECB mode.\n     *\n     * @param agree  the key agreement used as the basis for the encryption\n     * @param kdf    the key derivation function used for byte generation\n     * @param mac    the message authentication code generator for the message\n     * @param cipher the cipher to used for encrypting the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac,\n        BufferedBlockCipher cipher)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = cipher;\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param forEncryption whether or not this is encryption/decryption.\n     * @param privParam     our private key parameters\n     * @param pubParam      the recipient's/sender's public key parameters\n     * @param params        encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     */\n    public void init(\n        boolean forEncryption,\n        CipherParameters privParam,\n        CipherParameters pubParam,\n        CipherParameters params)\n    {\n        this.forEncryption = forEncryption;\n        this.privParam = privParam;\n        this.pubParam = pubParam;\n        this.V = new byte[0];\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the decryptor.\n     *\n     * @param publicKey      the recipient's/sender's public key parameters\n     * @param params         encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param ephemeralKeyPairGenerator             the ephemeral key pair generator to use.\n     */\n    public void init(AsymmetricKeyParameter publicKey, CipherParameters params, EphemeralKeyPairGenerator ephemeralKeyPairGenerator)\n    {\n        this.forEncryption = true;\n        this.pubParam = publicKey;\n        this.keyPairGenerator = ephemeralKeyPairGenerator;\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param privateKey      the recipient's private key.\n     * @param params          encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param publicKeyParser the parser for reading the ephemeral public key.\n     */\n    public void init(AsymmetricKeyParameter privateKey, CipherParameters params, KeyParser publicKeyParser)\n    {\n        this.forEncryption = false;\n        this.privParam = privateKey;\n        this.keyParser = publicKeyParser;\n\n        extractParams(params);\n    }\n\n    private void extractParams(CipherParameters params)\n    {\n        if (params instanceof ParametersWithIV)\n        {\n            this.IV = ((ParametersWithIV)params).getIV();\n            this.param = (IESParameters)((ParametersWithIV)params).getParameters();\n        }\n        else\n        {\n            this.IV = null;\n            this.param = (IESParameters)params;\n        }\n    }\n\n    public BufferedBlockCipher getCipher()\n    {\n        return cipher;\n    }\n\n    public Mac getMac()\n    {\n        return mac;\n    }\n\n    private byte[] encryptBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] C = null, K = null, K1 = null, K2 = null;\n        int len;\n\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, inLen, K2, 0, K2.length);\n            }\n\n            C = new byte[inLen];\n\n            for (int i = 0; i != inLen; i++)\n            {\n                C[i] = (byte)(in[inOff + i] ^ K1[i]);\n            }\n            len = inLen;\n        }\n        else\n        {\n            // Block cipher mode.\n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If iv provided use it to initialise the cipher\n            if (IV != null)\n            {\n                cipher.init(true, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(true, new KeyParameter(K1));    \n            }\n            \n            C = new byte[cipher.getOutputSize(inLen)];\n            len = cipher.processBytes(in, inOff, inLen, C, 0);\n            len += cipher.doFinal(C, len);\n        }\n\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n\n        // Apply the MAC.\n        byte[] T = new byte[mac.getMacSize()];\n\n        mac.init(new KeyParameter(K2));\n        mac.update(C, 0, C.length);\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T, 0);\n\n\n        // Output the triple (V,C,T).\n        byte[] Output = new byte[V.length + len + T.length];\n        System.arraycopy(V, 0, Output, 0, V.length);\n        System.arraycopy(C, 0, Output, V.length, len);\n        System.arraycopy(T, 0, Output, V.length + len, T.length);\n        return Output;\n    }\n\n    private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M, K, K1, K2;\n        int len = 0;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            // process the message\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));\n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n\n            // do initial processing\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n        }\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"invalid MAC\");\n        }\n\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n    }\n\n\n    public byte[] processBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        if (forEncryption)\n        {\n            if (keyPairGenerator != null)\n            {\n                EphemeralKeyPair ephKeyPair = keyPairGenerator.generate();\n\n                this.privParam = ephKeyPair.getKeyPair().getPrivate();\n                this.V = ephKeyPair.getEncodedPublicKey();\n            }\n        }\n        else\n        {\n            if (keyParser != null)\n            {\n                ByteArrayInputStream bIn = new ByteArrayInputStream(in, inOff, inLen);\n\n                try\n                {\n                    this.pubParam = keyParser.readKey(bIn);\n                }\n                catch (IOException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n                catch (IllegalArgumentException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n\n                int encLength = (inLen - bIn.available());\n                this.V = Arrays.copyOfRange(in, inOff, inOff + encLength);\n            }\n        }\n\n        // Compute the common value and convert to byte array. \n        agree.init(privParam);\n        BigInteger z = agree.calculateAgreement(pubParam);\n        byte[] Z = BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z);\n\n        // Create input to KDF.  \n        if (V.length != 0)\n        {\n            byte[] VZ = Arrays.concatenate(V, Z);\n            Arrays.fill(Z, (byte)0);\n            Z = VZ;\n        }\n\n        try\n        {\n            // Initialise the KDF.\n            KDFParameters kdfParam = new KDFParameters(Z, param.getDerivationV());\n            kdf.init(kdfParam);\n\n            return forEncryption\n                ? encryptBlock(in, inOff, inLen)\n                : decryptBlock(in, inOff, inLen);\n        }\n        finally\n        {\n            Arrays.fill(Z, (byte)0);\n        }\n    }\n\n    // as described in Shroup's paper and P1363a\n    protected byte[] getLengthTag(byte[] p2)\n    {\n        byte[] L2 = new byte[8];\n        if (p2 != null)\n        {\n            Pack.longToBigEndian(p2.length * 8L, L2, 0);\n        }\n        return L2;\n    }\n}\n", "package org.bouncycastle.crypto.params;\n\nimport java.math.BigInteger;\n\npublic class DHPublicKeyParameters\n    extends DHKeyParameters\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private BigInteger      y;\n\n    public DHPublicKeyParameters(\n        BigInteger      y,\n        DHParameters    params)\n    {\n        super(false, params);\n\n        this.y = validate(y, params);\n    }   \n\n    private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            // TLS check\n            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n            {\n                throw new IllegalArgumentException(\"invalid DH public key\");\n            }\n\n            return y;         // we can't validate without Q.\n        }\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public int hashCode()\n    {\n        return y.hashCode() ^ super.hashCode();\n    }\n\n    public boolean equals(\n        Object  obj)\n    {\n        if (!(obj instanceof DHPublicKeyParameters))\n        {\n            return false;\n        }\n\n        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;\n\n        return other.getY().equals(y) && super.equals(obj);\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.math.BigInteger;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.agreement.kdf.DHKEKGenerator;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.BaseAgreementSpi;\nimport org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec;\n\n/**\n * Diffie-Hellman key agreement. There's actually a better way of doing this\n * if you are using long term public keys, see the light-weight version for\n * details.\n */\npublic class KeyAgreementSpi\n    extends BaseAgreementSpi\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private BigInteger      x;\n    private BigInteger      p;\n    private BigInteger      g;\n\n    private BigInteger     result;\n\n    public KeyAgreementSpi()\n    {\n        super(\"Diffie-Hellman\", null);\n    }\n\n    public KeyAgreementSpi(\n        String kaAlgorithm,\n        DerivationFunction kdf)\n    {\n        super(kaAlgorithm, kdf);\n    }\n\n    protected byte[] bigIntToBytes(\n        BigInteger    r)\n    {\n        //\n        // RFC 2631 (2.1.2) specifies that the secret should be padded with leading zeros if necessary\n        // must be the same length as p\n        //\n        int expectedLength = (p.bitLength() + 7) / 8;\n\n        byte[]    tmp = r.toByteArray();\n\n        if (tmp.length == expectedLength)\n        {\n            return tmp;\n        }\n\n        if (tmp[0] == 0 && tmp.length == expectedLength + 1)\n        {\n            byte[]    rv = new byte[tmp.length - 1];\n            \n            System.arraycopy(tmp, 1, rv, 0, rv.length);\n            return rv;\n        }\n\n        // tmp must be shorter than expectedLength\n        // pad to the left with zeros.\n        byte[]    rv = new byte[expectedLength];\n\n        System.arraycopy(tmp, 0, rv, rv.length - tmp.length, tmp.length);\n\n        return rv;\n    }\n    \n    protected Key engineDoPhase(\n        Key     key,\n        boolean lastPhase) \n        throws InvalidKeyException, IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        if (!(key instanceof DHPublicKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement doPhase requires DHPublicKey\");\n        }\n        DHPublicKey pubKey = (DHPublicKey)key;\n\n        if (!pubKey.getParams().getG().equals(g) || !pubKey.getParams().getP().equals(p))\n        {\n            throw new InvalidKeyException(\"DHPublicKey not for this KeyAgreement!\");\n        }\n\n        BigInteger peerY = ((DHPublicKey)key).getY();\n        if (peerY == null || peerY.compareTo(TWO) < 0\n            || peerY.compareTo(p.subtract(ONE)) >= 0)\n        {\n            throw new InvalidKeyException(\"Invalid DH PublicKey\");\n        }\n\n        result = peerY.modPow(x, p);\n        if (result.compareTo(ONE) == 0)\n        {\n            throw new InvalidKeyException(\"Shared key can't be 1\");\n        }\n\n        if (lastPhase)\n        {\n            return null;\n        }\n\n        return new BCDHPublicKey(result, pubKey.getParams());\n    }\n\n    protected byte[] engineGenerateSecret() \n        throws IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        return super.engineGenerateSecret();\n    }\n\n    protected int engineGenerateSecret(\n        byte[]  sharedSecret,\n        int     offset) \n        throws IllegalStateException, ShortBufferException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        return super.engineGenerateSecret(sharedSecret, offset);\n    }\n\n    protected SecretKey engineGenerateSecret(\n        String algorithm)\n        throws NoSuchAlgorithmException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        byte[] res = bigIntToBytes(result);\n\n        // for JSSE compatibility\n        if (algorithm.equals(\"TlsPremasterSecret\"))\n        {\n            return new SecretKeySpec(trimZeroes(res), algorithm);\n        }\n\n        return super.engineGenerateSecret(algorithm);\n    }\n\n    protected void engineInit(\n        Key                     key,\n        AlgorithmParameterSpec  params,\n        SecureRandom            random) \n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        if (!(key instanceof DHPrivateKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement requires DHPrivateKey for initialisation\");\n        }\n        DHPrivateKey    privKey = (DHPrivateKey)key;\n\n        if (params != null)\n        {\n            if (params instanceof DHParameterSpec)    // p, g override.\n            {\n                DHParameterSpec p = (DHParameterSpec)params;\n\n                this.p = p.getP();\n                this.g = p.getG();\n            }\n            else if (params instanceof UserKeyingMaterialSpec)\n            {\n                this.p = privKey.getParams().getP();\n                this.g = privKey.getParams().getG();\n                this.ukmParameters = ((UserKeyingMaterialSpec)params).getUserKeyingMaterial();\n            }\n            else\n            {\n                throw new InvalidAlgorithmParameterException(\"DHKeyAgreement only accepts DHParameterSpec\");\n            }\n        }\n        else\n        {\n            this.p = privKey.getParams().getP();\n            this.g = privKey.getParams().getG();\n        }\n\n        this.x = this.result = privKey.getX();\n    }\n\n    protected void engineInit(\n        Key             key,\n        SecureRandom    random) \n        throws InvalidKeyException\n    {\n        if (!(key instanceof DHPrivateKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement requires DHPrivateKey\");\n        }\n\n        DHPrivateKey    privKey = (DHPrivateKey)key;\n\n        this.p = privKey.getParams().getP();\n        this.g = privKey.getParams().getG();\n        this.x = this.result = privKey.getX();\n    }\n\n    protected byte[] calcSecret()\n    {\n        return bigIntToBytes(result);\n    }\n\n    public static class DHwithRFC2631KDF\n        extends KeyAgreementSpi\n    {\n        public DHwithRFC2631KDF()\n        {\n            super(\"DHwithRFC2631KDF\", new DHKEKGenerator(new SHA1Digest()));\n        }\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/crypto/agreement/DHAgreement.java", "core/src/main/java/org/bouncycastle/crypto/agreement/DHBasicAgreement.java", "core/src/main/java/org/bouncycastle/crypto/engines/IESEngine.java", "core/src/main/java/org/bouncycastle/crypto/params/DHPublicKeyParameters.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/KeyAgreementSpi.java"], "buggy_code_start_loc": [8, 22, 410, 7, 31], "buggy_code_end_loc": [93, 70, 410, 31, 112], "fixing_code_start_loc": [9, 23, 411, 8, 32], "fixing_code_end_loc": [101, 78, 415, 46, 122], "type": "CWE-320", "message": "In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation.", "other": {"cve": {"id": "CVE-2016-1000346", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-04T21:29:00.303", "lastModified": "2020-10-20T22:15:17.780", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation."}, {"lang": "es", "value": "En Bouncy Castle JCE Provider, en versiones 1.55 y anteriores, no se valida completamente la clave p\u00fablica DH de la otra parte. Esto puede causar problemas, ya que las claves inv\u00e1lidas pueden emplearse para revelar detalles sobre la clave privada de la otra parte donde se emplea Diffie-Hellman est\u00e1tico. En la versi\u00f3n 1.56, los par\u00e1metros clave se comprueban sobre un c\u00e1lculo de acuerdo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-320"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/1127131c89021612c6eefa26dbe5714c194e7495#diff-d525a20b8acaed791ae2f0f770eb5937", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181127-0004/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3727-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/1127131c89021612c6eefa26dbe5714c194e7495#diff-d525a20b8acaed791ae2f0f770eb5937"}}