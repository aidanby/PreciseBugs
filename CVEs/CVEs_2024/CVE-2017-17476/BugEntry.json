{"buggy_code": ["# --\n# Copyright (C) 2001-2017 OTRS AG, http://otrs.com/\n# --\n# This software comes with ABSOLUTELY NO WARRANTY. For details, see\n# the enclosed file COPYING for license information (AGPL). If you\n# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.\n# --\n\npackage Kernel::Output::HTML::LayoutTemplate;\n\nuse strict;\nuse warnings;\n\nuse Scalar::Util qw();\nuse Template;\nuse Template::Stash::XS;\nuse Template::Context;\nuse Template::Plugins;\n\nuse Kernel::Output::Template::Provider;\n\n=head1 NAME\n\nKernel::Output::HTML::LayoutTemplate - template rendering engine based on Template::Toolkit\n\n=head1 PUBLIC INTERFACE\n\n=over 4\n\n=item Output()\n\ngenerates HTML output based on a template file.\n\nUsing a template file:\n\n    my $HTML = $LayoutObject->Output(\n        TemplateFile => 'AdminLog.tt',\n        Data         => \\%Param,\n    );\n\nUsing a template string:\n\n    my $HTML = $LayoutObject->Output(\n        Template => '<b>[% Data.SomeKey | html %]</b>',\n        Data     => \\%Param,\n    );\n\nAdditional parameters:\n\n    KeepScriptTags - this causes [% WRAPPER JSOnDocumentComplete %] blocks NOT\n        to be replaced. This is important to be able to generate snippets which can be cached.\n\n    my $HTML = $LayoutObject->Output(\n        TemplateFile   => 'AdminLog.tt',\n        Data           => \\%Param,\n        KeepScriptTags => 1,\n    );\n\n=cut\n\nsub Output {\n    my ( $Self, %Param ) = @_;\n\n    $Param{Data} ||= {};\n\n    # get and check param Data\n    if ( ref $Param{Data} ne 'HASH' ) {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => \"Need HashRef in Param Data! Got: '\" . ref $Param{Data} . \"'!\",\n        );\n        $Self->FatalError();\n    }\n\n    # fill init Env\n    if ( !$Self->{EnvRef} ) {\n        %{ $Self->{EnvRef} } = %ENV;\n\n        # all $Self->{*}\n        for ( sort keys %{$Self} ) {\n            if ( defined $Self->{$_} && !ref $Self->{$_} ) {\n                $Self->{EnvRef}->{$_} = $Self->{$_};\n            }\n        }\n    }\n\n    # add new env\n    if ( $Self->{EnvNewRef} ) {\n        for ( %{ $Self->{EnvNewRef} } ) {\n            $Self->{EnvRef}->{$_} = $Self->{EnvNewRef}->{$_};\n        }\n        undef $Self->{EnvNewRef};\n    }\n\n    # if we use the HTML5 input type 'email' jQuery Validate will always validate\n    # we do not want that if CheckEmailAddresses is set to 'no' in SysConfig\n    $Self->{EnvRef}->{EmailFieldType} = $Self->{ConfigObject}->Get('CheckEmailAddresses') ? 'email' : 'text';\n\n    my @TemplateFolders = (\n        \"$Self->{CustomTemplateDir}\",\n        \"$Self->{CustomStandardTemplateDir}\",\n        \"$Self->{TemplateDir}\",\n        \"$Self->{StandardTemplateDir}\",\n    );\n\n    my $TemplateString;\n\n    if ( $Param{TemplateFile} ) {\n        $Param{TemplateFileTT} .= \"$Param{TemplateFile}.tt\";\n    }\n\n    # take templates from string/array\n    elsif ( defined $Param{Template} && ref $Param{Template} eq 'ARRAY' ) {\n        for ( @{ $Param{Template} } ) {\n            $TemplateString .= $_;\n        }\n    }\n    elsif ( defined $Param{Template} ) {\n        $TemplateString = $Param{Template};\n    }\n    else {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => 'Need Template or TemplateFile Param!',\n        );\n        $Self->FatalError();\n    }\n\n    if ( !$Self->{TemplateObject} ) {\n\n        $Self->{TemplateProviderObject} = Kernel::Output::Template::Provider->new(\n            {\n                INCLUDE_PATH => \\@TemplateFolders,\n                EVAL_PERL    => 1,\n                COMPILE_EXT  => '.ttc',\n            }\n        );\n        $Self->{TemplateProviderObject}->OTRSInit(\n            %{$Self},\n            LayoutObject => $Self,\n        );\n\n        my $Plugins = Template::Plugins->new(\n            {\n                PLUGIN_BASE => 'Kernel::Output::Template::Plugin',\n            }\n        );\n\n        my $Context = Template::Context->new(\n            {\n                EVAL_PERL      => 1,\n                STASH          => Template::Stash::XS->new(),\n                LOAD_TEMPLATES => [ $Self->{TemplateProviderObject} ],\n                LOAD_PLUGINS   => [$Plugins],\n            }\n        );\n\n        # Store a weak reference to the LayoutObject in the context\n        #   to avoid ring references. We need it for the plugins.\n        $Context->{LayoutObject} = $Self;\n        Scalar::Util::weaken( $Context->{LayoutObject} );\n\n        my $Success = $Self->{TemplateObject} = Template->new(\n            {\n                CONTEXT => $Context,\n\n                #DEBUG => Template::Constants::DEBUG_ALL,\n            }\n        );\n\n        if ( !$Success ) {\n            $Self->{LogObject}->Log(\n                Priority => 'error',\n                Message  => \"$Template::ERROR;\",\n            );\n\n            # $Self->FatalError(); # Don't use FatalError here, might cause infinite recursion\n            die \"$Template::ERROR\\n\";\n        }\n    }\n\n    my $Output;\n    my $Success = $Self->{TemplateObject}->process(\n        $Param{TemplateFileTT} // \\$TemplateString,\n        {\n            Data => $Param{Data} // {},\n            global => {\n                BlockData      => $Self->{BlockData}     // [],\n                KeepScriptTags => $Param{KeepScriptTags} // 0,\n            },\n        },\n        \\$Output,\n    );\n    if ( !$Success ) {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => $Self->{TemplateObject}->error(),\n        );\n        $Self->FatalError();\n    }\n\n    # If the browser does not send the session cookie, we need to append it to all links and image urls.\n    #   We cannot do this in the template preprocessor because links are often dynamically generated.\n    if ( $Self->{SessionID} && !$Self->{SessionIDCookie} ) {\n\n        # rewrite a hrefs\n        $Output =~ s{\n            (<a.+?href=\")(.+?)(\\#.+?|)(\".+?>)\n        }\n        {\n            my $AHref   = $1;\n            my $Target  = $2;\n            my $End     = $3;\n            my $RealEnd = $4;\n            if ( lc $Target =~ /^(http:|https:|#|ftp:)/ ||\n                $Target !~ /\\.(pl|php|cgi|fcg|fcgi|fpl)(\\?|$)/ ||\n                $Target =~ /(\\?|&|;)\\Q$Self->{SessionName}\\E=/) {\n                $AHref.$Target.$End.$RealEnd;\n            }\n            else {\n                $AHref.$Target.';'.$Self->{SessionName}.'='.$Self->{SessionID}.$End.$RealEnd;\n            }\n        }iegxs;\n\n        # rewrite img and iframe src\n        $Output =~ s{\n            (<(?:img|iframe).+?src=\")(.+?)(\".+?>)\n        }\n        {\n            my $AHref = $1;\n            my $Target = $2;\n            my $End = $3;\n            if (lc $Target =~ m{^http s? :}smx || !$Self->{SessionID} ||\n                $Target !~ /\\.(pl|php|cgi|fcg|fcgi|fpl)(\\?|$)/ ||\n                $Target =~ /\\Q$Self->{SessionName}\\E=/) {\n                $AHref.$Target.$End;\n            }\n            else {\n                $AHref.$Target.'&'.$Self->{SessionName}.'='.$Self->{SessionID}.$End;\n            }\n        }iegxs;\n    }\n\n    #\n    # \"Post\" Output filter handling\n    #\n    if ( $Self->{FilterElementPost} && ref $Self->{FilterElementPost} eq 'HASH' ) {\n\n        # extract filter list\n        my %FilterList = %{ $Self->{FilterElementPost} };\n\n        FILTER:\n        for my $Filter ( sort keys %FilterList ) {\n\n            # extract filter config\n            my $FilterConfig = $FilterList{$Filter};\n\n            next FILTER if !$FilterConfig;\n            next FILTER if ref $FilterConfig ne 'HASH';\n\n            # extract template list\n            my %TemplateList = %{ $FilterConfig->{Templates} || {} };\n\n            if ( !%TemplateList ) {\n                $Self->{LogObject}->Log(\n                    Priority => 'error',\n                    Message =>\n                        \"Please add a template list to output filter $FilterConfig->{Module} to improve performance.\",\n                );\n            }\n            elsif ( $TemplateList{ALL} ) {\n                $Self->{LogObject}->Log(\n                    Priority => 'error',\n                    Message  => <<EOF,\n$FilterConfig->{Module} wants to operate on ALL templates. This will potentially slow down the system and is not recommended.\nEOF\n                );\n            }\n\n            # check template list\n            if ( $Param{TemplateFile} && !$TemplateList{ALL} ) {\n                next FILTER if !$TemplateList{ $Param{TemplateFile} };\n            }\n\n            next FILTER if !$Param{TemplateFile} && !$TemplateList{ALL};\n            next FILTER if !$Self->{MainObject}->Require( $FilterConfig->{Module} );\n\n            # create new instance\n            my $Object = $FilterConfig->{Module}->new(\n                %{$Self},\n                LayoutObject => $Self,\n            );\n\n            next FILTER if !$Object;\n\n            # run output filter\n            $Object->Run(\n                %{$FilterConfig},\n                Data         => \\$Output,\n                TemplateFile => $Param{TemplateFile} || '',\n            );\n        }\n    }\n\n    return $Output;\n}\n\n=item AddJSOnDocumentComplete()\n\ndynamically add JavaScript code that should be executed in Core.App.Ready().\nCall this for any dynamically generated code that is not in a template.\n\n    $LayoutObject->AddJSOnDocumentComplete(\n        Code => $MyCode,\n    );\n\n=cut\n\nsub AddJSOnDocumentComplete {\n    my ( $Self, %Param ) = @_;\n\n    $Self->{_JSOnDocumentComplete} //= [];\n    push @{ $Self->{_JSOnDocumentComplete} }, $Param{Code};\n\n}\n\n1;\n\n=back\n\n=head1 TERMS AND CONDITIONS\n\nThis software is part of the OTRS project (L<http://otrs.org/>).\n\nThis software comes with ABSOLUTELY NO WARRANTY. For details, see\nthe enclosed file COPYING for license information (AGPL). If you\ndid not receive this file, see L<http://www.gnu.org/licenses/agpl.txt>.\n\n=cut\n"], "fixing_code": ["# --\n# Copyright (C) 2001-2017 OTRS AG, http://otrs.com/\n# --\n# This software comes with ABSOLUTELY NO WARRANTY. For details, see\n# the enclosed file COPYING for license information (AGPL). If you\n# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.\n# --\n\npackage Kernel::Output::HTML::LayoutTemplate;\n\nuse strict;\nuse warnings;\n\nuse Scalar::Util qw();\nuse Template;\nuse Template::Stash::XS;\nuse Template::Context;\nuse Template::Plugins;\n\nuse Kernel::Output::Template::Provider;\n\n=head1 NAME\n\nKernel::Output::HTML::LayoutTemplate - template rendering engine based on Template::Toolkit\n\n=head1 PUBLIC INTERFACE\n\n=over 4\n\n=item Output()\n\ngenerates HTML output based on a template file.\n\nUsing a template file:\n\n    my $HTML = $LayoutObject->Output(\n        TemplateFile => 'AdminLog.tt',\n        Data         => \\%Param,\n    );\n\nUsing a template string:\n\n    my $HTML = $LayoutObject->Output(\n        Template => '<b>[% Data.SomeKey | html %]</b>',\n        Data     => \\%Param,\n    );\n\nAdditional parameters:\n\n    KeepScriptTags - this causes [% WRAPPER JSOnDocumentComplete %] blocks NOT\n        to be replaced. This is important to be able to generate snippets which can be cached.\n\n    my $HTML = $LayoutObject->Output(\n        TemplateFile   => 'AdminLog.tt',\n        Data           => \\%Param,\n        KeepScriptTags => 1,\n    );\n\n=cut\n\nsub Output {\n    my ( $Self, %Param ) = @_;\n\n    $Param{Data} ||= {};\n\n    # get and check param Data\n    if ( ref $Param{Data} ne 'HASH' ) {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => \"Need HashRef in Param Data! Got: '\" . ref $Param{Data} . \"'!\",\n        );\n        $Self->FatalError();\n    }\n\n    # fill init Env\n    if ( !$Self->{EnvRef} ) {\n        %{ $Self->{EnvRef} } = %ENV;\n\n        # all $Self->{*}\n        for ( sort keys %{$Self} ) {\n            if ( defined $Self->{$_} && !ref $Self->{$_} ) {\n                $Self->{EnvRef}->{$_} = $Self->{$_};\n            }\n        }\n    }\n\n    # add new env\n    if ( $Self->{EnvNewRef} ) {\n        for ( %{ $Self->{EnvNewRef} } ) {\n            $Self->{EnvRef}->{$_} = $Self->{EnvNewRef}->{$_};\n        }\n        undef $Self->{EnvNewRef};\n    }\n\n    # if we use the HTML5 input type 'email' jQuery Validate will always validate\n    # we do not want that if CheckEmailAddresses is set to 'no' in SysConfig\n    $Self->{EnvRef}->{EmailFieldType} = $Self->{ConfigObject}->Get('CheckEmailAddresses') ? 'email' : 'text';\n\n    my @TemplateFolders = (\n        \"$Self->{CustomTemplateDir}\",\n        \"$Self->{CustomStandardTemplateDir}\",\n        \"$Self->{TemplateDir}\",\n        \"$Self->{StandardTemplateDir}\",\n    );\n\n    my $TemplateString;\n\n    if ( $Param{TemplateFile} ) {\n        $Param{TemplateFileTT} .= \"$Param{TemplateFile}.tt\";\n    }\n\n    # take templates from string/array\n    elsif ( defined $Param{Template} && ref $Param{Template} eq 'ARRAY' ) {\n        for ( @{ $Param{Template} } ) {\n            $TemplateString .= $_;\n        }\n    }\n    elsif ( defined $Param{Template} ) {\n        $TemplateString = $Param{Template};\n    }\n    else {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => 'Need Template or TemplateFile Param!',\n        );\n        $Self->FatalError();\n    }\n\n    if ( !$Self->{TemplateObject} ) {\n\n        $Self->{TemplateProviderObject} = Kernel::Output::Template::Provider->new(\n            {\n                INCLUDE_PATH => \\@TemplateFolders,\n                EVAL_PERL    => 1,\n                COMPILE_EXT  => '.ttc',\n            }\n        );\n        $Self->{TemplateProviderObject}->OTRSInit(\n            %{$Self},\n            LayoutObject => $Self,\n        );\n\n        my $Plugins = Template::Plugins->new(\n            {\n                PLUGIN_BASE => 'Kernel::Output::Template::Plugin',\n            }\n        );\n\n        my $Context = Template::Context->new(\n            {\n                EVAL_PERL      => 1,\n                STASH          => Template::Stash::XS->new(),\n                LOAD_TEMPLATES => [ $Self->{TemplateProviderObject} ],\n                LOAD_PLUGINS   => [$Plugins],\n            }\n        );\n\n        # Store a weak reference to the LayoutObject in the context\n        #   to avoid ring references. We need it for the plugins.\n        $Context->{LayoutObject} = $Self;\n        Scalar::Util::weaken( $Context->{LayoutObject} );\n\n        my $Success = $Self->{TemplateObject} = Template->new(\n            {\n                CONTEXT => $Context,\n\n                #DEBUG => Template::Constants::DEBUG_ALL,\n            }\n        );\n\n        if ( !$Success ) {\n            $Self->{LogObject}->Log(\n                Priority => 'error',\n                Message  => \"$Template::ERROR;\",\n            );\n\n            # $Self->FatalError(); # Don't use FatalError here, might cause infinite recursion\n            die \"$Template::ERROR\\n\";\n        }\n    }\n\n    my $Output;\n    my $Success = $Self->{TemplateObject}->process(\n        $Param{TemplateFileTT} // \\$TemplateString,\n        {\n            Data => $Param{Data} // {},\n            global => {\n                BlockData      => $Self->{BlockData}     // [],\n                KeepScriptTags => $Param{KeepScriptTags} // 0,\n            },\n        },\n        \\$Output,\n    );\n    if ( !$Success ) {\n        $Self->{LogObject}->Log(\n            Priority => 'error',\n            Message  => $Self->{TemplateObject}->error(),\n        );\n        $Self->FatalError();\n    }\n\n    # If the browser does not send the session cookie, we need to append it to all links and image urls.\n    #   We cannot do this in the template preprocessor because links are often dynamically generated.\n    if ( $Self->{SessionID} && !$Self->{SessionIDCookie} ) {\n\n        # rewrite a hrefs\n        $Output =~ s{\n            (<a.+?href=\")(.+?)(\\#.+?|)(\".+?>)\n        }\n        {\n            my $AHref   = $1;\n            my $Target  = $2;\n            my $End     = $3;\n            my $RealEnd = $4;\n            if ( lc($Target) =~ /^(http:|https:|#|ftp:)/ ||\n                $Target !~ /\\.(pl|php|cgi|fcg|fcgi|fpl)(\\?|$)/ ||\n                $Target =~ /(\\?|&|;)\\Q$Self->{SessionName}\\E=/) {\n                $AHref.$Target.$End.$RealEnd;\n            }\n            else {\n                $AHref.$Target.';'.$Self->{SessionName}.'='.$Self->{SessionID}.$End.$RealEnd;\n            }\n        }iegxs;\n\n        # rewrite img and iframe src\n        $Output =~ s{\n            (<(?:img|iframe).+?src=\")(.+?)(\".+?>)\n        }\n        {\n            my $AHref = $1;\n            my $Target = $2;\n            my $End = $3;\n            if (lc($Target) =~ m{^http s? :}smx || !$Self->{SessionID} ||\n                $Target !~ /\\.(pl|php|cgi|fcg|fcgi|fpl)(\\?|$)/ ||\n                $Target =~ /\\Q$Self->{SessionName}\\E=/) {\n                $AHref.$Target.$End;\n            }\n            else {\n                $AHref.$Target.'&'.$Self->{SessionName}.'='.$Self->{SessionID}.$End;\n            }\n        }iegxs;\n    }\n\n    #\n    # \"Post\" Output filter handling\n    #\n    if ( $Self->{FilterElementPost} && ref $Self->{FilterElementPost} eq 'HASH' ) {\n\n        # extract filter list\n        my %FilterList = %{ $Self->{FilterElementPost} };\n\n        FILTER:\n        for my $Filter ( sort keys %FilterList ) {\n\n            # extract filter config\n            my $FilterConfig = $FilterList{$Filter};\n\n            next FILTER if !$FilterConfig;\n            next FILTER if ref $FilterConfig ne 'HASH';\n\n            # extract template list\n            my %TemplateList = %{ $FilterConfig->{Templates} || {} };\n\n            if ( !%TemplateList ) {\n                $Self->{LogObject}->Log(\n                    Priority => 'error',\n                    Message =>\n                        \"Please add a template list to output filter $FilterConfig->{Module} to improve performance.\",\n                );\n            }\n            elsif ( $TemplateList{ALL} ) {\n                $Self->{LogObject}->Log(\n                    Priority => 'error',\n                    Message  => <<EOF,\n$FilterConfig->{Module} wants to operate on ALL templates. This will potentially slow down the system and is not recommended.\nEOF\n                );\n            }\n\n            # check template list\n            if ( $Param{TemplateFile} && !$TemplateList{ALL} ) {\n                next FILTER if !$TemplateList{ $Param{TemplateFile} };\n            }\n\n            next FILTER if !$Param{TemplateFile} && !$TemplateList{ALL};\n            next FILTER if !$Self->{MainObject}->Require( $FilterConfig->{Module} );\n\n            # create new instance\n            my $Object = $FilterConfig->{Module}->new(\n                %{$Self},\n                LayoutObject => $Self,\n            );\n\n            next FILTER if !$Object;\n\n            # run output filter\n            $Object->Run(\n                %{$FilterConfig},\n                Data         => \\$Output,\n                TemplateFile => $Param{TemplateFile} || '',\n            );\n        }\n    }\n\n    return $Output;\n}\n\n=item AddJSOnDocumentComplete()\n\ndynamically add JavaScript code that should be executed in Core.App.Ready().\nCall this for any dynamically generated code that is not in a template.\n\n    $LayoutObject->AddJSOnDocumentComplete(\n        Code => $MyCode,\n    );\n\n=cut\n\nsub AddJSOnDocumentComplete {\n    my ( $Self, %Param ) = @_;\n\n    $Self->{_JSOnDocumentComplete} //= [];\n    push @{ $Self->{_JSOnDocumentComplete} }, $Param{Code};\n\n}\n\n1;\n\n=back\n\n=head1 TERMS AND CONDITIONS\n\nThis software is part of the OTRS project (L<http://otrs.org/>).\n\nThis software comes with ABSOLUTELY NO WARRANTY. For details, see\nthe enclosed file COPYING for license information (AGPL). If you\ndid not receive this file, see L<http://www.gnu.org/licenses/agpl.txt>.\n\n=cut\n"], "filenames": ["Kernel/Output/HTML/LayoutTemplate.pm"], "buggy_code_start_loc": [215], "buggy_code_end_loc": [234], "fixing_code_start_loc": [215], "fixing_code_end_loc": [234], "type": "CWE-200", "message": "Open Ticket Request System (OTRS) 4.0.x before 4.0.28, 5.0.x before 5.0.26, and 6.0.x before 6.0.3, when cookie support is disabled, might allow remote attackers to hijack web sessions and consequently gain privileges via a crafted email.", "other": {"cve": {"id": "CVE-2017-17476", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-20T17:29:00.357", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Ticket Request System (OTRS) 4.0.x before 4.0.28, 5.0.x before 5.0.26, and 6.0.x before 6.0.3, when cookie support is disabled, might allow remote attackers to hijack web sessions and consequently gain privileges via a crafted email."}, {"lang": "es", "value": "Open Ticket Request System (OTRS) en versiones 4.0.x anteriores a la 4.0.28, 5.0.x anteriores a la 5.0.26 y 6.0.x anteriores a la 6.0.3, cuando el soporte de cookies est\u00e1 desactivado, podr\u00eda permitir a los atacantes remotos secuestrar las sesiones web y ganar privilegios en consecuencia mediante un email manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:otrs:otrs:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.28", "matchCriteriaId": "87E8447E-0679-4520-9E24-25344DD01390"}, {"vulnerable": true, "criteria": "cpe:2.3:a:otrs:otrs:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.26", "matchCriteriaId": "D7A78367-51C1-4680-AA0B-E38029FC5DD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:otrs:otrs:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.3", "matchCriteriaId": "7F6B61B6-7466-4B85-AB4E-4D34657262A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/OTRS/otrs/commit/26707eaaa791648e6c7ad6aeaa27efd70e7c66eb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OTRS/otrs/commit/36e3be99cfe8a9e09afa1b75fdc39f3e28f561fc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OTRS/otrs/commit/720c73fbf53e476ca7dfdf2ae1d4d3d2aad2b953", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4069", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.otrs.com/security-advisory-2017-10-security-update-otrs-framework/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OTRS/otrs/commit/26707eaaa791648e6c7ad6aeaa27efd70e7c66eb"}}