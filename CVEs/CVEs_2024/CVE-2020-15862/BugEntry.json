{"buggy_code": ["\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n#include <net-snmp/net-snmp-includes.h>\n#include <net-snmp/agent/net-snmp-agent-includes.h>\n#include <net-snmp/agent/watcher.h>\n#include <net-snmp/agent/agent_callbacks.h>\n\n#include \"agent/extend.h\"\n#include \"utilities/execute.h\"\n#include \"struct.h\"\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n#include \"util_funcs/header_simple_table.h\"\n#include \"mibdefs.h\"\n#define SHELLCOMMAND 3\n#endif\n\nnetsnmp_feature_require(extract_table_row_data);\nnetsnmp_feature_require(table_data_delete_table);\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nnetsnmp_feature_require(insert_table_row);\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\noid  ns_extend_oid[]    = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2 };\n\ntypedef struct extend_registration_block_s {\n    netsnmp_table_data *dinfo;\n    oid                *root_oid;\n    size_t              oid_len;\n    long                num_entries;\n    netsnmp_extend     *ehead;\n    netsnmp_handler_registration       *reg[4];\n    struct extend_registration_block_s *next;\n} extend_registration_block;\nextend_registration_block *ereg_head = NULL;\n\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\ntypedef struct netsnmp_old_extend_s {\n    unsigned int idx;\n    netsnmp_extend *exec_entry;\n    netsnmp_extend *efix_entry;\n} netsnmp_old_extend;\n\nunsigned int             num_compatability_entries = 0;\nunsigned int             max_compatability_entries = 50;\nnetsnmp_old_extend *compatability_entries;\n\nchar           *cmdlinebuf;\nsize_t          cmdlinesize;\n\nWriteMethod fixExec2Error;\nFindVarMethod var_extensible_old;\noid  old_extensible_variables_oid[] = { NETSNMP_UCDAVIS_MIB, NETSNMP_SHELLMIBNUM, 1 };\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nstruct variable2 old_extensible_variables[] = {\n    {MIBINDEX,     ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {MIBINDEX}},\n    {ERRORNAME,    ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORNAME}},\n    {SHELLCOMMAND, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {SHELLCOMMAND}},\n    {ERRORFLAG,    ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFLAG}},\n    {ERRORMSG,     ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORMSG}},\n    {ERRORFIX,     ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,\n     var_extensible_old, 1, {ERRORFIX}},\n    {ERRORFIXCMD,  ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIXCMD}}\n};\n#else /* !NETSNMP_NO_WRITE_SUPPORT */\nstruct variable2 old_extensible_variables[] = {\n    {MIBINDEX,     ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {MIBINDEX}},\n    {ERRORNAME,    ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORNAME}},\n    {SHELLCOMMAND, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {SHELLCOMMAND}},\n    {ERRORFLAG,    ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFLAG}},\n    {ERRORMSG,     ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORMSG}},\n    {ERRORFIX,     ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIX}},\n    {ERRORFIXCMD,  ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIXCMD}}\n};\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n#endif\n\n\n        /*************************\n         *\n         *  Main initialisation routine\n         *\n         *************************/\n\nextend_registration_block *\n_find_extension_block( oid *name, size_t name_len )\n{\n    extend_registration_block         *eptr;\n    size_t len;\n    for ( eptr=ereg_head; eptr; eptr=eptr->next ) {\n        len = SNMP_MIN(name_len, eptr->oid_len);\n        if (!snmp_oid_compare( name, len, eptr->root_oid, eptr->oid_len))\n            return eptr;\n    }\n    return NULL;\n}\n\nextend_registration_block *\n_register_extend( oid *base, size_t len )\n{\n    extend_registration_block         *eptr;\n    oid oid_buf[MAX_OID_LEN];\n\n    netsnmp_table_data                *dinfo;\n    netsnmp_table_registration_info   *tinfo;\n    netsnmp_watcher_info              *winfo;\n    netsnmp_handler_registration      *reg = NULL;\n    int                                rc;\n\n    for ( eptr=ereg_head; eptr; eptr=eptr->next ) {\n        if (!snmp_oid_compare( base, len, eptr->root_oid, eptr->oid_len))\n            return eptr;\n    }\n    if (!eptr) {\n        eptr = SNMP_MALLOC_TYPEDEF( extend_registration_block );\n        if (!eptr)\n            return NULL;\n        eptr->root_oid = snmp_duplicate_objid( base, len );\n        eptr->oid_len  = len;\n        eptr->num_entries = 0;\n        eptr->ehead       = NULL;\n        eptr->dinfo       = netsnmp_create_table_data( \"nsExtendTable\" );\n        eptr->next        = ereg_head;\n        ereg_head         = eptr;\n    }\n\n    dinfo = eptr->dinfo;\n    memcpy( oid_buf, base, len*sizeof(oid) );\n\n        /*\n         * Register the configuration table\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, 0 );\n    tinfo->min_column = COLUMN_EXTCFG_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTCFG_LAST_COLUMN;\n    oid_buf[len] = 2;\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendConfigTable\", handle_nsExtendConfigTable, \n                oid_buf, len+1, HANDLER_CAN_RWRITE);\n#else /* !NETSNMP_NO_WRITE_SUPPORT */\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendConfigTable\", handle_nsExtendConfigTable, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n    rc = netsnmp_register_table_data( reg, dinfo, tinfo );\n    if (rc != SNMPERR_SUCCESS) {\n        goto bail;\n    }\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[0] = reg;\n\n        /*\n         * Register the main output table\n         *   using the same table_data handle.\n         * This is sufficient to link the two tables,\n         *   and implement the AUGMENTS behaviour\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, 0 );\n    tinfo->min_column = COLUMN_EXTOUT1_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTOUT1_LAST_COLUMN;\n    oid_buf[len] = 3;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendOut1Table\", handle_nsExtendOutput1Table, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    rc = netsnmp_register_table_data( reg, dinfo, tinfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[1] = reg;\n\n        /*\n         * Register the multi-line output table\n         *   using a simple table helper.\n         * This handles extracting the indexes from\n         *   the request OID, but leaves most of\n         *   the work to our handler routine.\n         * Still, it was nice while it lasted...\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, ASN_INTEGER, 0 );\n    tinfo->min_column = COLUMN_EXTOUT2_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTOUT2_LAST_COLUMN;\n    oid_buf[len] = 4;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendOut2Table\", handle_nsExtendOutput2Table, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    rc = netsnmp_register_table( reg, tinfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[2] = reg;\n\n        /*\n         * Register a watched scalar to keep track of the number of entries\n         */\n    oid_buf[len] = 1;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendNumEntries\", NULL, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    winfo = netsnmp_create_watcher_info(\n                &(eptr->num_entries), sizeof(eptr->num_entries),\n                ASN_INTEGER, WATCHER_FIXED_SIZE);\n    rc = netsnmp_register_watched_scalar2( reg, winfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    eptr->reg[3] = reg;\n\n    return eptr;\n\nbail:\n    if (eptr->reg[3])\n        netsnmp_unregister_handler(eptr->reg[3]);\n    if (eptr->reg[2])\n        netsnmp_unregister_handler(eptr->reg[2]);\n    if (eptr->reg[1])\n        netsnmp_unregister_handler(eptr->reg[1]);\n    if (eptr->reg[0])\n        netsnmp_unregister_handler(eptr->reg[0]);\n    return NULL;\n}\n\nstatic void\n_unregister_extend(extend_registration_block *eptr)\n{\n    extend_registration_block *prev;\n\n    netsnmp_assert(eptr);\n    for (prev = ereg_head; prev && prev->next != eptr; prev = prev->next)\n\t;\n    if (prev) {\n        netsnmp_assert(eptr == prev->next);\n\tprev->next = eptr->next;\n    } else {\n        netsnmp_assert(eptr == ereg_head);\n\tereg_head = eptr->next;\n    }\n\n    netsnmp_table_data_delete_table(eptr->dinfo);\n    free(eptr->root_oid);\n    free(eptr);\n}\n\nint\nextend_clear_callback(int majorID, int minorID,\n                    void *serverarg, void *clientarg)\n{\n    extend_registration_block *eptr, *enext = NULL;\n\n    for ( eptr=ereg_head; eptr; eptr=enext ) {\n        enext=eptr->next;\n        netsnmp_unregister_handler( eptr->reg[0] );\n        netsnmp_unregister_handler( eptr->reg[1] );\n        netsnmp_unregister_handler( eptr->reg[2] );\n        netsnmp_unregister_handler( eptr->reg[3] );\n        SNMP_FREE(eptr);\n    }\n    ereg_head = NULL;\n    return 0;\n}\n\nvoid init_extend( void )\n{\n    snmpd_register_config_handler(\"extend\",    extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"extend-sh\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"extendfix\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"exec2\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"sh2\",   extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"execFix2\", extend_parse_config, NULL, NULL);\n    (void)_register_extend( ns_extend_oid, OID_LENGTH(ns_extend_oid));\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    snmpd_register_config_handler(\"exec\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"sh\",   extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"execFix\", extend_parse_config, NULL, NULL);\n    compatability_entries = (netsnmp_old_extend *)\n        calloc( max_compatability_entries, sizeof(netsnmp_old_extend));\n    REGISTER_MIB(\"ucd-extensible\", old_extensible_variables,\n                 variable2, old_extensible_variables_oid);\n#endif\n\n    snmp_register_callback(SNMP_CALLBACK_APPLICATION,\n                           SNMPD_CALLBACK_PRE_UPDATE_CONFIG,\n                           extend_clear_callback, NULL);\n}\n\nvoid\nshutdown_extend(void)\n{\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    free(compatability_entries);\n    compatability_entries = NULL;\n#endif\n    while (ereg_head)\n\t_unregister_extend(ereg_head);\n}\n\n        /*************************\n         *\n         *  Cached-data hooks\n         *  see 'cache_handler' helper\n         *\n         *************************/\n\nint\nextend_load_cache(netsnmp_cache *cache, void *magic)\n{\n#ifndef USING_UTILITIES_EXECUTE_MODULE\n    NETSNMP_LOGONCE((LOG_WARNING,\"support for run_exec_command not available\\n\"));\n    return -1;\n#else\n    int  out_len = 1024*100;\n    char out_buf[ 1024*100 ];\n    int  cmd_len = 255*2 + 2;\t/* 2 * DisplayStrings */\n    char cmd_buf[ 255*2 + 2 ];\n    int  ret;\n    char *cp;\n    char *line_buf[ 1024 ];\n    netsnmp_extend *extension = (netsnmp_extend *)magic;\n\n    if (!magic)\n        return -1;\n    DEBUGMSGTL(( \"nsExtendTable:cache\", \"load %s\", extension->token ));\n    if ( extension->args )\n        snprintf( cmd_buf, cmd_len, \"%s %s\", extension->command, extension->args );\n    else \n        snprintf( cmd_buf, cmd_len, \"%s\", extension->command );\n    if ( extension->flags & NS_EXTEND_FLAGS_SHELL )\n        ret = run_shell_command( cmd_buf, extension->input, out_buf, &out_len);\n    else\n        ret = run_exec_command(  cmd_buf, extension->input, out_buf, &out_len);\n    DEBUGMSG(( \"nsExtendTable:cache\", \": %s : %d\\n\", cmd_buf, ret));\n    if (ret >= 0) {\n        if (out_buf[   out_len-1 ] == '\\n')\n            out_buf[ --out_len   ] =  '\\0';\t/* Stomp on trailing newline */\n        extension->output   = strdup( out_buf );\n        extension->out_len  = out_len;\n        /*\n         * Now we need to pick the output apart into separate lines.\n         * Start by counting how many lines we've got, and keeping\n         * track of where each line starts in a static buffer\n         */\n        extension->numlines = 1;\n        line_buf[ 0 ] = extension->output;\n        for (cp=extension->output; *cp; cp++) {\n            if (*cp == '\\n') {\n                line_buf[ extension->numlines++ ] = cp+1;\n            }\n        }\n        if ( extension->numlines > 1 ) {\n            extension->lines = (char**)calloc( sizeof(char *), extension->numlines );\n            memcpy( extension->lines, line_buf,\n                                       sizeof(char *) * extension->numlines );\n        } else {\n            extension->lines = &extension->output;\n        }\n    }\n    extension->result = ret;\n    return ret;\n#endif /* !defined(USING_UTILITIES_EXECUTE_MODULE) */\n}\n\nvoid\nextend_free_cache(netsnmp_cache *cache, void *magic)\n{\n    netsnmp_extend *extension = (netsnmp_extend *)magic;\n    if (!magic)\n        return;\n\n    DEBUGMSGTL(( \"nsExtendTable:cache\", \"free %s\\n\", extension->token ));\n    if (extension->output) {\n        SNMP_FREE(extension->output);\n        extension->output = NULL;\n    }\n    if ( extension->numlines > 1 ) {\n        SNMP_FREE(extension->lines);\n    }\n    extension->lines  = NULL;\n    extension->out_len  = 0;\n    extension->numlines = 0;\n}\n\n\n        /*************************\n         *\n         *  Utility routines for setting up a new entry\n         *  (either via SET requests, or the config file)\n         *\n         *************************/\n\nvoid\n_free_extension( netsnmp_extend *extension, extend_registration_block *ereg )\n{\n    netsnmp_extend *eptr  = NULL;\n    netsnmp_extend *eprev = NULL;\n\n    if (!extension)\n        return;\n\n    if (ereg) {\n        /* Unlink from 'ehead' list */\n        for (eptr=ereg->ehead; eptr; eptr=eptr->next) {\n            if (eptr == extension)\n                break;\n            eprev = eptr;\n        }\n        if (!eptr) {\n            snmp_log(LOG_ERR,\n                     \"extend: fell off end of list before finding extension\\n\");\n            return;\n        }\n        if (eprev)\n            eprev->next = eptr->next;\n        else\n            ereg->ehead = eptr->next;\n        netsnmp_table_data_remove_and_delete_row( ereg->dinfo, extension->row);\n    }\n\n    SNMP_FREE( extension->token );\n    SNMP_FREE( extension->cache );\n    SNMP_FREE( extension->command );\n    SNMP_FREE( extension->args  );\n    SNMP_FREE( extension->input );\n    SNMP_FREE( extension );\n    return;\n}\n\nnetsnmp_extend *\n_new_extension( char *exec_name, int exec_flags, extend_registration_block *ereg )\n{\n    netsnmp_extend     *extension;\n    netsnmp_table_row  *row;\n    netsnmp_extend     *eptr1, *eptr2; \n    netsnmp_table_data *dinfo = ereg->dinfo;\n\n    if (!exec_name)\n        return NULL;\n    extension = SNMP_MALLOC_TYPEDEF( netsnmp_extend );\n    if (!extension)\n        return NULL;\n    extension->token    = strdup( exec_name );\n    extension->flags    = exec_flags;\n    extension->cache    = netsnmp_cache_create( 0, extend_load_cache,\n                                                   extend_free_cache, NULL, 0 );\n    if (extension->cache)\n        extension->cache->magic = extension;\n\n    row = netsnmp_create_table_data_row();\n    if (!row || !extension->cache) {\n        _free_extension( extension, ereg );\n        SNMP_FREE( row );\n        return NULL;\n    }\n    row->data = (void *)extension;\n    extension->row = row;\n    netsnmp_table_row_add_index( row, ASN_OCTET_STR,\n                                 exec_name, strlen(exec_name));\n    if ( netsnmp_table_data_add_row( dinfo, row) != SNMPERR_SUCCESS ) {\n        /* _free_extension( extension, ereg ); */\n        SNMP_FREE( extension );  /* Probably not sufficient */\n        SNMP_FREE( row );\n        return NULL;\n    }\n\n    ereg->num_entries++;\n        /*\n         *  Now add this structure to a private linked list.\n         *  We don't need this for the main tables - the\n         *   'table_data' helper will take care of those.\n         *  But it's probably easier to handle the multi-line\n         *  output table ourselves, for which we need access\n         *  to the underlying data.\n         *   So we'll keep a list internally as well.\n         */\n    for ( eptr1 = ereg->ehead, eptr2 = NULL;\n          eptr1;\n          eptr2 = eptr1, eptr1 = eptr1->next ) {\n\n        if (strlen( eptr1->token )  > strlen( exec_name ))\n            break;\n        if (strlen( eptr1->token ) == strlen( exec_name ) &&\n            strcmp( eptr1->token, exec_name ) > 0 )\n            break;\n    }\n    if ( eptr2 )\n        eptr2->next = extension;\n    else\n        ereg->ehead = extension;\n    extension->next = eptr1;\n    return extension;\n}\n\nvoid\nextend_parse_config(const char *token, char *cptr)\n{\n    netsnmp_extend *extension;\n    char exec_name[STRMAX];\n    char exec_name2[STRMAX];     /* For use with UCD execFix directive */\n    char exec_command[STRMAX];\n    oid  oid_buf[MAX_OID_LEN];\n    size_t oid_len;\n    extend_registration_block *eptr;\n    int  flags;\n    int cache_timeout = 0;\n    int exec_type = NS_EXTEND_ETYPE_EXEC;\n\n    cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    if (strcmp(exec_name, \"-cacheTime\") == 0) {\n        char cache_timeout_str[32];\n\n        cptr = copy_nword(cptr, cache_timeout_str, sizeof(cache_timeout_str));\n        /* If atoi can't do the conversion, it returns 0 */\n        cache_timeout = atoi(cache_timeout_str);\n        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    }\n    if (strcmp(exec_name, \"-execType\") == 0) {\n        char exec_type_str[16];\n\n        cptr = copy_nword(cptr, exec_type_str, sizeof(exec_type_str));\n        if (strcmp(exec_type_str, \"sh\") == 0)\n            exec_type = NS_EXTEND_ETYPE_SHELL;\n        else\n            exec_type = NS_EXTEND_ETYPE_EXEC;\n        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    }\n    if ( *exec_name == '.' ) {\n        oid_len = MAX_OID_LEN - 2;\n        if (0 == read_objid( exec_name, oid_buf, &oid_len )) {\n            config_perror(\"ERROR: Unrecognised OID\" );\n            return;\n        }\n        cptr = copy_nword(cptr, exec_name,    sizeof(exec_name));\n        if (!strcmp( token, \"sh\"   ) ||\n            !strcmp( token, \"exec\" )) {\n            config_perror(\"ERROR: This output format has been deprecated - Please use the 'extend' directive instead\" );\n            return;\n        }\n    } else {\n        memcpy( oid_buf, ns_extend_oid, sizeof(ns_extend_oid));\n        oid_len = OID_LENGTH(ns_extend_oid);\n    }\n    cptr = copy_nword(cptr, exec_command, sizeof(exec_command));\n    /* XXX - check 'exec_command' exists & is executable */\n    flags = (NS_EXTEND_FLAGS_ACTIVE | NS_EXTEND_FLAGS_CONFIG);\n    if (!strcmp( token, \"sh\"        ) ||\n        !strcmp( token, \"extend-sh\" ) ||\n        !strcmp( token, \"sh2\") ||\n        exec_type == NS_EXTEND_ETYPE_SHELL)\n        flags |= NS_EXTEND_FLAGS_SHELL;\n    if (!strcmp( token, \"execFix\"   ) ||\n        !strcmp( token, \"extendfix\" ) ||\n        !strcmp( token, \"execFix2\" )) {\n        strcpy( exec_name2, exec_name );\n        strcat( exec_name, \"Fix\" );\n        flags |= NS_EXTEND_FLAGS_WRITEABLE;\n        /* XXX - Check for shell... */\n    }\n\n    eptr      = _register_extend( oid_buf, oid_len );\n    if (!eptr) {\n        snmp_log(LOG_ERR, \"Failed to register extend entry '%s' - possibly duplicate name.\\n\", exec_name );\n        return;\n    }\n    extension = _new_extension( exec_name, flags, eptr );\n    if (extension) {\n        extension->command  = strdup( exec_command );\n        if (cptr)\n            extension->args = strdup( cptr );\n        if (cache_timeout != 0)\n            extension->cache->timeout = cache_timeout;\n    } else {\n        snmp_log(LOG_ERR, \"Failed to register extend entry '%s' - possibly duplicate name.\\n\", exec_name );\n        return;\n    }\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    /*\n     *  Compatability with the UCD extTable\n     */\n    if (!strcmp( token, \"execFix\"  )) {\n        int  i;\n        for ( i=0; i < num_compatability_entries; i++ ) {\n            if (!strcmp( exec_name2,\n                    compatability_entries[i].exec_entry->token))\n                break;\n        }\n        if ( i == num_compatability_entries )\n            config_perror(\"No matching exec entry\" );\n        else\n            compatability_entries[ i ].efix_entry = extension;\n            \n    } else if (!strcmp( token, \"sh\"   ) ||\n               !strcmp( token, \"exec\" )) {\n        if ( num_compatability_entries == max_compatability_entries ) {\n            /* XXX - should really use dynamic allocation */\n            netsnmp_old_extend *new_compatability_entries;\n            new_compatability_entries = realloc(compatability_entries,\n                             max_compatability_entries*2*sizeof(netsnmp_old_extend));\n            if (!new_compatability_entries)\n                config_perror(\"No further UCD-compatible entries\" );\n            else {\n                memset(new_compatability_entries+num_compatability_entries, 0,\n                        sizeof(netsnmp_old_extend)*max_compatability_entries);\n                max_compatability_entries *= 2;\n                compatability_entries = new_compatability_entries;\n            }\n        }\n        if (num_compatability_entries != max_compatability_entries)\n            compatability_entries[\n                num_compatability_entries++ ].exec_entry = extension;\n    }\n#endif\n}\n\n        /*************************\n         *\n         *  Main table handlers\n         *  Most of the work is handled\n         *   by the 'table_data' helper.\n         *\n         *************************/\n\nint\nhandle_nsExtendConfigTable(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    extend_registration_block  *eptr;\n    int  i;\n    int  need_to_validate = 0;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n        table_info = netsnmp_extract_table_info( request );\n        extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n\n        DEBUGMSGTL(( \"nsExtendTable:config\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:config\", request->requestvb->name,\n                                             request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:config\", \" (%s)\\n\",\n                      se_find_label_in_slist(\"agent_mode\", reqinfo->mode)));\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->command,\n                    (extension->command)?strlen(extension->command):0);\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->args,\n                    (extension->args)?strlen(extension->args):0);\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->input,\n                    (extension->input)?strlen(extension->input):0);\n                break;\n            case COLUMN_EXTCFG_CACHETIME:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->cache->timeout, sizeof(int));\n                break;\n            case COLUMN_EXTCFG_EXECTYPE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_SHELL) ?\n                                         NS_EXTEND_ETYPE_SHELL :\n                                         NS_EXTEND_ETYPE_EXEC);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n            case COLUMN_EXTCFG_RUNTYPE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) ?\n                                         NS_EXTEND_RTYPE_RWRITE :\n                                         NS_EXTEND_RTYPE_RONLY);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n\n            case COLUMN_EXTCFG_STORAGE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_CONFIG) ?\n                                         ST_PERMANENT : ST_VOLATILE);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = ((extension->flags & NS_EXTEND_FLAGS_ACTIVE) ?\n                                         RS_ACTIVE :\n                                         RS_NOTINSERVICE);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n\n        /**********\n         *\n         * Start of SET handling\n         *\n         *   All config objects are potentially writable except\n         *     nsExtendStorage which is fixed as either 'permanent'\n         *     (if read from a config file) or 'volatile' (if set via SNMP)\n         *   The string-based settings of a 'permanent' entry cannot \n         *     be changed - neither can the execution or run type.\n         *   Such entries can be (temporarily) marked as inactive,\n         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********/\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n        case MODE_SET_RESERVE1:\n            /*\n             * Validate the new assignments\n             */\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                /*\n                 * Must have a full path to the command\n                 * XXX - Assumes Unix-style paths\n                 */\n                if (request->requestvb->val_len == 0 ||\n                    request->requestvb->val.string[0] != '/') {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                /*\n                 * XXX - need to check this file exists\n                 *       (and is executable)\n                 */\n\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_ARGS:\n            case COLUMN_EXTCFG_INPUT:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_CACHETIME:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                /*\n                 * -1 is a special value indicating \"don't cache\"\n                 *    [[ XXX - should this be 0 ?? ]]\n                 * Otherwise, cache times must be non-negative\n                 */\n                if (i < -1 ) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_EXECTYPE:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                if (i<1 || i>2) {  /* 'exec(1)' or 'shell(2)' only */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_RUNTYPE:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                /*\n                 * 'run-on-read(1)', 'run-on-set(2)'\n                 *  or 'run-command(3)' only\n                 */\n                i = *request->requestvb->val.integer;\n                if (i<1 || i>3) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                /*\n                 * 'run-command(3)' can only be used with\n                 *  a pre-existing 'run-on-set(2)' entry.\n                 */\n                if (i==3 && !(extension && (extension->flags & NS_EXTEND_FLAGS_WRITEABLE))) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n                /*\n                 * 'run-command(3)' is the only valid assignment\n                 *  for permanent (i.e. config) entries\n                 */\n                if ((extension && extension->flags & NS_EXTEND_FLAGS_CONFIG)\n                    && i!=3 ) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_STATUS:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_NOTINSERVICE:\n                    if (!extension) {\n                        /* Must be used with existing rows */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_INCONSISTENTVALUE);\n                        return SNMP_ERR_INCONSISTENTVALUE;\n                    }\n                    break;    /* OK */\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    if (extension) {\n                        /* Can only be used to create new rows */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_INCONSISTENTVALUE);\n                        return SNMP_ERR_INCONSISTENTVALUE;\n                    }\n                    break;\n                case RS_DESTROY:\n                    break;\n                default:\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                break;\n\n            default:\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_ERR_NOTWRITABLE);\n                return SNMP_ERR_NOTWRITABLE;\n            }\n            break;\n\n        case MODE_SET_RESERVE2:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    extension = _new_extension( (char *) table_info->indexes->val.string,\n                                                0, eptr );\n                    if (!extension) {  /* failed */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_RESOURCEUNAVAILABLE);\n                        return SNMP_ERR_RESOURCEUNAVAILABLE;\n                    }\n                    netsnmp_insert_table_row( request, extension->row );\n                }\n            }\n            break;\n\n        case MODE_SET_FREE:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                }\n            }\n            break;\n\n        case MODE_SET_ACTION:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                extension->old_command = extension->command;\n                extension->command = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                extension->old_args = extension->args;\n                extension->args = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                extension->old_input = extension->input;\n                extension->input = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_CREATEANDGO:\n                    need_to_validate = 1;\n                }\n                break;\n            }\n            break;\n\n        case MODE_SET_UNDO:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if ( extension && extension->old_command ) {\n                    SNMP_FREE(extension->command);\n                    extension->command     = extension->old_command;\n                    extension->old_command = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                if ( extension && extension->old_args ) {\n                    SNMP_FREE(extension->args);\n                    extension->args     = extension->old_args;\n                    extension->old_args = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                if ( extension && extension->old_input ) {\n                    SNMP_FREE(extension->input);\n                    extension->input     = extension->old_input;\n                    extension->old_input = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                }\n                break;\n            }\n            break;\n\n        case MODE_SET_COMMIT:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_CACHETIME:\n                i = *request->requestvb->val.integer;\n                extension->cache->timeout = i;\n                break;\n\n            case COLUMN_EXTCFG_RUNTYPE:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case 1:\n                    extension->flags &= ~NS_EXTEND_FLAGS_WRITEABLE;\n                    break;\n                case 2:\n                    extension->flags |=  NS_EXTEND_FLAGS_WRITEABLE;\n                    break;\n                case 3:\n                    (void)netsnmp_cache_check_and_reload( extension->cache );\n                    break;\n                }\n                break;\n\n            case COLUMN_EXTCFG_EXECTYPE:\n                i = *request->requestvb->val.integer;\n                if ( i == NS_EXTEND_ETYPE_SHELL )\n                    extension->flags |=  NS_EXTEND_FLAGS_SHELL;\n                else\n                    extension->flags &= ~NS_EXTEND_FLAGS_SHELL;\n                break;\n\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_CREATEANDGO:\n                    extension->flags |= NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_NOTINSERVICE:\n                case RS_CREATEANDWAIT:\n                    extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_DESTROY:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */ \n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    /*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     */\n    if (need_to_validate) {\n        for ( request=requests; request; request=request->next ) {\n            if (request->processed)\n                continue;\n            table_info = netsnmp_extract_table_info( request );\n            extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                if (( i == RS_ACTIVE || i == RS_CREATEANDGO ) &&\n                    !(extension && extension->command &&\n                      extension->command[0] == '/' /* &&\n                      is_executable(extension->command) */)) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n    \n    return SNMP_ERR_NOERROR;\n}\n\n\nint\nhandle_nsExtendOutput1Table(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    int len;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n        table_info = netsnmp_extract_table_info( request );\n        extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n\n        DEBUGMSGTL(( \"nsExtendTable:output1\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:output1\", request->requestvb->name,\n                                              request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:output1\", \"\\n\"));\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n            if (!extension || !(extension->flags & NS_EXTEND_FLAGS_ACTIVE)) {\n                /*\n                 * If this row is inactive, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n            if (!(extension->flags & NS_EXTEND_FLAGS_WRITEABLE) &&\n                (netsnmp_cache_check_and_reload( extension->cache ) < 0 )) {\n                /*\n                 * If reloading the output cache of a 'run-on-read'\n                 * entry fails, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n            if ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) &&\n                (netsnmp_cache_check_expired( extension->cache ) == 1 )) {\n                /*\n                 * If the output cache of a 'run-on-write'\n                 * entry has expired, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n\n            switch (table_info->colnum) {\n            case COLUMN_EXTOUT1_OUTLEN:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->out_len, sizeof(int));\n                break;\n            case COLUMN_EXTOUT1_OUTPUT1:\n                /* \n                 * If we've got more than one line,\n                 * find the length of the first one.\n                 * Otherwise find the length of the whole string.\n                 */\n                if (extension->numlines > 1) {\n                    len = (extension->lines[1])-(extension->output) -1;\n                } else if (extension->output) {\n                    len = strlen(extension->output);\n                } else {\n                    len = 0;\n                }\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->output, len);\n                break;\n            case COLUMN_EXTOUT1_OUTPUT2:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->output,\n                    (extension->output)?extension->out_len:0);\n                break;\n            case COLUMN_EXTOUT1_NUMLINES:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->numlines, sizeof(int));\n                break;\n            case COLUMN_EXTOUT1_RESULT:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->result, sizeof(int));\n                break;\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n    return SNMP_ERR_NOERROR;\n}\n\n\n        /*************************\n         *\n         *  Multi-line output table handler\n         *  Most of the work is handled here.\n         *\n         *************************/\n\n\n/*\n *  Locate the appropriate entry for a given request\n */\nnetsnmp_extend *\n_extend_find_entry( netsnmp_request_info       *request,\n                    netsnmp_table_request_info *table_info,\n                    int mode  )\n{\n    netsnmp_extend            *eptr;\n    extend_registration_block *ereg;\n    unsigned int line_idx;\n    oid oid_buf[MAX_OID_LEN];\n    int oid_len;\n    int i;\n    char  *token;\n    size_t token_len;\n\n    if (!request || !table_info || !table_info->indexes\n                 || !table_info->indexes->next_variable) {\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"invalid invocation\\n\"));\n        return NULL;\n    }\n\n    ereg = _find_extension_block( request->requestvb->name,\n                                  request->requestvb->name_length );\n\n    /***\n     *  GET handling - find the exact entry being requested\n     ***/\n    if ( mode == MODE_GET ) {\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"GET: %s / %ld\\n \",\n                      table_info->indexes->val.string,\n                     *table_info->indexes->next_variable->val.integer));\n        for ( eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n            if ( !strcmp( eptr->token, (char *) table_info->indexes->val.string ))\n                break;\n        }\n\n        if ( eptr ) {\n            /*\n             * Ensure the output is available...\n             */\n            if (!(eptr->flags & NS_EXTEND_FLAGS_ACTIVE) ||\n               (netsnmp_cache_check_and_reload( eptr->cache ) < 0 ))\n                return NULL;\n\n            /*\n             * ...and check the line requested is valid\n             */\n            line_idx = *table_info->indexes->next_variable->val.integer;\n            if (line_idx < 1 || line_idx > eptr->numlines)\n                return NULL;\n        }\n    }\n\n        /***\n         *  GETNEXT handling - find the first suitable entry\n         ***/\n    else {\n        if (!table_info->indexes->val_len ) {\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT: first entry\\n\"));\n            /*\n             * Beginning of the table - find the first active\n             *  (and successful) entry, and use the first line of it\n             */\n            for (eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n                if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                    (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                    line_idx = 1;\n                    break;\n                }\n            }\n        } else {\n            token     =  (char *) table_info->indexes->val.string;\n            token_len =  table_info->indexes->val_len;\n            line_idx  = *table_info->indexes->next_variable->val.integer;\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT: %s / %d\\n \",\n                          token, line_idx ));\n            /*\n             * Otherwise, find the first entry not earlier\n             * than the requested token...\n             */\n            for (eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n                if ( strlen(eptr->token) > token_len )\n                    break;\n                if ( strlen(eptr->token) == token_len &&\n                     strcmp(eptr->token, token) >= 0 )\n                    break;\n            }\n            if (!eptr)\n                return NULL;    /* (assuming there is one) */\n\n            /*\n             * ... and make sure it's active & the output is available\n             * (or use the first following entry that is)\n             */\n            for (    ; eptr; eptr = eptr->next ) {\n                if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                    (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                    break;\n                }\n                line_idx = 1;\n            }\n\n            if (!eptr)\n                return NULL;    /* (assuming there is one) */\n\n            /*\n             *  If we're working with the same entry that was requested,\n             *  see whether we've reached the end of the output...\n             */\n            if (!strcmp( eptr->token, token )) {\n                if ( eptr->numlines <= line_idx ) {\n                    /*\n                     * ... and if so, move on to the first line\n                     * of the next (active and successful) entry.\n                     */\n                    line_idx = 1;\n                    for (eptr = eptr->next ; eptr; eptr = eptr->next ) {\n                        if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                            (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                            break;\n                        }\n                    }\n                } else {\n                    /*\n                     * Otherwise just use the next line of this entry.\n                     */\n                    line_idx++;\n                }\n            }\n            else {\n                /*\n                 * If this is not the same entry that was requested,\n                 * then we should return the first line.\n                 */\n                line_idx = 1;\n            }\n        }\n        if (eptr) {\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT -> %s / %d\\n \",\n                          eptr->token, line_idx));\n            /*\n             * Since we're processing a GETNEXT request,\n             * now we've found the appropriate entry (and line),\n             * we need to update the varbind OID ...\n             */\n            memset(oid_buf, 0, sizeof(oid_buf));\n            oid_len = ereg->oid_len;\n            memcpy( oid_buf, ereg->root_oid, oid_len*sizeof(oid));\n            oid_buf[ oid_len++ ] = 4;    /* nsExtendOutput2Table */\n            oid_buf[ oid_len++ ] = 1;    /* nsExtendOutput2Entry */\n            oid_buf[ oid_len++ ] = COLUMN_EXTOUT2_OUTLINE;\n                                         /* string token index */\n            oid_buf[ oid_len++ ] = strlen(eptr->token);\n            for ( i=0; i < (int)strlen(eptr->token); i++ )\n                oid_buf[ oid_len+i ] = eptr->token[i];\n            oid_len += strlen( eptr->token );\n                                         /* plus line number */\n            oid_buf[ oid_len++ ] = line_idx;\n            snmp_set_var_objid( request->requestvb, oid_buf, oid_len );\n            /*\n             * ... and index values to match.\n             */\n            snmp_set_var_value( table_info->indexes,\n                                eptr->token, strlen(eptr->token));\n            snmp_set_var_value( table_info->indexes->next_variable,\n                                (const u_char*)&line_idx, sizeof(line_idx));\n        }\n    }\n    return eptr;  /* Finally, signal success */\n}\n\n/*\n *  Multi-line output handler\n *  Locate the appropriate entry (using _extend_find_entry)\n *  and return the appropriate output line\n */\nint\nhandle_nsExtendOutput2Table(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    char *cp;\n    unsigned int line_idx;\n    int len;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n\n        table_info = netsnmp_extract_table_info( request );\n        extension  = _extend_find_entry( request, table_info, reqinfo->mode );\n\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:output2\", request->requestvb->name,\n                                              request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:output2\", \" (%s)\\n\",\n                                    (extension) ? extension->token : \"[none]\"));\n\n        if (!extension) {\n            if (reqinfo->mode == MODE_GET)\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);\n            else\n                netsnmp_set_request_error(reqinfo, request, SNMP_ENDOFMIBVIEW);\n            continue;\n        }\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n        case MODE_GETNEXT:\n            switch (table_info->colnum) {\n            case COLUMN_EXTOUT2_OUTLINE:\n                /* \n                 * Determine which line we've been asked for....\n                 */\n                line_idx = *table_info->indexes->next_variable->val.integer;\n                if (line_idx < 1 || line_idx > extension->numlines) {\n                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);\n                    continue;\n                }\n                cp  = extension->lines[line_idx-1];\n\n                /* \n                 * ... and how long it is.\n                 */\n                if ( extension->numlines > line_idx )\n                    len = (extension->lines[line_idx])-cp -1;\n                else if (cp)\n                    len = strlen(cp);\n                else\n                    len = 0;\n\n                snmp_set_var_typed_value( request->requestvb,\n                                          ASN_OCTET_STR, cp, len );\n                break;\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n    return SNMP_ERR_NOERROR;\n}\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n        /*************************\n         *\n         *  Compatability with the UCD extTable\n         *\n         *************************/\n\nchar * _get_cmdline(netsnmp_extend *extend)\n{\n    size_t          size;\n    char           *newbuf;\n    const char     *args = extend->args;\n\n    if (args == NULL)\n        /* Use empty string for processes without arguments. */\n        args = \"\";\n\n    size = strlen(extend->command) + strlen(args) + 2;\n    if (size > cmdlinesize) {\n        newbuf = realloc(cmdlinebuf, size);\n        if (!newbuf) {\n            free(cmdlinebuf);\n            cmdlinebuf = NULL;\n            cmdlinesize = 0;\n            return NULL;\n        }\n        cmdlinebuf = newbuf;\n        cmdlinesize = size;\n    }\n    sprintf(cmdlinebuf, \"%s %s\", extend->command, args);\n    return cmdlinebuf;\n}\n\nu_char *\nvar_extensible_old(struct variable * vp,\n                     oid * name,\n                     size_t * length,\n                     int exact,\n                     size_t * var_len, WriteMethod ** write_method)\n{\n    netsnmp_old_extend *exten = NULL;\n    static long     long_ret;\n    unsigned int idx;\n    char         *cmdline;\n\n    if (header_simple_table\n        (vp, name, length, exact, var_len, write_method, num_compatability_entries))\n        return (NULL);\n\n    idx = name[*length-1] -1;\n\tif (idx > max_compatability_entries)\n\t\treturn NULL;\n    exten = &compatability_entries[idx];\n    switch (vp->magic) {\n    case MIBINDEX:\n        long_ret = name[*length - 1];\n        return (u_char *) &long_ret;\n    case ERRORNAME:        /* name defined in config file */\n        *var_len = strlen(exten->exec_entry->token);\n        return ((u_char *) (exten->exec_entry->token));\n    case SHELLCOMMAND:\n        cmdline = _get_cmdline(exten->exec_entry);\n        if (cmdline)\n            *var_len = strlen(cmdline);\n        return (u_char *) cmdline;\n    case ERRORFLAG:        /* return code from the process */\n        netsnmp_cache_check_and_reload( exten->exec_entry->cache );\n        long_ret = exten->exec_entry->result;\n        return (u_char *) &long_ret;\n    case ERRORMSG:         /* first line of text returned from the process */\n        netsnmp_cache_check_and_reload( exten->exec_entry->cache );\n        if (exten->exec_entry->numlines > 1) {\n            *var_len = (exten->exec_entry->lines[1])-\n                (exten->exec_entry->output) -1;\n        } else if (exten->exec_entry->output) {\n            *var_len = strlen(exten->exec_entry->output);\n        } else {\n            *var_len = 0;\n        }\n        return (u_char *) exten->exec_entry->output;\n    case ERRORFIX:\n        *write_method = fixExec2Error;\n        long_return = 0;\n        return (u_char *) &long_return;\n\n    case ERRORFIXCMD:\n        if (exten->efix_entry) {\n            cmdline = _get_cmdline(exten->efix_entry);\n            if (cmdline)\n                *var_len = strlen(cmdline);\n            return (u_char *) cmdline;\n        } else {\n            *var_len = 0;\n            return (u_char *) &long_return;  /* Just needs to be non-null! */\n        }\n    }\n    return NULL;\n}\n\n\nint\nfixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n    return SNMP_ERR_NOERROR;\n}\n#endif /* USING_UCD_SNMP_EXTENSIBLE_MODULE */\n"], "fixing_code": ["\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n#include <net-snmp/net-snmp-includes.h>\n#include <net-snmp/agent/net-snmp-agent-includes.h>\n#include <net-snmp/agent/watcher.h>\n#include <net-snmp/agent/agent_callbacks.h>\n\n#include \"agent/extend.h\"\n#include \"utilities/execute.h\"\n#include \"struct.h\"\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n#include \"util_funcs/header_simple_table.h\"\n#include \"mibdefs.h\"\n#define SHELLCOMMAND 3\n#endif\n\n/*  This mib is potentially dangerous to turn on by default, since it\n *  allows arbitrary commands to be set by anyone with SNMP WRITE\n *  access to the MIB table.  If all of your users are \"root\" level\n *  users, then it may be safe to turn on. */\n#define ENABLE_EXTEND_WRITE_ACCESS 0\n\nnetsnmp_feature_require(extract_table_row_data);\nnetsnmp_feature_require(table_data_delete_table);\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nnetsnmp_feature_require(insert_table_row);\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\noid  ns_extend_oid[]    = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2 };\n\ntypedef struct extend_registration_block_s {\n    netsnmp_table_data *dinfo;\n    oid                *root_oid;\n    size_t              oid_len;\n    long                num_entries;\n    netsnmp_extend     *ehead;\n    netsnmp_handler_registration       *reg[4];\n    struct extend_registration_block_s *next;\n} extend_registration_block;\nextend_registration_block *ereg_head = NULL;\n\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\ntypedef struct netsnmp_old_extend_s {\n    unsigned int idx;\n    netsnmp_extend *exec_entry;\n    netsnmp_extend *efix_entry;\n} netsnmp_old_extend;\n\nunsigned int             num_compatability_entries = 0;\nunsigned int             max_compatability_entries = 50;\nnetsnmp_old_extend *compatability_entries;\n\nchar           *cmdlinebuf;\nsize_t          cmdlinesize;\n\nWriteMethod fixExec2Error;\nFindVarMethod var_extensible_old;\noid  old_extensible_variables_oid[] = { NETSNMP_UCDAVIS_MIB, NETSNMP_SHELLMIBNUM, 1 };\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nstruct variable2 old_extensible_variables[] = {\n    {MIBINDEX,     ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {MIBINDEX}},\n    {ERRORNAME,    ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORNAME}},\n    {SHELLCOMMAND, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {SHELLCOMMAND}},\n    {ERRORFLAG,    ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFLAG}},\n    {ERRORMSG,     ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORMSG}},\n    {ERRORFIX,     ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,\n     var_extensible_old, 1, {ERRORFIX}},\n    {ERRORFIXCMD,  ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIXCMD}}\n};\n#else /* !NETSNMP_NO_WRITE_SUPPORT */\nstruct variable2 old_extensible_variables[] = {\n    {MIBINDEX,     ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {MIBINDEX}},\n    {ERRORNAME,    ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORNAME}},\n    {SHELLCOMMAND, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {SHELLCOMMAND}},\n    {ERRORFLAG,    ASN_INTEGER,   NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFLAG}},\n    {ERRORMSG,     ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORMSG}},\n    {ERRORFIX,     ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIX}},\n    {ERRORFIXCMD,  ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,\n     var_extensible_old, 1, {ERRORFIXCMD}}\n};\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n#endif\n\n\n        /*************************\n         *\n         *  Main initialisation routine\n         *\n         *************************/\n\nextend_registration_block *\n_find_extension_block( oid *name, size_t name_len )\n{\n    extend_registration_block         *eptr;\n    size_t len;\n    for ( eptr=ereg_head; eptr; eptr=eptr->next ) {\n        len = SNMP_MIN(name_len, eptr->oid_len);\n        if (!snmp_oid_compare( name, len, eptr->root_oid, eptr->oid_len))\n            return eptr;\n    }\n    return NULL;\n}\n\nextend_registration_block *\n_register_extend( oid *base, size_t len )\n{\n    extend_registration_block         *eptr;\n    oid oid_buf[MAX_OID_LEN];\n\n    netsnmp_table_data                *dinfo;\n    netsnmp_table_registration_info   *tinfo;\n    netsnmp_watcher_info              *winfo;\n    netsnmp_handler_registration      *reg = NULL;\n    int                                rc;\n\n    for ( eptr=ereg_head; eptr; eptr=eptr->next ) {\n        if (!snmp_oid_compare( base, len, eptr->root_oid, eptr->oid_len))\n            return eptr;\n    }\n    if (!eptr) {\n        eptr = SNMP_MALLOC_TYPEDEF( extend_registration_block );\n        if (!eptr)\n            return NULL;\n        eptr->root_oid = snmp_duplicate_objid( base, len );\n        eptr->oid_len  = len;\n        eptr->num_entries = 0;\n        eptr->ehead       = NULL;\n        eptr->dinfo       = netsnmp_create_table_data( \"nsExtendTable\" );\n        eptr->next        = ereg_head;\n        ereg_head         = eptr;\n    }\n\n    dinfo = eptr->dinfo;\n    memcpy( oid_buf, base, len*sizeof(oid) );\n\n        /*\n         * Register the configuration table\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, 0 );\n    tinfo->min_column = COLUMN_EXTCFG_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTCFG_LAST_COLUMN;\n    oid_buf[len] = 2;\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendConfigTable\", handle_nsExtendConfigTable, \n                oid_buf, len+1, HANDLER_CAN_RWRITE);\n#else /* !NETSNMP_NO_WRITE_SUPPORT */\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendConfigTable\", handle_nsExtendConfigTable, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n    rc = netsnmp_register_table_data( reg, dinfo, tinfo );\n    if (rc != SNMPERR_SUCCESS) {\n        goto bail;\n    }\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[0] = reg;\n\n        /*\n         * Register the main output table\n         *   using the same table_data handle.\n         * This is sufficient to link the two tables,\n         *   and implement the AUGMENTS behaviour\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, 0 );\n    tinfo->min_column = COLUMN_EXTOUT1_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTOUT1_LAST_COLUMN;\n    oid_buf[len] = 3;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendOut1Table\", handle_nsExtendOutput1Table, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    rc = netsnmp_register_table_data( reg, dinfo, tinfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[1] = reg;\n\n        /*\n         * Register the multi-line output table\n         *   using a simple table helper.\n         * This handles extracting the indexes from\n         *   the request OID, but leaves most of\n         *   the work to our handler routine.\n         * Still, it was nice while it lasted...\n         */\n    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );\n    netsnmp_table_helper_add_indexes( tinfo, ASN_OCTET_STR, ASN_INTEGER, 0 );\n    tinfo->min_column = COLUMN_EXTOUT2_FIRST_COLUMN;\n    tinfo->max_column = COLUMN_EXTOUT2_LAST_COLUMN;\n    oid_buf[len] = 4;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendOut2Table\", handle_nsExtendOutput2Table, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    rc = netsnmp_register_table( reg, tinfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    netsnmp_handler_owns_table_info(reg->handler->next);\n    eptr->reg[2] = reg;\n\n        /*\n         * Register a watched scalar to keep track of the number of entries\n         */\n    oid_buf[len] = 1;\n    reg   = netsnmp_create_handler_registration(\n                \"nsExtendNumEntries\", NULL, \n                oid_buf, len+1, HANDLER_CAN_RONLY);\n    winfo = netsnmp_create_watcher_info(\n                &(eptr->num_entries), sizeof(eptr->num_entries),\n                ASN_INTEGER, WATCHER_FIXED_SIZE);\n    rc = netsnmp_register_watched_scalar2( reg, winfo );\n    if (rc != SNMPERR_SUCCESS)\n        goto bail;\n    eptr->reg[3] = reg;\n\n    return eptr;\n\nbail:\n    if (eptr->reg[3])\n        netsnmp_unregister_handler(eptr->reg[3]);\n    if (eptr->reg[2])\n        netsnmp_unregister_handler(eptr->reg[2]);\n    if (eptr->reg[1])\n        netsnmp_unregister_handler(eptr->reg[1]);\n    if (eptr->reg[0])\n        netsnmp_unregister_handler(eptr->reg[0]);\n    return NULL;\n}\n\nstatic void\n_unregister_extend(extend_registration_block *eptr)\n{\n    extend_registration_block *prev;\n\n    netsnmp_assert(eptr);\n    for (prev = ereg_head; prev && prev->next != eptr; prev = prev->next)\n\t;\n    if (prev) {\n        netsnmp_assert(eptr == prev->next);\n\tprev->next = eptr->next;\n    } else {\n        netsnmp_assert(eptr == ereg_head);\n\tereg_head = eptr->next;\n    }\n\n    netsnmp_table_data_delete_table(eptr->dinfo);\n    free(eptr->root_oid);\n    free(eptr);\n}\n\nint\nextend_clear_callback(int majorID, int minorID,\n                    void *serverarg, void *clientarg)\n{\n    extend_registration_block *eptr, *enext = NULL;\n\n    for ( eptr=ereg_head; eptr; eptr=enext ) {\n        enext=eptr->next;\n        netsnmp_unregister_handler( eptr->reg[0] );\n        netsnmp_unregister_handler( eptr->reg[1] );\n        netsnmp_unregister_handler( eptr->reg[2] );\n        netsnmp_unregister_handler( eptr->reg[3] );\n        SNMP_FREE(eptr);\n    }\n    ereg_head = NULL;\n    return 0;\n}\n\nvoid init_extend( void )\n{\n    snmpd_register_config_handler(\"extend\",    extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"extend-sh\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"extendfix\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"exec2\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"sh2\",   extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"execFix2\", extend_parse_config, NULL, NULL);\n    (void)_register_extend( ns_extend_oid, OID_LENGTH(ns_extend_oid));\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    snmpd_register_config_handler(\"exec\", extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"sh\",   extend_parse_config, NULL, NULL);\n    snmpd_register_config_handler(\"execFix\", extend_parse_config, NULL, NULL);\n    compatability_entries = (netsnmp_old_extend *)\n        calloc( max_compatability_entries, sizeof(netsnmp_old_extend));\n    REGISTER_MIB(\"ucd-extensible\", old_extensible_variables,\n                 variable2, old_extensible_variables_oid);\n#endif\n\n    snmp_register_callback(SNMP_CALLBACK_APPLICATION,\n                           SNMPD_CALLBACK_PRE_UPDATE_CONFIG,\n                           extend_clear_callback, NULL);\n}\n\nvoid\nshutdown_extend(void)\n{\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    free(compatability_entries);\n    compatability_entries = NULL;\n#endif\n    while (ereg_head)\n\t_unregister_extend(ereg_head);\n}\n\n        /*************************\n         *\n         *  Cached-data hooks\n         *  see 'cache_handler' helper\n         *\n         *************************/\n\nint\nextend_load_cache(netsnmp_cache *cache, void *magic)\n{\n#ifndef USING_UTILITIES_EXECUTE_MODULE\n    NETSNMP_LOGONCE((LOG_WARNING,\"support for run_exec_command not available\\n\"));\n    return -1;\n#else\n    int  out_len = 1024*100;\n    char out_buf[ 1024*100 ];\n    int  cmd_len = 255*2 + 2;\t/* 2 * DisplayStrings */\n    char cmd_buf[ 255*2 + 2 ];\n    int  ret;\n    char *cp;\n    char *line_buf[ 1024 ];\n    netsnmp_extend *extension = (netsnmp_extend *)magic;\n\n    if (!magic)\n        return -1;\n    DEBUGMSGTL(( \"nsExtendTable:cache\", \"load %s\", extension->token ));\n    if ( extension->args )\n        snprintf( cmd_buf, cmd_len, \"%s %s\", extension->command, extension->args );\n    else \n        snprintf( cmd_buf, cmd_len, \"%s\", extension->command );\n    if ( extension->flags & NS_EXTEND_FLAGS_SHELL )\n        ret = run_shell_command( cmd_buf, extension->input, out_buf, &out_len);\n    else\n        ret = run_exec_command(  cmd_buf, extension->input, out_buf, &out_len);\n    DEBUGMSG(( \"nsExtendTable:cache\", \": %s : %d\\n\", cmd_buf, ret));\n    if (ret >= 0) {\n        if (out_buf[   out_len-1 ] == '\\n')\n            out_buf[ --out_len   ] =  '\\0';\t/* Stomp on trailing newline */\n        extension->output   = strdup( out_buf );\n        extension->out_len  = out_len;\n        /*\n         * Now we need to pick the output apart into separate lines.\n         * Start by counting how many lines we've got, and keeping\n         * track of where each line starts in a static buffer\n         */\n        extension->numlines = 1;\n        line_buf[ 0 ] = extension->output;\n        for (cp=extension->output; *cp; cp++) {\n            if (*cp == '\\n') {\n                line_buf[ extension->numlines++ ] = cp+1;\n            }\n        }\n        if ( extension->numlines > 1 ) {\n            extension->lines = (char**)calloc( sizeof(char *), extension->numlines );\n            memcpy( extension->lines, line_buf,\n                                       sizeof(char *) * extension->numlines );\n        } else {\n            extension->lines = &extension->output;\n        }\n    }\n    extension->result = ret;\n    return ret;\n#endif /* !defined(USING_UTILITIES_EXECUTE_MODULE) */\n}\n\nvoid\nextend_free_cache(netsnmp_cache *cache, void *magic)\n{\n    netsnmp_extend *extension = (netsnmp_extend *)magic;\n    if (!magic)\n        return;\n\n    DEBUGMSGTL(( \"nsExtendTable:cache\", \"free %s\\n\", extension->token ));\n    if (extension->output) {\n        SNMP_FREE(extension->output);\n        extension->output = NULL;\n    }\n    if ( extension->numlines > 1 ) {\n        SNMP_FREE(extension->lines);\n    }\n    extension->lines  = NULL;\n    extension->out_len  = 0;\n    extension->numlines = 0;\n}\n\n\n        /*************************\n         *\n         *  Utility routines for setting up a new entry\n         *  (either via SET requests, or the config file)\n         *\n         *************************/\n\nvoid\n_free_extension( netsnmp_extend *extension, extend_registration_block *ereg )\n{\n    netsnmp_extend *eptr  = NULL;\n    netsnmp_extend *eprev = NULL;\n\n    if (!extension)\n        return;\n\n    if (ereg) {\n        /* Unlink from 'ehead' list */\n        for (eptr=ereg->ehead; eptr; eptr=eptr->next) {\n            if (eptr == extension)\n                break;\n            eprev = eptr;\n        }\n        if (!eptr) {\n            snmp_log(LOG_ERR,\n                     \"extend: fell off end of list before finding extension\\n\");\n            return;\n        }\n        if (eprev)\n            eprev->next = eptr->next;\n        else\n            ereg->ehead = eptr->next;\n        netsnmp_table_data_remove_and_delete_row( ereg->dinfo, extension->row);\n    }\n\n    SNMP_FREE( extension->token );\n    SNMP_FREE( extension->cache );\n    SNMP_FREE( extension->command );\n    SNMP_FREE( extension->args  );\n    SNMP_FREE( extension->input );\n    SNMP_FREE( extension );\n    return;\n}\n\nnetsnmp_extend *\n_new_extension( char *exec_name, int exec_flags, extend_registration_block *ereg )\n{\n    netsnmp_extend     *extension;\n    netsnmp_table_row  *row;\n    netsnmp_extend     *eptr1, *eptr2; \n    netsnmp_table_data *dinfo = ereg->dinfo;\n\n    if (!exec_name)\n        return NULL;\n    extension = SNMP_MALLOC_TYPEDEF( netsnmp_extend );\n    if (!extension)\n        return NULL;\n    extension->token    = strdup( exec_name );\n    extension->flags    = exec_flags;\n    extension->cache    = netsnmp_cache_create( 0, extend_load_cache,\n                                                   extend_free_cache, NULL, 0 );\n    if (extension->cache)\n        extension->cache->magic = extension;\n\n    row = netsnmp_create_table_data_row();\n    if (!row || !extension->cache) {\n        _free_extension( extension, ereg );\n        SNMP_FREE( row );\n        return NULL;\n    }\n    row->data = (void *)extension;\n    extension->row = row;\n    netsnmp_table_row_add_index( row, ASN_OCTET_STR,\n                                 exec_name, strlen(exec_name));\n    if ( netsnmp_table_data_add_row( dinfo, row) != SNMPERR_SUCCESS ) {\n        /* _free_extension( extension, ereg ); */\n        SNMP_FREE( extension );  /* Probably not sufficient */\n        SNMP_FREE( row );\n        return NULL;\n    }\n\n    ereg->num_entries++;\n        /*\n         *  Now add this structure to a private linked list.\n         *  We don't need this for the main tables - the\n         *   'table_data' helper will take care of those.\n         *  But it's probably easier to handle the multi-line\n         *  output table ourselves, for which we need access\n         *  to the underlying data.\n         *   So we'll keep a list internally as well.\n         */\n    for ( eptr1 = ereg->ehead, eptr2 = NULL;\n          eptr1;\n          eptr2 = eptr1, eptr1 = eptr1->next ) {\n\n        if (strlen( eptr1->token )  > strlen( exec_name ))\n            break;\n        if (strlen( eptr1->token ) == strlen( exec_name ) &&\n            strcmp( eptr1->token, exec_name ) > 0 )\n            break;\n    }\n    if ( eptr2 )\n        eptr2->next = extension;\n    else\n        ereg->ehead = extension;\n    extension->next = eptr1;\n    return extension;\n}\n\nvoid\nextend_parse_config(const char *token, char *cptr)\n{\n    netsnmp_extend *extension;\n    char exec_name[STRMAX];\n    char exec_name2[STRMAX];     /* For use with UCD execFix directive */\n    char exec_command[STRMAX];\n    oid  oid_buf[MAX_OID_LEN];\n    size_t oid_len;\n    extend_registration_block *eptr;\n    int  flags;\n    int cache_timeout = 0;\n    int exec_type = NS_EXTEND_ETYPE_EXEC;\n\n    cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    if (strcmp(exec_name, \"-cacheTime\") == 0) {\n        char cache_timeout_str[32];\n\n        cptr = copy_nword(cptr, cache_timeout_str, sizeof(cache_timeout_str));\n        /* If atoi can't do the conversion, it returns 0 */\n        cache_timeout = atoi(cache_timeout_str);\n        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    }\n    if (strcmp(exec_name, \"-execType\") == 0) {\n        char exec_type_str[16];\n\n        cptr = copy_nword(cptr, exec_type_str, sizeof(exec_type_str));\n        if (strcmp(exec_type_str, \"sh\") == 0)\n            exec_type = NS_EXTEND_ETYPE_SHELL;\n        else\n            exec_type = NS_EXTEND_ETYPE_EXEC;\n        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));\n    }\n    if ( *exec_name == '.' ) {\n        oid_len = MAX_OID_LEN - 2;\n        if (0 == read_objid( exec_name, oid_buf, &oid_len )) {\n            config_perror(\"ERROR: Unrecognised OID\" );\n            return;\n        }\n        cptr = copy_nword(cptr, exec_name,    sizeof(exec_name));\n        if (!strcmp( token, \"sh\"   ) ||\n            !strcmp( token, \"exec\" )) {\n            config_perror(\"ERROR: This output format has been deprecated - Please use the 'extend' directive instead\" );\n            return;\n        }\n    } else {\n        memcpy( oid_buf, ns_extend_oid, sizeof(ns_extend_oid));\n        oid_len = OID_LENGTH(ns_extend_oid);\n    }\n    cptr = copy_nword(cptr, exec_command, sizeof(exec_command));\n    /* XXX - check 'exec_command' exists & is executable */\n    flags = (NS_EXTEND_FLAGS_ACTIVE | NS_EXTEND_FLAGS_CONFIG);\n    if (!strcmp( token, \"sh\"        ) ||\n        !strcmp( token, \"extend-sh\" ) ||\n        !strcmp( token, \"sh2\") ||\n        exec_type == NS_EXTEND_ETYPE_SHELL)\n        flags |= NS_EXTEND_FLAGS_SHELL;\n    if (!strcmp( token, \"execFix\"   ) ||\n        !strcmp( token, \"extendfix\" ) ||\n        !strcmp( token, \"execFix2\" )) {\n        strcpy( exec_name2, exec_name );\n        strcat( exec_name, \"Fix\" );\n        flags |= NS_EXTEND_FLAGS_WRITEABLE;\n        /* XXX - Check for shell... */\n    }\n\n    eptr      = _register_extend( oid_buf, oid_len );\n    if (!eptr) {\n        snmp_log(LOG_ERR, \"Failed to register extend entry '%s' - possibly duplicate name.\\n\", exec_name );\n        return;\n    }\n    extension = _new_extension( exec_name, flags, eptr );\n    if (extension) {\n        extension->command  = strdup( exec_command );\n        if (cptr)\n            extension->args = strdup( cptr );\n        if (cache_timeout != 0)\n            extension->cache->timeout = cache_timeout;\n    } else {\n        snmp_log(LOG_ERR, \"Failed to register extend entry '%s' - possibly duplicate name.\\n\", exec_name );\n        return;\n    }\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n    /*\n     *  Compatability with the UCD extTable\n     */\n    if (!strcmp( token, \"execFix\"  )) {\n        int  i;\n        for ( i=0; i < num_compatability_entries; i++ ) {\n            if (!strcmp( exec_name2,\n                    compatability_entries[i].exec_entry->token))\n                break;\n        }\n        if ( i == num_compatability_entries )\n            config_perror(\"No matching exec entry\" );\n        else\n            compatability_entries[ i ].efix_entry = extension;\n            \n    } else if (!strcmp( token, \"sh\"   ) ||\n               !strcmp( token, \"exec\" )) {\n        if ( num_compatability_entries == max_compatability_entries ) {\n            /* XXX - should really use dynamic allocation */\n            netsnmp_old_extend *new_compatability_entries;\n            new_compatability_entries = realloc(compatability_entries,\n                             max_compatability_entries*2*sizeof(netsnmp_old_extend));\n            if (!new_compatability_entries)\n                config_perror(\"No further UCD-compatible entries\" );\n            else {\n                memset(new_compatability_entries+num_compatability_entries, 0,\n                        sizeof(netsnmp_old_extend)*max_compatability_entries);\n                max_compatability_entries *= 2;\n                compatability_entries = new_compatability_entries;\n            }\n        }\n        if (num_compatability_entries != max_compatability_entries)\n            compatability_entries[\n                num_compatability_entries++ ].exec_entry = extension;\n    }\n#endif\n}\n\n        /*************************\n         *\n         *  Main table handlers\n         *  Most of the work is handled\n         *   by the 'table_data' helper.\n         *\n         *************************/\n\nint\nhandle_nsExtendConfigTable(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    extend_registration_block  *eptr;\n    int  i;\n    int  need_to_validate = 0;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n        table_info = netsnmp_extract_table_info( request );\n        extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n\n        DEBUGMSGTL(( \"nsExtendTable:config\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:config\", request->requestvb->name,\n                                             request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:config\", \" (%s)\\n\",\n                      se_find_label_in_slist(\"agent_mode\", reqinfo->mode)));\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->command,\n                    (extension->command)?strlen(extension->command):0);\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->args,\n                    (extension->args)?strlen(extension->args):0);\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->input,\n                    (extension->input)?strlen(extension->input):0);\n                break;\n            case COLUMN_EXTCFG_CACHETIME:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->cache->timeout, sizeof(int));\n                break;\n            case COLUMN_EXTCFG_EXECTYPE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_SHELL) ?\n                                         NS_EXTEND_ETYPE_SHELL :\n                                         NS_EXTEND_ETYPE_EXEC);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n            case COLUMN_EXTCFG_RUNTYPE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) ?\n                                         NS_EXTEND_RTYPE_RWRITE :\n                                         NS_EXTEND_RTYPE_RONLY);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n\n            case COLUMN_EXTCFG_STORAGE:\n                i = ((extension->flags & NS_EXTEND_FLAGS_CONFIG) ?\n                                         ST_PERMANENT : ST_VOLATILE);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = ((extension->flags & NS_EXTEND_FLAGS_ACTIVE) ?\n                                         RS_ACTIVE :\n                                         RS_NOTINSERVICE);\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&i, sizeof(i));\n                break;\n\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n\n        /**********\n         *\n         * Start of SET handling\n         *\n         *   All config objects are potentially writable except\n         *     nsExtendStorage which is fixed as either 'permanent'\n         *     (if read from a config file) or 'volatile' (if set via SNMP)\n         *   The string-based settings of a 'permanent' entry cannot \n         *     be changed - neither can the execution or run type.\n         *   Such entries can be (temporarily) marked as inactive,\n         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********/\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n        case MODE_SET_RESERVE1:\n            /*\n             * Validate the new assignments\n             */\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                /*\n                 * Must have a full path to the command\n                 * XXX - Assumes Unix-style paths\n                 */\n                if (request->requestvb->val_len == 0 ||\n                    request->requestvb->val.string[0] != '/') {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                /*\n                 * XXX - need to check this file exists\n                 *       (and is executable)\n                 */\n\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_ARGS:\n            case COLUMN_EXTCFG_INPUT:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_CACHETIME:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                /*\n                 * -1 is a special value indicating \"don't cache\"\n                 *    [[ XXX - should this be 0 ?? ]]\n                 * Otherwise, cache times must be non-negative\n                 */\n                if (i < -1 ) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_EXECTYPE:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                if (i<1 || i>2) {  /* 'exec(1)' or 'shell(2)' only */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) {\n                    /*\n                     * config entries are \"permanent\" so can't be changed\n                     */\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_NOTWRITABLE);\n                    return SNMP_ERR_NOTWRITABLE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_RUNTYPE:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                /*\n                 * 'run-on-read(1)', 'run-on-set(2)'\n                 *  or 'run-command(3)' only\n                 */\n                i = *request->requestvb->val.integer;\n                if (i<1 || i>3) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                /*\n                 * 'run-command(3)' can only be used with\n                 *  a pre-existing 'run-on-set(2)' entry.\n                 */\n                if (i==3 && !(extension && (extension->flags & NS_EXTEND_FLAGS_WRITEABLE))) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n                /*\n                 * 'run-command(3)' is the only valid assignment\n                 *  for permanent (i.e. config) entries\n                 */\n                if ((extension && extension->flags & NS_EXTEND_FLAGS_CONFIG)\n                    && i!=3 ) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n                break;\n\n            case COLUMN_EXTCFG_STATUS:\n                if (request->requestvb->type != ASN_INTEGER) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                }\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_NOTINSERVICE:\n                    if (!extension) {\n                        /* Must be used with existing rows */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_INCONSISTENTVALUE);\n                        return SNMP_ERR_INCONSISTENTVALUE;\n                    }\n                    break;    /* OK */\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    if (extension) {\n                        /* Can only be used to create new rows */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_INCONSISTENTVALUE);\n                        return SNMP_ERR_INCONSISTENTVALUE;\n                    }\n                    break;\n                case RS_DESTROY:\n                    break;\n                default:\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGVALUE);\n                    return SNMP_ERR_WRONGVALUE;\n                }\n                break;\n\n            default:\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_ERR_NOTWRITABLE);\n                return SNMP_ERR_NOTWRITABLE;\n            }\n            break;\n\n        case MODE_SET_RESERVE2:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    extension = _new_extension( (char *) table_info->indexes->val.string,\n                                                0, eptr );\n                    if (!extension) {  /* failed */\n                        netsnmp_set_request_error(reqinfo, request,\n                                                  SNMP_ERR_RESOURCEUNAVAILABLE);\n                        return SNMP_ERR_RESOURCEUNAVAILABLE;\n                    }\n                    netsnmp_insert_table_row( request, extension->row );\n                }\n            }\n            break;\n\n        case MODE_SET_FREE:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                }\n            }\n            break;\n\n        case MODE_SET_ACTION:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                extension->old_command = extension->command;\n                extension->command = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                extension->old_args = extension->args;\n                extension->args = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                extension->old_input = extension->input;\n                extension->input = netsnmp_strdup_and_null(\n                    request->requestvb->val.string,\n                    request->requestvb->val_len);\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_CREATEANDGO:\n                    need_to_validate = 1;\n                }\n                break;\n            }\n            break;\n\n        case MODE_SET_UNDO:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if ( extension && extension->old_command ) {\n                    SNMP_FREE(extension->command);\n                    extension->command     = extension->old_command;\n                    extension->old_command = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_ARGS:\n                if ( extension && extension->old_args ) {\n                    SNMP_FREE(extension->args);\n                    extension->args     = extension->old_args;\n                    extension->old_args = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_INPUT:\n                if ( extension && extension->old_input ) {\n                    SNMP_FREE(extension->input);\n                    extension->input     = extension->old_input;\n                    extension->old_input = NULL;\n                }\n                break;\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_CREATEANDGO:\n                case RS_CREATEANDWAIT:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                }\n                break;\n            }\n            break;\n\n        case MODE_SET_COMMIT:\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_CACHETIME:\n                i = *request->requestvb->val.integer;\n                extension->cache->timeout = i;\n                break;\n\n            case COLUMN_EXTCFG_RUNTYPE:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case 1:\n                    extension->flags &= ~NS_EXTEND_FLAGS_WRITEABLE;\n                    break;\n                case 2:\n                    extension->flags |=  NS_EXTEND_FLAGS_WRITEABLE;\n                    break;\n                case 3:\n                    (void)netsnmp_cache_check_and_reload( extension->cache );\n                    break;\n                }\n                break;\n\n            case COLUMN_EXTCFG_EXECTYPE:\n                i = *request->requestvb->val.integer;\n                if ( i == NS_EXTEND_ETYPE_SHELL )\n                    extension->flags |=  NS_EXTEND_FLAGS_SHELL;\n                else\n                    extension->flags &= ~NS_EXTEND_FLAGS_SHELL;\n                break;\n\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                switch (i) {\n                case RS_ACTIVE:\n                case RS_CREATEANDGO:\n                    extension->flags |= NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_NOTINSERVICE:\n                case RS_CREATEANDWAIT:\n                    extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_DESTROY:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif /* !NETSNMP_NO_WRITE_SUPPORT and ENABLE_EXTEND_WRITE_ACCESS */\n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n    /*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     */\n    if (need_to_validate) {\n        for ( request=requests; request; request=request->next ) {\n            if (request->processed)\n                continue;\n            table_info = netsnmp_extract_table_info( request );\n            extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_STATUS:\n                i = *request->requestvb->val.integer;\n                if (( i == RS_ACTIVE || i == RS_CREATEANDGO ) &&\n                    !(extension && extension->command &&\n                      extension->command[0] == '/' /* &&\n                      is_executable(extension->command) */)) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT && ENABLE_EXTEND_WRITE_ACCESS */\n    \n    return SNMP_ERR_NOERROR;\n}\n\n\nint\nhandle_nsExtendOutput1Table(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    int len;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n        table_info = netsnmp_extract_table_info( request );\n        extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n\n        DEBUGMSGTL(( \"nsExtendTable:output1\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:output1\", request->requestvb->name,\n                                              request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:output1\", \"\\n\"));\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n            if (!extension || !(extension->flags & NS_EXTEND_FLAGS_ACTIVE)) {\n                /*\n                 * If this row is inactive, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n            if (!(extension->flags & NS_EXTEND_FLAGS_WRITEABLE) &&\n                (netsnmp_cache_check_and_reload( extension->cache ) < 0 )) {\n                /*\n                 * If reloading the output cache of a 'run-on-read'\n                 * entry fails, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n            if ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) &&\n                (netsnmp_cache_check_expired( extension->cache ) == 1 )) {\n                /*\n                 * If the output cache of a 'run-on-write'\n                 * entry has expired, then skip it.\n                 */\n                netsnmp_set_request_error(reqinfo, request,\n                                          SNMP_NOSUCHINSTANCE);\n                continue;\n            }\n\n            switch (table_info->colnum) {\n            case COLUMN_EXTOUT1_OUTLEN:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->out_len, sizeof(int));\n                break;\n            case COLUMN_EXTOUT1_OUTPUT1:\n                /* \n                 * If we've got more than one line,\n                 * find the length of the first one.\n                 * Otherwise find the length of the whole string.\n                 */\n                if (extension->numlines > 1) {\n                    len = (extension->lines[1])-(extension->output) -1;\n                } else if (extension->output) {\n                    len = strlen(extension->output);\n                } else {\n                    len = 0;\n                }\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->output, len);\n                break;\n            case COLUMN_EXTOUT1_OUTPUT2:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_OCTET_STR,\n                     extension->output,\n                    (extension->output)?extension->out_len:0);\n                break;\n            case COLUMN_EXTOUT1_NUMLINES:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->numlines, sizeof(int));\n                break;\n            case COLUMN_EXTOUT1_RESULT:\n                snmp_set_var_typed_value(\n                     request->requestvb, ASN_INTEGER,\n                    (u_char*)&extension->result, sizeof(int));\n                break;\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n    return SNMP_ERR_NOERROR;\n}\n\n\n        /*************************\n         *\n         *  Multi-line output table handler\n         *  Most of the work is handled here.\n         *\n         *************************/\n\n\n/*\n *  Locate the appropriate entry for a given request\n */\nnetsnmp_extend *\n_extend_find_entry( netsnmp_request_info       *request,\n                    netsnmp_table_request_info *table_info,\n                    int mode  )\n{\n    netsnmp_extend            *eptr;\n    extend_registration_block *ereg;\n    unsigned int line_idx;\n    oid oid_buf[MAX_OID_LEN];\n    int oid_len;\n    int i;\n    char  *token;\n    size_t token_len;\n\n    if (!request || !table_info || !table_info->indexes\n                 || !table_info->indexes->next_variable) {\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"invalid invocation\\n\"));\n        return NULL;\n    }\n\n    ereg = _find_extension_block( request->requestvb->name,\n                                  request->requestvb->name_length );\n\n    /***\n     *  GET handling - find the exact entry being requested\n     ***/\n    if ( mode == MODE_GET ) {\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"GET: %s / %ld\\n \",\n                      table_info->indexes->val.string,\n                     *table_info->indexes->next_variable->val.integer));\n        for ( eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n            if ( !strcmp( eptr->token, (char *) table_info->indexes->val.string ))\n                break;\n        }\n\n        if ( eptr ) {\n            /*\n             * Ensure the output is available...\n             */\n            if (!(eptr->flags & NS_EXTEND_FLAGS_ACTIVE) ||\n               (netsnmp_cache_check_and_reload( eptr->cache ) < 0 ))\n                return NULL;\n\n            /*\n             * ...and check the line requested is valid\n             */\n            line_idx = *table_info->indexes->next_variable->val.integer;\n            if (line_idx < 1 || line_idx > eptr->numlines)\n                return NULL;\n        }\n    }\n\n        /***\n         *  GETNEXT handling - find the first suitable entry\n         ***/\n    else {\n        if (!table_info->indexes->val_len ) {\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT: first entry\\n\"));\n            /*\n             * Beginning of the table - find the first active\n             *  (and successful) entry, and use the first line of it\n             */\n            for (eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n                if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                    (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                    line_idx = 1;\n                    break;\n                }\n            }\n        } else {\n            token     =  (char *) table_info->indexes->val.string;\n            token_len =  table_info->indexes->val_len;\n            line_idx  = *table_info->indexes->next_variable->val.integer;\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT: %s / %d\\n \",\n                          token, line_idx ));\n            /*\n             * Otherwise, find the first entry not earlier\n             * than the requested token...\n             */\n            for (eptr = ereg->ehead; eptr; eptr = eptr->next ) {\n                if ( strlen(eptr->token) > token_len )\n                    break;\n                if ( strlen(eptr->token) == token_len &&\n                     strcmp(eptr->token, token) >= 0 )\n                    break;\n            }\n            if (!eptr)\n                return NULL;    /* (assuming there is one) */\n\n            /*\n             * ... and make sure it's active & the output is available\n             * (or use the first following entry that is)\n             */\n            for (    ; eptr; eptr = eptr->next ) {\n                if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                    (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                    break;\n                }\n                line_idx = 1;\n            }\n\n            if (!eptr)\n                return NULL;    /* (assuming there is one) */\n\n            /*\n             *  If we're working with the same entry that was requested,\n             *  see whether we've reached the end of the output...\n             */\n            if (!strcmp( eptr->token, token )) {\n                if ( eptr->numlines <= line_idx ) {\n                    /*\n                     * ... and if so, move on to the first line\n                     * of the next (active and successful) entry.\n                     */\n                    line_idx = 1;\n                    for (eptr = eptr->next ; eptr; eptr = eptr->next ) {\n                        if ((eptr->flags & NS_EXTEND_FLAGS_ACTIVE) &&\n                            (netsnmp_cache_check_and_reload( eptr->cache ) >= 0 )) {\n                            break;\n                        }\n                    }\n                } else {\n                    /*\n                     * Otherwise just use the next line of this entry.\n                     */\n                    line_idx++;\n                }\n            }\n            else {\n                /*\n                 * If this is not the same entry that was requested,\n                 * then we should return the first line.\n                 */\n                line_idx = 1;\n            }\n        }\n        if (eptr) {\n            DEBUGMSGTL(( \"nsExtendTable:output2\", \"GETNEXT -> %s / %d\\n \",\n                          eptr->token, line_idx));\n            /*\n             * Since we're processing a GETNEXT request,\n             * now we've found the appropriate entry (and line),\n             * we need to update the varbind OID ...\n             */\n            memset(oid_buf, 0, sizeof(oid_buf));\n            oid_len = ereg->oid_len;\n            memcpy( oid_buf, ereg->root_oid, oid_len*sizeof(oid));\n            oid_buf[ oid_len++ ] = 4;    /* nsExtendOutput2Table */\n            oid_buf[ oid_len++ ] = 1;    /* nsExtendOutput2Entry */\n            oid_buf[ oid_len++ ] = COLUMN_EXTOUT2_OUTLINE;\n                                         /* string token index */\n            oid_buf[ oid_len++ ] = strlen(eptr->token);\n            for ( i=0; i < (int)strlen(eptr->token); i++ )\n                oid_buf[ oid_len+i ] = eptr->token[i];\n            oid_len += strlen( eptr->token );\n                                         /* plus line number */\n            oid_buf[ oid_len++ ] = line_idx;\n            snmp_set_var_objid( request->requestvb, oid_buf, oid_len );\n            /*\n             * ... and index values to match.\n             */\n            snmp_set_var_value( table_info->indexes,\n                                eptr->token, strlen(eptr->token));\n            snmp_set_var_value( table_info->indexes->next_variable,\n                                (const u_char*)&line_idx, sizeof(line_idx));\n        }\n    }\n    return eptr;  /* Finally, signal success */\n}\n\n/*\n *  Multi-line output handler\n *  Locate the appropriate entry (using _extend_find_entry)\n *  and return the appropriate output line\n */\nint\nhandle_nsExtendOutput2Table(netsnmp_mib_handler          *handler,\n                     netsnmp_handler_registration *reginfo,\n                     netsnmp_agent_request_info   *reqinfo,\n                     netsnmp_request_info         *requests)\n{\n    netsnmp_request_info       *request;\n    netsnmp_table_request_info *table_info;\n    netsnmp_extend             *extension;\n    char *cp;\n    unsigned int line_idx;\n    int len;\n\n    for ( request=requests; request; request=request->next ) {\n        if (request->processed)\n            continue;\n\n        table_info = netsnmp_extract_table_info( request );\n        extension  = _extend_find_entry( request, table_info, reqinfo->mode );\n\n        DEBUGMSGTL(( \"nsExtendTable:output2\", \"varbind: \"));\n        DEBUGMSGOID((\"nsExtendTable:output2\", request->requestvb->name,\n                                              request->requestvb->name_length));\n        DEBUGMSG((   \"nsExtendTable:output2\", \" (%s)\\n\",\n                                    (extension) ? extension->token : \"[none]\"));\n\n        if (!extension) {\n            if (reqinfo->mode == MODE_GET)\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);\n            else\n                netsnmp_set_request_error(reqinfo, request, SNMP_ENDOFMIBVIEW);\n            continue;\n        }\n\n        switch (reqinfo->mode) {\n        case MODE_GET:\n        case MODE_GETNEXT:\n            switch (table_info->colnum) {\n            case COLUMN_EXTOUT2_OUTLINE:\n                /* \n                 * Determine which line we've been asked for....\n                 */\n                line_idx = *table_info->indexes->next_variable->val.integer;\n                if (line_idx < 1 || line_idx > extension->numlines) {\n                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);\n                    continue;\n                }\n                cp  = extension->lines[line_idx-1];\n\n                /* \n                 * ... and how long it is.\n                 */\n                if ( extension->numlines > line_idx )\n                    len = (extension->lines[line_idx])-cp -1;\n                else if (cp)\n                    len = strlen(cp);\n                else\n                    len = 0;\n\n                snmp_set_var_typed_value( request->requestvb,\n                                          ASN_OCTET_STR, cp, len );\n                break;\n            default:\n                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);\n                continue;\n            }\n            break;\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n    return SNMP_ERR_NOERROR;\n}\n\n#ifndef USING_UCD_SNMP_EXTENSIBLE_MODULE\n        /*************************\n         *\n         *  Compatability with the UCD extTable\n         *\n         *************************/\n\nchar * _get_cmdline(netsnmp_extend *extend)\n{\n    size_t          size;\n    char           *newbuf;\n    const char     *args = extend->args;\n\n    if (args == NULL)\n        /* Use empty string for processes without arguments. */\n        args = \"\";\n\n    size = strlen(extend->command) + strlen(args) + 2;\n    if (size > cmdlinesize) {\n        newbuf = realloc(cmdlinebuf, size);\n        if (!newbuf) {\n            free(cmdlinebuf);\n            cmdlinebuf = NULL;\n            cmdlinesize = 0;\n            return NULL;\n        }\n        cmdlinebuf = newbuf;\n        cmdlinesize = size;\n    }\n    sprintf(cmdlinebuf, \"%s %s\", extend->command, args);\n    return cmdlinebuf;\n}\n\nu_char *\nvar_extensible_old(struct variable * vp,\n                     oid * name,\n                     size_t * length,\n                     int exact,\n                     size_t * var_len, WriteMethod ** write_method)\n{\n    netsnmp_old_extend *exten = NULL;\n    static long     long_ret;\n    unsigned int idx;\n    char         *cmdline;\n\n    if (header_simple_table\n        (vp, name, length, exact, var_len, write_method, num_compatability_entries))\n        return (NULL);\n\n    idx = name[*length-1] -1;\n\tif (idx > max_compatability_entries)\n\t\treturn NULL;\n    exten = &compatability_entries[idx];\n    switch (vp->magic) {\n    case MIBINDEX:\n        long_ret = name[*length - 1];\n        return (u_char *) &long_ret;\n    case ERRORNAME:        /* name defined in config file */\n        *var_len = strlen(exten->exec_entry->token);\n        return ((u_char *) (exten->exec_entry->token));\n    case SHELLCOMMAND:\n        cmdline = _get_cmdline(exten->exec_entry);\n        if (cmdline)\n            *var_len = strlen(cmdline);\n        return (u_char *) cmdline;\n    case ERRORFLAG:        /* return code from the process */\n        netsnmp_cache_check_and_reload( exten->exec_entry->cache );\n        long_ret = exten->exec_entry->result;\n        return (u_char *) &long_ret;\n    case ERRORMSG:         /* first line of text returned from the process */\n        netsnmp_cache_check_and_reload( exten->exec_entry->cache );\n        if (exten->exec_entry->numlines > 1) {\n            *var_len = (exten->exec_entry->lines[1])-\n                (exten->exec_entry->output) -1;\n        } else if (exten->exec_entry->output) {\n            *var_len = strlen(exten->exec_entry->output);\n        } else {\n            *var_len = 0;\n        }\n        return (u_char *) exten->exec_entry->output;\n    case ERRORFIX:\n        *write_method = fixExec2Error;\n        long_return = 0;\n        return (u_char *) &long_return;\n\n    case ERRORFIXCMD:\n        if (exten->efix_entry) {\n            cmdline = _get_cmdline(exten->efix_entry);\n            if (cmdline)\n                *var_len = strlen(cmdline);\n            return (u_char *) cmdline;\n        } else {\n            *var_len = 0;\n            return (u_char *) &long_return;  /* Just needs to be non-null! */\n        }\n    }\n    return NULL;\n}\n\n\nint\nfixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT && ENABLE_EXTEND_WRITE_ACCESS */\n    return SNMP_ERR_NOERROR;\n}\n#endif /* USING_UCD_SNMP_EXTENSIBLE_MODULE */\n"], "filenames": ["agent/mibgroup/agent/extend.c"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [1612], "fixing_code_start_loc": [18], "fixing_code_end_loc": [1618], "type": "CWE-269", "message": "Net-SNMP through 5.7.3 has Improper Privilege Management because SNMP WRITE access to the EXTEND MIB provides the ability to run arbitrary commands as root.", "other": {"cve": {"id": "CVE-2020-15862", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-20T01:17:13.897", "lastModified": "2020-09-04T14:58:57.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Net-SNMP through 5.7.3 has Improper Privilege Management because SNMP WRITE access to the EXTEND MIB provides the ability to run arbitrary commands as root."}, {"lang": "es", "value": "Net-SNMP versiones hasta 5.7.3, presenta una Administraci\u00f3n de Privilegios Inapropiada porque el acceso de SNMP WRITE en el EXTEND MIB provee la capacidad de ejecutar comandos arbitrarios como root."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:net-snmp:net-snmp:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.7.3", "matchCriteriaId": "8BD5C233-45FA-4501-8EA4-C28EC33E7460"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=965166", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/net-snmp/net-snmp/commit/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://salsa.debian.org/debian/net-snmp/-/commit/fad8725402752746daf0a751dcff19eb6aeab52e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2020-15862", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202008-12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200904-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4471-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/net-snmp/net-snmp/commit/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205"}}