{"buggy_code": ["import * as http from 'http';\nimport { IncomingMessage, ServerResponse, STATUS_CODES } from 'http';\nimport url from 'url';\nimport path from 'path';\nimport fs from 'fs';\nimport { Service } from './Service';\nimport { Utils } from '../Utils';\n\nconst map: Record<string, string> = {\n    '.wasm': 'application/wasm',\n    '.js': 'text/javascript',\n    '.png': 'image/png',\n    '.html': 'text/html',\n    '.css': 'text/css',\n    '.jar': 'application/java-archive',\n    '.json': 'application/json',\n    '.jpg': 'image/jpeg',\n};\n\nconst proto = 'http';\nconst PUBLIC_DIR = path.join(__dirname, '../public');\n\nexport class HttpServer implements Service {\n    private static instance: HttpServer;\n    private server?: http.Server;\n    private port = parseInt(process.argv[2], 10) || 8000;\n\n    protected constructor() {\n        // nothing here\n    }\n\n    public static getInstance(): HttpServer {\n        if (!HttpServer.instance) {\n            HttpServer.instance = new HttpServer();\n        }\n        return HttpServer.instance;\n    }\n\n    private createServer(publicDir: string): http.Server {\n        const server = http.createServer((req: IncomingMessage, res: ServerResponse) => {\n            if (!req.url) {\n                res.statusCode = 400;\n                res.end(STATUS_CODES[400]);\n                return;\n            }\n            const parsedUrl = url.parse(req.url);\n            let pathname = path.join(publicDir, (parsedUrl.pathname || '.').replace(/^(\\.)+/, '.'));\n            fs.stat(pathname, (statErr, stat) => {\n                if (statErr) {\n                    if (statErr.code === 'ENOENT') {\n                        // if the file is not found, return 404\n                        res.statusCode = 404;\n                        res.end(`File ${pathname} not found!`);\n                    } else {\n                        res.statusCode = 500;\n                        res.end(`Error getting the file: ${statErr}.`);\n                    }\n                    return;\n                }\n                if (stat.isDirectory()) {\n                    pathname = path.join(pathname, 'index.html');\n                }\n                const ext = path.parse(pathname).ext;\n                fs.readFile(pathname, (readErr, data) => {\n                    if (readErr) {\n                        res.statusCode = 500;\n                        res.end(`Error getting the file: ${statErr}.`);\n                    } else {\n                        // if the file is found, set Content-type and send data\n                        res.setHeader('Content-type', map[ext] || 'text/plain');\n                        res.end(data);\n                    }\n                });\n            });\n        });\n        server.on('close', () => {\n            console.log(`${this.getName()} stopped`);\n        });\n        return server;\n    }\n\n    public getPort(): number {\n        return this.port;\n    }\n\n    public getServer(): http.Server | undefined {\n        return this.server;\n    }\n\n    public getName(): string {\n        return `HTTP Server {tcp:${this.port}}`;\n    }\n\n    public start(): void {\n        this.server = this.createServer(PUBLIC_DIR);\n        this.server.listen(this.port, () => {\n            Utils.printListeningMsg(proto, this.port);\n        });\n    }\n\n    public release(): void {\n        this.server?.close();\n    }\n}\n"], "fixing_code": ["import * as http from 'http';\nimport { IncomingMessage, ServerResponse, STATUS_CODES } from 'http';\nimport url from 'url';\nimport path from 'path';\nimport fs from 'fs';\nimport { Service } from './Service';\nimport { Utils } from '../Utils';\n\nconst map: Record<string, string> = {\n    '.wasm': 'application/wasm',\n    '.js': 'text/javascript',\n    '.png': 'image/png',\n    '.html': 'text/html',\n    '.css': 'text/css',\n    '.jar': 'application/java-archive',\n    '.json': 'application/json',\n    '.jpg': 'image/jpeg',\n};\n\nconst proto = 'http';\nconst PUBLIC_DIR = path.join(__dirname, '../public');\n\nexport class HttpServer implements Service {\n    private static instance: HttpServer;\n    private server?: http.Server;\n    private port = parseInt(process.argv[2], 10) || 8000;\n\n    protected constructor() {\n        // nothing here\n    }\n\n    public static getInstance(): HttpServer {\n        if (!HttpServer.instance) {\n            HttpServer.instance = new HttpServer();\n        }\n        return HttpServer.instance;\n    }\n\n    private createServer(publicDir: string): http.Server {\n        const server = http.createServer((req: IncomingMessage, res: ServerResponse) => {\n            if (!req.url) {\n                res.statusCode = 400;\n                res.end(STATUS_CODES[400]);\n                return;\n            }\n            const parsedUrl = url.parse(req.url);\n            let pathname = path.join(publicDir, (parsedUrl.pathname || '.').replace(/^(\\.)+/, '.'));\n            if (pathname.indexOf(publicDir) !== 0) {\n                res.statusCode = 403;\n                res.end();\n                return;\n            }\n            fs.stat(pathname, (statErr, stat) => {\n                if (statErr) {\n                    if (statErr.code === 'ENOENT') {\n                        // if the file is not found, return 404\n                        res.statusCode = 404;\n                        res.end(`File ${pathname} not found!`);\n                    } else {\n                        res.statusCode = 500;\n                        res.end(`Error getting the file: ${statErr}.`);\n                    }\n                    return;\n                }\n                if (stat.isDirectory()) {\n                    pathname = path.join(pathname, 'index.html');\n                }\n                const ext = path.parse(pathname).ext;\n                fs.readFile(pathname, (readErr, data) => {\n                    if (readErr) {\n                        res.statusCode = 500;\n                        res.end(`Error getting the file: ${statErr}.`);\n                    } else {\n                        // if the file is found, set Content-type and send data\n                        res.setHeader('Content-type', map[ext] || 'text/plain');\n                        res.end(data);\n                    }\n                });\n            });\n        });\n        server.on('close', () => {\n            console.log(`${this.getName()} stopped`);\n        });\n        return server;\n    }\n\n    public getPort(): number {\n        return this.port;\n    }\n\n    public getServer(): http.Server | undefined {\n        return this.server;\n    }\n\n    public getName(): string {\n        return `HTTP Server {tcp:${this.port}}`;\n    }\n\n    public start(): void {\n        this.server = this.createServer(PUBLIC_DIR);\n        this.server.listen(this.port, () => {\n            Utils.printListeningMsg(proto, this.port);\n        });\n    }\n\n    public release(): void {\n        this.server?.close();\n    }\n}\n"], "filenames": ["src/server/services/HttpServer.ts"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [47], "fixing_code_start_loc": [48], "fixing_code_end_loc": [53], "type": "CWE-73", "message": "ws-scrcpy is vulnerable to External Control of File Name or Path", "other": {"cve": {"id": "CVE-2021-3845", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-04T17:15:08.230", "lastModified": "2022-10-28T19:28:47.393", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ws-scrcpy is vulnerable to External Control of File Name or Path"}, {"lang": "es", "value": "ws-scrcpy es vulnerable al Control Externo del Nombre o la Ruta del Archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-73"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-610"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ws_scrcpy_project:ws_scrcpy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.1", "matchCriteriaId": "BA641A56-DA26-479E-B5C3-215DB79A5F90"}]}]}], "references": [{"url": "https://github.com/netristv/ws-scrcpy/commit/e83cf65438bef83a3503b25358bba97bcc156fef", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/dc7fc98f-4f4f-440a-b6f6-124a56ea36ef", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netristv/ws-scrcpy/commit/e83cf65438bef83a3503b25358bba97bcc156fef"}}