{"buggy_code": ["Changelog\n=========\n\n2.0 - May 15, 2011\n------------------\n\n* Start moving codebase to PEP8 compatible coding style.\n\n* Add support for Python 3.2.\n\n* Several code cleanups. As a side effect Python versions before 2.6\n  are unfortunatley no longer supported. If you use Python 2.5 or older\n  Pyrad 1.2 will still work for you.\n\n\n1.2 - July 12, 2009\n-------------------\n\n* Setup sphinx based documentation.\n\n* Use hashlib instead of md5, if present. This fixes deprecation warnings \n  for python 2.6. Patch from Jeremy Lian\u00e9.\n\n* Support parsing VENDOR format specifications in dictionary files. Patch by\n  Kristoffer Gr\u00f6nlun.\n\n* Supprt $INCLUDE directores in dictionary files. Patch by\n  Kristoffer Gr\u00f6nlun.\n\n* Standardize on 4 spaces for indents. Patch by Kristoffer Gr\u00f6nlund/\n  Purplescout.\n\n* Make sure all encoding utility methods raise a TypeError if a value of\n  the wrong type is passed in.\n\n\n1.1 - September 30, 2007\n------------------------\n\n* Add the 'octets' datatype from FreeRADIUS. This is treated just like string;\n  the only difference is how FreeRADIUS prints it.\n\n* Check against unimplemented datatypes in EncodeData and DecodeData instead\n  of assuming an identity transform works.\n\n* Make Packet.has_key and __contains__ gracefully handle unknown attributes. \n  Based on a patch from Alexey V Michurun <am@rol.ru>.\n\n* Add a __delitem__ implementation to Packet. Based on a patch from\n  Alexey V Michurun <am@rol.ru>.\n\n\n1.0 - September 16, 2007\n------------------------\n\n* Add unit tests. Pyrad now has 100% test coverage!\n\n* Moved the proxy server has been out of the server module to a new\n  proxy module.\n\n* Fix several errors that prevented the proxy code from working.\n\n* Use the standard logging module instead of printing to stdout.\n\n* The default dictionary for Server instances was shared between all\n  instances, possibly leading to unwanted data pollution. Each Server now\n  gets its own dict instance if none is passed in to the constructor.\n\n* Fixed a timeout handling problem in the client: after receiving an\n  invalid reply the current time was not updated, possibly leading to\n  the client blocking forever.\n\n* Switch to setuptools, allowing pyrad to be distributed as an egg\n  via the python package index.\n\n* Use absolute instead of relative imports.\n\n* Sockets are now opened with SO_REUSEADDR enabled to allow for faster\n  restarts.\n\n\n0.9 - April 25, 2007\n------------------------\n\n* Start using trac to manage the project: http://code.wiggy.net/tracker/pyrad/\n\n* [bug 3] Fix handling of packets with an id of 0\n\n* [bug 2] Fix handling of file descriptor parameters in the server\n  code and example.\n\n* [bug 4] Fix wrong variable name in exception raised when encountering\n  an overly long packet.\n\n* [bug 5] Fix error message in parse error for dictionaries.\n\n* [bug 8] Packet.CreateAuthenticator is now a static method.\n\n\n0.8\n---\n\n* Fix time-handling in the client packet sending code: it would loop\n  forever since the now time was updated at the wrong moment. Fix from\n  Michael Mitchell <Michael.Mitchell@team.telstra.com>\n\n* Fix passing of dict parameter when creating reply packets\n\t  \n\t\n0.7\n---\n\n* add HandleAuthPacket and HandleAcctPacket hooks to Server class.\n  Request from Thomas Boettcher.\n\n* Pass on dict attribute when creating a reply packet. Requested by\n  Thomas Boettcher.\n\n* Allow specififying new attributes when using\n  Server.CreateReplyPacket. Requested by Thomas Boettcher.\n\n\n0.6\n---\n\n* packet.VerifyReply() had a syntax error when not called with a raw packet.\n\n* Add bind() method to the Client class.\n\n* [SECURITY] Fix handling of timeouts in client module: when a bad\n  packet was received pyrad immediately started the next retry instead of\n  discarding it and waiting for a timeout. This could be exploited by\n  sending a number of bogus responses before a correct reply to make pyrad\n  not see the real response.\n\n* correctly set Acct-Delay-Time when resending accounting requests packets.\n\n* verify account request packages as well (from Farshad Khoshkhui).\n\n* protect against packets with bogus lengths (from Farshad Khoshkhui).\n\n\n0.5\n---\n\n* Fix typo in server class which broke handling of accounting packets.\n\n* Create seperate AuthPacket and AcctPacket classes; this resulted in\n  a fair number of API changes.\n\n* Packets now know how to create and verify replies.\n\n* Client now directs authentication and accounting packets to the\n  correct port on the server.\n\n* Add twisted support via the new curved module.\n\n* Fix incorrect exception handling in client code.\n\n* Update example server to handle accounting packets.\n\n* Add example for sending account packets.\n\n\n0.4\n---\n\n* Fix last case of bogus exception usage.\n\n* Move RADIUS code constants to packet module.\n\n* Add support for decoding passwords and generating reply packets to Packet\n  class.\n\n* Add basic RADIUS server and proxy implementation.\n\n\n0.3\n---\n\n* client.Timeout is now derived from Exception.\n\n* Docstring documentation added.\n\n* Include example dictionaries and authentication script.\n\n\n0.2\n---\n\n* Use proper exceptions.\n\n* Encode and decode vendor attributes.\n\n* Dictionary can parse vendor dictionaries.\n\n* Dictionary can handle attribute values.\n\n* Enhance most constructors; they now take extra optional parameters\n  with initialisation info.\n\n* No longer use obsolete python interfaces like whrandom.\n\n\n0.1\n---\n\n* First release\n", "# packet.py\n#\n# Copyright 2002-2005,2007 Wichert Akkerman <wichert@wiggy.net>\n#\n# A RADIUS packet as defined in RFC 2138\n\n\nimport struct\nimport random\ntry:\n    import hashlib\n    md5_constructor = hashlib.md5\nexcept ImportError:\n    # BBB for python 2.4\n    import md5\n    md5_constructor = md5.new\nimport six\nfrom pyrad import tools\n\n# Packet codes\nAccessRequest = 1\nAccessAccept = 2\nAccessReject = 3\nAccountingRequest = 4\nAccountingResponse = 5\nAccessChallenge = 11\nStatusServer = 12\nStatusClient = 13\nDisconnectRequest = 40\nDisconnectACK = 41\nDisconnectNAK = 42\nCoARequest = 43\nCoAACK = 44\nCoANAK = 45\n\n# Current ID\nCurrentID = random.randrange(1, 255)\n\n\nclass PacketError(Exception):\n    pass\n\n\nclass Packet(dict):\n    \"\"\"Packet acts like a standard python map to provide simple access\n    to the RADIUS attributes. Since RADIUS allows for repeated\n    attributes the value will always be a sequence. pyrad makes sure\n    to preserve the ordering when encoding and decoding packets.\n\n    There are two ways to use the map intereface: if attribute\n    names are used pyrad take care of en-/decoding data. If\n    the attribute type number (or a vendor ID/attribute type\n    tuple for vendor attributes) is used you work with the\n    raw data.\n\n    Normally you will not use this class directly, but one of the\n    :obj:`AuthPacket` or :obj:`AcctPacket` classes.\n    \"\"\"\n\n    def __init__(self, code=0, id=None, secret=six.b(''), authenticator=None,\n            **attributes):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        dict.__init__(self)\n        self.code = code\n        if id is not None:\n            self.id = id\n        else:\n            self.id = CreateID()\n        if not isinstance(secret, six.binary_type):\n            raise TypeError('secret must be a binary string')\n        self.secret = secret\n        if authenticator is not None and \\\n                not isinstance(authenticator, six.binary_type):\n                    raise TypeError('authenticator must be a binary string')\n        self.authenticator = authenticator\n\n        if 'dict' in attributes:\n            self.dict = attributes['dict']\n\n        if 'packet' in attributes:\n            self.DecodePacket(attributes['packet'])\n\n        for (key, value) in attributes.items():\n            if key in ['dict', 'fd', 'packet']:\n                continue\n            key = key.replace('_', '-')\n            self.AddAttribute(key, value)\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return Packet(id=self.id, secret=self.secret,\n                      authenticator=self.authenticator, dict=self.dict,\n                      **attributes)\n\n    def _DecodeValue(self, attr, value):\n        if attr.values.HasBackward(value):\n            return attr.values.GetBackward(value)\n        else:\n            return tools.DecodeAttr(attr.type, value)\n\n    def _EncodeValue(self, attr, value):\n        if attr.values.HasForward(value):\n            return attr.values.GetForward(value)\n        else:\n            return tools.EncodeAttr(attr.type, value)\n\n    def _EncodeKeyValues(self, key, values):\n        if not isinstance(key, str):\n            return (key, values)\n\n        attr = self.dict.attributes[key]\n        if attr.vendor:\n            key = (self.dict.vendors.GetForward(attr.vendor), attr.code)\n        else:\n            key = attr.code\n\n        return (key, [self._EncodeValue(attr, v) for v in values])\n\n    def _EncodeKey(self, key):\n        if not isinstance(key, str):\n            return key\n\n        attr = self.dict.attributes[key]\n        if attr.vendor:\n            return (self.dict.vendors.GetForward(attr.vendor), attr.code)\n        else:\n            return attr.code\n\n    def _DecodeKey(self, key):\n        \"\"\"Turn a key into a string if possible\"\"\"\n\n        if self.dict.attrindex.HasBackward(key):\n            return self.dict.attrindex.GetBackward(key)\n        return key\n\n    def AddAttribute(self, key, value):\n        \"\"\"Add an attribute to the packet.\n\n        :param key:   attribute name or identification\n        :type key:    string, attribute code or (vendor code, attribute code)\n                      tuple\n        :param value: value\n        :type value:  depends on type of attribute\n        \"\"\"\n        (key, value) = self._EncodeKeyValues(key, [value])\n        value = value[0]\n\n        self.setdefault(key, []).append(value)\n\n    def __getitem__(self, key):\n        if not isinstance(key, six.string_types):\n            return dict.__getitem__(self, key)\n\n        values = dict.__getitem__(self, self._EncodeKey(key))\n        attr = self.dict.attributes[key]\n        res = []\n        for v in values:\n            res.append(self._DecodeValue(attr, v))\n        return res\n\n    def __contains__(self, key):\n        try:\n            return dict.__contains__(self, self._EncodeKey(key))\n        except KeyError:\n            return False\n\n    has_key = __contains__\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, self._EncodeKey(key))\n\n    def __setitem__(self, key, item):\n        if isinstance(key, six.string_types):\n            (key, item) = self._EncodeKeyValues(key, [item])\n            dict.__setitem__(self, key, item)\n        else:\n            assert isinstance(item, list)\n            dict.__setitem__(self, key, item)\n\n    def keys(self):\n        return [self._DecodeKey(key) for key in dict.keys(self)]\n\n    @staticmethod\n    def CreateAuthenticator():\n        \"\"\"Create a packet autenticator. All RADIUS packets contain a sixteen\n        byte authenticator which is used to authenticate replies from the\n        RADIUS server and in the password hiding algorithm. This function\n        returns a suitable random string that can be used as an authenticator.\n\n        :return: valid packet authenticator\n        :rtype: binary string\n        \"\"\"\n\n        data = []\n        for i in range(16):\n            data.append(random.randrange(0, 256))\n        if six.PY3:\n            return bytes(data)\n        else:\n            return ''.join(chr(b) for b in data)\n\n    def CreateID(self):\n        \"\"\"Create a packet ID.  All RADIUS requests have a ID which is used to\n        identify a request. This is used to detect retries and replay attacks.\n        This function returns a suitable random number that can be used as ID.\n\n        :return: ID number\n        :rtype:  integer\n\n        \"\"\"\n        return random.randrange(0, 256)\n\n    def ReplyPacket(self):\n        \"\"\"Create a ready-to-transmit authentication reply packet.\n        Returns a RADIUS packet which can be directly transmitted\n        to a RADIUS server. This differs with Packet() in how\n        the authenticator is calculated.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        assert(self.authenticator)\n        assert(self.secret)\n\n        attr = self._PktEncodeAttributes()\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n\n        authenticator = md5_constructor(header[0:4] + self.authenticator\n                              + attr + self.secret).digest()\n        return header + authenticator + attr\n\n    def VerifyReply(self, reply, rawreply=None):\n        if reply.id != self.id:\n            return False\n\n        if rawreply is None:\n            rawreply = reply.ReplyPacket()\n\n        hash = md5_constructor(rawreply[0:4] + self.authenticator +\n                     rawreply[20:] + self.secret).digest()\n\n        if hash != rawreply[4:20]:\n            return False\n        return True\n\n    def _PktEncodeAttribute(self, key, value):\n        if isinstance(key, tuple):\n            value = struct.pack('!L', key[0]) + \\\n                self._PktEncodeAttribute(key[1], value)\n            key = 26\n\n        return struct.pack('!BB', key, (len(value) + 2)) + value\n\n    def _PktEncodeAttributes(self):\n        result = six.b('')\n        for (code, datalst) in self.items():\n            for data in datalst:\n                result += self._PktEncodeAttribute(code, data)\n\n        return result\n\n    def _PktDecodeVendorAttribute(self, data):\n        # Check if this packet is long enough to be in the\n        # RFC2865 recommended form\n        if len(data) < 6:\n            return (26, data)\n\n        (vendor, type, length) = struct.unpack('!LBB', data[:6])[0:3]\n        # Another sanity check\n        if len(data) != length + 4:\n            return (26, data)\n\n        return ((vendor, type), data[6:])\n\n    def DecodePacket(self, packet):\n        \"\"\"Initialize the object from raw packet data.  Decode a packet as\n        received from the network and decode it.\n\n        :param packet: raw packet\n        :type packet:  string\"\"\"\n\n        try:\n            (self.code, self.id, length, self.authenticator) = \\\n                    struct.unpack('!BBH16s', packet[0:20])\n        except struct.error:\n            raise PacketError('Packet header is corrupt')\n        if len(packet) != length:\n            raise PacketError('Packet has invalid length')\n        if length > 8192:\n            raise PacketError('Packet length is too long (%d)' % length)\n\n        self.clear()\n\n        packet = packet[20:]\n        while packet:\n            try:\n                (key, attrlen) = struct.unpack('!BB', packet[0:2])\n            except struct.error:\n                raise PacketError('Attribute header is corrupt')\n\n            if attrlen < 2:\n                raise PacketError(\n                        'Attribute length is too small (%d)' % attrlen)\n\n            value = packet[2:attrlen]\n            if key == 26:\n                (key, value) = self._PktDecodeVendorAttribute(value)\n\n            self.setdefault(key, []).append(value)\n            packet = packet[attrlen:]\n\n\nclass AuthPacket(Packet):\n    def __init__(self, code=AccessRequest, id=None, secret=six.b(''),\n            authenticator=None, **attributes):\n        \"\"\"Constructor\n\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        Packet.__init__(self, code, id, secret, authenticator, **attributes)\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AuthPacket(AccessAccept, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)\n\n    def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        attr = self._PktEncodeAttributes()\n\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH16s', self.code, self.id,\n            (20 + len(attr)), self.authenticator)\n\n        return header + attr\n\n    def PwDecrypt(self, password):\n        \"\"\"Unobfuscate a RADIUS password. RADIUS hides passwords in packets by\n        using an algorithm based on the MD5 hash of the packet authenticator\n        and RADIUS secret. This function reverses the obfuscation process.\n\n        :param password: obfuscated form of password\n        :type password:  binary string\n        :return:         plaintext password\n        :rtype:          unicode string\n        \"\"\"\n        buf = password\n        pw = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    pw += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    pw += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            (last, buf) = (buf[:16], buf[16:])\n\n        while pw.endswith(six.b('\\x00')):\n            pw = pw[:-1]\n\n        return pw.decode('utf-8')\n\n    def PwCrypt(self, password):\n        \"\"\"Obfuscate password.\n        RADIUS hides passwords in packets by using an algorithm\n        based on the MD5 hash of the packet authenticator and RADIUS\n        secret. If no authenticator has been set before calling PwCrypt\n        one is created automatically. Changing the authenticator after\n        setting a password that has been encrypted using this function\n        will not work.\n\n        :param password: plaintext password\n        :type password:  unicode stringn\n        :return:         obfuscated version of the password\n        :rtype:          binary string\n        \"\"\"\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if isinstance(password, six.text_type):\n            password = password.encode('utf-8')\n\n        buf = password\n        if len(password) % 16 != 0:\n            buf += six.b('\\x00') * (16 - (len(password) % 16))\n\n        hash = md5_constructor(self.secret + self.authenticator).digest()\n        result = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    result += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    result += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            last = result[-16:]\n            buf = buf[16:]\n\n        return result\n\n\nclass AcctPacket(Packet):\n    \"\"\"RADIUS accounting packets. This class is a specialization\n    of the generic :obj:`Packet` class for accounting packets.\n    \"\"\"\n\n    def __init__(self, code=AccountingRequest, id=None, secret=six.b(''),\n            authenticator=None, **attributes):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        Packet.__init__(self, code, id, secret, authenticator, **attributes)\n        if 'packet' in attributes:\n            self.raw_packet = attributes['packet']\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AcctPacket(AccountingResponse, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)\n\n    def VerifyAcctRequest(self):\n        \"\"\"Verify request authenticator.\n\n        :return: True if verification failed else False\n        :rtype: boolean\n        \"\"\"\n        assert(self.raw_packet)\n        hash = md5_constructor(self.raw_packet[0:4] + 16 * six.b('\\x00') +\n                self.raw_packet[20:] + self.secret).digest()\n        return hash == self.authenticator\n\n    def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n\n        attr = self._PktEncodeAttributes()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n        self.authenticator = md5_constructor(header[0:4] + 16 * six.b('\\x00') + attr\n            + self.secret).digest()\n        return header + self.authenticator + attr\n\n\ndef CreateID():\n    \"\"\"Generate a packet ID.\n\n    :return: packet ID\n    :rtype:  8 bit integer\n    \"\"\"\n    global CurrentID\n\n    CurrentID = (CurrentID + 1) % 256\n    return CurrentID\n"], "fixing_code": ["Changelog\n=========\n\n2.1 - Unreleased\n------------------\n\n* Use a different random generator to improve the security of generated\n  packet ids and authenticators.\n\n\n2.0 - May 15, 2011\n------------------\n\n* Start moving codebase to PEP8 compatible coding style.\n\n* Add support for Python 3.2.\n\n* Several code cleanups. As a side effect Python versions before 2.6\n  are unfortunatley no longer supported. If you use Python 2.5 or older\n  Pyrad 1.2 will still work for you.\n\n\n1.2 - July 12, 2009\n-------------------\n\n* Setup sphinx based documentation.\n\n* Use hashlib instead of md5, if present. This fixes deprecation warnings \n  for python 2.6. Patch from Jeremy Lian\u00e9.\n\n* Support parsing VENDOR format specifications in dictionary files. Patch by\n  Kristoffer Gr\u00f6nlun.\n\n* Supprt $INCLUDE directores in dictionary files. Patch by\n  Kristoffer Gr\u00f6nlun.\n\n* Standardize on 4 spaces for indents. Patch by Kristoffer Gr\u00f6nlund/\n  Purplescout.\n\n* Make sure all encoding utility methods raise a TypeError if a value of\n  the wrong type is passed in.\n\n\n1.1 - September 30, 2007\n------------------------\n\n* Add the 'octets' datatype from FreeRADIUS. This is treated just like string;\n  the only difference is how FreeRADIUS prints it.\n\n* Check against unimplemented datatypes in EncodeData and DecodeData instead\n  of assuming an identity transform works.\n\n* Make Packet.has_key and __contains__ gracefully handle unknown attributes. \n  Based on a patch from Alexey V Michurun <am@rol.ru>.\n\n* Add a __delitem__ implementation to Packet. Based on a patch from\n  Alexey V Michurun <am@rol.ru>.\n\n\n1.0 - September 16, 2007\n------------------------\n\n* Add unit tests. Pyrad now has 100% test coverage!\n\n* Moved the proxy server has been out of the server module to a new\n  proxy module.\n\n* Fix several errors that prevented the proxy code from working.\n\n* Use the standard logging module instead of printing to stdout.\n\n* The default dictionary for Server instances was shared between all\n  instances, possibly leading to unwanted data pollution. Each Server now\n  gets its own dict instance if none is passed in to the constructor.\n\n* Fixed a timeout handling problem in the client: after receiving an\n  invalid reply the current time was not updated, possibly leading to\n  the client blocking forever.\n\n* Switch to setuptools, allowing pyrad to be distributed as an egg\n  via the python package index.\n\n* Use absolute instead of relative imports.\n\n* Sockets are now opened with SO_REUSEADDR enabled to allow for faster\n  restarts.\n\n\n0.9 - April 25, 2007\n------------------------\n\n* Start using trac to manage the project: http://code.wiggy.net/tracker/pyrad/\n\n* [bug 3] Fix handling of packets with an id of 0\n\n* [bug 2] Fix handling of file descriptor parameters in the server\n  code and example.\n\n* [bug 4] Fix wrong variable name in exception raised when encountering\n  an overly long packet.\n\n* [bug 5] Fix error message in parse error for dictionaries.\n\n* [bug 8] Packet.CreateAuthenticator is now a static method.\n\n\n0.8\n---\n\n* Fix time-handling in the client packet sending code: it would loop\n  forever since the now time was updated at the wrong moment. Fix from\n  Michael Mitchell <Michael.Mitchell@team.telstra.com>\n\n* Fix passing of dict parameter when creating reply packets\n\t  \n\t\n0.7\n---\n\n* add HandleAuthPacket and HandleAcctPacket hooks to Server class.\n  Request from Thomas Boettcher.\n\n* Pass on dict attribute when creating a reply packet. Requested by\n  Thomas Boettcher.\n\n* Allow specififying new attributes when using\n  Server.CreateReplyPacket. Requested by Thomas Boettcher.\n\n\n0.6\n---\n\n* packet.VerifyReply() had a syntax error when not called with a raw packet.\n\n* Add bind() method to the Client class.\n\n* [SECURITY] Fix handling of timeouts in client module: when a bad\n  packet was received pyrad immediately started the next retry instead of\n  discarding it and waiting for a timeout. This could be exploited by\n  sending a number of bogus responses before a correct reply to make pyrad\n  not see the real response.\n\n* correctly set Acct-Delay-Time when resending accounting requests packets.\n\n* verify account request packages as well (from Farshad Khoshkhui).\n\n* protect against packets with bogus lengths (from Farshad Khoshkhui).\n\n\n0.5\n---\n\n* Fix typo in server class which broke handling of accounting packets.\n\n* Create seperate AuthPacket and AcctPacket classes; this resulted in\n  a fair number of API changes.\n\n* Packets now know how to create and verify replies.\n\n* Client now directs authentication and accounting packets to the\n  correct port on the server.\n\n* Add twisted support via the new curved module.\n\n* Fix incorrect exception handling in client code.\n\n* Update example server to handle accounting packets.\n\n* Add example for sending account packets.\n\n\n0.4\n---\n\n* Fix last case of bogus exception usage.\n\n* Move RADIUS code constants to packet module.\n\n* Add support for decoding passwords and generating reply packets to Packet\n  class.\n\n* Add basic RADIUS server and proxy implementation.\n\n\n0.3\n---\n\n* client.Timeout is now derived from Exception.\n\n* Docstring documentation added.\n\n* Include example dictionaries and authentication script.\n\n\n0.2\n---\n\n* Use proper exceptions.\n\n* Encode and decode vendor attributes.\n\n* Dictionary can parse vendor dictionaries.\n\n* Dictionary can handle attribute values.\n\n* Enhance most constructors; they now take extra optional parameters\n  with initialisation info.\n\n* No longer use obsolete python interfaces like whrandom.\n\n\n0.1\n---\n\n* First release\n", "# packet.py\n#\n# Copyright 2002-2005,2007 Wichert Akkerman <wichert@wiggy.net>\n#\n# A RADIUS packet as defined in RFC 2138\n\n\nimport struct\nimport random\ntry:\n    import hashlib\n    md5_constructor = hashlib.md5\nexcept ImportError:\n    # BBB for python 2.4\n    import md5\n    md5_constructor = md5.new\nimport six\nfrom pyrad import tools\n\n# Packet codes\nAccessRequest = 1\nAccessAccept = 2\nAccessReject = 3\nAccountingRequest = 4\nAccountingResponse = 5\nAccessChallenge = 11\nStatusServer = 12\nStatusClient = 13\nDisconnectRequest = 40\nDisconnectACK = 41\nDisconnectNAK = 42\nCoARequest = 43\nCoAACK = 44\nCoANAK = 45\n\n# Use cryptographic-safe random generator as provided by the OS.\nrandom_generator = random.SystemRandom()\n\n# Current ID\nCurrentID = random_generator.randrange(1, 255)\n\n\nclass PacketError(Exception):\n    pass\n\n\nclass Packet(dict):\n    \"\"\"Packet acts like a standard python map to provide simple access\n    to the RADIUS attributes. Since RADIUS allows for repeated\n    attributes the value will always be a sequence. pyrad makes sure\n    to preserve the ordering when encoding and decoding packets.\n\n    There are two ways to use the map intereface: if attribute\n    names are used pyrad take care of en-/decoding data. If\n    the attribute type number (or a vendor ID/attribute type\n    tuple for vendor attributes) is used you work with the\n    raw data.\n\n    Normally you will not use this class directly, but one of the\n    :obj:`AuthPacket` or :obj:`AcctPacket` classes.\n    \"\"\"\n\n    def __init__(self, code=0, id=None, secret=six.b(''), authenticator=None,\n            **attributes):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        dict.__init__(self)\n        self.code = code\n        if id is not None:\n            self.id = id\n        else:\n            self.id = CreateID()\n        if not isinstance(secret, six.binary_type):\n            raise TypeError('secret must be a binary string')\n        self.secret = secret\n        if authenticator is not None and \\\n                not isinstance(authenticator, six.binary_type):\n                    raise TypeError('authenticator must be a binary string')\n        self.authenticator = authenticator\n\n        if 'dict' in attributes:\n            self.dict = attributes['dict']\n\n        if 'packet' in attributes:\n            self.DecodePacket(attributes['packet'])\n\n        for (key, value) in attributes.items():\n            if key in ['dict', 'fd', 'packet']:\n                continue\n            key = key.replace('_', '-')\n            self.AddAttribute(key, value)\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return Packet(id=self.id, secret=self.secret,\n                      authenticator=self.authenticator, dict=self.dict,\n                      **attributes)\n\n    def _DecodeValue(self, attr, value):\n        if attr.values.HasBackward(value):\n            return attr.values.GetBackward(value)\n        else:\n            return tools.DecodeAttr(attr.type, value)\n\n    def _EncodeValue(self, attr, value):\n        if attr.values.HasForward(value):\n            return attr.values.GetForward(value)\n        else:\n            return tools.EncodeAttr(attr.type, value)\n\n    def _EncodeKeyValues(self, key, values):\n        if not isinstance(key, str):\n            return (key, values)\n\n        attr = self.dict.attributes[key]\n        if attr.vendor:\n            key = (self.dict.vendors.GetForward(attr.vendor), attr.code)\n        else:\n            key = attr.code\n\n        return (key, [self._EncodeValue(attr, v) for v in values])\n\n    def _EncodeKey(self, key):\n        if not isinstance(key, str):\n            return key\n\n        attr = self.dict.attributes[key]\n        if attr.vendor:\n            return (self.dict.vendors.GetForward(attr.vendor), attr.code)\n        else:\n            return attr.code\n\n    def _DecodeKey(self, key):\n        \"\"\"Turn a key into a string if possible\"\"\"\n\n        if self.dict.attrindex.HasBackward(key):\n            return self.dict.attrindex.GetBackward(key)\n        return key\n\n    def AddAttribute(self, key, value):\n        \"\"\"Add an attribute to the packet.\n\n        :param key:   attribute name or identification\n        :type key:    string, attribute code or (vendor code, attribute code)\n                      tuple\n        :param value: value\n        :type value:  depends on type of attribute\n        \"\"\"\n        (key, value) = self._EncodeKeyValues(key, [value])\n        value = value[0]\n\n        self.setdefault(key, []).append(value)\n\n    def __getitem__(self, key):\n        if not isinstance(key, six.string_types):\n            return dict.__getitem__(self, key)\n\n        values = dict.__getitem__(self, self._EncodeKey(key))\n        attr = self.dict.attributes[key]\n        res = []\n        for v in values:\n            res.append(self._DecodeValue(attr, v))\n        return res\n\n    def __contains__(self, key):\n        try:\n            return dict.__contains__(self, self._EncodeKey(key))\n        except KeyError:\n            return False\n\n    has_key = __contains__\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, self._EncodeKey(key))\n\n    def __setitem__(self, key, item):\n        if isinstance(key, six.string_types):\n            (key, item) = self._EncodeKeyValues(key, [item])\n            dict.__setitem__(self, key, item)\n        else:\n            assert isinstance(item, list)\n            dict.__setitem__(self, key, item)\n\n    def keys(self):\n        return [self._DecodeKey(key) for key in dict.keys(self)]\n\n    @staticmethod\n    def CreateAuthenticator():\n        \"\"\"Create a packet autenticator. All RADIUS packets contain a sixteen\n        byte authenticator which is used to authenticate replies from the\n        RADIUS server and in the password hiding algorithm. This function\n        returns a suitable random string that can be used as an authenticator.\n\n        :return: valid packet authenticator\n        :rtype: binary string\n        \"\"\"\n\n        data = []\n        for i in range(16):\n            data.append(random_generator.randrange(0, 256))\n        if six.PY3:\n            return bytes(data)\n        else:\n            return ''.join(chr(b) for b in data)\n\n    def CreateID(self):\n        \"\"\"Create a packet ID.  All RADIUS requests have a ID which is used to\n        identify a request. This is used to detect retries and replay attacks.\n        This function returns a suitable random number that can be used as ID.\n\n        :return: ID number\n        :rtype:  integer\n\n        \"\"\"\n        return random_generator.randrange(0, 256)\n\n    def ReplyPacket(self):\n        \"\"\"Create a ready-to-transmit authentication reply packet.\n        Returns a RADIUS packet which can be directly transmitted\n        to a RADIUS server. This differs with Packet() in how\n        the authenticator is calculated.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        assert(self.authenticator)\n        assert(self.secret)\n\n        attr = self._PktEncodeAttributes()\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n\n        authenticator = md5_constructor(header[0:4] + self.authenticator\n                              + attr + self.secret).digest()\n        return header + authenticator + attr\n\n    def VerifyReply(self, reply, rawreply=None):\n        if reply.id != self.id:\n            return False\n\n        if rawreply is None:\n            rawreply = reply.ReplyPacket()\n\n        hash = md5_constructor(rawreply[0:4] + self.authenticator +\n                     rawreply[20:] + self.secret).digest()\n\n        if hash != rawreply[4:20]:\n            return False\n        return True\n\n    def _PktEncodeAttribute(self, key, value):\n        if isinstance(key, tuple):\n            value = struct.pack('!L', key[0]) + \\\n                self._PktEncodeAttribute(key[1], value)\n            key = 26\n\n        return struct.pack('!BB', key, (len(value) + 2)) + value\n\n    def _PktEncodeAttributes(self):\n        result = six.b('')\n        for (code, datalst) in self.items():\n            for data in datalst:\n                result += self._PktEncodeAttribute(code, data)\n\n        return result\n\n    def _PktDecodeVendorAttribute(self, data):\n        # Check if this packet is long enough to be in the\n        # RFC2865 recommended form\n        if len(data) < 6:\n            return (26, data)\n\n        (vendor, type, length) = struct.unpack('!LBB', data[:6])[0:3]\n        # Another sanity check\n        if len(data) != length + 4:\n            return (26, data)\n\n        return ((vendor, type), data[6:])\n\n    def DecodePacket(self, packet):\n        \"\"\"Initialize the object from raw packet data.  Decode a packet as\n        received from the network and decode it.\n\n        :param packet: raw packet\n        :type packet:  string\"\"\"\n\n        try:\n            (self.code, self.id, length, self.authenticator) = \\\n                    struct.unpack('!BBH16s', packet[0:20])\n        except struct.error:\n            raise PacketError('Packet header is corrupt')\n        if len(packet) != length:\n            raise PacketError('Packet has invalid length')\n        if length > 8192:\n            raise PacketError('Packet length is too long (%d)' % length)\n\n        self.clear()\n\n        packet = packet[20:]\n        while packet:\n            try:\n                (key, attrlen) = struct.unpack('!BB', packet[0:2])\n            except struct.error:\n                raise PacketError('Attribute header is corrupt')\n\n            if attrlen < 2:\n                raise PacketError(\n                        'Attribute length is too small (%d)' % attrlen)\n\n            value = packet[2:attrlen]\n            if key == 26:\n                (key, value) = self._PktDecodeVendorAttribute(value)\n\n            self.setdefault(key, []).append(value)\n            packet = packet[attrlen:]\n\n\nclass AuthPacket(Packet):\n    def __init__(self, code=AccessRequest, id=None, secret=six.b(''),\n            authenticator=None, **attributes):\n        \"\"\"Constructor\n\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        Packet.__init__(self, code, id, secret, authenticator, **attributes)\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AuthPacket(AccessAccept, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)\n\n    def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        attr = self._PktEncodeAttributes()\n\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH16s', self.code, self.id,\n            (20 + len(attr)), self.authenticator)\n\n        return header + attr\n\n    def PwDecrypt(self, password):\n        \"\"\"Unobfuscate a RADIUS password. RADIUS hides passwords in packets by\n        using an algorithm based on the MD5 hash of the packet authenticator\n        and RADIUS secret. This function reverses the obfuscation process.\n\n        :param password: obfuscated form of password\n        :type password:  binary string\n        :return:         plaintext password\n        :rtype:          unicode string\n        \"\"\"\n        buf = password\n        pw = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    pw += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    pw += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            (last, buf) = (buf[:16], buf[16:])\n\n        while pw.endswith(six.b('\\x00')):\n            pw = pw[:-1]\n\n        return pw.decode('utf-8')\n\n    def PwCrypt(self, password):\n        \"\"\"Obfuscate password.\n        RADIUS hides passwords in packets by using an algorithm\n        based on the MD5 hash of the packet authenticator and RADIUS\n        secret. If no authenticator has been set before calling PwCrypt\n        one is created automatically. Changing the authenticator after\n        setting a password that has been encrypted using this function\n        will not work.\n\n        :param password: plaintext password\n        :type password:  unicode stringn\n        :return:         obfuscated version of the password\n        :rtype:          binary string\n        \"\"\"\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if isinstance(password, six.text_type):\n            password = password.encode('utf-8')\n\n        buf = password\n        if len(password) % 16 != 0:\n            buf += six.b('\\x00') * (16 - (len(password) % 16))\n\n        hash = md5_constructor(self.secret + self.authenticator).digest()\n        result = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    result += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    result += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            last = result[-16:]\n            buf = buf[16:]\n\n        return result\n\n\nclass AcctPacket(Packet):\n    \"\"\"RADIUS accounting packets. This class is a specialization\n    of the generic :obj:`Packet` class for accounting packets.\n    \"\"\"\n\n    def __init__(self, code=AccountingRequest, id=None, secret=six.b(''),\n            authenticator=None, **attributes):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identifaction number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        Packet.__init__(self, code, id, secret, authenticator, **attributes)\n        if 'packet' in attributes:\n            self.raw_packet = attributes['packet']\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AcctPacket(AccountingResponse, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)\n\n    def VerifyAcctRequest(self):\n        \"\"\"Verify request authenticator.\n\n        :return: True if verification failed else False\n        :rtype: boolean\n        \"\"\"\n        assert(self.raw_packet)\n        hash = md5_constructor(self.raw_packet[0:4] + 16 * six.b('\\x00') +\n                self.raw_packet[20:] + self.secret).digest()\n        return hash == self.authenticator\n\n    def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n\n        attr = self._PktEncodeAttributes()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n        self.authenticator = md5_constructor(header[0:4] + 16 * six.b('\\x00') + attr\n            + self.secret).digest()\n        return header + self.authenticator + attr\n\n\ndef CreateID():\n    \"\"\"Generate a packet ID.\n\n    :return: packet ID\n    :rtype:  8 bit integer\n    \"\"\"\n    global CurrentID\n\n    CurrentID = (CurrentID + 1) % 256\n    return CurrentID\n"], "filenames": ["CHANGES.txt", "pyrad/packet.py"], "buggy_code_start_loc": [2, 35], "buggy_code_end_loc": [2, 227], "fixing_code_start_loc": [3, 36], "fixing_code_end_loc": [10, 230], "type": "CWE-330", "message": "packet.py in pyrad before 2.1 uses weak random numbers to generate RADIUS authenticators and hash passwords, which makes it easier for remote attackers to obtain sensitive information via a brute force attack.", "other": {"cve": {"id": "CVE-2013-0294", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-28T16:15:11.447", "lastModified": "2020-01-31T19:07:21.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "packet.py in pyrad before 2.1 uses weak random numbers to generate RADIUS authenticators and hash passwords, which makes it easier for remote attackers to obtain sensitive information via a brute force attack."}, {"lang": "es", "value": "El archivo packet.py en pyrad versiones anteriores a 2.1, utiliza n\u00fameros aleatorios d\u00e9biles para generar autenticadores RADIUS y contrase\u00f1as de hash, lo que facilita a atacantes remotos obtener informaci\u00f3n confidencial por medio de un ataque de fuerza bruta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyrad_project:pyrad:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1", "matchCriteriaId": "B79141AC-6E97-47EF-8EE5-87ED1E3F5B73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/115677.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/115705.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/116567.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/02/15/13", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/57984", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=911682", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/82133", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/wichert/pyrad/commit/38f74b36814ca5b1a27d9898141126af4953bee5", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wichert/pyrad/commit/38f74b36814ca5b1a27d9898141126af4953bee5"}}