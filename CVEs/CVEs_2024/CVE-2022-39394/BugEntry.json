{"buggy_code": ["use crate::{wasm_frame_vec_t, wasm_instance_t, wasm_name_t, wasm_store_t};\nuse once_cell::unsync::OnceCell;\nuse wasmtime::{Trap, TrapCode};\n\n#[repr(C)]\n#[derive(Clone)]\npub struct wasm_trap_t {\n    pub(crate) trap: Trap,\n}\n\nwasmtime_c_api_macros::declare_ref!(wasm_trap_t);\n\nimpl wasm_trap_t {\n    pub(crate) fn new(trap: Trap) -> wasm_trap_t {\n        wasm_trap_t { trap: trap }\n    }\n}\n\n#[repr(C)]\n#[derive(Clone)]\npub struct wasm_frame_t {\n    trap: Trap,\n    idx: usize,\n    func_name: OnceCell<Option<wasm_name_t>>,\n    module_name: OnceCell<Option<wasm_name_t>>,\n}\n\nwasmtime_c_api_macros::declare_own!(wasm_frame_t);\n\npub type wasm_message_t = wasm_name_t;\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_new(\n    _store: &wasm_store_t,\n    message: &wasm_message_t,\n) -> Box<wasm_trap_t> {\n    let message = message.as_slice();\n    if message[message.len() - 1] != 0 {\n        panic!(\"wasm_trap_new message stringz expected\");\n    }\n    let message = String::from_utf8_lossy(&message[..message.len() - 1]);\n    Box::new(wasm_trap_t {\n        trap: Trap::new(message),\n    })\n}\n\n#[no_mangle]\npub unsafe extern \"C\" fn wasmtime_trap_new(message: *const u8, len: usize) -> Box<wasm_trap_t> {\n    let bytes = crate::slice_from_raw_parts(message, len);\n    let message = String::from_utf8_lossy(&bytes);\n    Box::new(wasm_trap_t {\n        trap: Trap::new(message),\n    })\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_message(trap: &wasm_trap_t, out: &mut wasm_message_t) {\n    let mut buffer = Vec::new();\n    buffer.extend_from_slice(trap.trap.to_string().as_bytes());\n    buffer.reserve_exact(1);\n    buffer.push(0);\n    out.set_buffer(buffer);\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_origin(raw: &wasm_trap_t) -> Option<Box<wasm_frame_t>> {\n    if raw.trap.trace().unwrap_or(&[]).len() > 0 {\n        Some(Box::new(wasm_frame_t {\n            trap: raw.trap.clone(),\n            idx: 0,\n            func_name: OnceCell::new(),\n            module_name: OnceCell::new(),\n        }))\n    } else {\n        None\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_trace(raw: &wasm_trap_t, out: &mut wasm_frame_vec_t) {\n    let vec = (0..raw.trap.trace().unwrap_or(&[]).len())\n        .map(|idx| {\n            Some(Box::new(wasm_frame_t {\n                trap: raw.trap.clone(),\n                idx,\n                func_name: OnceCell::new(),\n                module_name: OnceCell::new(),\n            }))\n        })\n        .collect();\n    out.set_buffer(vec);\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_trap_code(raw: &wasm_trap_t, code: &mut i32) -> bool {\n    match raw.trap.trap_code() {\n        Some(c) => {\n            *code = match c {\n                TrapCode::StackOverflow => 0,\n                TrapCode::MemoryOutOfBounds => 1,\n                TrapCode::HeapMisaligned => 2,\n                TrapCode::TableOutOfBounds => 3,\n                TrapCode::IndirectCallToNull => 4,\n                TrapCode::BadSignature => 5,\n                TrapCode::IntegerOverflow => 6,\n                TrapCode::IntegerDivisionByZero => 7,\n                TrapCode::BadConversionToInteger => 8,\n                TrapCode::UnreachableCodeReached => 9,\n                TrapCode::Interrupt => 10,\n                _ => unreachable!(),\n            };\n            true\n        }\n        None => false,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_trap_exit_status(raw: &wasm_trap_t, status: &mut i32) -> bool {\n    match raw.trap.i32_exit_status() {\n        Some(i) => {\n            *status = i;\n            true\n        }\n        None => false,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_func_index(frame: &wasm_frame_t) -> u32 {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx].func_index()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_frame_func_name(frame: &wasm_frame_t) -> Option<&wasm_name_t> {\n    frame\n        .func_name\n        .get_or_init(|| {\n            frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n                .func_name()\n                .map(|s| wasm_name_t::from(s.to_string().into_bytes()))\n        })\n        .as_ref()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_frame_module_name(frame: &wasm_frame_t) -> Option<&wasm_name_t> {\n    frame\n        .module_name\n        .get_or_init(|| {\n            frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n                .module_name()\n                .map(|s| wasm_name_t::from(s.to_string().into_bytes()))\n        })\n        .as_ref()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_func_offset(frame: &wasm_frame_t) -> usize {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n        .func_offset()\n        .unwrap_or(usize::MAX)\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_instance(_arg1: *const wasm_frame_t) -> *mut wasm_instance_t {\n    unimplemented!(\"wasm_frame_instance\")\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_module_offset(frame: &wasm_frame_t) -> usize {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n        .module_offset()\n        .unwrap_or(usize::MAX)\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_copy(frame: &wasm_frame_t) -> Box<wasm_frame_t> {\n    Box::new(frame.clone())\n}\n"], "fixing_code": ["use crate::{wasm_frame_vec_t, wasm_instance_t, wasm_name_t, wasm_store_t};\nuse once_cell::unsync::OnceCell;\nuse wasmtime::{Trap, TrapCode};\n\n#[repr(C)]\n#[derive(Clone)]\npub struct wasm_trap_t {\n    pub(crate) trap: Trap,\n}\n\nwasmtime_c_api_macros::declare_ref!(wasm_trap_t);\n\nimpl wasm_trap_t {\n    pub(crate) fn new(trap: Trap) -> wasm_trap_t {\n        wasm_trap_t { trap: trap }\n    }\n}\n\n#[repr(C)]\n#[derive(Clone)]\npub struct wasm_frame_t {\n    trap: Trap,\n    idx: usize,\n    func_name: OnceCell<Option<wasm_name_t>>,\n    module_name: OnceCell<Option<wasm_name_t>>,\n}\n\nwasmtime_c_api_macros::declare_own!(wasm_frame_t);\n\npub type wasm_message_t = wasm_name_t;\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_new(\n    _store: &wasm_store_t,\n    message: &wasm_message_t,\n) -> Box<wasm_trap_t> {\n    let message = message.as_slice();\n    if message[message.len() - 1] != 0 {\n        panic!(\"wasm_trap_new message stringz expected\");\n    }\n    let message = String::from_utf8_lossy(&message[..message.len() - 1]);\n    Box::new(wasm_trap_t {\n        trap: Trap::new(message),\n    })\n}\n\n#[no_mangle]\npub unsafe extern \"C\" fn wasmtime_trap_new(message: *const u8, len: usize) -> Box<wasm_trap_t> {\n    let bytes = crate::slice_from_raw_parts(message, len);\n    let message = String::from_utf8_lossy(&bytes);\n    Box::new(wasm_trap_t {\n        trap: Trap::new(message),\n    })\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_message(trap: &wasm_trap_t, out: &mut wasm_message_t) {\n    let mut buffer = Vec::new();\n    buffer.extend_from_slice(trap.trap.to_string().as_bytes());\n    buffer.reserve_exact(1);\n    buffer.push(0);\n    out.set_buffer(buffer);\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_origin(raw: &wasm_trap_t) -> Option<Box<wasm_frame_t>> {\n    if raw.trap.trace().unwrap_or(&[]).len() > 0 {\n        Some(Box::new(wasm_frame_t {\n            trap: raw.trap.clone(),\n            idx: 0,\n            func_name: OnceCell::new(),\n            module_name: OnceCell::new(),\n        }))\n    } else {\n        None\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_trap_trace(raw: &wasm_trap_t, out: &mut wasm_frame_vec_t) {\n    let vec = (0..raw.trap.trace().unwrap_or(&[]).len())\n        .map(|idx| {\n            Some(Box::new(wasm_frame_t {\n                trap: raw.trap.clone(),\n                idx,\n                func_name: OnceCell::new(),\n                module_name: OnceCell::new(),\n            }))\n        })\n        .collect();\n    out.set_buffer(vec);\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_trap_code(raw: &wasm_trap_t, code: &mut u8) -> bool {\n    match raw.trap.trap_code() {\n        Some(c) => {\n            *code = match c {\n                TrapCode::StackOverflow => 0,\n                TrapCode::MemoryOutOfBounds => 1,\n                TrapCode::HeapMisaligned => 2,\n                TrapCode::TableOutOfBounds => 3,\n                TrapCode::IndirectCallToNull => 4,\n                TrapCode::BadSignature => 5,\n                TrapCode::IntegerOverflow => 6,\n                TrapCode::IntegerDivisionByZero => 7,\n                TrapCode::BadConversionToInteger => 8,\n                TrapCode::UnreachableCodeReached => 9,\n                TrapCode::Interrupt => 10,\n                _ => unreachable!(),\n            };\n            true\n        }\n        None => false,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_trap_exit_status(raw: &wasm_trap_t, status: &mut i32) -> bool {\n    match raw.trap.i32_exit_status() {\n        Some(i) => {\n            *status = i;\n            true\n        }\n        None => false,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_func_index(frame: &wasm_frame_t) -> u32 {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx].func_index()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_frame_func_name(frame: &wasm_frame_t) -> Option<&wasm_name_t> {\n    frame\n        .func_name\n        .get_or_init(|| {\n            frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n                .func_name()\n                .map(|s| wasm_name_t::from(s.to_string().into_bytes()))\n        })\n        .as_ref()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasmtime_frame_module_name(frame: &wasm_frame_t) -> Option<&wasm_name_t> {\n    frame\n        .module_name\n        .get_or_init(|| {\n            frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n                .module_name()\n                .map(|s| wasm_name_t::from(s.to_string().into_bytes()))\n        })\n        .as_ref()\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_func_offset(frame: &wasm_frame_t) -> usize {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n        .func_offset()\n        .unwrap_or(usize::MAX)\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_instance(_arg1: *const wasm_frame_t) -> *mut wasm_instance_t {\n    unimplemented!(\"wasm_frame_instance\")\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_module_offset(frame: &wasm_frame_t) -> usize {\n    frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]\n        .module_offset()\n        .unwrap_or(usize::MAX)\n}\n\n#[no_mangle]\npub extern \"C\" fn wasm_frame_copy(frame: &wasm_frame_t) -> Box<wasm_frame_t> {\n    Box::new(frame.clone())\n}\n"], "filenames": ["crates/c-api/src/trap.rs"], "buggy_code_start_loc": [95], "buggy_code_end_loc": [96], "fixing_code_start_loc": [95], "fixing_code_end_loc": [96], "type": "CWE-787", "message": "Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's C API implementation where the definition of the `wasmtime_trap_code` does not match its declared signature in the `wasmtime/trap.h` header file. This discrepancy causes the function implementation to perform a 4-byte write into a 1-byte buffer provided by the caller. This can lead to three zero bytes being written beyond the 1-byte location provided by the caller. This bug has been patched and users should upgrade to Wasmtime 2.0.2. This bug can be worked around by providing a 4-byte buffer casted to a 1-byte buffer when calling `wasmtime_trap_code`. Users of the `wasmtime` crate are not affected by this issue, only users of the C API function `wasmtime_trap_code` are affected.", "other": {"cve": {"id": "CVE-2022-39394", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-10T20:15:11.850", "lastModified": "2022-11-16T13:31:56.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's C API implementation where the definition of the `wasmtime_trap_code` does not match its declared signature in the `wasmtime/trap.h` header file. This discrepancy causes the function implementation to perform a 4-byte write into a 1-byte buffer provided by the caller. This can lead to three zero bytes being written beyond the 1-byte location provided by the caller. This bug has been patched and users should upgrade to Wasmtime 2.0.2. This bug can be worked around by providing a 4-byte buffer casted to a 1-byte buffer when calling `wasmtime_trap_code`. Users of the `wasmtime` crate are not affected by this issue, only users of the C API function `wasmtime_trap_code` are affected."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.8, "baseSeverity": "LOW"}, "exploitabilityScore": 0.3, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:*:*", "versionEndExcluding": "1.0.2", "matchCriteriaId": "DD102201-19F4-4CB7-828B-0B8A8A209919"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.2", "matchCriteriaId": "838C8442-0507-4DFD-B6B8-29462F63E721"}]}]}], "references": [{"url": "https://github.com/bytecodealliance/wasmtime/commit/087d9d7becf7422b3f872a3bcd5d97bb7ce7ff36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-h84q-m8rr-3v9q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bytecodealliance/wasmtime/commit/087d9d7becf7422b3f872a3bcd5d97bb7ce7ff36"}}