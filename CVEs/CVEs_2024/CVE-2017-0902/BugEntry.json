{"buggy_code": ["# frozen_string_literal: true\nrequire 'rubygems'\nrequire 'rubygems/request'\nrequire 'rubygems/uri_formatter'\nrequire 'rubygems/user_interaction'\nrequire 'rubygems/request/connection_pools'\nrequire 'resolv'\n\n##\n# RemoteFetcher handles the details of fetching gems and gem information from\n# a remote source.\n\nclass Gem::RemoteFetcher\n\n  include Gem::UserInteraction\n\n  ##\n  # A FetchError exception wraps up the various possible IO and HTTP failures\n  # that could happen while downloading from the internet.\n\n  class FetchError < Gem::Exception\n\n    ##\n    # The URI which was being accessed when the exception happened.\n\n    attr_accessor :uri\n\n    def initialize(message, uri)\n      super message\n      begin\n        uri = URI(uri)\n        uri.password = 'REDACTED' if uri.password\n        @uri = uri.to_s\n      rescue URI::InvalidURIError, ArgumentError\n        @uri = uri\n      end\n    end\n\n    def to_s # :nodoc:\n      \"#{super} (#{uri})\"\n    end\n\n  end\n\n  ##\n  # A FetchError that indicates that the reason for not being\n  # able to fetch data was that the host could not be contacted\n\n  class UnknownHostError < FetchError\n  end\n\n  @fetcher = nil\n\n  ##\n  # Cached RemoteFetcher instance.\n\n  def self.fetcher\n    @fetcher ||= self.new Gem.configuration[:http_proxy]\n  end\n\n  attr_accessor :headers\n\n  ##\n  # Initialize a remote fetcher using the source URI and possible proxy\n  # information.\n  #\n  # +proxy+\n  # * [String]: explicit specification of proxy; overrides any environment\n  #             variable setting\n  # * nil: respect environment variables (HTTP_PROXY, HTTP_PROXY_USER,\n  #        HTTP_PROXY_PASS)\n  # * <tt>:no_proxy</tt>: ignore environment variables and _don't_ use a proxy\n  #\n  # +dns+: An object to use for DNS resolution of the API endpoint.\n  #        By default, use Resolv::DNS.\n  #\n  # +headers+: A set of additional HTTP headers to be sent to the server when\n  #            fetching the gem.\n\n  def initialize(proxy=nil, dns=Resolv::DNS.new, headers={})\n    require 'net/http'\n    require 'stringio'\n    require 'time'\n    require 'uri'\n\n    Socket.do_not_reverse_lookup = true\n\n    @proxy = proxy\n    @pools = {}\n    @pool_lock = Mutex.new\n    @cert_files = Gem::Request.get_cert_files\n\n    @dns = dns\n    @headers = headers\n  end\n\n  ##\n  # Given a source at +uri+, calculate what hostname to actually\n  # connect to query the data for it.\n\n  def api_endpoint(uri)\n    host = uri.host\n\n    begin\n      res = @dns.getresource \"_rubygems._tcp.#{host}\",\n                             Resolv::DNS::Resource::IN::SRV\n    rescue Resolv::ResolvError => e\n      verbose \"Getting SRV record failed: #{e}\"\n      uri\n    else\n      target = res.target.to_s.strip\n\n      if /\\.#{Regexp.quote(host)}\\z/ =~ target\n        return URI.parse \"#{uri.scheme}://#{target}#{uri.path}\"\n      end\n\n      uri\n    end\n  end\n\n  ##\n  # Given a name and requirement, downloads this gem into cache and returns the\n  # filename. Returns nil if the gem cannot be located.\n  #--\n  # Should probably be integrated with #download below, but that will be a\n  # larger, more encompassing effort. -erikh\n\n  def download_to_cache dependency\n    found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency\n\n    return if found.empty?\n\n    spec, source = found.max_by { |(s,_)| s.version }\n\n    download spec, source.uri.to_s\n  end\n\n  ##\n  # Moves the gem +spec+ from +source_uri+ to the cache dir unless it is\n  # already there.  If the source_uri is local the gem cache dir copy is\n  # always replaced.\n\n  def download(spec, source_uri, install_dir = Gem.dir)\n    cache_dir =\n      if Dir.pwd == install_dir then # see fetch_command\n        install_dir\n      elsif File.writable? install_dir then\n        File.join install_dir, \"cache\"\n      else\n        File.join Gem.user_dir, \"cache\"\n      end\n\n    gem_file_name = File.basename spec.cache_file\n    local_gem_path = File.join cache_dir, gem_file_name\n\n    FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir\n\n    # Always escape URI's to deal with potential spaces and such\n    # It should also be considered that source_uri may already be\n    # a valid URI with escaped characters. e.g. \"{DESede}\" is encoded\n    # as \"%7BDESede%7D\". If this is escaped again the percentage\n    # symbols will be escaped.\n    unless source_uri.is_a?(URI::Generic)\n      begin\n        source_uri = URI.parse(source_uri)\n      rescue\n        source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?\n                               URI::DEFAULT_PARSER.escape(source_uri.to_s) :\n                               URI.escape(source_uri.to_s))\n      end\n    end\n\n    scheme = source_uri.scheme\n\n    # URI.parse gets confused by MS Windows paths with forward slashes.\n    scheme = nil if scheme =~ /^[a-z]$/i\n\n    # REFACTOR: split this up and dispatch on scheme (eg download_http)\n    # REFACTOR: be sure to clean up fake fetcher when you do this... cleaner\n    case scheme\n    when 'http', 'https', 's3' then\n      unless File.exist? local_gem_path then\n        begin\n          verbose \"Downloading gem #{gem_file_name}\"\n\n          remote_gem_path = source_uri + \"gems/#{gem_file_name}\"\n\n          self.cache_update_path remote_gem_path, local_gem_path\n        rescue Gem::RemoteFetcher::FetchError\n          raise if spec.original_platform == spec.platform\n\n          alternate_name = \"#{spec.original_name}.gem\"\n\n          verbose \"Failed, downloading gem #{alternate_name}\"\n\n          remote_gem_path = source_uri + \"gems/#{alternate_name}\"\n\n          self.cache_update_path remote_gem_path, local_gem_path\n        end\n      end\n    when 'file' then\n      begin\n        path = source_uri.path\n        path = File.dirname(path) if File.extname(path) == '.gem'\n\n        remote_gem_path = correct_for_windows_path(File.join(path, 'gems', gem_file_name))\n\n        FileUtils.cp(remote_gem_path, local_gem_path)\n      rescue Errno::EACCES\n        local_gem_path = source_uri.to_s\n      end\n\n      verbose \"Using local gem #{local_gem_path}\"\n    when nil then # TODO test for local overriding cache\n      source_path = if Gem.win_platform? && source_uri.scheme &&\n                       !source_uri.path.include?(':') then\n                      \"#{source_uri.scheme}:#{source_uri.path}\"\n                    else\n                      source_uri.path\n                    end\n\n      source_path = Gem::UriFormatter.new(source_path).unescape\n\n      begin\n        FileUtils.cp source_path, local_gem_path unless\n          File.identical?(source_path, local_gem_path)\n      rescue Errno::EACCES\n        local_gem_path = source_uri.to_s\n      end\n\n      verbose \"Using local gem #{local_gem_path}\"\n    else\n      raise ArgumentError, \"unsupported URI scheme #{source_uri.scheme}\"\n    end\n\n    local_gem_path\n  end\n\n  ##\n  # File Fetcher. Dispatched by +fetch_path+. Use it instead.\n\n  def fetch_file uri, *_\n    Gem.read_binary correct_for_windows_path uri.path\n  end\n\n  ##\n  # HTTP Fetcher. Dispatched by +fetch_path+. Use it instead.\n\n  def fetch_http uri, last_modified = nil, head = false, depth = 0\n    fetch_type = head ? Net::HTTP::Head : Net::HTTP::Get\n    response   = request uri, fetch_type, last_modified do |req|\n      headers.each { |k,v| req.add_field(k,v) }\n    end\n\n    case response\n    when Net::HTTPOK, Net::HTTPNotModified then\n      response.uri = uri if response.respond_to? :uri\n      head ? response : response.body\n    when Net::HTTPMovedPermanently, Net::HTTPFound, Net::HTTPSeeOther,\n         Net::HTTPTemporaryRedirect then\n      raise FetchError.new('too many redirects', uri) if depth > 10\n\n      unless location = response['Location']\n        raise FetchError.new(\"redirecting but no redirect location was given\", uri)\n      end\n      location = URI.parse response['Location']\n\n      if https?(uri) && !https?(location)\n        raise FetchError.new(\"redirecting to non-https resource: #{location}\", uri)\n      end\n\n      fetch_http(location, last_modified, head, depth + 1)\n    else\n      raise FetchError.new(\"bad response #{response.message} #{response.code}\", uri)\n    end\n  end\n\n  alias :fetch_https :fetch_http\n\n  ##\n  # Downloads +uri+ and returns it as a String.\n\n  def fetch_path(uri, mtime = nil, head = false)\n    uri = URI.parse uri unless URI::Generic === uri\n\n    raise ArgumentError, \"bad uri: #{uri}\" unless uri\n\n    unless uri.scheme\n      raise ArgumentError, \"uri scheme is invalid: #{uri.scheme.inspect}\"\n    end\n\n    data = send \"fetch_#{uri.scheme}\", uri, mtime, head\n\n    if data and !head and uri.to_s =~ /\\.gz$/\n      begin\n        data = Gem.gunzip data\n      rescue Zlib::GzipFile::Error\n        raise FetchError.new(\"server did not return a valid file\", uri.to_s)\n      end\n    end\n\n    data\n  rescue FetchError\n    raise\n  rescue Timeout::Error\n    raise UnknownHostError.new('timed out', uri.to_s)\n  rescue IOError, SocketError, SystemCallError => e\n    if e.message =~ /getaddrinfo/\n      raise UnknownHostError.new('no such name', uri.to_s)\n    else\n      raise FetchError.new(\"#{e.class}: #{e}\", uri.to_s)\n    end\n  end\n\n  def fetch_s3(uri, mtime = nil, head = false)\n    public_uri = sign_s3_url(uri)\n    fetch_https public_uri, mtime, head\n  end\n\n  ##\n  # Downloads +uri+ to +path+ if necessary. If no path is given, it just\n  # passes the data.\n\n  def cache_update_path uri, path = nil, update = true\n    mtime = path && File.stat(path).mtime rescue nil\n\n    data = fetch_path(uri, mtime)\n\n    if data == nil # indicates the server returned 304 Not Modified\n      return Gem.read_binary(path)\n    end\n\n    if update and path\n      Gem.write_binary(path, data)\n    end\n\n    data\n  end\n\n  ##\n  # Returns the size of +uri+ in bytes.\n\n  def fetch_size(uri) # TODO: phase this out\n    response = fetch_path(uri, nil, true)\n\n    response['content-length'].to_i\n  end\n\n  def correct_for_windows_path(path)\n    if path[0].chr == '/' && path[1].chr =~ /[a-z]/i && path[2].chr == ':'\n      path[1..-1]\n    else\n      path\n    end\n  end\n\n  ##\n  # Performs a Net::HTTP request of type +request_class+ on +uri+ returning\n  # a Net::HTTP response object.  request maintains a table of persistent\n  # connections to reduce connect overhead.\n\n  def request(uri, request_class, last_modified = nil)\n    proxy = proxy_for @proxy, uri\n    pool  = pools_for(proxy).pool_for uri\n\n    request = Gem::Request.new uri, request_class, last_modified, pool\n\n    request.fetch do |req|\n      yield req if block_given?\n    end\n  end\n\n  def https?(uri)\n    uri.scheme.downcase == 'https'\n  end\n\n  def close_all\n    @pools.each_value {|pool| pool.close_all}\n  end\n\n  protected\n\n  # we have our own signing code here to avoid a dependency on the aws-sdk gem\n  # fortunately, a simple GET request isn't too complex to sign properly\n  def sign_s3_url(uri, expiration = nil)\n    require 'base64'\n    require 'openssl'\n\n    unless uri.user && uri.password\n      raise FetchError.new(\"credentials needed in s3 source, like s3://key:secret@bucket-name/\", uri.to_s)\n    end\n\n    expiration ||= s3_expiration\n    canonical_path = \"/#{uri.host}#{uri.path}\"\n    payload = \"GET\\n\\n\\n#{expiration}\\n#{canonical_path}\"\n    digest = OpenSSL::HMAC.digest('sha1', uri.password, payload)\n    # URI.escape is deprecated, and there isn't yet a replacement that does quite what we want\n    signature = Base64.encode64(digest).gsub(\"\\n\", '').gsub(/[\\+\\/=]/) { |c| BASE64_URI_TRANSLATE[c] }\n    URI.parse(\"https://#{uri.host}.s3.amazonaws.com#{uri.path}?AWSAccessKeyId=#{uri.user}&Expires=#{expiration}&Signature=#{signature}\")\n  end\n\n  def s3_expiration\n    (Time.now + 3600).to_i # one hour from now\n  end\n\n  BASE64_URI_TRANSLATE = { '+' => '%2B', '/' => '%2F', '=' => '%3D' }.freeze\n\n  private\n\n  def proxy_for proxy, uri\n    Gem::Request.proxy_uri(proxy || Gem::Request.get_proxy_from_env(uri.scheme))\n  end\n\n  def pools_for proxy\n    @pool_lock.synchronize do\n      @pools[proxy] ||= Gem::Request::ConnectionPools.new proxy, @cert_files\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\n\nrequire 'webrick'\nbegin\n  require 'webrick/https'\nrescue LoadError => e\n  raise unless (e.respond_to?(:path) && e.path == 'openssl') ||\n               e.message =~ / -- openssl$/\nend\n\nrequire 'rubygems/remote_fetcher'\nrequire 'rubygems/package'\nrequire 'minitest/mock'\n\n# = Testing Proxy Settings\n#\n# These tests check the proper proxy server settings by running two\n# web servers.  The web server at http://localhost:#{SERVER_PORT}\n# represents the normal gem server and returns a gemspec with a rake\n# version of 0.4.11.  The web server at http://localhost:#{PROXY_PORT}\n# represents the proxy server and returns a different dataset where\n# rake has version 0.4.2.  This allows us to detect which server is\n# returning the data.\n#\n# Note that the proxy server is not a *real* proxy server.  But our\n# software doesn't really care, as long as we hit the proxy URL when a\n# proxy is configured.\n\nclass TestGemRemoteFetcher < Gem::TestCase\n\n  include Gem::DefaultUserInteraction\n\n  SERVER_DATA = <<-EOY\n--- !ruby/object:Gem::Cache\ngems:\n  rake-0.4.11: !ruby/object:Gem::Specification\n    rubygems_version: \"0.7\"\n    specification_version: 1\n    name: rake\n    version: !ruby/object:Gem::Version\n      version: 0.4.11\n    date: 2004-11-12\n    summary: Ruby based make-like utility.\n    require_paths:\n      - lib\n    author: Jim Weirich\n    email: jim@weirichhouse.org\n    homepage: http://rake.rubyforge.org\n    rubyforge_project: rake\n    description: Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.\n    autorequire:\n    default_executable: rake\n    bindir: bin\n    has_rdoc: true\n    required_ruby_version: !ruby/object:Gem::Version::Requirement\n      requirements:\n        -\n          - \">\"\n          - !ruby/object:Gem::Version\n            version: 0.0.0\n      version:\n    platform: ruby\n    files:\n      - README\n    test_files: []\n    library_stubs:\n    rdoc_options:\n    extra_rdoc_files:\n    executables:\n      - rake\n    extensions: []\n    requirements: []\n    dependencies: []\n  EOY\n\n  PROXY_DATA = SERVER_DATA.gsub(/0.4.11/, '0.4.2')\n\n  DIR = File.expand_path(File.dirname(__FILE__))\n\n  # Generated via:\n  #   x = OpenSSL::PKey::DH.new(2048) # wait a while...\n  #   x.to_s => pem\n  TEST_KEY_DH2048 =  OpenSSL::PKey::DH.new <<-_end_of_pem_\n-----BEGIN DH PARAMETERS-----\nMIIBCAKCAQEA3Ze2EHSfYkZLUn557torAmjBgPsqzbodaRaGZtgK1gEU+9nNJaFV\nG1JKhmGUiEDyIW7idsBpe4sX/Wqjnp48Lr8IeI/SlEzLdoGpf05iRYXC8Cm9o8aM\ncfmVgoSEAo9YLBpzoji2jHkO7Q5IPt4zxbTdlmmGFLc/GO9q7LGHhC+rcMcNTGsM\n49AnILNn49pq4Y72jSwdmvq4psHZwwFBbPwLdw6bLUDDCN90jfqvYt18muwUxDiN\nNP0fuvVAIB158VnQ0liHSwcl6+9vE1mL0Jo/qEXQxl0+UdKDjaGfTsn6HIrwTnmJ\nPeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==\n-----END DH PARAMETERS-----\n    _end_of_pem_\n\n  def setup\n    @proxies = %w[https_proxy http_proxy HTTP_PROXY http_proxy_user HTTP_PROXY_USER http_proxy_pass HTTP_PROXY_PASS no_proxy NO_PROXY]\n    @old_proxies = @proxies.map {|k| ENV[k] }\n    @proxies.each {|k| ENV[k] = nil }\n\n    super\n    self.class.start_servers\n    self.class.enable_yaml = true\n    self.class.enable_zip = false\n\n    base_server_uri = \"http://localhost:#{self.class.normal_server_port}\"\n    @proxy_uri = \"http://localhost:#{self.class.proxy_server_port}\"\n\n    @server_uri = base_server_uri + \"/yaml\"\n    @server_z_uri = base_server_uri + \"/yaml.Z\"\n\n    # REFACTOR: copied from test_gem_dependency_installer.rb\n    @gems_dir = File.join @tempdir, 'gems'\n    @cache_dir = File.join @gemhome, \"cache\"\n    FileUtils.mkdir @gems_dir\n\n    # TODO: why does the remote fetcher need it written to disk?\n    @a1, @a1_gem = util_gem 'a', '1' do |s| s.executables << 'a_bin' end\n    @a1.loaded_from = File.join(@gemhome, 'specifications', @a1.full_name)\n\n    Gem::RemoteFetcher.fetcher = nil\n\n    @fetcher = Gem::RemoteFetcher.fetcher\n  end\n\n  def teardown\n    @fetcher.close_all\n    self.class.stop_servers\n    super\n    Gem.configuration[:http_proxy] = nil\n    @proxies.each_with_index {|k, i| ENV[k] = @old_proxies[i] }\n  end\n\n  def test_self_fetcher\n    fetcher = Gem::RemoteFetcher.fetcher\n    refute_nil fetcher\n    assert_kind_of Gem::RemoteFetcher, fetcher\n  end\n\n  def test_self_fetcher_with_proxy\n    proxy_uri = 'http://proxy.example.com'\n    Gem.configuration[:http_proxy] = proxy_uri\n    Gem::RemoteFetcher.fetcher = nil\n\n    fetcher = Gem::RemoteFetcher.fetcher\n\n    refute_nil fetcher\n    assert_kind_of Gem::RemoteFetcher, fetcher\n    assert_equal proxy_uri, fetcher.instance_variable_get(:@proxy).to_s\n  end\n\n  def test_fetch_size_bad_uri\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    e = assert_raises ArgumentError do\n      fetcher.fetch_size 'gems.example.com/yaml'\n    end\n\n    assert_equal 'uri scheme is invalid: nil', e.message\n  end\n\n  def test_fetch_size_socket_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    def fetcher.request(uri, request_class, last_modified = nil)\n      raise SocketError, \"oops\"\n    end\n\n    uri = 'http://gems.example.com/yaml'\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_size uri\n    end\n\n    assert_equal \"SocketError: oops (#{uri})\", e.message\n  end\n\n  def test_no_proxy\n    use_ui @ui do\n      assert_data_from_server @fetcher.fetch_path(@server_uri)\n      assert_equal SERVER_DATA.size, @fetcher.fetch_size(@server_uri)\n    end\n  end\n\n  def test_api_endpoint\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"gems.example.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://gems.example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values\n    uri = URI.parse \"http://gems.example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"blah.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://gems.example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values_that_starts_with_original\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"example.combadguy.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values_that_end_with_original\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"badexample.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_timeout_warning\n    uri = URI.parse \"http://gems.example.com/foo\"\n\n    dns = MiniTest::Mock.new\n    def dns.getresource arg, *rest\n      raise Resolv::ResolvError.new('timeout!')\n    end\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    begin\n      old_verbose, Gem.configuration.verbose = Gem.configuration.verbose, 1\n      endpoint = use_ui @ui do\n        fetch.api_endpoint(uri)\n      end\n    ensure\n      Gem.configuration.verbose = old_verbose\n    end\n\n    assert_equal uri, endpoint\n\n    assert_equal \"Getting SRV record failed: timeout!\\n\", @ui.output\n\n    dns.verify\n  end\n\n  def test_cache_update_path\n    uri = URI 'http://example/file'\n    path = File.join @tempdir, 'file'\n\n    fetcher = util_fuck_with_fetcher 'hello'\n\n    data = fetcher.cache_update_path uri, path\n\n    assert_equal 'hello', data\n\n    assert_equal 'hello', File.read(path)\n  end\n\n  def test_cache_update_path_no_update\n    uri = URI 'http://example/file'\n    path = File.join @tempdir, 'file'\n\n    fetcher = util_fuck_with_fetcher 'hello'\n\n    data = fetcher.cache_update_path uri, path, false\n\n    assert_equal 'hello', data\n\n    refute_path_exists path\n  end\n\n  def util_fuck_with_fetcher data, blow = false\n    fetcher = Gem::RemoteFetcher.fetcher\n    fetcher.instance_variable_set :@test_data, data\n\n    unless blow then\n      def fetcher.fetch_path arg, *rest\n        @test_arg = arg\n        @test_data\n      end\n    else\n      def fetcher.fetch_path arg, *rest\n        # OMG I'm such an ass\n        class << self; remove_method :fetch_path; end\n        def self.fetch_path arg, *rest\n          @test_arg = arg\n          @test_data\n        end\n\n        raise Gem::RemoteFetcher::FetchError.new(\"haha!\", nil)\n      end\n    end\n\n    fetcher\n  end\n\n  def test_download\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://gems.example.com')\n    assert_equal(\"http://gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_with_auth\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:password@gems.example.com')\n    assert_equal(\"http://user:password@gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_with_encoded_auth\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:%25pas%25sword@gems.example.com')\n    assert_equal(\"http://user:%25pas%25sword@gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_cached\n    FileUtils.mv @a1_gem, @cache_dir\n\n    inst = Gem::RemoteFetcher.fetcher\n\n    assert_equal @a1.cache_file, inst.download(@a1, 'http://gems.example.com')\n  end\n\n  def test_download_local\n    FileUtils.mv @a1_gem, @tempdir\n    local_path = File.join @tempdir, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    assert_equal @a1.cache_file, inst.download(@a1, local_path)\n  end\n\n  def test_download_local_space\n    space_path = File.join @tempdir, 'space path'\n    FileUtils.mkdir space_path\n    FileUtils.mv @a1_gem, space_path\n    local_path = File.join space_path, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    assert_equal @a1.cache_file, inst.download(@a1, local_path)\n  end\n\n  def test_download_install_dir\n    a1_data = File.open @a1_gem, 'rb' do |fp|\n      fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    install_dir = File.join @tempdir, 'more_gems'\n\n    a1_cache_gem = File.join install_dir, \"cache\", @a1.file_name\n    FileUtils.mkdir_p(File.dirname(a1_cache_gem))\n    actual = fetcher.download(@a1, 'http://gems.example.com', install_dir)\n\n    assert_equal a1_cache_gem, actual\n    assert_equal(\"http://gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n\n    assert File.exist?(a1_cache_gem)\n  end\n\n  unless win_platform? # File.chmod doesn't work\n    def test_download_local_read_only\n      FileUtils.mv @a1_gem, @tempdir\n      local_path = File.join @tempdir, @a1.file_name\n      inst = nil\n      FileUtils.chmod 0555, @a1.cache_dir\n\n      Dir.chdir @tempdir do\n        inst = Gem::RemoteFetcher.fetcher\n      end\n\n      assert_equal(File.join(@tempdir, @a1.file_name),\n                   inst.download(@a1, local_path))\n    ensure\n      FileUtils.chmod 0755, @a1.cache_dir\n    end\n\n    def test_download_read_only\n      FileUtils.chmod 0555, @a1.cache_dir\n      FileUtils.chmod 0555, @gemhome\n\n      fetcher = util_fuck_with_fetcher File.read(@a1_gem)\n      fetcher.download(@a1, 'http://gems.example.com')\n      a1_cache_gem = File.join Gem.user_dir, \"cache\", @a1.file_name\n      assert File.exist? a1_cache_gem\n    ensure\n      FileUtils.chmod 0755, @gemhome\n      FileUtils.chmod 0755, @a1.cache_dir\n    end\n  end\n\n  def test_download_platform_legacy\n    original_platform = 'old-platform'\n\n    e1, e1_gem = util_gem 'e', '1' do |s|\n      s.platform = Gem::Platform::CURRENT\n      s.instance_variable_set :@original_platform, original_platform\n    end\n    e1.loaded_from = File.join(@gemhome, 'specifications', e1.full_name)\n\n    e1_data = nil\n    File.open e1_gem, 'rb' do |fp|\n      e1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher e1_data, :blow_chunks\n\n    e1_cache_gem = e1.cache_file\n\n    assert_equal e1_cache_gem, fetcher.download(e1, 'http://gems.example.com')\n\n    assert_equal(\"http://gems.example.com/gems/#{e1.original_name}.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(e1_cache_gem)\n  end\n\n  def test_download_same_file\n    FileUtils.mv @a1_gem, @tempdir\n    local_path = File.join @tempdir, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    cache_path = @a1.cache_file\n    FileUtils.mv local_path, cache_path\n\n    gem = Gem::Package.new cache_path\n\n    assert_equal cache_path, inst.download(gem.spec, cache_path)\n  end\n\n  def test_download_unsupported\n    inst = Gem::RemoteFetcher.fetcher\n\n    e = assert_raises ArgumentError do\n      inst.download @a1, 'ftp://gems.rubyforge.org'\n    end\n\n    assert_equal 'unsupported URI scheme ftp', e.message\n  end\n\n  def test_download_to_cache\n    @a2, @a2_gem = util_gem 'a', '2'\n\n    util_setup_spec_fetcher @a1, @a2\n    @fetcher.instance_variable_set :@a1, @a1\n    @fetcher.instance_variable_set :@a2, @a2\n    def @fetcher.fetch_path uri, mtime = nil, head = false\n      case uri.request_uri\n      when /#{@a1.spec_name}/ then\n        Gem.deflate Marshal.dump @a1\n      when /#{@a2.spec_name}/ then\n        Gem.deflate Marshal.dump @a2\n      else\n        uri.to_s\n      end\n    end\n\n    gem = Gem::RemoteFetcher.fetcher.download_to_cache dep 'a'\n\n    assert_equal @a2.file_name, File.basename(gem)\n  end\n\n  def test_fetch_path_gzip\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      Gem.gzip 'foo'\n    end\n\n    assert_equal 'foo', fetcher.fetch_path(@uri + 'foo.gz')\n  end\n\n  def test_fetch_path_gzip_unmodified\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      nil\n    end\n\n    assert_equal nil, fetcher.fetch_path(@uri + 'foo.gz', Time.at(0))\n  end\n\n  def test_fetch_path_io_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(*)\n      raise EOFError\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_equal \"EOFError: EOFError (#{url})\", e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_socket_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      raise SocketError\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_equal \"SocketError: SocketError (#{url})\", e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_system_call_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime = nil, head = nil)\n      raise Errno::ECONNREFUSED, 'connect(2)'\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_match %r|ECONNREFUSED:.*connect\\(2\\) \\(#{Regexp.escape url}\\)\\z|,\n                 e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_unmodified\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      nil\n    end\n\n    assert_equal nil, fetcher.fetch_path(URI.parse(@gem_repo), Time.at(0))\n  end\n\n  def test_implicit_no_proxy\n    use_ui @ui do\n      ENV['http_proxy'] = 'http://fakeurl:12345'\n      fetcher = Gem::RemoteFetcher.new :no_proxy\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_proxy\n    use_ui @ui do\n      ENV['http_proxy'] = @proxy_uri\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_proxy fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_upper_case_proxy\n    use_ui @ui do\n      ENV['HTTP_PROXY'] = @proxy_uri\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_proxy fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_proxy_no_env\n    use_ui @ui do\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_fetch_http\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      url = 'http://gems.example.com/redirect'\n      unless defined? @requested then\n        @requested = true\n        res = Net::HTTPMovedPermanently.new nil, 301, nil\n        res.add_field 'Location', url\n        res\n      else\n        res = Net::HTTPOK.new nil, 200, nil\n        def res.body() 'real_path' end\n        res\n      end\n    end\n\n    data = fetcher.fetch_http URI.parse(url)\n\n    assert_equal 'real_path', data\n  end\n\n  def test_fetch_http_redirects\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      url = 'http://gems.example.com/redirect'\n      res = Net::HTTPMovedPermanently.new nil, 301, nil\n      res.add_field 'Location', url\n      res\n    end\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_http URI.parse(url)\n    end\n\n    assert_equal \"too many redirects (#{url})\", e.message\n  end\n\n  def test_fetch_http_redirects_without_location\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      res = Net::HTTPMovedPermanently.new nil, 301, nil\n      res\n    end\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_http URI.parse(url)\n    end\n\n    assert_equal \"redirecting but no redirect location was given (#{url})\", e.message\n  end\n\n  def test_fetch_http_with_additional_headers\n    ENV[\"http_proxy\"] = @proxy_uri\n    ENV[\"no_proxy\"] = URI::parse(@server_uri).host\n    fetcher = Gem::RemoteFetcher.new nil, nil, {\"X-Captain\" => \"murphy\"}\n    @fetcher = fetcher\n    assert_equal \"murphy\", fetcher.fetch_path(@server_uri)\n  end\n\n  def test_fetch_s3\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 's3://testuser:testpass@my-bucket/gems/specs.4.8.gz'\n    $fetched_uri = nil\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      $fetched_uri = uri\n      res = Net::HTTPOK.new nil, 200, nil\n      def res.body() 'success' end\n      res\n    end\n\n    def fetcher.s3_expiration\n      1395098371\n    end\n\n    data = fetcher.fetch_s3 URI.parse(url)\n\n    assert_equal 'https://my-bucket.s3.amazonaws.com/gems/specs.4.8.gz?AWSAccessKeyId=testuser&Expires=1395098371&Signature=eUTr7NkpZEet%2BJySE%2BfH6qukroI%3D', $fetched_uri.to_s\n    assert_equal 'success', data\n  ensure\n    $fetched_uri = nil\n  end\n\n  def test_fetch_s3_no_creds\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 's3://my-bucket/gems/specs.4.8.gz'\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_s3 URI.parse(url)\n    end\n\n    assert_match \"credentials needed\", e.message\n  end\n\n  def test_observe_no_proxy_env_single_host\n    use_ui @ui do\n      ENV[\"http_proxy\"] = @proxy_uri\n      ENV[\"no_proxy\"] = URI::parse(@server_uri).host\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_observe_no_proxy_env_list\n    use_ui @ui do\n      ENV[\"http_proxy\"] = @proxy_uri\n      ENV[\"no_proxy\"] = \"fakeurl.com, #{URI::parse(@server_uri).host}\"\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_request_block\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    assert_throws :block_called do\n      fetcher.request URI('http://example'), Net::HTTP::Get do |req|\n        assert_kind_of Net::HTTPGenericRequest, req\n        throw :block_called\n      end\n    end\n  end\n\n  def test_yaml_error_on_size\n    use_ui @ui do\n      self.class.enable_yaml = false\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_error { fetcher.size }\n    end\n  end\n\n  def test_ssl_connection\n    ssl_server = self.class.start_ssl_server\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    with_configured_fetcher(\":ssl_ca_cert: #{temp_ca_cert}\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_ssl_client_cert_auth_connection\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    ssl_server = self.class.start_ssl_server({\n      :SSLVerifyClient =>\n        OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})\n\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    temp_client_cert = File.join(DIR, 'client.pem')\n\n    with_configured_fetcher(\n      \":ssl_ca_cert: #{temp_ca_cert}\\n\" +\n      \":ssl_client_cert: #{temp_client_cert}\\n\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_do_not_allow_invalid_client_cert_auth_connection\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    ssl_server = self.class.start_ssl_server({\n      :SSLVerifyClient =>\n        OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})\n\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    temp_client_cert = File.join(DIR, 'invalid_client.pem')\n\n    with_configured_fetcher(\n      \":ssl_ca_cert: #{temp_ca_cert}\\n\" +\n      \":ssl_client_cert: #{temp_client_cert}\\n\") do |fetcher|\n        assert_raises Gem::RemoteFetcher::FetchError do\n          fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n        end\n    end\n  end\n\n  def test_do_not_allow_insecure_ssl_connection_by_default\n    ssl_server = self.class.start_ssl_server\n    with_configured_fetcher do |fetcher|\n      assert_raises Gem::RemoteFetcher::FetchError do\n        fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n      end\n    end\n  end\n\n  def test_ssl_connection_allow_verify_none\n    ssl_server = self.class.start_ssl_server\n    with_configured_fetcher(\":ssl_verify_mode: 0\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_do_not_follow_insecure_redirect\n    ssl_server = self.class.start_ssl_server\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem'),\n    with_configured_fetcher(\":ssl_ca_cert: #{temp_ca_cert}\") do |fetcher|\n      assert_raises Gem::RemoteFetcher::FetchError do\n        fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/insecure_redirect?to=#{@server_uri}\")\n      end\n    end\n  end\n\n  def with_configured_fetcher(config_str = nil, &block)\n    if config_str\n      temp_conf = File.join @tempdir, '.gemrc'\n      File.open temp_conf, 'w' do |fp|\n        fp.puts config_str\n      end\n      Gem.configuration = Gem::ConfigFile.new %W[--config-file #{temp_conf}]\n    end\n    fetcher = Gem::RemoteFetcher.new\n    yield fetcher\n  ensure\n    fetcher.close_all\n    Gem.configuration = nil\n  end\n\n  def assert_error(exception_class=Exception)\n    got_exception = false\n\n    begin\n      yield\n    rescue exception_class\n      got_exception = true\n    end\n\n    assert got_exception, \"Expected exception conforming to #{exception_class}\"\n  end\n\n  def assert_data_from_server(data)\n    assert_match(/0\\.4\\.11/, data, \"Data is not from server\")\n  end\n\n  def assert_data_from_proxy(data)\n    assert_match(/0\\.4\\.2/, data, \"Data is not from proxy\")\n  end\n\n  class NilLog < WEBrick::Log\n    def log(level, data) #Do nothing\n    end\n  end\n\n  class << self\n    attr_reader :normal_server, :proxy_server\n    attr_accessor :enable_zip, :enable_yaml\n\n    def start_servers\n      @normal_server ||= start_server(SERVER_DATA)\n      @proxy_server  ||= start_server(PROXY_DATA)\n      @enable_yaml = true\n      @enable_zip = false\n      @ssl_server = nil\n      @ssl_server_thread = nil\n    end\n\n    def stop_servers\n      if @normal_server\n        @normal_server.kill.join\n        @normal_server = nil\n      end\n      if @proxy_server\n        @proxy_server.kill.join\n        @proxy_server = nil\n      end\n      if @ssl_server\n        @ssl_server.stop\n        @ssl_server = nil\n      end\n      if @ssl_server_thread\n        @ssl_server_thread.kill.join\n        @ssl_server_thread = nil\n      end\n      utils = WEBrick::Utils    # TimeoutHandler is since 1.9\n      utils::TimeoutHandler.terminate if defined?(utils::TimeoutHandler.terminate)\n    end\n\n    def normal_server_port\n      @normal_server[:server].config[:Port]\n    end\n\n    def proxy_server_port\n      @proxy_server[:server].config[:Port]\n    end\n\n    DIR = File.expand_path(File.dirname(__FILE__))\n\n    def start_ssl_server(config = {})\n      raise MiniTest::Skip, 'openssl not installed' unless\n        defined?(OpenSSL::SSL)\n\n      null_logger = NilLog.new\n      server = WEBrick::HTTPServer.new({\n        :Port => 0,\n        :Logger => null_logger,\n        :AccessLog => [],\n        :SSLEnable => true,\n        :SSLCACertificateFile => File.join(DIR, 'ca_cert.pem'),\n        :SSLCertificate => cert('ssl_cert.pem'),\n        :SSLPrivateKey => key('ssl_key.pem'),\n        :SSLVerifyClient => nil,\n        :SSLCertName => nil\n      }.merge(config))\n      server.mount_proc(\"/yaml\") { |req, res|\n        res.body = \"--- true\\n\"\n      }\n      server.mount_proc(\"/insecure_redirect\") { |req, res|\n        res.set_redirect(WEBrick::HTTPStatus::MovedPermanently, req.query['to'])\n      }\n      server.ssl_context.tmp_dh_callback = proc { TEST_KEY_DH2048 }\n      t = Thread.new do\n        begin\n          server.start\n        rescue Exception => ex\n          abort ex.message\n          puts \"ERROR during server thread: #{ex.message}\"\n        ensure\n          server.shutdown\n        end\n      end\n      while server.status != :Running\n        sleep 0.1\n        unless t.alive?\n          t.join\n          raise\n        end\n      end\n      @ssl_server = server\n      @ssl_server_thread = t\n      server\n    end\n\n    private\n\n    def start_server(data)\n      null_logger = NilLog.new\n      s = WEBrick::HTTPServer.new(\n        :Port            => 0,\n        :DocumentRoot    => nil,\n        :Logger          => null_logger,\n        :AccessLog       => null_logger\n        )\n      s.mount_proc(\"/kill\") { |req, res| s.shutdown }\n      s.mount_proc(\"/yaml\") { |req, res|\n        if req[\"X-Captain\"]\n          res.body = req[\"X-Captain\"]\n        elsif @enable_yaml\n          res.body = data\n          res['Content-Type'] = 'text/plain'\n          res['content-length'] = data.size\n        else\n          res.status = \"404\"\n          res.body = \"<h1>NOT FOUND</h1>\"\n          res['Content-Type'] = 'text/html'\n        end\n      }\n      s.mount_proc(\"/yaml.Z\") { |req, res|\n        if @enable_zip\n          res.body = Zlib::Deflate.deflate(data)\n          res['Content-Type'] = 'text/plain'\n        else\n          res.status = \"404\"\n          res.body = \"<h1>NOT FOUND</h1>\"\n          res['Content-Type'] = 'text/html'\n        end\n      }\n      th = Thread.new do\n        begin\n          s.start\n        rescue Exception => ex\n          abort \"ERROR during server thread: #{ex.message}\"\n        ensure\n          s.shutdown\n        end\n      end\n      th[:server] = s\n      th\n    end\n\n    def cert(filename)\n      OpenSSL::X509::Certificate.new(File.read(File.join(DIR, filename)))\n    end\n\n    def key(filename)\n      OpenSSL::PKey::RSA.new(File.read(File.join(DIR, filename)))\n    end\n  end\n\n  def test_correct_for_windows_path\n    path = \"/C:/WINDOWS/Temp/gems\"\n    assert_equal \"C:/WINDOWS/Temp/gems\", @fetcher.correct_for_windows_path(path)\n\n    path = \"/home/skillet\"\n    assert_equal \"/home/skillet\", @fetcher.correct_for_windows_path(path)\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\nrequire 'rubygems'\nrequire 'rubygems/request'\nrequire 'rubygems/uri_formatter'\nrequire 'rubygems/user_interaction'\nrequire 'rubygems/request/connection_pools'\nrequire 'resolv'\n\n##\n# RemoteFetcher handles the details of fetching gems and gem information from\n# a remote source.\n\nclass Gem::RemoteFetcher\n\n  include Gem::UserInteraction\n\n  ##\n  # A FetchError exception wraps up the various possible IO and HTTP failures\n  # that could happen while downloading from the internet.\n\n  class FetchError < Gem::Exception\n\n    ##\n    # The URI which was being accessed when the exception happened.\n\n    attr_accessor :uri\n\n    def initialize(message, uri)\n      super message\n      begin\n        uri = URI(uri)\n        uri.password = 'REDACTED' if uri.password\n        @uri = uri.to_s\n      rescue URI::InvalidURIError, ArgumentError\n        @uri = uri\n      end\n    end\n\n    def to_s # :nodoc:\n      \"#{super} (#{uri})\"\n    end\n\n  end\n\n  ##\n  # A FetchError that indicates that the reason for not being\n  # able to fetch data was that the host could not be contacted\n\n  class UnknownHostError < FetchError\n  end\n\n  @fetcher = nil\n\n  ##\n  # Cached RemoteFetcher instance.\n\n  def self.fetcher\n    @fetcher ||= self.new Gem.configuration[:http_proxy]\n  end\n\n  attr_accessor :headers\n\n  ##\n  # Initialize a remote fetcher using the source URI and possible proxy\n  # information.\n  #\n  # +proxy+\n  # * [String]: explicit specification of proxy; overrides any environment\n  #             variable setting\n  # * nil: respect environment variables (HTTP_PROXY, HTTP_PROXY_USER,\n  #        HTTP_PROXY_PASS)\n  # * <tt>:no_proxy</tt>: ignore environment variables and _don't_ use a proxy\n  #\n  # +dns+: An object to use for DNS resolution of the API endpoint.\n  #        By default, use Resolv::DNS.\n  #\n  # +headers+: A set of additional HTTP headers to be sent to the server when\n  #            fetching the gem.\n\n  def initialize(proxy=nil, dns=Resolv::DNS.new, headers={})\n    require 'net/http'\n    require 'stringio'\n    require 'time'\n    require 'uri'\n\n    Socket.do_not_reverse_lookup = true\n\n    @proxy = proxy\n    @pools = {}\n    @pool_lock = Mutex.new\n    @cert_files = Gem::Request.get_cert_files\n\n    @dns = dns\n    @headers = headers\n  end\n\n  ##\n  # Given a source at +uri+, calculate what hostname to actually\n  # connect to query the data for it.\n\n  def api_endpoint(uri)\n    host = uri.host\n\n    begin\n      res = @dns.getresource \"_rubygems._tcp.#{host}\",\n                             Resolv::DNS::Resource::IN::SRV\n    rescue Resolv::ResolvError => e\n      verbose \"Getting SRV record failed: #{e}\"\n      uri\n    else\n      target = res.target.to_s.strip\n\n      if URI(\"http://\" + target).host.end_with?(\".#{host}\")\n        return URI.parse \"#{uri.scheme}://#{target}#{uri.path}\"\n      end\n\n      uri\n    end\n  end\n\n  ##\n  # Given a name and requirement, downloads this gem into cache and returns the\n  # filename. Returns nil if the gem cannot be located.\n  #--\n  # Should probably be integrated with #download below, but that will be a\n  # larger, more encompassing effort. -erikh\n\n  def download_to_cache dependency\n    found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency\n\n    return if found.empty?\n\n    spec, source = found.max_by { |(s,_)| s.version }\n\n    download spec, source.uri.to_s\n  end\n\n  ##\n  # Moves the gem +spec+ from +source_uri+ to the cache dir unless it is\n  # already there.  If the source_uri is local the gem cache dir copy is\n  # always replaced.\n\n  def download(spec, source_uri, install_dir = Gem.dir)\n    cache_dir =\n      if Dir.pwd == install_dir then # see fetch_command\n        install_dir\n      elsif File.writable? install_dir then\n        File.join install_dir, \"cache\"\n      else\n        File.join Gem.user_dir, \"cache\"\n      end\n\n    gem_file_name = File.basename spec.cache_file\n    local_gem_path = File.join cache_dir, gem_file_name\n\n    FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir\n\n    # Always escape URI's to deal with potential spaces and such\n    # It should also be considered that source_uri may already be\n    # a valid URI with escaped characters. e.g. \"{DESede}\" is encoded\n    # as \"%7BDESede%7D\". If this is escaped again the percentage\n    # symbols will be escaped.\n    unless source_uri.is_a?(URI::Generic)\n      begin\n        source_uri = URI.parse(source_uri)\n      rescue\n        source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?\n                               URI::DEFAULT_PARSER.escape(source_uri.to_s) :\n                               URI.escape(source_uri.to_s))\n      end\n    end\n\n    scheme = source_uri.scheme\n\n    # URI.parse gets confused by MS Windows paths with forward slashes.\n    scheme = nil if scheme =~ /^[a-z]$/i\n\n    # REFACTOR: split this up and dispatch on scheme (eg download_http)\n    # REFACTOR: be sure to clean up fake fetcher when you do this... cleaner\n    case scheme\n    when 'http', 'https', 's3' then\n      unless File.exist? local_gem_path then\n        begin\n          verbose \"Downloading gem #{gem_file_name}\"\n\n          remote_gem_path = source_uri + \"gems/#{gem_file_name}\"\n\n          self.cache_update_path remote_gem_path, local_gem_path\n        rescue Gem::RemoteFetcher::FetchError\n          raise if spec.original_platform == spec.platform\n\n          alternate_name = \"#{spec.original_name}.gem\"\n\n          verbose \"Failed, downloading gem #{alternate_name}\"\n\n          remote_gem_path = source_uri + \"gems/#{alternate_name}\"\n\n          self.cache_update_path remote_gem_path, local_gem_path\n        end\n      end\n    when 'file' then\n      begin\n        path = source_uri.path\n        path = File.dirname(path) if File.extname(path) == '.gem'\n\n        remote_gem_path = correct_for_windows_path(File.join(path, 'gems', gem_file_name))\n\n        FileUtils.cp(remote_gem_path, local_gem_path)\n      rescue Errno::EACCES\n        local_gem_path = source_uri.to_s\n      end\n\n      verbose \"Using local gem #{local_gem_path}\"\n    when nil then # TODO test for local overriding cache\n      source_path = if Gem.win_platform? && source_uri.scheme &&\n                       !source_uri.path.include?(':') then\n                      \"#{source_uri.scheme}:#{source_uri.path}\"\n                    else\n                      source_uri.path\n                    end\n\n      source_path = Gem::UriFormatter.new(source_path).unescape\n\n      begin\n        FileUtils.cp source_path, local_gem_path unless\n          File.identical?(source_path, local_gem_path)\n      rescue Errno::EACCES\n        local_gem_path = source_uri.to_s\n      end\n\n      verbose \"Using local gem #{local_gem_path}\"\n    else\n      raise ArgumentError, \"unsupported URI scheme #{source_uri.scheme}\"\n    end\n\n    local_gem_path\n  end\n\n  ##\n  # File Fetcher. Dispatched by +fetch_path+. Use it instead.\n\n  def fetch_file uri, *_\n    Gem.read_binary correct_for_windows_path uri.path\n  end\n\n  ##\n  # HTTP Fetcher. Dispatched by +fetch_path+. Use it instead.\n\n  def fetch_http uri, last_modified = nil, head = false, depth = 0\n    fetch_type = head ? Net::HTTP::Head : Net::HTTP::Get\n    response   = request uri, fetch_type, last_modified do |req|\n      headers.each { |k,v| req.add_field(k,v) }\n    end\n\n    case response\n    when Net::HTTPOK, Net::HTTPNotModified then\n      response.uri = uri if response.respond_to? :uri\n      head ? response : response.body\n    when Net::HTTPMovedPermanently, Net::HTTPFound, Net::HTTPSeeOther,\n         Net::HTTPTemporaryRedirect then\n      raise FetchError.new('too many redirects', uri) if depth > 10\n\n      unless location = response['Location']\n        raise FetchError.new(\"redirecting but no redirect location was given\", uri)\n      end\n      location = URI.parse response['Location']\n\n      if https?(uri) && !https?(location)\n        raise FetchError.new(\"redirecting to non-https resource: #{location}\", uri)\n      end\n\n      fetch_http(location, last_modified, head, depth + 1)\n    else\n      raise FetchError.new(\"bad response #{response.message} #{response.code}\", uri)\n    end\n  end\n\n  alias :fetch_https :fetch_http\n\n  ##\n  # Downloads +uri+ and returns it as a String.\n\n  def fetch_path(uri, mtime = nil, head = false)\n    uri = URI.parse uri unless URI::Generic === uri\n\n    raise ArgumentError, \"bad uri: #{uri}\" unless uri\n\n    unless uri.scheme\n      raise ArgumentError, \"uri scheme is invalid: #{uri.scheme.inspect}\"\n    end\n\n    data = send \"fetch_#{uri.scheme}\", uri, mtime, head\n\n    if data and !head and uri.to_s =~ /\\.gz$/\n      begin\n        data = Gem.gunzip data\n      rescue Zlib::GzipFile::Error\n        raise FetchError.new(\"server did not return a valid file\", uri.to_s)\n      end\n    end\n\n    data\n  rescue FetchError\n    raise\n  rescue Timeout::Error\n    raise UnknownHostError.new('timed out', uri.to_s)\n  rescue IOError, SocketError, SystemCallError => e\n    if e.message =~ /getaddrinfo/\n      raise UnknownHostError.new('no such name', uri.to_s)\n    else\n      raise FetchError.new(\"#{e.class}: #{e}\", uri.to_s)\n    end\n  end\n\n  def fetch_s3(uri, mtime = nil, head = false)\n    public_uri = sign_s3_url(uri)\n    fetch_https public_uri, mtime, head\n  end\n\n  ##\n  # Downloads +uri+ to +path+ if necessary. If no path is given, it just\n  # passes the data.\n\n  def cache_update_path uri, path = nil, update = true\n    mtime = path && File.stat(path).mtime rescue nil\n\n    data = fetch_path(uri, mtime)\n\n    if data == nil # indicates the server returned 304 Not Modified\n      return Gem.read_binary(path)\n    end\n\n    if update and path\n      Gem.write_binary(path, data)\n    end\n\n    data\n  end\n\n  ##\n  # Returns the size of +uri+ in bytes.\n\n  def fetch_size(uri) # TODO: phase this out\n    response = fetch_path(uri, nil, true)\n\n    response['content-length'].to_i\n  end\n\n  def correct_for_windows_path(path)\n    if path[0].chr == '/' && path[1].chr =~ /[a-z]/i && path[2].chr == ':'\n      path[1..-1]\n    else\n      path\n    end\n  end\n\n  ##\n  # Performs a Net::HTTP request of type +request_class+ on +uri+ returning\n  # a Net::HTTP response object.  request maintains a table of persistent\n  # connections to reduce connect overhead.\n\n  def request(uri, request_class, last_modified = nil)\n    proxy = proxy_for @proxy, uri\n    pool  = pools_for(proxy).pool_for uri\n\n    request = Gem::Request.new uri, request_class, last_modified, pool\n\n    request.fetch do |req|\n      yield req if block_given?\n    end\n  end\n\n  def https?(uri)\n    uri.scheme.downcase == 'https'\n  end\n\n  def close_all\n    @pools.each_value {|pool| pool.close_all}\n  end\n\n  protected\n\n  # we have our own signing code here to avoid a dependency on the aws-sdk gem\n  # fortunately, a simple GET request isn't too complex to sign properly\n  def sign_s3_url(uri, expiration = nil)\n    require 'base64'\n    require 'openssl'\n\n    unless uri.user && uri.password\n      raise FetchError.new(\"credentials needed in s3 source, like s3://key:secret@bucket-name/\", uri.to_s)\n    end\n\n    expiration ||= s3_expiration\n    canonical_path = \"/#{uri.host}#{uri.path}\"\n    payload = \"GET\\n\\n\\n#{expiration}\\n#{canonical_path}\"\n    digest = OpenSSL::HMAC.digest('sha1', uri.password, payload)\n    # URI.escape is deprecated, and there isn't yet a replacement that does quite what we want\n    signature = Base64.encode64(digest).gsub(\"\\n\", '').gsub(/[\\+\\/=]/) { |c| BASE64_URI_TRANSLATE[c] }\n    URI.parse(\"https://#{uri.host}.s3.amazonaws.com#{uri.path}?AWSAccessKeyId=#{uri.user}&Expires=#{expiration}&Signature=#{signature}\")\n  end\n\n  def s3_expiration\n    (Time.now + 3600).to_i # one hour from now\n  end\n\n  BASE64_URI_TRANSLATE = { '+' => '%2B', '/' => '%2F', '=' => '%3D' }.freeze\n\n  private\n\n  def proxy_for proxy, uri\n    Gem::Request.proxy_uri(proxy || Gem::Request.get_proxy_from_env(uri.scheme))\n  end\n\n  def pools_for proxy\n    @pool_lock.synchronize do\n      @pools[proxy] ||= Gem::Request::ConnectionPools.new proxy, @cert_files\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\n\nrequire 'webrick'\nbegin\n  require 'webrick/https'\nrescue LoadError => e\n  raise unless (e.respond_to?(:path) && e.path == 'openssl') ||\n               e.message =~ / -- openssl$/\nend\n\nrequire 'rubygems/remote_fetcher'\nrequire 'rubygems/package'\nrequire 'minitest/mock'\n\n# = Testing Proxy Settings\n#\n# These tests check the proper proxy server settings by running two\n# web servers.  The web server at http://localhost:#{SERVER_PORT}\n# represents the normal gem server and returns a gemspec with a rake\n# version of 0.4.11.  The web server at http://localhost:#{PROXY_PORT}\n# represents the proxy server and returns a different dataset where\n# rake has version 0.4.2.  This allows us to detect which server is\n# returning the data.\n#\n# Note that the proxy server is not a *real* proxy server.  But our\n# software doesn't really care, as long as we hit the proxy URL when a\n# proxy is configured.\n\nclass TestGemRemoteFetcher < Gem::TestCase\n\n  include Gem::DefaultUserInteraction\n\n  SERVER_DATA = <<-EOY\n--- !ruby/object:Gem::Cache\ngems:\n  rake-0.4.11: !ruby/object:Gem::Specification\n    rubygems_version: \"0.7\"\n    specification_version: 1\n    name: rake\n    version: !ruby/object:Gem::Version\n      version: 0.4.11\n    date: 2004-11-12\n    summary: Ruby based make-like utility.\n    require_paths:\n      - lib\n    author: Jim Weirich\n    email: jim@weirichhouse.org\n    homepage: http://rake.rubyforge.org\n    rubyforge_project: rake\n    description: Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.\n    autorequire:\n    default_executable: rake\n    bindir: bin\n    has_rdoc: true\n    required_ruby_version: !ruby/object:Gem::Version::Requirement\n      requirements:\n        -\n          - \">\"\n          - !ruby/object:Gem::Version\n            version: 0.0.0\n      version:\n    platform: ruby\n    files:\n      - README\n    test_files: []\n    library_stubs:\n    rdoc_options:\n    extra_rdoc_files:\n    executables:\n      - rake\n    extensions: []\n    requirements: []\n    dependencies: []\n  EOY\n\n  PROXY_DATA = SERVER_DATA.gsub(/0.4.11/, '0.4.2')\n\n  DIR = File.expand_path(File.dirname(__FILE__))\n\n  # Generated via:\n  #   x = OpenSSL::PKey::DH.new(2048) # wait a while...\n  #   x.to_s => pem\n  TEST_KEY_DH2048 =  OpenSSL::PKey::DH.new <<-_end_of_pem_\n-----BEGIN DH PARAMETERS-----\nMIIBCAKCAQEA3Ze2EHSfYkZLUn557torAmjBgPsqzbodaRaGZtgK1gEU+9nNJaFV\nG1JKhmGUiEDyIW7idsBpe4sX/Wqjnp48Lr8IeI/SlEzLdoGpf05iRYXC8Cm9o8aM\ncfmVgoSEAo9YLBpzoji2jHkO7Q5IPt4zxbTdlmmGFLc/GO9q7LGHhC+rcMcNTGsM\n49AnILNn49pq4Y72jSwdmvq4psHZwwFBbPwLdw6bLUDDCN90jfqvYt18muwUxDiN\nNP0fuvVAIB158VnQ0liHSwcl6+9vE1mL0Jo/qEXQxl0+UdKDjaGfTsn6HIrwTnmJ\nPeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==\n-----END DH PARAMETERS-----\n    _end_of_pem_\n\n  def setup\n    @proxies = %w[https_proxy http_proxy HTTP_PROXY http_proxy_user HTTP_PROXY_USER http_proxy_pass HTTP_PROXY_PASS no_proxy NO_PROXY]\n    @old_proxies = @proxies.map {|k| ENV[k] }\n    @proxies.each {|k| ENV[k] = nil }\n\n    super\n    self.class.start_servers\n    self.class.enable_yaml = true\n    self.class.enable_zip = false\n\n    base_server_uri = \"http://localhost:#{self.class.normal_server_port}\"\n    @proxy_uri = \"http://localhost:#{self.class.proxy_server_port}\"\n\n    @server_uri = base_server_uri + \"/yaml\"\n    @server_z_uri = base_server_uri + \"/yaml.Z\"\n\n    # REFACTOR: copied from test_gem_dependency_installer.rb\n    @gems_dir = File.join @tempdir, 'gems'\n    @cache_dir = File.join @gemhome, \"cache\"\n    FileUtils.mkdir @gems_dir\n\n    # TODO: why does the remote fetcher need it written to disk?\n    @a1, @a1_gem = util_gem 'a', '1' do |s| s.executables << 'a_bin' end\n    @a1.loaded_from = File.join(@gemhome, 'specifications', @a1.full_name)\n\n    Gem::RemoteFetcher.fetcher = nil\n\n    @fetcher = Gem::RemoteFetcher.fetcher\n  end\n\n  def teardown\n    @fetcher.close_all\n    self.class.stop_servers\n    super\n    Gem.configuration[:http_proxy] = nil\n    @proxies.each_with_index {|k, i| ENV[k] = @old_proxies[i] }\n  end\n\n  def test_self_fetcher\n    fetcher = Gem::RemoteFetcher.fetcher\n    refute_nil fetcher\n    assert_kind_of Gem::RemoteFetcher, fetcher\n  end\n\n  def test_self_fetcher_with_proxy\n    proxy_uri = 'http://proxy.example.com'\n    Gem.configuration[:http_proxy] = proxy_uri\n    Gem::RemoteFetcher.fetcher = nil\n\n    fetcher = Gem::RemoteFetcher.fetcher\n\n    refute_nil fetcher\n    assert_kind_of Gem::RemoteFetcher, fetcher\n    assert_equal proxy_uri, fetcher.instance_variable_get(:@proxy).to_s\n  end\n\n  def test_fetch_size_bad_uri\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    e = assert_raises ArgumentError do\n      fetcher.fetch_size 'gems.example.com/yaml'\n    end\n\n    assert_equal 'uri scheme is invalid: nil', e.message\n  end\n\n  def test_fetch_size_socket_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    def fetcher.request(uri, request_class, last_modified = nil)\n      raise SocketError, \"oops\"\n    end\n\n    uri = 'http://gems.example.com/yaml'\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_size uri\n    end\n\n    assert_equal \"SocketError: oops (#{uri})\", e.message\n  end\n\n  def test_no_proxy\n    use_ui @ui do\n      assert_data_from_server @fetcher.fetch_path(@server_uri)\n      assert_equal SERVER_DATA.size, @fetcher.fetch_size(@server_uri)\n    end\n  end\n\n  def test_api_endpoint\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"gems.example.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://gems.example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values\n    uri = URI.parse \"http://gems.example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"blah.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://gems.example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values_that_starts_with_original\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"example.combadguy.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values_that_end_with_original\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"badexample.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_ignores_trans_domain_values_that_end_with_original_in_path\n    uri = URI.parse \"http://example.com/foo\"\n    target = MiniTest::Mock.new\n    target.expect :target, \"evil.com/a.example.com\"\n\n    dns = MiniTest::Mock.new\n    dns.expect :getresource, target, [String, Object]\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    assert_equal URI.parse(\"http://example.com/foo\"), fetch.api_endpoint(uri)\n\n    target.verify\n    dns.verify\n  end\n\n  def test_api_endpoint_timeout_warning\n    uri = URI.parse \"http://gems.example.com/foo\"\n\n    dns = MiniTest::Mock.new\n    def dns.getresource arg, *rest\n      raise Resolv::ResolvError.new('timeout!')\n    end\n\n    fetch = Gem::RemoteFetcher.new nil, dns\n    begin\n      old_verbose, Gem.configuration.verbose = Gem.configuration.verbose, 1\n      endpoint = use_ui @ui do\n        fetch.api_endpoint(uri)\n      end\n    ensure\n      Gem.configuration.verbose = old_verbose\n    end\n\n    assert_equal uri, endpoint\n\n    assert_equal \"Getting SRV record failed: timeout!\\n\", @ui.output\n\n    dns.verify\n  end\n\n  def test_cache_update_path\n    uri = URI 'http://example/file'\n    path = File.join @tempdir, 'file'\n\n    fetcher = util_fuck_with_fetcher 'hello'\n\n    data = fetcher.cache_update_path uri, path\n\n    assert_equal 'hello', data\n\n    assert_equal 'hello', File.read(path)\n  end\n\n  def test_cache_update_path_no_update\n    uri = URI 'http://example/file'\n    path = File.join @tempdir, 'file'\n\n    fetcher = util_fuck_with_fetcher 'hello'\n\n    data = fetcher.cache_update_path uri, path, false\n\n    assert_equal 'hello', data\n\n    refute_path_exists path\n  end\n\n  def util_fuck_with_fetcher data, blow = false\n    fetcher = Gem::RemoteFetcher.fetcher\n    fetcher.instance_variable_set :@test_data, data\n\n    unless blow then\n      def fetcher.fetch_path arg, *rest\n        @test_arg = arg\n        @test_data\n      end\n    else\n      def fetcher.fetch_path arg, *rest\n        # OMG I'm such an ass\n        class << self; remove_method :fetch_path; end\n        def self.fetch_path arg, *rest\n          @test_arg = arg\n          @test_data\n        end\n\n        raise Gem::RemoteFetcher::FetchError.new(\"haha!\", nil)\n      end\n    end\n\n    fetcher\n  end\n\n  def test_download\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://gems.example.com')\n    assert_equal(\"http://gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_with_auth\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:password@gems.example.com')\n    assert_equal(\"http://user:password@gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_with_encoded_auth\n    a1_data = nil\n    File.open @a1_gem, 'rb' do |fp|\n      a1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    a1_cache_gem = @a1.cache_file\n    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:%25pas%25sword@gems.example.com')\n    assert_equal(\"http://user:%25pas%25sword@gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(a1_cache_gem)\n  end\n\n  def test_download_cached\n    FileUtils.mv @a1_gem, @cache_dir\n\n    inst = Gem::RemoteFetcher.fetcher\n\n    assert_equal @a1.cache_file, inst.download(@a1, 'http://gems.example.com')\n  end\n\n  def test_download_local\n    FileUtils.mv @a1_gem, @tempdir\n    local_path = File.join @tempdir, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    assert_equal @a1.cache_file, inst.download(@a1, local_path)\n  end\n\n  def test_download_local_space\n    space_path = File.join @tempdir, 'space path'\n    FileUtils.mkdir space_path\n    FileUtils.mv @a1_gem, space_path\n    local_path = File.join space_path, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    assert_equal @a1.cache_file, inst.download(@a1, local_path)\n  end\n\n  def test_download_install_dir\n    a1_data = File.open @a1_gem, 'rb' do |fp|\n      fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher a1_data\n\n    install_dir = File.join @tempdir, 'more_gems'\n\n    a1_cache_gem = File.join install_dir, \"cache\", @a1.file_name\n    FileUtils.mkdir_p(File.dirname(a1_cache_gem))\n    actual = fetcher.download(@a1, 'http://gems.example.com', install_dir)\n\n    assert_equal a1_cache_gem, actual\n    assert_equal(\"http://gems.example.com/gems/a-1.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n\n    assert File.exist?(a1_cache_gem)\n  end\n\n  unless win_platform? # File.chmod doesn't work\n    def test_download_local_read_only\n      FileUtils.mv @a1_gem, @tempdir\n      local_path = File.join @tempdir, @a1.file_name\n      inst = nil\n      FileUtils.chmod 0555, @a1.cache_dir\n\n      Dir.chdir @tempdir do\n        inst = Gem::RemoteFetcher.fetcher\n      end\n\n      assert_equal(File.join(@tempdir, @a1.file_name),\n                   inst.download(@a1, local_path))\n    ensure\n      FileUtils.chmod 0755, @a1.cache_dir\n    end\n\n    def test_download_read_only\n      FileUtils.chmod 0555, @a1.cache_dir\n      FileUtils.chmod 0555, @gemhome\n\n      fetcher = util_fuck_with_fetcher File.read(@a1_gem)\n      fetcher.download(@a1, 'http://gems.example.com')\n      a1_cache_gem = File.join Gem.user_dir, \"cache\", @a1.file_name\n      assert File.exist? a1_cache_gem\n    ensure\n      FileUtils.chmod 0755, @gemhome\n      FileUtils.chmod 0755, @a1.cache_dir\n    end\n  end\n\n  def test_download_platform_legacy\n    original_platform = 'old-platform'\n\n    e1, e1_gem = util_gem 'e', '1' do |s|\n      s.platform = Gem::Platform::CURRENT\n      s.instance_variable_set :@original_platform, original_platform\n    end\n    e1.loaded_from = File.join(@gemhome, 'specifications', e1.full_name)\n\n    e1_data = nil\n    File.open e1_gem, 'rb' do |fp|\n      e1_data = fp.read\n    end\n\n    fetcher = util_fuck_with_fetcher e1_data, :blow_chunks\n\n    e1_cache_gem = e1.cache_file\n\n    assert_equal e1_cache_gem, fetcher.download(e1, 'http://gems.example.com')\n\n    assert_equal(\"http://gems.example.com/gems/#{e1.original_name}.gem\",\n                 fetcher.instance_variable_get(:@test_arg).to_s)\n    assert File.exist?(e1_cache_gem)\n  end\n\n  def test_download_same_file\n    FileUtils.mv @a1_gem, @tempdir\n    local_path = File.join @tempdir, @a1.file_name\n    inst = nil\n\n    Dir.chdir @tempdir do\n      inst = Gem::RemoteFetcher.fetcher\n    end\n\n    cache_path = @a1.cache_file\n    FileUtils.mv local_path, cache_path\n\n    gem = Gem::Package.new cache_path\n\n    assert_equal cache_path, inst.download(gem.spec, cache_path)\n  end\n\n  def test_download_unsupported\n    inst = Gem::RemoteFetcher.fetcher\n\n    e = assert_raises ArgumentError do\n      inst.download @a1, 'ftp://gems.rubyforge.org'\n    end\n\n    assert_equal 'unsupported URI scheme ftp', e.message\n  end\n\n  def test_download_to_cache\n    @a2, @a2_gem = util_gem 'a', '2'\n\n    util_setup_spec_fetcher @a1, @a2\n    @fetcher.instance_variable_set :@a1, @a1\n    @fetcher.instance_variable_set :@a2, @a2\n    def @fetcher.fetch_path uri, mtime = nil, head = false\n      case uri.request_uri\n      when /#{@a1.spec_name}/ then\n        Gem.deflate Marshal.dump @a1\n      when /#{@a2.spec_name}/ then\n        Gem.deflate Marshal.dump @a2\n      else\n        uri.to_s\n      end\n    end\n\n    gem = Gem::RemoteFetcher.fetcher.download_to_cache dep 'a'\n\n    assert_equal @a2.file_name, File.basename(gem)\n  end\n\n  def test_fetch_path_gzip\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      Gem.gzip 'foo'\n    end\n\n    assert_equal 'foo', fetcher.fetch_path(@uri + 'foo.gz')\n  end\n\n  def test_fetch_path_gzip_unmodified\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      nil\n    end\n\n    assert_equal nil, fetcher.fetch_path(@uri + 'foo.gz', Time.at(0))\n  end\n\n  def test_fetch_path_io_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(*)\n      raise EOFError\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_equal \"EOFError: EOFError (#{url})\", e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_socket_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      raise SocketError\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_equal \"SocketError: SocketError (#{url})\", e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_system_call_error\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime = nil, head = nil)\n      raise Errno::ECONNREFUSED, 'connect(2)'\n    end\n\n    url = 'http://example.com/uri'\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_path url\n    end\n\n    assert_match %r|ECONNREFUSED:.*connect\\(2\\) \\(#{Regexp.escape url}\\)\\z|,\n                 e.message\n    assert_equal url, e.uri\n  end\n\n  def test_fetch_path_unmodified\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    def fetcher.fetch_http(uri, mtime, head = nil)\n      nil\n    end\n\n    assert_equal nil, fetcher.fetch_path(URI.parse(@gem_repo), Time.at(0))\n  end\n\n  def test_implicit_no_proxy\n    use_ui @ui do\n      ENV['http_proxy'] = 'http://fakeurl:12345'\n      fetcher = Gem::RemoteFetcher.new :no_proxy\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_proxy\n    use_ui @ui do\n      ENV['http_proxy'] = @proxy_uri\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_proxy fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_upper_case_proxy\n    use_ui @ui do\n      ENV['HTTP_PROXY'] = @proxy_uri\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_proxy fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_implicit_proxy_no_env\n    use_ui @ui do\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_fetch_http\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      url = 'http://gems.example.com/redirect'\n      unless defined? @requested then\n        @requested = true\n        res = Net::HTTPMovedPermanently.new nil, 301, nil\n        res.add_field 'Location', url\n        res\n      else\n        res = Net::HTTPOK.new nil, 200, nil\n        def res.body() 'real_path' end\n        res\n      end\n    end\n\n    data = fetcher.fetch_http URI.parse(url)\n\n    assert_equal 'real_path', data\n  end\n\n  def test_fetch_http_redirects\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      url = 'http://gems.example.com/redirect'\n      res = Net::HTTPMovedPermanently.new nil, 301, nil\n      res.add_field 'Location', url\n      res\n    end\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_http URI.parse(url)\n    end\n\n    assert_equal \"too many redirects (#{url})\", e.message\n  end\n\n  def test_fetch_http_redirects_without_location\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 'http://gems.example.com/redirect'\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      res = Net::HTTPMovedPermanently.new nil, 301, nil\n      res\n    end\n\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_http URI.parse(url)\n    end\n\n    assert_equal \"redirecting but no redirect location was given (#{url})\", e.message\n  end\n\n  def test_fetch_http_with_additional_headers\n    ENV[\"http_proxy\"] = @proxy_uri\n    ENV[\"no_proxy\"] = URI::parse(@server_uri).host\n    fetcher = Gem::RemoteFetcher.new nil, nil, {\"X-Captain\" => \"murphy\"}\n    @fetcher = fetcher\n    assert_equal \"murphy\", fetcher.fetch_path(@server_uri)\n  end\n\n  def test_fetch_s3\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 's3://testuser:testpass@my-bucket/gems/specs.4.8.gz'\n    $fetched_uri = nil\n\n    def fetcher.request(uri, request_class, last_modified = nil)\n      $fetched_uri = uri\n      res = Net::HTTPOK.new nil, 200, nil\n      def res.body() 'success' end\n      res\n    end\n\n    def fetcher.s3_expiration\n      1395098371\n    end\n\n    data = fetcher.fetch_s3 URI.parse(url)\n\n    assert_equal 'https://my-bucket.s3.amazonaws.com/gems/specs.4.8.gz?AWSAccessKeyId=testuser&Expires=1395098371&Signature=eUTr7NkpZEet%2BJySE%2BfH6qukroI%3D', $fetched_uri.to_s\n    assert_equal 'success', data\n  ensure\n    $fetched_uri = nil\n  end\n\n  def test_fetch_s3_no_creds\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n    url = 's3://my-bucket/gems/specs.4.8.gz'\n    e = assert_raises Gem::RemoteFetcher::FetchError do\n      fetcher.fetch_s3 URI.parse(url)\n    end\n\n    assert_match \"credentials needed\", e.message\n  end\n\n  def test_observe_no_proxy_env_single_host\n    use_ui @ui do\n      ENV[\"http_proxy\"] = @proxy_uri\n      ENV[\"no_proxy\"] = URI::parse(@server_uri).host\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_observe_no_proxy_env_list\n    use_ui @ui do\n      ENV[\"http_proxy\"] = @proxy_uri\n      ENV[\"no_proxy\"] = \"fakeurl.com, #{URI::parse(@server_uri).host}\"\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_data_from_server fetcher.fetch_path(@server_uri)\n    end\n  end\n\n  def test_request_block\n    fetcher = Gem::RemoteFetcher.new nil\n    @fetcher = fetcher\n\n    assert_throws :block_called do\n      fetcher.request URI('http://example'), Net::HTTP::Get do |req|\n        assert_kind_of Net::HTTPGenericRequest, req\n        throw :block_called\n      end\n    end\n  end\n\n  def test_yaml_error_on_size\n    use_ui @ui do\n      self.class.enable_yaml = false\n      fetcher = Gem::RemoteFetcher.new nil\n      @fetcher = fetcher\n      assert_error { fetcher.size }\n    end\n  end\n\n  def test_ssl_connection\n    ssl_server = self.class.start_ssl_server\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    with_configured_fetcher(\":ssl_ca_cert: #{temp_ca_cert}\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_ssl_client_cert_auth_connection\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    ssl_server = self.class.start_ssl_server({\n      :SSLVerifyClient =>\n        OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})\n\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    temp_client_cert = File.join(DIR, 'client.pem')\n\n    with_configured_fetcher(\n      \":ssl_ca_cert: #{temp_ca_cert}\\n\" +\n      \":ssl_client_cert: #{temp_client_cert}\\n\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_do_not_allow_invalid_client_cert_auth_connection\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    ssl_server = self.class.start_ssl_server({\n      :SSLVerifyClient =>\n        OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})\n\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem')\n    temp_client_cert = File.join(DIR, 'invalid_client.pem')\n\n    with_configured_fetcher(\n      \":ssl_ca_cert: #{temp_ca_cert}\\n\" +\n      \":ssl_client_cert: #{temp_client_cert}\\n\") do |fetcher|\n        assert_raises Gem::RemoteFetcher::FetchError do\n          fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n        end\n    end\n  end\n\n  def test_do_not_allow_insecure_ssl_connection_by_default\n    ssl_server = self.class.start_ssl_server\n    with_configured_fetcher do |fetcher|\n      assert_raises Gem::RemoteFetcher::FetchError do\n        fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n      end\n    end\n  end\n\n  def test_ssl_connection_allow_verify_none\n    ssl_server = self.class.start_ssl_server\n    with_configured_fetcher(\":ssl_verify_mode: 0\") do |fetcher|\n      fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/yaml\")\n    end\n  end\n\n  def test_do_not_follow_insecure_redirect\n    ssl_server = self.class.start_ssl_server\n    temp_ca_cert = File.join(DIR, 'ca_cert.pem'),\n    with_configured_fetcher(\":ssl_ca_cert: #{temp_ca_cert}\") do |fetcher|\n      assert_raises Gem::RemoteFetcher::FetchError do\n        fetcher.fetch_path(\"https://localhost:#{ssl_server.config[:Port]}/insecure_redirect?to=#{@server_uri}\")\n      end\n    end\n  end\n\n  def with_configured_fetcher(config_str = nil, &block)\n    if config_str\n      temp_conf = File.join @tempdir, '.gemrc'\n      File.open temp_conf, 'w' do |fp|\n        fp.puts config_str\n      end\n      Gem.configuration = Gem::ConfigFile.new %W[--config-file #{temp_conf}]\n    end\n    fetcher = Gem::RemoteFetcher.new\n    yield fetcher\n  ensure\n    fetcher.close_all\n    Gem.configuration = nil\n  end\n\n  def assert_error(exception_class=Exception)\n    got_exception = false\n\n    begin\n      yield\n    rescue exception_class\n      got_exception = true\n    end\n\n    assert got_exception, \"Expected exception conforming to #{exception_class}\"\n  end\n\n  def assert_data_from_server(data)\n    assert_match(/0\\.4\\.11/, data, \"Data is not from server\")\n  end\n\n  def assert_data_from_proxy(data)\n    assert_match(/0\\.4\\.2/, data, \"Data is not from proxy\")\n  end\n\n  class NilLog < WEBrick::Log\n    def log(level, data) #Do nothing\n    end\n  end\n\n  class << self\n    attr_reader :normal_server, :proxy_server\n    attr_accessor :enable_zip, :enable_yaml\n\n    def start_servers\n      @normal_server ||= start_server(SERVER_DATA)\n      @proxy_server  ||= start_server(PROXY_DATA)\n      @enable_yaml = true\n      @enable_zip = false\n      @ssl_server = nil\n      @ssl_server_thread = nil\n    end\n\n    def stop_servers\n      if @normal_server\n        @normal_server.kill.join\n        @normal_server = nil\n      end\n      if @proxy_server\n        @proxy_server.kill.join\n        @proxy_server = nil\n      end\n      if @ssl_server\n        @ssl_server.stop\n        @ssl_server = nil\n      end\n      if @ssl_server_thread\n        @ssl_server_thread.kill.join\n        @ssl_server_thread = nil\n      end\n      utils = WEBrick::Utils    # TimeoutHandler is since 1.9\n      utils::TimeoutHandler.terminate if defined?(utils::TimeoutHandler.terminate)\n    end\n\n    def normal_server_port\n      @normal_server[:server].config[:Port]\n    end\n\n    def proxy_server_port\n      @proxy_server[:server].config[:Port]\n    end\n\n    DIR = File.expand_path(File.dirname(__FILE__))\n\n    def start_ssl_server(config = {})\n      raise MiniTest::Skip, 'openssl not installed' unless\n        defined?(OpenSSL::SSL)\n\n      null_logger = NilLog.new\n      server = WEBrick::HTTPServer.new({\n        :Port => 0,\n        :Logger => null_logger,\n        :AccessLog => [],\n        :SSLEnable => true,\n        :SSLCACertificateFile => File.join(DIR, 'ca_cert.pem'),\n        :SSLCertificate => cert('ssl_cert.pem'),\n        :SSLPrivateKey => key('ssl_key.pem'),\n        :SSLVerifyClient => nil,\n        :SSLCertName => nil\n      }.merge(config))\n      server.mount_proc(\"/yaml\") { |req, res|\n        res.body = \"--- true\\n\"\n      }\n      server.mount_proc(\"/insecure_redirect\") { |req, res|\n        res.set_redirect(WEBrick::HTTPStatus::MovedPermanently, req.query['to'])\n      }\n      server.ssl_context.tmp_dh_callback = proc { TEST_KEY_DH2048 }\n      t = Thread.new do\n        begin\n          server.start\n        rescue Exception => ex\n          abort ex.message\n          puts \"ERROR during server thread: #{ex.message}\"\n        ensure\n          server.shutdown\n        end\n      end\n      while server.status != :Running\n        sleep 0.1\n        unless t.alive?\n          t.join\n          raise\n        end\n      end\n      @ssl_server = server\n      @ssl_server_thread = t\n      server\n    end\n\n    private\n\n    def start_server(data)\n      null_logger = NilLog.new\n      s = WEBrick::HTTPServer.new(\n        :Port            => 0,\n        :DocumentRoot    => nil,\n        :Logger          => null_logger,\n        :AccessLog       => null_logger\n        )\n      s.mount_proc(\"/kill\") { |req, res| s.shutdown }\n      s.mount_proc(\"/yaml\") { |req, res|\n        if req[\"X-Captain\"]\n          res.body = req[\"X-Captain\"]\n        elsif @enable_yaml\n          res.body = data\n          res['Content-Type'] = 'text/plain'\n          res['content-length'] = data.size\n        else\n          res.status = \"404\"\n          res.body = \"<h1>NOT FOUND</h1>\"\n          res['Content-Type'] = 'text/html'\n        end\n      }\n      s.mount_proc(\"/yaml.Z\") { |req, res|\n        if @enable_zip\n          res.body = Zlib::Deflate.deflate(data)\n          res['Content-Type'] = 'text/plain'\n        else\n          res.status = \"404\"\n          res.body = \"<h1>NOT FOUND</h1>\"\n          res['Content-Type'] = 'text/html'\n        end\n      }\n      th = Thread.new do\n        begin\n          s.start\n        rescue Exception => ex\n          abort \"ERROR during server thread: #{ex.message}\"\n        ensure\n          s.shutdown\n        end\n      end\n      th[:server] = s\n      th\n    end\n\n    def cert(filename)\n      OpenSSL::X509::Certificate.new(File.read(File.join(DIR, filename)))\n    end\n\n    def key(filename)\n      OpenSSL::PKey::RSA.new(File.read(File.join(DIR, filename)))\n    end\n  end\n\n  def test_correct_for_windows_path\n    path = \"/C:/WINDOWS/Temp/gems\"\n    assert_equal \"C:/WINDOWS/Temp/gems\", @fetcher.correct_for_windows_path(path)\n\n    path = \"/home/skillet\"\n    assert_equal \"/home/skillet\", @fetcher.correct_for_windows_path(path)\n  end\n\nend\n"], "filenames": ["lib/rubygems/remote_fetcher.rb", "test/rubygems/test_gem_remote_fetcher.rb"], "buggy_code_start_loc": [113, 243], "buggy_code_end_loc": [114, 243], "fixing_code_start_loc": [113, 244], "fixing_code_end_loc": [114, 259], "type": "CWE-346", "message": "RubyGems version 2.6.12 and earlier is vulnerable to a DNS hijacking vulnerability that allows a MITM attacker to force the RubyGems client to download and install gems from a server that the attacker controls.", "other": {"cve": {"id": "CVE-2017-0902", "sourceIdentifier": "support@hackerone.com", "published": "2017-08-31T20:29:00.603", "lastModified": "2019-10-09T23:21:10.117", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version 2.6.12 and earlier is vulnerable to a DNS hijacking vulnerability that allows a MITM attacker to force the RubyGems client to download and install gems from a server that the attacker controls."}, {"lang": "es", "value": "RubyGems 2.6.12 y anteriores es vulnerable a secuestro de DNS, lo que permite a un atacante Man-in-the-Middle (MitM) forzar el cliente RubyGems a que descargue e instale gemas desde un servidor que est\u00e1 bajo el control del atacante."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-350"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.12", "matchCriteriaId": "1161B0D8-43B3-4123-BD4F-87F260AB8947"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://blog.rubygems.org/2017/08/27/2.6.13-released.html", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/100586", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039249", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3485", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0378", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0583", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0585", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rubygems/rubygems/commit/8d91516fb7037ecfb27622f605dc40245e0f8d32", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/218088", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-01", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3553-1/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3685-1/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3966", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/8d91516fb7037ecfb27622f605dc40245e0f8d32"}}