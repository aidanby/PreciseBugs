{"buggy_code": ["# pengu\n\n**pengu** is lightweight web chat built with HTML 5 resembling Club Penguin.\n\n## Prerequisites\n\nThe project uses npm to install dependencies and Node.js to run. Download them by running [Nix](https://nixos.org/download.html)\u2019s `nix-shell` command, using your system\u2019s package manager or from [their website](https://nodejs.org/en/).\n\nOptionally, you will also need [PostgreSQL](https://www.postgresql.org/) database server if you want Pengu to remember player inventories across restarts.\n\n## Installation\n\n1. Create the following table in PostgreSQL database and set `DATABASE_URL` to correct connection string.\n\n```\nCREATE TABLE \"penguin\" (\n\t\"name\" character varying NOT NULL PRIMARY KEY,\n\t\"closet\" json DEFAULT '{}' NOT NULL,\n\t\"clothing\" json DEFAULT '[]' NOT NULL,\n\t\"registered\" timestamptz DEFAULT current_timestamp NOT NULL,\n\t\"banned\" boolean DEFAULT false NOT NULL,\n\t\"group\" character varying DEFAULT 'basic' NOT NULL\n);\n```\n\n2. Run `npm install`.\n3. Compile assets using `npm run build`.\n4. Start with `npm start`, the game will run on port set by `PORT` env variable.\n\n## Configuration\n\npengu uses the following environment variables for configuration:\n\n* `PORT` \u2013 The port a web server will be running on. Of not specified it defaults to `8080`.\n* `DATABASE_URL` \u2013 [Connection string](https://node-postgres.com/features/connecting/#connection-uri) for the PostgreSQL database. If omitted, persistence will be missing.\n* `NODE_ENV` \u2013 Can be set to `production` for less verbose logs. Defaults to `development`.\n* `OPENID_PROVIDER` \u2013 If this is set, pengu will use OpenID to log-in. Though it only supports using a hardcoded identity specified by this variable. User will be redirected to the provider, where they will confirm their credentials, and then be redirected back to Pengu with an access code. Pengu will then verify the access code against the OpenID verification URL and realm specified by `OPENID_VERIFY`, `OPENID_REALM` environment variables.\n\n## Development\n\nThe front-end of Pengu is stored in the `assets/` directory and needs to be rebuilt when it is changed. You can use `npm run build` command to do that, or `npm run dev` if you want it to rebuild automatically on changes. Its build artefacts end up in the `client/` directory, from where the server will serve them.\n\n## License\n\npengu source code is made available under MIT license.\n", "#!/usr/bin/env node\n'use strict';\n\nprocess.title = 'pengu';\n\nconst { server: WebSocketServer } = require('websocket');\nconst http = require('http');\nconst path = require('path');\nconst express = require('express');\nconst pg = require('pg');\nconst poly = require('./poly');\nconst { Line, Point } = poly;\nconst pengu = require('./pengu');\nconst mapUtils = require('./mapUtils');\nconst { promisify } = require('es6-promisify');\nconst session = require('express-session');\nconst { signedCookie } = require('cookie-parser');\nconst morgan = require('morgan');\nconst serveStatic = require('serve-static');\nconst fs = require('fs');\n\nfunction findById(arr, id) {\n\tfor (let item of arr) {\n\t\tif (item.id === id) {\n\t\t\treturn item;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function runApp() {\n\tlet app = express();\n\n\tapp.set('port', process.env.PORT ?? 8080);\n\n\tlet sessionStore = new session.MemoryStore();\n\tlet secret = Math.random().toString();\n\tapp.use(session({store: sessionStore, resave: true, saveUninitialized: true, secret: secret, cookie: { maxAge: 10000 }, key: 'sid'}));\n\n\tlet env = process.env.NODE_ENV ?? 'development';\n\tif (env === 'development') {\n\t\tapp.use(morgan('combined'));\n\t}\n\n\tapp.get('/', function(req, res) {\n\t\tif (!req.session.user) {\n\t\t\tres.redirect('/authenticate');\n\t\t} else {\n\t\t\tres.statusCode = 200;\n\t\t\tres.sendFile(path.join(__dirname, '../client/index.html'));\n\t\t}\n\t});\n\n\tapp.use('/content', serveStatic(path.join(__dirname, '../content')));\n\tapp.use('/', serveStatic(path.join(__dirname, '../client')));\n\n\tif (process.env.OPENID_PROVIDER) {\n\t\trequire('./auth/openid')(app, process.env.OPENID_VERIFY, process.env.OPENID_REALM, process.env.OPENID_PROVIDER);\n\t} else {\n\t\trequire('./auth/simple')(app);\n\t}\n\n\tlet server = http.createServer(app).listen(app.get('port'));\n\tconsole.log('Started app on port %d', app.get('port'));\n\n\tlet wsServer = new WebSocketServer({\n\t\thttpServer: server,\n\t\tautoAcceptConnections: false\n\t});\n\n\tfunction originIsAllowed() {\n\t\treturn true;\n\t}\n\n\tlet clients = [];\n\tlet players = {};\n\tlet rooms = JSON.parse(fs.readFileSync(path.join(__dirname, '../content/world/map.json'), 'utf8'), function (key, value) {\n\t\tlet type;\n\t\tif (value && typeof value === 'object') {\n\t\t\ttype = value._class;\n\t\t\tif (typeof type === 'string' && typeof poly[type] === 'function') {\n\t\t\t\treturn new (poly[type])(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n\tlet items = JSON.parse(fs.readFileSync(path.join(__dirname, '../content/items/items.json'), 'utf8'));\n\n\tlet _dbUri = process.env.DATABASE_URL;\n\tlet dbEnabled = _dbUri !== null;\n\tlet pgpool = null;\n\tlet registered = {};\n\tif (dbEnabled) {\n\t\tpgpool = new pg.Pool({connectionString: _dbUri});\n\t\tlet result = await pgpool.query('select * from \"penguin\"');\n\t\tfor (let row of result.rows) {\n\t\t\tregistered[row.name] = row;\n\t\t}\n\t}\n\n\twsServer.on('request', function(request) {\n\t\tif (!originIsAllowed(request.origin)) {\n\t\t\trequest.reject();\n\t\t\tconsole.log((new Date()) + ' Connection from origin ' + request.origin + ' rejected.');\n\t\t\treturn;\n\t\t}\n\n\t\tlet connection = request.accept(null, request.origin);\n\t\tclients.push(connection);\n\t\tconsole.log((new Date()) + ' Connection accepted.');\n\t\tconnection.on('message', async function(message) {\n\t\t\tif (message.type === 'utf8') {\n\t\t\t\ttry {\n\t\t\t\t\tlet json = JSON.parse(message.utf8Data);\n\t\t\t\t\tconsole.log(json);\n\t\t\t\t\tif (json.type === 'init' && connection.name === undefined) {\n\t\t\t\t\t\tlet sid = signedCookie(request.cookies.filter((x) => x.name == 'sid')[0].value, secret);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet session = await promisify(sessionStore.get.bind(sessionStore))(sid);\n\t\t\t\t\t\t\tif (!session) {\n\t\t\t\t\t\t\t\tthrow 'Missing session.';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (Object.keys(players).includes(session.user)) {\n\t\t\t\t\t\t\t\tconnection.drop(pengu.USERNAME_ALREADY_BEING_USED, 'Username already being used');\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet name = connection.name = session.user;\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'sync', name: name, data: players}));\n\t\t\t\t\t\t\tif (!Object.keys(registered).includes(name)) {\n\t\t\t\t\t\t\t\tregistered[name] = {clothing: [], closet: {}, registered: (new Date()).toUTCString(), group: json.group};\n\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait pgpool.query('insert into \"penguin\"(\"name\", \"closet\", \"clothing\", \"registered\", \"group\") VALUES($1, $2, $3, $4, $5)', [name, JSON.stringify(registered[name].closet), JSON.stringify(registered[name].clothing), registered[name].registered, registered[name].group]);\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tplayers[name] = registered[name];\n\t\t\t\t\t\t\tplayers[name].x = 550;\n\t\t\t\t\t\t\tplayers[name].y = 500;\n\t\t\t\t\t\t\tplayers[name].room = 'plaza';\n\n\t\t\t\t\t\t\tconsole.info('Initial handshake with ' + name);\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'enter', name: name, room: players[name].room, x: players[name].x, y: players[name].y, clothing: players[name].clothing}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'syncCloset', closet: players[name].closet}));\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconnection.drop(pengu.SESSION_READ_ERROR, 'Problems reading session');\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'move') {\n\t\t\t\t\t\tlet newRoom = null;\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tlet currentRoom = players[name].room;\n\t\t\t\t\t\tlet target = mapUtils.getTarget(rooms[currentRoom], new Line(new Point(players[name].x, players[name].y), new Point(json.x, json.y)));\n\t\t\t\t\t\tif (rooms[currentRoom].zones[0].area.containsPoint(target)) {\n\t\t\t\t\t\t\tconsole.log('Moving ' + name + ' to ' + target);\n\t\t\t\t\t\t\tplayers[name].x = target.x;\n\t\t\t\t\t\t\tplayers[name].y = target.y;\n\t\t\t\t\t\t\tfor (let zone of rooms[currentRoom].zones) {\n\t\t\t\t\t\t\t\tif (zone.type[0] === 'door' && zone.area.containsPoint(target)) {\n\t\t\t\t\t\t\t\t\tnewRoom = zone.type[1];\n\t\t\t\t\t\t\t\t\tconsole.log(name + ' goes to ' + newRoom);\n\t\t\t\t\t\t\t\t\tplayers[name].room = newRoom;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet msg = {type: 'move', name: name, x: players[name].x, y: players[name].y};\n\t\t\t\t\t\t\tif (newRoom) {\n\t\t\t\t\t\t\t\tmsg.travel = newRoom;\n\t\t\t\t\t\t\t\tplayers[name].x = msg.newX = rooms[newRoom].spawn.x;\n\t\t\t\t\t\t\t\tplayers[name].y = msg.newY = rooms[newRoom].spawn.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify(msg));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'message') {\n\t\t\t\t\t\tjson.text = json.text.trim();\n\t\t\t\t\t\tif (json.text !== '') {\n\t\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\t\tif (json.text.startsWith('/')) {\n\t\t\t\t\t\t\t\tif (json.text.startsWith('/mute ') && ['admin', 'moderator'].includes(players[name].group)) {\n\t\t\t\t\t\t\t\t\tlet bannedName = json.text.substr(6);\n\t\t\t\t\t\t\t\t\tplayers[bannedName].banned = true;\n\t\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"banned\"=true where \"name\"=$1', [bannedName]);\n\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (json.text.startsWith('/unmute ') && ['admin', 'moderator'].includes(players[name].group)) {\n\t\t\t\t\t\t\t\t\tlet bannedName = json.text.substr(8);\n\t\t\t\t\t\t\t\t\tplayers[bannedName].banned = false;\n\t\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"banned\"=false where \"name\"=$1', [bannedName]);\n\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!players[name].banned) {\n\t\t\t\t\t\t\t\t\tconsole.log(name + ' said ' + json.text);\n\t\t\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'say', name: name, text: json.text}));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'say', name: name, text: json.text}));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'addItem') {\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tjson.itemId = parseInt(json.itemId);\n\t\t\t\t\t\tif (!findById(items, json.itemId)?.available) {\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'error', message: 'Tato v\u011bc nejde v\u00a0sou\u010dasnosti z\u00edskat.'}));\n\t\t\t\t\t\t\tconsole.log(name + ' attempted to acquire ' + json.itemId);\n\t\t\t\t\t\t} else if (!Object.keys(players[name].closet).includes(`${json.itemId}`)) {\n\t\t\t\t\t\t\tplayers[name].closet[json.itemId] = {'date': new Date(), 'means': 'collect'};\n\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"closet\"=$2 where \"name\"=$1', [name, JSON.stringify(players[name].closet)]);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'syncCloset', closet: players[name].closet}));\n\t\t\t\t\t\t\tconsole.log(name + ' acquired ' + json.itemId);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'error', message: 'Tuto v\u011bc ji\u017e m\u00e1\u0161.'}));\n\t\t\t\t\t\t\tconsole.log(name + ' attempted to reacquire ' + json.itemId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'dress') {\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tjson.itemId = parseInt(json.itemId);\n\t\t\t\t\t\tif (Object.keys(players[name].closet).includes(`${json.itemId}`)) {\n\t\t\t\t\t\t\tif (players[name].clothing.includes(json.itemId)) {\n\t\t\t\t\t\t\t\tplayers[name].clothing = players[name].clothing.filter(item => item !== json.itemId);\n\t\t\t\t\t\t\t\tconsole.log(name + ' undressed ' + json.itemId);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tplayers[name].clothing.push(json.itemId);\n\t\t\t\t\t\t\t\tconsole.log(name + ' dressed ' + json.itemId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"clothing\"=$2 where \"name\"=$1', [name, JSON.stringify(players[name].clothing)]);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'dress', name: name, clothing: players[name].clothing}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tconsole.error(ex);\n\t\t\t\t}\n\t\t\t\t// connection.sendUTF(message.utf8Data);\n\t\t\t}\n\t\t});\n\t\tconnection.on('close', function(reasonCode, description) {\n\t\t\t// remove the connection from the pool\n\t\t\tclients = clients.filter((client) => client !== connection);\n\t\t\tregistered[connection.name] = players[connection.name];\n\t\t\tdelete players[connection.name];\n\t\t\tconsole.log((new Date()) + ' Peer ' + connection.remoteAddress + '(' + connection.name + ') disconnected.' + (description ? ' Reason: ' + description : ''));\n\t\t\tfor (let client of clients) {\n\t\t\t\tclient.sendUTF(JSON.stringify({type: 'exit', name: connection.name}));\n\t\t\t}\n\t\t});\n\t});\n\n\tfunction exitHandler() {\n\t\tconsole.log('Server is going down');\n\t\tfor (let client of clients) {\n\t\t\tclient.drop(pengu.SERVER_GOING_DOWN, 'Server is going down');\n\t\t}\n\t\tprocess.exit();\n\t}\n\n\tprocess.on('SIGINT', exitHandler);\n}\n\nrunApp();\n"], "fixing_code": ["# pengu\n\n**pengu** is lightweight web chat built with HTML 5 resembling Club Penguin.\n\n## Prerequisites\n\nThe project uses npm to install dependencies and Node.js to run. Download them by running [Nix](https://nixos.org/download.html)\u2019s `nix-shell` command, using your system\u2019s package manager or from [their website](https://nodejs.org/en/).\n\nOptionally, you will also need [PostgreSQL](https://www.postgresql.org/) database server if you want Pengu to remember player inventories across restarts.\n\n## Installation\n\n1. Create the following table in PostgreSQL database and set `DATABASE_URL` to correct connection string.\n\n```\nCREATE TABLE \"penguin\" (\n\t\"name\" character varying NOT NULL PRIMARY KEY,\n\t\"closet\" json DEFAULT '{}' NOT NULL,\n\t\"clothing\" json DEFAULT '[]' NOT NULL,\n\t\"registered\" timestamptz DEFAULT current_timestamp NOT NULL,\n\t\"banned\" boolean DEFAULT false NOT NULL,\n\t\"group\" character varying DEFAULT 'basic' NOT NULL\n);\n```\n\n2. Run `npm install`.\n3. Compile assets using `npm run build`.\n4. Start with `npm start`, the game will run on port set by `PORT` env variable.\n\n## Configuration\n\npengu uses the following environment variables for configuration:\n\n* `PORT` \u2013 The port a web server will be running on. Of not specified it defaults to `8080`.\n* `DATABASE_URL` \u2013 [Connection string](https://node-postgres.com/features/connecting/#connection-uri) for the PostgreSQL database. If omitted, persistence will be missing.\n* `NODE_ENV` \u2013 Can be set to `production` for less verbose logs. Defaults to `development`.\n* `OPENID_PROVIDER` \u2013 If this is set, pengu will use OpenID to log-in. Though it only supports using a hardcoded identity specified by this variable. User will be redirected to the provider, where they will confirm their credentials, and then be redirected back to Pengu with an access code. Pengu will then verify the access code against the OpenID verification URL and realm specified by `OPENID_VERIFY`, `OPENID_REALM` environment variables.\n* `ACCEPTED_ORIGINS` \u2013 comma-separated list of domain names that are allowed to access the WebSockets server. This is necessary to prevent [cross-site request forgery](https://en.wikipedia.org/wiki/WebSocket#Security_considerations). When the environment variable is not set, only `localhost` and `127.0.0.1` will be allowed to connect.\n\n## Development\n\nThe front-end of Pengu is stored in the `assets/` directory and needs to be rebuilt when it is changed. You can use `npm run build` command to do that, or `npm run dev` if you want it to rebuild automatically on changes. Its build artefacts end up in the `client/` directory, from where the server will serve them.\n\n## License\n\npengu source code is made available under MIT license.\n", "#!/usr/bin/env node\n'use strict';\n\nprocess.title = 'pengu';\n\nconst { server: WebSocketServer } = require('websocket');\nconst http = require('http');\nconst path = require('path');\nconst express = require('express');\nconst pg = require('pg');\nconst poly = require('./poly');\nconst { Line, Point } = poly;\nconst pengu = require('./pengu');\nconst mapUtils = require('./mapUtils');\nconst { promisify } = require('es6-promisify');\nconst session = require('express-session');\nconst { signedCookie } = require('cookie-parser');\nconst morgan = require('morgan');\nconst serveStatic = require('serve-static');\nconst fs = require('fs');\n\nfunction findById(arr, id) {\n\tfor (let item of arr) {\n\t\tif (item.id === id) {\n\t\t\treturn item;\n\t\t}\n\t}\n\treturn null;\n}\n\nconst acceptedOrigins = process.env.ACCEPTED_ORIGINS ? process.env.ACCEPTED_ORIGINS.split(',') : ['localhost', '127.0.0.1'];\n\nasync function runApp() {\n\tlet app = express();\n\n\tapp.set('port', process.env.PORT ?? 8080);\n\n\tlet sessionStore = new session.MemoryStore();\n\tlet secret = Math.random().toString();\n\tapp.use(session({store: sessionStore, resave: true, saveUninitialized: true, secret: secret, cookie: { maxAge: 10000 }, key: 'sid'}));\n\n\tlet env = process.env.NODE_ENV ?? 'development';\n\tif (env === 'development') {\n\t\tapp.use(morgan('combined'));\n\t}\n\n\tapp.get('/', function(req, res) {\n\t\tif (!req.session.user) {\n\t\t\tres.redirect('/authenticate');\n\t\t} else {\n\t\t\tres.statusCode = 200;\n\t\t\tres.sendFile(path.join(__dirname, '../client/index.html'));\n\t\t}\n\t});\n\n\tapp.use('/content', serveStatic(path.join(__dirname, '../content')));\n\tapp.use('/', serveStatic(path.join(__dirname, '../client')));\n\n\tif (process.env.OPENID_PROVIDER) {\n\t\trequire('./auth/openid')(app, process.env.OPENID_VERIFY, process.env.OPENID_REALM, process.env.OPENID_PROVIDER);\n\t} else {\n\t\trequire('./auth/simple')(app);\n\t}\n\n\tlet server = http.createServer(app).listen(app.get('port'));\n\tconsole.log('Started app on port %d', app.get('port'));\n\n\tlet wsServer = new WebSocketServer({\n\t\thttpServer: server,\n\t\tautoAcceptConnections: false\n\t});\n\n\tfunction originIsAllowed(origin) {\n\t\tconst url = new URL(origin);\n\t\treturn acceptedOrigins.includes(url.hostname);\n\t}\n\n\tlet clients = [];\n\tlet players = {};\n\tlet rooms = JSON.parse(fs.readFileSync(path.join(__dirname, '../content/world/map.json'), 'utf8'), function (key, value) {\n\t\tlet type;\n\t\tif (value && typeof value === 'object') {\n\t\t\ttype = value._class;\n\t\t\tif (typeof type === 'string' && typeof poly[type] === 'function') {\n\t\t\t\treturn new (poly[type])(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n\tlet items = JSON.parse(fs.readFileSync(path.join(__dirname, '../content/items/items.json'), 'utf8'));\n\n\tlet _dbUri = process.env.DATABASE_URL;\n\tlet dbEnabled = _dbUri !== null;\n\tlet pgpool = null;\n\tlet registered = {};\n\tif (dbEnabled) {\n\t\tpgpool = new pg.Pool({connectionString: _dbUri});\n\t\tlet result = await pgpool.query('select * from \"penguin\"');\n\t\tfor (let row of result.rows) {\n\t\t\tregistered[row.name] = row;\n\t\t}\n\t}\n\n\twsServer.on('request', function(request) {\n\t\tif (!originIsAllowed(request.origin)) {\n\t\t\trequest.reject();\n\t\t\tconsole.log((new Date()) + ' Connection from origin ' + request.origin + ' rejected.');\n\t\t\treturn;\n\t\t}\n\n\t\tlet connection = request.accept(null, request.origin);\n\t\tclients.push(connection);\n\t\tconsole.log((new Date()) + ' Connection accepted.');\n\t\tconnection.on('message', async function(message) {\n\t\t\tif (message.type === 'utf8') {\n\t\t\t\ttry {\n\t\t\t\t\tlet json = JSON.parse(message.utf8Data);\n\t\t\t\t\tconsole.log(json);\n\t\t\t\t\tif (json.type === 'init' && connection.name === undefined) {\n\t\t\t\t\t\tlet sid = signedCookie(request.cookies.filter((x) => x.name == 'sid')[0].value, secret);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet session = await promisify(sessionStore.get.bind(sessionStore))(sid);\n\t\t\t\t\t\t\tif (!session) {\n\t\t\t\t\t\t\t\tthrow 'Missing session.';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (Object.keys(players).includes(session.user)) {\n\t\t\t\t\t\t\t\tconnection.drop(pengu.USERNAME_ALREADY_BEING_USED, 'Username already being used');\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet name = connection.name = session.user;\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'sync', name: name, data: players}));\n\t\t\t\t\t\t\tif (!Object.keys(registered).includes(name)) {\n\t\t\t\t\t\t\t\tregistered[name] = {clothing: [], closet: {}, registered: (new Date()).toUTCString(), group: json.group};\n\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait pgpool.query('insert into \"penguin\"(\"name\", \"closet\", \"clothing\", \"registered\", \"group\") VALUES($1, $2, $3, $4, $5)', [name, JSON.stringify(registered[name].closet), JSON.stringify(registered[name].clothing), registered[name].registered, registered[name].group]);\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tplayers[name] = registered[name];\n\t\t\t\t\t\t\tplayers[name].x = 550;\n\t\t\t\t\t\t\tplayers[name].y = 500;\n\t\t\t\t\t\t\tplayers[name].room = 'plaza';\n\n\t\t\t\t\t\t\tconsole.info('Initial handshake with ' + name);\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'enter', name: name, room: players[name].room, x: players[name].x, y: players[name].y, clothing: players[name].clothing}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'syncCloset', closet: players[name].closet}));\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconnection.drop(pengu.SESSION_READ_ERROR, 'Problems reading session');\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'move') {\n\t\t\t\t\t\tlet newRoom = null;\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tlet currentRoom = players[name].room;\n\t\t\t\t\t\tlet target = mapUtils.getTarget(rooms[currentRoom], new Line(new Point(players[name].x, players[name].y), new Point(json.x, json.y)));\n\t\t\t\t\t\tif (rooms[currentRoom].zones[0].area.containsPoint(target)) {\n\t\t\t\t\t\t\tconsole.log('Moving ' + name + ' to ' + target);\n\t\t\t\t\t\t\tplayers[name].x = target.x;\n\t\t\t\t\t\t\tplayers[name].y = target.y;\n\t\t\t\t\t\t\tfor (let zone of rooms[currentRoom].zones) {\n\t\t\t\t\t\t\t\tif (zone.type[0] === 'door' && zone.area.containsPoint(target)) {\n\t\t\t\t\t\t\t\t\tnewRoom = zone.type[1];\n\t\t\t\t\t\t\t\t\tconsole.log(name + ' goes to ' + newRoom);\n\t\t\t\t\t\t\t\t\tplayers[name].room = newRoom;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet msg = {type: 'move', name: name, x: players[name].x, y: players[name].y};\n\t\t\t\t\t\t\tif (newRoom) {\n\t\t\t\t\t\t\t\tmsg.travel = newRoom;\n\t\t\t\t\t\t\t\tplayers[name].x = msg.newX = rooms[newRoom].spawn.x;\n\t\t\t\t\t\t\t\tplayers[name].y = msg.newY = rooms[newRoom].spawn.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify(msg));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'message') {\n\t\t\t\t\t\tjson.text = json.text.trim();\n\t\t\t\t\t\tif (json.text !== '') {\n\t\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\t\tif (json.text.startsWith('/')) {\n\t\t\t\t\t\t\t\tif (json.text.startsWith('/mute ') && ['admin', 'moderator'].includes(players[name].group)) {\n\t\t\t\t\t\t\t\t\tlet bannedName = json.text.substr(6);\n\t\t\t\t\t\t\t\t\tplayers[bannedName].banned = true;\n\t\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"banned\"=true where \"name\"=$1', [bannedName]);\n\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (json.text.startsWith('/unmute ') && ['admin', 'moderator'].includes(players[name].group)) {\n\t\t\t\t\t\t\t\t\tlet bannedName = json.text.substr(8);\n\t\t\t\t\t\t\t\t\tplayers[bannedName].banned = false;\n\t\t\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"banned\"=false where \"name\"=$1', [bannedName]);\n\t\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!players[name].banned) {\n\t\t\t\t\t\t\t\t\tconsole.log(name + ' said ' + json.text);\n\t\t\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'say', name: name, text: json.text}));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'say', name: name, text: json.text}));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'addItem') {\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tjson.itemId = parseInt(json.itemId);\n\t\t\t\t\t\tif (!findById(items, json.itemId)?.available) {\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'error', message: 'Tato v\u011bc nejde v\u00a0sou\u010dasnosti z\u00edskat.'}));\n\t\t\t\t\t\t\tconsole.log(name + ' attempted to acquire ' + json.itemId);\n\t\t\t\t\t\t} else if (!Object.keys(players[name].closet).includes(`${json.itemId}`)) {\n\t\t\t\t\t\t\tplayers[name].closet[json.itemId] = {'date': new Date(), 'means': 'collect'};\n\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"closet\"=$2 where \"name\"=$1', [name, JSON.stringify(players[name].closet)]);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'syncCloset', closet: players[name].closet}));\n\t\t\t\t\t\t\tconsole.log(name + ' acquired ' + json.itemId);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconnection.sendUTF(JSON.stringify({type: 'error', message: 'Tuto v\u011bc ji\u017e m\u00e1\u0161.'}));\n\t\t\t\t\t\t\tconsole.log(name + ' attempted to reacquire ' + json.itemId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (json.type === 'dress') {\n\t\t\t\t\t\tlet name = connection.name;\n\t\t\t\t\t\tjson.itemId = parseInt(json.itemId);\n\t\t\t\t\t\tif (Object.keys(players[name].closet).includes(`${json.itemId}`)) {\n\t\t\t\t\t\t\tif (players[name].clothing.includes(json.itemId)) {\n\t\t\t\t\t\t\t\tplayers[name].clothing = players[name].clothing.filter(item => item !== json.itemId);\n\t\t\t\t\t\t\t\tconsole.log(name + ' undressed ' + json.itemId);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tplayers[name].clothing.push(json.itemId);\n\t\t\t\t\t\t\t\tconsole.log(name + ' dressed ' + json.itemId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dbEnabled) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait pgpool.query('update \"penguin\" set \"clothing\"=$2 where \"name\"=$1', [name, JSON.stringify(players[name].clothing)]);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let client of clients) {\n\t\t\t\t\t\t\t\tclient.sendUTF(JSON.stringify({type: 'dress', name: name, clothing: players[name].clothing}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tconsole.error(ex);\n\t\t\t\t}\n\t\t\t\t// connection.sendUTF(message.utf8Data);\n\t\t\t}\n\t\t});\n\t\tconnection.on('close', function(reasonCode, description) {\n\t\t\t// remove the connection from the pool\n\t\t\tclients = clients.filter((client) => client !== connection);\n\t\t\tregistered[connection.name] = players[connection.name];\n\t\t\tdelete players[connection.name];\n\t\t\tconsole.log((new Date()) + ' Peer ' + connection.remoteAddress + '(' + connection.name + ') disconnected.' + (description ? ' Reason: ' + description : ''));\n\t\t\tfor (let client of clients) {\n\t\t\t\tclient.sendUTF(JSON.stringify({type: 'exit', name: connection.name}));\n\t\t\t}\n\t\t});\n\t});\n\n\tfunction exitHandler() {\n\t\tconsole.log('Server is going down');\n\t\tfor (let client of clients) {\n\t\t\tclient.drop(pengu.SERVER_GOING_DOWN, 'Server is going down');\n\t\t}\n\t\tprocess.exit();\n\t}\n\n\tprocess.on('SIGINT', exitHandler);\n}\n\nrunApp();\n"], "filenames": ["README.md", "src/index.js"], "buggy_code_start_loc": [37, 30], "buggy_code_end_loc": [37, 73], "fixing_code_start_loc": [38, 31], "fixing_code_end_loc": [39, 76], "type": "CWE-352", "message": "A vulnerability was found in Pengu. It has been declared as problematic. Affected by this vulnerability is the function runApp of the file src/index.js. The manipulation leads to cross-site request forgery. The attack can be launched remotely. The name of the patch is aea66f12b8cdfc3c8c50ad6a9c89d8307e9d0a91. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216475.", "other": {"cve": {"id": "CVE-2020-36623", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-21T19:15:12.227", "lastModified": "2022-12-28T18:46:11.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Pengu. It has been declared as problematic. Affected by this vulnerability is the function runApp of the file src/index.js. The manipulation leads to cross-site request forgery. The attack can be launched remotely. The name of the patch is aea66f12b8cdfc3c8c50ad6a9c89d8307e9d0a91. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216475."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}, {"lang": "en", "value": "CWE-862"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pengu_project:pengu:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-11-02", "matchCriteriaId": "69657BC6-E5C0-4D73-A890-093ACB51853E"}]}]}], "references": [{"url": "https://github.com/jtojnar/pengu/commit/aea66f12b8cdfc3c8c50ad6a9c89d8307e9d0a91", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216475", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/jtojnar/pengu/commit/aea66f12b8cdfc3c8c50ad6a9c89d8307e9d0a91"}}