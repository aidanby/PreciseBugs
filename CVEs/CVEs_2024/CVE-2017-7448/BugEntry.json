{"buggy_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n#include <atomic>\n#include <functional>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n#include <thread>\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n#include \"base_coders.hh\"\n#include \"component_info.hh\"\n#include \"../vp8/model/color_context.hh\"\n#include \"../vp8/util/block_based_image.hh\"\nstruct componentInfo;\n\nclass Block;\n\n\n\nclass UncompressedComponents {\n    typedef int CounterType;\n    class ExtendedComponentInfo {\n        ExtendedComponentInfo(const ExtendedComponentInfo&); // not implemented\n        ExtendedComponentInfo operator=(const ExtendedComponentInfo&); // not implemented\n    public:\n        BlockBasedImage component_;\n        CounterType dpos_block_progress_;\n        componentInfo info_;\n        int trunc_bcv_; // the number of vertical components in this (truncated) image\n        int trunc_bc_;\n        ExtendedComponentInfo() :dpos_block_progress_(0),\n                                 trunc_bcv_(0), trunc_bc_(0) {\n        }\n    };\n    int cmpc_; // the number of components\n    int mcuh_;\n    int mcuv_;\n\ttypedef Sirikata::Array1d<ExtendedComponentInfo, 4> ExtendedInfo;\n    ExtendedInfo header_;\n\t\n    CounterType coefficient_position_progress_;\n    CounterType bit_progress_;\n    CounterType worker_start_read_signal_;\n    int reserved_; // don't want to change memory layout\n    BaseDecoder *decoder_;\n    UncompressedComponents(const UncompressedComponents&);// not implemented\n    UncompressedComponents&operator=(const UncompressedComponents&);// not implemented\n    int bch_(int component) const {\n        return header_[component].info_.bch;\n    }\n    int bcv_(int component) const {\n        return header_[component].trunc_bcv_;\n    }\npublic:\n    UncompressedComponents() : coefficient_position_progress_(0), bit_progress_(0), worker_start_read_signal_(0) {\n        decoder_ = NULL;\n        reserved_ = 0;\n        mcuh_ = 0;\n        mcuv_ = 0;\n        cmpc_ = 0;\n    }\n    unsigned short *get_quantization_tables(BlockType component) const {\n        return header_[(int)component].info_.qtable;\n    }\n    Sirikata::Array1d<uint32_t, (size_t)ColorChannel::NumBlockTypes> get_max_coded_heights() const{\n        Sirikata::Array1d<uint32_t, (size_t)ColorChannel::NumBlockTypes> retval;\n        retval.memset(0);\n        for (int i = 0; i < cmpc_ && i < (int)ColorChannel::NumBlockTypes; ++i) {\n            retval[i] = header_[i].trunc_bcv_;\n        }\n        return retval;\n    }\n    int get_mcu_count_vertical() const{\n        return mcuv_;\n    }\n    int get_mcu_count_horizontal() const{\n        return mcuh_;\n    }\n    bool is_memory_optimized(int cmp) const {\n        return header_[cmp].component_.is_memory_optimized();\n    }\n    int get_num_components() const{\n        return cmpc_;\n    }\n\n    void worker_update_bit_progress(int add_bit_progress) {\n        bit_progress_ += add_bit_progress;\n    }\n    void worker_update_coefficient_position_progress(int add_coefficient_position_progress) {\n        coefficient_position_progress_ += add_coefficient_position_progress;\n    }\n    void worker_update_cmp_progress(BlockType cmp, int add_bit_progress) {\n        header_[(int)cmp].dpos_block_progress_ += add_bit_progress;\n    }\n    void worker_mark_cmp_finished(BlockType cmp) {\n        CounterType dpos_block_progress_ = header_[(int)cmp].trunc_bc_;\n        header_[(int)cmp].dpos_block_progress_ = dpos_block_progress_;\n    }\n    void start_decoder(BaseDecoder *decoder) {\n        decoder_ = decoder;\n    }\n    CodingReturnValue do_more_work() {\n        return decoder_->decode_chunk(this);\n    }\n    template<bool force_memory_optimized>\n    void allocate_channel_framebuffer(int desired_cmp,\n                                      BlockBasedImageBase<force_memory_optimized> *framebuffer,\n                                      bool memory_optimized=force_memory_optimized) const {\n        uint64_t total_req_blocks = 0;\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            total_req_blocks += header_[cmp].info_.bcv * header_[cmp].info_.bch;\n        }\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            int bc_allocated = header_[cmp].info_.bc;\n            int64_t max_cmp_bc = max_number_of_blocks;\n            max_cmp_bc *= header_[cmp].info_.bcv;\n            max_cmp_bc *= header_[cmp].info_.bch;\n            max_cmp_bc /= total_req_blocks;\n            if (bc_allocated > max_cmp_bc) {\n                bc_allocated = max_cmp_bc - (max_cmp_bc % header_[cmp].info_.bch);\n            }\n            if (cmp == desired_cmp) {\n                framebuffer->init(header_[cmp].info_.bch,\n                                  header_[cmp].info_.bcv,\n                                  bc_allocated,\n                                  memory_optimized);\n                break;\n            }\n        }\n    }\n    void init(Sirikata::Array1d<componentInfo, ExtendedInfo::size0> cmpinfo, int cmpc,\n              int mcuh, int mcuv, bool memory_optimized_image) {\n        mcuh_ = mcuh;\n        mcuv_ = mcuv;\n        if (cmpc > (int)ColorChannel::NumBlockTypes) {\n            cmpc = (int)ColorChannel::NumBlockTypes;\n            //abort here: we probably can't support this kind of image\n            const char * errmsg = \"We only support 3 color channels or fewer\\n\";\n            int err = write(2, errmsg, strlen(errmsg));\n            (void)err;\n            dev_assert(cmpc <= (int)ColorChannel::NumBlockTypes && \"We only support 3 color channels or less\");\n            custom_exit(ExitCode::UNSUPPORTED_4_COLORS);\n        }\n        cmpc_ = cmpc;\n        for (int cmp = 0; cmp < cmpc; cmp++) {\n            header_[cmp].info_ = cmpinfo[cmp];\n            header_[cmp].trunc_bcv_ = cmpinfo[cmp].bcv;\n            header_[cmp].trunc_bc_ = cmpinfo[cmp].bc;\n        }\n        if (!memory_optimized_image) {\n            for (int cmp = 0; cmp < (int)sizeof(header_)/(int)sizeof(header_[0]) && cmp < cmpc; cmp++) {\n                allocate_channel_framebuffer(cmp,\n                                             &this->header_[cmp].component_,\n                                             memory_optimized_image);\n            }\n        }\n    }\n    void set_block_count_dpos(ExtendedComponentInfo *ci, int trunc_bc) {\n        always_assert(ci->info_.bcv == ci->info_.bc / ci->info_.bch + (ci->info_.bc % ci->info_.bch ?  1 : 0));\n        int vertical_scanlines = std::min(trunc_bc / ci->info_.bch + (trunc_bc % ci->info_.bch ? 1 : 0), ci->info_.bcv);\n        int ratio = min_vertical_extcmp_multiple(ci);\n        while (vertical_scanlines % ratio != 0\n            && vertical_scanlines + 1 <= ci->info_.bcv) {\n            ++vertical_scanlines;\n        }\n        always_assert(vertical_scanlines <= ci->info_.bcv);\n        ci->trunc_bcv_ = vertical_scanlines;\n        ci->trunc_bc_ = trunc_bc;\n    }\n    void set_truncation_bounds(int /*max_cmp*/, int /*max_bpos*/,\n                               int max_dpos[sizeof(header_)/sizeof(header_[0])], int /*max_sah*/) {\n        for (int i = 0; i < cmpc_; ++i) {\n            set_block_count_dpos(&header_[i], max_dpos[i] + 1);\n        }\n    }\n    void wait_for_worker_on_bit(int bit) {\n        while (bit >= (bit_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n            //fprintf(stderr, \"Waiting for bit %d > %d\\n\", bit, bit_progress_ += 0);\n        }\n    }\n    void wait_for_worker_on_bpos(int bpos) {\n        while (bpos >= (coefficient_position_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n            //fprintf(stderr, \"Waiting for coefficient_position %d > %d\\n\", bpos, coefficient_position_progress_ += 0);\n        }\n    }\n    void wait_for_worker_on_dpos(int cmp, int dpos) {\n        dpos = std::min(dpos, header_[cmp].trunc_bc_ - 1);\n        while (dpos >= (header_[cmp].dpos_block_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n        }\n    }\n    void signal_worker_should_begin() {\n        //std::atomic_thread_fence(std::memory_order_release);\n         worker_start_read_signal_++;\n    }\n    unsigned int component_size_allocated(int cmp) const {\n        return header_[cmp].component_.bytes_allocated();\n    }\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes>\n        get_component_size_in_blocks() const {\n        Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> retval;\n        retval.memset(0);\n        for (int cmp = 0; cmp < cmpc_; ++cmp) {\n            retval[cmp] = header_[cmp].trunc_bc_;\n        }\n        return retval;\n    }\n    unsigned int component_size_in_blocks(int cmp) const {\n        return header_[cmp].trunc_bc_;\n    }\n    BlockBasedImage& full_component_write(BlockType cmp) {\n        return header_[(int)cmp].component_;\n    }\n    const BlockBasedImage& full_component_nosync(int cmp) const{\n        return header_[cmp].component_;\n\n    }\n    const AlignedBlock& block(BlockType cmp, int dpos) {\n        wait_for_worker_on_dpos((int)cmp, dpos);\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    const AlignedBlock& block_nosync(BlockType cmp, int dpos) const {\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    signed short at_nosync(BlockType cmp, int bpos, int dpos) const {\n        return header_[(int)cmp].component_.\n            raster(dpos).coefficients_zigzag(bpos);\n    }\n    // return the minimum luma multiple for full mcu splits in luma\n    int min_vertical_luma_multiple() const;\n    int min_vertical_cmp_multiple(int cmp) const;\n    int min_vertical_extcmp_multiple(const ExtendedComponentInfo *info) const;\n    int block_height( const int cmp ) const\n    {\n        return bcv_(cmp);\n    }\n\n    int block_width( const int cmp ) const\n    {\n        return bch_(cmp);\n    }\n    \n    int block_width( const BlockType cmp ) const\n    {\n        return bch_((int)cmp);\n    }\n    \n    void reset() {\n        bit_progress_ -= bit_progress_;\n    }\n    ~UncompressedComponents() {\n        reset();\n    }\n    static int max_number_of_blocks;\n\n\n    // the following functions are progressive-only functions (recode_jpeg)\n    // or decode-only functions (decode_jpeg, check_value_range)\n    // these are the only functions able to access the components\n    friend bool decode_jpeg(const std::vector<std::pair<uint32_t, uint32_t> >&huff_byte_offsets,\n                            std::vector<ThreadHandoff>*luma_row_offset_return);\n    friend bool recode_jpeg(void);\n    friend bool check_value_range(void);\nprivate:\n    AlignedBlock& mutable_block(BlockType cmp, int dpos) {\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    signed short at(BlockType cmp, int bpos, int dpos) {\n        wait_for_worker_on_dpos((int)cmp, dpos);\n        return header_[(int)cmp].component_.\n            raster(dpos).coefficients_zigzag(bpos);\n    }\n    signed short&set(BlockType cmp, int bpos, int dpos) {\n        return header_[(int)cmp].component_.\n            raster(dpos).mutable_coefficients_zigzag(bpos);\n    }\n\n};\n\n\n", "#ifndef MODEL_HH\n#define MODEL_HH\n\n#include <vector>\n#include <memory>\n\n#include \"../util/debug.hh\"\n#include \"../util/options.hh\"\n#include \"../util/nd_array.hh\"\n#include \"../../lepton/idct.hh\"\n#include \"numeric.hh\"\n#include \"branch.hh\"\n#include \"../util/aligned_block.hh\"\n#include \"../util/block_based_image.hh\"\n\n#ifndef USE_SCALAR\n#include <tmmintrin.h>\n#include \"../util/mm_mullo_epi32.hh\"\n#endif\n\nclass BoolEncoder;\nconstexpr bool advanced_dc_prediction = true;\nenum TableParams : unsigned int {\n    MAX_EXPONENT = 11,\n    BLOCK_TYPES = 2, // setting this to 3 gives us ~1% savings.. 2/3 from BLOCK_TYPES=2\n    NUM_NONZEROS_BINS = 10,\n    BSR_BEST_PRIOR_MAX = 11, // 1023 requires 11 bits to describe\n    band_divisor = 1,\n    COEF_BANDS = 64 / band_divisor,\n    ENTROPY_NODES = 15,\n    NUM_NONZEROS_EOB_PRIORS = 66,\n    ZERO_OR_EOB = 3,\n    RESIDUAL_NOISE_FLOOR = 7,\n    COEF_BITS = MAX_EXPONENT - 1, // the last item of the length is always 1\n};\nint get_sum_median_8(int16_t*data16i);\nvoid set_branch_range_identity(Branch *start, Branch* end);\n\ntemplate <class BranchArray> void set_branch_array_identity(BranchArray &branches) {\n    auto begin = branches.begin();\n    auto end = branches.end();\n    set_branch_range_identity(begin, end);\n    /*\n    for (;false&&begin != end; ++begin) {\n        begin->set_identity();\n    }*/\n}\nstruct Model\n{\n    typedef Sirikata::Array4d<Branch, BLOCK_TYPES, 26, 6, 32> NonzeroCounts7x7;\n    NonzeroCounts7x7 num_nonzeros_counts_7x7_;\n\n    typedef Sirikata::Array5d<Branch, BLOCK_TYPES, 8, 8, 3, 4> NonzeroCounts1x8;\n    NonzeroCounts1x8 num_nonzeros_counts_1x8_;\n    NonzeroCounts1x8 num_nonzeros_counts_8x1_;\n\n    typedef Sirikata::Array4d<Branch,\n                              BLOCK_TYPES,\n                              COEF_BANDS,\n                              (8 > NUM_NONZEROS_BINS?8:(unsigned int)NUM_NONZEROS_BINS),\n                              COEF_BITS> ResidualNoiseCounts;\n\n    ResidualNoiseCounts residual_noise_counts_;\n\n    typedef Sirikata::Array2d<Branch,\n                              NUMERIC_LENGTH_MAX,\n                              COEF_BITS> ResidualNoiseCountsDc;\n\n    ResidualNoiseCountsDc residual_noise_counts_dc_;\n\n    typedef Sirikata::Array4d<Branch,\n                              BLOCK_TYPES,\n                              (1<<(1 + RESIDUAL_NOISE_FLOOR)),\n                              1 + RESIDUAL_NOISE_FLOOR,\n                              1<<RESIDUAL_NOISE_FLOOR > ResidualThresholdCounts;\n\n    ResidualThresholdCounts residual_threshold_counts_;\n\n    typedef Sirikata::Array5d<Branch,\n                    BLOCK_TYPES,\n                    NUM_NONZEROS_BINS,\n                    15,\n                    NUMERIC_LENGTH_MAX,\n                    MAX_EXPONENT> ExponentCounts8;\n\n    typedef Sirikata::Array5d<Branch,\n                              BLOCK_TYPES,\n                              NUM_NONZEROS_BINS,\n                              49,\n                              NUMERIC_LENGTH_MAX,\n                              MAX_EXPONENT> ExponentCounts7x7;\n\ntypedef Sirikata::Array3d<Branch,\n                          ((unsigned int)NUM_NONZEROS_BINS <= (unsigned int)NUMERIC_LENGTH_MAX\n                           ? (unsigned int)NUMERIC_LENGTH_MAX : (unsigned int)NUM_NONZEROS_BINS),\n                          17/*any 16 bit number should fit*/,\n                          MAX_EXPONENT> ExponentCountsDC;\n\n  ExponentCounts7x7 exponent_counts_;\n  ExponentCounts8 exponent_counts_x_;\n  ExponentCountsDC exponent_counts_dc_;\n  void set_tables_identity() {\n      set_branch_array_identity(num_nonzeros_counts_7x7_);\n      set_branch_array_identity(num_nonzeros_counts_1x8_);\n      set_branch_array_identity(num_nonzeros_counts_8x1_);\n      set_branch_array_identity(residual_noise_counts_);\n      set_branch_array_identity(residual_noise_counts_dc_);\n      set_branch_array_identity(residual_threshold_counts_);\n      set_branch_array_identity(exponent_counts_);\n      set_branch_array_identity(exponent_counts_x_);\n      set_branch_array_identity(exponent_counts_dc_);\n      set_branch_array_identity(sign_counts_);\n  }\n  typedef Sirikata::Array3d<Branch, BLOCK_TYPES, 4, NUMERIC_LENGTH_MAX> SignCounts;\n  SignCounts sign_counts_;\n  \n  template <typename lambda>\n  void forall( const lambda & proc )\n  {\n      num_nonzeros_counts_7x7_.foreach(proc);\n      num_nonzeros_counts_1x8_.foreach(proc);\n      num_nonzeros_counts_8x1_.foreach(proc);\n      exponent_counts_x_.foreach(proc);\n      exponent_counts_.foreach(proc);\n      exponent_counts_dc_.foreach(proc);\n\n      residual_noise_counts_.foreach(proc);\n      residual_threshold_counts_.foreach(proc);\n      sign_counts_.foreach(proc);\n  }\n    enum Printability{\n        PRINTABLE_INSIGNIFICANT = 1,\n        PRINTABLE_OK = 2,\n        CLOSE_TO_50 = 4,\n        CLOSE_TO_ONE_ANOTHER = 8\n    };\n    struct PrintabilitySpecification {\n        uint64_t printability_bitmask;\n        double tolerance;\n        uint64_t min_samples;\n    };\n    const Model& debug_print(const Model* other, PrintabilitySpecification spec)const;\n\n};\n\nenum ContextTypes{\n    ZDSTSCAN,\n    ZEROS7x7,\n    EXPDC,\n    RESDC,\n    SIGNDC,\n    EXP7x7,\n    RES7x7,\n    SIGN7x7,\n    ZEROS1x8,\n    ZEROS8x1,\n    EXP8,\n    THRESH8,\n    RES8,\n    SIGN8,\n    NUMCONTEXT\n};\n#if 0\nstruct Context {\n    enum {\n        H = 2448,\n        W = 3264\n    };\n    int cur_cmp;\n    int cur_jpeg_x;\n    int cur_jpeg_y;\n    ContextTypes annot;\n    int p[3][H/8][W/8][8][8][NUMCONTEXT][3];\n};\nextern Context *gctx;\n#define ANNOTATION_ENABLED\n#define ANNOTATE_CTX(bpos,annot_type,ctxnum,value) \\\n    (gctx->annot = annot_type, \\\n     gctx->p[gctx->cur_cmp][gctx->cur_jpeg_y][gctx->cur_jpeg_x][bpos/8][bpos%8][annot_type][ctxnum] = value)\n#else\n#define ANNOTATE_CTX(bpos, annot_type, ctxnum, value)\n#endif\n\nclass Slice;\nvoid optimize_model(Model&model);\nvoid serialize_model(const Model & model, int output_fd);\nvoid reset_model(Model &model);\nvoid normalize_model(Model &model);\nvoid load_model(Model &model, const char* filename);\n#ifdef _WIN32\n#define WINALIGN16 __declspec(align(16))\n#define UNIXALIGN16\n#else\n#define WINALIGN16\n#define UNIXALIGN16 __attribute__((aligned(16)))\n#endif\nclass ProbabilityTablesBase {\nprotected:\n    Model model_;\n\n    static WINALIGN16 int32_t icos_idct_edge_8192_dequantized_x_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n    \n    static WINALIGN16 int32_t icos_idct_edge_8192_dequantized_y_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n    \n    static WINALIGN16 int32_t icos_idct_linear_8192_dequantized_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint16_t quantization_table_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint16_t freqmax_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint8_t bitlen_freqmax_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint8_t min_noise_threshold_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\npublic:\n    Model &model() {return model_;}\n    void load_probability_tables();\n    static uint16_t* quantization_table(uint8_t color) {\n        return quantization_table_[color];\n    }\n\n    static uint16_t quantization_table(uint8_t color, uint8_t coef) {\n        return quantization_table_[color][coef];\n    }\n    static uint16_t freqmax(uint8_t color, uint8_t coef) {\n        return freqmax_[color][coef];\n    }\n    static uint8_t bitlen_freqmax(uint8_t color, uint8_t coef) {\n        return bitlen_freqmax_[color][coef];\n    }\n    static uint8_t min_noise_threshold(uint8_t color, uint8_t coef) {\n        return min_noise_threshold_[color][coef];\n    }\n    static void set_quantization_table(BlockType color, const unsigned short quantization_table[64]) {\n        for (int i = 0; i < 64; ++i) {\n            quantization_table_[(int)color][i] = quantization_table[zigzag[i]];\n        }\n        for (int pixel_row = 0; pixel_row < 8; ++pixel_row) {\n            for (int i = 0; i < 8; ++i) {\n                icos_idct_linear_8192_dequantized((int)color)[pixel_row * 8 + i] = icos_idct_linear_8192_scaled[pixel_row * 8 + i] * quantization_table_[(int)color][i];\n                icos_idct_edge_8192_dequantized_x((int)color)[pixel_row * 8 + i] = icos_base_8192_scaled[i * 8] * quantization_table_[(int)color][i * 8 + pixel_row];\n                icos_idct_edge_8192_dequantized_y((int)color)[pixel_row * 8 + i] = icos_base_8192_scaled[i * 8] * quantization_table_[(int)color][pixel_row * 8 + i];\n            }\n        }\n        static const unsigned short int freqmax[] =\n        {\n            1024, 931, 985, 968, 1020, 968, 1020, 1020,\n            932, 858, 884, 840, 932, 838, 854, 854,\n            985, 884, 871, 875, 985, 878, 871, 854,\n            967, 841, 876, 844, 967, 886, 870, 837,\n            1020, 932, 985, 967, 1020, 969, 1020, 1020,\n            969, 838, 878, 886, 969, 838, 969, 838,\n            1020, 854, 871, 870, 1010, 969, 1020, 1020,\n            1020, 854, 854, 838, 1020, 838, 1020, 838\n        };\n        for (int coord = 0; coord < 64; ++coord) {\n            freqmax_[(int)color][coord] = (freqmax[coord] + quantization_table_[(int)color][coord] - 1)\n                / quantization_table_[(int)color][coord];\n            uint8_t max_len = uint16bit_length(freqmax_[(int)color][coord]);\n            bitlen_freqmax_[(int)color][coord] = max_len;\n            if (max_len > (int)RESIDUAL_NOISE_FLOOR) {\n                min_noise_threshold_[(int)color][coord] = max_len - RESIDUAL_NOISE_FLOOR;\n            }\n        }\n    }\n    static int32_t *icos_idct_edge_8192_dequantized_x(int color) {\n        return icos_idct_edge_8192_dequantized_x_[(int)color];\n    }\n    static int32_t *icos_idct_edge_8192_dequantized_y(int color) {\n        return icos_idct_edge_8192_dequantized_y_[(int)color];\n    }\n    static int32_t *icos_idct_linear_8192_dequantized(int color) {\n        return icos_idct_linear_8192_dequantized_[(int)color];\n    }\n    struct CoefficientContext {\n        int best_prior; //lakhani or aavrg depending on coefficient number\n        uint8_t num_nonzeros_bin; // num_nonzeros mapped into a bin\n        uint8_t bsr_best_prior;\n    };\n    enum {\n        VECTORIZE = ::VECTORIZE,\n        MICROVECTORIZE = ::MICROVECTORIZE\n    };\n};\n\n#define USE_TEMPLATIZED_COLOR\n#ifdef USE_TEMPLATIZED_COLOR\n#define TEMPLATE_ARG_COLOR0 BlockType::Y\n#define TEMPLATE_ARG_COLOR1 BlockType::Cb\n#define TEMPLATE_ARG_COLOR2 BlockType::Cr\n#define TEMPLATE_ARG_COLOR3 BlockType::Ck\n\n#else\n#define TEMPLATE_ARG_COLOR0 BlockType::Y\n#define TEMPLATE_ARG_COLOR1 BlockType::Y\n#define TEMPLATE_ARG_COLOR2 BlockType::Y\n#define TEMPLATE_ARG_COLOR3 BlockType::Y\n#endif\ntemplate <bool all_present, BlockType\n#ifdef USE_TEMPLATIZED_COLOR\n              color\n#else\n              deprecated_color\n#endif\n>\nclass ProbabilityTables\n{\nprivate:\n    typedef ProbabilityTablesBase::CoefficientContext CoefficientContext;\n    const bool left_present;\n    const bool above_present;\n    const bool above_right_present;\npublic:\n#ifdef USE_TEMPLATIZED_COLOR\n    enum {\n        COLOR = (int)color\n    };\n    ProbabilityTables(BlockType kcolor,\n                      bool in_left_present,\n                      bool in_above_present,\n                      bool in_above_right_present)\n        : left_present(in_left_present),\n          above_present(in_above_present),\n          above_right_present(in_above_right_present) {\n       always_assert((left_present && above_present && above_right_present) == all_present);\n       always_assert(kcolor == color);\n    }\n#else\n    const BlockType COLOR;\n    ProbabilityTables(BlockType color,\n                      bool in_left_present,\n                      bool in_above_present,\n                      bool in_above_right_present)\n        : left_present(in_left_present),\n          above_present(in_above_present),\n          above_right_present(in_above_right_present),\n          COLOR(color) {\n        always_assert((left_present && right_present && above_right_present) == all_present);\n        static_assert((int)deprecated_color == 0, \"Using dynamic color\");\n    }\n#endif\n    void reset(ProbabilityTablesBase&base) {\n        reset_model(base.model());\n    }\n    void load(ProbabilityTablesBase&base, const char * filename) {\n        load_model(base.model(), filename);\n    }\n    int color_index() {\n        if (BLOCK_TYPES == 2) {\n            if (0 == (int)COLOR) {\n                return 0;\n            }\n            return 1;\n        } else {\n            return std::min((int)(BLOCK_TYPES - 1), (int)COLOR);\n        }\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context7x7(int coord,\n                                       int aligned_zz,\n                                       const ConstBlockContext block, uint8_t num_nonzeros_left) {\n        ProbabilityTablesBase::CoefficientContext retval;\n        retval.best_prior = compute_aavrg(coord, aligned_zz, block);\n        retval.num_nonzeros_bin = num_nonzeros_to_bin(num_nonzeros_left);\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context7x7_precomp(int aligned_zz,\n                                       int aavrg,\n                                       const ConstBlockContext block, uint8_t num_nonzeros_left) {\n        ProbabilityTablesBase::CoefficientContext retval;\n        dev_assert(aavrg == compute_aavrg(aligned_to_raster.at(aligned_zz), aligned_zz, block));\n        //This was to make sure the code was right compute_aavrg_vec(aligned_zz, block);\n        retval.best_prior = aavrg;\n        retval.num_nonzeros_bin = num_nonzeros_to_bin(num_nonzeros_left);\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n#ifndef USE_SCALAR\n        if (MICROVECTORIZE) {\n            retval.best_prior = (coefficient & 7)\n            ? compute_lak_horizontal(block, coefficient) : compute_lak_vertical(block, coefficient);\n        } else {\n            retval.best_prior = compute_lak(block, coefficient);\n        }\n#else\n        retval.best_prior = compute_lak(block, coefficient);\n#endif\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n#ifndef USE_SCALAR\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_horiz(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n        retval.best_prior = compute_lak_horizontal(block, coefficient);\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_vert(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n        retval.best_prior = compute_lak_vertical(block, coefficient);\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n\n#define INSTANTIATE_TEMPLATE_METHOD(N)  \\\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_templ##N(const ConstBlockContext block, \\\n                                                   uint8_t num_nonzeros_x) { \\\n        ProbabilityTablesBase::CoefficientContext retval = {0, 0, 0};     \\\n        retval.best_prior = compute_lak_templ<N>(block); \\\n        retval.num_nonzeros_bin = num_nonzeros_x; \\\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023)); \\\n        return retval; \\\n    }\n    INSTANTIATE_TEMPLATE_METHOD(1)\n    INSTANTIATE_TEMPLATE_METHOD(2)\n    INSTANTIATE_TEMPLATE_METHOD(3)\n    INSTANTIATE_TEMPLATE_METHOD(4)\n    INSTANTIATE_TEMPLATE_METHOD(5)\n    INSTANTIATE_TEMPLATE_METHOD(6)\n    INSTANTIATE_TEMPLATE_METHOD(7)\n    INSTANTIATE_TEMPLATE_METHOD(8)\n    INSTANTIATE_TEMPLATE_METHOD(16)\n    INSTANTIATE_TEMPLATE_METHOD(24)\n    INSTANTIATE_TEMPLATE_METHOD(32)\n    INSTANTIATE_TEMPLATE_METHOD(40)\n    INSTANTIATE_TEMPLATE_METHOD(48)\n    INSTANTIATE_TEMPLATE_METHOD(56)\n#endif\n\n    Sirikata::Array2d<Branch, 6, 32>::Slice nonzero_counts_7x7(ProbabilityTablesBase &pt,\n                                                               const ConstBlockContext block) {\n        uint8_t num_nonzeros_above = 0;\n        uint8_t num_nonzeros_left = 0;\n        if (all_present || above_present) {\n            num_nonzeros_above = block.nonzeros_above_7x7_unchecked();\n        }\n        if (all_present || left_present) {\n            num_nonzeros_left = block.nonzeros_left_7x7_unchecked();\n        }\n\n        uint8_t num_nonzeros_context = 0;\n        if ((!all_present) && above_present && !left_present) {\n            num_nonzeros_context = (num_nonzeros_above + 1) / 2;\n        } else if ((!all_present) && left_present && !above_present) {\n            num_nonzeros_context = (num_nonzeros_left + 1) / 2;\n        } else if (all_present || (left_present && above_present)) {\n            num_nonzeros_context = (num_nonzeros_above + num_nonzeros_left + 2) / 4;\n        }\n        ANNOTATE_CTX(0, ZEROS7x7, 0, num_nonzeros_context);\n        return pt.model().num_nonzeros_counts_7x7_.at(color_index(),\n                                                      num_nonzeros_to_bin(num_nonzeros_context));\n    }\n    Sirikata::Array2d<Branch, 3u, 4u>::Slice x_nonzero_counts_8x1(ProbabilityTablesBase &pt,\n                                                          unsigned int eob_x,\n                                                          unsigned int num_nonzeros) {\n        ANNOTATE_CTX(0, ZEROS8x1, 0, ((num_nonzeros + 3) / 7));\n        ANNOTATE_CTX(0, ZEROS8x1, 1, eob_x);\n        return pt.model().num_nonzeros_counts_8x1_.at(color_index(), eob_x, ((num_nonzeros + 3) / 7));\n    }\n    Sirikata::Array2d<Branch, 3u, 4u>::Slice y_nonzero_counts_1x8(ProbabilityTablesBase &pt,\n                                                          unsigned int eob_x,\n                                                          unsigned int num_nonzeros) {\n        ANNOTATE_CTX(0, ZEROS1x8, 0, ((num_nonzeros + 3) / 7));\n        ANNOTATE_CTX(0, ZEROS1x8, 1, eob_x);\n        return pt.model().num_nonzeros_counts_1x8_.at(color_index(), eob_x, ((num_nonzeros + 3) / 7));\n    }\n    Sirikata::Array1d<Branch, MAX_EXPONENT>::Slice exponent_array_x(ProbabilityTablesBase &pt, int band, int zig15, CoefficientContext context) {\n        ANNOTATE_CTX(band, EXP8, 0, context.bsr_best_prior);\n        ANNOTATE_CTX(band, EXP8, 1, context.num_nonzeros);\n        dev_assert((band & 7)== 0 ? ((band >>3) + 7) : band - 1 == zig15);\n        return pt.model().exponent_counts_x_.at(color_index(),\n                                             context.num_nonzeros_bin,\n                                             zig15,\n                                             context.bsr_best_prior);\n    }\n    Sirikata::Array1d<Branch, MAX_EXPONENT>::Slice exponent_array_7x7(ProbabilityTablesBase &pt,\n                                                                      const unsigned int band,\n                                                                      const unsigned int zig49,\n                                                                      const CoefficientContext context) {\n        ANNOTATE_CTX(band, EXP7x7, 0, context.bsr_best_prior);\n        ANNOTATE_CTX(band, EXP7x7, 1, context.num_nonzeros_bin);\n        return pt.model().exponent_counts_.at(color_index(),\n            context.num_nonzeros_bin,\n            zig49,\n            context.bsr_best_prior);\n    }\n    Sirikata::Array1d<Branch,\n                      MAX_EXPONENT>::Slice exponent_array_dc(ProbabilityTablesBase &pt,\n\t\t\t\t\t\t\t     uint16_t len_abs_mxm,\n\t\t\t\t\t\t\t     uint16_t len_abs_offset_to_closest_edge) {\n        return pt.model().exponent_counts_dc_.\n\t  at(std::min(len_abs_mxm,\n\t\t      (uint16_t)(Model::ExponentCountsDC::size0 - 1)),\n\t     std::min(len_abs_offset_to_closest_edge,\n\t\t      (uint16_t)(Model::ExponentCountsDC::size1 - 1)));\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_array_dc(ProbabilityTablesBase &pt,\n                                                                     uint16_t len_abs_mxm\n                                                                  , uint16_t len_abs_offset_to_closest_edge) {\n        return pt.model().residual_noise_counts_dc_\n\t  .at(std::min((uint16_t)(Model::ResidualNoiseCountsDc::size0 - 1),\n\t\t       len_abs_mxm));\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_x(ProbabilityTablesBase &pt,\n                                                          const unsigned int band,\n                                                          const CoefficientContext context) {\n        ANNOTATE_CTX(band, RES8, 0, num_nonzeros_x);\n        return residual_noise_array_shared(pt, band,\n                                           context);\n    }\n\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_shared(ProbabilityTablesBase &pt,\n                                                            const unsigned int band,\n                                                            const CoefficientContext context) {\n        return pt.model().residual_noise_counts_.at(color_index(),\n                                                 band/band_divisor,\n                                                 context.num_nonzeros_bin);\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_7x7(ProbabilityTablesBase &pt,\n                                                            const unsigned int band,\n                                                            const CoefficientContext context) {\n        if (band == 0) {\n            ANNOTATE_CTX(0, RESDC, 0, num_nonzeros_to_bin(num_nonzeros));\n        } else {\n            ANNOTATE_CTX(band, RES7x7, 0, num_nonzeros_to_bin(num_nonzeros));\n        }\n        return residual_noise_array_shared(pt, band, context);\n    }\n    unsigned int num_nonzeros_to_bin(uint8_t num_nonzeros) {\n        return nonzero_to_bin[NUM_NONZEROS_BINS-1][num_nonzeros];\n    }\n    int idct_2d_8x1(const AlignedBlock&block, bool ignore_first, int pixel_row) {\n        int retval = 0;\n        if (!ignore_first) {\n            retval = block.coefficients_raster(0) * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 0];\n        }\n        retval += block.coefficients_raster(1)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 1];\n        retval += block.coefficients_raster(2)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 2];\n        retval += block.coefficients_raster(3)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 3];\n        retval += block.coefficients_raster(4)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 4];\n        retval += block.coefficients_raster(5)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 5];\n        retval += block.coefficients_raster(6)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 6];\n        retval += block.coefficients_raster(7)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 7];\n        return retval;\n    }\n\n    int idct_2d_1x8(const AlignedBlock&block, bool ignore_first, int pixel_row) {\n        int retval = 0;\n        if (!ignore_first) {\n            retval = block.dc() * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 0];\n        }\n        retval += block.coefficients_raster(8)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 1];\n        retval += block.coefficients_raster(16)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 2];\n        retval += block.coefficients_raster(24)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 3];\n        retval += block.coefficients_raster(32)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 4];\n        retval += block.coefficients_raster(40)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 5];\n        retval += block.coefficients_raster(48)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 6];\n        retval += block.coefficients_raster(56)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 7];\n        return retval;\n    }\n\n    int predict_dc_dct(const ConstBlockContext&context) {\n        int prediction = 0;\n        int left_block = 0;\n        int left_edge = 0;\n        int above_block = 0;\n        int above_edge = 0;\n        if (all_present || left_present) {\n            left_block = idct_2d_8x1(context.left_unchecked(), 0, 7);\n            left_edge = idct_2d_8x1(context.here(), 1, 0);\n        }\n        if (all_present || above_present) {\n            above_block = idct_2d_1x8(context.above_unchecked(), 0, 7);\n            above_edge = idct_2d_1x8(context.here(), 1, 0);\n        }\n        if (all_present || left_present) {\n            if (all_present || above_present) {\n                prediction = ( ( left_block - left_edge ) + (above_block - above_edge) ) * 4;\n            } else {\n                prediction = ( left_block - left_edge ) * 8;\n            }\n        } else if (above_present) {\n            prediction = ( above_block - above_edge ) * 8;\n        }\n        int DCT_RSC = 8192;\n        prediction = std::max(-1024 * DCT_RSC, std::min(1016 * DCT_RSC, prediction));\n        prediction /= ProbabilityTablesBase::quantization_table((int)COLOR, 0);\n        int round = DCT_RSC/2;\n        if (prediction < 0) {\n            round = -round;\n        }\n        return (prediction + round) / DCT_RSC;\n    }\n    int predict_locoi_dc_deprecated(const ConstBlockContext&context) {\n        if (all_present || left_present) {\n            int a = context.left_unchecked().dc();\n            if (all_present || above_present) {\n                int b = context.above_unchecked().dc();\n                int c = context.above_left_unchecked().dc();\n                if (c >= std::max(a,b)) {\n                    return std::min(a,b);\n                } else if (c <= std::min(a,b)) {\n                    return std::max(a,b);\n                }\n                return a + b - c;\n            }else { \n                return a;\n            }\n        } else if (above_present) {\n            return context.above_unchecked().dc();\n        } else {\n            return 0;\n        }\n    }\n    int predict_or_unpredict_dc(const ConstBlockContext&context, bool recover_original) {\n        int max_value = (1 << (1 + MAX_EXPONENT)) - 1;\n        int min_value = -max_value;\n        int adjustment_factor = 2 * max_value + 1;\n        int retval = //predict_locoi_dc_deprecated(block);\n            predict_dc_dct(context);\n        retval = context.here().dc() + (recover_original ? retval : -retval);\n        if (retval < min_value) retval += adjustment_factor;\n        if (retval > max_value) retval -= adjustment_factor;\n        return retval;\n    }\n#define shift_right_round_zero_epi16(vec, imm8) (_mm_sign_epi16(_mm_srli_epi16(_mm_sign_epi16(vec, vec), imm8), vec));\n    int adv_predict_dc_pix(const ConstBlockContext&context, int16_t*pixels_sans_dc, int32_t *uncertainty_val, int32_t *uncertainty2_val) {\n        uint16_t *q = ProbabilityTablesBase::quantization_table((int)color);\n        idct(context.here(), q, pixels_sans_dc, true);\n\n        Sirikata::AlignedArray1d<int16_t, 16> dc_estimates;\n        dc_estimates.memset(0);\n        int32_t avgmed = 0;\n        if(all_present || left_present || above_present) {\n#ifndef USE_SCALAR\n            if (all_present || above_present) { //above goes first to prime the cache\n                __m128i neighbor_above = _mm_loadu_si128((const __m128i*)(const char*)context\n                                                         .neighbor_context_above_unchecked()\n                                                         .horizontal_ptr());\n                __m128i pixels_sans_dc_reg = _mm_loadu_si128((const __m128i*)(const char*)pixels_sans_dc);\n                __m128i pixels2_sans_dc_reg = _mm_loadu_si128((const __m128i*)(const char*)(pixels_sans_dc + 8));\n                __m128i pixels_delta = _mm_sub_epi16(pixels_sans_dc_reg,\n                                                     pixels2_sans_dc_reg);\n                __m128i pixels_delta_div2 = shift_right_round_zero_epi16(pixels_delta, 1);\n                __m128i pixels_sans_dc_recentered = _mm_add_epi16(pixels_sans_dc_reg,\n                                                                  _mm_set1_epi16(1024));\n                __m128i above_dc_estimate = _mm_sub_epi16(_mm_sub_epi16(neighbor_above, pixels_delta_div2),\n                                                          pixels_sans_dc_recentered);\n\n                _mm_store_si128((__m128i*)(char*)(dc_estimates.begin()\n                                                  + ((all_present || left_present) ? 8 : 0)),\n                                above_dc_estimate);\n            }\n            if (all_present || left_present) {\n                const int16_t * horiz_data = context.neighbor_context_left_unchecked().vertical_ptr_except_7();\n                __m128i neighbor_horiz = _mm_loadu_si128((const __m128i*)(const char*)horiz_data);\n                //neighbor_horiz = _mm_insert_epi16(neighbor_horiz, horiz_data[NeighborSummary::VERTICAL_LAST_PIXEL_OFFSET_FROM_FIRST_PIXEL], 7);\n                __m128i pixels_sans_dc_reg = _mm_set_epi16(pixels_sans_dc[56],\n                                                           pixels_sans_dc[48],\n                                                           pixels_sans_dc[40],\n                                                           pixels_sans_dc[32],\n                                                           pixels_sans_dc[24],\n                                                           pixels_sans_dc[16],\n                                                           pixels_sans_dc[8],\n                                                           pixels_sans_dc[0]);\n                __m128i pixels_delta = _mm_sub_epi16(pixels_sans_dc_reg,\n                                                     _mm_set_epi16(pixels_sans_dc[57],\n                                                                   pixels_sans_dc[49],\n                                                                   pixels_sans_dc[41],\n                                                                   pixels_sans_dc[33],\n                                                                   pixels_sans_dc[25],\n                                                                   pixels_sans_dc[17],\n                                                                   pixels_sans_dc[9],\n                                                                   pixels_sans_dc[1]));\n\n                __m128i pixels_delta_div2 = shift_right_round_zero_epi16(pixels_delta, 1);\n                __m128i left_dc_estimate = _mm_sub_epi16(_mm_sub_epi16(neighbor_horiz, pixels_delta_div2),\n                                                          _mm_add_epi16(pixels_sans_dc_reg,\n                                                                        _mm_set1_epi16(1024)));\n\n                _mm_store_si128((__m128i*)(char*)dc_estimates.begin(), left_dc_estimate);\n            }\n#else\n            if (all_present || left_present) {\n                for (int i = 0; i < 8;++i) {\n                    int a = pixels_sans_dc[i << 3] + 1024;\n                    int pixel_delta = pixels_sans_dc[i << 3] - pixels_sans_dc[(i << 3) + 1];\n                    int b = context.neighbor_context_left_unchecked().vertical(i) - (pixel_delta / 2); //round to zero\n                    dc_estimates[i] = b - a;\n                }\n            }\n            if (all_present || above_present) {\n                for (int i = 0; i < 8;++i) {\n                    int a = pixels_sans_dc[i] + 1024;\n                    int pixel_delta = pixels_sans_dc[i] - pixels_sans_dc[i + 8];\n                    int b = context.neighbor_context_above_unchecked().horizontal(i) - (pixel_delta / 2); //round to zero\n                    dc_estimates[i + ((all_present || left_present) ? 8 : 0)] = b - a;\n                }\n            }\n#endif\n            int32_t avg_h_v[2] = {0, 0};\n            int32_t min_dc = dc_estimates[0];\n            int32_t max_dc = dc_estimates[0];\n            size_t which_est = 0;\n            for (int vert = 0; vert != 2; ++vert) {\n                for (int i = 0; i < 8; ++which_est, ++i) {\n                    int16_t cur_est = dc_estimates[which_est];\n                    avg_h_v[vert] += cur_est;\n                    if (min_dc > cur_est) {\n                        min_dc = cur_est;\n                    }\n                    if (max_dc < cur_est) {\n                        max_dc = cur_est;\n                    }\n                }\n                if ((!all_present) && (above_present == false || left_present == false)) {\n                    avg_h_v[1] = avg_h_v[0];\n                    break;\n                }\n            }\n            int32_t overall_avg = (avg_h_v[0] + avg_h_v[1]) >> 1;\n            avgmed = overall_avg;\n            *uncertainty_val = (max_dc - min_dc)>>3;\n            avg_h_v[0] -= avgmed;\n            avg_h_v[1] -= avgmed;\n            int32_t far_afield_value = avg_h_v[1];\n            if (abs(avg_h_v[0]) < abs(avg_h_v[1])) {\n                far_afield_value = avg_h_v[0];\n            }\n            *uncertainty2_val = (far_afield_value) >> 3;\n\n            if (false) { // this is to debug some of the differences\n                debug_print_deltas(context, dc_estimates.begin(), avgmed);\n            }\n        }\n        return ((avgmed / q[0] + 4) >> 3);\n    }\n    void debug_print_deltas(const ConstBlockContext&context, int16_t *dc_estimates, int avgmed) {\n        int actual_dc = context.here().dc();\n        uint16_t *q = ProbabilityTablesBase::quantization_table((int)color);\n        int len_est = ((all_present || (left_present && above_present)) ? 16 : 8);\n        int avg_estimated_dc = 0;\n        int dc_sum = 0;\n        for (int i = 0 ;i < len_est; ++i) {\n            dc_sum += dc_estimates[i];\n        }\n        avg_estimated_dc = dc_sum;\n        if (all_present || (left_present && above_present)) {\n            avg_estimated_dc >>= 1;\n        }\n        \n        avg_estimated_dc = (avg_estimated_dc/q[0] + xIDCTSCALE / 2) >> 3;\n        int16_t dc_copy[16];\n        memcpy(dc_copy, dc_estimates, len_est*sizeof(int16_t));\n        std::sort(dc_copy, dc_copy + len_est);\n        int mmed = dc_copy[len_est/2];\n        int scaled_med = (mmed/q[0] + 4);\n        int scaled_avgmed = (((avgmed/q[0]) + 4) >> 3);\n        using namespace LeptonDebug;\n        LeptonDebug::med_err += abs(scaled_med - actual_dc);\n        LeptonDebug::amd_err += abs(scaled_avgmed - actual_dc);\n        LeptonDebug::avg_err += abs(avg_estimated_dc - actual_dc);\n        int locoi_pred = predict_locoi_dc_deprecated(context);\n        int predicted_dc = predict_dc_dct(context);\n        LeptonDebug::ori_err += abs(predicted_dc - actual_dc);\n        LeptonDebug::loc_err += abs(locoi_pred - actual_dc);\n\n        fprintf(stderr, \"MXM: %d\\n\", dc_estimates[len_est - 1] - dc_estimates[0]);\n        fprintf(stderr, \"MED: %d (%d)\\n\", scaled_med, LeptonDebug::med_err);\n        fprintf(stderr, \"AMD: %d (%d)\\n\", scaled_avgmed, LeptonDebug::amd_err);\n        fprintf(stderr, \"AVG: %d (%d)\\n\", avg_estimated_dc, LeptonDebug::avg_err);\n        fprintf(stderr, \"ORI: %d (%d)\\n\", predicted_dc, LeptonDebug::ori_err);\n        fprintf(stderr, \"LOC: %d (%d)\\n\", locoi_pred, LeptonDebug::loc_err);\n        fprintf(stderr, \"DC : %d\\n\", actual_dc);\n    }\n    int adv_predict_or_unpredict_dc(int16_t saved_dc, bool recover_original, int predicted_val) {\n        int max_value = (1 << (MAX_EXPONENT - 1));\n        int min_value = -max_value;\n        int adjustment_factor = 2 * max_value + 1;\n        int retval = predicted_val;\n        retval = saved_dc + (recover_original ? retval : -retval);\n        if (retval < min_value) retval += adjustment_factor;\n        if (retval > max_value) retval -= adjustment_factor;\n        return retval;\n    }\n    int compute_aavrg_dc(ConstBlockContext context) {\n        return compute_aavrg(0, raster_to_aligned.at(0), context);\n        \n        uint32_t total = 0;\n        if (all_present || left_present) {\n            total += abs(context.left_unchecked().dc());\n        }\n        if (all_present || above_present) {\n            total += abs(context.above_unchecked().dc());\n        }\n        if (all_present || (left_present && above_present)) {\n            constexpr unsigned int log_weight = 5;\n            total *= 13;\n            total += 6 * abs(context.above_left_unchecked().dc());\n            return total >> log_weight;\n        } else {\n            return total;\n        }\n    }\n    int16_t compute_aavrg(unsigned int coord, unsigned int aligned_zz, ConstBlockContext context) {\n        int16_t total = 0;\n        if (all_present || left_present) {\n            total += abs(context.left_unchecked().coefficients_raster(coord));\n        }\n        if (all_present || above_present) {\n            total += abs(context.above_unchecked().coefficients_raster(coord));\n        }\n        if (all_present || (left_present && above_present)) {\n            constexpr unsigned int log_weight = 5;\n            total *= 13;\n            total += 6 * abs(context.above_left_unchecked().coefficients_raster(coord));\n            return ((uint16_t)total) >> log_weight;\n        } else {\n            return total;\n        }\n        //if (block.context().above_right.initialized()) {\n        //total += abs(block.context().above_right.get()->coefficients().at(0));\n        //}\n    }\n#if defined(OPTIMIZED_7x7) && !defined(USE_SCALAR)\n    bool aavrg_vec_matches(__m128i retval, unsigned int aligned_zz, ConstBlockContext context) {\n        short ret[8];\n        _mm_storeu_si128((__m128i*)(char*)ret, retval);\n        short correct[8] = {compute_aavrg(aligned_to_raster.at(aligned_zz), aligned_zz +0, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+1), aligned_zz + 1, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+2), aligned_zz + 2, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+3), aligned_zz + 3, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+4), aligned_zz + 4, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+5), aligned_zz + 5, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+6), aligned_zz + 6, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+7), aligned_zz + 7, context)};\n        return (memcmp(ret, correct, sizeof(correct)) == 0);\n    }\n    void compute_aavrg_vec(unsigned int aligned_zz, ConstBlockContext context, short* aligned_retval) {\n        _mm_store_si128((__m128i*)(char*)aligned_retval, compute_aavrg_vec(aligned_zz, context));\n    }\n#if defined (__clang__) || defined(__GNUC__)\n#define x_mm_loadu_si64(a) _mm_set1_epi64x(*(uint64_t*)(char*)(a))\n#else\n#define x_mm_loadu_si64 _mm_loadu_si64\n#endif\n\n    __m128i compute_aavrg_vec(unsigned int aligned_zz, ConstBlockContext context) {\n        if (all_present == false && left_present == false && above_present == false) {\n            return _mm_setzero_si128();\n        }\n        __m128i left;\n        if (all_present || left_present) {\n            left = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.left_unchecked().coef.at(aligned_zz)));\n            if ((!all_present) && !above_present) {\n                return left;\n            }\n        }\n        __m128i above = _mm_setzero_si128();\n        if (all_present || above_present) {\n            above = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.above_unchecked().coef.at(aligned_zz)));\n            if (all_present == false && !left_present) {\n                return above;\n            }\n        }\n        constexpr unsigned int log_weight = 5;\n        __m128i total = _mm_add_epi16(left, above);\n        total = _mm_mullo_epi16(total, _mm_set1_epi16(13)); // approximate (a*2+b*2 + c)/5 as (a *13 + b * 13 + c * 6)/32\n        __m128i aboveleft = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.above_left_unchecked().coef.at(aligned_zz)));\n        total = _mm_add_epi16(total, _mm_mullo_epi16(aboveleft, _mm_set1_epi16(6)));\n        __m128i retval = _mm_srli_epi16(total, log_weight);\n        dev_assert(aavrg_vec_matches(retval, aligned_zz, context));\n        return retval;\n        //if (block.context().above_right.initialized()) {\n        //total += abs(block.context().above_right.get()->coefficients().at(0));\n        //}\n    }\n#endif\n\n#ifndef USE_SCALAR\n    static int32_t compute_lak_vec(__m128i coeffs_x_low, __m128i coeffs_x_high, __m128i coeffs_a_low, __m128i \n#ifdef _WIN32\n        &\n#endif\n        indirect_coeffs_a_high, const int32_t *icos_deq) {\n        __m128i sign_mask = _mm_set_epi32(-1, 1, -1, 1); // ((i & 1) ? -1 : 1)\n\n        //coeffs_x[i] = ((i & 1) ? -1 : 1) * coeffs_a[i] - coeffs_x[i];\n        coeffs_a_low = _mm_sign_epi32(coeffs_a_low, sign_mask);\n        __m128i coeffs_a_high = _mm_sign_epi32(indirect_coeffs_a_high, sign_mask);\n        coeffs_x_low = _mm_sub_epi32(coeffs_a_low, coeffs_x_low);\n        coeffs_x_high = _mm_sub_epi32(coeffs_a_high, coeffs_x_high);\n\n        __m128i icos_low = _mm_load_si128((const __m128i*)(const char*)icos_deq);\n        __m128i icos_high = _mm_load_si128((const __m128i*)(const char*)(icos_deq + 4));\n        // coeffs_x[i] *= icos[i]\n        __m128i deq_low = _mm_mullo_epi32(coeffs_x_low, icos_low);\n        __m128i deq_high = _mm_mullo_epi32(coeffs_x_high, icos_high);\n\n        __m128i sum = _mm_add_epi32(deq_low, deq_high);\n        sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 8));\n        sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 4));\n        // coeffs_x[0] = sum(coeffs_x)\n        int32_t prediction = _mm_cvtsi128_si32(sum);\n        //if (prediction > 0) { <-- rounding hurts prediction perf and costs compute  this rounding didn't round the same way as the unvectorized one anyhow\n        //    prediction += icos_deq[0]/2;\n        //} else {\n        //    prediction -= icos_deq[0]/2; // round away from zero\n        //}\n        return prediction / icos_deq[0];\n    }\n\n#define ITER(x_var, a_var, i, step) \\\n        (x_var = _mm_set_epi32(   context.here().coefficients_raster(band + step * ((i) + 3)), \\\n                                  context.here().coefficients_raster(band + step * ((i) + 2)), \\\n                                  context.here().coefficients_raster(band + step * ((i) + 1)), \\\n                                  i == 0 ? 0 : context.here().coefficients_raster(band + step * (i))), \\\n         a_var = _mm_set_epi32(neighbor.coefficients_raster(band + step * ((i) + 3)), \\\n                                  neighbor.coefficients_raster(band + step * ((i) + 2)), \\\n                                  neighbor.coefficients_raster(band + step * ((i) + 1)), \\\n                                  neighbor.coefficients_raster(band + step * (i))))\n    \n    template<int band>\n#ifndef _WIN32\n    __attribute__((always_inline))\n#endif\n    int32_t compute_lak_templ(const ConstBlockContext&context) {\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        const int32_t * icos = nullptr;\n        static_assert((band & 7) == 0 || (band >> 3) == 0, \"This function only works on edges\");\n        if ((band >> 3) == 0) {\n            if(all_present == false && !above_present) {\n                return 0;\n            }\n            const auto &neighbor = context.above_unchecked();\n            ITER(coeffs_x_low, coeffs_a_low, 0, 8);\n            ITER(coeffs_x_high, coeffs_a_high, 4, 8);\n            icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        } else {\n            if (all_present == false && !left_present) {\n                return 0;\n            }\n            const auto &neighbor = context.left_unchecked();\n            ITER(coeffs_x_low, coeffs_a_low, 0, 1);\n            ITER(coeffs_x_high, coeffs_a_high, 4, 1);\n            icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        }\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high, icos);\n    }\n    int32_t compute_lak_horizontal(const ConstBlockContext&context, unsigned int band) {\n        if (all_present == false && !above_present) {\n            return 0;\n        }\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        dev_assert(band/8 == 0 && \"this function only works for the top edge\");\n        const auto &neighbor = context.above_unchecked();\n        ITER(coeffs_x_low, coeffs_a_low, 0, 8);\n        ITER(coeffs_x_high, coeffs_a_high, 4, 8);\n        const int32_t * icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high, icos);\n    }\n    int32_t compute_lak_vertical(const ConstBlockContext&context, unsigned int band) {\n        dev_assert((band & 7) == 0 && \"Must be used for veritcal\");\n        if (all_present == false && !left_present) {\n            return 0;\n        }\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        const auto &neighbor = context.left_unchecked();\n        ITER(coeffs_x_low, coeffs_a_low, 0, 1);\n        ITER(coeffs_x_high, coeffs_a_high, 4, 1);\n#undef ITER\n        const int32_t *icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high,\n                        icos);\n    }\n#endif\n    int32_t compute_lak(const ConstBlockContext&context, unsigned int band) {\n        int coeffs_x[8];\n        int coeffs_a[8];\n        const int32_t *coef_idct = nullptr;\n        if ((band & 7) && (all_present || above_present)) {\n            // y == 0: we're the x\n            dev_assert(band/8 == 0); //this function only works for the edge\n            const auto &above = context.above_unchecked();\n            for (int i = 0; i < 8; ++i) {\n                uint8_t cur_coef = band + i * 8;\n                coeffs_x[i]  = i ? context.here().coefficients_raster(cur_coef) : 0;\n                coeffs_a[i]  = above.coefficients_raster(cur_coef);\n            }\n            coef_idct = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        } else if ((band & 7) == 0 && left_present) {\n            // x == 0: we're the y\n            const auto &left = context.left_unchecked();\n            for (int i = 0; i < 8; ++i) {\n                uint8_t cur_coef = band + i;\n                coeffs_x[i]  = i ? context.here().coefficients_raster(cur_coef) : 0;\n                coeffs_a[i]  = left.coefficients_raster(cur_coef);\n            }\n            coef_idct = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        } else {\n            return 0;\n        }\n        int prediction = coeffs_a[0] * coef_idct[0]; // rounding towards zero before adding coeffs_a[0] helps ratio slightly, but this is cheaper\n        for (int i = 1; i < 8; ++i) {\n            int sign = (i & 1) ? 1 : -1;\n            prediction -= coef_idct[i] * (coeffs_x[i] + sign * coeffs_a[i]);\n        }\n        prediction /= coef_idct[0];\n#if _DEBUG\n        // In DEBUG mode verify that the scalar compute_lak matches the vectorized ones\n        dev_assert(((band & 7) ? compute_lak_horizontal(context,band): compute_lak_vertical(context,band)) == prediction\n               && \"Vectorized version must match sequential version\");\n#endif\n        return prediction;\n    }\n    Sirikata::Array1d<Branch,\n            (1<<RESIDUAL_NOISE_FLOOR)>::Slice\n        residual_thresh_array(ProbabilityTablesBase &pt,\n                              const unsigned int band,\n                              const uint8_t cur_exponent,\n                              const CoefficientContext context,\n                              int min_threshold) {\n        uint16_t ctx_abs = abs(context.best_prior);\n        ANNOTATE_CTX(band, THRESH8, 0, ctx_abs >> min_threshold);\n        ANNOTATE_CTX(band, THRESH8, 2, cur_exponent - min_threshold);\n        return pt.model(\n            ).residual_threshold_counts_.at(color_index(),\n                                            std::min(ctx_abs >> min_threshold,\n                                                     (uint16_t)Model::ResidualThresholdCounts::size1 - 1),\n                                            std::min(cur_exponent - min_threshold,\n                                                     Model::ResidualThresholdCounts::size2 - 1));\n    }\n    void residual_thresh_array_annot_update(const unsigned int band,\n                                            uint16_t cur_serialized_thresh_value) {\n        (void)band;\n        (void)cur_serialized_thresh_value;\n        ANNOTATE_CTX(band, THRESH8, 1, cur_serialized_thresh_value);\n    }\n    enum SignValue {\n        ZERO_SIGN=0,\n        POSITIVE_SIGN=1,\n        NEGATIVE_SIGN=2,\n    };\n    Branch& sign_array_dc(ProbabilityTablesBase &pt,\n                          int avg_delta,\n                          int offset_to_closest_edge) {\n        ANNOTATE_CTX(0, SIGNDC, 0, 1);\n        return pt.model().sign_counts_.at(color_index(),\n                                          0,\n                                          offset_to_closest_edge >= 0\n                                          ? offset_to_closest_edge == 0\n                                          ? 3 : 2 : 1);\n    }\n    Branch& sign_array_7x7(ProbabilityTablesBase &pt, uint8_t band, CoefficientContext context) {\n        ANNOTATE_CTX(band, SIGN7x7, 0, 0);\n        return pt.model().sign_counts_.at(color_index(), 0, 0);\n    }\n    Branch& sign_array_8(ProbabilityTablesBase &pt, uint8_t band, CoefficientContext context) {\n\n        int16_t val = context.best_prior;\n        uint8_t ctx0 = context.bsr_best_prior;\n        uint8_t ctx1 = (val == 0 ? 0 : (val > 0 ? 1 : 2));\n        ANNOTATE_CTX(band, SIGN8, 0, ctx0);\n        ANNOTATE_CTX(band, SIGN8, 1, ctx1);\n        return pt.model().sign_counts_.at(color_index(), ctx1, ctx0);\n    }\n  \n    uint8_t get_noise_threshold(int coord) {\n        return ProbabilityTablesBase::min_noise_threshold((int)COLOR, coord);\n    }\n    void optimize(ProbabilityTablesBase &pt) {\n        optimize_model(pt.model());\n    }\n    void serialize(ProbabilityTablesBase &pt, int output_fd ) const{\n        serialize_model(pt.model(), output_fd);\n    }\n\n    // this reduces the counts to something easier to override by new data\n    void normalize(ProbabilityTablesBase &pt) {\n        normalize_model(pt.model());\n    }\n    \n};\n\n#endif /* DECODER_HH */\n"], "fixing_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n#include <atomic>\n#include <functional>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n#include <thread>\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n#include \"base_coders.hh\"\n#include \"component_info.hh\"\n#include \"../vp8/model/color_context.hh\"\n#include \"../vp8/util/block_based_image.hh\"\nstruct componentInfo;\n\nclass Block;\n\n\n\nclass UncompressedComponents {\n    typedef int CounterType;\n    class ExtendedComponentInfo {\n        ExtendedComponentInfo(const ExtendedComponentInfo&); // not implemented\n        ExtendedComponentInfo operator=(const ExtendedComponentInfo&); // not implemented\n    public:\n        BlockBasedImage component_;\n        CounterType dpos_block_progress_;\n        componentInfo info_;\n        int trunc_bcv_; // the number of vertical components in this (truncated) image\n        int trunc_bc_;\n        ExtendedComponentInfo() :dpos_block_progress_(0),\n                                 trunc_bcv_(0), trunc_bc_(0) {\n        }\n    };\n    int cmpc_; // the number of components\n    int mcuh_;\n    int mcuv_;\n\ttypedef Sirikata::Array1d<ExtendedComponentInfo, 4> ExtendedInfo;\n    ExtendedInfo header_;\n\t\n    CounterType coefficient_position_progress_;\n    CounterType bit_progress_;\n    CounterType worker_start_read_signal_;\n    int reserved_; // don't want to change memory layout\n    BaseDecoder *decoder_;\n    UncompressedComponents(const UncompressedComponents&);// not implemented\n    UncompressedComponents&operator=(const UncompressedComponents&);// not implemented\n    int bch_(int component) const {\n        return header_[component].info_.bch;\n    }\n    int bcv_(int component) const {\n        return header_[component].trunc_bcv_;\n    }\npublic:\n    UncompressedComponents() : coefficient_position_progress_(0), bit_progress_(0), worker_start_read_signal_(0) {\n        decoder_ = NULL;\n        reserved_ = 0;\n        mcuh_ = 0;\n        mcuv_ = 0;\n        cmpc_ = 0;\n    }\n    unsigned short *get_quantization_tables(BlockType component) const {\n        return header_[(int)component].info_.qtable;\n    }\n    Sirikata::Array1d<uint32_t, (size_t)ColorChannel::NumBlockTypes> get_max_coded_heights() const{\n        Sirikata::Array1d<uint32_t, (size_t)ColorChannel::NumBlockTypes> retval;\n        retval.memset(0);\n        for (int i = 0; i < cmpc_ && i < (int)ColorChannel::NumBlockTypes; ++i) {\n            retval[i] = header_[i].trunc_bcv_;\n        }\n        return retval;\n    }\n    int get_mcu_count_vertical() const{\n        return mcuv_;\n    }\n    int get_mcu_count_horizontal() const{\n        return mcuh_;\n    }\n    bool is_memory_optimized(int cmp) const {\n        return header_[cmp].component_.is_memory_optimized();\n    }\n    int get_num_components() const{\n        return cmpc_;\n    }\n\n    void worker_update_bit_progress(int add_bit_progress) {\n        bit_progress_ += add_bit_progress;\n    }\n    void worker_update_coefficient_position_progress(int add_coefficient_position_progress) {\n        coefficient_position_progress_ += add_coefficient_position_progress;\n    }\n    void worker_update_cmp_progress(BlockType cmp, int add_bit_progress) {\n        header_[(int)cmp].dpos_block_progress_ += add_bit_progress;\n    }\n    void worker_mark_cmp_finished(BlockType cmp) {\n        CounterType dpos_block_progress_ = header_[(int)cmp].trunc_bc_;\n        header_[(int)cmp].dpos_block_progress_ = dpos_block_progress_;\n    }\n    void start_decoder(BaseDecoder *decoder) {\n        decoder_ = decoder;\n    }\n    CodingReturnValue do_more_work() {\n        return decoder_->decode_chunk(this);\n    }\n    template<bool force_memory_optimized>\n    void allocate_channel_framebuffer(int desired_cmp,\n                                      BlockBasedImageBase<force_memory_optimized> *framebuffer,\n                                      bool memory_optimized=force_memory_optimized) const {\n        uint64_t total_req_blocks = 0;\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            total_req_blocks += header_[cmp].info_.bcv * header_[cmp].info_.bch;\n        }\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            int bc_allocated = header_[cmp].info_.bc;\n            int64_t max_cmp_bc = max_number_of_blocks;\n            max_cmp_bc *= header_[cmp].info_.bcv;\n            max_cmp_bc *= header_[cmp].info_.bch;\n            if (total_req_blocks) {\n                max_cmp_bc /= total_req_blocks;\n            }\n            if (bc_allocated > max_cmp_bc) {\n                int rem = 0;\n                if (header_[cmp].info_.bch) {\n                    rem = (max_cmp_bc % header_[cmp].info_.bch);\n                }\n                bc_allocated = max_cmp_bc - rem;\n            }\n            if (cmp == desired_cmp) {\n                framebuffer->init(header_[cmp].info_.bch,\n                                  header_[cmp].info_.bcv,\n                                  bc_allocated,\n                                  memory_optimized);\n                break;\n            }\n        }\n    }\n    void init(Sirikata::Array1d<componentInfo, ExtendedInfo::size0> cmpinfo, int cmpc,\n              int mcuh, int mcuv, bool memory_optimized_image) {\n        mcuh_ = mcuh;\n        mcuv_ = mcuv;\n        if (cmpc > (int)ColorChannel::NumBlockTypes) {\n            cmpc = (int)ColorChannel::NumBlockTypes;\n            //abort here: we probably can't support this kind of image\n            const char * errmsg = \"We only support 3 color channels or fewer\\n\";\n            int err = write(2, errmsg, strlen(errmsg));\n            (void)err;\n            dev_assert(cmpc <= (int)ColorChannel::NumBlockTypes && \"We only support 3 color channels or less\");\n            custom_exit(ExitCode::UNSUPPORTED_4_COLORS);\n        }\n        cmpc_ = cmpc;\n        for (int cmp = 0; cmp < cmpc; cmp++) {\n            header_[cmp].info_ = cmpinfo[cmp];\n            header_[cmp].trunc_bcv_ = cmpinfo[cmp].bcv;\n            header_[cmp].trunc_bc_ = cmpinfo[cmp].bc;\n        }\n        if (!memory_optimized_image) {\n            for (int cmp = 0; cmp < (int)sizeof(header_)/(int)sizeof(header_[0]) && cmp < cmpc; cmp++) {\n                allocate_channel_framebuffer(cmp,\n                                             &this->header_[cmp].component_,\n                                             memory_optimized_image);\n            }\n        }\n    }\n    void set_block_count_dpos(ExtendedComponentInfo *ci, int trunc_bc) {\n        always_assert(ci->info_.bcv == ci->info_.bc / ci->info_.bch + (ci->info_.bc % ci->info_.bch ?  1 : 0));\n        int vertical_scanlines = std::min(trunc_bc / ci->info_.bch + (trunc_bc % ci->info_.bch ? 1 : 0), ci->info_.bcv);\n        int ratio = min_vertical_extcmp_multiple(ci);\n        while (vertical_scanlines % ratio != 0\n            && vertical_scanlines + 1 <= ci->info_.bcv) {\n            ++vertical_scanlines;\n        }\n        always_assert(vertical_scanlines <= ci->info_.bcv);\n        ci->trunc_bcv_ = vertical_scanlines;\n        ci->trunc_bc_ = trunc_bc;\n    }\n    void set_truncation_bounds(int /*max_cmp*/, int /*max_bpos*/,\n                               int max_dpos[sizeof(header_)/sizeof(header_[0])], int /*max_sah*/) {\n        for (int i = 0; i < cmpc_; ++i) {\n            set_block_count_dpos(&header_[i], max_dpos[i] + 1);\n        }\n    }\n    void wait_for_worker_on_bit(int bit) {\n        while (bit >= (bit_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n            //fprintf(stderr, \"Waiting for bit %d > %d\\n\", bit, bit_progress_ += 0);\n        }\n    }\n    void wait_for_worker_on_bpos(int bpos) {\n        while (bpos >= (coefficient_position_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n            //fprintf(stderr, \"Waiting for coefficient_position %d > %d\\n\", bpos, coefficient_position_progress_ += 0);\n        }\n    }\n    void wait_for_worker_on_dpos(int cmp, int dpos) {\n        dpos = std::min(dpos, header_[cmp].trunc_bc_ - 1);\n        while (dpos >= (header_[cmp].dpos_block_progress_ += 0)) {\n            CodingReturnValue retval = do_more_work();\n            if (retval == CODING_ERROR) {\n                dev_assert(false && \"Incorrectly coded item\");\n                custom_exit(ExitCode::CODING_ERROR);\n            }\n        }\n    }\n    void signal_worker_should_begin() {\n        //std::atomic_thread_fence(std::memory_order_release);\n         worker_start_read_signal_++;\n    }\n    unsigned int component_size_allocated(int cmp) const {\n        return header_[cmp].component_.bytes_allocated();\n    }\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes>\n        get_component_size_in_blocks() const {\n        Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> retval;\n        retval.memset(0);\n        for (int cmp = 0; cmp < cmpc_; ++cmp) {\n            retval[cmp] = header_[cmp].trunc_bc_;\n        }\n        return retval;\n    }\n    unsigned int component_size_in_blocks(int cmp) const {\n        return header_[cmp].trunc_bc_;\n    }\n    BlockBasedImage& full_component_write(BlockType cmp) {\n        return header_[(int)cmp].component_;\n    }\n    const BlockBasedImage& full_component_nosync(int cmp) const{\n        return header_[cmp].component_;\n\n    }\n    const AlignedBlock& block(BlockType cmp, int dpos) {\n        wait_for_worker_on_dpos((int)cmp, dpos);\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    const AlignedBlock& block_nosync(BlockType cmp, int dpos) const {\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    signed short at_nosync(BlockType cmp, int bpos, int dpos) const {\n        return header_[(int)cmp].component_.\n            raster(dpos).coefficients_zigzag(bpos);\n    }\n    // return the minimum luma multiple for full mcu splits in luma\n    int min_vertical_luma_multiple() const;\n    int min_vertical_cmp_multiple(int cmp) const;\n    int min_vertical_extcmp_multiple(const ExtendedComponentInfo *info) const;\n    int block_height( const int cmp ) const\n    {\n        return bcv_(cmp);\n    }\n\n    int block_width( const int cmp ) const\n    {\n        return bch_(cmp);\n    }\n    \n    int block_width( const BlockType cmp ) const\n    {\n        return bch_((int)cmp);\n    }\n    \n    void reset() {\n        bit_progress_ -= bit_progress_;\n    }\n    ~UncompressedComponents() {\n        reset();\n    }\n    static int max_number_of_blocks;\n\n\n    // the following functions are progressive-only functions (recode_jpeg)\n    // or decode-only functions (decode_jpeg, check_value_range)\n    // these are the only functions able to access the components\n    friend bool decode_jpeg(const std::vector<std::pair<uint32_t, uint32_t> >&huff_byte_offsets,\n                            std::vector<ThreadHandoff>*luma_row_offset_return);\n    friend bool recode_jpeg(void);\n    friend bool check_value_range(void);\nprivate:\n    AlignedBlock& mutable_block(BlockType cmp, int dpos) {\n        return header_[(int)cmp].component_.raster(dpos);\n    }\n    signed short at(BlockType cmp, int bpos, int dpos) {\n        wait_for_worker_on_dpos((int)cmp, dpos);\n        return header_[(int)cmp].component_.\n            raster(dpos).coefficients_zigzag(bpos);\n    }\n    signed short&set(BlockType cmp, int bpos, int dpos) {\n        return header_[(int)cmp].component_.\n            raster(dpos).mutable_coefficients_zigzag(bpos);\n    }\n\n};\n\n\n", "#ifndef MODEL_HH\n#define MODEL_HH\n\n#include <vector>\n#include <memory>\n\n#include \"../util/debug.hh\"\n#include \"../util/options.hh\"\n#include \"../util/nd_array.hh\"\n#include \"../../lepton/idct.hh\"\n#include \"numeric.hh\"\n#include \"branch.hh\"\n#include \"../util/aligned_block.hh\"\n#include \"../util/block_based_image.hh\"\n\n#ifndef USE_SCALAR\n#include <tmmintrin.h>\n#include \"../util/mm_mullo_epi32.hh\"\n#endif\n\nclass BoolEncoder;\nconstexpr bool advanced_dc_prediction = true;\nenum TableParams : unsigned int {\n    MAX_EXPONENT = 11,\n    BLOCK_TYPES = 2, // setting this to 3 gives us ~1% savings.. 2/3 from BLOCK_TYPES=2\n    NUM_NONZEROS_BINS = 10,\n    BSR_BEST_PRIOR_MAX = 11, // 1023 requires 11 bits to describe\n    band_divisor = 1,\n    COEF_BANDS = 64 / band_divisor,\n    ENTROPY_NODES = 15,\n    NUM_NONZEROS_EOB_PRIORS = 66,\n    ZERO_OR_EOB = 3,\n    RESIDUAL_NOISE_FLOOR = 7,\n    COEF_BITS = MAX_EXPONENT - 1, // the last item of the length is always 1\n};\nint get_sum_median_8(int16_t*data16i);\nvoid set_branch_range_identity(Branch *start, Branch* end);\n\ntemplate <class BranchArray> void set_branch_array_identity(BranchArray &branches) {\n    auto begin = branches.begin();\n    auto end = branches.end();\n    set_branch_range_identity(begin, end);\n    /*\n    for (;false&&begin != end; ++begin) {\n        begin->set_identity();\n    }*/\n}\nstruct Model\n{\n    typedef Sirikata::Array4d<Branch, BLOCK_TYPES, 26, 6, 32> NonzeroCounts7x7;\n    NonzeroCounts7x7 num_nonzeros_counts_7x7_;\n\n    typedef Sirikata::Array5d<Branch, BLOCK_TYPES, 8, 8, 3, 4> NonzeroCounts1x8;\n    NonzeroCounts1x8 num_nonzeros_counts_1x8_;\n    NonzeroCounts1x8 num_nonzeros_counts_8x1_;\n\n    typedef Sirikata::Array4d<Branch,\n                              BLOCK_TYPES,\n                              COEF_BANDS,\n                              (8 > NUM_NONZEROS_BINS?8:(unsigned int)NUM_NONZEROS_BINS),\n                              COEF_BITS> ResidualNoiseCounts;\n\n    ResidualNoiseCounts residual_noise_counts_;\n\n    typedef Sirikata::Array2d<Branch,\n                              NUMERIC_LENGTH_MAX,\n                              COEF_BITS> ResidualNoiseCountsDc;\n\n    ResidualNoiseCountsDc residual_noise_counts_dc_;\n\n    typedef Sirikata::Array4d<Branch,\n                              BLOCK_TYPES,\n                              (1<<(1 + RESIDUAL_NOISE_FLOOR)),\n                              1 + RESIDUAL_NOISE_FLOOR,\n                              1<<RESIDUAL_NOISE_FLOOR > ResidualThresholdCounts;\n\n    ResidualThresholdCounts residual_threshold_counts_;\n\n    typedef Sirikata::Array5d<Branch,\n                    BLOCK_TYPES,\n                    NUM_NONZEROS_BINS,\n                    15,\n                    NUMERIC_LENGTH_MAX,\n                    MAX_EXPONENT> ExponentCounts8;\n\n    typedef Sirikata::Array5d<Branch,\n                              BLOCK_TYPES,\n                              NUM_NONZEROS_BINS,\n                              49,\n                              NUMERIC_LENGTH_MAX,\n                              MAX_EXPONENT> ExponentCounts7x7;\n\ntypedef Sirikata::Array3d<Branch,\n                          ((unsigned int)NUM_NONZEROS_BINS <= (unsigned int)NUMERIC_LENGTH_MAX\n                           ? (unsigned int)NUMERIC_LENGTH_MAX : (unsigned int)NUM_NONZEROS_BINS),\n                          17/*any 16 bit number should fit*/,\n                          MAX_EXPONENT> ExponentCountsDC;\n\n  ExponentCounts7x7 exponent_counts_;\n  ExponentCounts8 exponent_counts_x_;\n  ExponentCountsDC exponent_counts_dc_;\n  void set_tables_identity() {\n      set_branch_array_identity(num_nonzeros_counts_7x7_);\n      set_branch_array_identity(num_nonzeros_counts_1x8_);\n      set_branch_array_identity(num_nonzeros_counts_8x1_);\n      set_branch_array_identity(residual_noise_counts_);\n      set_branch_array_identity(residual_noise_counts_dc_);\n      set_branch_array_identity(residual_threshold_counts_);\n      set_branch_array_identity(exponent_counts_);\n      set_branch_array_identity(exponent_counts_x_);\n      set_branch_array_identity(exponent_counts_dc_);\n      set_branch_array_identity(sign_counts_);\n  }\n  typedef Sirikata::Array3d<Branch, BLOCK_TYPES, 4, NUMERIC_LENGTH_MAX> SignCounts;\n  SignCounts sign_counts_;\n  \n  template <typename lambda>\n  void forall( const lambda & proc )\n  {\n      num_nonzeros_counts_7x7_.foreach(proc);\n      num_nonzeros_counts_1x8_.foreach(proc);\n      num_nonzeros_counts_8x1_.foreach(proc);\n      exponent_counts_x_.foreach(proc);\n      exponent_counts_.foreach(proc);\n      exponent_counts_dc_.foreach(proc);\n\n      residual_noise_counts_.foreach(proc);\n      residual_threshold_counts_.foreach(proc);\n      sign_counts_.foreach(proc);\n  }\n    enum Printability{\n        PRINTABLE_INSIGNIFICANT = 1,\n        PRINTABLE_OK = 2,\n        CLOSE_TO_50 = 4,\n        CLOSE_TO_ONE_ANOTHER = 8\n    };\n    struct PrintabilitySpecification {\n        uint64_t printability_bitmask;\n        double tolerance;\n        uint64_t min_samples;\n    };\n    const Model& debug_print(const Model* other, PrintabilitySpecification spec)const;\n\n};\n\nenum ContextTypes{\n    ZDSTSCAN,\n    ZEROS7x7,\n    EXPDC,\n    RESDC,\n    SIGNDC,\n    EXP7x7,\n    RES7x7,\n    SIGN7x7,\n    ZEROS1x8,\n    ZEROS8x1,\n    EXP8,\n    THRESH8,\n    RES8,\n    SIGN8,\n    NUMCONTEXT\n};\n#if 0\nstruct Context {\n    enum {\n        H = 2448,\n        W = 3264\n    };\n    int cur_cmp;\n    int cur_jpeg_x;\n    int cur_jpeg_y;\n    ContextTypes annot;\n    int p[3][H/8][W/8][8][8][NUMCONTEXT][3];\n};\nextern Context *gctx;\n#define ANNOTATION_ENABLED\n#define ANNOTATE_CTX(bpos,annot_type,ctxnum,value) \\\n    (gctx->annot = annot_type, \\\n     gctx->p[gctx->cur_cmp][gctx->cur_jpeg_y][gctx->cur_jpeg_x][bpos/8][bpos%8][annot_type][ctxnum] = value)\n#else\n#define ANNOTATE_CTX(bpos, annot_type, ctxnum, value)\n#endif\n\nclass Slice;\nvoid optimize_model(Model&model);\nvoid serialize_model(const Model & model, int output_fd);\nvoid reset_model(Model &model);\nvoid normalize_model(Model &model);\nvoid load_model(Model &model, const char* filename);\n#ifdef _WIN32\n#define WINALIGN16 __declspec(align(16))\n#define UNIXALIGN16\n#else\n#define WINALIGN16\n#define UNIXALIGN16 __attribute__((aligned(16)))\n#endif\nclass ProbabilityTablesBase {\nprotected:\n    Model model_;\n\n    static WINALIGN16 int32_t icos_idct_edge_8192_dequantized_x_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n    \n    static WINALIGN16 int32_t icos_idct_edge_8192_dequantized_y_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n    \n    static WINALIGN16 int32_t icos_idct_linear_8192_dequantized_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint16_t quantization_table_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint16_t freqmax_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint8_t bitlen_freqmax_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\n    static WINALIGN16 uint8_t min_noise_threshold_[(int)ColorChannel::NumBlockTypes][64] UNIXALIGN16;\n\npublic:\n    Model &model() {return model_;}\n    void load_probability_tables();\n    static uint16_t* quantization_table(uint8_t color) {\n        return quantization_table_[color];\n    }\n\n    static uint16_t quantization_table(uint8_t color, uint8_t coef) {\n        return quantization_table_[color][coef];\n    }\n    static uint16_t freqmax(uint8_t color, uint8_t coef) {\n        return freqmax_[color][coef];\n    }\n    static uint8_t bitlen_freqmax(uint8_t color, uint8_t coef) {\n        return bitlen_freqmax_[color][coef];\n    }\n    static uint8_t min_noise_threshold(uint8_t color, uint8_t coef) {\n        return min_noise_threshold_[color][coef];\n    }\n    static void set_quantization_table(BlockType color, const unsigned short quantization_table[64]) {\n        for (int i = 0; i < 64; ++i) {\n            quantization_table_[(int)color][i] = quantization_table[zigzag[i]];\n        }\n        for (int pixel_row = 0; pixel_row < 8; ++pixel_row) {\n            for (int i = 0; i < 8; ++i) {\n                icos_idct_linear_8192_dequantized((int)color)[pixel_row * 8 + i] = icos_idct_linear_8192_scaled[pixel_row * 8 + i] * quantization_table_[(int)color][i];\n                icos_idct_edge_8192_dequantized_x((int)color)[pixel_row * 8 + i] = icos_base_8192_scaled[i * 8] * quantization_table_[(int)color][i * 8 + pixel_row];\n                icos_idct_edge_8192_dequantized_y((int)color)[pixel_row * 8 + i] = icos_base_8192_scaled[i * 8] * quantization_table_[(int)color][pixel_row * 8 + i];\n            }\n        }\n        static const unsigned short int freqmax[] =\n        {\n            1024, 931, 985, 968, 1020, 968, 1020, 1020,\n            932, 858, 884, 840, 932, 838, 854, 854,\n            985, 884, 871, 875, 985, 878, 871, 854,\n            967, 841, 876, 844, 967, 886, 870, 837,\n            1020, 932, 985, 967, 1020, 969, 1020, 1020,\n            969, 838, 878, 886, 969, 838, 969, 838,\n            1020, 854, 871, 870, 1010, 969, 1020, 1020,\n            1020, 854, 854, 838, 1020, 838, 1020, 838\n        };\n        for (int coord = 0; coord < 64; ++coord) {\n            freqmax_[(int)color][coord] = (freqmax[coord] + quantization_table_[(int)color][coord] - 1);\n            if (quantization_table_[(int)color][coord]) {\n                freqmax_[(int)color][coord] /= quantization_table_[(int)color][coord];\n            }\n            uint8_t max_len = uint16bit_length(freqmax_[(int)color][coord]);\n            bitlen_freqmax_[(int)color][coord] = max_len;\n            if (max_len > (int)RESIDUAL_NOISE_FLOOR) {\n                min_noise_threshold_[(int)color][coord] = max_len - RESIDUAL_NOISE_FLOOR;\n            }\n        }\n    }\n    static int32_t *icos_idct_edge_8192_dequantized_x(int color) {\n        return icos_idct_edge_8192_dequantized_x_[(int)color];\n    }\n    static int32_t *icos_idct_edge_8192_dequantized_y(int color) {\n        return icos_idct_edge_8192_dequantized_y_[(int)color];\n    }\n    static int32_t *icos_idct_linear_8192_dequantized(int color) {\n        return icos_idct_linear_8192_dequantized_[(int)color];\n    }\n    struct CoefficientContext {\n        int best_prior; //lakhani or aavrg depending on coefficient number\n        uint8_t num_nonzeros_bin; // num_nonzeros mapped into a bin\n        uint8_t bsr_best_prior;\n    };\n    enum {\n        VECTORIZE = ::VECTORIZE,\n        MICROVECTORIZE = ::MICROVECTORIZE\n    };\n};\n\n#define USE_TEMPLATIZED_COLOR\n#ifdef USE_TEMPLATIZED_COLOR\n#define TEMPLATE_ARG_COLOR0 BlockType::Y\n#define TEMPLATE_ARG_COLOR1 BlockType::Cb\n#define TEMPLATE_ARG_COLOR2 BlockType::Cr\n#define TEMPLATE_ARG_COLOR3 BlockType::Ck\n\n#else\n#define TEMPLATE_ARG_COLOR0 BlockType::Y\n#define TEMPLATE_ARG_COLOR1 BlockType::Y\n#define TEMPLATE_ARG_COLOR2 BlockType::Y\n#define TEMPLATE_ARG_COLOR3 BlockType::Y\n#endif\ntemplate <bool all_present, BlockType\n#ifdef USE_TEMPLATIZED_COLOR\n              color\n#else\n              deprecated_color\n#endif\n>\nclass ProbabilityTables\n{\nprivate:\n    typedef ProbabilityTablesBase::CoefficientContext CoefficientContext;\n    const bool left_present;\n    const bool above_present;\n    const bool above_right_present;\npublic:\n#ifdef USE_TEMPLATIZED_COLOR\n    enum {\n        COLOR = (int)color\n    };\n    ProbabilityTables(BlockType kcolor,\n                      bool in_left_present,\n                      bool in_above_present,\n                      bool in_above_right_present)\n        : left_present(in_left_present),\n          above_present(in_above_present),\n          above_right_present(in_above_right_present) {\n       always_assert((left_present && above_present && above_right_present) == all_present);\n       always_assert(kcolor == color);\n    }\n#else\n    const BlockType COLOR;\n    ProbabilityTables(BlockType color,\n                      bool in_left_present,\n                      bool in_above_present,\n                      bool in_above_right_present)\n        : left_present(in_left_present),\n          above_present(in_above_present),\n          above_right_present(in_above_right_present),\n          COLOR(color) {\n        always_assert((left_present && right_present && above_right_present) == all_present);\n        static_assert((int)deprecated_color == 0, \"Using dynamic color\");\n    }\n#endif\n    void reset(ProbabilityTablesBase&base) {\n        reset_model(base.model());\n    }\n    void load(ProbabilityTablesBase&base, const char * filename) {\n        load_model(base.model(), filename);\n    }\n    int color_index() {\n        if (BLOCK_TYPES == 2) {\n            if (0 == (int)COLOR) {\n                return 0;\n            }\n            return 1;\n        } else {\n            return std::min((int)(BLOCK_TYPES - 1), (int)COLOR);\n        }\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context7x7(int coord,\n                                       int aligned_zz,\n                                       const ConstBlockContext block, uint8_t num_nonzeros_left) {\n        ProbabilityTablesBase::CoefficientContext retval;\n        retval.best_prior = compute_aavrg(coord, aligned_zz, block);\n        retval.num_nonzeros_bin = num_nonzeros_to_bin(num_nonzeros_left);\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context7x7_precomp(int aligned_zz,\n                                       int aavrg,\n                                       const ConstBlockContext block, uint8_t num_nonzeros_left) {\n        ProbabilityTablesBase::CoefficientContext retval;\n        dev_assert(aavrg == compute_aavrg(aligned_to_raster.at(aligned_zz), aligned_zz, block));\n        //This was to make sure the code was right compute_aavrg_vec(aligned_zz, block);\n        retval.best_prior = aavrg;\n        retval.num_nonzeros_bin = num_nonzeros_to_bin(num_nonzeros_left);\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n#ifndef USE_SCALAR\n        if (MICROVECTORIZE) {\n            retval.best_prior = (coefficient & 7)\n            ? compute_lak_horizontal(block, coefficient) : compute_lak_vertical(block, coefficient);\n        } else {\n            retval.best_prior = compute_lak(block, coefficient);\n        }\n#else\n        retval.best_prior = compute_lak(block, coefficient);\n#endif\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n#ifndef USE_SCALAR\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_horiz(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n        retval.best_prior = compute_lak_horizontal(block, coefficient);\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_vert(uint8_t coefficient,\n                                                   const ConstBlockContext block, uint8_t num_nonzeros_x) {\n        CoefficientContext retval = {0, 0, 0};\n        retval.best_prior = compute_lak_vertical(block, coefficient);\n        retval.num_nonzeros_bin = num_nonzeros_x;\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023));\n        return retval;\n    }\n\n#define INSTANTIATE_TEMPLATE_METHOD(N)  \\\n    ProbabilityTablesBase::CoefficientContext update_coefficient_context8_templ##N(const ConstBlockContext block, \\\n                                                   uint8_t num_nonzeros_x) { \\\n        ProbabilityTablesBase::CoefficientContext retval = {0, 0, 0};     \\\n        retval.best_prior = compute_lak_templ<N>(block); \\\n        retval.num_nonzeros_bin = num_nonzeros_x; \\\n        retval.bsr_best_prior = bit_length(std::min(abs(retval.best_prior), 1023)); \\\n        return retval; \\\n    }\n    INSTANTIATE_TEMPLATE_METHOD(1)\n    INSTANTIATE_TEMPLATE_METHOD(2)\n    INSTANTIATE_TEMPLATE_METHOD(3)\n    INSTANTIATE_TEMPLATE_METHOD(4)\n    INSTANTIATE_TEMPLATE_METHOD(5)\n    INSTANTIATE_TEMPLATE_METHOD(6)\n    INSTANTIATE_TEMPLATE_METHOD(7)\n    INSTANTIATE_TEMPLATE_METHOD(8)\n    INSTANTIATE_TEMPLATE_METHOD(16)\n    INSTANTIATE_TEMPLATE_METHOD(24)\n    INSTANTIATE_TEMPLATE_METHOD(32)\n    INSTANTIATE_TEMPLATE_METHOD(40)\n    INSTANTIATE_TEMPLATE_METHOD(48)\n    INSTANTIATE_TEMPLATE_METHOD(56)\n#endif\n\n    Sirikata::Array2d<Branch, 6, 32>::Slice nonzero_counts_7x7(ProbabilityTablesBase &pt,\n                                                               const ConstBlockContext block) {\n        uint8_t num_nonzeros_above = 0;\n        uint8_t num_nonzeros_left = 0;\n        if (all_present || above_present) {\n            num_nonzeros_above = block.nonzeros_above_7x7_unchecked();\n        }\n        if (all_present || left_present) {\n            num_nonzeros_left = block.nonzeros_left_7x7_unchecked();\n        }\n\n        uint8_t num_nonzeros_context = 0;\n        if ((!all_present) && above_present && !left_present) {\n            num_nonzeros_context = (num_nonzeros_above + 1) / 2;\n        } else if ((!all_present) && left_present && !above_present) {\n            num_nonzeros_context = (num_nonzeros_left + 1) / 2;\n        } else if (all_present || (left_present && above_present)) {\n            num_nonzeros_context = (num_nonzeros_above + num_nonzeros_left + 2) / 4;\n        }\n        ANNOTATE_CTX(0, ZEROS7x7, 0, num_nonzeros_context);\n        return pt.model().num_nonzeros_counts_7x7_.at(color_index(),\n                                                      num_nonzeros_to_bin(num_nonzeros_context));\n    }\n    Sirikata::Array2d<Branch, 3u, 4u>::Slice x_nonzero_counts_8x1(ProbabilityTablesBase &pt,\n                                                          unsigned int eob_x,\n                                                          unsigned int num_nonzeros) {\n        ANNOTATE_CTX(0, ZEROS8x1, 0, ((num_nonzeros + 3) / 7));\n        ANNOTATE_CTX(0, ZEROS8x1, 1, eob_x);\n        return pt.model().num_nonzeros_counts_8x1_.at(color_index(), eob_x, ((num_nonzeros + 3) / 7));\n    }\n    Sirikata::Array2d<Branch, 3u, 4u>::Slice y_nonzero_counts_1x8(ProbabilityTablesBase &pt,\n                                                          unsigned int eob_x,\n                                                          unsigned int num_nonzeros) {\n        ANNOTATE_CTX(0, ZEROS1x8, 0, ((num_nonzeros + 3) / 7));\n        ANNOTATE_CTX(0, ZEROS1x8, 1, eob_x);\n        return pt.model().num_nonzeros_counts_1x8_.at(color_index(), eob_x, ((num_nonzeros + 3) / 7));\n    }\n    Sirikata::Array1d<Branch, MAX_EXPONENT>::Slice exponent_array_x(ProbabilityTablesBase &pt, int band, int zig15, CoefficientContext context) {\n        ANNOTATE_CTX(band, EXP8, 0, context.bsr_best_prior);\n        ANNOTATE_CTX(band, EXP8, 1, context.num_nonzeros);\n        dev_assert((band & 7)== 0 ? ((band >>3) + 7) : band - 1 == zig15);\n        return pt.model().exponent_counts_x_.at(color_index(),\n                                             context.num_nonzeros_bin,\n                                             zig15,\n                                             context.bsr_best_prior);\n    }\n    Sirikata::Array1d<Branch, MAX_EXPONENT>::Slice exponent_array_7x7(ProbabilityTablesBase &pt,\n                                                                      const unsigned int band,\n                                                                      const unsigned int zig49,\n                                                                      const CoefficientContext context) {\n        ANNOTATE_CTX(band, EXP7x7, 0, context.bsr_best_prior);\n        ANNOTATE_CTX(band, EXP7x7, 1, context.num_nonzeros_bin);\n        return pt.model().exponent_counts_.at(color_index(),\n            context.num_nonzeros_bin,\n            zig49,\n            context.bsr_best_prior);\n    }\n    Sirikata::Array1d<Branch,\n                      MAX_EXPONENT>::Slice exponent_array_dc(ProbabilityTablesBase &pt,\n\t\t\t\t\t\t\t     uint16_t len_abs_mxm,\n\t\t\t\t\t\t\t     uint16_t len_abs_offset_to_closest_edge) {\n        return pt.model().exponent_counts_dc_.\n\t  at(std::min(len_abs_mxm,\n\t\t      (uint16_t)(Model::ExponentCountsDC::size0 - 1)),\n\t     std::min(len_abs_offset_to_closest_edge,\n\t\t      (uint16_t)(Model::ExponentCountsDC::size1 - 1)));\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_array_dc(ProbabilityTablesBase &pt,\n                                                                     uint16_t len_abs_mxm\n                                                                  , uint16_t len_abs_offset_to_closest_edge) {\n        return pt.model().residual_noise_counts_dc_\n\t  .at(std::min((uint16_t)(Model::ResidualNoiseCountsDc::size0 - 1),\n\t\t       len_abs_mxm));\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_x(ProbabilityTablesBase &pt,\n                                                          const unsigned int band,\n                                                          const CoefficientContext context) {\n        ANNOTATE_CTX(band, RES8, 0, num_nonzeros_x);\n        return residual_noise_array_shared(pt, band,\n                                           context);\n    }\n\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_shared(ProbabilityTablesBase &pt,\n                                                            const unsigned int band,\n                                                            const CoefficientContext context) {\n        return pt.model().residual_noise_counts_.at(color_index(),\n                                                 band/band_divisor,\n                                                 context.num_nonzeros_bin);\n    }\n    Sirikata::Array1d<Branch, COEF_BITS>::Slice residual_noise_array_7x7(ProbabilityTablesBase &pt,\n                                                            const unsigned int band,\n                                                            const CoefficientContext context) {\n        if (band == 0) {\n            ANNOTATE_CTX(0, RESDC, 0, num_nonzeros_to_bin(num_nonzeros));\n        } else {\n            ANNOTATE_CTX(band, RES7x7, 0, num_nonzeros_to_bin(num_nonzeros));\n        }\n        return residual_noise_array_shared(pt, band, context);\n    }\n    unsigned int num_nonzeros_to_bin(uint8_t num_nonzeros) {\n        return nonzero_to_bin[NUM_NONZEROS_BINS-1][num_nonzeros];\n    }\n    int idct_2d_8x1(const AlignedBlock&block, bool ignore_first, int pixel_row) {\n        int retval = 0;\n        if (!ignore_first) {\n            retval = block.coefficients_raster(0) * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 0];\n        }\n        retval += block.coefficients_raster(1)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 1];\n        retval += block.coefficients_raster(2)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 2];\n        retval += block.coefficients_raster(3)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 3];\n        retval += block.coefficients_raster(4)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 4];\n        retval += block.coefficients_raster(5)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 5];\n        retval += block.coefficients_raster(6)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 6];\n        retval += block.coefficients_raster(7)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 7];\n        return retval;\n    }\n\n    int idct_2d_1x8(const AlignedBlock&block, bool ignore_first, int pixel_row) {\n        int retval = 0;\n        if (!ignore_first) {\n            retval = block.dc() * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 0];\n        }\n        retval += block.coefficients_raster(8)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 1];\n        retval += block.coefficients_raster(16)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 2];\n        retval += block.coefficients_raster(24)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 3];\n        retval += block.coefficients_raster(32)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 4];\n        retval += block.coefficients_raster(40)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 5];\n        retval += block.coefficients_raster(48)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 6];\n        retval += block.coefficients_raster(56)\n            * ProbabilityTablesBase::icos_idct_linear_8192_dequantized((int)COLOR)[pixel_row * 8 + 7];\n        return retval;\n    }\n\n    int predict_dc_dct(const ConstBlockContext&context) {\n        int prediction = 0;\n        int left_block = 0;\n        int left_edge = 0;\n        int above_block = 0;\n        int above_edge = 0;\n        if (all_present || left_present) {\n            left_block = idct_2d_8x1(context.left_unchecked(), 0, 7);\n            left_edge = idct_2d_8x1(context.here(), 1, 0);\n        }\n        if (all_present || above_present) {\n            above_block = idct_2d_1x8(context.above_unchecked(), 0, 7);\n            above_edge = idct_2d_1x8(context.here(), 1, 0);\n        }\n        if (all_present || left_present) {\n            if (all_present || above_present) {\n                prediction = ( ( left_block - left_edge ) + (above_block - above_edge) ) * 4;\n            } else {\n                prediction = ( left_block - left_edge ) * 8;\n            }\n        } else if (above_present) {\n            prediction = ( above_block - above_edge ) * 8;\n        }\n        int DCT_RSC = 8192;\n        prediction = std::max(-1024 * DCT_RSC, std::min(1016 * DCT_RSC, prediction));\n        prediction /= ProbabilityTablesBase::quantization_table((int)COLOR, 0);\n        int round = DCT_RSC/2;\n        if (prediction < 0) {\n            round = -round;\n        }\n        return (prediction + round) / DCT_RSC;\n    }\n    int predict_locoi_dc_deprecated(const ConstBlockContext&context) {\n        if (all_present || left_present) {\n            int a = context.left_unchecked().dc();\n            if (all_present || above_present) {\n                int b = context.above_unchecked().dc();\n                int c = context.above_left_unchecked().dc();\n                if (c >= std::max(a,b)) {\n                    return std::min(a,b);\n                } else if (c <= std::min(a,b)) {\n                    return std::max(a,b);\n                }\n                return a + b - c;\n            }else { \n                return a;\n            }\n        } else if (above_present) {\n            return context.above_unchecked().dc();\n        } else {\n            return 0;\n        }\n    }\n    int predict_or_unpredict_dc(const ConstBlockContext&context, bool recover_original) {\n        int max_value = (1 << (1 + MAX_EXPONENT)) - 1;\n        int min_value = -max_value;\n        int adjustment_factor = 2 * max_value + 1;\n        int retval = //predict_locoi_dc_deprecated(block);\n            predict_dc_dct(context);\n        retval = context.here().dc() + (recover_original ? retval : -retval);\n        if (retval < min_value) retval += adjustment_factor;\n        if (retval > max_value) retval -= adjustment_factor;\n        return retval;\n    }\n#define shift_right_round_zero_epi16(vec, imm8) (_mm_sign_epi16(_mm_srli_epi16(_mm_sign_epi16(vec, vec), imm8), vec));\n    int adv_predict_dc_pix(const ConstBlockContext&context, int16_t*pixels_sans_dc, int32_t *uncertainty_val, int32_t *uncertainty2_val) {\n        uint16_t *q = ProbabilityTablesBase::quantization_table((int)color);\n        idct(context.here(), q, pixels_sans_dc, true);\n\n        Sirikata::AlignedArray1d<int16_t, 16> dc_estimates;\n        dc_estimates.memset(0);\n        int32_t avgmed = 0;\n        if(all_present || left_present || above_present) {\n#ifndef USE_SCALAR\n            if (all_present || above_present) { //above goes first to prime the cache\n                __m128i neighbor_above = _mm_loadu_si128((const __m128i*)(const char*)context\n                                                         .neighbor_context_above_unchecked()\n                                                         .horizontal_ptr());\n                __m128i pixels_sans_dc_reg = _mm_loadu_si128((const __m128i*)(const char*)pixels_sans_dc);\n                __m128i pixels2_sans_dc_reg = _mm_loadu_si128((const __m128i*)(const char*)(pixels_sans_dc + 8));\n                __m128i pixels_delta = _mm_sub_epi16(pixels_sans_dc_reg,\n                                                     pixels2_sans_dc_reg);\n                __m128i pixels_delta_div2 = shift_right_round_zero_epi16(pixels_delta, 1);\n                __m128i pixels_sans_dc_recentered = _mm_add_epi16(pixels_sans_dc_reg,\n                                                                  _mm_set1_epi16(1024));\n                __m128i above_dc_estimate = _mm_sub_epi16(_mm_sub_epi16(neighbor_above, pixels_delta_div2),\n                                                          pixels_sans_dc_recentered);\n\n                _mm_store_si128((__m128i*)(char*)(dc_estimates.begin()\n                                                  + ((all_present || left_present) ? 8 : 0)),\n                                above_dc_estimate);\n            }\n            if (all_present || left_present) {\n                const int16_t * horiz_data = context.neighbor_context_left_unchecked().vertical_ptr_except_7();\n                __m128i neighbor_horiz = _mm_loadu_si128((const __m128i*)(const char*)horiz_data);\n                //neighbor_horiz = _mm_insert_epi16(neighbor_horiz, horiz_data[NeighborSummary::VERTICAL_LAST_PIXEL_OFFSET_FROM_FIRST_PIXEL], 7);\n                __m128i pixels_sans_dc_reg = _mm_set_epi16(pixels_sans_dc[56],\n                                                           pixels_sans_dc[48],\n                                                           pixels_sans_dc[40],\n                                                           pixels_sans_dc[32],\n                                                           pixels_sans_dc[24],\n                                                           pixels_sans_dc[16],\n                                                           pixels_sans_dc[8],\n                                                           pixels_sans_dc[0]);\n                __m128i pixels_delta = _mm_sub_epi16(pixels_sans_dc_reg,\n                                                     _mm_set_epi16(pixels_sans_dc[57],\n                                                                   pixels_sans_dc[49],\n                                                                   pixels_sans_dc[41],\n                                                                   pixels_sans_dc[33],\n                                                                   pixels_sans_dc[25],\n                                                                   pixels_sans_dc[17],\n                                                                   pixels_sans_dc[9],\n                                                                   pixels_sans_dc[1]));\n\n                __m128i pixels_delta_div2 = shift_right_round_zero_epi16(pixels_delta, 1);\n                __m128i left_dc_estimate = _mm_sub_epi16(_mm_sub_epi16(neighbor_horiz, pixels_delta_div2),\n                                                          _mm_add_epi16(pixels_sans_dc_reg,\n                                                                        _mm_set1_epi16(1024)));\n\n                _mm_store_si128((__m128i*)(char*)dc_estimates.begin(), left_dc_estimate);\n            }\n#else\n            if (all_present || left_present) {\n                for (int i = 0; i < 8;++i) {\n                    int a = pixels_sans_dc[i << 3] + 1024;\n                    int pixel_delta = pixels_sans_dc[i << 3] - pixels_sans_dc[(i << 3) + 1];\n                    int b = context.neighbor_context_left_unchecked().vertical(i) - (pixel_delta / 2); //round to zero\n                    dc_estimates[i] = b - a;\n                }\n            }\n            if (all_present || above_present) {\n                for (int i = 0; i < 8;++i) {\n                    int a = pixels_sans_dc[i] + 1024;\n                    int pixel_delta = pixels_sans_dc[i] - pixels_sans_dc[i + 8];\n                    int b = context.neighbor_context_above_unchecked().horizontal(i) - (pixel_delta / 2); //round to zero\n                    dc_estimates[i + ((all_present || left_present) ? 8 : 0)] = b - a;\n                }\n            }\n#endif\n            int32_t avg_h_v[2] = {0, 0};\n            int32_t min_dc = dc_estimates[0];\n            int32_t max_dc = dc_estimates[0];\n            size_t which_est = 0;\n            for (int vert = 0; vert != 2; ++vert) {\n                for (int i = 0; i < 8; ++which_est, ++i) {\n                    int16_t cur_est = dc_estimates[which_est];\n                    avg_h_v[vert] += cur_est;\n                    if (min_dc > cur_est) {\n                        min_dc = cur_est;\n                    }\n                    if (max_dc < cur_est) {\n                        max_dc = cur_est;\n                    }\n                }\n                if ((!all_present) && (above_present == false || left_present == false)) {\n                    avg_h_v[1] = avg_h_v[0];\n                    break;\n                }\n            }\n            int32_t overall_avg = (avg_h_v[0] + avg_h_v[1]) >> 1;\n            avgmed = overall_avg;\n            *uncertainty_val = (max_dc - min_dc)>>3;\n            avg_h_v[0] -= avgmed;\n            avg_h_v[1] -= avgmed;\n            int32_t far_afield_value = avg_h_v[1];\n            if (abs(avg_h_v[0]) < abs(avg_h_v[1])) {\n                far_afield_value = avg_h_v[0];\n            }\n            *uncertainty2_val = (far_afield_value) >> 3;\n\n            if (false) { // this is to debug some of the differences\n                debug_print_deltas(context, dc_estimates.begin(), avgmed);\n            }\n        }\n        return ((avgmed / q[0] + 4) >> 3);\n    }\n    void debug_print_deltas(const ConstBlockContext&context, int16_t *dc_estimates, int avgmed) {\n        int actual_dc = context.here().dc();\n        uint16_t *q = ProbabilityTablesBase::quantization_table((int)color);\n        int len_est = ((all_present || (left_present && above_present)) ? 16 : 8);\n        int avg_estimated_dc = 0;\n        int dc_sum = 0;\n        for (int i = 0 ;i < len_est; ++i) {\n            dc_sum += dc_estimates[i];\n        }\n        avg_estimated_dc = dc_sum;\n        if (all_present || (left_present && above_present)) {\n            avg_estimated_dc >>= 1;\n        }\n        \n        avg_estimated_dc = (avg_estimated_dc/q[0] + xIDCTSCALE / 2) >> 3;\n        int16_t dc_copy[16];\n        memcpy(dc_copy, dc_estimates, len_est*sizeof(int16_t));\n        std::sort(dc_copy, dc_copy + len_est);\n        int mmed = dc_copy[len_est/2];\n        int scaled_med = (mmed/q[0] + 4);\n        int scaled_avgmed = (((avgmed/q[0]) + 4) >> 3);\n        using namespace LeptonDebug;\n        LeptonDebug::med_err += abs(scaled_med - actual_dc);\n        LeptonDebug::amd_err += abs(scaled_avgmed - actual_dc);\n        LeptonDebug::avg_err += abs(avg_estimated_dc - actual_dc);\n        int locoi_pred = predict_locoi_dc_deprecated(context);\n        int predicted_dc = predict_dc_dct(context);\n        LeptonDebug::ori_err += abs(predicted_dc - actual_dc);\n        LeptonDebug::loc_err += abs(locoi_pred - actual_dc);\n\n        fprintf(stderr, \"MXM: %d\\n\", dc_estimates[len_est - 1] - dc_estimates[0]);\n        fprintf(stderr, \"MED: %d (%d)\\n\", scaled_med, LeptonDebug::med_err);\n        fprintf(stderr, \"AMD: %d (%d)\\n\", scaled_avgmed, LeptonDebug::amd_err);\n        fprintf(stderr, \"AVG: %d (%d)\\n\", avg_estimated_dc, LeptonDebug::avg_err);\n        fprintf(stderr, \"ORI: %d (%d)\\n\", predicted_dc, LeptonDebug::ori_err);\n        fprintf(stderr, \"LOC: %d (%d)\\n\", locoi_pred, LeptonDebug::loc_err);\n        fprintf(stderr, \"DC : %d\\n\", actual_dc);\n    }\n    int adv_predict_or_unpredict_dc(int16_t saved_dc, bool recover_original, int predicted_val) {\n        int max_value = (1 << (MAX_EXPONENT - 1));\n        int min_value = -max_value;\n        int adjustment_factor = 2 * max_value + 1;\n        int retval = predicted_val;\n        retval = saved_dc + (recover_original ? retval : -retval);\n        if (retval < min_value) retval += adjustment_factor;\n        if (retval > max_value) retval -= adjustment_factor;\n        return retval;\n    }\n    int compute_aavrg_dc(ConstBlockContext context) {\n        return compute_aavrg(0, raster_to_aligned.at(0), context);\n        \n        uint32_t total = 0;\n        if (all_present || left_present) {\n            total += abs(context.left_unchecked().dc());\n        }\n        if (all_present || above_present) {\n            total += abs(context.above_unchecked().dc());\n        }\n        if (all_present || (left_present && above_present)) {\n            constexpr unsigned int log_weight = 5;\n            total *= 13;\n            total += 6 * abs(context.above_left_unchecked().dc());\n            return total >> log_weight;\n        } else {\n            return total;\n        }\n    }\n    int16_t compute_aavrg(unsigned int coord, unsigned int aligned_zz, ConstBlockContext context) {\n        int16_t total = 0;\n        if (all_present || left_present) {\n            total += abs(context.left_unchecked().coefficients_raster(coord));\n        }\n        if (all_present || above_present) {\n            total += abs(context.above_unchecked().coefficients_raster(coord));\n        }\n        if (all_present || (left_present && above_present)) {\n            constexpr unsigned int log_weight = 5;\n            total *= 13;\n            total += 6 * abs(context.above_left_unchecked().coefficients_raster(coord));\n            return ((uint16_t)total) >> log_weight;\n        } else {\n            return total;\n        }\n        //if (block.context().above_right.initialized()) {\n        //total += abs(block.context().above_right.get()->coefficients().at(0));\n        //}\n    }\n#if defined(OPTIMIZED_7x7) && !defined(USE_SCALAR)\n    bool aavrg_vec_matches(__m128i retval, unsigned int aligned_zz, ConstBlockContext context) {\n        short ret[8];\n        _mm_storeu_si128((__m128i*)(char*)ret, retval);\n        short correct[8] = {compute_aavrg(aligned_to_raster.at(aligned_zz), aligned_zz +0, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+1), aligned_zz + 1, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+2), aligned_zz + 2, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+3), aligned_zz + 3, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+4), aligned_zz + 4, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+5), aligned_zz + 5, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+6), aligned_zz + 6, context),\n            compute_aavrg(aligned_to_raster.at(aligned_zz+7), aligned_zz + 7, context)};\n        return (memcmp(ret, correct, sizeof(correct)) == 0);\n    }\n    void compute_aavrg_vec(unsigned int aligned_zz, ConstBlockContext context, short* aligned_retval) {\n        _mm_store_si128((__m128i*)(char*)aligned_retval, compute_aavrg_vec(aligned_zz, context));\n    }\n#if defined (__clang__) || defined(__GNUC__)\n#define x_mm_loadu_si64(a) _mm_set1_epi64x(*(uint64_t*)(char*)(a))\n#else\n#define x_mm_loadu_si64 _mm_loadu_si64\n#endif\n\n    __m128i compute_aavrg_vec(unsigned int aligned_zz, ConstBlockContext context) {\n        if (all_present == false && left_present == false && above_present == false) {\n            return _mm_setzero_si128();\n        }\n        __m128i left;\n        if (all_present || left_present) {\n            left = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.left_unchecked().coef.at(aligned_zz)));\n            if ((!all_present) && !above_present) {\n                return left;\n            }\n        }\n        __m128i above = _mm_setzero_si128();\n        if (all_present || above_present) {\n            above = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.above_unchecked().coef.at(aligned_zz)));\n            if (all_present == false && !left_present) {\n                return above;\n            }\n        }\n        constexpr unsigned int log_weight = 5;\n        __m128i total = _mm_add_epi16(left, above);\n        total = _mm_mullo_epi16(total, _mm_set1_epi16(13)); // approximate (a*2+b*2 + c)/5 as (a *13 + b * 13 + c * 6)/32\n        __m128i aboveleft = _mm_abs_epi16(_mm_load_si128((const __m128i*)(const char*)&context.above_left_unchecked().coef.at(aligned_zz)));\n        total = _mm_add_epi16(total, _mm_mullo_epi16(aboveleft, _mm_set1_epi16(6)));\n        __m128i retval = _mm_srli_epi16(total, log_weight);\n        dev_assert(aavrg_vec_matches(retval, aligned_zz, context));\n        return retval;\n        //if (block.context().above_right.initialized()) {\n        //total += abs(block.context().above_right.get()->coefficients().at(0));\n        //}\n    }\n#endif\n\n#ifndef USE_SCALAR\n    static int32_t compute_lak_vec(__m128i coeffs_x_low, __m128i coeffs_x_high, __m128i coeffs_a_low, __m128i \n#ifdef _WIN32\n        &\n#endif\n        indirect_coeffs_a_high, const int32_t *icos_deq) {\n        __m128i sign_mask = _mm_set_epi32(-1, 1, -1, 1); // ((i & 1) ? -1 : 1)\n\n        //coeffs_x[i] = ((i & 1) ? -1 : 1) * coeffs_a[i] - coeffs_x[i];\n        coeffs_a_low = _mm_sign_epi32(coeffs_a_low, sign_mask);\n        __m128i coeffs_a_high = _mm_sign_epi32(indirect_coeffs_a_high, sign_mask);\n        coeffs_x_low = _mm_sub_epi32(coeffs_a_low, coeffs_x_low);\n        coeffs_x_high = _mm_sub_epi32(coeffs_a_high, coeffs_x_high);\n\n        __m128i icos_low = _mm_load_si128((const __m128i*)(const char*)icos_deq);\n        __m128i icos_high = _mm_load_si128((const __m128i*)(const char*)(icos_deq + 4));\n        // coeffs_x[i] *= icos[i]\n        __m128i deq_low = _mm_mullo_epi32(coeffs_x_low, icos_low);\n        __m128i deq_high = _mm_mullo_epi32(coeffs_x_high, icos_high);\n\n        __m128i sum = _mm_add_epi32(deq_low, deq_high);\n        sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 8));\n        sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 4));\n        // coeffs_x[0] = sum(coeffs_x)\n        int32_t prediction = _mm_cvtsi128_si32(sum);\n        //if (prediction > 0) { <-- rounding hurts prediction perf and costs compute  this rounding didn't round the same way as the unvectorized one anyhow\n        //    prediction += icos_deq[0]/2;\n        //} else {\n        //    prediction -= icos_deq[0]/2; // round away from zero\n        //}\n        return prediction / icos_deq[0];\n    }\n\n#define ITER(x_var, a_var, i, step) \\\n        (x_var = _mm_set_epi32(   context.here().coefficients_raster(band + step * ((i) + 3)), \\\n                                  context.here().coefficients_raster(band + step * ((i) + 2)), \\\n                                  context.here().coefficients_raster(band + step * ((i) + 1)), \\\n                                  i == 0 ? 0 : context.here().coefficients_raster(band + step * (i))), \\\n         a_var = _mm_set_epi32(neighbor.coefficients_raster(band + step * ((i) + 3)), \\\n                                  neighbor.coefficients_raster(band + step * ((i) + 2)), \\\n                                  neighbor.coefficients_raster(band + step * ((i) + 1)), \\\n                                  neighbor.coefficients_raster(band + step * (i))))\n    \n    template<int band>\n#ifndef _WIN32\n    __attribute__((always_inline))\n#endif\n    int32_t compute_lak_templ(const ConstBlockContext&context) {\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        const int32_t * icos = nullptr;\n        static_assert((band & 7) == 0 || (band >> 3) == 0, \"This function only works on edges\");\n        if ((band >> 3) == 0) {\n            if(all_present == false && !above_present) {\n                return 0;\n            }\n            const auto &neighbor = context.above_unchecked();\n            ITER(coeffs_x_low, coeffs_a_low, 0, 8);\n            ITER(coeffs_x_high, coeffs_a_high, 4, 8);\n            icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        } else {\n            if (all_present == false && !left_present) {\n                return 0;\n            }\n            const auto &neighbor = context.left_unchecked();\n            ITER(coeffs_x_low, coeffs_a_low, 0, 1);\n            ITER(coeffs_x_high, coeffs_a_high, 4, 1);\n            icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        }\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high, icos);\n    }\n    int32_t compute_lak_horizontal(const ConstBlockContext&context, unsigned int band) {\n        if (all_present == false && !above_present) {\n            return 0;\n        }\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        dev_assert(band/8 == 0 && \"this function only works for the top edge\");\n        const auto &neighbor = context.above_unchecked();\n        ITER(coeffs_x_low, coeffs_a_low, 0, 8);\n        ITER(coeffs_x_high, coeffs_a_high, 4, 8);\n        const int32_t * icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high, icos);\n    }\n    int32_t compute_lak_vertical(const ConstBlockContext&context, unsigned int band) {\n        dev_assert((band & 7) == 0 && \"Must be used for veritcal\");\n        if (all_present == false && !left_present) {\n            return 0;\n        }\n        __m128i coeffs_x_low;\n        __m128i coeffs_x_high;\n        __m128i coeffs_a_low;\n        __m128i coeffs_a_high;\n        const auto &neighbor = context.left_unchecked();\n        ITER(coeffs_x_low, coeffs_a_low, 0, 1);\n        ITER(coeffs_x_high, coeffs_a_high, 4, 1);\n#undef ITER\n        const int32_t *icos = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        return compute_lak_vec(coeffs_x_low, coeffs_x_high, coeffs_a_low, coeffs_a_high,\n                        icos);\n    }\n#endif\n    int32_t compute_lak(const ConstBlockContext&context, unsigned int band) {\n        int coeffs_x[8];\n        int coeffs_a[8];\n        const int32_t *coef_idct = nullptr;\n        if ((band & 7) && (all_present || above_present)) {\n            // y == 0: we're the x\n            dev_assert(band/8 == 0); //this function only works for the edge\n            const auto &above = context.above_unchecked();\n            for (int i = 0; i < 8; ++i) {\n                uint8_t cur_coef = band + i * 8;\n                coeffs_x[i]  = i ? context.here().coefficients_raster(cur_coef) : 0;\n                coeffs_a[i]  = above.coefficients_raster(cur_coef);\n            }\n            coef_idct = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_x((int)COLOR) + band * 8;\n        } else if ((band & 7) == 0 && left_present) {\n            // x == 0: we're the y\n            const auto &left = context.left_unchecked();\n            for (int i = 0; i < 8; ++i) {\n                uint8_t cur_coef = band + i;\n                coeffs_x[i]  = i ? context.here().coefficients_raster(cur_coef) : 0;\n                coeffs_a[i]  = left.coefficients_raster(cur_coef);\n            }\n            coef_idct = ProbabilityTablesBase::icos_idct_edge_8192_dequantized_y((int)COLOR) + band;\n        } else {\n            return 0;\n        }\n        int prediction = coeffs_a[0] * coef_idct[0]; // rounding towards zero before adding coeffs_a[0] helps ratio slightly, but this is cheaper\n        for (int i = 1; i < 8; ++i) {\n            int sign = (i & 1) ? 1 : -1;\n            prediction -= coef_idct[i] * (coeffs_x[i] + sign * coeffs_a[i]);\n        }\n        prediction /= coef_idct[0];\n#if _DEBUG\n        // In DEBUG mode verify that the scalar compute_lak matches the vectorized ones\n        dev_assert(((band & 7) ? compute_lak_horizontal(context,band): compute_lak_vertical(context,band)) == prediction\n               && \"Vectorized version must match sequential version\");\n#endif\n        return prediction;\n    }\n    Sirikata::Array1d<Branch,\n            (1<<RESIDUAL_NOISE_FLOOR)>::Slice\n        residual_thresh_array(ProbabilityTablesBase &pt,\n                              const unsigned int band,\n                              const uint8_t cur_exponent,\n                              const CoefficientContext context,\n                              int min_threshold) {\n        uint16_t ctx_abs = abs(context.best_prior);\n        ANNOTATE_CTX(band, THRESH8, 0, ctx_abs >> min_threshold);\n        ANNOTATE_CTX(band, THRESH8, 2, cur_exponent - min_threshold);\n        return pt.model(\n            ).residual_threshold_counts_.at(color_index(),\n                                            std::min(ctx_abs >> min_threshold,\n                                                     (uint16_t)Model::ResidualThresholdCounts::size1 - 1),\n                                            std::min(cur_exponent - min_threshold,\n                                                     Model::ResidualThresholdCounts::size2 - 1));\n    }\n    void residual_thresh_array_annot_update(const unsigned int band,\n                                            uint16_t cur_serialized_thresh_value) {\n        (void)band;\n        (void)cur_serialized_thresh_value;\n        ANNOTATE_CTX(band, THRESH8, 1, cur_serialized_thresh_value);\n    }\n    enum SignValue {\n        ZERO_SIGN=0,\n        POSITIVE_SIGN=1,\n        NEGATIVE_SIGN=2,\n    };\n    Branch& sign_array_dc(ProbabilityTablesBase &pt,\n                          int avg_delta,\n                          int offset_to_closest_edge) {\n        ANNOTATE_CTX(0, SIGNDC, 0, 1);\n        return pt.model().sign_counts_.at(color_index(),\n                                          0,\n                                          offset_to_closest_edge >= 0\n                                          ? offset_to_closest_edge == 0\n                                          ? 3 : 2 : 1);\n    }\n    Branch& sign_array_7x7(ProbabilityTablesBase &pt, uint8_t band, CoefficientContext context) {\n        ANNOTATE_CTX(band, SIGN7x7, 0, 0);\n        return pt.model().sign_counts_.at(color_index(), 0, 0);\n    }\n    Branch& sign_array_8(ProbabilityTablesBase &pt, uint8_t band, CoefficientContext context) {\n\n        int16_t val = context.best_prior;\n        uint8_t ctx0 = context.bsr_best_prior;\n        uint8_t ctx1 = (val == 0 ? 0 : (val > 0 ? 1 : 2));\n        ANNOTATE_CTX(band, SIGN8, 0, ctx0);\n        ANNOTATE_CTX(band, SIGN8, 1, ctx1);\n        return pt.model().sign_counts_.at(color_index(), ctx1, ctx0);\n    }\n  \n    uint8_t get_noise_threshold(int coord) {\n        return ProbabilityTablesBase::min_noise_threshold((int)COLOR, coord);\n    }\n    void optimize(ProbabilityTablesBase &pt) {\n        optimize_model(pt.model());\n    }\n    void serialize(ProbabilityTablesBase &pt, int output_fd ) const{\n        serialize_model(pt.model(), output_fd);\n    }\n\n    // this reduces the counts to something easier to override by new data\n    void normalize(ProbabilityTablesBase &pt) {\n        normalize_model(pt.model());\n    }\n    \n};\n\n#endif /* DECODER_HH */\n"], "filenames": ["src/lepton/uncompressed_components.hh", "src/vp8/model/model.hh"], "buggy_code_start_loc": [122, 257], "buggy_code_end_loc": [125, 259], "fixing_code_start_loc": [122, 257], "fixing_code_end_loc": [131, 261], "type": "CWE-369", "message": "The allocate_channel_framebuffer function in uncompressed_components.hh in Dropbox Lepton 1.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a malformed JPEG image.", "other": {"cve": {"id": "CVE-2017-7448", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-05T23:59:00.157", "lastModified": "2017-04-12T01:59:01.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The allocate_channel_framebuffer function in uncompressed_components.hh in Dropbox Lepton 1.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a malformed JPEG image."}, {"lang": "es", "value": "La funci\u00f3n allocate_channel_framebuffer en uncompressed_components.hh en Dropbox Lepton 1.2.1 permite atacantes remotos provocar una denegaci\u00f3n de servicio (error de divisi\u00f3n y ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de una imagen JPEG mal formada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropbox:lepton:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "6DCDBF54-A4B3-4D67-A014-6ECC38D58621"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97490", "source": "cve@mitre.org"}, {"url": "https://github.com/dropbox/lepton/commit/7789d99ac156adfd7bbf66e7824bd3e948a74cf7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropbox/lepton/issues/86", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dropbox/lepton/commit/7789d99ac156adfd7bbf66e7824bd3e948a74cf7"}}