{"buggy_code": ["/******************************************************************************\n *\n * Copyright(c) 2003 - 2011 Intel Corporation. All rights reserved.\n *\n * Portions of this file are derived from the ipw3945 project, as well\n * as portions of the ieee80211 subsystem header files.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA\n *\n * The full GNU General Public License is included in this distribution in the\n * file called LICENSE.\n *\n * Contact Information:\n *  Intel Linux Wireless <ilw@linux.intel.com>\n * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n *\n *****************************************************************************/\n\n#include <net/mac80211.h>\n\n#include \"iwl-dev.h\"\n#include \"iwl-core.h\"\n#include \"iwl-agn.h\"\n#include \"iwl-trans.h\"\n\n/* priv->shrd->sta_lock must be held */\nstatic void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}\n\nstatic int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}\n\nint iwl_add_sta_callback(struct iwl_priv *priv, struct iwl_rx_mem_buffer *rxb,\n\t\t\t       struct iwl_device_cmd *cmd)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_addsta_cmd *addsta =\n\t\t(struct iwl_addsta_cmd *) cmd->payload;\n\n\treturn iwl_process_add_sta_resp(priv, addsta, pkt);\n}\n\nint iwl_send_add_sta(struct iwl_priv *priv,\n\t\t     struct iwl_addsta_cmd *sta, u8 flags)\n{\n\tint ret = 0;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_ADD_STA,\n\t\t.flags = flags,\n\t\t.data = { sta, },\n\t\t.len = { sizeof(*sta), },\n\t};\n\tu8 sta_id __maybe_unused = sta->sta.sta_id;\n\n\tIWL_DEBUG_INFO(priv, \"Adding sta %u (%pM) %ssynchronously\\n\",\n\t\t       sta_id, sta->sta.addr, flags & CMD_ASYNC ?  \"a\" : \"\");\n\n\tif (!(flags & CMD_ASYNC)) {\n\t\tcmd.flags |= CMD_WANT_SKB;\n\t\tmight_sleep();\n\t}\n\n\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\n\tif (ret || (flags & CMD_ASYNC))\n\t\treturn ret;\n\t/*else the command was successfully sent in SYNC mode, need to free\n\t * the reply page */\n\n\tiwl_free_pages(priv->shrd, cmd.reply_page);\n\n\tif (cmd.handler_status)\n\t\tIWL_ERR(priv, \"%s - error in the CMD response %d\", __func__,\n\t\t\tcmd.handler_status);\n\n\treturn cmd.handler_status;\n}\n\nstatic void iwl_set_ht_add_station(struct iwl_priv *priv, u8 index,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct iwl_rxon_context *ctx)\n{\n\tstruct ieee80211_sta_ht_cap *sta_ht_inf = &sta->ht_cap;\n\t__le32 sta_flags;\n\tu8 mimo_ps_mode;\n\n\tif (!sta || !sta_ht_inf->ht_supported)\n\t\tgoto done;\n\n\tmimo_ps_mode = (sta_ht_inf->cap & IEEE80211_HT_CAP_SM_PS) >> 2;\n\tIWL_DEBUG_ASSOC(priv, \"spatial multiplexing power save mode: %s\\n\",\n\t\t\t(mimo_ps_mode == WLAN_HT_CAP_SM_PS_STATIC) ?\n\t\t\t\"static\" :\n\t\t\t(mimo_ps_mode == WLAN_HT_CAP_SM_PS_DYNAMIC) ?\n\t\t\t\"dynamic\" : \"disabled\");\n\n\tsta_flags = priv->stations[index].sta.station_flags;\n\n\tsta_flags &= ~(STA_FLG_RTS_MIMO_PROT_MSK | STA_FLG_MIMO_DIS_MSK);\n\n\tswitch (mimo_ps_mode) {\n\tcase WLAN_HT_CAP_SM_PS_STATIC:\n\t\tsta_flags |= STA_FLG_MIMO_DIS_MSK;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DYNAMIC:\n\t\tsta_flags |= STA_FLG_RTS_MIMO_PROT_MSK;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DISABLED:\n\t\tbreak;\n\tdefault:\n\t\tIWL_WARN(priv, \"Invalid MIMO PS mode %d\\n\", mimo_ps_mode);\n\t\tbreak;\n\t}\n\n\tsta_flags |= cpu_to_le32(\n\t      (u32)sta_ht_inf->ampdu_factor << STA_FLG_MAX_AGG_SIZE_POS);\n\n\tsta_flags |= cpu_to_le32(\n\t      (u32)sta_ht_inf->ampdu_density << STA_FLG_AGG_MPDU_DENSITY_POS);\n\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, &sta->ht_cap))\n\t\tsta_flags |= STA_FLG_HT40_EN_MSK;\n\telse\n\t\tsta_flags &= ~STA_FLG_HT40_EN_MSK;\n\n\tpriv->stations[index].sta.station_flags = sta_flags;\n done:\n\treturn;\n}\n\n/**\n * iwl_prep_station - Prepare station information for addition\n *\n * should be called with sta_lock held\n */\nu8 iwl_prep_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t    const u8 *addr, bool is_ap, struct ieee80211_sta *sta)\n{\n\tstruct iwl_station_entry *station;\n\tint i;\n\tu8 sta_id = IWL_INVALID_STATION;\n\n\tif (is_ap)\n\t\tsta_id = ctx->ap_sta_id;\n\telse if (is_broadcast_ether_addr(addr))\n\t\tsta_id = ctx->bcast_sta_id;\n\telse\n\t\tfor (i = IWL_STA_ID; i < IWLAGN_STATION_COUNT; i++) {\n\t\t\tif (!compare_ether_addr(priv->stations[i].sta.sta.addr,\n\t\t\t\t\t\taddr)) {\n\t\t\t\tsta_id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!priv->stations[i].used &&\n\t\t\t    sta_id == IWL_INVALID_STATION)\n\t\t\t\tsta_id = i;\n\t\t}\n\n\t/*\n\t * These two conditions have the same outcome, but keep them\n\t * separate\n\t */\n\tif (unlikely(sta_id == IWL_INVALID_STATION))\n\t\treturn sta_id;\n\n\t/*\n\t * uCode is not able to deal with multiple requests to add a\n\t * station. Keep track if one is in progress so that we do not send\n\t * another.\n\t */\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {\n\t\tIWL_DEBUG_INFO(priv, \"STA %d already in process of being \"\n\t\t\t       \"added.\\n\", sta_id);\n\t\treturn sta_id;\n\t}\n\n\tif ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&\n\t    (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) &&\n\t    !compare_ether_addr(priv->stations[sta_id].sta.sta.addr, addr)) {\n\t\tIWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"\n\t\t\t\t\"adding again.\\n\", sta_id, addr);\n\t\treturn sta_id;\n\t}\n\n\tstation = &priv->stations[sta_id];\n\tstation->used = IWL_STA_DRIVER_ACTIVE;\n\tIWL_DEBUG_ASSOC(priv, \"Add STA to driver ID %d: %pM\\n\",\n\t\t\tsta_id, addr);\n\tpriv->num_stations++;\n\n\t/* Set up the REPLY_ADD_STA command to send to device */\n\tmemset(&station->sta, 0, sizeof(struct iwl_addsta_cmd));\n\tmemcpy(station->sta.sta.addr, addr, ETH_ALEN);\n\tstation->sta.mode = 0;\n\tstation->sta.sta.sta_id = sta_id;\n\tstation->sta.station_flags = ctx->station_flags;\n\tstation->ctxid = ctx->ctxid;\n\n\tif (sta) {\n\t\tstruct iwl_station_priv *sta_priv;\n\n\t\tsta_priv = (void *)sta->drv_priv;\n\t\tsta_priv->ctx = ctx;\n\t}\n\n\t/*\n\t * OK to call unconditionally, since local stations (IBSS BSSID\n\t * STA and broadcast STA) pass in a NULL sta, and mac80211\n\t * doesn't allow HT IBSS.\n\t */\n\tiwl_set_ht_add_station(priv, sta_id, sta, ctx);\n\n\treturn sta_id;\n\n}\n\n#define STA_WAIT_TIMEOUT (HZ/2)\n\n/**\n * iwl_add_station_common -\n */\nint iwl_add_station_common(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t\t   const u8 *addr, bool is_ap,\n\t\t\t   struct ieee80211_sta *sta, u8 *sta_id_r)\n{\n\tunsigned long flags_spin;\n\tint ret = 0;\n\tu8 sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\t*sta_id_r = 0;\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tsta_id = iwl_prep_station(priv, ctx, addr, is_ap, sta);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Unable to prepare station %pM for addition\\n\",\n\t\t\taddr);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * uCode is not able to deal with multiple requests to add a\n\t * station. Keep track if one is in progress so that we do not send\n\t * another.\n\t */\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {\n\t\tIWL_DEBUG_INFO(priv, \"STA %d already in process of being \"\n\t\t\t       \"added.\\n\", sta_id);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\tif ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&\n\t    (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {\n\t\tIWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"\n\t\t\t\t\"adding again.\\n\", sta_id, addr);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\tpriv->stations[sta_id].used |= IWL_STA_UCODE_INPROGRESS;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\n\t       sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\t/* Add station to device's station table */\n\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\tIWL_ERR(priv, \"Adding station %pM failed.\\n\",\n\t\t\tpriv->stations[sta_id].sta.sta.addr);\n\t\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\t\tpriv->stations[sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t}\n\t*sta_id_r = sta_id;\n\treturn ret;\n}\n\n/**\n * iwl_sta_ucode_deactivate - deactivate ucode status for a station\n *\n * priv->shrd->sta_lock must be held\n */\nstatic void iwl_sta_ucode_deactivate(struct iwl_priv *priv, u8 sta_id)\n{\n\t/* Ucode must be active and driver must be non active */\n\tif ((priv->stations[sta_id].used &\n\t     (IWL_STA_UCODE_ACTIVE | IWL_STA_DRIVER_ACTIVE)) !=\n\t      IWL_STA_UCODE_ACTIVE)\n\t\tIWL_ERR(priv, \"removed non active STA %u\\n\", sta_id);\n\n\tpriv->stations[sta_id].used &= ~IWL_STA_UCODE_ACTIVE;\n\n\tmemset(&priv->stations[sta_id], 0, sizeof(struct iwl_station_entry));\n\tIWL_DEBUG_ASSOC(priv, \"Removed STA %u\\n\", sta_id);\n}\n\nstatic int iwl_send_remove_station(struct iwl_priv *priv,\n\t\t\t\t   const u8 *addr, int sta_id,\n\t\t\t\t   bool temporary)\n{\n\tstruct iwl_rx_packet *pkt;\n\tint ret;\n\n\tunsigned long flags_spin;\n\tstruct iwl_rem_sta_cmd rm_sta_cmd;\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_REMOVE_STA,\n\t\t.len = { sizeof(struct iwl_rem_sta_cmd), },\n\t\t.flags = CMD_SYNC,\n\t\t.data = { &rm_sta_cmd, },\n\t};\n\n\tmemset(&rm_sta_cmd, 0, sizeof(rm_sta_cmd));\n\trm_sta_cmd.num_sta = 1;\n\tmemcpy(&rm_sta_cmd.addr, addr, ETH_ALEN);\n\n\tcmd.flags |= CMD_WANT_SKB;\n\n\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = (struct iwl_rx_packet *)cmd.reply_page;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_REMOVE_STA (0x%08X)\\n\",\n\t\t\t  pkt->hdr.flags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tswitch (pkt->u.rem_sta.status) {\n\t\tcase REM_STA_SUCCESS_MSK:\n\t\t\tif (!temporary) {\n\t\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t\tiwl_sta_ucode_deactivate(priv, sta_id);\n\t\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t}\n\t\t\tIWL_DEBUG_ASSOC(priv, \"REPLY_REMOVE_STA PASSED\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tIWL_ERR(priv, \"REPLY_REMOVE_STA failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tiwl_free_pages(priv->shrd, cmd.reply_page);\n\n\treturn ret;\n}\n\n/**\n * iwl_remove_station - Remove driver's knowledge of station.\n */\nint iwl_remove_station(struct iwl_priv *priv, const u8 sta_id,\n\t\t       const u8 *addr)\n{\n\tunsigned long flags;\n\tu8 tid;\n\n\tif (!iwl_is_ready(priv->shrd)) {\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\"Unable to remove station %pM, device not ready.\\n\",\n\t\t\taddr);\n\t\t/*\n\t\t * It is typical for stations to be removed when we are\n\t\t * going down. Return success since device will be down\n\t\t * soon anyway\n\t\t */\n\t\treturn 0;\n\t}\n\n\tIWL_DEBUG_ASSOC(priv, \"Removing STA from driver:%d  %pM\\n\",\n\t\t\tsta_id, addr);\n\n\tif (WARN_ON(sta_id == IWL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tIWL_DEBUG_INFO(priv, \"Removing %pM but non DRIVER active\\n\",\n\t\t\t\taddr);\n\t\tgoto out_err;\n\t}\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {\n\t\tIWL_DEBUG_INFO(priv, \"Removing %pM but non UCODE active\\n\",\n\t\t\t\taddr);\n\t\tgoto out_err;\n\t}\n\n\tif (priv->stations[sta_id].used & IWL_STA_LOCAL) {\n\t\tkfree(priv->stations[sta_id].lq);\n\t\tpriv->stations[sta_id].lq = NULL;\n\t}\n\n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)\n\t\tmemset(&priv->tid_data[sta_id][tid], 0,\n\t\t\tsizeof(priv->tid_data[sta_id][tid]));\n\n\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\n\tpriv->num_stations--;\n\n\tif (WARN_ON(priv->num_stations < 0))\n\t\tpriv->num_stations = 0;\n\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_remove_station(priv, addr, sta_id, false);\nout_err:\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn -EINVAL;\n}\n\n/**\n * iwl_clear_ucode_stations - clear ucode station table bits\n *\n * This function clears all the bits in the driver indicating\n * which stations are active in the ucode. Call when something\n * other than explicit station management would cause this in\n * the ucode, e.g. unassociated RXON.\n */\nvoid iwl_clear_ucode_stations(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx)\n{\n\tint i;\n\tunsigned long flags_spin;\n\tbool cleared = false;\n\n\tIWL_DEBUG_INFO(priv, \"Clearing ucode stations in driver\\n\");\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (ctx && ctx->ctxid != priv->stations[i].ctxid)\n\t\t\tcontinue;\n\n\t\tif (priv->stations[i].used & IWL_STA_UCODE_ACTIVE) {\n\t\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\t\"Clearing ucode active for station %d\\n\", i);\n\t\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;\n\t\t\tcleared = true;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\tif (!cleared)\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"No active stations found to be cleared\\n\");\n}\n\n/**\n * iwl_restore_stations() - Restore driver known stations to device\n *\n * All stations considered active by driver, but not present in ucode, is\n * restored.\n *\n * Function sleeps.\n */\nvoid iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_addsta_cmd sta_cmd;\n\tstruct iwl_link_quality_cmd lq;\n\tunsigned long flags_spin;\n\tint i;\n\tbool found = false;\n\tint ret;\n\tbool send_lq;\n\n\tif (!iwl_is_ready(priv->shrd)) {\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"Not ready yet, not restoring any stations.\\n\");\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_ASSOC(priv, \"Restoring all known stations ... start.\\n\");\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (ctx->ctxid != priv->stations[i].ctxid)\n\t\t\tcontinue;\n\t\tif ((priv->stations[i].used & IWL_STA_DRIVER_ACTIVE) &&\n\t\t\t    !(priv->stations[i].used & IWL_STA_UCODE_ACTIVE)) {\n\t\t\tIWL_DEBUG_ASSOC(priv, \"Restoring sta %pM\\n\",\n\t\t\t\t\tpriv->stations[i].sta.sta.addr);\n\t\t\tpriv->stations[i].sta.mode = 0;\n\t\t\tpriv->stations[i].used |= IWL_STA_UCODE_INPROGRESS;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif ((priv->stations[i].used & IWL_STA_UCODE_INPROGRESS)) {\n\t\t\tmemcpy(&sta_cmd, &priv->stations[i].sta,\n\t\t\t       sizeof(struct iwl_addsta_cmd));\n\t\t\tsend_lq = false;\n\t\t\tif (priv->stations[i].lq) {\n\t\t\t\tif (priv->shrd->wowlan)\n\t\t\t\t\tiwl_sta_fill_lq(priv, ctx, i, &lq);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(&lq, priv->stations[i].lq,\n\t\t\t\t\t       sizeof(struct iwl_link_quality_cmd));\n\t\t\t\tsend_lq = true;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\t       flags_spin);\n\t\t\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\t\t\tif (ret) {\n\t\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock,\n\t\t\t\t\t\t  flags_spin);\n\t\t\t\tIWL_ERR(priv, \"Adding station %pM failed.\\n\",\n\t\t\t\t\tpriv->stations[i].sta.sta.addr);\n\t\t\t\tpriv->stations[i].used &=\n\t\t\t\t\t\t~IWL_STA_DRIVER_ACTIVE;\n\t\t\t\tpriv->stations[i].used &=\n\t\t\t\t\t\t~IWL_STA_UCODE_INPROGRESS;\n\t\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\t\t       flags_spin);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Rate scaling has already been initialized, send\n\t\t\t * current LQ command\n\t\t\t */\n\t\t\tif (send_lq)\n\t\t\t\tiwl_send_lq_cmd(priv, ctx, &lq,\n\t\t\t\t\t\tCMD_SYNC, true);\n\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\tif (!found)\n\t\tIWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"\n\t\t\t\"no stations to be restored.\\n\");\n\telse\n\t\tIWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"\n\t\t\t\"complete.\\n\");\n}\n\nvoid iwl_reprogram_ap_sta(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tunsigned long flags;\n\tint sta_id = ctx->ap_sta_id;\n\tint ret;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tstruct iwl_link_quality_cmd lq;\n\tbool active, have_lq = false;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\t\treturn;\n\t}\n\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tsta_cmd.mode = 0;\n\tif (priv->stations[sta_id].lq) {\n\t\tmemcpy(&lq, priv->stations[sta_id].lq, sizeof(lq));\n\t\thave_lq = true;\n\t}\n\n\tactive = priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE;\n\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tif (active) {\n\t\tret = iwl_send_remove_station(\n\t\t\tpriv, priv->stations[sta_id].sta.sta.addr,\n\t\t\tsta_id, true);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"failed to remove STA %pM (%d)\\n\",\n\t\t\t\tpriv->stations[sta_id].sta.sta.addr, ret);\n\t}\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\tif (ret)\n\t\tIWL_ERR(priv, \"failed to re-add STA %pM (%d)\\n\",\n\t\t\tpriv->stations[sta_id].sta.sta.addr, ret);\n\tif (have_lq)\n\t\tiwl_send_lq_cmd(priv, ctx, &lq, CMD_SYNC, true);\n}\n\nint iwl_get_free_ucode_key_offset(struct iwl_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->sta_key_max_num; i++)\n\t\tif (!test_and_set_bit(i, &priv->ucode_key_table))\n\t\t\treturn i;\n\n\treturn WEP_INVALID_OFFSET;\n}\n\nvoid iwl_dealloc_bcast_stations(struct iwl_priv *priv)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (!(priv->stations[i].used & IWL_STA_BCAST))\n\t\t\tcontinue;\n\n\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;\n\t\tpriv->num_stations--;\n\t\tif (WARN_ON(priv->num_stations < 0))\n\t\t\tpriv->num_stations = 0;\n\t\tkfree(priv->stations[i].lq);\n\t\tpriv->stations[i].lq = NULL;\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nstatic void iwl_dump_lq_cmd(struct iwl_priv *priv,\n\t\t\t   struct iwl_link_quality_cmd *lq)\n{\n\tint i;\n\tIWL_DEBUG_RATE(priv, \"lq station id 0x%x\\n\", lq->sta_id);\n\tIWL_DEBUG_RATE(priv, \"lq ant 0x%X 0x%X\\n\",\n\t\t       lq->general_params.single_stream_ant_msk,\n\t\t       lq->general_params.dual_stream_ant_msk);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tIWL_DEBUG_RATE(priv, \"lq index %d 0x%X\\n\",\n\t\t\t       i, lq->rs_table[i].rate_n_flags);\n}\n#else\nstatic inline void iwl_dump_lq_cmd(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_link_quality_cmd *lq)\n{\n}\n#endif\n\n/**\n * is_lq_table_valid() - Test one aspect of LQ cmd for validity\n *\n * It sometimes happens when a HT rate has been in use and we\n * loose connectivity with AP then mac80211 will first tell us that the\n * current channel is not HT anymore before removing the station. In such a\n * scenario the RXON flags will be updated to indicate we are not\n * communicating HT anymore, but the LQ command may still contain HT rates.\n * Test for this to prevent driver from sending LQ command between the time\n * RXON flags are updated and when LQ command is updated.\n */\nstatic bool is_lq_table_valid(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t      struct iwl_link_quality_cmd *lq)\n{\n\tint i;\n\n\tif (ctx->ht.enabled)\n\t\treturn true;\n\n\tIWL_DEBUG_INFO(priv, \"Channel %u is not an HT channel\\n\",\n\t\t       ctx->active.channel);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tif (le32_to_cpu(lq->rs_table[i].rate_n_flags) &\n\t\t    RATE_MCS_HT_MSK) {\n\t\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\t       \"index %d of LQ expects HT channel\\n\",\n\t\t\t\t       i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * iwl_send_lq_cmd() - Send link quality command\n * @init: This command is sent as part of station initialization right\n *        after station has been added.\n *\n * The link quality command is sent as the last step of station creation.\n * This is the special case in which init is set and we call a callback in\n * this case to clear the state indicating that station creation is in\n * progress.\n */\nint iwl_send_lq_cmd(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t    struct iwl_link_quality_cmd *lq, u8 flags, bool init)\n{\n\tint ret = 0;\n\tunsigned long flags_spin;\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_TX_LINK_QUALITY_CMD,\n\t\t.len = { sizeof(struct iwl_link_quality_cmd), },\n\t\t.flags = flags,\n\t\t.data = { lq, },\n\t};\n\n\tif (WARN_ON(lq->sta_id == IWL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tif (!(priv->stations[lq->sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\tiwl_dump_lq_cmd(priv, lq);\n\tif (WARN_ON(init && (cmd.flags & CMD_ASYNC)))\n\t\treturn -EINVAL;\n\n\tif (is_lq_table_valid(priv, ctx, lq))\n\t\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\telse\n\t\tret = -EINVAL;\n\n\tif (cmd.flags & CMD_ASYNC)\n\t\treturn ret;\n\n\tif (init) {\n\t\tIWL_DEBUG_INFO(priv, \"init LQ command complete, \"\n\t\t\t       \"clearing sta addition status for sta %d\\n\",\n\t\t\t       lq->sta_id);\n\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\tpriv->stations[lq->sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t}\n\treturn ret;\n}\n\n\nvoid iwl_sta_fill_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t     u8 sta_id, struct iwl_link_quality_cmd *link_cmd)\n{\n\tint i, r;\n\tu32 rate_flags = 0;\n\t__le32 rate_n_flags;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tmemset(link_cmd, 0, sizeof(*link_cmd));\n\n\t/* Set up the rate scaling to start at selected rate, fall back\n\t * all the way down to 1M in IEEE order, and then spin on 1M */\n\tif (priv->band == IEEE80211_BAND_5GHZ)\n\t\tr = IWL_RATE_6M_INDEX;\n\telse if (ctx && ctx->vif && ctx->vif->p2p)\n\t\tr = IWL_RATE_6M_INDEX;\n\telse\n\t\tr = IWL_RATE_1M_INDEX;\n\n\tif (r >= IWL_FIRST_CCK_RATE && r <= IWL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\trate_flags |= first_antenna(hw_params(priv).valid_tx_ant) <<\n\t\t\t\tRATE_MCS_ANT_POS;\n\trate_n_flags = iwl_hw_set_rate_n_flags(iwl_rates[r].plcp, rate_flags);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\n\n\tlink_cmd->general_params.single_stream_ant_msk =\n\t\t\tfirst_antenna(hw_params(priv).valid_tx_ant);\n\n\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\thw_params(priv).valid_tx_ant &\n\t\t~first_antenna(hw_params(priv).valid_tx_ant);\n\tif (!link_cmd->general_params.dual_stream_ant_msk) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (num_of_ant(hw_params(priv).valid_tx_ant) == 2) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\t\thw_params(priv).valid_tx_ant;\n\t}\n\n\tlink_cmd->agg_params.agg_dis_start_th =\n\t\tLINK_QUAL_AGG_DISABLE_START_DEF;\n\tlink_cmd->agg_params.agg_time_limit =\n\t\tcpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n\n\tlink_cmd->sta_id = sta_id;\n}\n\nstatic struct iwl_link_quality_cmd *\niwl_sta_alloc_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t u8 sta_id)\n{\n\tstruct iwl_link_quality_cmd *link_cmd;\n\n\tlink_cmd = kzalloc(sizeof(struct iwl_link_quality_cmd), GFP_KERNEL);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv, \"Unable to allocate memory for LQ cmd.\\n\");\n\t\treturn NULL;\n\t}\n\n\tiwl_sta_fill_lq(priv, ctx, sta_id, link_cmd);\n\n\treturn link_cmd;\n}\n\n/*\n * iwlagn_add_bssid_station - Add the special IBSS BSSID station\n *\n * Function sleeps.\n */\nint iwlagn_add_bssid_station(struct iwl_priv *priv,\n\t\t\t     struct iwl_rxon_context *ctx,\n\t\t\t     const u8 *addr, u8 *sta_id_r)\n{\n\tint ret;\n\tu8 sta_id;\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\n\tif (sta_id_r)\n\t\t*sta_id_r = IWL_INVALID_STATION;\n\n\tret = iwl_add_station_common(priv, ctx, addr, 0, NULL, &sta_id);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Unable to add station %pM\\n\", addr);\n\t\treturn ret;\n\t}\n\n\tif (sta_id_r)\n\t\t*sta_id_r = sta_id;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].used |= IWL_STA_LOCAL;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\t/* Set up default rate scaling table in device's station table */\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Unable to initialize rate scaling for station %pM.\\n\",\n\t\t\taddr);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = iwl_send_lq_cmd(priv, ctx, link_cmd, CMD_SYNC, true);\n\tif (ret)\n\t\tIWL_ERR(priv, \"Link quality command failed (%d)\\n\", ret);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\n/*\n * static WEP keys\n *\n * For each context, the device has a table of 4 static WEP keys\n * (one for each key index) that is updated with the following\n * commands.\n */\n\nstatic int iwl_send_static_wepkey_cmd(struct iwl_priv *priv,\n\t\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t\t      bool send_if_empty)\n{\n\tint i, not_empty = 0;\n\tu8 buff[sizeof(struct iwl_wep_cmd) +\n\t\tsizeof(struct iwl_wep_key) * WEP_KEYS_MAX];\n\tstruct iwl_wep_cmd *wep_cmd = (struct iwl_wep_cmd *)buff;\n\tsize_t cmd_size  = sizeof(struct iwl_wep_cmd);\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = ctx->wep_key_cmd,\n\t\t.data = { wep_cmd, },\n\t\t.flags = CMD_SYNC,\n\t};\n\n\tmight_sleep();\n\n\tmemset(wep_cmd, 0, cmd_size +\n\t\t\t(sizeof(struct iwl_wep_key) * WEP_KEYS_MAX));\n\n\tfor (i = 0; i < WEP_KEYS_MAX ; i++) {\n\t\twep_cmd->key[i].key_index = i;\n\t\tif (ctx->wep_keys[i].key_size) {\n\t\t\twep_cmd->key[i].key_offset = i;\n\t\t\tnot_empty = 1;\n\t\t} else {\n\t\t\twep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\n\t\t}\n\n\t\twep_cmd->key[i].key_size = ctx->wep_keys[i].key_size;\n\t\tmemcpy(&wep_cmd->key[i].key[3], ctx->wep_keys[i].key,\n\t\t\t\tctx->wep_keys[i].key_size);\n\t}\n\n\twep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\n\twep_cmd->num_keys = WEP_KEYS_MAX;\n\n\tcmd_size += sizeof(struct iwl_wep_key) * WEP_KEYS_MAX;\n\n\tcmd.len[0] = cmd_size;\n\n\tif (not_empty || send_if_empty)\n\t\treturn iwl_trans_send_cmd(trans(priv), &cmd);\n\telse\n\t\treturn 0;\n}\n\nint iwl_restore_default_wep_keys(struct iwl_priv *priv,\n\t\t\t\t struct iwl_rxon_context *ctx)\n{\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\treturn iwl_send_static_wepkey_cmd(priv, ctx, false);\n}\n\nint iwl_remove_default_wep_key(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx,\n\t\t\t       struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tIWL_DEBUG_WEP(priv, \"Removing default WEP key: idx=%d\\n\",\n\t\t      keyconf->keyidx);\n\n\tmemset(&ctx->wep_keys[keyconf->keyidx], 0, sizeof(ctx->wep_keys[0]));\n\tif (iwl_is_rfkill(priv->shrd)) {\n\t\tIWL_DEBUG_WEP(priv,\n\t\t\t\"Not sending REPLY_WEPKEY command due to RFKILL.\\n\");\n\t\t/* but keys in device are clear anyway so return success */\n\t\treturn 0;\n\t}\n\tret = iwl_send_static_wepkey_cmd(priv, ctx, 1);\n\tIWL_DEBUG_WEP(priv, \"Remove default WEP key: idx=%d ret=%d\\n\",\n\t\t      keyconf->keyidx, ret);\n\n\treturn ret;\n}\n\nint iwl_set_default_wep_key(struct iwl_priv *priv,\n\t\t\t    struct iwl_rxon_context *ctx,\n\t\t\t    struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tif (keyconf->keylen != WEP_KEY_LEN_128 &&\n\t    keyconf->keylen != WEP_KEY_LEN_64) {\n\t\tIWL_DEBUG_WEP(priv,\n\t\t\t      \"Bad WEP key length %d\\n\", keyconf->keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tkeyconf->hw_key_idx = IWLAGN_HW_KEY_DEFAULT;\n\n\tctx->wep_keys[keyconf->keyidx].key_size = keyconf->keylen;\n\tmemcpy(&ctx->wep_keys[keyconf->keyidx].key, &keyconf->key,\n\t\t\t\t\t\t\tkeyconf->keylen);\n\n\tret = iwl_send_static_wepkey_cmd(priv, ctx, false);\n\tIWL_DEBUG_WEP(priv, \"Set default WEP key: len=%d idx=%d ret=%d\\n\",\n\t\tkeyconf->keylen, keyconf->keyidx, ret);\n\n\treturn ret;\n}\n\n/*\n * dynamic (per-station) keys\n *\n * The dynamic keys are a little more complicated. The device has\n * a key cache of up to STA_KEY_MAX_NUM/STA_KEY_MAX_NUM_PAN keys.\n * These are linked to stations by a table that contains an index\n * into the key table for each station/key index/{mcast,unicast},\n * i.e. it's basically an array of pointers like this:\n *\tkey_offset_t key_mapping[NUM_STATIONS][4][2];\n * (it really works differently, but you can think of it as such)\n *\n * The key uploading and linking happens in the same command, the\n * add station command with STA_MODIFY_KEY_MASK.\n */\n\nstatic u8 iwlagn_key_sta_id(struct iwl_priv *priv,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tu8 sta_id = IWL_INVALID_STATION;\n\n\tif (sta)\n\t\tsta_id = iwl_sta_id(sta);\n\n\t/*\n\t * The device expects GTKs for station interfaces to be\n\t * installed as GTKs for the AP station. If we have no\n\t * station ID, then use the ap_sta_id in that case.\n\t */\n\tif (!sta && vif && vif_priv->ctx) {\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tsta_id = vif_priv->ctx->ap_sta_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * In all other cases, the key will be\n\t\t\t * used either for TX only or is bound\n\t\t\t * to a station already.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sta_id;\n}\n\nstatic int iwlagn_send_sta_key(struct iwl_priv *priv,\n\t\t\t       struct ieee80211_key_conf *keyconf,\n\t\t\t       u8 sta_id, u32 tkip_iv32, u16 *tkip_p1k,\n\t\t\t       u32 cmd_flags)\n{\n\tunsigned long flags;\n\t__le16 key_flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tint i;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tkey_flags = cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags |= STA_KEY_FLG_MAP_KEY_MSK;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_flags |= STA_KEY_FLG_CCMP;\n\t\tmemcpy(sta_cmd.key.key, keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_flags |= STA_KEY_FLG_TKIP;\n\t\tsta_cmd.key.tkip_rx_tsc_byte2 = tkip_iv32;\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tsta_cmd.key.tkip_rx_ttak[i] = cpu_to_le16(tkip_p1k[i]);\n\t\tmemcpy(sta_cmd.key.key, keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\n\t\t/* fall through */\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey_flags |= STA_KEY_FLG_WEP;\n\t\tmemcpy(&sta_cmd.key.key[3], keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\t/* key pointer (offset) */\n\tsta_cmd.key.key_offset = keyconf->hw_key_idx;\n\n\tsta_cmd.key.key_flags = key_flags;\n\tsta_cmd.mode = STA_CONTROL_MODIFY_MSK;\n\tsta_cmd.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, cmd_flags);\n}\n\nvoid iwl_update_tkip_key(struct iwl_priv *priv,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t struct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\n{\n\tu8 sta_id = iwlagn_key_sta_id(priv, vif, sta);\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn;\n\n\tif (iwl_scan_cancel(priv)) {\n\t\t/* cancel scan failed, just live w/ bad key and rely\n\t\t   briefly on SW decryption */\n\t\treturn;\n\t}\n\n\tiwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t    iv32, phase1key, CMD_ASYNC);\n}\n\nint iwl_remove_dynamic_key(struct iwl_priv *priv,\n\t\t\t   struct iwl_rxon_context *ctx,\n\t\t\t   struct ieee80211_key_conf *keyconf,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tunsigned long flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tu8 sta_id = iwlagn_key_sta_id(priv, ctx->vif, sta);\n\n\t/* if station isn't there, neither is the key */\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -ENOENT;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tif (!(priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE))\n\t\tsta_id = IWL_INVALID_STATION;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn 0;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tctx->key_mapping_keys--;\n\n\tIWL_DEBUG_WEP(priv, \"Remove dynamic key: idx=%d sta=%d\\n\",\n\t\t      keyconf->keyidx, sta_id);\n\n\tif (!test_and_clear_bit(keyconf->hw_key_idx, &priv->ucode_key_table))\n\t\tIWL_ERR(priv, \"offset %d not used in uCode key table.\\n\",\n\t\t\tkeyconf->hw_key_idx);\n\n\tsta_cmd.key.key_flags = STA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\n\tsta_cmd.key.key_offset = WEP_INVALID_OFFSET;\n\tsta_cmd.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\tsta_cmd.mode = STA_CONTROL_MODIFY_MSK;\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_set_dynamic_key(struct iwl_priv *priv,\n\t\t\tstruct iwl_rxon_context *ctx,\n\t\t\tstruct ieee80211_key_conf *keyconf,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ieee80211_key_seq seq;\n\tu16 p1k[5];\n\tint ret;\n\tu8 sta_id = iwlagn_key_sta_id(priv, ctx->vif, sta);\n\tconst u8 *addr;\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -EINVAL;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tkeyconf->hw_key_idx = iwl_get_free_ucode_key_offset(priv);\n\tif (keyconf->hw_key_idx == WEP_INVALID_OFFSET)\n\t\treturn -ENOSPC;\n\n\tctx->key_mapping_keys++;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta)\n\t\t\taddr = sta->addr;\n\t\telse /* station mode case only */\n\t\t\taddr = ctx->active.bssid_addr;\n\n\t\t/* pre-fill phase 1 key into device cache */\n\t\tieee80211_get_key_rx_seq(keyconf, 0, &seq);\n\t\tieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);\n\t\tret = iwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t\t\t  seq.tkip.iv32, p1k, CMD_SYNC);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tret = iwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t\t\t  0, NULL, CMD_SYNC);\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Unknown cipher %x\\n\", keyconf->cipher);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tctx->key_mapping_keys--;\n\t\tclear_bit(keyconf->hw_key_idx, &priv->ucode_key_table);\n\t}\n\n\tIWL_DEBUG_WEP(priv, \"Set dynamic key: cipher=%x len=%d idx=%d sta=%pM ret=%d\\n\",\n\t\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx,\n\t\t      sta ? sta->addr : NULL, ret);\n\n\treturn ret;\n}\n\n/**\n * iwlagn_alloc_bcast_station - add broadcast station into driver's station table.\n *\n * This adds the broadcast station into the driver's station table\n * and marks it driver active, so that it will be restored to the\n * device at the next best time.\n */\nint iwlagn_alloc_bcast_station(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\tu8 sta_id;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tsta_id = iwl_prep_station(priv, ctx, iwl_bcast_addr, false, NULL);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Unable to prepare broadcast station\\n\");\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;\n\tpriv->stations[sta_id].used |= IWL_STA_BCAST;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\n/**\n * iwl_update_bcast_station - update broadcast station's LQ command\n *\n * Only used by iwlagn. Placed here to have all bcast station management\n * code together.\n */\nint iwl_update_bcast_station(struct iwl_priv *priv,\n\t\t\t     struct iwl_rxon_context *ctx)\n{\n\tunsigned long flags;\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tu8 sta_id = ctx->bcast_sta_id;\n\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv, \"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tif (priv->stations[sta_id].lq)\n\t\tkfree(priv->stations[sta_id].lq);\n\telse\n\t\tIWL_DEBUG_INFO(priv, \"Bcast station rate scaling has not been initialized yet.\\n\");\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\nint iwl_update_bcast_stations(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\tint ret = 0;\n\n\tfor_each_context(priv, ctx) {\n\t\tret = iwl_update_bcast_station(priv, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n * iwl_sta_tx_modify_enable_tid - Enable Tx for this TID in station table\n */\nint iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv, int sta_id, int tid)\n{\n\tunsigned long flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\t/* Remove \"disable\" flag, to enable Tx for this TID */\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\tpriv->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_sta_rx_agg_start(struct iwl_priv *priv, struct ieee80211_sta *sta,\n\t\t\t int tid, u16 ssn)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tsta_id = iwl_sta_id(sta);\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags_msk = 0;\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\n\tpriv->stations[sta_id].sta.add_immediate_ba_tid = (u8)tid;\n\tpriv->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_sta_rx_agg_stop(struct iwl_priv *priv, struct ieee80211_sta *sta,\n\t\t\tint tid)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tsta_id = iwl_sta_id(sta);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags_msk = 0;\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\n\tpriv->stations[sta_id].sta.remove_immediate_ba_tid = (u8)tid;\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\n\n\nvoid iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv, int sta_id, int cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\n\tpriv->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\n\tpriv->stations[sta_id].sta.sta.modify_mask =\n\t\t\t\t\tSTA_MODIFY_SLEEP_TX_COUNT_MSK;\n\tpriv->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tiwl_send_add_sta(priv, &priv->stations[sta_id].sta, CMD_ASYNC);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n}\n"], "fixing_code": ["/******************************************************************************\n *\n * Copyright(c) 2003 - 2011 Intel Corporation. All rights reserved.\n *\n * Portions of this file are derived from the ipw3945 project, as well\n * as portions of the ieee80211 subsystem header files.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA\n *\n * The full GNU General Public License is included in this distribution in the\n * file called LICENSE.\n *\n * Contact Information:\n *  Intel Linux Wireless <ilw@linux.intel.com>\n * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n *\n *****************************************************************************/\n\n#include <net/mac80211.h>\n\n#include \"iwl-dev.h\"\n#include \"iwl-core.h\"\n#include \"iwl-agn.h\"\n#include \"iwl-trans.h\"\n\n/* priv->shrd->sta_lock must be held */\nstatic int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}\n\nstatic int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tret = iwl_sta_ucode_activate(priv, sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}\n\nint iwl_add_sta_callback(struct iwl_priv *priv, struct iwl_rx_mem_buffer *rxb,\n\t\t\t       struct iwl_device_cmd *cmd)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_addsta_cmd *addsta =\n\t\t(struct iwl_addsta_cmd *) cmd->payload;\n\n\treturn iwl_process_add_sta_resp(priv, addsta, pkt);\n}\n\nint iwl_send_add_sta(struct iwl_priv *priv,\n\t\t     struct iwl_addsta_cmd *sta, u8 flags)\n{\n\tint ret = 0;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_ADD_STA,\n\t\t.flags = flags,\n\t\t.data = { sta, },\n\t\t.len = { sizeof(*sta), },\n\t};\n\tu8 sta_id __maybe_unused = sta->sta.sta_id;\n\n\tIWL_DEBUG_INFO(priv, \"Adding sta %u (%pM) %ssynchronously\\n\",\n\t\t       sta_id, sta->sta.addr, flags & CMD_ASYNC ?  \"a\" : \"\");\n\n\tif (!(flags & CMD_ASYNC)) {\n\t\tcmd.flags |= CMD_WANT_SKB;\n\t\tmight_sleep();\n\t}\n\n\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\n\tif (ret || (flags & CMD_ASYNC))\n\t\treturn ret;\n\t/*else the command was successfully sent in SYNC mode, need to free\n\t * the reply page */\n\n\tiwl_free_pages(priv->shrd, cmd.reply_page);\n\n\tif (cmd.handler_status)\n\t\tIWL_ERR(priv, \"%s - error in the CMD response %d\", __func__,\n\t\t\tcmd.handler_status);\n\n\treturn cmd.handler_status;\n}\n\nstatic void iwl_set_ht_add_station(struct iwl_priv *priv, u8 index,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct iwl_rxon_context *ctx)\n{\n\tstruct ieee80211_sta_ht_cap *sta_ht_inf = &sta->ht_cap;\n\t__le32 sta_flags;\n\tu8 mimo_ps_mode;\n\n\tif (!sta || !sta_ht_inf->ht_supported)\n\t\tgoto done;\n\n\tmimo_ps_mode = (sta_ht_inf->cap & IEEE80211_HT_CAP_SM_PS) >> 2;\n\tIWL_DEBUG_ASSOC(priv, \"spatial multiplexing power save mode: %s\\n\",\n\t\t\t(mimo_ps_mode == WLAN_HT_CAP_SM_PS_STATIC) ?\n\t\t\t\"static\" :\n\t\t\t(mimo_ps_mode == WLAN_HT_CAP_SM_PS_DYNAMIC) ?\n\t\t\t\"dynamic\" : \"disabled\");\n\n\tsta_flags = priv->stations[index].sta.station_flags;\n\n\tsta_flags &= ~(STA_FLG_RTS_MIMO_PROT_MSK | STA_FLG_MIMO_DIS_MSK);\n\n\tswitch (mimo_ps_mode) {\n\tcase WLAN_HT_CAP_SM_PS_STATIC:\n\t\tsta_flags |= STA_FLG_MIMO_DIS_MSK;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DYNAMIC:\n\t\tsta_flags |= STA_FLG_RTS_MIMO_PROT_MSK;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DISABLED:\n\t\tbreak;\n\tdefault:\n\t\tIWL_WARN(priv, \"Invalid MIMO PS mode %d\\n\", mimo_ps_mode);\n\t\tbreak;\n\t}\n\n\tsta_flags |= cpu_to_le32(\n\t      (u32)sta_ht_inf->ampdu_factor << STA_FLG_MAX_AGG_SIZE_POS);\n\n\tsta_flags |= cpu_to_le32(\n\t      (u32)sta_ht_inf->ampdu_density << STA_FLG_AGG_MPDU_DENSITY_POS);\n\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, &sta->ht_cap))\n\t\tsta_flags |= STA_FLG_HT40_EN_MSK;\n\telse\n\t\tsta_flags &= ~STA_FLG_HT40_EN_MSK;\n\n\tpriv->stations[index].sta.station_flags = sta_flags;\n done:\n\treturn;\n}\n\n/**\n * iwl_prep_station - Prepare station information for addition\n *\n * should be called with sta_lock held\n */\nu8 iwl_prep_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t    const u8 *addr, bool is_ap, struct ieee80211_sta *sta)\n{\n\tstruct iwl_station_entry *station;\n\tint i;\n\tu8 sta_id = IWL_INVALID_STATION;\n\n\tif (is_ap)\n\t\tsta_id = ctx->ap_sta_id;\n\telse if (is_broadcast_ether_addr(addr))\n\t\tsta_id = ctx->bcast_sta_id;\n\telse\n\t\tfor (i = IWL_STA_ID; i < IWLAGN_STATION_COUNT; i++) {\n\t\t\tif (!compare_ether_addr(priv->stations[i].sta.sta.addr,\n\t\t\t\t\t\taddr)) {\n\t\t\t\tsta_id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!priv->stations[i].used &&\n\t\t\t    sta_id == IWL_INVALID_STATION)\n\t\t\t\tsta_id = i;\n\t\t}\n\n\t/*\n\t * These two conditions have the same outcome, but keep them\n\t * separate\n\t */\n\tif (unlikely(sta_id == IWL_INVALID_STATION))\n\t\treturn sta_id;\n\n\t/*\n\t * uCode is not able to deal with multiple requests to add a\n\t * station. Keep track if one is in progress so that we do not send\n\t * another.\n\t */\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {\n\t\tIWL_DEBUG_INFO(priv, \"STA %d already in process of being \"\n\t\t\t       \"added.\\n\", sta_id);\n\t\treturn sta_id;\n\t}\n\n\tif ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&\n\t    (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) &&\n\t    !compare_ether_addr(priv->stations[sta_id].sta.sta.addr, addr)) {\n\t\tIWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"\n\t\t\t\t\"adding again.\\n\", sta_id, addr);\n\t\treturn sta_id;\n\t}\n\n\tstation = &priv->stations[sta_id];\n\tstation->used = IWL_STA_DRIVER_ACTIVE;\n\tIWL_DEBUG_ASSOC(priv, \"Add STA to driver ID %d: %pM\\n\",\n\t\t\tsta_id, addr);\n\tpriv->num_stations++;\n\n\t/* Set up the REPLY_ADD_STA command to send to device */\n\tmemset(&station->sta, 0, sizeof(struct iwl_addsta_cmd));\n\tmemcpy(station->sta.sta.addr, addr, ETH_ALEN);\n\tstation->sta.mode = 0;\n\tstation->sta.sta.sta_id = sta_id;\n\tstation->sta.station_flags = ctx->station_flags;\n\tstation->ctxid = ctx->ctxid;\n\n\tif (sta) {\n\t\tstruct iwl_station_priv *sta_priv;\n\n\t\tsta_priv = (void *)sta->drv_priv;\n\t\tsta_priv->ctx = ctx;\n\t}\n\n\t/*\n\t * OK to call unconditionally, since local stations (IBSS BSSID\n\t * STA and broadcast STA) pass in a NULL sta, and mac80211\n\t * doesn't allow HT IBSS.\n\t */\n\tiwl_set_ht_add_station(priv, sta_id, sta, ctx);\n\n\treturn sta_id;\n\n}\n\n#define STA_WAIT_TIMEOUT (HZ/2)\n\n/**\n * iwl_add_station_common -\n */\nint iwl_add_station_common(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t\t   const u8 *addr, bool is_ap,\n\t\t\t   struct ieee80211_sta *sta, u8 *sta_id_r)\n{\n\tunsigned long flags_spin;\n\tint ret = 0;\n\tu8 sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\t*sta_id_r = 0;\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tsta_id = iwl_prep_station(priv, ctx, addr, is_ap, sta);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Unable to prepare station %pM for addition\\n\",\n\t\t\taddr);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * uCode is not able to deal with multiple requests to add a\n\t * station. Keep track if one is in progress so that we do not send\n\t * another.\n\t */\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {\n\t\tIWL_DEBUG_INFO(priv, \"STA %d already in process of being \"\n\t\t\t       \"added.\\n\", sta_id);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\tif ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&\n\t    (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {\n\t\tIWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"\n\t\t\t\t\"adding again.\\n\", sta_id, addr);\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\tpriv->stations[sta_id].used |= IWL_STA_UCODE_INPROGRESS;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\n\t       sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\t/* Add station to device's station table */\n\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\tIWL_ERR(priv, \"Adding station %pM failed.\\n\",\n\t\t\tpriv->stations[sta_id].sta.sta.addr);\n\t\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\t\tpriv->stations[sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t}\n\t*sta_id_r = sta_id;\n\treturn ret;\n}\n\n/**\n * iwl_sta_ucode_deactivate - deactivate ucode status for a station\n *\n * priv->shrd->sta_lock must be held\n */\nstatic void iwl_sta_ucode_deactivate(struct iwl_priv *priv, u8 sta_id)\n{\n\t/* Ucode must be active and driver must be non active */\n\tif ((priv->stations[sta_id].used &\n\t     (IWL_STA_UCODE_ACTIVE | IWL_STA_DRIVER_ACTIVE)) !=\n\t      IWL_STA_UCODE_ACTIVE)\n\t\tIWL_ERR(priv, \"removed non active STA %u\\n\", sta_id);\n\n\tpriv->stations[sta_id].used &= ~IWL_STA_UCODE_ACTIVE;\n\n\tmemset(&priv->stations[sta_id], 0, sizeof(struct iwl_station_entry));\n\tIWL_DEBUG_ASSOC(priv, \"Removed STA %u\\n\", sta_id);\n}\n\nstatic int iwl_send_remove_station(struct iwl_priv *priv,\n\t\t\t\t   const u8 *addr, int sta_id,\n\t\t\t\t   bool temporary)\n{\n\tstruct iwl_rx_packet *pkt;\n\tint ret;\n\n\tunsigned long flags_spin;\n\tstruct iwl_rem_sta_cmd rm_sta_cmd;\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_REMOVE_STA,\n\t\t.len = { sizeof(struct iwl_rem_sta_cmd), },\n\t\t.flags = CMD_SYNC,\n\t\t.data = { &rm_sta_cmd, },\n\t};\n\n\tmemset(&rm_sta_cmd, 0, sizeof(rm_sta_cmd));\n\trm_sta_cmd.num_sta = 1;\n\tmemcpy(&rm_sta_cmd.addr, addr, ETH_ALEN);\n\n\tcmd.flags |= CMD_WANT_SKB;\n\n\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = (struct iwl_rx_packet *)cmd.reply_page;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_REMOVE_STA (0x%08X)\\n\",\n\t\t\t  pkt->hdr.flags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tswitch (pkt->u.rem_sta.status) {\n\t\tcase REM_STA_SUCCESS_MSK:\n\t\t\tif (!temporary) {\n\t\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t\tiwl_sta_ucode_deactivate(priv, sta_id);\n\t\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t}\n\t\t\tIWL_DEBUG_ASSOC(priv, \"REPLY_REMOVE_STA PASSED\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tIWL_ERR(priv, \"REPLY_REMOVE_STA failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tiwl_free_pages(priv->shrd, cmd.reply_page);\n\n\treturn ret;\n}\n\n/**\n * iwl_remove_station - Remove driver's knowledge of station.\n */\nint iwl_remove_station(struct iwl_priv *priv, const u8 sta_id,\n\t\t       const u8 *addr)\n{\n\tunsigned long flags;\n\tu8 tid;\n\n\tif (!iwl_is_ready(priv->shrd)) {\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\"Unable to remove station %pM, device not ready.\\n\",\n\t\t\taddr);\n\t\t/*\n\t\t * It is typical for stations to be removed when we are\n\t\t * going down. Return success since device will be down\n\t\t * soon anyway\n\t\t */\n\t\treturn 0;\n\t}\n\n\tIWL_DEBUG_ASSOC(priv, \"Removing STA from driver:%d  %pM\\n\",\n\t\t\tsta_id, addr);\n\n\tif (WARN_ON(sta_id == IWL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tIWL_DEBUG_INFO(priv, \"Removing %pM but non DRIVER active\\n\",\n\t\t\t\taddr);\n\t\tgoto out_err;\n\t}\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {\n\t\tIWL_DEBUG_INFO(priv, \"Removing %pM but non UCODE active\\n\",\n\t\t\t\taddr);\n\t\tgoto out_err;\n\t}\n\n\tif (priv->stations[sta_id].used & IWL_STA_LOCAL) {\n\t\tkfree(priv->stations[sta_id].lq);\n\t\tpriv->stations[sta_id].lq = NULL;\n\t}\n\n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)\n\t\tmemset(&priv->tid_data[sta_id][tid], 0,\n\t\t\tsizeof(priv->tid_data[sta_id][tid]));\n\n\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\n\tpriv->num_stations--;\n\n\tif (WARN_ON(priv->num_stations < 0))\n\t\tpriv->num_stations = 0;\n\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_remove_station(priv, addr, sta_id, false);\nout_err:\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn -EINVAL;\n}\n\n/**\n * iwl_clear_ucode_stations - clear ucode station table bits\n *\n * This function clears all the bits in the driver indicating\n * which stations are active in the ucode. Call when something\n * other than explicit station management would cause this in\n * the ucode, e.g. unassociated RXON.\n */\nvoid iwl_clear_ucode_stations(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx)\n{\n\tint i;\n\tunsigned long flags_spin;\n\tbool cleared = false;\n\n\tIWL_DEBUG_INFO(priv, \"Clearing ucode stations in driver\\n\");\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (ctx && ctx->ctxid != priv->stations[i].ctxid)\n\t\t\tcontinue;\n\n\t\tif (priv->stations[i].used & IWL_STA_UCODE_ACTIVE) {\n\t\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\t\"Clearing ucode active for station %d\\n\", i);\n\t\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;\n\t\t\tcleared = true;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\tif (!cleared)\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"No active stations found to be cleared\\n\");\n}\n\n/**\n * iwl_restore_stations() - Restore driver known stations to device\n *\n * All stations considered active by driver, but not present in ucode, is\n * restored.\n *\n * Function sleeps.\n */\nvoid iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_addsta_cmd sta_cmd;\n\tstruct iwl_link_quality_cmd lq;\n\tunsigned long flags_spin;\n\tint i;\n\tbool found = false;\n\tint ret;\n\tbool send_lq;\n\n\tif (!iwl_is_ready(priv->shrd)) {\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"Not ready yet, not restoring any stations.\\n\");\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_ASSOC(priv, \"Restoring all known stations ... start.\\n\");\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (ctx->ctxid != priv->stations[i].ctxid)\n\t\t\tcontinue;\n\t\tif ((priv->stations[i].used & IWL_STA_DRIVER_ACTIVE) &&\n\t\t\t    !(priv->stations[i].used & IWL_STA_UCODE_ACTIVE)) {\n\t\t\tIWL_DEBUG_ASSOC(priv, \"Restoring sta %pM\\n\",\n\t\t\t\t\tpriv->stations[i].sta.sta.addr);\n\t\t\tpriv->stations[i].sta.mode = 0;\n\t\t\tpriv->stations[i].used |= IWL_STA_UCODE_INPROGRESS;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif ((priv->stations[i].used & IWL_STA_UCODE_INPROGRESS)) {\n\t\t\tmemcpy(&sta_cmd, &priv->stations[i].sta,\n\t\t\t       sizeof(struct iwl_addsta_cmd));\n\t\t\tsend_lq = false;\n\t\t\tif (priv->stations[i].lq) {\n\t\t\t\tif (priv->shrd->wowlan)\n\t\t\t\t\tiwl_sta_fill_lq(priv, ctx, i, &lq);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(&lq, priv->stations[i].lq,\n\t\t\t\t\t       sizeof(struct iwl_link_quality_cmd));\n\t\t\t\tsend_lq = true;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\t       flags_spin);\n\t\t\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\t\t\tif (ret) {\n\t\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock,\n\t\t\t\t\t\t  flags_spin);\n\t\t\t\tIWL_ERR(priv, \"Adding station %pM failed.\\n\",\n\t\t\t\t\tpriv->stations[i].sta.sta.addr);\n\t\t\t\tpriv->stations[i].used &=\n\t\t\t\t\t\t~IWL_STA_DRIVER_ACTIVE;\n\t\t\t\tpriv->stations[i].used &=\n\t\t\t\t\t\t~IWL_STA_UCODE_INPROGRESS;\n\t\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\t\t       flags_spin);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Rate scaling has already been initialized, send\n\t\t\t * current LQ command\n\t\t\t */\n\t\t\tif (send_lq)\n\t\t\t\tiwl_send_lq_cmd(priv, ctx, &lq,\n\t\t\t\t\t\tCMD_SYNC, true);\n\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\tif (!found)\n\t\tIWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"\n\t\t\t\"no stations to be restored.\\n\");\n\telse\n\t\tIWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"\n\t\t\t\"complete.\\n\");\n}\n\nvoid iwl_reprogram_ap_sta(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tunsigned long flags;\n\tint sta_id = ctx->ap_sta_id;\n\tint ret;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tstruct iwl_link_quality_cmd lq;\n\tbool active, have_lq = false;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\t\treturn;\n\t}\n\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tsta_cmd.mode = 0;\n\tif (priv->stations[sta_id].lq) {\n\t\tmemcpy(&lq, priv->stations[sta_id].lq, sizeof(lq));\n\t\thave_lq = true;\n\t}\n\n\tactive = priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE;\n\tpriv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tif (active) {\n\t\tret = iwl_send_remove_station(\n\t\t\tpriv, priv->stations[sta_id].sta.sta.addr,\n\t\t\tsta_id, true);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"failed to remove STA %pM (%d)\\n\",\n\t\t\t\tpriv->stations[sta_id].sta.sta.addr, ret);\n\t}\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n\tif (ret)\n\t\tIWL_ERR(priv, \"failed to re-add STA %pM (%d)\\n\",\n\t\t\tpriv->stations[sta_id].sta.sta.addr, ret);\n\tif (have_lq)\n\t\tiwl_send_lq_cmd(priv, ctx, &lq, CMD_SYNC, true);\n}\n\nint iwl_get_free_ucode_key_offset(struct iwl_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->sta_key_max_num; i++)\n\t\tif (!test_and_set_bit(i, &priv->ucode_key_table))\n\t\t\treturn i;\n\n\treturn WEP_INVALID_OFFSET;\n}\n\nvoid iwl_dealloc_bcast_stations(struct iwl_priv *priv)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tfor (i = 0; i < IWLAGN_STATION_COUNT; i++) {\n\t\tif (!(priv->stations[i].used & IWL_STA_BCAST))\n\t\t\tcontinue;\n\n\t\tpriv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;\n\t\tpriv->num_stations--;\n\t\tif (WARN_ON(priv->num_stations < 0))\n\t\t\tpriv->num_stations = 0;\n\t\tkfree(priv->stations[i].lq);\n\t\tpriv->stations[i].lq = NULL;\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nstatic void iwl_dump_lq_cmd(struct iwl_priv *priv,\n\t\t\t   struct iwl_link_quality_cmd *lq)\n{\n\tint i;\n\tIWL_DEBUG_RATE(priv, \"lq station id 0x%x\\n\", lq->sta_id);\n\tIWL_DEBUG_RATE(priv, \"lq ant 0x%X 0x%X\\n\",\n\t\t       lq->general_params.single_stream_ant_msk,\n\t\t       lq->general_params.dual_stream_ant_msk);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tIWL_DEBUG_RATE(priv, \"lq index %d 0x%X\\n\",\n\t\t\t       i, lq->rs_table[i].rate_n_flags);\n}\n#else\nstatic inline void iwl_dump_lq_cmd(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_link_quality_cmd *lq)\n{\n}\n#endif\n\n/**\n * is_lq_table_valid() - Test one aspect of LQ cmd for validity\n *\n * It sometimes happens when a HT rate has been in use and we\n * loose connectivity with AP then mac80211 will first tell us that the\n * current channel is not HT anymore before removing the station. In such a\n * scenario the RXON flags will be updated to indicate we are not\n * communicating HT anymore, but the LQ command may still contain HT rates.\n * Test for this to prevent driver from sending LQ command between the time\n * RXON flags are updated and when LQ command is updated.\n */\nstatic bool is_lq_table_valid(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t      struct iwl_link_quality_cmd *lq)\n{\n\tint i;\n\n\tif (ctx->ht.enabled)\n\t\treturn true;\n\n\tIWL_DEBUG_INFO(priv, \"Channel %u is not an HT channel\\n\",\n\t\t       ctx->active.channel);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tif (le32_to_cpu(lq->rs_table[i].rate_n_flags) &\n\t\t    RATE_MCS_HT_MSK) {\n\t\t\tIWL_DEBUG_INFO(priv,\n\t\t\t\t       \"index %d of LQ expects HT channel\\n\",\n\t\t\t\t       i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * iwl_send_lq_cmd() - Send link quality command\n * @init: This command is sent as part of station initialization right\n *        after station has been added.\n *\n * The link quality command is sent as the last step of station creation.\n * This is the special case in which init is set and we call a callback in\n * this case to clear the state indicating that station creation is in\n * progress.\n */\nint iwl_send_lq_cmd(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t    struct iwl_link_quality_cmd *lq, u8 flags, bool init)\n{\n\tint ret = 0;\n\tunsigned long flags_spin;\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_TX_LINK_QUALITY_CMD,\n\t\t.len = { sizeof(struct iwl_link_quality_cmd), },\n\t\t.flags = flags,\n\t\t.data = { lq, },\n\t};\n\n\tif (WARN_ON(lq->sta_id == IWL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\tif (!(priv->stations[lq->sta_id].used & IWL_STA_DRIVER_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\n\tiwl_dump_lq_cmd(priv, lq);\n\tif (WARN_ON(init && (cmd.flags & CMD_ASYNC)))\n\t\treturn -EINVAL;\n\n\tif (is_lq_table_valid(priv, ctx, lq))\n\t\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\telse\n\t\tret = -EINVAL;\n\n\tif (cmd.flags & CMD_ASYNC)\n\t\treturn ret;\n\n\tif (init) {\n\t\tIWL_DEBUG_INFO(priv, \"init LQ command complete, \"\n\t\t\t       \"clearing sta addition status for sta %d\\n\",\n\t\t\t       lq->sta_id);\n\t\tspin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);\n\t\tpriv->stations[lq->sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);\n\t}\n\treturn ret;\n}\n\n\nvoid iwl_sta_fill_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t     u8 sta_id, struct iwl_link_quality_cmd *link_cmd)\n{\n\tint i, r;\n\tu32 rate_flags = 0;\n\t__le32 rate_n_flags;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tmemset(link_cmd, 0, sizeof(*link_cmd));\n\n\t/* Set up the rate scaling to start at selected rate, fall back\n\t * all the way down to 1M in IEEE order, and then spin on 1M */\n\tif (priv->band == IEEE80211_BAND_5GHZ)\n\t\tr = IWL_RATE_6M_INDEX;\n\telse if (ctx && ctx->vif && ctx->vif->p2p)\n\t\tr = IWL_RATE_6M_INDEX;\n\telse\n\t\tr = IWL_RATE_1M_INDEX;\n\n\tif (r >= IWL_FIRST_CCK_RATE && r <= IWL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\trate_flags |= first_antenna(hw_params(priv).valid_tx_ant) <<\n\t\t\t\tRATE_MCS_ANT_POS;\n\trate_n_flags = iwl_hw_set_rate_n_flags(iwl_rates[r].plcp, rate_flags);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\n\n\tlink_cmd->general_params.single_stream_ant_msk =\n\t\t\tfirst_antenna(hw_params(priv).valid_tx_ant);\n\n\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\thw_params(priv).valid_tx_ant &\n\t\t~first_antenna(hw_params(priv).valid_tx_ant);\n\tif (!link_cmd->general_params.dual_stream_ant_msk) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (num_of_ant(hw_params(priv).valid_tx_ant) == 2) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\t\thw_params(priv).valid_tx_ant;\n\t}\n\n\tlink_cmd->agg_params.agg_dis_start_th =\n\t\tLINK_QUAL_AGG_DISABLE_START_DEF;\n\tlink_cmd->agg_params.agg_time_limit =\n\t\tcpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n\n\tlink_cmd->sta_id = sta_id;\n}\n\nstatic struct iwl_link_quality_cmd *\niwl_sta_alloc_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t u8 sta_id)\n{\n\tstruct iwl_link_quality_cmd *link_cmd;\n\n\tlink_cmd = kzalloc(sizeof(struct iwl_link_quality_cmd), GFP_KERNEL);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv, \"Unable to allocate memory for LQ cmd.\\n\");\n\t\treturn NULL;\n\t}\n\n\tiwl_sta_fill_lq(priv, ctx, sta_id, link_cmd);\n\n\treturn link_cmd;\n}\n\n/*\n * iwlagn_add_bssid_station - Add the special IBSS BSSID station\n *\n * Function sleeps.\n */\nint iwlagn_add_bssid_station(struct iwl_priv *priv,\n\t\t\t     struct iwl_rxon_context *ctx,\n\t\t\t     const u8 *addr, u8 *sta_id_r)\n{\n\tint ret;\n\tu8 sta_id;\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\n\tif (sta_id_r)\n\t\t*sta_id_r = IWL_INVALID_STATION;\n\n\tret = iwl_add_station_common(priv, ctx, addr, 0, NULL, &sta_id);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Unable to add station %pM\\n\", addr);\n\t\treturn ret;\n\t}\n\n\tif (sta_id_r)\n\t\t*sta_id_r = sta_id;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].used |= IWL_STA_LOCAL;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\t/* Set up default rate scaling table in device's station table */\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Unable to initialize rate scaling for station %pM.\\n\",\n\t\t\taddr);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = iwl_send_lq_cmd(priv, ctx, link_cmd, CMD_SYNC, true);\n\tif (ret)\n\t\tIWL_ERR(priv, \"Link quality command failed (%d)\\n\", ret);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\n/*\n * static WEP keys\n *\n * For each context, the device has a table of 4 static WEP keys\n * (one for each key index) that is updated with the following\n * commands.\n */\n\nstatic int iwl_send_static_wepkey_cmd(struct iwl_priv *priv,\n\t\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t\t      bool send_if_empty)\n{\n\tint i, not_empty = 0;\n\tu8 buff[sizeof(struct iwl_wep_cmd) +\n\t\tsizeof(struct iwl_wep_key) * WEP_KEYS_MAX];\n\tstruct iwl_wep_cmd *wep_cmd = (struct iwl_wep_cmd *)buff;\n\tsize_t cmd_size  = sizeof(struct iwl_wep_cmd);\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = ctx->wep_key_cmd,\n\t\t.data = { wep_cmd, },\n\t\t.flags = CMD_SYNC,\n\t};\n\n\tmight_sleep();\n\n\tmemset(wep_cmd, 0, cmd_size +\n\t\t\t(sizeof(struct iwl_wep_key) * WEP_KEYS_MAX));\n\n\tfor (i = 0; i < WEP_KEYS_MAX ; i++) {\n\t\twep_cmd->key[i].key_index = i;\n\t\tif (ctx->wep_keys[i].key_size) {\n\t\t\twep_cmd->key[i].key_offset = i;\n\t\t\tnot_empty = 1;\n\t\t} else {\n\t\t\twep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\n\t\t}\n\n\t\twep_cmd->key[i].key_size = ctx->wep_keys[i].key_size;\n\t\tmemcpy(&wep_cmd->key[i].key[3], ctx->wep_keys[i].key,\n\t\t\t\tctx->wep_keys[i].key_size);\n\t}\n\n\twep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\n\twep_cmd->num_keys = WEP_KEYS_MAX;\n\n\tcmd_size += sizeof(struct iwl_wep_key) * WEP_KEYS_MAX;\n\n\tcmd.len[0] = cmd_size;\n\n\tif (not_empty || send_if_empty)\n\t\treturn iwl_trans_send_cmd(trans(priv), &cmd);\n\telse\n\t\treturn 0;\n}\n\nint iwl_restore_default_wep_keys(struct iwl_priv *priv,\n\t\t\t\t struct iwl_rxon_context *ctx)\n{\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\treturn iwl_send_static_wepkey_cmd(priv, ctx, false);\n}\n\nint iwl_remove_default_wep_key(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx,\n\t\t\t       struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tIWL_DEBUG_WEP(priv, \"Removing default WEP key: idx=%d\\n\",\n\t\t      keyconf->keyidx);\n\n\tmemset(&ctx->wep_keys[keyconf->keyidx], 0, sizeof(ctx->wep_keys[0]));\n\tif (iwl_is_rfkill(priv->shrd)) {\n\t\tIWL_DEBUG_WEP(priv,\n\t\t\t\"Not sending REPLY_WEPKEY command due to RFKILL.\\n\");\n\t\t/* but keys in device are clear anyway so return success */\n\t\treturn 0;\n\t}\n\tret = iwl_send_static_wepkey_cmd(priv, ctx, 1);\n\tIWL_DEBUG_WEP(priv, \"Remove default WEP key: idx=%d ret=%d\\n\",\n\t\t      keyconf->keyidx, ret);\n\n\treturn ret;\n}\n\nint iwl_set_default_wep_key(struct iwl_priv *priv,\n\t\t\t    struct iwl_rxon_context *ctx,\n\t\t\t    struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tif (keyconf->keylen != WEP_KEY_LEN_128 &&\n\t    keyconf->keylen != WEP_KEY_LEN_64) {\n\t\tIWL_DEBUG_WEP(priv,\n\t\t\t      \"Bad WEP key length %d\\n\", keyconf->keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tkeyconf->hw_key_idx = IWLAGN_HW_KEY_DEFAULT;\n\n\tctx->wep_keys[keyconf->keyidx].key_size = keyconf->keylen;\n\tmemcpy(&ctx->wep_keys[keyconf->keyidx].key, &keyconf->key,\n\t\t\t\t\t\t\tkeyconf->keylen);\n\n\tret = iwl_send_static_wepkey_cmd(priv, ctx, false);\n\tIWL_DEBUG_WEP(priv, \"Set default WEP key: len=%d idx=%d ret=%d\\n\",\n\t\tkeyconf->keylen, keyconf->keyidx, ret);\n\n\treturn ret;\n}\n\n/*\n * dynamic (per-station) keys\n *\n * The dynamic keys are a little more complicated. The device has\n * a key cache of up to STA_KEY_MAX_NUM/STA_KEY_MAX_NUM_PAN keys.\n * These are linked to stations by a table that contains an index\n * into the key table for each station/key index/{mcast,unicast},\n * i.e. it's basically an array of pointers like this:\n *\tkey_offset_t key_mapping[NUM_STATIONS][4][2];\n * (it really works differently, but you can think of it as such)\n *\n * The key uploading and linking happens in the same command, the\n * add station command with STA_MODIFY_KEY_MASK.\n */\n\nstatic u8 iwlagn_key_sta_id(struct iwl_priv *priv,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tu8 sta_id = IWL_INVALID_STATION;\n\n\tif (sta)\n\t\tsta_id = iwl_sta_id(sta);\n\n\t/*\n\t * The device expects GTKs for station interfaces to be\n\t * installed as GTKs for the AP station. If we have no\n\t * station ID, then use the ap_sta_id in that case.\n\t */\n\tif (!sta && vif && vif_priv->ctx) {\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tsta_id = vif_priv->ctx->ap_sta_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * In all other cases, the key will be\n\t\t\t * used either for TX only or is bound\n\t\t\t * to a station already.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sta_id;\n}\n\nstatic int iwlagn_send_sta_key(struct iwl_priv *priv,\n\t\t\t       struct ieee80211_key_conf *keyconf,\n\t\t\t       u8 sta_id, u32 tkip_iv32, u16 *tkip_p1k,\n\t\t\t       u32 cmd_flags)\n{\n\tunsigned long flags;\n\t__le16 key_flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tint i;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tkey_flags = cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags |= STA_KEY_FLG_MAP_KEY_MSK;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_flags |= STA_KEY_FLG_CCMP;\n\t\tmemcpy(sta_cmd.key.key, keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_flags |= STA_KEY_FLG_TKIP;\n\t\tsta_cmd.key.tkip_rx_tsc_byte2 = tkip_iv32;\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tsta_cmd.key.tkip_rx_ttak[i] = cpu_to_le16(tkip_p1k[i]);\n\t\tmemcpy(sta_cmd.key.key, keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\n\t\t/* fall through */\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey_flags |= STA_KEY_FLG_WEP;\n\t\tmemcpy(&sta_cmd.key.key[3], keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\t/* key pointer (offset) */\n\tsta_cmd.key.key_offset = keyconf->hw_key_idx;\n\n\tsta_cmd.key.key_flags = key_flags;\n\tsta_cmd.mode = STA_CONTROL_MODIFY_MSK;\n\tsta_cmd.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, cmd_flags);\n}\n\nvoid iwl_update_tkip_key(struct iwl_priv *priv,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t struct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\n{\n\tu8 sta_id = iwlagn_key_sta_id(priv, vif, sta);\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn;\n\n\tif (iwl_scan_cancel(priv)) {\n\t\t/* cancel scan failed, just live w/ bad key and rely\n\t\t   briefly on SW decryption */\n\t\treturn;\n\t}\n\n\tiwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t    iv32, phase1key, CMD_ASYNC);\n}\n\nint iwl_remove_dynamic_key(struct iwl_priv *priv,\n\t\t\t   struct iwl_rxon_context *ctx,\n\t\t\t   struct ieee80211_key_conf *keyconf,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tunsigned long flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\tu8 sta_id = iwlagn_key_sta_id(priv, ctx->vif, sta);\n\n\t/* if station isn't there, neither is the key */\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -ENOENT;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));\n\tif (!(priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE))\n\t\tsta_id = IWL_INVALID_STATION;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn 0;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tctx->key_mapping_keys--;\n\n\tIWL_DEBUG_WEP(priv, \"Remove dynamic key: idx=%d sta=%d\\n\",\n\t\t      keyconf->keyidx, sta_id);\n\n\tif (!test_and_clear_bit(keyconf->hw_key_idx, &priv->ucode_key_table))\n\t\tIWL_ERR(priv, \"offset %d not used in uCode key table.\\n\",\n\t\t\tkeyconf->hw_key_idx);\n\n\tsta_cmd.key.key_flags = STA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\n\tsta_cmd.key.key_offset = WEP_INVALID_OFFSET;\n\tsta_cmd.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\tsta_cmd.mode = STA_CONTROL_MODIFY_MSK;\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_set_dynamic_key(struct iwl_priv *priv,\n\t\t\tstruct iwl_rxon_context *ctx,\n\t\t\tstruct ieee80211_key_conf *keyconf,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ieee80211_key_seq seq;\n\tu16 p1k[5];\n\tint ret;\n\tu8 sta_id = iwlagn_key_sta_id(priv, ctx->vif, sta);\n\tconst u8 *addr;\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -EINVAL;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tkeyconf->hw_key_idx = iwl_get_free_ucode_key_offset(priv);\n\tif (keyconf->hw_key_idx == WEP_INVALID_OFFSET)\n\t\treturn -ENOSPC;\n\n\tctx->key_mapping_keys++;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta)\n\t\t\taddr = sta->addr;\n\t\telse /* station mode case only */\n\t\t\taddr = ctx->active.bssid_addr;\n\n\t\t/* pre-fill phase 1 key into device cache */\n\t\tieee80211_get_key_rx_seq(keyconf, 0, &seq);\n\t\tieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);\n\t\tret = iwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t\t\t  seq.tkip.iv32, p1k, CMD_SYNC);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tret = iwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t\t\t  0, NULL, CMD_SYNC);\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Unknown cipher %x\\n\", keyconf->cipher);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tctx->key_mapping_keys--;\n\t\tclear_bit(keyconf->hw_key_idx, &priv->ucode_key_table);\n\t}\n\n\tIWL_DEBUG_WEP(priv, \"Set dynamic key: cipher=%x len=%d idx=%d sta=%pM ret=%d\\n\",\n\t\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx,\n\t\t      sta ? sta->addr : NULL, ret);\n\n\treturn ret;\n}\n\n/**\n * iwlagn_alloc_bcast_station - add broadcast station into driver's station table.\n *\n * This adds the broadcast station into the driver's station table\n * and marks it driver active, so that it will be restored to the\n * device at the next best time.\n */\nint iwlagn_alloc_bcast_station(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\tu8 sta_id;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tsta_id = iwl_prep_station(priv, ctx, iwl_bcast_addr, false, NULL);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Unable to prepare broadcast station\\n\");\n\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;\n\tpriv->stations[sta_id].used |= IWL_STA_BCAST;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\n/**\n * iwl_update_bcast_station - update broadcast station's LQ command\n *\n * Only used by iwlagn. Placed here to have all bcast station management\n * code together.\n */\nint iwl_update_bcast_station(struct iwl_priv *priv,\n\t\t\t     struct iwl_rxon_context *ctx)\n{\n\tunsigned long flags;\n\tstruct iwl_link_quality_cmd *link_cmd;\n\tu8 sta_id = ctx->bcast_sta_id;\n\n\tlink_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);\n\tif (!link_cmd) {\n\t\tIWL_ERR(priv, \"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tif (priv->stations[sta_id].lq)\n\t\tkfree(priv->stations[sta_id].lq);\n\telse\n\t\tIWL_DEBUG_INFO(priv, \"Bcast station rate scaling has not been initialized yet.\\n\");\n\tpriv->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn 0;\n}\n\nint iwl_update_bcast_stations(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\tint ret = 0;\n\n\tfor_each_context(priv, ctx) {\n\t\tret = iwl_update_bcast_station(priv, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n * iwl_sta_tx_modify_enable_tid - Enable Tx for this TID in station table\n */\nint iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv, int sta_id, int tid)\n{\n\tunsigned long flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\t/* Remove \"disable\" flag, to enable Tx for this TID */\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\tpriv->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_sta_rx_agg_start(struct iwl_priv *priv, struct ieee80211_sta *sta,\n\t\t\t int tid, u16 ssn)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tsta_id = iwl_sta_id(sta);\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags_msk = 0;\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\n\tpriv->stations[sta_id].sta.add_immediate_ba_tid = (u8)tid;\n\tpriv->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\nint iwl_sta_rx_agg_stop(struct iwl_priv *priv, struct ieee80211_sta *sta,\n\t\t\tint tid)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\tsta_id = iwl_sta_id(sta);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags_msk = 0;\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\n\tpriv->stations[sta_id].sta.remove_immediate_ba_tid = (u8)tid;\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n\n\n\nvoid iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv, int sta_id, int cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\n\tpriv->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\n\tpriv->stations[sta_id].sta.sta.modify_mask =\n\t\t\t\t\tSTA_MODIFY_SLEEP_TX_COUNT_MSK;\n\tpriv->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tiwl_send_add_sta(priv, &priv->stations[sta_id].sta, CMD_ASYNC);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n}\n"], "filenames": ["drivers/net/wireless/iwlwifi/iwl-agn-sta.c"], "buggy_code_start_loc": [38], "buggy_code_end_loc": [82], "fixing_code_start_loc": [38], "fixing_code_end_loc": [85], "type": "CWE-119", "message": "In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption.", "other": {"cve": {"id": "CVE-2012-6712", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:11.323", "lastModified": "2022-11-03T02:10:57.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 3.4, ocurre un desbordamiento de b\u00fafer en el archivo drivers/net/wireless/iwlwifi/iwl-agn-sta.c, que causar\u00e1 al menos una corrupci\u00f3n de memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.27", "versionEndExcluding": "3.4", "matchCriteriaId": "C6D146FC-F039-4EBE-B4EC-B76476932290"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2da424b0773cea3db47e1e81db71eeebde8269d4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.4", "source": "cve@mitre.org", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4"}}