{"buggy_code": ["<?php\n/**\n * @author Arthur Schiwon <blizzz@owncloud.com>\n * @author Bart Visscher <bartv@thisnet.nl>\n * @author Bj\u00f6rn Schie\u00dfle <schiessle@owncloud.com>\n * @author Felix Moeller <mail@felixmoeller.de>\n * @author Florin Peter <github@florin-peter.de>\n * @author Georg Ehrke <georg@owncloud.com>\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author J\u00f6rn Friedrich Dreyer <jfd@butonic.de>\n * @author Lukas Reschke <lukas@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Robin McCorkell <robin@mccorkell.me.uk>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Victor Dubiniuk <dubiniuk@owncloud.com>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\n/**\n * Versions\n *\n * A class to handle the versioning of files.\n */\n\nnamespace OCA\\Files_Versions;\n\nuse OC\\Files\\Filesystem;\nuse OC\\Files\\View;\nuse OCA\\Files_Versions\\AppInfo\\Application;\nuse OCA\\Files_Versions\\Command\\Expire;\nuse OCP\\Files\\NotFoundException;\nuse OCP\\Lock\\ILockingProvider;\nuse OCP\\User;\n\nclass Storage {\n\n\tconst DEFAULTENABLED=true;\n\tconst DEFAULTMAXSIZE=50; // unit: percentage; 50% of available disk space/quota\n\tconst VERSIONS_ROOT = 'files_versions/';\n\n\tconst DELETE_TRIGGER_MASTER_REMOVED = 0;\n\tconst DELETE_TRIGGER_RETENTION_CONSTRAINT = 1;\n\tconst DELETE_TRIGGER_QUOTA_EXCEEDED = 2;\n\n\t// files for which we can remove the versions after the delete operation was successful\n\tprivate static $deletedFiles = array();\n\n\tprivate static $sourcePathAndUser = array();\n\n\tprivate static $max_versions_per_interval = array(\n\t\t//first 10sec, one version every 2sec\n\t\t1 => array('intervalEndsAfter' => 10,      'step' => 2),\n\t\t//next minute, one version every 10sec\n\t\t2 => array('intervalEndsAfter' => 60,      'step' => 10),\n\t\t//next hour, one version every minute\n\t\t3 => array('intervalEndsAfter' => 3600,    'step' => 60),\n\t\t//next 24h, one version every hour\n\t\t4 => array('intervalEndsAfter' => 86400,   'step' => 3600),\n\t\t//next 30days, one version per day\n\t\t5 => array('intervalEndsAfter' => 2592000, 'step' => 86400),\n\t\t//until the end one version per week\n\t\t6 => array('intervalEndsAfter' => -1,      'step' => 604800),\n\t);\n\t\n\t/** @var \\OCA\\Files_Versions\\AppInfo\\Application */\n\tprivate static $application;\n\n\t/**\n\t * get the UID of the owner of the file and the path to the file relative to\n\t * owners files folder\n\t *\n\t * @param string $filename\n\t * @return array\n\t * @throws \\OC\\User\\NoUserException\n\t */\n\tpublic static function getUidAndFilename($filename) {\n\t\t$uid = Filesystem::getOwner($filename);\n\t\t$userManager = \\OC::$server->getUserManager();\n\t\t// if the user with the UID doesn't exists, e.g. because the UID points\n\t\t// to a remote user with a federated cloud ID we use the current logged-in\n\t\t// user. We need a valid local user to create the versions\n\t\tif (!$userManager->userExists($uid)) {\n\t\t\t$uid = User::getUser();\n\t\t}\n\t\tFilesystem::initMountPoints($uid);\n\t\tif ( $uid != User::getUser() ) {\n\t\t\t$info = Filesystem::getFileInfo($filename);\n\t\t\t$ownerView = new View('/'.$uid.'/files');\n\t\t\ttry {\n\t\t\t\t$filename = $ownerView->getPath($info['fileid']);\n\t\t\t\t// make sure that the file name doesn't end with a trailing slash\n\t\t\t\t// can for example happen single files shared across servers\n\t\t\t\t$filename = rtrim($filename, '/');\n\t\t\t} catch (NotFoundException $e) {\n\t\t\t\t$filename = null;\n\t\t\t}\n\t\t}\n\t\treturn [$uid, $filename];\n\t}\n\n\t/**\n\t * Remember the owner and the owner path of the source file\n\t *\n\t * @param string $source source path\n\t */\n\tpublic static function setSourcePathAndUser($source) {\n\t\tlist($uid, $path) = self::getUidAndFilename($source);\n\t\tself::$sourcePathAndUser[$source] = array('uid' => $uid, 'path' => $path);\n\t}\n\n\t/**\n\t * Gets the owner and the owner path from the source path\n\t *\n\t * @param string $source source path\n\t * @return array with user id and path\n\t */\n\tpublic static function getSourcePathAndUser($source) {\n\n\t\tif (isset(self::$sourcePathAndUser[$source])) {\n\t\t\t$uid = self::$sourcePathAndUser[$source]['uid'];\n\t\t\t$path = self::$sourcePathAndUser[$source]['path'];\n\t\t\tunset(self::$sourcePathAndUser[$source]);\n\t\t} else {\n\t\t\t$uid = $path = false;\n\t\t}\n\t\treturn array($uid, $path);\n\t}\n\n\t/**\n\t * get current size of all versions from a given user\n\t *\n\t * @param string $user user who owns the versions\n\t * @return int versions size\n\t */\n\tprivate static function getVersionsSize($user) {\n\t\t$view = new View('/' . $user);\n\t\t$fileInfo = $view->getFileInfo('/files_versions');\n\t\treturn isset($fileInfo['size']) ? $fileInfo['size'] : 0;\n\t}\n\n\t/**\n\t * store a new version of a file.\n\t */\n\tpublic static function store($filename) {\n\t\tif(\\OCP\\Config::getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true') {\n\n\t\t\t// if the file gets streamed we need to remove the .part extension\n\t\t\t// to get the right target\n\t\t\t$ext = pathinfo($filename, PATHINFO_EXTENSION);\n\t\t\tif ($ext === 'part') {\n\t\t\t\t$filename = substr($filename, 0, strlen($filename) - 5);\n\t\t\t}\n\n\t\t\t// we only handle existing files\n\t\t\tif (! Filesystem::file_exists($filename) || Filesystem::is_dir($filename)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($filename);\n\n\t\t\t$files_view = new View('/'.$uid .'/files');\n\t\t\t$users_view = new View('/'.$uid);\n\n\t\t\t// no use making versions for empty files\n\t\t\tif ($files_view->filesize($filename) === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// create all parent folders\n\t\t\tself::createMissingDirectories($filename, $users_view);\n\n\t\t\tself::scheduleExpire($uid, $filename);\n\n\t\t\t// store a new version of a file\n\t\t\t$mtime = $users_view->filemtime('files/' . $filename);\n\t\t\t$users_view->copy('files/' . $filename, 'files_versions/' . $filename . '.v' . $mtime);\n\t\t\t// call getFileInfo to enforce a file cache entry for the new version\n\t\t\t$users_view->getFileInfo('files_versions/' . $filename . '.v' . $mtime);\n\t\t}\n\t}\n\n\n\t/**\n\t * mark file as deleted so that we can remove the versions if the file is gone\n\t * @param string $path\n\t */\n\tpublic static function markDeletedFile($path) {\n\t\tlist($uid, $filename) = self::getUidAndFilename($path);\n\t\tself::$deletedFiles[$path] = array(\n\t\t\t'uid' => $uid,\n\t\t\t'filename' => $filename);\n\t}\n\n\t/**\n\t * delete the version from the storage and cache\n\t *\n\t * @param View $view\n\t * @param string $path\n\t */\n\tprotected static function deleteVersion($view, $path) {\n\t\t$view->unlink($path);\n\t\t/**\n\t\t * @var \\OC\\Files\\Storage\\Storage $storage\n\t\t * @var string $internalPath\n\t\t */\n\t\tlist($storage, $internalPath) = $view->resolvePath($path);\n\t\t$cache = $storage->getCache($internalPath);\n\t\t$cache->remove($internalPath);\n\t}\n\n\t/**\n\t * Delete versions of a file\n\t */\n\tpublic static function delete($path) {\n\n\t\t$deletedFile = self::$deletedFiles[$path];\n\t\t$uid = $deletedFile['uid'];\n\t\t$filename = $deletedFile['filename'];\n\n\t\tif (!Filesystem::file_exists($path)) {\n\n\t\t\t$view = new View('/' . $uid . '/files_versions');\n\n\t\t\t$versions = self::getVersions($uid, $filename);\n\t\t\tif (!empty($versions)) {\n\t\t\t\tforeach ($versions as $v) {\n\t\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $path . $v['version'], 'trigger' => self::DELETE_TRIGGER_MASTER_REMOVED));\n\t\t\t\t\tself::deleteVersion($view, $filename . '.v' . $v['version']);\n\t\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $path . $v['version'], 'trigger' => self::DELETE_TRIGGER_MASTER_REMOVED));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunset(self::$deletedFiles[$path]);\n\t}\n\n\t/**\n\t * Rename or copy versions of a file of the given paths\n\t *\n\t * @param string $sourcePath source path of the file to move, relative to\n\t * the currently logged in user's \"files\" folder\n\t * @param string $targetPath target path of the file to move, relative to\n\t * the currently logged in user's \"files\" folder\n\t * @param string $operation can be 'copy' or 'rename'\n\t */\n\tpublic static function renameOrCopy($sourcePath, $targetPath, $operation) {\n\t\tlist($sourceOwner, $sourcePath) = self::getSourcePathAndUser($sourcePath);\n\n\t\t// it was a upload of a existing file if no old path exists\n\t\t// in this case the pre-hook already called the store method and we can\n\t\t// stop here\n\t\tif ($sourcePath === false) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlist($targetOwner, $targetPath) = self::getUidAndFilename($targetPath);\n\n\t\t$sourcePath = ltrim($sourcePath, '/');\n\t\t$targetPath = ltrim($targetPath, '/');\n\n\t\t$rootView = new View('');\n\n\t\t// did we move a directory ?\n\t\tif ($rootView->is_dir('/' . $targetOwner . '/files/' . $targetPath)) {\n\t\t\t// does the directory exists for versions too ?\n\t\t\tif ($rootView->is_dir('/' . $sourceOwner . '/files_versions/' . $sourcePath)) {\n\t\t\t\t// create missing dirs if necessary\n\t\t\t\tself::createMissingDirectories($targetPath, new View('/'. $targetOwner));\n\n\t\t\t\t// move the directory containing the versions\n\t\t\t\t$rootView->$operation(\n\t\t\t\t\t'/' . $sourceOwner . '/files_versions/' . $sourcePath,\n\t\t\t\t\t'/' . $targetOwner . '/files_versions/' . $targetPath\n\t\t\t\t);\n\t\t\t}\n\t\t} else if ($versions = Storage::getVersions($sourceOwner, '/' . $sourcePath)) {\n\t\t\t// create missing dirs if necessary\n\t\t\tself::createMissingDirectories($targetPath, new View('/'. $targetOwner));\n\n\t\t\tforeach ($versions as $v) {\n\t\t\t\t// move each version one by one to the target directory\n\t\t\t\t$rootView->$operation(\n\t\t\t\t\t'/' . $sourceOwner . '/files_versions/' . $sourcePath.'.v' . $v['version'],\n\t\t\t\t\t'/' . $targetOwner . '/files_versions/' . $targetPath.'.v'.$v['version']\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// if we moved versions directly for a file, schedule expiration check for that file\n\t\tif (!$rootView->is_dir('/' . $targetOwner . '/files/' . $targetPath)) {\n\t\t\tself::scheduleExpire($targetOwner, $targetPath);\n\t\t}\n\n\t}\n\n\t/**\n\t * Rollback to an old version of a file.\n\t *\n\t * @param string $file file name\n\t * @param int $revision revision timestamp\n\t */\n\tpublic static function rollback($file, $revision) {\n\n\t\tif(\\OCP\\Config::getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true') {\n\t\t\t// add expected leading slash\n\t\t\t$file = '/' . ltrim($file, '/');\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($file);\n\t\t\t$users_view = new View('/'.$uid);\n\t\t\t$files_view = new View('/'. User::getUser().'/files');\n\t\t\t$versionCreated = false;\n\n\t\t\t//first create a new version\n\t\t\t$version = 'files_versions'.$filename.'.v'.$users_view->filemtime('files'.$filename);\n\t\t\tif (!$users_view->file_exists($version)) {\n\t\t\t\t$users_view->copy('files'.$filename, 'files_versions'.$filename.'.v'.$users_view->filemtime('files'.$filename));\n\t\t\t\t$versionCreated = true;\n\t\t\t}\n\n\t\t\t$fileToRestore =  'files_versions' . $filename . '.v' . $revision;\n\n\t\t\t// Restore encrypted version of the old file for the newly restored file\n\t\t\t// This has to happen manually here since the file is manually copied below\n\t\t\t$oldVersion = $users_view->getFileInfo($fileToRestore)->getEncryptedVersion();\n\t\t\t$oldFileInfo = $users_view->getFileInfo($fileToRestore);\n\t\t\t$newFileInfo = $files_view->getFileInfo($filename);\n\t\t\t$cache = $newFileInfo->getStorage()->getCache();\n\t\t\t$cache->update(\n\t\t\t\t$newFileInfo->getId(), [\n\t\t\t\t\t'encrypted' => $oldVersion,\n\t\t\t\t\t'encryptedVersion' => $oldVersion,\n\t\t\t\t\t'size' => $oldFileInfo->getSize()\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// rollback\n\t\t\tif (self::copyFileContents($users_view, $fileToRestore, 'files' . $filename)) {\n\t\t\t\t$files_view->touch($file, $revision);\n\t\t\t\tStorage::scheduleExpire($uid, $file);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'rollback', array(\n\t\t\t\t\t'path' => $filename,\n\t\t\t\t\t'revision' => $revision,\n\t\t\t\t));\n\t\t\t\treturn true;\n\t\t\t} else if ($versionCreated) {\n\t\t\t\tself::deleteVersion($users_view, $version);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Stream copy file contents from $path1 to $path2\n\t *\n\t * @param View $view view to use for copying\n\t * @param string $path1 source file to copy\n\t * @param string $path2 target file\n\t *\n\t * @return bool true for success, false otherwise\n\t */\n\tprivate static function copyFileContents($view, $path1, $path2) {\n\t\t/** @var \\OC\\Files\\Storage\\Storage $storage1 */\n\t\tlist($storage1, $internalPath1) = $view->resolvePath($path1);\n\t\t/** @var \\OC\\Files\\Storage\\Storage $storage2 */\n\t\tlist($storage2, $internalPath2) = $view->resolvePath($path2);\n\n\t\t$view->lockFile($path1, ILockingProvider::LOCK_EXCLUSIVE);\n\t\t$view->lockFile($path2, ILockingProvider::LOCK_EXCLUSIVE);\n\n\t\t// TODO add a proper way of overwriting a file while maintaining file ids\n\t\tif ($storage1->instanceOfStorage('\\OC\\Files\\ObjectStore\\ObjectStoreStorage') || $storage2->instanceOfStorage('\\OC\\Files\\ObjectStore\\ObjectStoreStorage')) {\n\t\t\t$source = $storage1->fopen($internalPath1, 'r');\n\t\t\t$target = $storage2->fopen($internalPath2, 'w');\n\t\t\tlist(, $result) = \\OC_Helper::streamCopy($source, $target);\n\t\t\tfclose($source);\n\t\t\tfclose($target);\n\n\t\t\tif ($result !== false) {\n\t\t\t\t$storage1->unlink($internalPath1);\n\t\t\t}\n\t\t} else {\n\t\t\t$result = $storage2->moveFromStorage($storage1, $internalPath1, $internalPath2);\n\t\t}\n\n\t\t$view->unlockFile($path1, ILockingProvider::LOCK_EXCLUSIVE);\n\t\t$view->unlockFile($path2, ILockingProvider::LOCK_EXCLUSIVE);\n\n\t\treturn ($result !== false);\n\t}\n\n\t/**\n\t * get a list of all available versions of a file in descending chronological order\n\t * @param string $uid user id from the owner of the file\n\t * @param string $filename file to find versions of, relative to the user files dir\n\t * @param string $userFullPath\n\t * @return array versions newest version first\n\t */\n\tpublic static function getVersions($uid, $filename, $userFullPath = '') {\n\t\t$versions = array();\n\t\tif (empty($filename)) {\n\t\t\treturn $versions;\n\t\t}\n\t\t// fetch for old versions\n\t\t$view = new View('/' . $uid . '/');\n\n\t\t$pathinfo = pathinfo($filename);\n\t\t$versionedFile = $pathinfo['basename'];\n\n\t\t$dir = Filesystem::normalizePath(self::VERSIONS_ROOT . '/' . $pathinfo['dirname']);\n\n\t\t$dirContent = false;\n\t\tif ($view->is_dir($dir)) {\n\t\t\t$dirContent = $view->opendir($dir);\n\t\t}\n\n\t\tif ($dirContent === false) {\n\t\t\treturn $versions;\n\t\t}\n\n\t\tif (is_resource($dirContent)) {\n\t\t\twhile (($entryName = readdir($dirContent)) !== false) {\n\t\t\t\tif (!Filesystem::isIgnoredDir($entryName)) {\n\t\t\t\t\t$pathparts = pathinfo($entryName);\n\t\t\t\t\t$filename = $pathparts['filename'];\n\t\t\t\t\tif ($filename === $versionedFile) {\n\t\t\t\t\t\t$pathparts = pathinfo($entryName);\n\t\t\t\t\t\t$timestamp = substr($pathparts['extension'], 1);\n\t\t\t\t\t\t$filename = $pathparts['filename'];\n\t\t\t\t\t\t$key = $timestamp . '#' . $filename;\n\t\t\t\t\t\t$versions[$key]['version'] = $timestamp;\n\t\t\t\t\t\t$versions[$key]['humanReadableTimestamp'] = self::getHumanReadableTimestamp($timestamp);\n\t\t\t\t\t\tif (empty($userFullPath)) {\n\t\t\t\t\t\t\t$versions[$key]['preview'] = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$versions[$key]['preview'] = \\OCP\\Util::linkToRoute('core_ajax_versions_preview', array('file' => $userFullPath, 'version' => $timestamp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$versions[$key]['path'] = Filesystem::normalizePath($pathinfo['dirname'] . '/' . $filename);\n\t\t\t\t\t\t$versions[$key]['name'] = $versionedFile;\n\t\t\t\t\t\t$versions[$key]['size'] = $view->filesize($dir . '/' . $entryName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir($dirContent);\n\t\t}\n\n\t\t// sort with newest version first\n\t\tkrsort($versions);\n\n\t\treturn $versions;\n\t}\n\n\t/**\n\t * Expire versions that older than max version retention time\n\t * @param string $uid\n\t */\n\tpublic static function expireOlderThanMaxForUser($uid){\n\t\t$expiration = self::getExpiration();\n\t\t$threshold = $expiration->getMaxAgeAsTimestamp();\n\t\t$versions = self::getAllVersions($uid);\n\t\tif (!$threshold || !array_key_exists('all', $versions)) {\n\t\t\treturn;\n\t\t}\n\n\t\t$toDelete = [];\n\t\tforeach (array_reverse($versions['all']) as $key => $version) {\n\t\t\tif (intval($version['version'])<$threshold) {\n\t\t\t\t$toDelete[$key] = $version;\n\t\t\t} else {\n\t\t\t\t//Versions are sorted by time - nothing mo to iterate.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$view = new View('/' . $uid . '/files_versions');\n\t\tif (!empty($toDelete)) {\n\t\t\tforeach ($toDelete as $version) {\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_RETENTION_CONSTRAINT));\n\t\t\t\tself::deleteVersion($view, $version['path'] . '.v' . $version['version']);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_RETENTION_CONSTRAINT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * translate a timestamp into a string like \"5 days ago\"\n\t * @param int $timestamp\n\t * @return string for example \"5 days ago\"\n\t */\n\tprivate static function getHumanReadableTimestamp($timestamp) {\n\n\t\t$diff = time() - $timestamp;\n\n\t\tif ($diff < 60) { // first minute\n\t\t\treturn  $diff . \" seconds ago\";\n\t\t} elseif ($diff < 3600) { //first hour\n\t\t\treturn round($diff / 60) . \" minutes ago\";\n\t\t} elseif ($diff < 86400) { // first day\n\t\t\treturn round($diff / 3600) . \" hours ago\";\n\t\t} elseif ($diff < 604800) { //first week\n\t\t\treturn round($diff / 86400) . \" days ago\";\n\t\t} elseif ($diff < 2419200) { //first month\n\t\t\treturn round($diff / 604800) . \" weeks ago\";\n\t\t} elseif ($diff < 29030400) { // first year\n\t\t\treturn round($diff / 2419200) . \" months ago\";\n\t\t} else {\n\t\t\treturn round($diff / 29030400) . \" years ago\";\n\t\t}\n\n\t}\n\n\t/**\n\t * returns all stored file versions from a given user\n\t * @param string $uid id of the user\n\t * @return array with contains two arrays 'all' which contains all versions sorted by age and 'by_file' which contains all versions sorted by filename\n\t */\n\tprivate static function getAllVersions($uid) {\n\t\t$view = new View('/' . $uid . '/');\n\t\t$dirs = array(self::VERSIONS_ROOT);\n\t\t$versions = array();\n\n\t\twhile (!empty($dirs)) {\n\t\t\t$dir = array_pop($dirs);\n\t\t\t$files = $view->getDirectoryContent($dir);\n\n\t\t\tforeach ($files as $file) {\n\t\t\t\t$fileData = $file->getData();\n\t\t\t\t$filePath = $dir . '/' . $fileData['name'];\n\t\t\t\tif ($file['type'] === 'dir') {\n\t\t\t\t\tarray_push($dirs, $filePath);\n\t\t\t\t} else {\n\t\t\t\t\t$versionsBegin = strrpos($filePath, '.v');\n\t\t\t\t\t$relPathStart = strlen(self::VERSIONS_ROOT);\n\t\t\t\t\t$version = substr($filePath, $versionsBegin + 2);\n\t\t\t\t\t$relpath = substr($filePath, $relPathStart, $versionsBegin - $relPathStart);\n\t\t\t\t\t$key = $version . '#' . $relpath;\n\t\t\t\t\t$versions[$key] = array('path' => $relpath, 'timestamp' => $version);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// newest version first\n\t\tkrsort($versions);\n\n\t\t$result = array();\n\n\t\tforeach ($versions as $key => $value) {\n\t\t\t$size = $view->filesize(self::VERSIONS_ROOT.'/'.$value['path'].'.v'.$value['timestamp']);\n\t\t\t$filename = $value['path'];\n\n\t\t\t$result['all'][$key]['version'] = $value['timestamp'];\n\t\t\t$result['all'][$key]['path'] = $filename;\n\t\t\t$result['all'][$key]['size'] = $size;\n\n\t\t\t$result['by_file'][$filename][$key]['version'] = $value['timestamp'];\n\t\t\t$result['by_file'][$filename][$key]['path'] = $filename;\n\t\t\t$result['by_file'][$filename][$key]['size'] = $size;\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * get list of files we want to expire\n\t * @param array $versions list of versions\n\t * @param integer $time\n\t * @param bool $quotaExceeded is versions storage limit reached\n\t * @return array containing the list of to deleted versions and the size of them\n\t */\n\tprotected static function getExpireList($time, $versions, $quotaExceeded = false) {\n\t\t$expiration = self::getExpiration();\n\n\t\tif ($expiration->shouldAutoExpire()) {\n\t\t\tlist($toDelete, $size) = self::getAutoExpireList($time, $versions);\n\t\t} else {\n\t\t\t$size = 0;\n\t\t\t$toDelete = [];  // versions we want to delete\n\t\t}\n\n\t\tforeach ($versions as $key => $version) {\n\t\t\tif ($expiration->isExpired($version['version'], $quotaExceeded) && !isset($toDelete[$key])) {\n\t\t\t\t$size += $version['size'];\n\t\t\t\t$toDelete[$key] = $version['path'] . '.v' . $version['version'];\n\t\t\t}\n\t\t}\n\n\t\treturn [$toDelete, $size];\n\t}\n\n\t/**\n\t * get list of files we want to expire\n\t * @param array $versions list of versions\n\t * @param integer $time\n\t * @return array containing the list of to deleted versions and the size of them\n\t */\n\tprotected static function getAutoExpireList($time, $versions) {\n\t\t$size = 0;\n\t\t$toDelete = array();  // versions we want to delete\n\n\t\t$interval = 1;\n\t\t$step = Storage::$max_versions_per_interval[$interval]['step'];\n\t\tif (Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'] == -1) {\n\t\t\t$nextInterval = -1;\n\t\t} else {\n\t\t\t$nextInterval = $time - Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'];\n\t\t}\n\n\t\t$firstVersion = reset($versions);\n\t\t$firstKey = key($versions);\n\t\t$prevTimestamp = $firstVersion['version'];\n\t\t$nextVersion = $firstVersion['version'] - $step;\n\t\tunset($versions[$firstKey]);\n\n\t\tforeach ($versions as $key => $version) {\n\t\t\t$newInterval = true;\n\t\t\twhile ($newInterval) {\n\t\t\t\tif ($nextInterval == -1 || $prevTimestamp > $nextInterval) {\n\t\t\t\t\tif ($version['version'] > $nextVersion) {\n\t\t\t\t\t\t//distance between two version too small, mark to delete\n\t\t\t\t\t\t$toDelete[$key] = $version['path'] . '.v' . $version['version'];\n\t\t\t\t\t\t$size += $version['size'];\n\t\t\t\t\t\t\\OCP\\Util::writeLog('files_versions', 'Mark to expire '. $version['path'] .' next version should be ' . $nextVersion . \" or smaller. (prevTimestamp: \" . $prevTimestamp . \"; step: \" . $step, \\OCP\\Util::DEBUG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$nextVersion = $version['version'] - $step;\n\t\t\t\t\t\t$prevTimestamp = $version['version'];\n\t\t\t\t\t}\n\t\t\t\t\t$newInterval = false; // version checked so we can move to the next one\n\t\t\t\t} else { // time to move on to the next interval\n\t\t\t\t\t$interval++;\n\t\t\t\t\t$step = Storage::$max_versions_per_interval[$interval]['step'];\n\t\t\t\t\t$nextVersion = $prevTimestamp - $step;\n\t\t\t\t\tif (Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'] == -1) {\n\t\t\t\t\t\t$nextInterval = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$nextInterval = $time - Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'];\n\t\t\t\t\t}\n\t\t\t\t\t$newInterval = true; // we changed the interval -> check same version with new interval\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn array($toDelete, $size);\n\t}\n\n\t/**\n\t * Schedule versions expiration for the given file\n\t *\n\t * @param string $uid owner of the file\n\t * @param string $fileName file/folder for which to schedule expiration\n\t */\n\tprivate static function scheduleExpire($uid, $fileName) {\n\t\t// let the admin disable auto expire\n\t\t$expiration = self::getExpiration();\n\t\tif ($expiration->isEnabled()) {\n\t\t\t$command = new Expire($uid, $fileName);\n\t\t\t\\OC::$server->getCommandBus()->push($command);\n\t\t}\n\t}\n\n\t/**\n\t * Expire versions which exceed the quota\n\t *\n\t * @param string $filename\n\t * @return bool|int|null\n\t */\n\tpublic static function expire($filename) {\n\t\t$config = \\OC::$server->getConfig();\n\t\t$expiration = self::getExpiration();\n\t\t\n\t\tif($config->getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true' && $expiration->isEnabled()) {\n\n\t\t\tif (!Filesystem::file_exists($filename)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($filename);\n\t\t\tif (empty($filename)) {\n\t\t\t\t// file maybe renamed or deleted\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$versionsFileview = new View('/'.$uid.'/files_versions');\n\n\t\t\t// get available disk space for user\n\t\t\t$user = \\OC::$server->getUserManager()->get($uid);\n\t\t\t$softQuota = true;\n\t\t\t$quota = $user->getQuota();\n\t\t\tif ( $quota === null || $quota === 'none' ) {\n\t\t\t\t$quota = Filesystem::free_space('/');\n\t\t\t\t$softQuota = false;\n\t\t\t} else {\n\t\t\t\t$quota = \\OCP\\Util::computerFileSize($quota);\n\t\t\t}\n\n\t\t\t// make sure that we have the current size of the version history\n\t\t\t$versionsSize = self::getVersionsSize($uid);\n\n\t\t\t// calculate available space for version history\n\t\t\t// subtract size of files and current versions size from quota\n\t\t\tif ($quota >= 0) {\n\t\t\t\tif ($softQuota) {\n\t\t\t\t\t$files_view = new View('/' . $uid . '/files');\n\t\t\t\t\t$rootInfo = $files_view->getFileInfo('/', false);\n\t\t\t\t\t$free = $quota - $rootInfo['size']; // remaining free space for user\n\t\t\t\t\tif ($free > 0) {\n\t\t\t\t\t\t$availableSpace = ($free * self::DEFAULTMAXSIZE / 100) - $versionsSize; // how much space can be used for versions\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$availableSpace = $free - $versionsSize;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$availableSpace = $quota;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$availableSpace = PHP_INT_MAX;\n\t\t\t}\n\n\t\t\t$allVersions = Storage::getVersions($uid, $filename);\n\n\t\t\t$time = time();\n\t\t\tlist($toDelete, $sizeOfDeletedVersions) = self::getExpireList($time, $allVersions, $availableSpace <= 0);\n\n\t\t\t$availableSpace = $availableSpace + $sizeOfDeletedVersions;\n\t\t\t$versionsSize = $versionsSize - $sizeOfDeletedVersions;\n\n\t\t\t// if still not enough free space we rearrange the versions from all files\n\t\t\tif ($availableSpace <= 0) {\n\t\t\t\t$result = Storage::getAllVersions($uid);\n\t\t\t\t$allVersions = $result['all'];\n\n\t\t\t\tforeach ($result['by_file'] as $versions) {\n\t\t\t\t\tlist($toDeleteNew, $size) = self::getExpireList($time, $versions, $availableSpace <= 0);\n\t\t\t\t\t$toDelete = array_merge($toDelete, $toDeleteNew);\n\t\t\t\t\t$sizeOfDeletedVersions += $size;\n\t\t\t\t}\n\t\t\t\t$availableSpace = $availableSpace + $sizeOfDeletedVersions;\n\t\t\t\t$versionsSize = $versionsSize - $sizeOfDeletedVersions;\n\t\t\t}\n\n\t\t\tforeach($toDelete as $key => $path) {\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $path, 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tself::deleteVersion($versionsFileview, $path);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $path, 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tunset($allVersions[$key]); // update array with the versions we keep\n\t\t\t\t\\OCP\\Util::writeLog('files_versions', \"Expire: \" . $path, \\OCP\\Util::DEBUG);\n\t\t\t}\n\n\t\t\t// Check if enough space is available after versions are rearranged.\n\t\t\t// If not we delete the oldest versions until we meet the size limit for versions,\n\t\t\t// but always keep the two latest versions\n\t\t\t$numOfVersions = count($allVersions) -2 ;\n\t\t\t$i = 0;\n\t\t\t// sort oldest first and make sure that we start at the first element\n\t\t\tksort($allVersions);\n\t\t\treset($allVersions);\n\t\t\twhile ($availableSpace < 0 && $i < $numOfVersions) {\n\t\t\t\t$version = current($allVersions);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tself::deleteVersion($versionsFileview, $version['path'] . '.v' . $version['version']);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\t\\OCP\\Util::writeLog('files_versions', 'running out of space! Delete oldest version: ' . $version['path'].'.v'.$version['version'] , \\OCP\\Util::DEBUG);\n\t\t\t\t$versionsSize -= $version['size'];\n\t\t\t\t$availableSpace += $version['size'];\n\t\t\t\tnext($allVersions);\n\t\t\t\t$i++;\n\t\t\t}\n\n\t\t\treturn $versionsSize; // finally return the new size of the version history\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create recursively missing directories inside of files_versions\n\t * that match the given path to a file.\n\t *\n\t * @param string $filename $path to a file, relative to the user's\n\t * \"files\" folder\n\t * @param View $view view on data/user/\n\t */\n\tprivate static function createMissingDirectories($filename, $view) {\n\t\t$dirname = Filesystem::normalizePath(dirname($filename));\n\t\t$dirParts = explode('/', $dirname);\n\t\t$dir = \"/files_versions\";\n\t\tforeach ($dirParts as $part) {\n\t\t\t$dir = $dir . '/' . $part;\n\t\t\tif (!$view->file_exists($dir)) {\n\t\t\t\t$view->mkdir($dir);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Static workaround\n\t * @return Expiration\n\t */\n\tprotected static function getExpiration(){\n\t\tif (is_null(self::$application)) {\n\t\t\tself::$application = new Application();\n\t\t}\n\t\treturn self::$application->getContainer()->query('Expiration');\n\t}\n\n}\n"], "fixing_code": ["<?php\n/**\n * @author Arthur Schiwon <blizzz@owncloud.com>\n * @author Bart Visscher <bartv@thisnet.nl>\n * @author Bj\u00f6rn Schie\u00dfle <schiessle@owncloud.com>\n * @author Felix Moeller <mail@felixmoeller.de>\n * @author Florin Peter <github@florin-peter.de>\n * @author Georg Ehrke <georg@owncloud.com>\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author J\u00f6rn Friedrich Dreyer <jfd@butonic.de>\n * @author Lukas Reschke <lukas@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Robin McCorkell <robin@mccorkell.me.uk>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Victor Dubiniuk <dubiniuk@owncloud.com>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\n/**\n * Versions\n *\n * A class to handle the versioning of files.\n */\n\nnamespace OCA\\Files_Versions;\n\nuse OC\\Files\\Filesystem;\nuse OC\\Files\\View;\nuse OCA\\Files_Versions\\AppInfo\\Application;\nuse OCA\\Files_Versions\\Command\\Expire;\nuse OCP\\Files\\NotFoundException;\nuse OCP\\Lock\\ILockingProvider;\nuse OCP\\User;\n\nclass Storage {\n\n\tconst DEFAULTENABLED=true;\n\tconst DEFAULTMAXSIZE=50; // unit: percentage; 50% of available disk space/quota\n\tconst VERSIONS_ROOT = 'files_versions/';\n\n\tconst DELETE_TRIGGER_MASTER_REMOVED = 0;\n\tconst DELETE_TRIGGER_RETENTION_CONSTRAINT = 1;\n\tconst DELETE_TRIGGER_QUOTA_EXCEEDED = 2;\n\n\t// files for which we can remove the versions after the delete operation was successful\n\tprivate static $deletedFiles = array();\n\n\tprivate static $sourcePathAndUser = array();\n\n\tprivate static $max_versions_per_interval = array(\n\t\t//first 10sec, one version every 2sec\n\t\t1 => array('intervalEndsAfter' => 10,      'step' => 2),\n\t\t//next minute, one version every 10sec\n\t\t2 => array('intervalEndsAfter' => 60,      'step' => 10),\n\t\t//next hour, one version every minute\n\t\t3 => array('intervalEndsAfter' => 3600,    'step' => 60),\n\t\t//next 24h, one version every hour\n\t\t4 => array('intervalEndsAfter' => 86400,   'step' => 3600),\n\t\t//next 30days, one version per day\n\t\t5 => array('intervalEndsAfter' => 2592000, 'step' => 86400),\n\t\t//until the end one version per week\n\t\t6 => array('intervalEndsAfter' => -1,      'step' => 604800),\n\t);\n\n\t/** @var \\OCA\\Files_Versions\\AppInfo\\Application */\n\tprivate static $application;\n\n\t/**\n\t * get the UID of the owner of the file and the path to the file relative to\n\t * owners files folder\n\t *\n\t * @param string $filename\n\t * @return array\n\t * @throws \\OC\\User\\NoUserException\n\t */\n\tpublic static function getUidAndFilename($filename) {\n\t\t$uid = Filesystem::getOwner($filename);\n\t\t$userManager = \\OC::$server->getUserManager();\n\t\t// if the user with the UID doesn't exists, e.g. because the UID points\n\t\t// to a remote user with a federated cloud ID we use the current logged-in\n\t\t// user. We need a valid local user to create the versions\n\t\tif (!$userManager->userExists($uid)) {\n\t\t\t$uid = User::getUser();\n\t\t}\n\t\tFilesystem::initMountPoints($uid);\n\t\tif ( $uid != User::getUser() ) {\n\t\t\t$info = Filesystem::getFileInfo($filename);\n\t\t\t$ownerView = new View('/'.$uid.'/files');\n\t\t\ttry {\n\t\t\t\t$filename = $ownerView->getPath($info['fileid']);\n\t\t\t\t// make sure that the file name doesn't end with a trailing slash\n\t\t\t\t// can for example happen single files shared across servers\n\t\t\t\t$filename = rtrim($filename, '/');\n\t\t\t} catch (NotFoundException $e) {\n\t\t\t\t$filename = null;\n\t\t\t}\n\t\t}\n\t\treturn [$uid, $filename];\n\t}\n\n\t/**\n\t * Remember the owner and the owner path of the source file\n\t *\n\t * @param string $source source path\n\t */\n\tpublic static function setSourcePathAndUser($source) {\n\t\tlist($uid, $path) = self::getUidAndFilename($source);\n\t\tself::$sourcePathAndUser[$source] = array('uid' => $uid, 'path' => $path);\n\t}\n\n\t/**\n\t * Gets the owner and the owner path from the source path\n\t *\n\t * @param string $source source path\n\t * @return array with user id and path\n\t */\n\tpublic static function getSourcePathAndUser($source) {\n\n\t\tif (isset(self::$sourcePathAndUser[$source])) {\n\t\t\t$uid = self::$sourcePathAndUser[$source]['uid'];\n\t\t\t$path = self::$sourcePathAndUser[$source]['path'];\n\t\t\tunset(self::$sourcePathAndUser[$source]);\n\t\t} else {\n\t\t\t$uid = $path = false;\n\t\t}\n\t\treturn array($uid, $path);\n\t}\n\n\t/**\n\t * get current size of all versions from a given user\n\t *\n\t * @param string $user user who owns the versions\n\t * @return int versions size\n\t */\n\tprivate static function getVersionsSize($user) {\n\t\t$view = new View('/' . $user);\n\t\t$fileInfo = $view->getFileInfo('/files_versions');\n\t\treturn isset($fileInfo['size']) ? $fileInfo['size'] : 0;\n\t}\n\n\t/**\n\t * store a new version of a file.\n\t */\n\tpublic static function store($filename) {\n\t\tif(\\OCP\\Config::getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true') {\n\n\t\t\t// if the file gets streamed we need to remove the .part extension\n\t\t\t// to get the right target\n\t\t\t$ext = pathinfo($filename, PATHINFO_EXTENSION);\n\t\t\tif ($ext === 'part') {\n\t\t\t\t$filename = substr($filename, 0, strlen($filename) - 5);\n\t\t\t}\n\n\t\t\t// we only handle existing files\n\t\t\tif (! Filesystem::file_exists($filename) || Filesystem::is_dir($filename)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($filename);\n\n\t\t\t$files_view = new View('/'.$uid .'/files');\n\t\t\t$users_view = new View('/'.$uid);\n\n\t\t\t// no use making versions for empty files\n\t\t\tif ($files_view->filesize($filename) === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// create all parent folders\n\t\t\tself::createMissingDirectories($filename, $users_view);\n\n\t\t\tself::scheduleExpire($uid, $filename);\n\n\t\t\t// store a new version of a file\n\t\t\t$mtime = $users_view->filemtime('files/' . $filename);\n\t\t\t$users_view->copy('files/' . $filename, 'files_versions/' . $filename . '.v' . $mtime);\n\t\t\t// call getFileInfo to enforce a file cache entry for the new version\n\t\t\t$users_view->getFileInfo('files_versions/' . $filename . '.v' . $mtime);\n\t\t}\n\t}\n\n\n\t/**\n\t * mark file as deleted so that we can remove the versions if the file is gone\n\t * @param string $path\n\t */\n\tpublic static function markDeletedFile($path) {\n\t\tlist($uid, $filename) = self::getUidAndFilename($path);\n\t\tself::$deletedFiles[$path] = array(\n\t\t\t'uid' => $uid,\n\t\t\t'filename' => $filename);\n\t}\n\n\t/**\n\t * delete the version from the storage and cache\n\t *\n\t * @param View $view\n\t * @param string $path\n\t */\n\tprotected static function deleteVersion($view, $path) {\n\t\t$view->unlink($path);\n\t\t/**\n\t\t * @var \\OC\\Files\\Storage\\Storage $storage\n\t\t * @var string $internalPath\n\t\t */\n\t\tlist($storage, $internalPath) = $view->resolvePath($path);\n\t\t$cache = $storage->getCache($internalPath);\n\t\t$cache->remove($internalPath);\n\t}\n\n\t/**\n\t * Delete versions of a file\n\t */\n\tpublic static function delete($path) {\n\n\t\t$deletedFile = self::$deletedFiles[$path];\n\t\t$uid = $deletedFile['uid'];\n\t\t$filename = $deletedFile['filename'];\n\n\t\tif (!Filesystem::file_exists($path)) {\n\n\t\t\t$view = new View('/' . $uid . '/files_versions');\n\n\t\t\t$versions = self::getVersions($uid, $filename);\n\t\t\tif (!empty($versions)) {\n\t\t\t\tforeach ($versions as $v) {\n\t\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $path . $v['version'], 'trigger' => self::DELETE_TRIGGER_MASTER_REMOVED));\n\t\t\t\t\tself::deleteVersion($view, $filename . '.v' . $v['version']);\n\t\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $path . $v['version'], 'trigger' => self::DELETE_TRIGGER_MASTER_REMOVED));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunset(self::$deletedFiles[$path]);\n\t}\n\n\t/**\n\t * Rename or copy versions of a file of the given paths\n\t *\n\t * @param string $sourcePath source path of the file to move, relative to\n\t * the currently logged in user's \"files\" folder\n\t * @param string $targetPath target path of the file to move, relative to\n\t * the currently logged in user's \"files\" folder\n\t * @param string $operation can be 'copy' or 'rename'\n\t */\n\tpublic static function renameOrCopy($sourcePath, $targetPath, $operation) {\n\t\tlist($sourceOwner, $sourcePath) = self::getSourcePathAndUser($sourcePath);\n\n\t\t// it was a upload of a existing file if no old path exists\n\t\t// in this case the pre-hook already called the store method and we can\n\t\t// stop here\n\t\tif ($sourcePath === false) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlist($targetOwner, $targetPath) = self::getUidAndFilename($targetPath);\n\n\t\t$sourcePath = ltrim($sourcePath, '/');\n\t\t$targetPath = ltrim($targetPath, '/');\n\n\t\t$rootView = new View('');\n\n\t\t// did we move a directory ?\n\t\tif ($rootView->is_dir('/' . $targetOwner . '/files/' . $targetPath)) {\n\t\t\t// does the directory exists for versions too ?\n\t\t\tif ($rootView->is_dir('/' . $sourceOwner . '/files_versions/' . $sourcePath)) {\n\t\t\t\t// create missing dirs if necessary\n\t\t\t\tself::createMissingDirectories($targetPath, new View('/'. $targetOwner));\n\n\t\t\t\t// move the directory containing the versions\n\t\t\t\t$rootView->$operation(\n\t\t\t\t\t'/' . $sourceOwner . '/files_versions/' . $sourcePath,\n\t\t\t\t\t'/' . $targetOwner . '/files_versions/' . $targetPath\n\t\t\t\t);\n\t\t\t}\n\t\t} else if ($versions = Storage::getVersions($sourceOwner, '/' . $sourcePath)) {\n\t\t\t// create missing dirs if necessary\n\t\t\tself::createMissingDirectories($targetPath, new View('/'. $targetOwner));\n\n\t\t\tforeach ($versions as $v) {\n\t\t\t\t// move each version one by one to the target directory\n\t\t\t\t$rootView->$operation(\n\t\t\t\t\t'/' . $sourceOwner . '/files_versions/' . $sourcePath.'.v' . $v['version'],\n\t\t\t\t\t'/' . $targetOwner . '/files_versions/' . $targetPath.'.v'.$v['version']\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// if we moved versions directly for a file, schedule expiration check for that file\n\t\tif (!$rootView->is_dir('/' . $targetOwner . '/files/' . $targetPath)) {\n\t\t\tself::scheduleExpire($targetOwner, $targetPath);\n\t\t}\n\n\t}\n\n\t/**\n\t * Rollback to an old version of a file.\n\t *\n\t * @param string $file file name\n\t * @param int $revision revision timestamp\n\t */\n\tpublic static function rollback($file, $revision) {\n\n\t\tif(\\OCP\\Config::getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true') {\n\t\t\t// add expected leading slash\n\t\t\t$file = '/' . ltrim($file, '/');\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($file);\n\t\t\t$users_view = new View('/'.$uid);\n\t\t\t$files_view = new View('/'. User::getUser().'/files');\n\t\t\t$versionCreated = false;\n\n\t\t\t$fileInfo = $files_view->getFileInfo($file);\n\n\t\t\t// check if user has the permissions to revert a version\n\t\t\tif (!$fileInfo->isUpdateable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//first create a new version\n\t\t\t$version = 'files_versions'.$filename.'.v'.$users_view->filemtime('files'.$filename);\n\t\t\tif (!$users_view->file_exists($version)) {\n\t\t\t\t$users_view->copy('files'.$filename, 'files_versions'.$filename.'.v'.$users_view->filemtime('files'.$filename));\n\t\t\t\t$versionCreated = true;\n\t\t\t}\n\n\t\t\t$fileToRestore =  'files_versions' . $filename . '.v' . $revision;\n\n\t\t\t// Restore encrypted version of the old file for the newly restored file\n\t\t\t// This has to happen manually here since the file is manually copied below\n\t\t\t$oldVersion = $users_view->getFileInfo($fileToRestore)->getEncryptedVersion();\n\t\t\t$oldFileInfo = $users_view->getFileInfo($fileToRestore);\n\t\t\t$cache = $fileInfo->getStorage()->getCache();\n\t\t\t$cache->update(\n\t\t\t\t$fileInfo->getId(), [\n\t\t\t\t\t'encrypted' => $oldVersion,\n\t\t\t\t\t'encryptedVersion' => $oldVersion,\n\t\t\t\t\t'size' => $oldFileInfo->getSize()\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// rollback\n\t\t\tif (self::copyFileContents($users_view, $fileToRestore, 'files' . $filename)) {\n\t\t\t\t$files_view->touch($file, $revision);\n\t\t\t\tStorage::scheduleExpire($uid, $file);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'rollback', array(\n\t\t\t\t\t'path' => $filename,\n\t\t\t\t\t'revision' => $revision,\n\t\t\t\t));\n\t\t\t\treturn true;\n\t\t\t} else if ($versionCreated) {\n\t\t\t\tself::deleteVersion($users_view, $version);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Stream copy file contents from $path1 to $path2\n\t *\n\t * @param View $view view to use for copying\n\t * @param string $path1 source file to copy\n\t * @param string $path2 target file\n\t *\n\t * @return bool true for success, false otherwise\n\t */\n\tprivate static function copyFileContents($view, $path1, $path2) {\n\t\t/** @var \\OC\\Files\\Storage\\Storage $storage1 */\n\t\tlist($storage1, $internalPath1) = $view->resolvePath($path1);\n\t\t/** @var \\OC\\Files\\Storage\\Storage $storage2 */\n\t\tlist($storage2, $internalPath2) = $view->resolvePath($path2);\n\n\t\t$view->lockFile($path1, ILockingProvider::LOCK_EXCLUSIVE);\n\t\t$view->lockFile($path2, ILockingProvider::LOCK_EXCLUSIVE);\n\n\t\t// TODO add a proper way of overwriting a file while maintaining file ids\n\t\tif ($storage1->instanceOfStorage('\\OC\\Files\\ObjectStore\\ObjectStoreStorage') || $storage2->instanceOfStorage('\\OC\\Files\\ObjectStore\\ObjectStoreStorage')) {\n\t\t\t$source = $storage1->fopen($internalPath1, 'r');\n\t\t\t$target = $storage2->fopen($internalPath2, 'w');\n\t\t\tlist(, $result) = \\OC_Helper::streamCopy($source, $target);\n\t\t\tfclose($source);\n\t\t\tfclose($target);\n\n\t\t\tif ($result !== false) {\n\t\t\t\t$storage1->unlink($internalPath1);\n\t\t\t}\n\t\t} else {\n\t\t\t$result = $storage2->moveFromStorage($storage1, $internalPath1, $internalPath2);\n\t\t}\n\n\t\t$view->unlockFile($path1, ILockingProvider::LOCK_EXCLUSIVE);\n\t\t$view->unlockFile($path2, ILockingProvider::LOCK_EXCLUSIVE);\n\n\t\treturn ($result !== false);\n\t}\n\n\t/**\n\t * get a list of all available versions of a file in descending chronological order\n\t * @param string $uid user id from the owner of the file\n\t * @param string $filename file to find versions of, relative to the user files dir\n\t * @param string $userFullPath\n\t * @return array versions newest version first\n\t */\n\tpublic static function getVersions($uid, $filename, $userFullPath = '') {\n\t\t$versions = array();\n\t\tif (empty($filename)) {\n\t\t\treturn $versions;\n\t\t}\n\t\t// fetch for old versions\n\t\t$view = new View('/' . $uid . '/');\n\n\t\t$pathinfo = pathinfo($filename);\n\t\t$versionedFile = $pathinfo['basename'];\n\n\t\t$dir = Filesystem::normalizePath(self::VERSIONS_ROOT . '/' . $pathinfo['dirname']);\n\n\t\t$dirContent = false;\n\t\tif ($view->is_dir($dir)) {\n\t\t\t$dirContent = $view->opendir($dir);\n\t\t}\n\n\t\tif ($dirContent === false) {\n\t\t\treturn $versions;\n\t\t}\n\n\t\tif (is_resource($dirContent)) {\n\t\t\twhile (($entryName = readdir($dirContent)) !== false) {\n\t\t\t\tif (!Filesystem::isIgnoredDir($entryName)) {\n\t\t\t\t\t$pathparts = pathinfo($entryName);\n\t\t\t\t\t$filename = $pathparts['filename'];\n\t\t\t\t\tif ($filename === $versionedFile) {\n\t\t\t\t\t\t$pathparts = pathinfo($entryName);\n\t\t\t\t\t\t$timestamp = substr($pathparts['extension'], 1);\n\t\t\t\t\t\t$filename = $pathparts['filename'];\n\t\t\t\t\t\t$key = $timestamp . '#' . $filename;\n\t\t\t\t\t\t$versions[$key]['version'] = $timestamp;\n\t\t\t\t\t\t$versions[$key]['humanReadableTimestamp'] = self::getHumanReadableTimestamp($timestamp);\n\t\t\t\t\t\tif (empty($userFullPath)) {\n\t\t\t\t\t\t\t$versions[$key]['preview'] = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$versions[$key]['preview'] = \\OCP\\Util::linkToRoute('core_ajax_versions_preview', array('file' => $userFullPath, 'version' => $timestamp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$versions[$key]['path'] = Filesystem::normalizePath($pathinfo['dirname'] . '/' . $filename);\n\t\t\t\t\t\t$versions[$key]['name'] = $versionedFile;\n\t\t\t\t\t\t$versions[$key]['size'] = $view->filesize($dir . '/' . $entryName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir($dirContent);\n\t\t}\n\n\t\t// sort with newest version first\n\t\tkrsort($versions);\n\n\t\treturn $versions;\n\t}\n\n\t/**\n\t * Expire versions that older than max version retention time\n\t * @param string $uid\n\t */\n\tpublic static function expireOlderThanMaxForUser($uid){\n\t\t$expiration = self::getExpiration();\n\t\t$threshold = $expiration->getMaxAgeAsTimestamp();\n\t\t$versions = self::getAllVersions($uid);\n\t\tif (!$threshold || !array_key_exists('all', $versions)) {\n\t\t\treturn;\n\t\t}\n\n\t\t$toDelete = [];\n\t\tforeach (array_reverse($versions['all']) as $key => $version) {\n\t\t\tif (intval($version['version'])<$threshold) {\n\t\t\t\t$toDelete[$key] = $version;\n\t\t\t} else {\n\t\t\t\t//Versions are sorted by time - nothing mo to iterate.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$view = new View('/' . $uid . '/files_versions');\n\t\tif (!empty($toDelete)) {\n\t\t\tforeach ($toDelete as $version) {\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_RETENTION_CONSTRAINT));\n\t\t\t\tself::deleteVersion($view, $version['path'] . '.v' . $version['version']);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_RETENTION_CONSTRAINT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * translate a timestamp into a string like \"5 days ago\"\n\t * @param int $timestamp\n\t * @return string for example \"5 days ago\"\n\t */\n\tprivate static function getHumanReadableTimestamp($timestamp) {\n\n\t\t$diff = time() - $timestamp;\n\n\t\tif ($diff < 60) { // first minute\n\t\t\treturn  $diff . \" seconds ago\";\n\t\t} elseif ($diff < 3600) { //first hour\n\t\t\treturn round($diff / 60) . \" minutes ago\";\n\t\t} elseif ($diff < 86400) { // first day\n\t\t\treturn round($diff / 3600) . \" hours ago\";\n\t\t} elseif ($diff < 604800) { //first week\n\t\t\treturn round($diff / 86400) . \" days ago\";\n\t\t} elseif ($diff < 2419200) { //first month\n\t\t\treturn round($diff / 604800) . \" weeks ago\";\n\t\t} elseif ($diff < 29030400) { // first year\n\t\t\treturn round($diff / 2419200) . \" months ago\";\n\t\t} else {\n\t\t\treturn round($diff / 29030400) . \" years ago\";\n\t\t}\n\n\t}\n\n\t/**\n\t * returns all stored file versions from a given user\n\t * @param string $uid id of the user\n\t * @return array with contains two arrays 'all' which contains all versions sorted by age and 'by_file' which contains all versions sorted by filename\n\t */\n\tprivate static function getAllVersions($uid) {\n\t\t$view = new View('/' . $uid . '/');\n\t\t$dirs = array(self::VERSIONS_ROOT);\n\t\t$versions = array();\n\n\t\twhile (!empty($dirs)) {\n\t\t\t$dir = array_pop($dirs);\n\t\t\t$files = $view->getDirectoryContent($dir);\n\n\t\t\tforeach ($files as $file) {\n\t\t\t\t$fileData = $file->getData();\n\t\t\t\t$filePath = $dir . '/' . $fileData['name'];\n\t\t\t\tif ($file['type'] === 'dir') {\n\t\t\t\t\tarray_push($dirs, $filePath);\n\t\t\t\t} else {\n\t\t\t\t\t$versionsBegin = strrpos($filePath, '.v');\n\t\t\t\t\t$relPathStart = strlen(self::VERSIONS_ROOT);\n\t\t\t\t\t$version = substr($filePath, $versionsBegin + 2);\n\t\t\t\t\t$relpath = substr($filePath, $relPathStart, $versionsBegin - $relPathStart);\n\t\t\t\t\t$key = $version . '#' . $relpath;\n\t\t\t\t\t$versions[$key] = array('path' => $relpath, 'timestamp' => $version);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// newest version first\n\t\tkrsort($versions);\n\n\t\t$result = array();\n\n\t\tforeach ($versions as $key => $value) {\n\t\t\t$size = $view->filesize(self::VERSIONS_ROOT.'/'.$value['path'].'.v'.$value['timestamp']);\n\t\t\t$filename = $value['path'];\n\n\t\t\t$result['all'][$key]['version'] = $value['timestamp'];\n\t\t\t$result['all'][$key]['path'] = $filename;\n\t\t\t$result['all'][$key]['size'] = $size;\n\n\t\t\t$result['by_file'][$filename][$key]['version'] = $value['timestamp'];\n\t\t\t$result['by_file'][$filename][$key]['path'] = $filename;\n\t\t\t$result['by_file'][$filename][$key]['size'] = $size;\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * get list of files we want to expire\n\t * @param array $versions list of versions\n\t * @param integer $time\n\t * @param bool $quotaExceeded is versions storage limit reached\n\t * @return array containing the list of to deleted versions and the size of them\n\t */\n\tprotected static function getExpireList($time, $versions, $quotaExceeded = false) {\n\t\t$expiration = self::getExpiration();\n\n\t\tif ($expiration->shouldAutoExpire()) {\n\t\t\tlist($toDelete, $size) = self::getAutoExpireList($time, $versions);\n\t\t} else {\n\t\t\t$size = 0;\n\t\t\t$toDelete = [];  // versions we want to delete\n\t\t}\n\n\t\tforeach ($versions as $key => $version) {\n\t\t\tif ($expiration->isExpired($version['version'], $quotaExceeded) && !isset($toDelete[$key])) {\n\t\t\t\t$size += $version['size'];\n\t\t\t\t$toDelete[$key] = $version['path'] . '.v' . $version['version'];\n\t\t\t}\n\t\t}\n\n\t\treturn [$toDelete, $size];\n\t}\n\n\t/**\n\t * get list of files we want to expire\n\t * @param array $versions list of versions\n\t * @param integer $time\n\t * @return array containing the list of to deleted versions and the size of them\n\t */\n\tprotected static function getAutoExpireList($time, $versions) {\n\t\t$size = 0;\n\t\t$toDelete = array();  // versions we want to delete\n\n\t\t$interval = 1;\n\t\t$step = Storage::$max_versions_per_interval[$interval]['step'];\n\t\tif (Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'] == -1) {\n\t\t\t$nextInterval = -1;\n\t\t} else {\n\t\t\t$nextInterval = $time - Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'];\n\t\t}\n\n\t\t$firstVersion = reset($versions);\n\t\t$firstKey = key($versions);\n\t\t$prevTimestamp = $firstVersion['version'];\n\t\t$nextVersion = $firstVersion['version'] - $step;\n\t\tunset($versions[$firstKey]);\n\n\t\tforeach ($versions as $key => $version) {\n\t\t\t$newInterval = true;\n\t\t\twhile ($newInterval) {\n\t\t\t\tif ($nextInterval == -1 || $prevTimestamp > $nextInterval) {\n\t\t\t\t\tif ($version['version'] > $nextVersion) {\n\t\t\t\t\t\t//distance between two version too small, mark to delete\n\t\t\t\t\t\t$toDelete[$key] = $version['path'] . '.v' . $version['version'];\n\t\t\t\t\t\t$size += $version['size'];\n\t\t\t\t\t\t\\OCP\\Util::writeLog('files_versions', 'Mark to expire '. $version['path'] .' next version should be ' . $nextVersion . \" or smaller. (prevTimestamp: \" . $prevTimestamp . \"; step: \" . $step, \\OCP\\Util::DEBUG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$nextVersion = $version['version'] - $step;\n\t\t\t\t\t\t$prevTimestamp = $version['version'];\n\t\t\t\t\t}\n\t\t\t\t\t$newInterval = false; // version checked so we can move to the next one\n\t\t\t\t} else { // time to move on to the next interval\n\t\t\t\t\t$interval++;\n\t\t\t\t\t$step = Storage::$max_versions_per_interval[$interval]['step'];\n\t\t\t\t\t$nextVersion = $prevTimestamp - $step;\n\t\t\t\t\tif (Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'] == -1) {\n\t\t\t\t\t\t$nextInterval = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$nextInterval = $time - Storage::$max_versions_per_interval[$interval]['intervalEndsAfter'];\n\t\t\t\t\t}\n\t\t\t\t\t$newInterval = true; // we changed the interval -> check same version with new interval\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn array($toDelete, $size);\n\t}\n\n\t/**\n\t * Schedule versions expiration for the given file\n\t *\n\t * @param string $uid owner of the file\n\t * @param string $fileName file/folder for which to schedule expiration\n\t */\n\tprivate static function scheduleExpire($uid, $fileName) {\n\t\t// let the admin disable auto expire\n\t\t$expiration = self::getExpiration();\n\t\tif ($expiration->isEnabled()) {\n\t\t\t$command = new Expire($uid, $fileName);\n\t\t\t\\OC::$server->getCommandBus()->push($command);\n\t\t}\n\t}\n\n\t/**\n\t * Expire versions which exceed the quota\n\t *\n\t * @param string $filename\n\t * @return bool|int|null\n\t */\n\tpublic static function expire($filename) {\n\t\t$config = \\OC::$server->getConfig();\n\t\t$expiration = self::getExpiration();\n\n\t\tif($config->getSystemValue('files_versions', Storage::DEFAULTENABLED)=='true' && $expiration->isEnabled()) {\n\n\t\t\tif (!Filesystem::file_exists($filename)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlist($uid, $filename) = self::getUidAndFilename($filename);\n\t\t\tif (empty($filename)) {\n\t\t\t\t// file maybe renamed or deleted\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$versionsFileview = new View('/'.$uid.'/files_versions');\n\n\t\t\t// get available disk space for user\n\t\t\t$user = \\OC::$server->getUserManager()->get($uid);\n\t\t\t$softQuota = true;\n\t\t\t$quota = $user->getQuota();\n\t\t\tif ( $quota === null || $quota === 'none' ) {\n\t\t\t\t$quota = Filesystem::free_space('/');\n\t\t\t\t$softQuota = false;\n\t\t\t} else {\n\t\t\t\t$quota = \\OCP\\Util::computerFileSize($quota);\n\t\t\t}\n\n\t\t\t// make sure that we have the current size of the version history\n\t\t\t$versionsSize = self::getVersionsSize($uid);\n\n\t\t\t// calculate available space for version history\n\t\t\t// subtract size of files and current versions size from quota\n\t\t\tif ($quota >= 0) {\n\t\t\t\tif ($softQuota) {\n\t\t\t\t\t$files_view = new View('/' . $uid . '/files');\n\t\t\t\t\t$rootInfo = $files_view->getFileInfo('/', false);\n\t\t\t\t\t$free = $quota - $rootInfo['size']; // remaining free space for user\n\t\t\t\t\tif ($free > 0) {\n\t\t\t\t\t\t$availableSpace = ($free * self::DEFAULTMAXSIZE / 100) - $versionsSize; // how much space can be used for versions\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$availableSpace = $free - $versionsSize;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$availableSpace = $quota;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$availableSpace = PHP_INT_MAX;\n\t\t\t}\n\n\t\t\t$allVersions = Storage::getVersions($uid, $filename);\n\n\t\t\t$time = time();\n\t\t\tlist($toDelete, $sizeOfDeletedVersions) = self::getExpireList($time, $allVersions, $availableSpace <= 0);\n\n\t\t\t$availableSpace = $availableSpace + $sizeOfDeletedVersions;\n\t\t\t$versionsSize = $versionsSize - $sizeOfDeletedVersions;\n\n\t\t\t// if still not enough free space we rearrange the versions from all files\n\t\t\tif ($availableSpace <= 0) {\n\t\t\t\t$result = Storage::getAllVersions($uid);\n\t\t\t\t$allVersions = $result['all'];\n\n\t\t\t\tforeach ($result['by_file'] as $versions) {\n\t\t\t\t\tlist($toDeleteNew, $size) = self::getExpireList($time, $versions, $availableSpace <= 0);\n\t\t\t\t\t$toDelete = array_merge($toDelete, $toDeleteNew);\n\t\t\t\t\t$sizeOfDeletedVersions += $size;\n\t\t\t\t}\n\t\t\t\t$availableSpace = $availableSpace + $sizeOfDeletedVersions;\n\t\t\t\t$versionsSize = $versionsSize - $sizeOfDeletedVersions;\n\t\t\t}\n\n\t\t\tforeach($toDelete as $key => $path) {\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $path, 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tself::deleteVersion($versionsFileview, $path);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $path, 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tunset($allVersions[$key]); // update array with the versions we keep\n\t\t\t\t\\OCP\\Util::writeLog('files_versions', \"Expire: \" . $path, \\OCP\\Util::DEBUG);\n\t\t\t}\n\n\t\t\t// Check if enough space is available after versions are rearranged.\n\t\t\t// If not we delete the oldest versions until we meet the size limit for versions,\n\t\t\t// but always keep the two latest versions\n\t\t\t$numOfVersions = count($allVersions) -2 ;\n\t\t\t$i = 0;\n\t\t\t// sort oldest first and make sure that we start at the first element\n\t\t\tksort($allVersions);\n\t\t\treset($allVersions);\n\t\t\twhile ($availableSpace < 0 && $i < $numOfVersions) {\n\t\t\t\t$version = current($allVersions);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'preDelete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\tself::deleteVersion($versionsFileview, $version['path'] . '.v' . $version['version']);\n\t\t\t\t\\OC_Hook::emit('\\OCP\\Versions', 'delete', array('path' => $version['path'].'.v'.$version['version'], 'trigger' => self::DELETE_TRIGGER_QUOTA_EXCEEDED));\n\t\t\t\t\\OCP\\Util::writeLog('files_versions', 'running out of space! Delete oldest version: ' . $version['path'].'.v'.$version['version'] , \\OCP\\Util::DEBUG);\n\t\t\t\t$versionsSize -= $version['size'];\n\t\t\t\t$availableSpace += $version['size'];\n\t\t\t\tnext($allVersions);\n\t\t\t\t$i++;\n\t\t\t}\n\n\t\t\treturn $versionsSize; // finally return the new size of the version history\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create recursively missing directories inside of files_versions\n\t * that match the given path to a file.\n\t *\n\t * @param string $filename $path to a file, relative to the user's\n\t * \"files\" folder\n\t * @param View $view view on data/user/\n\t */\n\tprivate static function createMissingDirectories($filename, $view) {\n\t\t$dirname = Filesystem::normalizePath(dirname($filename));\n\t\t$dirParts = explode('/', $dirname);\n\t\t$dir = \"/files_versions\";\n\t\tforeach ($dirParts as $part) {\n\t\t\t$dir = $dir . '/' . $part;\n\t\t\tif (!$view->file_exists($dir)) {\n\t\t\t\t$view->mkdir($dir);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Static workaround\n\t * @return Expiration\n\t */\n\tprotected static function getExpiration(){\n\t\tif (is_null(self::$application)) {\n\t\t\tself::$application = new Application();\n\t\t}\n\t\treturn self::$application->getContainer()->query('Expiration');\n\t}\n\n}\n"], "filenames": ["apps/files_versions/lib/storage.php"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [685], "fixing_code_start_loc": [81], "fixing_code_end_loc": [691], "type": "CWE-284", "message": "Nextcloud Server before 9.0.52 & ownCloud Server before 9.0.4 are not properly verifying restore privileges when restoring a file. The restore capability of Nextcloud/ownCloud was not verifying whether a user has only read-only access to a share. Thus a user with read-only access was able to restore old versions.", "other": {"cve": {"id": "CVE-2016-9462", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:00.887", "lastModified": "2019-10-09T23:20:28.867", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Nextcloud Server before 9.0.52 & ownCloud Server before 9.0.4 are not properly verifying restore privileges when restoring a file. The restore capability of Nextcloud/ownCloud was not verifying whether a user has only read-only access to a share. Thus a user with read-only access was able to restore old versions."}, {"lang": "es", "value": "Nextcloud Server en versiones anteriores a 9.0.52 & ownCloud Server en versiones anteriores a 9.0.4 no est\u00e1n verificando correctamente los privilegios de restauraci\u00f3n al restaurar un archivo. La capacidad de restauraci\u00f3n de Nextcloud/ownCloud no estaba verificando si un usuario s\u00f3lo tiene acceso de s\u00f3lo lectura a un recurso compartido. As\u00ed, un usuario con acceso de s\u00f3lo lectura fue capaz de restaurar versiones antiguas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-275"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:nextcloud_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.52", "matchCriteriaId": "DC479D9A-DAEB-42B6-98D7-0A417B34359D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.4", "matchCriteriaId": "3FAD2663-CE0E-4AB0-90C5-D47124458AAC"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97285", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/nextcloud/server/commit/1208953ba1d4d55a18a639846bbcdd66a2d5bc5e", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/23383080731d092e079986464a8c4c9ffcb79f4c", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/3b056fa68ce502ceb0db9b446dab3b9e7b10dd13", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/c93eca49c32428ece03dd67042772d5fa62c8d6e", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/d31720b6f1e8c8dfeb5e8805ab35ad7c8000b2f1", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/146067", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://nextcloud.com/security/advisory/?id=nc-sa-2016-005", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://owncloud.org/security/advisory/?id=oc-sa-2016-015", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nextcloud/server/commit/1208953ba1d4d55a18a639846bbcdd66a2d5bc5e"}}