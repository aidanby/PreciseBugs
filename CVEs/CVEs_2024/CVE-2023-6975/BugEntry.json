{"buggy_code": ["import ftplib\nimport os\nimport posixpath\nimport urllib.parse\nfrom contextlib import contextmanager\nfrom ftplib import FTP\nfrom urllib.parse import unquote\n\nfrom mlflow.entities.file_info import FileInfo\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.store.artifact.artifact_repo import ArtifactRepository\nfrom mlflow.utils.file_utils import relative_path_to_artifact_path\n\n\nclass FTPArtifactRepository(ArtifactRepository):\n    \"\"\"Stores artifacts as files in a remote directory, via ftp.\"\"\"\n\n    def __init__(self, artifact_uri):\n        self.uri = artifact_uri\n        parsed = urllib.parse.urlparse(artifact_uri)\n        self.config = {\n            \"host\": parsed.hostname,\n            \"port\": 21 if parsed.port is None else parsed.port,\n            \"username\": parsed.username,\n            \"password\": parsed.password,\n        }\n        self.path = parsed.path or \"/\"\n\n        if self.config[\"host\"] is None:\n            self.config[\"host\"] = \"localhost\"\n        if self.config[\"password\"] is None:\n            self.config[\"password\"] = \"\"\n        else:\n            self.config[\"password\"] = unquote(parsed.password)\n\n        super().__init__(artifact_uri)\n\n    @contextmanager\n    def get_ftp_client(self):\n        ftp = FTP()\n        ftp.connect(self.config[\"host\"], self.config[\"port\"])\n        ftp.login(self.config[\"username\"], self.config[\"password\"])\n        yield ftp\n        ftp.close()\n\n    @staticmethod\n    def _is_dir(ftp, full_file_path):\n        try:\n            ftp.cwd(full_file_path)\n            return True\n        except ftplib.error_perm:\n            return False\n\n    @staticmethod\n    def _mkdir(ftp, artifact_dir):\n        try:\n            if not FTPArtifactRepository._is_dir(ftp, artifact_dir):\n                ftp.mkd(artifact_dir)\n        except ftplib.error_perm:\n            head, _ = posixpath.split(artifact_dir)\n            FTPArtifactRepository._mkdir(ftp, head)\n            FTPArtifactRepository._mkdir(ftp, artifact_dir)\n\n    @staticmethod\n    def _size(ftp, full_file_path):\n        ftp.voidcmd(\"TYPE I\")\n        size = ftp.size(full_file_path)\n        ftp.voidcmd(\"TYPE A\")\n        return size\n\n    def log_artifact(self, local_file, artifact_path=None):\n        with self.get_ftp_client() as ftp:\n            artifact_dir = posixpath.join(self.path, artifact_path) if artifact_path else self.path\n            self._mkdir(ftp, artifact_dir)\n            with open(local_file, \"rb\") as f:\n                ftp.cwd(artifact_dir)\n                ftp.storbinary(\"STOR \" + os.path.basename(local_file), f)\n\n    def log_artifacts(self, local_dir, artifact_path=None):\n        dest_path = posixpath.join(self.path, artifact_path) if artifact_path else self.path\n\n        local_dir = os.path.abspath(local_dir)\n        for root, _, filenames in os.walk(local_dir):\n            upload_path = dest_path\n            if root != local_dir:\n                rel_path = os.path.relpath(root, local_dir)\n                rel_upload_path = relative_path_to_artifact_path(rel_path)\n                upload_path = posixpath.join(dest_path, rel_upload_path)\n            if not filenames:\n                with self.get_ftp_client() as ftp:\n                    self._mkdir(ftp, upload_path)\n            for f in filenames:\n                if os.path.isfile(os.path.join(root, f)):\n                    self.log_artifact(os.path.join(root, f), upload_path)\n\n    def _is_directory(self, artifact_path):\n        artifact_dir = self.path\n        list_dir = posixpath.join(artifact_dir, artifact_path) if artifact_path else artifact_dir\n        with self.get_ftp_client() as ftp:\n            return self._is_dir(ftp, list_dir)\n\n    def list_artifacts(self, path=None):\n        with self.get_ftp_client() as ftp:\n            artifact_dir = self.path\n            list_dir = posixpath.join(artifact_dir, path) if path else artifact_dir\n            if not self._is_dir(ftp, list_dir):\n                return []\n            artifact_files = ftp.nlst(list_dir)\n            artifact_files = list(filter(lambda x: x != \".\" and x != \"..\", artifact_files))\n            # Make sure artifact_files is a list of file names because ftp.nlst\n            # may return absolute paths.\n            artifact_files = [os.path.basename(f) for f in artifact_files]\n            infos = []\n            for file_name in artifact_files:\n                file_path = file_name if path is None else posixpath.join(path, file_name)\n                full_file_path = posixpath.join(list_dir, file_name)\n                if self._is_dir(ftp, full_file_path):\n                    infos.append(FileInfo(file_path, True, None))\n                else:\n                    size = self._size(ftp, full_file_path)\n                    infos.append(FileInfo(file_path, False, size))\n        return infos\n\n    def _download_file(self, remote_file_path, local_path):\n        remote_full_path = (\n            posixpath.join(self.path, remote_file_path) if remote_file_path else self.path\n        )\n        with self.get_ftp_client() as ftp:\n            with open(local_path, \"wb\") as f:\n                ftp.retrbinary(\"RETR \" + remote_full_path, f.write)\n\n    def delete_artifacts(self, artifact_path=None):\n        raise MlflowException(\"Not implemented yet\")\n", "# pylint: disable=redefined-outer-name\nimport ftplib\nimport posixpath\nfrom ftplib import FTP\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom mlflow.store.artifact.artifact_repository_registry import get_artifact_repository\nfrom mlflow.store.artifact.ftp_artifact_repo import FTPArtifactRepository\n\n\n@pytest.fixture\ndef ftp_mock():\n    return MagicMock(autospec=FTP)\n\n\ndef test_artifact_uri_factory():\n    repo = get_artifact_repository(\"ftp://user:pass@test_ftp:123/some/path\")\n    assert isinstance(repo, FTPArtifactRepository)\n\n\ndef test_list_artifacts_empty(ftp_mock):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    ftp_mock.nlst = MagicMock(return_value=[])\n    assert repo.list_artifacts() == []\n    ftp_mock.nlst.assert_called_once_with(\"/some/path\")\n\n\ndef test_list_artifacts(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- file\n    #  |- model\n    #     |- model.pb\n\n    file_path = \"file\"\n    file_size = 678\n    dir_path = \"model\"\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n    ftp_mock.nlst = MagicMock(return_value=[file_path, dir_path])\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=None)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_path\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_list_artifacts_when_ftp_nlst_returns_absolute_paths(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- file\n    #  |- model\n    #     |- model.pb\n\n    file_path = \"file\"\n    dir_path = \"model\"\n    file_size = 678\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n    ftp_mock.nlst = MagicMock(\n        return_value=[\n            posixpath.join(artifact_root_path, file_path),\n            posixpath.join(artifact_root_path, dir_path),\n        ]\n    )\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=None)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_path\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_list_artifacts_with_subdir(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"sftp://test_sftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- model\n    #     |- model.pb\n    #     |- variables\n    dir_name = \"model\"\n\n    # list artifacts at sub directory level\n    file_path = \"model.pb\"\n    file_size = 345\n    subdir_name = \"variables\"\n\n    ftp_mock.nlst = MagicMock(return_value=[file_path, subdir_name])\n\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=dir_name)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path + dir_name)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + dir_name + \"/\" + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == dir_name + \"/\" + file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_name + \"/\" + subdir_name\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_log_artifact(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    f = d.joinpath(\"test.txt\")\n    f.write_text(\"hello world!\")\n    fpath = d.joinpath(\"test.txt\")\n    fpath = str(fpath)\n\n    ftp_mock.cwd = MagicMock(side_effect=[ftplib.error_perm, None])\n\n    repo.log_artifact(fpath)\n\n    ftp_mock.mkd.assert_called_once_with(\"/some/path\")\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called_once()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test.txt\"\n\n\ndef test_log_artifact_multiple_calls(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    file1 = d.joinpath(\"test1.txt\")\n    file1.write_text(\"hello world!\")\n    fpath1 = d.joinpath(\"test1.txt\")\n    fpath1 = str(fpath1)\n\n    file2 = d.joinpath(\"test2.txt\")\n    file2.write_text(\"hello world!\")\n    fpath2 = d.joinpath(\"test2.txt\")\n    fpath2 = str(fpath2)\n\n    ftp_mock.cwd = MagicMock(\n        side_effect=[ftplib.error_perm, None, ftplib.error_perm, None, None, None]\n    )\n\n    repo.log_artifact(fpath1)\n    ftp_mock.mkd.assert_called_once_with(\"/some/path\")\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test1.txt\"\n    ftp_mock.reset_mock()\n\n    repo.log_artifact(fpath1, \"subdir\")\n    ftp_mock.mkd.assert_called_once_with(\"/some/path/subdir\")\n    ftp_mock.cwd.assert_called_with(\"/some/path/subdir\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test1.txt\"\n    ftp_mock.reset_mock()\n\n    repo.log_artifact(fpath2)\n    ftp_mock.mkd.assert_not_called()\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test2.txt\"\n\n\ndef __posixpath_parents(pathname, root):\n    parents = [posixpath.dirname(pathname)]\n    root = posixpath.normpath(root)\n    while parents[-1] != \"/\" and parents[-1] != root:\n        parents.append(posixpath.dirname(parents[-1]))\n    return parents\n\n\n@pytest.mark.parametrize(\"artifact_path\", [None, \"dir\", \"dir1/dir2\"])\ndef test_log_artifacts(artifact_path, ftp_mock, tmp_path):\n    # Setup FTP mock.\n    dest_path_root = \"/some/path\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + dest_path_root)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    dirs_created = {dest_path_root}\n    files_created = set()\n    cwd_history = [\"/\"]\n\n    def mkd_mock(pathname):\n        abs_pathname = posixpath.join(cwd_history[-1], pathname)\n        if posixpath.dirname(abs_pathname) not in dirs_created:\n            raise ftplib.error_perm\n        dirs_created.add(abs_pathname)\n\n    ftp_mock.mkd = MagicMock(side_effect=mkd_mock)\n\n    def cwd_mock(pathname):\n        abs_pathname = posixpath.join(cwd_history[-1], pathname)\n        if abs_pathname not in dirs_created:\n            raise ftplib.error_perm\n        cwd_history.append(abs_pathname)\n\n    ftp_mock.cwd = MagicMock(side_effect=cwd_mock)\n\n    def storbinary_mock(cmd, _):\n        head, basename = cmd.split(\" \", 1)\n        assert head == \"STOR\"\n        assert \"/\" not in basename\n        files_created.add(posixpath.join(cwd_history[-1], basename))\n\n    ftp_mock.storbinary = MagicMock(side_effect=storbinary_mock)\n\n    # Test\n    data = tmp_path.joinpath(\"data\")\n    data.mkdir()\n    subd = data.joinpath(\"subdir\")\n    subd.mkdir()\n    subd.joinpath(\"a.txt\").write_text(\"A\")\n    subd.joinpath(\"b.txt\").write_text(\"B\")\n    subd.joinpath(\"c.txt\").write_text(\"C\")\n    subd.joinpath(\"empty1\").mkdir()\n    subsubd = subd.joinpath(\"subsubdir\")\n    subsubd.mkdir()\n    subsubd.joinpath(\"aa.txt\").write_text(\"AA\")\n    subsubd.joinpath(\"bb.txt\").write_text(\"BB\")\n    subsubd.joinpath(\"cc.txt\").write_text(\"CC\")\n    subsubd.joinpath(\"empty2\").mkdir()\n\n    dest_path = (\n        dest_path_root if artifact_path is None else posixpath.join(dest_path_root, artifact_path)\n    )\n    dirs_expected = {\n        dest_path,\n        posixpath.join(dest_path, \"empty1\"),\n        posixpath.join(dest_path, \"subsubdir\"),\n        posixpath.join(dest_path, \"subsubdir\", \"empty2\"),\n    }\n\n    files_expected = {\n        posixpath.join(dest_path, \"a.txt\"),\n        posixpath.join(dest_path, \"b.txt\"),\n        posixpath.join(dest_path, \"c.txt\"),\n        posixpath.join(dest_path, \"subsubdir/aa.txt\"),\n        posixpath.join(dest_path, \"subsubdir/bb.txt\"),\n        posixpath.join(dest_path, \"subsubdir/cc.txt\"),\n    }\n\n    for dirs_expected_i in dirs_expected.copy():\n        if dirs_expected_i != dest_path_root:\n            dirs_expected |= set(__posixpath_parents(dirs_expected_i, root=dest_path_root))\n\n    repo.log_artifacts(subd, artifact_path)\n    assert dirs_created == dirs_expected\n    assert files_created == files_expected\n\n\ndef test_download_artifacts_single(ftp_mock):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    ftp_mock.cwd = MagicMock(side_effect=ftplib.error_perm)\n\n    repo.download_artifacts(\"test.txt\")\n\n    ftp_mock.retrbinary.assert_called_once()\n    assert ftp_mock.retrbinary.call_args_list[0][0][0] == \"RETR /some/path/test.txt\"\n\n\ndef test_download_artifacts(ftp_mock):\n    artifact_root_path = \"/some/path\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- model\n    #     |- model.pb\n    #     |- empty_dir\n    #     |- variables\n    #        |- test.txt\n    dir_path = posixpath.join(artifact_root_path, \"model\")\n\n    # list artifacts at sub directory level\n    model_file_path_sub = \"model.pb\"\n    model_file_path_full = posixpath.join(dir_path, model_file_path_sub)\n    empty_dir_name = \"empty_dir\"\n    empty_dir_path = posixpath.join(dir_path, empty_dir_name)\n    subdir_name = \"variables\"\n    subdir_path_full = posixpath.join(dir_path, subdir_name)\n    subfile_name = \"test.txt\"\n    subfile_path_full = posixpath.join(artifact_root_path, subdir_path_full, subfile_name)\n\n    is_dir_mapping = {\n        dir_path: True,\n        empty_dir_path: True,\n        model_file_path_full: False,\n        subdir_path_full: True,\n        subfile_path_full: False,\n    }\n\n    is_dir_call_args = [\n        dir_path,\n        model_file_path_full,\n        empty_dir_path,\n        subdir_path_full,\n        model_file_path_full,\n        subdir_path_full,\n        subfile_path_full,\n        subfile_path_full,\n    ]\n\n    def cwd_side_effect(call_arg):\n        if not is_dir_mapping[call_arg]:\n            raise ftplib.error_perm\n\n    ftp_mock.cwd = MagicMock(side_effect=cwd_side_effect)\n\n    def nlst_side_effect(call_arg):\n        if call_arg == dir_path:\n            return [model_file_path_sub, subdir_name, empty_dir_name]\n        elif call_arg == subdir_path_full:\n            return [subfile_name]\n        elif call_arg == empty_dir_path:\n            return []\n        else:\n            raise Exception(f\"should never call nlst for non-directories {call_arg}\")\n\n    ftp_mock.nlst = MagicMock(side_effect=nlst_side_effect)\n    repo.download_artifacts(\"model\")\n\n    cwd_call_args = [arg_entry[0][0] for arg_entry in ftp_mock.cwd.call_args_list]\n\n    assert set(cwd_call_args) == set(is_dir_call_args)\n    assert ftp_mock.nlst.call_count == 3\n    assert ftp_mock.retrbinary.call_args_list[0][0][0] == \"RETR \" + model_file_path_full\n    assert ftp_mock.retrbinary.call_args_list[1][0][0] == \"RETR \" + subfile_path_full\n\n\ndef test_log_artifact_reuse_ftp_client(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    file = d.joinpath(\"test.txt\")\n    file.write_text(\"hello world!\")\n    fpath = str(file)\n\n    repo.log_artifact(fpath)\n    repo.log_artifact(fpath, \"subdir1/subdir2\")\n    repo.log_artifact(fpath, \"subdir3\")\n\n    assert repo.get_ftp_client.call_count == 3\n"], "fixing_code": ["import ftplib\nimport os\nimport posixpath\nimport urllib.parse\nfrom contextlib import contextmanager\nfrom ftplib import FTP\nfrom urllib.parse import unquote\n\nfrom mlflow.entities.file_info import FileInfo\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.store.artifact.artifact_repo import ArtifactRepository\nfrom mlflow.utils.file_utils import relative_path_to_artifact_path\n\n\nclass FTPArtifactRepository(ArtifactRepository):\n    \"\"\"Stores artifacts as files in a remote directory, via ftp.\"\"\"\n\n    def __init__(self, artifact_uri):\n        self.uri = artifact_uri\n        parsed = urllib.parse.urlparse(artifact_uri)\n        self.config = {\n            \"host\": parsed.hostname,\n            \"port\": 21 if parsed.port is None else parsed.port,\n            \"username\": parsed.username,\n            \"password\": parsed.password,\n        }\n        self.path = parsed.path or \"/\"\n\n        if self.config[\"host\"] is None:\n            self.config[\"host\"] = \"localhost\"\n        if self.config[\"password\"] is None:\n            self.config[\"password\"] = \"\"\n        else:\n            self.config[\"password\"] = unquote(parsed.password)\n\n        super().__init__(artifact_uri)\n\n    @contextmanager\n    def get_ftp_client(self):\n        ftp = FTP()\n        ftp.connect(self.config[\"host\"], self.config[\"port\"])\n        ftp.login(self.config[\"username\"], self.config[\"password\"])\n        yield ftp\n        ftp.close()\n\n    @staticmethod\n    def _is_dir(ftp, full_file_path):\n        try:\n            ftp.cwd(full_file_path)\n            return True\n        except ftplib.error_perm:\n            return False\n\n    @staticmethod\n    def _mkdir(ftp, artifact_dir):\n        try:\n            if not FTPArtifactRepository._is_dir(ftp, artifact_dir):\n                ftp.mkd(artifact_dir)\n        except ftplib.error_perm:\n            head, _ = posixpath.split(artifact_dir)\n            FTPArtifactRepository._mkdir(ftp, head)\n            FTPArtifactRepository._mkdir(ftp, artifact_dir)\n\n    @staticmethod\n    def _size(ftp, full_file_path):\n        ftp.voidcmd(\"TYPE I\")\n        size = ftp.size(full_file_path)\n        ftp.voidcmd(\"TYPE A\")\n        return size\n\n    def log_artifact(self, local_file, artifact_path=None):\n        with self.get_ftp_client() as ftp:\n            artifact_dir = posixpath.join(self.path, artifact_path) if artifact_path else self.path\n            self._mkdir(ftp, artifact_dir)\n            with open(local_file, \"rb\") as f:\n                ftp.cwd(artifact_dir)\n                ftp.storbinary(\"STOR \" + os.path.basename(local_file), f)\n\n    def log_artifacts(self, local_dir, artifact_path=None):\n        dest_path = posixpath.join(self.path, artifact_path) if artifact_path else self.path\n\n        local_dir = os.path.abspath(local_dir)\n        for root, _, filenames in os.walk(local_dir):\n            upload_path = dest_path\n            if root != local_dir:\n                rel_path = os.path.relpath(root, local_dir)\n                rel_upload_path = relative_path_to_artifact_path(rel_path)\n                upload_path = posixpath.join(dest_path, rel_upload_path)\n            if not filenames:\n                with self.get_ftp_client() as ftp:\n                    self._mkdir(ftp, upload_path)\n            for f in filenames:\n                if os.path.isfile(os.path.join(root, f)):\n                    self.log_artifact(os.path.join(root, f), upload_path)\n\n    def _is_directory(self, artifact_path):\n        artifact_dir = self.path\n        list_dir = posixpath.join(artifact_dir, artifact_path) if artifact_path else artifact_dir\n        with self.get_ftp_client() as ftp:\n            return self._is_dir(ftp, list_dir)\n\n    def list_artifacts(self, path=None):\n        with self.get_ftp_client() as ftp:\n            artifact_dir = self.path\n            list_dir = posixpath.join(artifact_dir, path) if path else artifact_dir\n            if not self._is_dir(ftp, list_dir):\n                return []\n            artifact_files = ftp.nlst(list_dir)\n            # Make sure artifact_files is a list of file names because ftp.nlst\n            # may return absolute paths.\n            artifact_files = [os.path.basename(f) for f in artifact_files]\n            artifact_files = list(filter(lambda x: x != \".\" and x != \"..\", artifact_files))\n            infos = []\n            for file_name in artifact_files:\n                file_path = file_name if path is None else posixpath.join(path, file_name)\n                full_file_path = posixpath.join(list_dir, file_name)\n                if self._is_dir(ftp, full_file_path):\n                    infos.append(FileInfo(file_path, True, None))\n                else:\n                    size = self._size(ftp, full_file_path)\n                    infos.append(FileInfo(file_path, False, size))\n        return infos\n\n    def _download_file(self, remote_file_path, local_path):\n        remote_full_path = (\n            posixpath.join(self.path, remote_file_path) if remote_file_path else self.path\n        )\n        with self.get_ftp_client() as ftp:\n            with open(local_path, \"wb\") as f:\n                ftp.retrbinary(\"RETR \" + remote_full_path, f.write)\n\n    def delete_artifacts(self, artifact_path=None):\n        raise MlflowException(\"Not implemented yet\")\n", "# pylint: disable=redefined-outer-name\nimport ftplib\nimport posixpath\nfrom ftplib import FTP\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom mlflow.store.artifact.artifact_repository_registry import get_artifact_repository\nfrom mlflow.store.artifact.ftp_artifact_repo import FTPArtifactRepository\n\n\n@pytest.fixture\ndef ftp_mock():\n    return MagicMock(autospec=FTP)\n\n\ndef test_artifact_uri_factory():\n    repo = get_artifact_repository(\"ftp://user:pass@test_ftp:123/some/path\")\n    assert isinstance(repo, FTPArtifactRepository)\n\n\ndef test_list_artifacts_empty(ftp_mock):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    ftp_mock.nlst = MagicMock(return_value=[])\n    assert repo.list_artifacts() == []\n    ftp_mock.nlst.assert_called_once_with(\"/some/path\")\n\n\ndef test_list_artifacts(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- file\n    #  |- model\n    #     |- model.pb\n\n    file_path = \"file\"\n    file_size = 678\n    dir_path = \"model\"\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n    ftp_mock.nlst = MagicMock(return_value=[file_path, dir_path])\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=None)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_path\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_list_artifacts_malicious_path(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n    ftp_mock.nlst = MagicMock(return_value=[\".\", \"/.\", \"/..\", \"//..\"])\n\n    artifacts = repo.list_artifacts(path=None)\n    assert artifacts == []\n\n\ndef test_list_artifacts_when_ftp_nlst_returns_absolute_paths(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- file\n    #  |- model\n    #     |- model.pb\n\n    file_path = \"file\"\n    dir_path = \"model\"\n    file_size = 678\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n    ftp_mock.nlst = MagicMock(\n        return_value=[\n            posixpath.join(artifact_root_path, file_path),\n            posixpath.join(artifact_root_path, dir_path),\n        ]\n    )\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=None)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_path\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_list_artifacts_with_subdir(ftp_mock):\n    artifact_root_path = \"/experiment_id/run_id/\"\n    repo = FTPArtifactRepository(\"sftp://test_sftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- model\n    #     |- model.pb\n    #     |- variables\n    dir_name = \"model\"\n\n    # list artifacts at sub directory level\n    file_path = \"model.pb\"\n    file_size = 345\n    subdir_name = \"variables\"\n\n    ftp_mock.nlst = MagicMock(return_value=[file_path, subdir_name])\n\n    ftp_mock.cwd = MagicMock(side_effect=[None, ftplib.error_perm, None])\n\n    ftp_mock.size = MagicMock(return_value=file_size)\n\n    artifacts = repo.list_artifacts(path=dir_name)\n\n    ftp_mock.nlst.assert_called_once_with(artifact_root_path + dir_name)\n    ftp_mock.size.assert_called_once_with(artifact_root_path + dir_name + \"/\" + file_path)\n\n    assert len(artifacts) == 2\n    assert artifacts[0].path == dir_name + \"/\" + file_path\n    assert artifacts[0].is_dir is False\n    assert artifacts[0].file_size == file_size\n    assert artifacts[1].path == dir_name + \"/\" + subdir_name\n    assert artifacts[1].is_dir is True\n    assert artifacts[1].file_size is None\n\n\ndef test_log_artifact(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    f = d.joinpath(\"test.txt\")\n    f.write_text(\"hello world!\")\n    fpath = d.joinpath(\"test.txt\")\n    fpath = str(fpath)\n\n    ftp_mock.cwd = MagicMock(side_effect=[ftplib.error_perm, None])\n\n    repo.log_artifact(fpath)\n\n    ftp_mock.mkd.assert_called_once_with(\"/some/path\")\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called_once()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test.txt\"\n\n\ndef test_log_artifact_multiple_calls(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    file1 = d.joinpath(\"test1.txt\")\n    file1.write_text(\"hello world!\")\n    fpath1 = d.joinpath(\"test1.txt\")\n    fpath1 = str(fpath1)\n\n    file2 = d.joinpath(\"test2.txt\")\n    file2.write_text(\"hello world!\")\n    fpath2 = d.joinpath(\"test2.txt\")\n    fpath2 = str(fpath2)\n\n    ftp_mock.cwd = MagicMock(\n        side_effect=[ftplib.error_perm, None, ftplib.error_perm, None, None, None]\n    )\n\n    repo.log_artifact(fpath1)\n    ftp_mock.mkd.assert_called_once_with(\"/some/path\")\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test1.txt\"\n    ftp_mock.reset_mock()\n\n    repo.log_artifact(fpath1, \"subdir\")\n    ftp_mock.mkd.assert_called_once_with(\"/some/path/subdir\")\n    ftp_mock.cwd.assert_called_with(\"/some/path/subdir\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test1.txt\"\n    ftp_mock.reset_mock()\n\n    repo.log_artifact(fpath2)\n    ftp_mock.mkd.assert_not_called()\n    ftp_mock.cwd.assert_called_with(\"/some/path\")\n    ftp_mock.storbinary.assert_called()\n    assert ftp_mock.storbinary.call_args_list[0][0][0] == \"STOR test2.txt\"\n\n\ndef __posixpath_parents(pathname, root):\n    parents = [posixpath.dirname(pathname)]\n    root = posixpath.normpath(root)\n    while parents[-1] != \"/\" and parents[-1] != root:\n        parents.append(posixpath.dirname(parents[-1]))\n    return parents\n\n\n@pytest.mark.parametrize(\"artifact_path\", [None, \"dir\", \"dir1/dir2\"])\ndef test_log_artifacts(artifact_path, ftp_mock, tmp_path):\n    # Setup FTP mock.\n    dest_path_root = \"/some/path\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + dest_path_root)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    dirs_created = {dest_path_root}\n    files_created = set()\n    cwd_history = [\"/\"]\n\n    def mkd_mock(pathname):\n        abs_pathname = posixpath.join(cwd_history[-1], pathname)\n        if posixpath.dirname(abs_pathname) not in dirs_created:\n            raise ftplib.error_perm\n        dirs_created.add(abs_pathname)\n\n    ftp_mock.mkd = MagicMock(side_effect=mkd_mock)\n\n    def cwd_mock(pathname):\n        abs_pathname = posixpath.join(cwd_history[-1], pathname)\n        if abs_pathname not in dirs_created:\n            raise ftplib.error_perm\n        cwd_history.append(abs_pathname)\n\n    ftp_mock.cwd = MagicMock(side_effect=cwd_mock)\n\n    def storbinary_mock(cmd, _):\n        head, basename = cmd.split(\" \", 1)\n        assert head == \"STOR\"\n        assert \"/\" not in basename\n        files_created.add(posixpath.join(cwd_history[-1], basename))\n\n    ftp_mock.storbinary = MagicMock(side_effect=storbinary_mock)\n\n    # Test\n    data = tmp_path.joinpath(\"data\")\n    data.mkdir()\n    subd = data.joinpath(\"subdir\")\n    subd.mkdir()\n    subd.joinpath(\"a.txt\").write_text(\"A\")\n    subd.joinpath(\"b.txt\").write_text(\"B\")\n    subd.joinpath(\"c.txt\").write_text(\"C\")\n    subd.joinpath(\"empty1\").mkdir()\n    subsubd = subd.joinpath(\"subsubdir\")\n    subsubd.mkdir()\n    subsubd.joinpath(\"aa.txt\").write_text(\"AA\")\n    subsubd.joinpath(\"bb.txt\").write_text(\"BB\")\n    subsubd.joinpath(\"cc.txt\").write_text(\"CC\")\n    subsubd.joinpath(\"empty2\").mkdir()\n\n    dest_path = (\n        dest_path_root if artifact_path is None else posixpath.join(dest_path_root, artifact_path)\n    )\n    dirs_expected = {\n        dest_path,\n        posixpath.join(dest_path, \"empty1\"),\n        posixpath.join(dest_path, \"subsubdir\"),\n        posixpath.join(dest_path, \"subsubdir\", \"empty2\"),\n    }\n\n    files_expected = {\n        posixpath.join(dest_path, \"a.txt\"),\n        posixpath.join(dest_path, \"b.txt\"),\n        posixpath.join(dest_path, \"c.txt\"),\n        posixpath.join(dest_path, \"subsubdir/aa.txt\"),\n        posixpath.join(dest_path, \"subsubdir/bb.txt\"),\n        posixpath.join(dest_path, \"subsubdir/cc.txt\"),\n    }\n\n    for dirs_expected_i in dirs_expected.copy():\n        if dirs_expected_i != dest_path_root:\n            dirs_expected |= set(__posixpath_parents(dirs_expected_i, root=dest_path_root))\n\n    repo.log_artifacts(subd, artifact_path)\n    assert dirs_created == dirs_expected\n    assert files_created == files_expected\n\n\ndef test_download_artifacts_single(ftp_mock):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    ftp_mock.cwd = MagicMock(side_effect=ftplib.error_perm)\n\n    repo.download_artifacts(\"test.txt\")\n\n    ftp_mock.retrbinary.assert_called_once()\n    assert ftp_mock.retrbinary.call_args_list[0][0][0] == \"RETR /some/path/test.txt\"\n\n\ndef test_download_artifacts(ftp_mock):\n    artifact_root_path = \"/some/path\"\n    repo = FTPArtifactRepository(\"ftp://test_ftp\" + artifact_root_path)\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    # mocked file structure\n    #  |- model\n    #     |- model.pb\n    #     |- empty_dir\n    #     |- variables\n    #        |- test.txt\n    dir_path = posixpath.join(artifact_root_path, \"model\")\n\n    # list artifacts at sub directory level\n    model_file_path_sub = \"model.pb\"\n    model_file_path_full = posixpath.join(dir_path, model_file_path_sub)\n    empty_dir_name = \"empty_dir\"\n    empty_dir_path = posixpath.join(dir_path, empty_dir_name)\n    subdir_name = \"variables\"\n    subdir_path_full = posixpath.join(dir_path, subdir_name)\n    subfile_name = \"test.txt\"\n    subfile_path_full = posixpath.join(artifact_root_path, subdir_path_full, subfile_name)\n\n    is_dir_mapping = {\n        dir_path: True,\n        empty_dir_path: True,\n        model_file_path_full: False,\n        subdir_path_full: True,\n        subfile_path_full: False,\n    }\n\n    is_dir_call_args = [\n        dir_path,\n        model_file_path_full,\n        empty_dir_path,\n        subdir_path_full,\n        model_file_path_full,\n        subdir_path_full,\n        subfile_path_full,\n        subfile_path_full,\n    ]\n\n    def cwd_side_effect(call_arg):\n        if not is_dir_mapping[call_arg]:\n            raise ftplib.error_perm\n\n    ftp_mock.cwd = MagicMock(side_effect=cwd_side_effect)\n\n    def nlst_side_effect(call_arg):\n        if call_arg == dir_path:\n            return [model_file_path_sub, subdir_name, empty_dir_name]\n        elif call_arg == subdir_path_full:\n            return [subfile_name]\n        elif call_arg == empty_dir_path:\n            return []\n        else:\n            raise Exception(f\"should never call nlst for non-directories {call_arg}\")\n\n    ftp_mock.nlst = MagicMock(side_effect=nlst_side_effect)\n    repo.download_artifacts(\"model\")\n\n    cwd_call_args = [arg_entry[0][0] for arg_entry in ftp_mock.cwd.call_args_list]\n\n    assert set(cwd_call_args) == set(is_dir_call_args)\n    assert ftp_mock.nlst.call_count == 3\n    assert ftp_mock.retrbinary.call_args_list[0][0][0] == \"RETR \" + model_file_path_full\n    assert ftp_mock.retrbinary.call_args_list[1][0][0] == \"RETR \" + subfile_path_full\n\n\ndef test_log_artifact_reuse_ftp_client(ftp_mock, tmp_path):\n    repo = FTPArtifactRepository(\"ftp://test_ftp/some/path\")\n\n    repo.get_ftp_client = MagicMock()\n    call_mock = MagicMock(return_value=ftp_mock)\n    repo.get_ftp_client.return_value = MagicMock(__enter__=call_mock)\n\n    d = tmp_path.joinpath(\"data\")\n    d.mkdir()\n    file = d.joinpath(\"test.txt\")\n    file.write_text(\"hello world!\")\n    fpath = str(file)\n\n    repo.log_artifact(fpath)\n    repo.log_artifact(fpath, \"subdir1/subdir2\")\n    repo.log_artifact(fpath, \"subdir3\")\n\n    assert repo.get_ftp_client.call_count == 3\n"], "filenames": ["mlflow/store/artifact/ftp_artifact_repo.py", "tests/store/artifact/test_ftp_artifact_repo.py"], "buggy_code_start_loc": [109, 67], "buggy_code_end_loc": [112, 67], "fixing_code_start_loc": [108, 68], "fixing_code_end_loc": [113, 80], "type": "CWE-29", "message": "A malicious user could use this issue to get command execution on the vulnerable machine and get access to data & models information.", "other": {"cve": {"id": "CVE-2023-6975", "sourceIdentifier": "security@huntr.dev", "published": "2023-12-20T06:15:45.553", "lastModified": "2024-02-06T20:16:02.677", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A malicious user could use this issue to get command execution on the vulnerable machine and get access to data & models information."}, {"lang": "es", "value": "Un usuario malintencionado podr\u00eda utilizar este problema para ejecutar comandos en la m\u00e1quina vulnerable y obtener acceso a informaci\u00f3n de datos y modelos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-29"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:mlflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.2", "matchCriteriaId": "6B5585E2-CC70-4BED-AA89-B791F081ACFC"}]}]}], "references": [{"url": "https://github.com/mlflow/mlflow/commit/b9ab9ed77e1deda9697fe472fb1079fd428149ee", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/029a3824-cee3-4cf1-b260-7138aa539b85", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mlflow/mlflow/commit/b9ab9ed77e1deda9697fe472fb1079fd428149ee"}}