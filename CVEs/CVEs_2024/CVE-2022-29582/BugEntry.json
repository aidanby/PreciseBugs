{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Shared application/kernel submission and completion ring pairs, for\n * supporting fast/efficient IO.\n *\n * A note on the read/write ordering memory barriers that are matched between\n * the application and kernel side.\n *\n * After the application reads the CQ ring tail, it must use an\n * appropriate smp_rmb() to pair with the smp_wmb() the kernel uses\n * before writing the tail (using smp_load_acquire to read the tail will\n * do). It also needs a smp_mb() before updating CQ head (ordering the\n * entry load(s) with the head store), pairing with an implicit barrier\n * through a control-dependency in io_get_cqe (smp_store_release to\n * store head will do). Failure to do so could lead to reading invalid\n * CQ entries.\n *\n * Likewise, the application must use an appropriate smp_wmb() before\n * writing the SQ tail (ordering SQ entry stores with the tail store),\n * which pairs with smp_load_acquire in io_get_sqring (smp_store_release\n * to store the tail will do). And it needs a barrier ordering the SQ\n * head load before writing new SQ entries (smp_load_acquire to read\n * head will do).\n *\n * When using the SQ poll thread (IORING_SETUP_SQPOLL), the application\n * needs to check the SQ flags for IORING_SQ_NEED_WAKEUP *after*\n * updating the SQ tail; a full memory barrier smp_mb() is needed\n * between.\n *\n * Also see the examples in the liburing library:\n *\n *\tgit://git.kernel.dk/liburing\n *\n * io_uring also uses READ/WRITE_ONCE() for _any_ store or load that happens\n * from data shared between the kernel and application. This is done both\n * for ordering purposes, but also to ensure that once a value is loaded from\n * data that the application could potentially modify, it remains stable.\n *\n * Copyright (C) 2018-2019 Jens Axboe\n * Copyright (c) 2018-2019 Christoph Hellwig\n */\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <net/compat.h>\n#include <linux/refcount.h>\n#include <linux/uio.h>\n#include <linux/bits.h>\n\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/blk-mq.h>\n#include <linux/bvec.h>\n#include <linux/net.h>\n#include <net/sock.h>\n#include <net/af_unix.h>\n#include <net/scm.h>\n#include <linux/anon_inodes.h>\n#include <linux/sched/mm.h>\n#include <linux/uaccess.h>\n#include <linux/nospec.h>\n#include <linux/sizes.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/namei.h>\n#include <linux/fsnotify.h>\n#include <linux/fadvise.h>\n#include <linux/eventpoll.h>\n#include <linux/splice.h>\n#include <linux/task_work.h>\n#include <linux/pagemap.h>\n#include <linux/io_uring.h>\n#include <linux/audit.h>\n#include <linux/security.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"internal.h\"\n#include \"io-wq.h\"\n\n#define IORING_MAX_ENTRIES\t32768\n#define IORING_MAX_CQ_ENTRIES\t(2 * IORING_MAX_ENTRIES)\n#define IORING_SQPOLL_CAP_ENTRIES_VALUE 8\n\n/* only define max */\n#define IORING_MAX_FIXED_FILES\t(1U << 15)\n#define IORING_MAX_RESTRICTIONS\t(IORING_RESTRICTION_LAST + \\\n\t\t\t\t IORING_REGISTER_LAST + IORING_OP_LAST)\n\n#define IO_RSRC_TAG_TABLE_SHIFT\t(PAGE_SHIFT - 3)\n#define IO_RSRC_TAG_TABLE_MAX\t(1U << IO_RSRC_TAG_TABLE_SHIFT)\n#define IO_RSRC_TAG_TABLE_MASK\t(IO_RSRC_TAG_TABLE_MAX - 1)\n\n#define IORING_MAX_REG_BUFFERS\t(1U << 14)\n\n#define SQE_COMMON_FLAGS (IOSQE_FIXED_FILE | IOSQE_IO_LINK | \\\n\t\t\t  IOSQE_IO_HARDLINK | IOSQE_ASYNC)\n\n#define SQE_VALID_FLAGS\t(SQE_COMMON_FLAGS | IOSQE_BUFFER_SELECT | \\\n\t\t\tIOSQE_IO_DRAIN | IOSQE_CQE_SKIP_SUCCESS)\n\n#define IO_REQ_CLEAN_FLAGS (REQ_F_BUFFER_SELECTED | REQ_F_NEED_CLEANUP | \\\n\t\t\t\tREQ_F_POLLED | REQ_F_CREDS | REQ_F_ASYNC_DATA)\n\n#define IO_TCTX_REFS_CACHE_NR\t(1U << 10)\n\nstruct io_uring {\n\tu32 head ____cacheline_aligned_in_smp;\n\tu32 tail ____cacheline_aligned_in_smp;\n};\n\n/*\n * This data is shared with the application through the mmap at offsets\n * IORING_OFF_SQ_RING and IORING_OFF_CQ_RING.\n *\n * The offsets to the member fields are published through struct\n * io_sqring_offsets when calling io_uring_setup.\n */\nstruct io_rings {\n\t/*\n\t * Head and tail offsets into the ring; the offsets need to be\n\t * masked to get valid indices.\n\t *\n\t * The kernel controls head of the sq ring and the tail of the cq ring,\n\t * and the application controls tail of the sq ring and the head of the\n\t * cq ring.\n\t */\n\tstruct io_uring\t\tsq, cq;\n\t/*\n\t * Bitmasks to apply to head and tail offsets (constant, equals\n\t * ring_entries - 1)\n\t */\n\tu32\t\t\tsq_ring_mask, cq_ring_mask;\n\t/* Ring sizes (constant, power of 2) */\n\tu32\t\t\tsq_ring_entries, cq_ring_entries;\n\t/*\n\t * Number of invalid entries dropped by the kernel due to\n\t * invalid index stored in array\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application (i.e. get number of \"new events\" by comparing to\n\t * cached value).\n\t *\n\t * After a new SQ head value was read by the application this\n\t * counter includes all submissions that were dropped reaching\n\t * the new SQ head (and possibly more).\n\t */\n\tu32\t\t\tsq_dropped;\n\t/*\n\t * Runtime SQ flags\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application.\n\t *\n\t * The application needs a full memory barrier before checking\n\t * for IORING_SQ_NEED_WAKEUP after updating the sq tail.\n\t */\n\tu32\t\t\tsq_flags;\n\t/*\n\t * Runtime CQ flags\n\t *\n\t * Written by the application, shouldn't be modified by the\n\t * kernel.\n\t */\n\tu32\t\t\tcq_flags;\n\t/*\n\t * Number of completion events lost because the queue was full;\n\t * this should be avoided by the application by making sure\n\t * there are not more requests pending than there is space in\n\t * the completion queue.\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application (i.e. get number of \"new events\" by comparing to\n\t * cached value).\n\t *\n\t * As completion events come in out of order this counter is not\n\t * ordered with any other data.\n\t */\n\tu32\t\t\tcq_overflow;\n\t/*\n\t * Ring buffer of completion events.\n\t *\n\t * The kernel writes completion events fresh every time they are\n\t * produced, so the application is allowed to modify pending\n\t * entries.\n\t */\n\tstruct io_uring_cqe\tcqes[] ____cacheline_aligned_in_smp;\n};\n\nenum io_uring_cmd_flags {\n\tIO_URING_F_COMPLETE_DEFER\t= 1,\n\tIO_URING_F_UNLOCKED\t\t= 2,\n\t/* int's last bit, sign checks are usually faster than a bit test */\n\tIO_URING_F_NONBLOCK\t\t= INT_MIN,\n};\n\nstruct io_mapped_ubuf {\n\tu64\t\tubuf;\n\tu64\t\tubuf_end;\n\tunsigned int\tnr_bvecs;\n\tunsigned long\tacct_pages;\n\tstruct bio_vec\tbvec[];\n};\n\nstruct io_ring_ctx;\n\nstruct io_overflow_cqe {\n\tstruct io_uring_cqe cqe;\n\tstruct list_head list;\n};\n\nstruct io_fixed_file {\n\t/* file * with additional FFS_* flags */\n\tunsigned long file_ptr;\n};\n\nstruct io_rsrc_put {\n\tstruct list_head list;\n\tu64 tag;\n\tunion {\n\t\tvoid *rsrc;\n\t\tstruct file *file;\n\t\tstruct io_mapped_ubuf *buf;\n\t};\n};\n\nstruct io_file_table {\n\tstruct io_fixed_file *files;\n};\n\nstruct io_rsrc_node {\n\tstruct percpu_ref\t\trefs;\n\tstruct list_head\t\tnode;\n\tstruct list_head\t\trsrc_list;\n\tstruct io_rsrc_data\t\t*rsrc_data;\n\tstruct llist_node\t\tllist;\n\tbool\t\t\t\tdone;\n};\n\ntypedef void (rsrc_put_fn)(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc);\n\nstruct io_rsrc_data {\n\tstruct io_ring_ctx\t\t*ctx;\n\n\tu64\t\t\t\t**tags;\n\tunsigned int\t\t\tnr;\n\trsrc_put_fn\t\t\t*do_put;\n\tatomic_t\t\t\trefs;\n\tstruct completion\t\tdone;\n\tbool\t\t\t\tquiesce;\n};\n\nstruct io_buffer_list {\n\tstruct list_head list;\n\tstruct list_head buf_list;\n\t__u16 bgid;\n};\n\nstruct io_buffer {\n\tstruct list_head list;\n\t__u64 addr;\n\t__u32 len;\n\t__u16 bid;\n\t__u16 bgid;\n};\n\nstruct io_restriction {\n\tDECLARE_BITMAP(register_op, IORING_REGISTER_LAST);\n\tDECLARE_BITMAP(sqe_op, IORING_OP_LAST);\n\tu8 sqe_flags_allowed;\n\tu8 sqe_flags_required;\n\tbool registered;\n};\n\nenum {\n\tIO_SQ_THREAD_SHOULD_STOP = 0,\n\tIO_SQ_THREAD_SHOULD_PARK,\n};\n\nstruct io_sq_data {\n\trefcount_t\t\trefs;\n\tatomic_t\t\tpark_pending;\n\tstruct mutex\t\tlock;\n\n\t/* ctx's that are using this sqd */\n\tstruct list_head\tctx_list;\n\n\tstruct task_struct\t*thread;\n\tstruct wait_queue_head\twait;\n\n\tunsigned\t\tsq_thread_idle;\n\tint\t\t\tsq_cpu;\n\tpid_t\t\t\ttask_pid;\n\tpid_t\t\t\ttask_tgid;\n\n\tunsigned long\t\tstate;\n\tstruct completion\texited;\n};\n\n#define IO_COMPL_BATCH\t\t\t32\n#define IO_REQ_CACHE_SIZE\t\t32\n#define IO_REQ_ALLOC_BATCH\t\t8\n\nstruct io_submit_link {\n\tstruct io_kiocb\t\t*head;\n\tstruct io_kiocb\t\t*last;\n};\n\nstruct io_submit_state {\n\t/* inline/task_work completion list, under ->uring_lock */\n\tstruct io_wq_work_node\tfree_list;\n\t/* batch completion logic */\n\tstruct io_wq_work_list\tcompl_reqs;\n\tstruct io_submit_link\tlink;\n\n\tbool\t\t\tplug_started;\n\tbool\t\t\tneed_plug;\n\tbool\t\t\tflush_cqes;\n\tunsigned short\t\tsubmit_nr;\n\tstruct blk_plug\t\tplug;\n};\n\nstruct io_ev_fd {\n\tstruct eventfd_ctx\t*cq_ev_fd;\n\tunsigned int\t\teventfd_async: 1;\n\tstruct rcu_head\t\trcu;\n};\n\n#define IO_BUFFERS_HASH_BITS\t5\n\nstruct io_ring_ctx {\n\t/* const or read-mostly hot data */\n\tstruct {\n\t\tstruct percpu_ref\trefs;\n\n\t\tstruct io_rings\t\t*rings;\n\t\tunsigned int\t\tflags;\n\t\tunsigned int\t\tcompat: 1;\n\t\tunsigned int\t\tdrain_next: 1;\n\t\tunsigned int\t\trestricted: 1;\n\t\tunsigned int\t\toff_timeout_used: 1;\n\t\tunsigned int\t\tdrain_active: 1;\n\t\tunsigned int\t\tdrain_disabled: 1;\n\t\tunsigned int\t\thas_evfd: 1;\n\t} ____cacheline_aligned_in_smp;\n\n\t/* submission data */\n\tstruct {\n\t\tstruct mutex\t\turing_lock;\n\n\t\t/*\n\t\t * Ring buffer of indices into array of io_uring_sqe, which is\n\t\t * mmapped by the application using the IORING_OFF_SQES offset.\n\t\t *\n\t\t * This indirection could e.g. be used to assign fixed\n\t\t * io_uring_sqe entries to operations and only submit them to\n\t\t * the queue when needed.\n\t\t *\n\t\t * The kernel modifies neither the indices array nor the entries\n\t\t * array.\n\t\t */\n\t\tu32\t\t\t*sq_array;\n\t\tstruct io_uring_sqe\t*sq_sqes;\n\t\tunsigned\t\tcached_sq_head;\n\t\tunsigned\t\tsq_entries;\n\t\tstruct list_head\tdefer_list;\n\n\t\t/*\n\t\t * Fixed resources fast path, should be accessed only under\n\t\t * uring_lock, and updated through io_uring_register(2)\n\t\t */\n\t\tstruct io_rsrc_node\t*rsrc_node;\n\t\tint\t\t\trsrc_cached_refs;\n\t\tstruct io_file_table\tfile_table;\n\t\tunsigned\t\tnr_user_files;\n\t\tunsigned\t\tnr_user_bufs;\n\t\tstruct io_mapped_ubuf\t**user_bufs;\n\n\t\tstruct io_submit_state\tsubmit_state;\n\t\tstruct list_head\ttimeout_list;\n\t\tstruct list_head\tltimeout_list;\n\t\tstruct list_head\tcq_overflow_list;\n\t\tstruct list_head\t*io_buffers;\n\t\tstruct list_head\tio_buffers_cache;\n\t\tstruct list_head\tapoll_cache;\n\t\tstruct xarray\t\tpersonalities;\n\t\tu32\t\t\tpers_next;\n\t\tunsigned\t\tsq_thread_idle;\n\t} ____cacheline_aligned_in_smp;\n\n\t/* IRQ completion list, under ->completion_lock */\n\tstruct io_wq_work_list\tlocked_free_list;\n\tunsigned int\t\tlocked_free_nr;\n\n\tconst struct cred\t*sq_creds;\t/* cred used for __io_sq_thread() */\n\tstruct io_sq_data\t*sq_data;\t/* if using sq thread polling */\n\n\tstruct wait_queue_head\tsqo_sq_wait;\n\tstruct list_head\tsqd_list;\n\n\tunsigned long\t\tcheck_cq_overflow;\n\n\tstruct {\n\t\tunsigned\t\tcached_cq_tail;\n\t\tunsigned\t\tcq_entries;\n\t\tstruct io_ev_fd\t__rcu\t*io_ev_fd;\n\t\tstruct wait_queue_head\tcq_wait;\n\t\tunsigned\t\tcq_extra;\n\t\tatomic_t\t\tcq_timeouts;\n\t\tunsigned\t\tcq_last_tm_flush;\n\t} ____cacheline_aligned_in_smp;\n\n\tstruct {\n\t\tspinlock_t\t\tcompletion_lock;\n\n\t\tspinlock_t\t\ttimeout_lock;\n\n\t\t/*\n\t\t * ->iopoll_list is protected by the ctx->uring_lock for\n\t\t * io_uring instances that don't use IORING_SETUP_SQPOLL.\n\t\t * For SQPOLL, only the single threaded io_sq_thread() will\n\t\t * manipulate the list, hence no extra locking is needed there.\n\t\t */\n\t\tstruct io_wq_work_list\tiopoll_list;\n\t\tstruct hlist_head\t*cancel_hash;\n\t\tunsigned\t\tcancel_hash_bits;\n\t\tbool\t\t\tpoll_multi_queue;\n\n\t\tstruct list_head\tio_buffers_comp;\n\t} ____cacheline_aligned_in_smp;\n\n\tstruct io_restriction\t\trestrictions;\n\n\t/* slow path rsrc auxilary data, used by update/register */\n\tstruct {\n\t\tstruct io_rsrc_node\t\t*rsrc_backup_node;\n\t\tstruct io_mapped_ubuf\t\t*dummy_ubuf;\n\t\tstruct io_rsrc_data\t\t*file_data;\n\t\tstruct io_rsrc_data\t\t*buf_data;\n\n\t\tstruct delayed_work\t\trsrc_put_work;\n\t\tstruct llist_head\t\trsrc_put_llist;\n\t\tstruct list_head\t\trsrc_ref_list;\n\t\tspinlock_t\t\t\trsrc_ref_lock;\n\n\t\tstruct list_head\tio_buffers_pages;\n\t};\n\n\t/* Keep this last, we don't need it for the fast path */\n\tstruct {\n\t\t#if defined(CONFIG_UNIX)\n\t\t\tstruct socket\t\t*ring_sock;\n\t\t#endif\n\t\t/* hashed buffered write serialization */\n\t\tstruct io_wq_hash\t\t*hash_map;\n\n\t\t/* Only used for accounting purposes */\n\t\tstruct user_struct\t\t*user;\n\t\tstruct mm_struct\t\t*mm_account;\n\n\t\t/* ctx exit and cancelation */\n\t\tstruct llist_head\t\tfallback_llist;\n\t\tstruct delayed_work\t\tfallback_work;\n\t\tstruct work_struct\t\texit_work;\n\t\tstruct list_head\t\ttctx_list;\n\t\tstruct completion\t\tref_comp;\n\t\tu32\t\t\t\tiowq_limits[2];\n\t\tbool\t\t\t\tiowq_limits_set;\n\t};\n};\n\n/*\n * Arbitrary limit, can be raised if need be\n */\n#define IO_RINGFD_REG_MAX 16\n\nstruct io_uring_task {\n\t/* submission side */\n\tint\t\t\tcached_refs;\n\tstruct xarray\t\txa;\n\tstruct wait_queue_head\twait;\n\tconst struct io_ring_ctx *last;\n\tstruct io_wq\t\t*io_wq;\n\tstruct percpu_counter\tinflight;\n\tatomic_t\t\tin_idle;\n\n\tspinlock_t\t\ttask_lock;\n\tstruct io_wq_work_list\ttask_list;\n\tstruct io_wq_work_list\tprior_task_list;\n\tstruct callback_head\ttask_work;\n\tstruct file\t\t**registered_rings;\n\tbool\t\t\ttask_running;\n};\n\n/*\n * First field must be the file pointer in all the\n * iocb unions! See also 'struct kiocb' in <linux/fs.h>\n */\nstruct io_poll_iocb {\n\tstruct file\t\t\t*file;\n\tstruct wait_queue_head\t\t*head;\n\t__poll_t\t\t\tevents;\n\tstruct wait_queue_entry\t\twait;\n};\n\nstruct io_poll_update {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\told_user_data;\n\tu64\t\t\t\tnew_user_data;\n\t__poll_t\t\t\tevents;\n\tbool\t\t\t\tupdate_events;\n\tbool\t\t\t\tupdate_user_data;\n};\n\nstruct io_close {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tfd;\n\tu32\t\t\t\tfile_slot;\n};\n\nstruct io_timeout_data {\n\tstruct io_kiocb\t\t\t*req;\n\tstruct hrtimer\t\t\ttimer;\n\tstruct timespec64\t\tts;\n\tenum hrtimer_mode\t\tmode;\n\tu32\t\t\t\tflags;\n};\n\nstruct io_accept {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint __user\t\t\t*addr_len;\n\tint\t\t\t\tflags;\n\tu32\t\t\t\tfile_slot;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_sync {\n\tstruct file\t\t\t*file;\n\tloff_t\t\t\t\tlen;\n\tloff_t\t\t\t\toff;\n\tint\t\t\t\tflags;\n\tint\t\t\t\tmode;\n};\n\nstruct io_cancel {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n};\n\nstruct io_timeout {\n\tstruct file\t\t\t*file;\n\tu32\t\t\t\toff;\n\tu32\t\t\t\ttarget_seq;\n\tstruct list_head\t\tlist;\n\t/* head of the link, used by linked timeouts only */\n\tstruct io_kiocb\t\t\t*head;\n\t/* for linked completions */\n\tstruct io_kiocb\t\t\t*prev;\n};\n\nstruct io_timeout_rem {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n\n\t/* timeout update */\n\tstruct timespec64\t\tts;\n\tu32\t\t\t\tflags;\n\tbool\t\t\t\tltimeout;\n};\n\nstruct io_rw {\n\t/* NOTE: kiocb has the file as the first member, so don't do it here */\n\tstruct kiocb\t\t\tkiocb;\n\tu64\t\t\t\taddr;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tflags;\n};\n\nstruct io_connect {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint\t\t\t\taddr_len;\n};\n\nstruct io_sr_msg {\n\tstruct file\t\t\t*file;\n\tunion {\n\t\tstruct compat_msghdr __user\t*umsg_compat;\n\t\tstruct user_msghdr __user\t*umsg;\n\t\tvoid __user\t\t\t*buf;\n\t};\n\tint\t\t\t\tmsg_flags;\n\tint\t\t\t\tbgid;\n\tsize_t\t\t\t\tlen;\n\tsize_t\t\t\t\tdone_io;\n};\n\nstruct io_open {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tu32\t\t\t\tfile_slot;\n\tstruct filename\t\t\t*filename;\n\tstruct open_how\t\t\thow;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_rsrc_update {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\targ;\n\tu32\t\t\t\tnr_args;\n\tu32\t\t\t\toffset;\n};\n\nstruct io_fadvise {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\toffset;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tadvice;\n};\n\nstruct io_madvise {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tadvice;\n};\n\nstruct io_epoll {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tepfd;\n\tint\t\t\t\top;\n\tint\t\t\t\tfd;\n\tstruct epoll_event\t\tevent;\n};\n\nstruct io_splice {\n\tstruct file\t\t\t*file_out;\n\tloff_t\t\t\t\toff_out;\n\tloff_t\t\t\t\toff_in;\n\tu64\t\t\t\tlen;\n\tint\t\t\t\tsplice_fd_in;\n\tunsigned int\t\t\tflags;\n};\n\nstruct io_provide_buf {\n\tstruct file\t\t\t*file;\n\t__u64\t\t\t\taddr;\n\t__u32\t\t\t\tlen;\n\t__u32\t\t\t\tbgid;\n\t__u16\t\t\t\tnbufs;\n\t__u16\t\t\t\tbid;\n};\n\nstruct io_statx {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tunsigned int\t\t\tmask;\n\tunsigned int\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n\tstruct statx __user\t\t*buffer;\n};\n\nstruct io_shutdown {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\thow;\n};\n\nstruct io_rename {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nstruct io_unlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tint\t\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_mkdir {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tumode_t\t\t\t\tmode;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_symlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n};\n\nstruct io_hardlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tu64 user_data;\n\tu32 len;\n};\n\nstruct io_async_connect {\n\tstruct sockaddr_storage\t\taddress;\n};\n\nstruct io_async_msghdr {\n\tstruct iovec\t\t\tfast_iov[UIO_FASTIOV];\n\t/* points to an allocated iov, if NULL we use fast_iov instead */\n\tstruct iovec\t\t\t*free_iov;\n\tstruct sockaddr __user\t\t*uaddr;\n\tstruct msghdr\t\t\tmsg;\n\tstruct sockaddr_storage\t\taddr;\n};\n\nstruct io_rw_state {\n\tstruct iov_iter\t\t\titer;\n\tstruct iov_iter_state\t\titer_state;\n\tstruct iovec\t\t\tfast_iov[UIO_FASTIOV];\n};\n\nstruct io_async_rw {\n\tstruct io_rw_state\t\ts;\n\tconst struct iovec\t\t*free_iovec;\n\tsize_t\t\t\t\tbytes_done;\n\tstruct wait_page_queue\t\twpq;\n};\n\nenum {\n\tREQ_F_FIXED_FILE_BIT\t= IOSQE_FIXED_FILE_BIT,\n\tREQ_F_IO_DRAIN_BIT\t= IOSQE_IO_DRAIN_BIT,\n\tREQ_F_LINK_BIT\t\t= IOSQE_IO_LINK_BIT,\n\tREQ_F_HARDLINK_BIT\t= IOSQE_IO_HARDLINK_BIT,\n\tREQ_F_FORCE_ASYNC_BIT\t= IOSQE_ASYNC_BIT,\n\tREQ_F_BUFFER_SELECT_BIT\t= IOSQE_BUFFER_SELECT_BIT,\n\tREQ_F_CQE_SKIP_BIT\t= IOSQE_CQE_SKIP_SUCCESS_BIT,\n\n\t/* first byte is taken by user flags, shift it to not overlap */\n\tREQ_F_FAIL_BIT\t\t= 8,\n\tREQ_F_INFLIGHT_BIT,\n\tREQ_F_CUR_POS_BIT,\n\tREQ_F_NOWAIT_BIT,\n\tREQ_F_LINK_TIMEOUT_BIT,\n\tREQ_F_NEED_CLEANUP_BIT,\n\tREQ_F_POLLED_BIT,\n\tREQ_F_BUFFER_SELECTED_BIT,\n\tREQ_F_COMPLETE_INLINE_BIT,\n\tREQ_F_REISSUE_BIT,\n\tREQ_F_CREDS_BIT,\n\tREQ_F_REFCOUNT_BIT,\n\tREQ_F_ARM_LTIMEOUT_BIT,\n\tREQ_F_ASYNC_DATA_BIT,\n\tREQ_F_SKIP_LINK_CQES_BIT,\n\tREQ_F_SINGLE_POLL_BIT,\n\tREQ_F_DOUBLE_POLL_BIT,\n\tREQ_F_PARTIAL_IO_BIT,\n\t/* keep async read/write and isreg together and in order */\n\tREQ_F_SUPPORT_NOWAIT_BIT,\n\tREQ_F_ISREG_BIT,\n\n\t/* not a real bit, just to check we're not overflowing the space */\n\t__REQ_F_LAST_BIT,\n};\n\nenum {\n\t/* ctx owns file */\n\tREQ_F_FIXED_FILE\t= BIT(REQ_F_FIXED_FILE_BIT),\n\t/* drain existing IO first */\n\tREQ_F_IO_DRAIN\t\t= BIT(REQ_F_IO_DRAIN_BIT),\n\t/* linked sqes */\n\tREQ_F_LINK\t\t= BIT(REQ_F_LINK_BIT),\n\t/* doesn't sever on completion < 0 */\n\tREQ_F_HARDLINK\t\t= BIT(REQ_F_HARDLINK_BIT),\n\t/* IOSQE_ASYNC */\n\tREQ_F_FORCE_ASYNC\t= BIT(REQ_F_FORCE_ASYNC_BIT),\n\t/* IOSQE_BUFFER_SELECT */\n\tREQ_F_BUFFER_SELECT\t= BIT(REQ_F_BUFFER_SELECT_BIT),\n\t/* IOSQE_CQE_SKIP_SUCCESS */\n\tREQ_F_CQE_SKIP\t\t= BIT(REQ_F_CQE_SKIP_BIT),\n\n\t/* fail rest of links */\n\tREQ_F_FAIL\t\t= BIT(REQ_F_FAIL_BIT),\n\t/* on inflight list, should be cancelled and waited on exit reliably */\n\tREQ_F_INFLIGHT\t\t= BIT(REQ_F_INFLIGHT_BIT),\n\t/* read/write uses file position */\n\tREQ_F_CUR_POS\t\t= BIT(REQ_F_CUR_POS_BIT),\n\t/* must not punt to workers */\n\tREQ_F_NOWAIT\t\t= BIT(REQ_F_NOWAIT_BIT),\n\t/* has or had linked timeout */\n\tREQ_F_LINK_TIMEOUT\t= BIT(REQ_F_LINK_TIMEOUT_BIT),\n\t/* needs cleanup */\n\tREQ_F_NEED_CLEANUP\t= BIT(REQ_F_NEED_CLEANUP_BIT),\n\t/* already went through poll handler */\n\tREQ_F_POLLED\t\t= BIT(REQ_F_POLLED_BIT),\n\t/* buffer already selected */\n\tREQ_F_BUFFER_SELECTED\t= BIT(REQ_F_BUFFER_SELECTED_BIT),\n\t/* completion is deferred through io_comp_state */\n\tREQ_F_COMPLETE_INLINE\t= BIT(REQ_F_COMPLETE_INLINE_BIT),\n\t/* caller should reissue async */\n\tREQ_F_REISSUE\t\t= BIT(REQ_F_REISSUE_BIT),\n\t/* supports async reads/writes */\n\tREQ_F_SUPPORT_NOWAIT\t= BIT(REQ_F_SUPPORT_NOWAIT_BIT),\n\t/* regular file */\n\tREQ_F_ISREG\t\t= BIT(REQ_F_ISREG_BIT),\n\t/* has creds assigned */\n\tREQ_F_CREDS\t\t= BIT(REQ_F_CREDS_BIT),\n\t/* skip refcounting if not set */\n\tREQ_F_REFCOUNT\t\t= BIT(REQ_F_REFCOUNT_BIT),\n\t/* there is a linked timeout that has to be armed */\n\tREQ_F_ARM_LTIMEOUT\t= BIT(REQ_F_ARM_LTIMEOUT_BIT),\n\t/* ->async_data allocated */\n\tREQ_F_ASYNC_DATA\t= BIT(REQ_F_ASYNC_DATA_BIT),\n\t/* don't post CQEs while failing linked requests */\n\tREQ_F_SKIP_LINK_CQES\t= BIT(REQ_F_SKIP_LINK_CQES_BIT),\n\t/* single poll may be active */\n\tREQ_F_SINGLE_POLL\t= BIT(REQ_F_SINGLE_POLL_BIT),\n\t/* double poll may active */\n\tREQ_F_DOUBLE_POLL\t= BIT(REQ_F_DOUBLE_POLL_BIT),\n\t/* request has already done partial IO */\n\tREQ_F_PARTIAL_IO\t= BIT(REQ_F_PARTIAL_IO_BIT),\n};\n\nstruct async_poll {\n\tstruct io_poll_iocb\tpoll;\n\tstruct io_poll_iocb\t*double_poll;\n};\n\ntypedef void (*io_req_tw_func_t)(struct io_kiocb *req, bool *locked);\n\nstruct io_task_work {\n\tunion {\n\t\tstruct io_wq_work_node\tnode;\n\t\tstruct llist_node\tfallback_node;\n\t};\n\tio_req_tw_func_t\t\tfunc;\n};\n\nenum {\n\tIORING_RSRC_FILE\t\t= 0,\n\tIORING_RSRC_BUFFER\t\t= 1,\n};\n\n/*\n * NOTE! Each of the iocb union members has the file pointer\n * as the first entry in their struct definition. So you can\n * access the file pointer through any of the sub-structs,\n * or directly as just 'file' in this struct.\n */\nstruct io_kiocb {\n\tunion {\n\t\tstruct file\t\t*file;\n\t\tstruct io_rw\t\trw;\n\t\tstruct io_poll_iocb\tpoll;\n\t\tstruct io_poll_update\tpoll_update;\n\t\tstruct io_accept\taccept;\n\t\tstruct io_sync\t\tsync;\n\t\tstruct io_cancel\tcancel;\n\t\tstruct io_timeout\ttimeout;\n\t\tstruct io_timeout_rem\ttimeout_rem;\n\t\tstruct io_connect\tconnect;\n\t\tstruct io_sr_msg\tsr_msg;\n\t\tstruct io_open\t\topen;\n\t\tstruct io_close\t\tclose;\n\t\tstruct io_rsrc_update\trsrc_update;\n\t\tstruct io_fadvise\tfadvise;\n\t\tstruct io_madvise\tmadvise;\n\t\tstruct io_epoll\t\tepoll;\n\t\tstruct io_splice\tsplice;\n\t\tstruct io_provide_buf\tpbuf;\n\t\tstruct io_statx\t\tstatx;\n\t\tstruct io_shutdown\tshutdown;\n\t\tstruct io_rename\trename;\n\t\tstruct io_unlink\tunlink;\n\t\tstruct io_mkdir\t\tmkdir;\n\t\tstruct io_symlink\tsymlink;\n\t\tstruct io_hardlink\thardlink;\n\t\tstruct io_msg\t\tmsg;\n\t};\n\n\tu8\t\t\t\topcode;\n\t/* polled IO has completed */\n\tu8\t\t\t\tiopoll_completed;\n\tu16\t\t\t\tbuf_index;\n\tunsigned int\t\t\tflags;\n\n\tu64\t\t\t\tuser_data;\n\tu32\t\t\t\tresult;\n\tu32\t\t\t\tcflags;\n\n\tstruct io_ring_ctx\t\t*ctx;\n\tstruct task_struct\t\t*task;\n\n\tstruct percpu_ref\t\t*fixed_rsrc_refs;\n\t/* store used ubuf, so we can prevent reloading */\n\tstruct io_mapped_ubuf\t\t*imu;\n\n\t/* used by request caches, completion batching and iopoll */\n\tstruct io_wq_work_node\t\tcomp_list;\n\tatomic_t\t\t\trefs;\n\tatomic_t\t\t\tpoll_refs;\n\tstruct io_task_work\t\tio_task_work;\n\t/* for polled requests, i.e. IORING_OP_POLL_ADD and async armed poll */\n\tstruct hlist_node\t\thash_node;\n\t/* internal polling, see IORING_FEAT_FAST_POLL */\n\tstruct async_poll\t\t*apoll;\n\t/* opcode allocated if it needs to store data for async defer */\n\tvoid\t\t\t\t*async_data;\n\t/* stores selected buf, valid IFF REQ_F_BUFFER_SELECTED is set */\n\tstruct io_buffer\t\t*kbuf;\n\t/* linked requests, IFF REQ_F_HARDLINK or REQ_F_LINK are set */\n\tstruct io_kiocb\t\t\t*link;\n\t/* custom credentials, valid IFF REQ_F_CREDS is set */\n\tconst struct cred\t\t*creds;\n\tstruct io_wq_work\t\twork;\n};\n\nstruct io_tctx_node {\n\tstruct list_head\tctx_node;\n\tstruct task_struct\t*task;\n\tstruct io_ring_ctx\t*ctx;\n};\n\nstruct io_defer_entry {\n\tstruct list_head\tlist;\n\tstruct io_kiocb\t\t*req;\n\tu32\t\t\tseq;\n};\n\nstruct io_op_def {\n\t/* needs req->file assigned */\n\tunsigned\t\tneeds_file : 1;\n\t/* should block plug */\n\tunsigned\t\tplug : 1;\n\t/* hash wq insertion if file is a regular file */\n\tunsigned\t\thash_reg_file : 1;\n\t/* unbound wq insertion if file is a non-regular file */\n\tunsigned\t\tunbound_nonreg_file : 1;\n\t/* set if opcode supports polled \"wait\" */\n\tunsigned\t\tpollin : 1;\n\tunsigned\t\tpollout : 1;\n\tunsigned\t\tpoll_exclusive : 1;\n\t/* op supports buffer selection */\n\tunsigned\t\tbuffer_select : 1;\n\t/* do prep async if is going to be punted */\n\tunsigned\t\tneeds_async_setup : 1;\n\t/* opcode is not supported by this kernel */\n\tunsigned\t\tnot_supported : 1;\n\t/* skip auditing */\n\tunsigned\t\taudit_skip : 1;\n\t/* size of async data needed, if any */\n\tunsigned short\t\tasync_size;\n};\n\nstatic const struct io_op_def io_op_defs[] = {\n\t[IORING_OP_NOP] = {},\n\t[IORING_OP_READV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITEV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_FSYNC] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_READ_FIXED] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITE_FIXED] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_POLL_ADD] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_POLL_REMOVE] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SYNC_FILE_RANGE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SENDMSG] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_msghdr),\n\t},\n\t[IORING_OP_RECVMSG] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_msghdr),\n\t},\n\t[IORING_OP_TIMEOUT] = {\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_timeout_data),\n\t},\n\t[IORING_OP_TIMEOUT_REMOVE] = {\n\t\t/* used by timeout updates' prep() */\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_ACCEPT] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.poll_exclusive\t\t= 1,\n\t},\n\t[IORING_OP_ASYNC_CANCEL] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_LINK_TIMEOUT] = {\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_timeout_data),\n\t},\n\t[IORING_OP_CONNECT] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_connect),\n\t},\n\t[IORING_OP_FALLOCATE] = {\n\t\t.needs_file\t\t= 1,\n\t},\n\t[IORING_OP_OPENAT] = {},\n\t[IORING_OP_CLOSE] = {},\n\t[IORING_OP_FILES_UPDATE] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_STATX] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_READ] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_FADVISE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_MADVISE] = {},\n\t[IORING_OP_SEND] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_RECV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_OPENAT2] = {\n\t},\n\t[IORING_OP_EPOLL_CTL] = {\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SPLICE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_PROVIDE_BUFFERS] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_REMOVE_BUFFERS] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_TEE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SHUTDOWN] = {\n\t\t.needs_file\t\t= 1,\n\t},\n\t[IORING_OP_RENAMEAT] = {},\n\t[IORING_OP_UNLINKAT] = {},\n\t[IORING_OP_MKDIRAT] = {},\n\t[IORING_OP_SYMLINKAT] = {},\n\t[IORING_OP_LINKAT] = {},\n\t[IORING_OP_MSG_RING] = {\n\t\t.needs_file\t\t= 1,\n\t},\n};\n\n/* requests with any of those set should undergo io_disarm_next() */\n#define IO_DISARM_MASK (REQ_F_ARM_LTIMEOUT | REQ_F_LINK_TIMEOUT | REQ_F_FAIL)\n\nstatic bool io_disarm_next(struct io_kiocb *req);\nstatic void io_uring_del_tctx_node(unsigned long index);\nstatic void io_uring_try_cancel_requests(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct task_struct *task,\n\t\t\t\t\t bool cancel_all);\nstatic void io_uring_cancel_generic(bool cancel_all, struct io_sq_data *sqd);\n\nstatic void io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags);\n\nstatic void io_put_req(struct io_kiocb *req);\nstatic void io_put_req_deferred(struct io_kiocb *req);\nstatic void io_dismantle_req(struct io_kiocb *req);\nstatic void io_queue_linked_timeout(struct io_kiocb *req);\nstatic int __io_register_rsrc_update(struct io_ring_ctx *ctx, unsigned type,\n\t\t\t\t     struct io_uring_rsrc_update2 *up,\n\t\t\t\t     unsigned nr_args);\nstatic void io_clean_op(struct io_kiocb *req);\nstatic inline struct file *io_file_get_fixed(struct io_kiocb *req, int fd,\n\t\t\t\t\t     unsigned issue_flags);\nstatic inline struct file *io_file_get_normal(struct io_kiocb *req, int fd);\nstatic void io_drop_inflight_file(struct io_kiocb *req);\nstatic bool io_assign_file(struct io_kiocb *req, unsigned int issue_flags);\nstatic void __io_queue_sqe(struct io_kiocb *req);\nstatic void io_rsrc_put_work(struct work_struct *work);\n\nstatic void io_req_task_queue(struct io_kiocb *req);\nstatic void __io_submit_flush_completions(struct io_ring_ctx *ctx);\nstatic int io_req_prep_async(struct io_kiocb *req);\n\nstatic int io_install_fixed_file(struct io_kiocb *req, struct file *file,\n\t\t\t\t unsigned int issue_flags, u32 slot_index);\nstatic int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags);\n\nstatic enum hrtimer_restart io_link_timeout_fn(struct hrtimer *timer);\nstatic void io_eventfd_signal(struct io_ring_ctx *ctx);\n\nstatic struct kmem_cache *req_cachep;\n\nstatic const struct file_operations io_uring_fops;\n\nstruct sock *io_uring_get_socket(struct file *file)\n{\n#if defined(CONFIG_UNIX)\n\tif (file->f_op == &io_uring_fops) {\n\t\tstruct io_ring_ctx *ctx = file->private_data;\n\n\t\treturn ctx->ring_sock->sk;\n\t}\n#endif\n\treturn NULL;\n}\nEXPORT_SYMBOL(io_uring_get_socket);\n\nstatic inline void io_tw_lock(struct io_ring_ctx *ctx, bool *locked)\n{\n\tif (!*locked) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\t*locked = true;\n\t}\n}\n\n#define io_for_each_link(pos, head) \\\n\tfor (pos = (head); pos; pos = pos->link)\n\n/*\n * Shamelessly stolen from the mm implementation of page reference checking,\n * see commit f958d7b528b1 for details.\n */\n#define req_ref_zero_or_close_to_overflow(req)\t\\\n\t((unsigned int) atomic_read(&(req->refs)) + 127u <= 127u)\n\nstatic inline bool req_ref_inc_not_zero(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!(req->flags & REQ_F_REFCOUNT));\n\treturn atomic_inc_not_zero(&req->refs);\n}\n\nstatic inline bool req_ref_put_and_test(struct io_kiocb *req)\n{\n\tif (likely(!(req->flags & REQ_F_REFCOUNT)))\n\t\treturn true;\n\n\tWARN_ON_ONCE(req_ref_zero_or_close_to_overflow(req));\n\treturn atomic_dec_and_test(&req->refs);\n}\n\nstatic inline void req_ref_get(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!(req->flags & REQ_F_REFCOUNT));\n\tWARN_ON_ONCE(req_ref_zero_or_close_to_overflow(req));\n\tatomic_inc(&req->refs);\n}\n\nstatic inline void io_submit_flush_completions(struct io_ring_ctx *ctx)\n{\n\tif (!wq_list_empty(&ctx->submit_state.compl_reqs))\n\t\t__io_submit_flush_completions(ctx);\n}\n\nstatic inline void __io_req_set_refcount(struct io_kiocb *req, int nr)\n{\n\tif (!(req->flags & REQ_F_REFCOUNT)) {\n\t\treq->flags |= REQ_F_REFCOUNT;\n\t\tatomic_set(&req->refs, nr);\n\t}\n}\n\nstatic inline void io_req_set_refcount(struct io_kiocb *req)\n{\n\t__io_req_set_refcount(req, 1);\n}\n\n#define IO_RSRC_REF_BATCH\t100\n\nstatic inline void io_req_put_rsrc_locked(struct io_kiocb *req,\n\t\t\t\t\t  struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct percpu_ref *ref = req->fixed_rsrc_refs;\n\n\tif (ref) {\n\t\tif (ref == &ctx->rsrc_node->refs)\n\t\t\tctx->rsrc_cached_refs++;\n\t\telse\n\t\t\tpercpu_ref_put(ref);\n\t}\n}\n\nstatic inline void io_req_put_rsrc(struct io_kiocb *req, struct io_ring_ctx *ctx)\n{\n\tif (req->fixed_rsrc_refs)\n\t\tpercpu_ref_put(req->fixed_rsrc_refs);\n}\n\nstatic __cold void io_rsrc_refs_drop(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tif (ctx->rsrc_cached_refs) {\n\t\tpercpu_ref_put_many(&ctx->rsrc_node->refs, ctx->rsrc_cached_refs);\n\t\tctx->rsrc_cached_refs = 0;\n\t}\n}\n\nstatic void io_rsrc_refs_refill(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tctx->rsrc_cached_refs += IO_RSRC_REF_BATCH;\n\tpercpu_ref_get_many(&ctx->rsrc_node->refs, IO_RSRC_REF_BATCH);\n}\n\nstatic inline void io_req_set_rsrc_node(struct io_kiocb *req,\n\t\t\t\t\tstruct io_ring_ctx *ctx,\n\t\t\t\t\tunsigned int issue_flags)\n{\n\tif (!req->fixed_rsrc_refs) {\n\t\treq->fixed_rsrc_refs = &ctx->rsrc_node->refs;\n\n\t\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\t\tlockdep_assert_held(&ctx->uring_lock);\n\t\t\tctx->rsrc_cached_refs--;\n\t\t\tif (unlikely(ctx->rsrc_cached_refs < 0))\n\t\t\t\tio_rsrc_refs_refill(ctx);\n\t\t} else {\n\t\t\tpercpu_ref_get(req->fixed_rsrc_refs);\n\t\t}\n\t}\n}\n\nstatic unsigned int __io_put_kbuf(struct io_kiocb *req, struct list_head *list)\n{\n\tstruct io_buffer *kbuf = req->kbuf;\n\tunsigned int cflags;\n\n\tcflags = IORING_CQE_F_BUFFER | (kbuf->bid << IORING_CQE_BUFFER_SHIFT);\n\treq->flags &= ~REQ_F_BUFFER_SELECTED;\n\tlist_add(&kbuf->list, list);\n\treq->kbuf = NULL;\n\treturn cflags;\n}\n\nstatic inline unsigned int io_put_kbuf_comp(struct io_kiocb *req)\n{\n\tlockdep_assert_held(&req->ctx->completion_lock);\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn 0;\n\treturn __io_put_kbuf(req, &req->ctx->io_buffers_comp);\n}\n\nstatic inline unsigned int io_put_kbuf(struct io_kiocb *req,\n\t\t\t\t       unsigned issue_flags)\n{\n\tunsigned int cflags;\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn 0;\n\n\t/*\n\t * We can add this buffer back to two lists:\n\t *\n\t * 1) The io_buffers_cache list. This one is protected by the\n\t *    ctx->uring_lock. If we already hold this lock, add back to this\n\t *    list as we can grab it from issue as well.\n\t * 2) The io_buffers_comp list. This one is protected by the\n\t *    ctx->completion_lock.\n\t *\n\t * We migrate buffers from the comp_list to the issue cache list\n\t * when we need one.\n\t */\n\tif (issue_flags & IO_URING_F_UNLOCKED) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock(&ctx->completion_lock);\n\t\tcflags = __io_put_kbuf(req, &ctx->io_buffers_comp);\n\t\tspin_unlock(&ctx->completion_lock);\n\t} else {\n\t\tlockdep_assert_held(&req->ctx->uring_lock);\n\n\t\tcflags = __io_put_kbuf(req, &req->ctx->io_buffers_cache);\n\t}\n\n\treturn cflags;\n}\n\nstatic struct io_buffer_list *io_buffer_get_list(struct io_ring_ctx *ctx,\n\t\t\t\t\t\t unsigned int bgid)\n{\n\tstruct list_head *hash_list;\n\tstruct io_buffer_list *bl;\n\n\thash_list = &ctx->io_buffers[hash_32(bgid, IO_BUFFERS_HASH_BITS)];\n\tlist_for_each_entry(bl, hash_list, list)\n\t\tif (bl->bgid == bgid || bgid == -1U)\n\t\t\treturn bl;\n\n\treturn NULL;\n}\n\nstatic void io_kbuf_recycle(struct io_kiocb *req, unsigned issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tstruct io_buffer *buf;\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn;\n\t/* don't recycle if we already did IO to this buffer */\n\tif (req->flags & REQ_F_PARTIAL_IO)\n\t\treturn;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_lock(&ctx->uring_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbuf = req->kbuf;\n\tbl = io_buffer_get_list(ctx, buf->bgid);\n\tlist_add(&buf->list, &bl->buf_list);\n\treq->flags &= ~REQ_F_BUFFER_SELECTED;\n\treq->kbuf = NULL;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic bool io_match_task(struct io_kiocb *head, struct task_struct *task,\n\t\t\t  bool cancel_all)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tif (task && head->task != task)\n\t\treturn false;\n\treturn cancel_all;\n}\n\n/*\n * As io_match_task() but protected against racing with linked timeouts.\n * User must not hold timeout_lock.\n */\nstatic bool io_match_task_safe(struct io_kiocb *head, struct task_struct *task,\n\t\t\t       bool cancel_all)\n{\n\tif (task && head->task != task)\n\t\treturn false;\n\treturn cancel_all;\n}\n\nstatic inline bool req_has_async_data(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_ASYNC_DATA;\n}\n\nstatic inline void req_set_fail(struct io_kiocb *req)\n{\n\treq->flags |= REQ_F_FAIL;\n\tif (req->flags & REQ_F_CQE_SKIP) {\n\t\treq->flags &= ~REQ_F_CQE_SKIP;\n\t\treq->flags |= REQ_F_SKIP_LINK_CQES;\n\t}\n}\n\nstatic inline void req_fail_link_node(struct io_kiocb *req, int res)\n{\n\treq_set_fail(req);\n\treq->result = res;\n}\n\nstatic __cold void io_ring_ctx_ref_free(struct percpu_ref *ref)\n{\n\tstruct io_ring_ctx *ctx = container_of(ref, struct io_ring_ctx, refs);\n\n\tcomplete(&ctx->ref_comp);\n}\n\nstatic inline bool io_is_timeout_noseq(struct io_kiocb *req)\n{\n\treturn !req->timeout.off;\n}\n\nstatic __cold void io_fallback_req_func(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx,\n\t\t\t\t\t\tfallback_work.work);\n\tstruct llist_node *node = llist_del_all(&ctx->fallback_llist);\n\tstruct io_kiocb *req, *tmp;\n\tbool locked = false;\n\n\tpercpu_ref_get(&ctx->refs);\n\tllist_for_each_entry_safe(req, tmp, node, io_task_work.fallback_node)\n\t\treq->io_task_work.func(req, &locked);\n\n\tif (locked) {\n\t\tio_submit_flush_completions(ctx);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\tpercpu_ref_put(&ctx->refs);\n}\n\nstatic __cold struct io_ring_ctx *io_ring_ctx_alloc(struct io_uring_params *p)\n{\n\tstruct io_ring_ctx *ctx;\n\tint i, hash_bits;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\t/*\n\t * Use 5 bits less than the max cq entries, that should give us around\n\t * 32 entries per hash list if totally full and uniformly spread.\n\t */\n\thash_bits = ilog2(p->cq_entries);\n\thash_bits -= 5;\n\tif (hash_bits <= 0)\n\t\thash_bits = 1;\n\tctx->cancel_hash_bits = hash_bits;\n\tctx->cancel_hash = kmalloc((1U << hash_bits) * sizeof(struct hlist_head),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ctx->cancel_hash)\n\t\tgoto err;\n\t__hash_init(ctx->cancel_hash, 1U << hash_bits);\n\n\tctx->dummy_ubuf = kzalloc(sizeof(*ctx->dummy_ubuf), GFP_KERNEL);\n\tif (!ctx->dummy_ubuf)\n\t\tgoto err;\n\t/* set invalid range, so io_import_fixed() fails meeting it */\n\tctx->dummy_ubuf->ubuf = -1UL;\n\n\tctx->io_buffers = kcalloc(1U << IO_BUFFERS_HASH_BITS,\n\t\t\t\t\tsizeof(struct list_head), GFP_KERNEL);\n\tif (!ctx->io_buffers)\n\t\tgoto err;\n\tfor (i = 0; i < (1U << IO_BUFFERS_HASH_BITS); i++)\n\t\tINIT_LIST_HEAD(&ctx->io_buffers[i]);\n\n\tif (percpu_ref_init(&ctx->refs, io_ring_ctx_ref_free,\n\t\t\t    PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->flags = p->flags;\n\tinit_waitqueue_head(&ctx->sqo_sq_wait);\n\tINIT_LIST_HEAD(&ctx->sqd_list);\n\tINIT_LIST_HEAD(&ctx->cq_overflow_list);\n\tINIT_LIST_HEAD(&ctx->io_buffers_cache);\n\tINIT_LIST_HEAD(&ctx->apoll_cache);\n\tinit_completion(&ctx->ref_comp);\n\txa_init_flags(&ctx->personalities, XA_FLAGS_ALLOC1);\n\tmutex_init(&ctx->uring_lock);\n\tinit_waitqueue_head(&ctx->cq_wait);\n\tspin_lock_init(&ctx->completion_lock);\n\tspin_lock_init(&ctx->timeout_lock);\n\tINIT_WQ_LIST(&ctx->iopoll_list);\n\tINIT_LIST_HEAD(&ctx->io_buffers_pages);\n\tINIT_LIST_HEAD(&ctx->io_buffers_comp);\n\tINIT_LIST_HEAD(&ctx->defer_list);\n\tINIT_LIST_HEAD(&ctx->timeout_list);\n\tINIT_LIST_HEAD(&ctx->ltimeout_list);\n\tspin_lock_init(&ctx->rsrc_ref_lock);\n\tINIT_LIST_HEAD(&ctx->rsrc_ref_list);\n\tINIT_DELAYED_WORK(&ctx->rsrc_put_work, io_rsrc_put_work);\n\tinit_llist_head(&ctx->rsrc_put_llist);\n\tINIT_LIST_HEAD(&ctx->tctx_list);\n\tctx->submit_state.free_list.next = NULL;\n\tINIT_WQ_LIST(&ctx->locked_free_list);\n\tINIT_DELAYED_WORK(&ctx->fallback_work, io_fallback_req_func);\n\tINIT_WQ_LIST(&ctx->submit_state.compl_reqs);\n\treturn ctx;\nerr:\n\tkfree(ctx->dummy_ubuf);\n\tkfree(ctx->cancel_hash);\n\tkfree(ctx->io_buffers);\n\tkfree(ctx);\n\treturn NULL;\n}\n\nstatic void io_account_cq_overflow(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *r = ctx->rings;\n\n\tWRITE_ONCE(r->cq_overflow, READ_ONCE(r->cq_overflow) + 1);\n\tctx->cq_extra--;\n}\n\nstatic bool req_need_defer(struct io_kiocb *req, u32 seq)\n{\n\tif (unlikely(req->flags & REQ_F_IO_DRAIN)) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\treturn seq + READ_ONCE(ctx->cq_extra) != ctx->cached_cq_tail;\n\t}\n\n\treturn false;\n}\n\n#define FFS_NOWAIT\t\t0x1UL\n#define FFS_ISREG\t\t0x2UL\n#define FFS_MASK\t\t~(FFS_NOWAIT|FFS_ISREG)\n\nstatic inline bool io_req_ffs_set(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_FIXED_FILE;\n}\n\nstatic struct io_kiocb *__io_prep_linked_timeout(struct io_kiocb *req)\n{\n\tif (WARN_ON_ONCE(!req->link))\n\t\treturn NULL;\n\n\treq->flags &= ~REQ_F_ARM_LTIMEOUT;\n\treq->flags |= REQ_F_LINK_TIMEOUT;\n\n\t/* linked timeouts should have two refs once prep'ed */\n\tio_req_set_refcount(req);\n\t__io_req_set_refcount(req->link, 2);\n\treturn req->link;\n}\n\nstatic inline struct io_kiocb *io_prep_linked_timeout(struct io_kiocb *req)\n{\n\tif (likely(!(req->flags & REQ_F_ARM_LTIMEOUT)))\n\t\treturn NULL;\n\treturn __io_prep_linked_timeout(req);\n}\n\nstatic void io_prep_async_work(struct io_kiocb *req)\n{\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!(req->flags & REQ_F_CREDS)) {\n\t\treq->flags |= REQ_F_CREDS;\n\t\treq->creds = get_current_cred();\n\t}\n\n\treq->work.list.next = NULL;\n\treq->work.flags = 0;\n\tif (req->flags & REQ_F_FORCE_ASYNC)\n\t\treq->work.flags |= IO_WQ_WORK_CONCURRENT;\n\n\tif (req->flags & REQ_F_ISREG) {\n\t\tif (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n\t} else if (!req->file || !S_ISBLK(file_inode(req->file)->i_mode)) {\n\t\tif (def->unbound_nonreg_file)\n\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n\t}\n}\n\nstatic void io_prep_async_link(struct io_kiocb *req)\n{\n\tstruct io_kiocb *cur;\n\n\tif (req->flags & REQ_F_LINK_TIMEOUT) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tio_for_each_link(cur, req)\n\t\t\tio_prep_async_work(cur);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t} else {\n\t\tio_for_each_link(cur, req)\n\t\t\tio_prep_async_work(cur);\n\t}\n}\n\nstatic inline void io_req_add_compl_list(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\tctx->submit_state.flush_cqes = true;\n\twq_list_add_tail(&req->comp_list, &state->compl_reqs);\n}\n\nstatic void io_queue_async_work(struct io_kiocb *req, bool *dont_use)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *link = io_prep_linked_timeout(req);\n\tstruct io_uring_task *tctx = req->task->io_uring;\n\n\tBUG_ON(!tctx);\n\tBUG_ON(!tctx->io_wq);\n\n\t/* init ->work of the whole link before punting */\n\tio_prep_async_link(req);\n\n\t/*\n\t * Not expected to happen, but if we do have a bug where this _can_\n\t * happen, catch it here and ensure the request is marked as\n\t * canceled. That will make io-wq go through the usual work cancel\n\t * procedure rather than attempt to run this request (or create a new\n\t * worker for it).\n\t */\n\tif (WARN_ON_ONCE(!same_thread_group(req->task, current)))\n\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n\n\ttrace_io_uring_queue_async_work(ctx, req, req->user_data, req->opcode, req->flags,\n\t\t\t\t\t&req->work, io_wq_is_hashed(&req->work));\n\tio_wq_enqueue(tctx->io_wq, &req->work);\n\tif (link)\n\t\tio_queue_linked_timeout(link);\n}\n\nstatic void io_kill_timeout(struct io_kiocb *req, int status)\n\t__must_hold(&req->ctx->completion_lock)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io = req->async_data;\n\n\tif (hrtimer_try_to_cancel(&io->timer) != -1) {\n\t\tif (status)\n\t\t\treq_set_fail(req);\n\t\tatomic_set(&req->ctx->cq_timeouts,\n\t\t\tatomic_read(&req->ctx->cq_timeouts) + 1);\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_fill_cqe_req(req, status, 0);\n\t\tio_put_req_deferred(req);\n\t}\n}\n\nstatic __cold void io_queue_deferred(struct io_ring_ctx *ctx)\n{\n\twhile (!list_empty(&ctx->defer_list)) {\n\t\tstruct io_defer_entry *de = list_first_entry(&ctx->defer_list,\n\t\t\t\t\t\tstruct io_defer_entry, list);\n\n\t\tif (req_need_defer(de->req, de->seq))\n\t\t\tbreak;\n\t\tlist_del_init(&de->list);\n\t\tio_req_task_queue(de->req);\n\t\tkfree(de);\n\t}\n}\n\nstatic __cold void io_flush_timeouts(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since seq can easily wrap around over time, subtract\n\t\t * the last seq at which timeouts were flushed before comparing.\n\t\t * Assuming not more than 2^31-1 events have happened since,\n\t\t * these subtractions won't have wrapped, so we can check if\n\t\t * target is in [last_seq, current_seq] by comparing the two.\n\t\t */\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}\n\nstatic inline void io_commit_cqring(struct io_ring_ctx *ctx)\n{\n\t/* order cqe stores with ring update */\n\tsmp_store_release(&ctx->rings->cq.tail, ctx->cached_cq_tail);\n}\n\nstatic void __io_commit_cqring_flush(struct io_ring_ctx *ctx)\n{\n\tif (ctx->off_timeout_used || ctx->drain_active) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tif (ctx->off_timeout_used)\n\t\t\tio_flush_timeouts(ctx);\n\t\tif (ctx->drain_active)\n\t\t\tio_queue_deferred(ctx);\n\t\tio_commit_cqring(ctx);\n\t\tspin_unlock(&ctx->completion_lock);\n\t}\n\tif (ctx->has_evfd)\n\t\tio_eventfd_signal(ctx);\n}\n\nstatic inline bool io_sqring_full(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *r = ctx->rings;\n\n\treturn READ_ONCE(r->sq.tail) - ctx->cached_sq_head == ctx->sq_entries;\n}\n\nstatic inline unsigned int __io_cqring_events(struct io_ring_ctx *ctx)\n{\n\treturn ctx->cached_cq_tail - READ_ONCE(ctx->rings->cq.head);\n}\n\nstatic inline struct io_uring_cqe *io_get_cqe(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\tunsigned tail, mask = ctx->cq_entries - 1;\n\n\t/*\n\t * writes to the cq entry need to come after reading head; the\n\t * control dependency is enough as we're using WRITE_ONCE to\n\t * fill the cq entry\n\t */\n\tif (__io_cqring_events(ctx) == ctx->cq_entries)\n\t\treturn NULL;\n\n\ttail = ctx->cached_cq_tail++;\n\treturn &rings->cqes[tail & mask];\n}\n\nstatic void io_eventfd_signal(struct io_ring_ctx *ctx)\n{\n\tstruct io_ev_fd *ev_fd;\n\n\trcu_read_lock();\n\t/*\n\t * rcu_dereference ctx->io_ev_fd once and use it for both for checking\n\t * and eventfd_signal\n\t */\n\tev_fd = rcu_dereference(ctx->io_ev_fd);\n\n\t/*\n\t * Check again if ev_fd exists incase an io_eventfd_unregister call\n\t * completed between the NULL check of ctx->io_ev_fd at the start of\n\t * the function and rcu_read_lock.\n\t */\n\tif (unlikely(!ev_fd))\n\t\tgoto out;\n\tif (READ_ONCE(ctx->rings->cq_flags) & IORING_CQ_EVENTFD_DISABLED)\n\t\tgoto out;\n\n\tif (!ev_fd->eventfd_async || io_wq_current_is_worker())\n\t\teventfd_signal(ev_fd->cq_ev_fd, 1);\nout:\n\trcu_read_unlock();\n}\n\nstatic inline void io_cqring_wake(struct io_ring_ctx *ctx)\n{\n\t/*\n\t * wake_up_all() may seem excessive, but io_wake_function() and\n\t * io_should_wake() handle the termination of the loop and only\n\t * wake as many waiters as we need to.\n\t */\n\tif (wq_has_sleeper(&ctx->cq_wait))\n\t\twake_up_all(&ctx->cq_wait);\n}\n\n/*\n * This should only get called when at least one event has been posted.\n * Some applications rely on the eventfd notification count only changing\n * IFF a new CQE has been added to the CQ ring. There's no depedency on\n * 1:1 relationship between how many times this function is called (and\n * hence the eventfd count) and number of CQEs posted to the CQ ring.\n */\nstatic inline void io_cqring_ev_posted(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(ctx->off_timeout_used || ctx->drain_active ||\n\t\t     ctx->has_evfd))\n\t\t__io_commit_cqring_flush(ctx);\n\n\tio_cqring_wake(ctx);\n}\n\nstatic void io_cqring_ev_posted_iopoll(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(ctx->off_timeout_used || ctx->drain_active ||\n\t\t     ctx->has_evfd))\n\t\t__io_commit_cqring_flush(ctx);\n\n\tif (ctx->flags & IORING_SETUP_SQPOLL)\n\t\tio_cqring_wake(ctx);\n}\n\n/* Returns true if there are no backlogged entries after the flush */\nstatic bool __io_cqring_overflow_flush(struct io_ring_ctx *ctx, bool force)\n{\n\tbool all_flushed, posted;\n\n\tif (!force && __io_cqring_events(ctx) == ctx->cq_entries)\n\t\treturn false;\n\n\tposted = false;\n\tspin_lock(&ctx->completion_lock);\n\twhile (!list_empty(&ctx->cq_overflow_list)) {\n\t\tstruct io_uring_cqe *cqe = io_get_cqe(ctx);\n\t\tstruct io_overflow_cqe *ocqe;\n\n\t\tif (!cqe && !force)\n\t\t\tbreak;\n\t\tocqe = list_first_entry(&ctx->cq_overflow_list,\n\t\t\t\t\tstruct io_overflow_cqe, list);\n\t\tif (cqe)\n\t\t\tmemcpy(cqe, &ocqe->cqe, sizeof(*cqe));\n\t\telse\n\t\t\tio_account_cq_overflow(ctx);\n\n\t\tposted = true;\n\t\tlist_del(&ocqe->list);\n\t\tkfree(ocqe);\n\t}\n\n\tall_flushed = list_empty(&ctx->cq_overflow_list);\n\tif (all_flushed) {\n\t\tclear_bit(0, &ctx->check_cq_overflow);\n\t\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t\t   ctx->rings->sq_flags & ~IORING_SQ_CQ_OVERFLOW);\n\t}\n\n\tif (posted)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (posted)\n\t\tio_cqring_ev_posted(ctx);\n\treturn all_flushed;\n}\n\nstatic bool io_cqring_overflow_flush(struct io_ring_ctx *ctx)\n{\n\tbool ret = true;\n\n\tif (test_bit(0, &ctx->check_cq_overflow)) {\n\t\t/* iopoll syncs against uring_lock, not completion_lock */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\tret = __io_cqring_overflow_flush(ctx, false);\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\n\treturn ret;\n}\n\n/* must to be called somewhat shortly after putting a request */\nstatic inline void io_put_task(struct task_struct *task, int nr)\n{\n\tstruct io_uring_task *tctx = task->io_uring;\n\n\tif (likely(task == current)) {\n\t\ttctx->cached_refs += nr;\n\t} else {\n\t\tpercpu_counter_sub(&tctx->inflight, nr);\n\t\tif (unlikely(atomic_read(&tctx->in_idle)))\n\t\t\twake_up(&tctx->wait);\n\t\tput_task_struct_many(task, nr);\n\t}\n}\n\nstatic void io_task_refs_refill(struct io_uring_task *tctx)\n{\n\tunsigned int refill = -tctx->cached_refs + IO_TCTX_REFS_CACHE_NR;\n\n\tpercpu_counter_add(&tctx->inflight, refill);\n\trefcount_add(refill, &current->usage);\n\ttctx->cached_refs += refill;\n}\n\nstatic inline void io_get_task_refs(int nr)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\ttctx->cached_refs -= nr;\n\tif (unlikely(tctx->cached_refs < 0))\n\t\tio_task_refs_refill(tctx);\n}\n\nstatic __cold void io_uring_drop_tctx_refs(struct task_struct *task)\n{\n\tstruct io_uring_task *tctx = task->io_uring;\n\tunsigned int refs = tctx->cached_refs;\n\n\tif (refs) {\n\t\ttctx->cached_refs = 0;\n\t\tpercpu_counter_sub(&tctx->inflight, refs);\n\t\tput_task_struct_many(task, refs);\n\t}\n}\n\nstatic bool io_cqring_event_overflow(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tstruct io_overflow_cqe *ocqe;\n\n\tocqe = kmalloc(sizeof(*ocqe), GFP_ATOMIC | __GFP_ACCOUNT);\n\tif (!ocqe) {\n\t\t/*\n\t\t * If we're in ring overflow flush mode, or in task cancel mode,\n\t\t * or cannot allocate an overflow entry, then we need to drop it\n\t\t * on the floor.\n\t\t */\n\t\tio_account_cq_overflow(ctx);\n\t\treturn false;\n\t}\n\tif (list_empty(&ctx->cq_overflow_list)) {\n\t\tset_bit(0, &ctx->check_cq_overflow);\n\t\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t\t   ctx->rings->sq_flags | IORING_SQ_CQ_OVERFLOW);\n\n\t}\n\tocqe->cqe.user_data = user_data;\n\tocqe->cqe.res = res;\n\tocqe->cqe.flags = cflags;\n\tlist_add_tail(&ocqe->list, &ctx->cq_overflow_list);\n\treturn true;\n}\n\nstatic inline bool __io_fill_cqe(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t s32 res, u32 cflags)\n{\n\tstruct io_uring_cqe *cqe;\n\n\t/*\n\t * If we can't get a cq entry, userspace overflowed the\n\t * submission (by quite a lot). Increment the overflow count in\n\t * the ring.\n\t */\n\tcqe = io_get_cqe(ctx);\n\tif (likely(cqe)) {\n\t\tWRITE_ONCE(cqe->user_data, user_data);\n\t\tWRITE_ONCE(cqe->res, res);\n\t\tWRITE_ONCE(cqe->flags, cflags);\n\t\treturn true;\n\t}\n\treturn io_cqring_event_overflow(ctx, user_data, res, cflags);\n}\n\nstatic inline bool __io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags)\n{\n\ttrace_io_uring_complete(req->ctx, req, req->user_data, res, cflags);\n\treturn __io_fill_cqe(req->ctx, req->user_data, res, cflags);\n}\n\nstatic noinline void io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags)\n{\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t__io_fill_cqe_req(req, res, cflags);\n}\n\nstatic noinline bool io_fill_cqe_aux(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tctx->cq_extra++;\n\ttrace_io_uring_complete(ctx, NULL, user_data, res, cflags);\n\treturn __io_fill_cqe(ctx, user_data, res, cflags);\n}\n\nstatic void __io_req_complete_post(struct io_kiocb *req, s32 res,\n\t\t\t\t   u32 cflags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t__io_fill_cqe_req(req, res, cflags);\n\t/*\n\t * If we're the last reference to this request, add to our locked\n\t * free_list cache.\n\t */\n\tif (req_ref_put_and_test(req)) {\n\t\tif (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {\n\t\t\tif (req->flags & IO_DISARM_MASK)\n\t\t\t\tio_disarm_next(req);\n\t\t\tif (req->link) {\n\t\t\t\tio_req_task_queue(req->link);\n\t\t\t\treq->link = NULL;\n\t\t\t}\n\t\t}\n\t\tio_req_put_rsrc(req, ctx);\n\t\t/*\n\t\t * Selected buffer deallocation in io_clean_op() assumes that\n\t\t * we don't hold ->completion_lock. Clean them here to avoid\n\t\t * deadlocks.\n\t\t */\n\t\tio_put_kbuf_comp(req);\n\t\tio_dismantle_req(req);\n\t\tio_put_task(req->task, 1);\n\t\twq_list_add_head(&req->comp_list, &ctx->locked_free_list);\n\t\tctx->locked_free_nr++;\n\t}\n}\n\nstatic void io_req_complete_post(struct io_kiocb *req, s32 res,\n\t\t\t\t u32 cflags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tspin_lock(&ctx->completion_lock);\n\t__io_req_complete_post(req, res, cflags);\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic inline void io_req_complete_state(struct io_kiocb *req, s32 res,\n\t\t\t\t\t u32 cflags)\n{\n\treq->result = res;\n\treq->cflags = cflags;\n\treq->flags |= REQ_F_COMPLETE_INLINE;\n}\n\nstatic inline void __io_req_complete(struct io_kiocb *req, unsigned issue_flags,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tif (issue_flags & IO_URING_F_COMPLETE_DEFER)\n\t\tio_req_complete_state(req, res, cflags);\n\telse\n\t\tio_req_complete_post(req, res, cflags);\n}\n\nstatic inline void io_req_complete(struct io_kiocb *req, s32 res)\n{\n\t__io_req_complete(req, 0, res, 0);\n}\n\nstatic void io_req_complete_failed(struct io_kiocb *req, s32 res)\n{\n\treq_set_fail(req);\n\tio_req_complete_post(req, res, io_put_kbuf(req, IO_URING_F_UNLOCKED));\n}\n\nstatic void io_req_complete_fail_submit(struct io_kiocb *req)\n{\n\t/*\n\t * We don't submit, fail them all, for that replace hardlinks with\n\t * normal links. Extra REQ_F_LINK is tolerated.\n\t */\n\treq->flags &= ~REQ_F_HARDLINK;\n\treq->flags |= REQ_F_LINK;\n\tio_req_complete_failed(req, req->result);\n}\n\n/*\n * Don't initialise the fields below on every allocation, but do that in\n * advance and keep them valid across allocations.\n */\nstatic void io_preinit_req(struct io_kiocb *req, struct io_ring_ctx *ctx)\n{\n\treq->ctx = ctx;\n\treq->link = NULL;\n\treq->async_data = NULL;\n\t/* not necessary, but safer to zero */\n\treq->result = 0;\n}\n\nstatic void io_flush_cached_locked_reqs(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct io_submit_state *state)\n{\n\tspin_lock(&ctx->completion_lock);\n\twq_list_splice(&ctx->locked_free_list, &state->free_list);\n\tctx->locked_free_nr = 0;\n\tspin_unlock(&ctx->completion_lock);\n}\n\n/* Returns true IFF there are requests in the cache */\nstatic bool io_flush_cached_reqs(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\t/*\n\t * If we have more than a batch's worth of requests in our IRQ side\n\t * locked cache, grab the lock and move them over to our submission\n\t * side cache.\n\t */\n\tif (READ_ONCE(ctx->locked_free_nr) > IO_COMPL_BATCH)\n\t\tio_flush_cached_locked_reqs(ctx, state);\n\treturn !!state->free_list.next;\n}\n\n/*\n * A request might get retired back into the request caches even before opcode\n * handlers and io_issue_sqe() are done with it, e.g. inline completion path.\n * Because of that, io_alloc_req() should be called only under ->uring_lock\n * and with extra caution to not get a request that is still worked on.\n */\nstatic __cold bool __io_alloc_req_refill(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\n\tvoid *reqs[IO_REQ_ALLOC_BATCH];\n\tstruct io_kiocb *req;\n\tint ret, i;\n\n\tif (likely(state->free_list.next || io_flush_cached_reqs(ctx)))\n\t\treturn true;\n\n\tret = kmem_cache_alloc_bulk(req_cachep, gfp, ARRAY_SIZE(reqs), reqs);\n\n\t/*\n\t * Bulk alloc is all-or-nothing. If we fail to get a batch,\n\t * retry single alloc to be on the safe side.\n\t */\n\tif (unlikely(ret <= 0)) {\n\t\treqs[0] = kmem_cache_alloc(req_cachep, gfp);\n\t\tif (!reqs[0])\n\t\t\treturn false;\n\t\tret = 1;\n\t}\n\n\tpercpu_ref_get_many(&ctx->refs, ret);\n\tfor (i = 0; i < ret; i++) {\n\t\treq = reqs[i];\n\n\t\tio_preinit_req(req, ctx);\n\t\twq_stack_add_head(&req->comp_list, &state->free_list);\n\t}\n\treturn true;\n}\n\nstatic inline bool io_alloc_req_refill(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(!ctx->submit_state.free_list.next))\n\t\treturn __io_alloc_req_refill(ctx);\n\treturn true;\n}\n\nstatic inline struct io_kiocb *io_alloc_req(struct io_ring_ctx *ctx)\n{\n\tstruct io_wq_work_node *node;\n\n\tnode = wq_stack_extract(&ctx->submit_state.free_list);\n\treturn container_of(node, struct io_kiocb, comp_list);\n}\n\nstatic inline void io_put_file(struct file *file)\n{\n\tif (file)\n\t\tfput(file);\n}\n\nstatic inline void io_dismantle_req(struct io_kiocb *req)\n{\n\tunsigned int flags = req->flags;\n\n\tif (unlikely(flags & IO_REQ_CLEAN_FLAGS))\n\t\tio_clean_op(req);\n\tif (!(flags & REQ_F_FIXED_FILE))\n\t\tio_put_file(req->file);\n}\n\nstatic __cold void __io_free_req(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tio_req_put_rsrc(req, ctx);\n\tio_dismantle_req(req);\n\tio_put_task(req->task, 1);\n\n\tspin_lock(&ctx->completion_lock);\n\twq_list_add_head(&req->comp_list, &ctx->locked_free_list);\n\tctx->locked_free_nr++;\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic inline void io_remove_next_linked(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = req->link;\n\n\treq->link = nxt->link;\n\tnxt->link = NULL;\n}\n\nstatic bool io_kill_linked_timeout(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tstruct io_kiocb *link = req->link;\n\n\tif (link && link->opcode == IORING_OP_LINK_TIMEOUT) {\n\t\tstruct io_timeout_data *io = link->async_data;\n\n\t\tio_remove_next_linked(req);\n\t\tlink->timeout.head = NULL;\n\t\tif (hrtimer_try_to_cancel(&io->timer) != -1) {\n\t\t\tlist_del(&link->timeout.list);\n\t\t\t/* leave REQ_F_CQE_SKIP to io_fill_cqe_req */\n\t\t\tio_fill_cqe_req(link, -ECANCELED, 0);\n\t\t\tio_put_req_deferred(link);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void io_fail_links(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n{\n\tstruct io_kiocb *nxt, *link = req->link;\n\tbool ignore_cqes = req->flags & REQ_F_SKIP_LINK_CQES;\n\n\treq->link = NULL;\n\twhile (link) {\n\t\tlong res = -ECANCELED;\n\n\t\tif (link->flags & REQ_F_FAIL)\n\t\t\tres = link->result;\n\n\t\tnxt = link->link;\n\t\tlink->link = NULL;\n\n\t\ttrace_io_uring_fail_link(req->ctx, req, req->user_data,\n\t\t\t\t\treq->opcode, link);\n\n\t\tif (!ignore_cqes) {\n\t\t\tlink->flags &= ~REQ_F_CQE_SKIP;\n\t\t\tio_fill_cqe_req(link, res, 0);\n\t\t}\n\t\tio_put_req_deferred(link);\n\t\tlink = nxt;\n\t}\n}\n\nstatic bool io_disarm_next(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n{\n\tbool posted = false;\n\n\tif (req->flags & REQ_F_ARM_LTIMEOUT) {\n\t\tstruct io_kiocb *link = req->link;\n\n\t\treq->flags &= ~REQ_F_ARM_LTIMEOUT;\n\t\tif (link && link->opcode == IORING_OP_LINK_TIMEOUT) {\n\t\t\tio_remove_next_linked(req);\n\t\t\t/* leave REQ_F_CQE_SKIP to io_fill_cqe_req */\n\t\t\tio_fill_cqe_req(link, -ECANCELED, 0);\n\t\t\tio_put_req_deferred(link);\n\t\t\tposted = true;\n\t\t}\n\t} else if (req->flags & REQ_F_LINK_TIMEOUT) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tposted = io_kill_linked_timeout(req);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t}\n\tif (unlikely((req->flags & REQ_F_FAIL) &&\n\t\t     !(req->flags & REQ_F_HARDLINK))) {\n\t\tposted |= (req->link != NULL);\n\t\tio_fail_links(req);\n\t}\n\treturn posted;\n}\n\nstatic void __io_req_find_next_prep(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool posted;\n\n\tspin_lock(&ctx->completion_lock);\n\tposted = io_disarm_next(req);\n\tif (posted)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (posted)\n\t\tio_cqring_ev_posted(ctx);\n}\n\nstatic inline struct io_kiocb *io_req_find_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt;\n\n\tif (likely(!(req->flags & (REQ_F_LINK|REQ_F_HARDLINK))))\n\t\treturn NULL;\n\t/*\n\t * If LINK is set, we have dependent requests in this chain. If we\n\t * didn't fail this request, queue the first one up, moving any other\n\t * dependencies to the next request. In case of failure, fail the rest\n\t * of the chain.\n\t */\n\tif (unlikely(req->flags & IO_DISARM_MASK))\n\t\t__io_req_find_next_prep(req);\n\tnxt = req->link;\n\treq->link = NULL;\n\treturn nxt;\n}\n\nstatic void ctx_flush_and_put(struct io_ring_ctx *ctx, bool *locked)\n{\n\tif (!ctx)\n\t\treturn;\n\tif (*locked) {\n\t\tio_submit_flush_completions(ctx);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\t*locked = false;\n\t}\n\tpercpu_ref_put(&ctx->refs);\n}\n\nstatic inline void ctx_commit_and_unlock(struct io_ring_ctx *ctx)\n{\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic void handle_prev_tw_list(struct io_wq_work_node *node,\n\t\t\t\tstruct io_ring_ctx **ctx, bool *uring_locked)\n{\n\tif (*ctx && !*uring_locked)\n\t\tspin_lock(&(*ctx)->completion_lock);\n\n\tdo {\n\t\tstruct io_wq_work_node *next = node->next;\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    io_task_work.node);\n\n\t\tprefetch(container_of(next, struct io_kiocb, io_task_work.node));\n\n\t\tif (req->ctx != *ctx) {\n\t\t\tif (unlikely(!*uring_locked && *ctx))\n\t\t\t\tctx_commit_and_unlock(*ctx);\n\n\t\t\tctx_flush_and_put(*ctx, uring_locked);\n\t\t\t*ctx = req->ctx;\n\t\t\t/* if not contended, grab and improve batching */\n\t\t\t*uring_locked = mutex_trylock(&(*ctx)->uring_lock);\n\t\t\tpercpu_ref_get(&(*ctx)->refs);\n\t\t\tif (unlikely(!*uring_locked))\n\t\t\t\tspin_lock(&(*ctx)->completion_lock);\n\t\t}\n\t\tif (likely(*uring_locked))\n\t\t\treq->io_task_work.func(req, uring_locked);\n\t\telse\n\t\t\t__io_req_complete_post(req, req->result,\n\t\t\t\t\t\tio_put_kbuf_comp(req));\n\t\tnode = next;\n\t} while (node);\n\n\tif (unlikely(!*uring_locked))\n\t\tctx_commit_and_unlock(*ctx);\n}\n\nstatic void handle_tw_list(struct io_wq_work_node *node,\n\t\t\t   struct io_ring_ctx **ctx, bool *locked)\n{\n\tdo {\n\t\tstruct io_wq_work_node *next = node->next;\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    io_task_work.node);\n\n\t\tprefetch(container_of(next, struct io_kiocb, io_task_work.node));\n\n\t\tif (req->ctx != *ctx) {\n\t\t\tctx_flush_and_put(*ctx, locked);\n\t\t\t*ctx = req->ctx;\n\t\t\t/* if not contended, grab and improve batching */\n\t\t\t*locked = mutex_trylock(&(*ctx)->uring_lock);\n\t\t\tpercpu_ref_get(&(*ctx)->refs);\n\t\t}\n\t\treq->io_task_work.func(req, locked);\n\t\tnode = next;\n\t} while (node);\n}\n\nstatic void tctx_task_work(struct callback_head *cb)\n{\n\tbool uring_locked = false;\n\tstruct io_ring_ctx *ctx = NULL;\n\tstruct io_uring_task *tctx = container_of(cb, struct io_uring_task,\n\t\t\t\t\t\t  task_work);\n\n\twhile (1) {\n\t\tstruct io_wq_work_node *node1, *node2;\n\n\t\tif (!tctx->task_list.first &&\n\t\t    !tctx->prior_task_list.first && uring_locked)\n\t\t\tio_submit_flush_completions(ctx);\n\n\t\tspin_lock_irq(&tctx->task_lock);\n\t\tnode1 = tctx->prior_task_list.first;\n\t\tnode2 = tctx->task_list.first;\n\t\tINIT_WQ_LIST(&tctx->task_list);\n\t\tINIT_WQ_LIST(&tctx->prior_task_list);\n\t\tif (!node2 && !node1)\n\t\t\ttctx->task_running = false;\n\t\tspin_unlock_irq(&tctx->task_lock);\n\t\tif (!node2 && !node1)\n\t\t\tbreak;\n\n\t\tif (node1)\n\t\t\thandle_prev_tw_list(node1, &ctx, &uring_locked);\n\n\t\tif (node2)\n\t\t\thandle_tw_list(node2, &ctx, &uring_locked);\n\t\tcond_resched();\n\t}\n\n\tctx_flush_and_put(ctx, &uring_locked);\n\n\t/* relaxed read is enough as only the task itself sets ->in_idle */\n\tif (unlikely(atomic_read(&tctx->in_idle)))\n\t\tio_uring_drop_tctx_refs(current);\n}\n\nstatic void io_req_task_work_add(struct io_kiocb *req, bool priority)\n{\n\tstruct task_struct *tsk = req->task;\n\tstruct io_uring_task *tctx = tsk->io_uring;\n\tenum task_work_notify_mode notify;\n\tstruct io_wq_work_node *node;\n\tunsigned long flags;\n\tbool running;\n\n\tWARN_ON_ONCE(!tctx);\n\n\tio_drop_inflight_file(req);\n\n\tspin_lock_irqsave(&tctx->task_lock, flags);\n\tif (priority)\n\t\twq_list_add_tail(&req->io_task_work.node, &tctx->prior_task_list);\n\telse\n\t\twq_list_add_tail(&req->io_task_work.node, &tctx->task_list);\n\trunning = tctx->task_running;\n\tif (!running)\n\t\ttctx->task_running = true;\n\tspin_unlock_irqrestore(&tctx->task_lock, flags);\n\n\t/* task_work already pending, we're done */\n\tif (running)\n\t\treturn;\n\n\t/*\n\t * SQPOLL kernel thread doesn't need notification, just a wakeup. For\n\t * all other cases, use TWA_SIGNAL unconditionally to ensure we're\n\t * processing task_work. There's no reliable way to tell if TWA_RESUME\n\t * will do the job.\n\t */\n\tnotify = (req->ctx->flags & IORING_SETUP_SQPOLL) ? TWA_NONE : TWA_SIGNAL;\n\tif (likely(!task_work_add(tsk, &tctx->task_work, notify))) {\n\t\tif (notify == TWA_NONE)\n\t\t\twake_up_process(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&tctx->task_lock, flags);\n\ttctx->task_running = false;\n\tnode = wq_list_merge(&tctx->prior_task_list, &tctx->task_list);\n\tspin_unlock_irqrestore(&tctx->task_lock, flags);\n\n\twhile (node) {\n\t\treq = container_of(node, struct io_kiocb, io_task_work.node);\n\t\tnode = node->next;\n\t\tif (llist_add(&req->io_task_work.fallback_node,\n\t\t\t      &req->ctx->fallback_llist))\n\t\t\tschedule_delayed_work(&req->ctx->fallback_work, 1);\n\t}\n}\n\nstatic void io_req_task_cancel(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t/* not needed for normal modes, but SQPOLL depends on it */\n\tio_tw_lock(ctx, locked);\n\tio_req_complete_failed(req, req->result);\n}\n\nstatic void io_req_task_submit(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tio_tw_lock(ctx, locked);\n\t/* req->task == current here, checking PF_EXITING is safe */\n\tif (likely(!(req->task->flags & PF_EXITING)))\n\t\t__io_queue_sqe(req);\n\telse\n\t\tio_req_complete_failed(req, -EFAULT);\n}\n\nstatic void io_req_task_queue_fail(struct io_kiocb *req, int ret)\n{\n\treq->result = ret;\n\treq->io_task_work.func = io_req_task_cancel;\n\tio_req_task_work_add(req, false);\n}\n\nstatic void io_req_task_queue(struct io_kiocb *req)\n{\n\treq->io_task_work.func = io_req_task_submit;\n\tio_req_task_work_add(req, false);\n}\n\nstatic void io_req_task_queue_reissue(struct io_kiocb *req)\n{\n\treq->io_task_work.func = io_queue_async_work;\n\tio_req_task_work_add(req, false);\n}\n\nstatic inline void io_queue_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = io_req_find_next(req);\n\n\tif (nxt)\n\t\tio_req_task_queue(nxt);\n}\n\nstatic void io_free_req(struct io_kiocb *req)\n{\n\tio_queue_next(req);\n\t__io_free_req(req);\n}\n\nstatic void io_free_req_work(struct io_kiocb *req, bool *locked)\n{\n\tio_free_req(req);\n}\n\nstatic void io_free_batch_list(struct io_ring_ctx *ctx,\n\t\t\t\tstruct io_wq_work_node *node)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct task_struct *task = NULL;\n\tint task_refs = 0;\n\n\tdo {\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    comp_list);\n\n\t\tif (unlikely(req->flags & REQ_F_REFCOUNT)) {\n\t\t\tnode = req->comp_list.next;\n\t\t\tif (!req_ref_put_and_test(req))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tio_req_put_rsrc_locked(req, ctx);\n\t\tio_queue_next(req);\n\t\tio_dismantle_req(req);\n\n\t\tif (req->task != task) {\n\t\t\tif (task)\n\t\t\t\tio_put_task(task, task_refs);\n\t\t\ttask = req->task;\n\t\t\ttask_refs = 0;\n\t\t}\n\t\ttask_refs++;\n\t\tnode = req->comp_list.next;\n\t\twq_stack_add_head(&req->comp_list, &ctx->submit_state.free_list);\n\t} while (node);\n\n\tif (task)\n\t\tio_put_task(task, task_refs);\n}\n\nstatic void __io_submit_flush_completions(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_wq_work_node *node, *prev;\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (state->flush_cqes) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\twq_list_for_each(node, prev, &state->compl_reqs) {\n\t\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    comp_list);\n\n\t\t\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t\t\t__io_fill_cqe_req(req, req->result, req->cflags);\n\t\t\tif ((req->flags & REQ_F_POLLED) && req->apoll) {\n\t\t\t\tstruct async_poll *apoll = req->apoll;\n\n\t\t\t\tif (apoll->double_poll)\n\t\t\t\t\tkfree(apoll->double_poll);\n\t\t\t\tlist_add(&apoll->poll.wait.entry,\n\t\t\t\t\t\t&ctx->apoll_cache);\n\t\t\t\treq->flags &= ~REQ_F_POLLED;\n\t\t\t}\n\t\t}\n\n\t\tio_commit_cqring(ctx);\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tio_cqring_ev_posted(ctx);\n\t\tstate->flush_cqes = false;\n\t}\n\n\tio_free_batch_list(ctx, state->compl_reqs.first);\n\tINIT_WQ_LIST(&state->compl_reqs);\n}\n\n/*\n * Drop reference to request, return next in chain (if there is one) if this\n * was the last reference to this request.\n */\nstatic inline struct io_kiocb *io_put_req_find_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = NULL;\n\n\tif (req_ref_put_and_test(req)) {\n\t\tnxt = io_req_find_next(req);\n\t\t__io_free_req(req);\n\t}\n\treturn nxt;\n}\n\nstatic inline void io_put_req(struct io_kiocb *req)\n{\n\tif (req_ref_put_and_test(req))\n\t\tio_free_req(req);\n}\n\nstatic inline void io_put_req_deferred(struct io_kiocb *req)\n{\n\tif (req_ref_put_and_test(req)) {\n\t\treq->io_task_work.func = io_free_req_work;\n\t\tio_req_task_work_add(req, false);\n\t}\n}\n\nstatic unsigned io_cqring_events(struct io_ring_ctx *ctx)\n{\n\t/* See comment at the top of this file */\n\tsmp_rmb();\n\treturn __io_cqring_events(ctx);\n}\n\nstatic inline unsigned int io_sqring_entries(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\n\t/* make sure SQ entry isn't read before tail */\n\treturn smp_load_acquire(&rings->sq.tail) - ctx->cached_sq_head;\n}\n\nstatic inline bool io_run_task_work(void)\n{\n\tif (test_thread_flag(TIF_NOTIFY_SIGNAL) || task_work_pending(current)) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tclear_notify_signal();\n\t\tif (task_work_pending(current))\n\t\t\ttask_work_run();\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int io_do_iopoll(struct io_ring_ctx *ctx, bool force_nonspin)\n{\n\tstruct io_wq_work_node *pos, *start, *prev;\n\tunsigned int poll_flags = BLK_POLL_NOSLEEP;\n\tDEFINE_IO_COMP_BATCH(iob);\n\tint nr_events = 0;\n\n\t/*\n\t * Only spin for completions if we don't have multiple devices hanging\n\t * off our complete list.\n\t */\n\tif (ctx->poll_multi_queue || force_nonspin)\n\t\tpoll_flags |= BLK_POLL_ONESHOT;\n\n\twq_list_for_each(pos, start, &ctx->iopoll_list) {\n\t\tstruct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list);\n\t\tstruct kiocb *kiocb = &req->rw.kiocb;\n\t\tint ret;\n\n\t\t/*\n\t\t * Move completed and retryable entries to our local lists.\n\t\t * If we find a request that requires polling, break out\n\t\t * and complete those lists first, if we have entries there.\n\t\t */\n\t\tif (READ_ONCE(req->iopoll_completed))\n\t\t\tbreak;\n\n\t\tret = kiocb->ki_filp->f_op->iopoll(kiocb, &iob, poll_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tpoll_flags |= BLK_POLL_ONESHOT;\n\n\t\t/* iopoll may have completed current req */\n\t\tif (!rq_list_empty(iob.req_list) ||\n\t\t    READ_ONCE(req->iopoll_completed))\n\t\t\tbreak;\n\t}\n\n\tif (!rq_list_empty(iob.req_list))\n\t\tiob.complete(&iob);\n\telse if (!pos)\n\t\treturn 0;\n\n\tprev = start;\n\twq_list_for_each_resume(pos, prev) {\n\t\tstruct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list);\n\n\t\t/* order with io_complete_rw_iopoll(), e.g. ->result updates */\n\t\tif (!smp_load_acquire(&req->iopoll_completed))\n\t\t\tbreak;\n\t\tif (unlikely(req->flags & REQ_F_CQE_SKIP))\n\t\t\tcontinue;\n\n\t\t__io_fill_cqe_req(req, req->result, io_put_kbuf(req, 0));\n\t\tnr_events++;\n\t}\n\n\tif (unlikely(!nr_events))\n\t\treturn 0;\n\n\tio_commit_cqring(ctx);\n\tio_cqring_ev_posted_iopoll(ctx);\n\tpos = start ? start->next : ctx->iopoll_list.first;\n\twq_list_cut(&ctx->iopoll_list, prev, start);\n\tio_free_batch_list(ctx, pos);\n\treturn nr_events;\n}\n\n/*\n * We can't just wait for polled events to come to us, we have to actively\n * find and complete them.\n */\nstatic __cold void io_iopoll_try_reap_events(struct io_ring_ctx *ctx)\n{\n\tif (!(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn;\n\n\tmutex_lock(&ctx->uring_lock);\n\twhile (!wq_list_empty(&ctx->iopoll_list)) {\n\t\t/* let it sleep and repeat later if can't complete a request */\n\t\tif (io_do_iopoll(ctx, true) == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Ensure we allow local-to-the-cpu processing to take place,\n\t\t * in this case we need to ensure that we reap all events.\n\t\t * Also let task_work, etc. to progress by releasing the mutex\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tcond_resched();\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t}\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic int io_iopoll_check(struct io_ring_ctx *ctx, long min)\n{\n\tunsigned int nr_events = 0;\n\tint ret = 0;\n\n\t/*\n\t * We disallow the app entering submit/complete with polling, but we\n\t * still need to lock the ring to prevent racing with polled issue\n\t * that got punted to a workqueue.\n\t */\n\tmutex_lock(&ctx->uring_lock);\n\t/*\n\t * Don't enter poll loop if we already have events pending.\n\t * If we do, we can potentially be spinning for commands that\n\t * already triggered a CQE (eg in error).\n\t */\n\tif (test_bit(0, &ctx->check_cq_overflow))\n\t\t__io_cqring_overflow_flush(ctx, false);\n\tif (io_cqring_events(ctx))\n\t\tgoto out;\n\tdo {\n\t\t/*\n\t\t * If a submit got punted to a workqueue, we can have the\n\t\t * application entering polling for a command before it gets\n\t\t * issued. That app will hold the uring_lock for the duration\n\t\t * of the poll right here, so we need to take a breather every\n\t\t * now and then to ensure that the issue has a chance to add\n\t\t * the poll to the issued list. Otherwise we can spin here\n\t\t * forever, while the workqueue is stuck trying to acquire the\n\t\t * very same mutex.\n\t\t */\n\t\tif (wq_list_empty(&ctx->iopoll_list)) {\n\t\t\tu32 tail = ctx->cached_cq_tail;\n\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tio_run_task_work();\n\t\t\tmutex_lock(&ctx->uring_lock);\n\n\t\t\t/* some requests don't go through iopoll_list */\n\t\t\tif (tail != ctx->cached_cq_tail ||\n\t\t\t    wq_list_empty(&ctx->iopoll_list))\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_do_iopoll(ctx, !min);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tnr_events += ret;\n\t\tret = 0;\n\t} while (nr_events < min && !need_resched());\nout:\n\tmutex_unlock(&ctx->uring_lock);\n\treturn ret;\n}\n\nstatic void kiocb_end_write(struct io_kiocb *req)\n{\n\t/*\n\t * Tell lockdep we inherited freeze protection from submission\n\t * thread.\n\t */\n\tif (req->flags & REQ_F_ISREG) {\n\t\tstruct super_block *sb = file_inode(req->file)->i_sb;\n\n\t\t__sb_writers_acquired(sb, SB_FREEZE_WRITE);\n\t\tsb_end_write(sb);\n\t}\n}\n\n#ifdef CONFIG_BLOCK\nstatic bool io_resubmit_prep(struct io_kiocb *req)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\n\tif (!req_has_async_data(req))\n\t\treturn !io_req_prep_async(req);\n\tiov_iter_restore(&rw->s.iter, &rw->s.iter_state);\n\treturn true;\n}\n\nstatic bool io_rw_should_reissue(struct io_kiocb *req)\n{\n\tumode_t mode = file_inode(req->file)->i_mode;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!S_ISBLK(mode) && !S_ISREG(mode))\n\t\treturn false;\n\tif ((req->flags & REQ_F_NOWAIT) || (io_wq_current_is_worker() &&\n\t    !(ctx->flags & IORING_SETUP_IOPOLL)))\n\t\treturn false;\n\t/*\n\t * If ref is dying, we might be running poll reap from the exit work.\n\t * Don't attempt to reissue from that path, just let it fail with\n\t * -EAGAIN.\n\t */\n\tif (percpu_ref_is_dying(&ctx->refs))\n\t\treturn false;\n\t/*\n\t * Play it safe and assume not safe to re-import and reissue if we're\n\t * not in the original thread group (or in task context).\n\t */\n\tif (!same_thread_group(req->task, current) || !in_task())\n\t\treturn false;\n\treturn true;\n}\n#else\nstatic bool io_resubmit_prep(struct io_kiocb *req)\n{\n\treturn false;\n}\nstatic bool io_rw_should_reissue(struct io_kiocb *req)\n{\n\treturn false;\n}\n#endif\n\nstatic bool __io_complete_rw_common(struct io_kiocb *req, long res)\n{\n\tif (req->rw.kiocb.ki_flags & IOCB_WRITE) {\n\t\tkiocb_end_write(req);\n\t\tfsnotify_modify(req->file);\n\t} else {\n\t\tfsnotify_access(req->file);\n\t}\n\tif (unlikely(res != req->result)) {\n\t\tif ((res == -EAGAIN || res == -EOPNOTSUPP) &&\n\t\t    io_rw_should_reissue(req)) {\n\t\t\treq->flags |= REQ_F_REISSUE;\n\t\t\treturn true;\n\t\t}\n\t\treq_set_fail(req);\n\t\treq->result = res;\n\t}\n\treturn false;\n}\n\nstatic inline void io_req_task_complete(struct io_kiocb *req, bool *locked)\n{\n\tint res = req->result;\n\n\tif (*locked) {\n\t\tio_req_complete_state(req, res, io_put_kbuf(req, 0));\n\t\tio_req_add_compl_list(req);\n\t} else {\n\t\tio_req_complete_post(req, res,\n\t\t\t\t\tio_put_kbuf(req, IO_URING_F_UNLOCKED));\n\t}\n}\n\nstatic void __io_complete_rw(struct io_kiocb *req, long res,\n\t\t\t     unsigned int issue_flags)\n{\n\tif (__io_complete_rw_common(req, res))\n\t\treturn;\n\t__io_req_complete(req, issue_flags, req->result,\n\t\t\t\tio_put_kbuf(req, issue_flags));\n}\n\nstatic void io_complete_rw(struct kiocb *kiocb, long res)\n{\n\tstruct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);\n\n\tif (__io_complete_rw_common(req, res))\n\t\treturn;\n\treq->result = res;\n\treq->io_task_work.func = io_req_task_complete;\n\tio_req_task_work_add(req, !!(req->ctx->flags & IORING_SETUP_SQPOLL));\n}\n\nstatic void io_complete_rw_iopoll(struct kiocb *kiocb, long res)\n{\n\tstruct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE)\n\t\tkiocb_end_write(req);\n\tif (unlikely(res != req->result)) {\n\t\tif (res == -EAGAIN && io_rw_should_reissue(req)) {\n\t\t\treq->flags |= REQ_F_REISSUE;\n\t\t\treturn;\n\t\t}\n\t\treq->result = res;\n\t}\n\n\t/* order with io_iopoll_complete() checking ->iopoll_completed */\n\tsmp_store_release(&req->iopoll_completed, 1);\n}\n\n/*\n * After the iocb has been issued, it's safe to be found on the poll list.\n * Adding the kiocb to the list AFTER submission ensures that we don't\n * find it from a io_do_iopoll() thread before the issuer is done\n * accessing the kiocb cookie.\n */\nstatic void io_iopoll_req_issued(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tconst bool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\t/* workqueue context doesn't hold uring_lock, grab it now */\n\tif (unlikely(needs_lock))\n\t\tmutex_lock(&ctx->uring_lock);\n\n\t/*\n\t * Track whether we have multiple files in our lists. This will impact\n\t * how we do polling eventually, not spinning if we're on potentially\n\t * different devices.\n\t */\n\tif (wq_list_empty(&ctx->iopoll_list)) {\n\t\tctx->poll_multi_queue = false;\n\t} else if (!ctx->poll_multi_queue) {\n\t\tstruct io_kiocb *list_req;\n\n\t\tlist_req = container_of(ctx->iopoll_list.first, struct io_kiocb,\n\t\t\t\t\tcomp_list);\n\t\tif (list_req->file != req->file)\n\t\t\tctx->poll_multi_queue = true;\n\t}\n\n\t/*\n\t * For fast devices, IO may have already completed. If it has, add\n\t * it to the front so we find it first.\n\t */\n\tif (READ_ONCE(req->iopoll_completed))\n\t\twq_list_add_head(&req->comp_list, &ctx->iopoll_list);\n\telse\n\t\twq_list_add_tail(&req->comp_list, &ctx->iopoll_list);\n\n\tif (unlikely(needs_lock)) {\n\t\t/*\n\t\t * If IORING_SETUP_SQPOLL is enabled, sqes are either handle\n\t\t * in sq thread task context or in io worker task context. If\n\t\t * current task context is sq thread, we don't need to check\n\t\t * whether should wake up sq thread.\n\t\t */\n\t\tif ((ctx->flags & IORING_SETUP_SQPOLL) &&\n\t\t    wq_has_sleeper(&ctx->sq_data->wait))\n\t\t\twake_up(&ctx->sq_data->wait);\n\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n}\n\nstatic bool io_bdev_nowait(struct block_device *bdev)\n{\n\treturn !bdev || blk_queue_nowait(bdev_get_queue(bdev));\n}\n\n/*\n * If we tracked the file through the SCM inflight mechanism, we could support\n * any file. For now, just ensure that anything potentially problematic is done\n * inline.\n */\nstatic bool __io_file_supports_nowait(struct file *file, umode_t mode)\n{\n\tif (S_ISBLK(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(I_BDEV(file->f_mapping->host)))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif (S_ISSOCK(mode))\n\t\treturn true;\n\tif (S_ISREG(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&\n\t\t    file->f_op != &io_uring_fops)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* any ->read/write should understand O_NONBLOCK */\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn true;\n\treturn file->f_mode & FMODE_NOWAIT;\n}\n\n/*\n * If we tracked the file through the SCM inflight mechanism, we could support\n * any file. For now, just ensure that anything potentially problematic is done\n * inline.\n */\nstatic unsigned int io_file_get_flags(struct file *file)\n{\n\tumode_t mode = file_inode(file)->i_mode;\n\tunsigned int res = 0;\n\n\tif (S_ISREG(mode))\n\t\tres |= FFS_ISREG;\n\tif (__io_file_supports_nowait(file, mode))\n\t\tres |= FFS_NOWAIT;\n\treturn res;\n}\n\nstatic inline bool io_file_supports_nowait(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_SUPPORT_NOWAIT;\n}\n\nstatic int io_prep_rw(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tunsigned ioprio;\n\tint ret;\n\n\tkiocb->ki_pos = READ_ONCE(sqe->off);\n\n\tioprio = READ_ONCE(sqe->ioprio);\n\tif (ioprio) {\n\t\tret = ioprio_check_cap(ioprio);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkiocb->ki_ioprio = ioprio;\n\t} else {\n\t\tkiocb->ki_ioprio = get_current_ioprio();\n\t}\n\n\treq->imu = NULL;\n\treq->rw.addr = READ_ONCE(sqe->addr);\n\treq->rw.len = READ_ONCE(sqe->len);\n\treq->rw.flags = READ_ONCE(sqe->rw_flags);\n\treq->buf_index = READ_ONCE(sqe->buf_index);\n\treturn 0;\n}\n\nstatic inline void io_rw_done(struct kiocb *kiocb, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * We can't just restart the syscall, since previously\n\t\t * submitted sqes may already be in progress. Just fail this\n\t\t * IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\tfallthrough;\n\tdefault:\n\t\tkiocb->ki_complete(kiocb, ret);\n\t}\n}\n\nstatic inline loff_t *io_kiocb_update_pos(struct io_kiocb *req)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool is_stream = req->file->f_mode & FMODE_STREAM;\n\n\tif (kiocb->ki_pos == -1) {\n\t\tif (!is_stream) {\n\t\t\treq->flags |= REQ_F_CUR_POS;\n\t\t\tkiocb->ki_pos = req->file->f_pos;\n\t\t\treturn &kiocb->ki_pos;\n\t\t} else {\n\t\t\tkiocb->ki_pos = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn is_stream ? NULL : &kiocb->ki_pos;\n}\n\nstatic void kiocb_done(struct io_kiocb *req, ssize_t ret,\n\t\t       unsigned int issue_flags)\n{\n\tstruct io_async_rw *io = req->async_data;\n\n\t/* add previously done IO, if any */\n\tif (req_has_async_data(req) && io->bytes_done > 0) {\n\t\tif (ret < 0)\n\t\t\tret = io->bytes_done;\n\t\telse\n\t\t\tret += io->bytes_done;\n\t}\n\n\tif (req->flags & REQ_F_CUR_POS)\n\t\treq->file->f_pos = req->rw.kiocb.ki_pos;\n\tif (ret >= 0 && (req->rw.kiocb.ki_complete == io_complete_rw))\n\t\t__io_complete_rw(req, ret, issue_flags);\n\telse\n\t\tio_rw_done(&req->rw.kiocb, ret);\n\n\tif (req->flags & REQ_F_REISSUE) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (io_resubmit_prep(req))\n\t\t\tio_req_task_queue_reissue(req);\n\t\telse\n\t\t\tio_req_task_queue_fail(req, ret);\n\t}\n}\n\nstatic int __io_import_fixed(struct io_kiocb *req, int rw, struct iov_iter *iter,\n\t\t\t     struct io_mapped_ubuf *imu)\n{\n\tsize_t len = req->rw.len;\n\tu64 buf_end, buf_addr = req->rw.addr;\n\tsize_t offset;\n\n\tif (unlikely(check_add_overflow(buf_addr, (u64)len, &buf_end)))\n\t\treturn -EFAULT;\n\t/* not inside the mapped region */\n\tif (unlikely(buf_addr < imu->ubuf || buf_end > imu->ubuf_end))\n\t\treturn -EFAULT;\n\n\t/*\n\t * May not be a start of buffer, set size appropriately\n\t * and advance us to the beginning.\n\t */\n\toffset = buf_addr - imu->ubuf;\n\tiov_iter_bvec(iter, rw, imu->bvec, imu->nr_bvecs, offset + len);\n\n\tif (offset) {\n\t\t/*\n\t\t * Don't use iov_iter_advance() here, as it's really slow for\n\t\t * using the latter parts of a big fixed buffer - it iterates\n\t\t * over each segment manually. We can cheat a bit here, because\n\t\t * we know that:\n\t\t *\n\t\t * 1) it's a BVEC iter, we set it up\n\t\t * 2) all bvecs are PAGE_SIZE in size, except potentially the\n\t\t *    first and last bvec\n\t\t *\n\t\t * So just find our index, and adjust the iterator afterwards.\n\t\t * If the offset is within the first bvec (or the whole first\n\t\t * bvec, just use iov_iter_advance(). This makes it easier\n\t\t * since we can just skip the first segment, which may not\n\t\t * be PAGE_SIZE aligned.\n\t\t */\n\t\tconst struct bio_vec *bvec = imu->bvec;\n\n\t\tif (offset <= bvec->bv_len) {\n\t\t\tiov_iter_advance(iter, offset);\n\t\t} else {\n\t\t\tunsigned long seg_skip;\n\n\t\t\t/* skip first vec */\n\t\t\toffset -= bvec->bv_len;\n\t\t\tseg_skip = 1 + (offset >> PAGE_SHIFT);\n\n\t\t\titer->bvec = bvec + seg_skip;\n\t\t\titer->nr_segs -= seg_skip;\n\t\t\titer->count -= bvec->bv_len + offset;\n\t\t\titer->iov_offset = offset & ~PAGE_MASK;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int io_import_fixed(struct io_kiocb *req, int rw, struct iov_iter *iter,\n\t\t\t   unsigned int issue_flags)\n{\n\tstruct io_mapped_ubuf *imu = req->imu;\n\tu16 index, buf_index = req->buf_index;\n\n\tif (likely(!imu)) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tif (unlikely(buf_index >= ctx->nr_user_bufs))\n\t\t\treturn -EFAULT;\n\t\tio_req_set_rsrc_node(req, ctx, issue_flags);\n\t\tindex = array_index_nospec(buf_index, ctx->nr_user_bufs);\n\t\timu = READ_ONCE(ctx->user_bufs[index]);\n\t\treq->imu = imu;\n\t}\n\treturn __io_import_fixed(req, rw, iter, imu);\n}\n\nstatic void io_ring_submit_unlock(struct io_ring_ctx *ctx, bool needs_lock)\n{\n\tif (needs_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic void io_ring_submit_lock(struct io_ring_ctx *ctx, bool needs_lock)\n{\n\t/*\n\t * \"Normal\" inline submissions always hold the uring_lock, since we\n\t * grab it from the system call. Same is true for the SQPOLL offload.\n\t * The only exception is when we've detached the request and issue it\n\t * from an async worker thread, grab the lock for that case.\n\t */\n\tif (needs_lock)\n\t\tmutex_lock(&ctx->uring_lock);\n}\n\nstatic void io_buffer_add_list(struct io_ring_ctx *ctx,\n\t\t\t       struct io_buffer_list *bl, unsigned int bgid)\n{\n\tstruct list_head *list;\n\n\tlist = &ctx->io_buffers[hash_32(bgid, IO_BUFFERS_HASH_BITS)];\n\tINIT_LIST_HEAD(&bl->buf_list);\n\tbl->bgid = bgid;\n\tlist_add(&bl->list, list);\n}\n\nstatic struct io_buffer *io_buffer_select(struct io_kiocb *req, size_t *len,\n\t\t\t\t\t  int bgid, unsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf = req->kbuf;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\n\tif (req->flags & REQ_F_BUFFER_SELECTED)\n\t\treturn kbuf;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbl = io_buffer_get_list(ctx, bgid);\n\tif (bl && !list_empty(&bl->buf_list)) {\n\t\tkbuf = list_first_entry(&bl->buf_list, struct io_buffer, list);\n\t\tlist_del(&kbuf->list);\n\t\tif (*len > kbuf->len)\n\t\t\t*len = kbuf->len;\n\t\treq->flags |= REQ_F_BUFFER_SELECTED;\n\t\treq->kbuf = kbuf;\n\t} else {\n\t\tkbuf = ERR_PTR(-ENOBUFS);\n\t}\n\n\tio_ring_submit_unlock(req->ctx, needs_lock);\n\treturn kbuf;\n}\n\nstatic void __user *io_rw_buffer_select(struct io_kiocb *req, size_t *len,\n\t\t\t\t\tunsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf;\n\tu16 bgid;\n\n\tbgid = req->buf_index;\n\tkbuf = io_buffer_select(req, len, bgid, issue_flags);\n\tif (IS_ERR(kbuf))\n\t\treturn kbuf;\n\treturn u64_to_user_ptr(kbuf->addr);\n}\n\n#ifdef CONFIG_COMPAT\nstatic ssize_t io_compat_import(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\tunsigned int issue_flags)\n{\n\tstruct compat_iovec __user *uiov;\n\tcompat_ssize_t clen;\n\tvoid __user *buf;\n\tssize_t len;\n\n\tuiov = u64_to_user_ptr(req->rw.addr);\n\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\treturn -EFAULT;\n\tif (__get_user(clen, &uiov->iov_len))\n\t\treturn -EFAULT;\n\tif (clen < 0)\n\t\treturn -EINVAL;\n\n\tlen = clen;\n\tbuf = io_rw_buffer_select(req, &len, issue_flags);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = (compat_size_t) len;\n\treturn 0;\n}\n#endif\n\nstatic ssize_t __io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\t      unsigned int issue_flags)\n{\n\tstruct iovec __user *uiov = u64_to_user_ptr(req->rw.addr);\n\tvoid __user *buf;\n\tssize_t len;\n\n\tif (copy_from_user(iov, uiov, sizeof(*uiov)))\n\t\treturn -EFAULT;\n\n\tlen = iov[0].iov_len;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tbuf = io_rw_buffer_select(req, &len, issue_flags);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = len;\n\treturn 0;\n}\n\nstatic ssize_t io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\t    unsigned int issue_flags)\n{\n\tif (req->flags & REQ_F_BUFFER_SELECTED) {\n\t\tstruct io_buffer *kbuf = req->kbuf;\n\n\t\tiov[0].iov_base = u64_to_user_ptr(kbuf->addr);\n\t\tiov[0].iov_len = kbuf->len;\n\t\treturn 0;\n\t}\n\tif (req->rw.len != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\treturn io_compat_import(req, iov, issue_flags);\n#endif\n\n\treturn __io_iov_buffer_select(req, iov, issue_flags);\n}\n\nstatic struct iovec *__io_import_iovec(int rw, struct io_kiocb *req,\n\t\t\t\t       struct io_rw_state *s,\n\t\t\t\t       unsigned int issue_flags)\n{\n\tstruct iov_iter *iter = &s->iter;\n\tu8 opcode = req->opcode;\n\tstruct iovec *iovec;\n\tvoid __user *buf;\n\tsize_t sqe_len;\n\tssize_t ret;\n\n\tif (opcode == IORING_OP_READ_FIXED || opcode == IORING_OP_WRITE_FIXED) {\n\t\tret = io_import_fixed(req, rw, iter, issue_flags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\treturn NULL;\n\t}\n\n\t/* buffer index only valid with fixed read/write, or buffer select  */\n\tif (unlikely(req->buf_index && !(req->flags & REQ_F_BUFFER_SELECT)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbuf = u64_to_user_ptr(req->rw.addr);\n\tsqe_len = req->rw.len;\n\n\tif (opcode == IORING_OP_READ || opcode == IORING_OP_WRITE) {\n\t\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\t\tbuf = io_rw_buffer_select(req, &sqe_len, issue_flags);\n\t\t\tif (IS_ERR(buf))\n\t\t\t\treturn ERR_CAST(buf);\n\t\t\treq->rw.len = sqe_len;\n\t\t}\n\n\t\tret = import_single_range(rw, buf, sqe_len, s->fast_iov, iter);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\treturn NULL;\n\t}\n\n\tiovec = s->fast_iov;\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tret = io_iov_buffer_select(req, iovec, issue_flags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tiov_iter_init(iter, rw, iovec, 1, iovec->iov_len);\n\t\treturn NULL;\n\t}\n\n\tret = __import_iovec(rw, buf, sqe_len, UIO_FASTIOV, &iovec, iter,\n\t\t\t      req->ctx->compat);\n\tif (unlikely(ret < 0))\n\t\treturn ERR_PTR(ret);\n\treturn iovec;\n}\n\nstatic inline int io_import_iovec(int rw, struct io_kiocb *req,\n\t\t\t\t  struct iovec **iovec, struct io_rw_state *s,\n\t\t\t\t  unsigned int issue_flags)\n{\n\t*iovec = __io_import_iovec(rw, req, s, issue_flags);\n\tif (unlikely(IS_ERR(*iovec)))\n\t\treturn PTR_ERR(*iovec);\n\n\tiov_iter_save_state(&s->iter, &s->iter_state);\n\treturn 0;\n}\n\nstatic inline loff_t *io_kiocb_ppos(struct kiocb *kiocb)\n{\n\treturn (kiocb->ki_filp->f_mode & FMODE_STREAM) ? NULL : &kiocb->ki_pos;\n}\n\n/*\n * For files that don't have ->read_iter() and ->write_iter(), handle them\n * by looping over ->read() or ->write() manually.\n */\nstatic ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct file *file = req->file;\n\tssize_t ret = 0;\n\tloff_t *ppos;\n\n\t/*\n\t * Don't support polled IO through this interface, and we can't\n\t * support non-blocking either. For the latter, this just causes\n\t * the kiocb to be handled from an async context.\n\t */\n\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) &&\n\t    !(kiocb->ki_filp->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tppos = io_kiocb_ppos(kiocb);\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec;\n\t\tssize_t nr;\n\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiovec = iov_iter_iovec(iter);\n\t\t} else {\n\t\t\tiovec.iov_base = u64_to_user_ptr(req->rw.addr);\n\t\t\tiovec.iov_len = req->rw.len;\n\t\t}\n\n\t\tif (rw == READ) {\n\t\t\tnr = file->f_op->read(file, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = file->f_op->write(file, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiov_iter_advance(iter, nr);\n\t\t} else {\n\t\t\treq->rw.addr += nr;\n\t\t\treq->rw.len -= nr;\n\t\t\tif (!req->rw.len)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void io_req_map_rw(struct io_kiocb *req, const struct iovec *iovec,\n\t\t\t  const struct iovec *fast_iov, struct iov_iter *iter)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\n\tmemcpy(&rw->s.iter, iter, sizeof(*iter));\n\trw->free_iovec = iovec;\n\trw->bytes_done = 0;\n\t/* can only be fixed buffers, no need to do anything */\n\tif (iov_iter_is_bvec(iter))\n\t\treturn;\n\tif (!iovec) {\n\t\tunsigned iov_off = 0;\n\n\t\trw->s.iter.iov = rw->s.fast_iov;\n\t\tif (iter->iov != fast_iov) {\n\t\t\tiov_off = iter->iov - fast_iov;\n\t\t\trw->s.iter.iov += iov_off;\n\t\t}\n\t\tif (rw->s.fast_iov != fast_iov)\n\t\t\tmemcpy(rw->s.fast_iov + iov_off, fast_iov + iov_off,\n\t\t\t       sizeof(struct iovec) * iter->nr_segs);\n\t} else {\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\t}\n}\n\nstatic inline bool io_alloc_async_data(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!io_op_defs[req->opcode].async_size);\n\treq->async_data = kmalloc(io_op_defs[req->opcode].async_size, GFP_KERNEL);\n\tif (req->async_data) {\n\t\treq->flags |= REQ_F_ASYNC_DATA;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int io_setup_async_rw(struct io_kiocb *req, const struct iovec *iovec,\n\t\t\t     struct io_rw_state *s, bool force)\n{\n\tif (!force && !io_op_defs[req->opcode].needs_async_setup)\n\t\treturn 0;\n\tif (!req_has_async_data(req)) {\n\t\tstruct io_async_rw *iorw;\n\n\t\tif (io_alloc_async_data(req)) {\n\t\t\tkfree(iovec);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tio_req_map_rw(req, iovec, s->fast_iov, &s->iter);\n\t\tiorw = req->async_data;\n\t\t/* we've copied and mapped the iter, ensure state is saved */\n\t\tiov_iter_save_state(&iorw->s.iter, &iorw->s.iter_state);\n\t}\n\treturn 0;\n}\n\nstatic inline int io_rw_prep_async(struct io_kiocb *req, int rw)\n{\n\tstruct io_async_rw *iorw = req->async_data;\n\tstruct iovec *iov;\n\tint ret;\n\n\t/* submission path, ->uring_lock should already be taken */\n\tret = io_import_iovec(rw, req, &iov, &iorw->s, 0);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tiorw->bytes_done = 0;\n\tiorw->free_iovec = iov;\n\tif (iov)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\n/*\n * This is our waitqueue callback handler, registered through __folio_lock_async()\n * when we initially tried to do the IO with the iocb armed our waitqueue.\n * This gets called when the page is unlocked, and we generally expect that to\n * happen when the page IO is completed and the page is now uptodate. This will\n * queue a task_work based retry of the operation, attempting to copy the data\n * again. If the latter fails because the page was NOT uptodate, then we will\n * do a thread based blocking retry of the operation. That's the unexpected\n * slow path.\n */\nstatic int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,\n\t\t\t     int sync, void *arg)\n{\n\tstruct wait_page_queue *wpq;\n\tstruct io_kiocb *req = wait->private;\n\tstruct wait_page_key *key = arg;\n\n\twpq = container_of(wait, struct wait_page_queue, wait);\n\n\tif (!wake_page_match(wpq, key))\n\t\treturn 0;\n\n\treq->rw.kiocb.ki_flags &= ~IOCB_WAITQ;\n\tlist_del_init(&wait->entry);\n\tio_req_task_queue(req);\n\treturn 1;\n}\n\n/*\n * This controls whether a given IO request should be armed for async page\n * based retry. If we return false here, the request is handed to the async\n * worker threads for retry. If we're doing buffered reads on a regular file,\n * we prepare a private wait_page_queue entry and retry the operation. This\n * will either succeed because the page is now uptodate and unlocked, or it\n * will register a callback when the page is unlocked at IO completion. Through\n * that callback, io_uring uses task_work to setup a retry of the operation.\n * That retry will attempt the buffered read again. The retry will generally\n * succeed, or in rare cases where it fails, we then fall back to using the\n * async worker threads for a blocking retry.\n */\nstatic bool io_rw_should_retry(struct io_kiocb *req)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\tstruct wait_page_queue *wait = &rw->wpq;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\n\t/* never retry for NOWAIT, we just complete with -EAGAIN */\n\tif (req->flags & REQ_F_NOWAIT)\n\t\treturn false;\n\n\t/* Only for buffered IO */\n\tif (kiocb->ki_flags & (IOCB_DIRECT | IOCB_HIPRI))\n\t\treturn false;\n\n\t/*\n\t * just use poll if we can, and don't attempt if the fs doesn't\n\t * support callback based unlocks\n\t */\n\tif (file_can_poll(req->file) || !(req->file->f_mode & FMODE_BUF_RASYNC))\n\t\treturn false;\n\n\twait->wait.func = io_async_buf_func;\n\twait->wait.private = req;\n\twait->wait.flags = 0;\n\tINIT_LIST_HEAD(&wait->wait.entry);\n\tkiocb->ki_flags |= IOCB_WAITQ;\n\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\tkiocb->ki_waitq = wait;\n\treturn true;\n}\n\nstatic inline int io_iter_do_read(struct io_kiocb *req, struct iov_iter *iter)\n{\n\tif (likely(req->file->f_op->read_iter))\n\t\treturn call_read_iter(req->file, &req->rw.kiocb, iter);\n\telse if (req->file->f_op->read)\n\t\treturn loop_rw_iter(READ, req, iter);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool need_read_all(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_ISREG ||\n\t\tS_ISBLK(file_inode(req->file)->i_mode);\n}\n\nstatic int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rw_state __s, *s = &__s;\n\tstruct iovec *iovec;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tstruct io_async_rw *rw;\n\tssize_t ret, ret2;\n\tloff_t *ppos;\n\n\tif (!req_has_async_data(req)) {\n\t\tret = io_import_iovec(READ, req, &iovec, s, issue_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t} else {\n\t\t/*\n\t\t * Safe and required to re-import if we're using provided\n\t\t * buffers, as we dropped the selected one before retry.\n\t\t */\n\t\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\t\tret = io_import_iovec(READ, req, &iovec, s, issue_flags);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t}\n\n\t\trw = req->async_data;\n\t\ts = &rw->s;\n\t\t/*\n\t\t * We come here from an earlier attempt, restore our state to\n\t\t * match in case it doesn't. It's cheap enough that we don't\n\t\t * need to make this conditional.\n\t\t */\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tiovec = NULL;\n\t}\n\tret = io_rw_init_file(req, FMODE_READ);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treq->result = iov_iter_count(&s->iter);\n\n\tif (force_nonblock) {\n\t\t/* If the file doesn't support async, just async punt */\n\t\tif (unlikely(!io_file_supports_nowait(req))) {\n\t\t\tret = io_setup_async_rw(req, iovec, s, true);\n\t\t\treturn ret ?: -EAGAIN;\n\t\t}\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\t} else {\n\t\t/* Ensure we clear previously set non-block flag */\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\t}\n\n\tppos = io_kiocb_update_pos(req);\n\n\tret = rw_verify_area(READ, req->file, ppos, req->result);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\n\tret = io_iter_do_read(req, &s->iter);\n\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\t/* if we can poll, just do that */\n\t\tif (req->opcode == IORING_OP_READ && file_can_poll(req->file))\n\t\t\treturn -EAGAIN;\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret == req->result || ret <= 0 || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !need_read_all(req)) {\n\t\t/* read all, failed, already did sync or don't want to retry */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Don't depend on the iter state matching what was consumed, or being\n\t * untouched in case of error. Restore it and we'll advance it\n\t * manually if we need to.\n\t */\n\tiov_iter_restore(&s->iter, &s->iter_state);\n\n\tret2 = io_setup_async_rw(req, iovec, s, true);\n\tif (ret2)\n\t\treturn ret2;\n\n\tiovec = NULL;\n\trw = req->async_data;\n\ts = &rw->s;\n\t/*\n\t * Now use our persistent iterator and state, if we aren't already.\n\t * We've restored and mapped the iter to match.\n\t */\n\n\tdo {\n\t\t/*\n\t\t * We end up here because of a partial read, either from\n\t\t * above or inside this loop. Advance the iter by the bytes\n\t\t * that were consumed.\n\t\t */\n\t\tiov_iter_advance(&s->iter, ret);\n\t\tif (!iov_iter_count(&s->iter))\n\t\t\tbreak;\n\t\trw->bytes_done += ret;\n\t\tiov_iter_save_state(&s->iter, &s->iter_state);\n\n\t\t/* if we can retry, do so with the callbacks armed */\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If\n\t\t * we get -EIOCBQUEUED, then we'll get a notification when the\n\t\t * desired page gets unlocked. We can also get a partial read\n\t\t * here, and if we do, then just retry at the new offset.\n\t\t */\n\t\tret = io_iter_do_read(req, &s->iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\t/* we got some bytes, but not all. retry. */\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t} while (ret > 0);\ndone:\n\tkiocb_done(req, ret, issue_flags);\nout_free:\n\t/* it's faster to check here then delegate to kfree */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}\n\nstatic int io_write(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rw_state __s, *s = &__s;\n\tstruct iovec *iovec;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tssize_t ret, ret2;\n\tloff_t *ppos;\n\n\tif (!req_has_async_data(req)) {\n\t\tret = io_import_iovec(WRITE, req, &iovec, s, issue_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t} else {\n\t\tstruct io_async_rw *rw = req->async_data;\n\n\t\ts = &rw->s;\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tiovec = NULL;\n\t}\n\tret = io_rw_init_file(req, FMODE_WRITE);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treq->result = iov_iter_count(&s->iter);\n\n\tif (force_nonblock) {\n\t\t/* If the file doesn't support async, just async punt */\n\t\tif (unlikely(!io_file_supports_nowait(req)))\n\t\t\tgoto copy_iov;\n\n\t\t/* file path doesn't support NOWAIT for non-direct_IO */\n\t\tif (force_nonblock && !(kiocb->ki_flags & IOCB_DIRECT) &&\n\t\t    (req->flags & REQ_F_ISREG))\n\t\t\tgoto copy_iov;\n\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\t} else {\n\t\t/* Ensure we clear previously set non-block flag */\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\t}\n\n\tppos = io_kiocb_update_pos(req);\n\n\tret = rw_verify_area(WRITE, req->file, ppos, req->result);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\t/*\n\t * Open-code file_start_write here to grab freeze protection,\n\t * which will be released by another thread in\n\t * io_complete_rw().  Fool lockdep by telling it the lock got\n\t * released so that it doesn't complain about the held lock when\n\t * we return to userspace.\n\t */\n\tif (req->flags & REQ_F_ISREG) {\n\t\tsb_start_write(file_inode(req->file)->i_sb);\n\t\t__sb_writers_release(file_inode(req->file)->i_sb,\n\t\t\t\t\tSB_FREEZE_WRITE);\n\t}\n\tkiocb->ki_flags |= IOCB_WRITE;\n\n\tif (likely(req->file->f_op->write_iter))\n\t\tret2 = call_write_iter(req->file, kiocb, &s->iter);\n\telse if (req->file->f_op->write)\n\t\tret2 = loop_rw_iter(WRITE, req, &s->iter);\n\telse\n\t\tret2 = -EINVAL;\n\n\tif (req->flags & REQ_F_REISSUE) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tret2 = -EAGAIN;\n\t}\n\n\t/*\n\t * Raw bdev writes will return -EOPNOTSUPP for IOCB_NOWAIT. Just\n\t * retry them without IOCB_NOWAIT.\n\t */\n\tif (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT))\n\t\tret2 = -EAGAIN;\n\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\tif (ret2 == -EAGAIN && (req->flags & REQ_F_NOWAIT))\n\t\tgoto done;\n\tif (!force_nonblock || ret2 != -EAGAIN) {\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (ret2 == -EAGAIN && (req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto copy_iov;\ndone:\n\t\tkiocb_done(req, ret2, issue_flags);\n\t} else {\ncopy_iov:\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tret = io_setup_async_rw(req, iovec, s, false);\n\t\treturn ret ?: -EAGAIN;\n\t}\nout_free:\n\t/* it's reportedly faster than delegating the null check to kfree() */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn ret;\n}\n\nstatic int io_renameat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_rename *ren = &req->rename;\n\tconst char __user *oldf, *newf;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tren->old_dfd = READ_ONCE(sqe->fd);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tren->new_dfd = READ_ONCE(sqe->len);\n\tren->flags = READ_ONCE(sqe->rename_flags);\n\n\tren->oldpath = getname(oldf);\n\tif (IS_ERR(ren->oldpath))\n\t\treturn PTR_ERR(ren->oldpath);\n\n\tren->newpath = getname(newf);\n\tif (IS_ERR(ren->newpath)) {\n\t\tputname(ren->oldpath);\n\t\treturn PTR_ERR(ren->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_renameat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rename *ren = &req->rename;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_renameat2(ren->old_dfd, ren->oldpath, ren->new_dfd,\n\t\t\t\tren->newpath, ren->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_unlinkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_unlink *un = &req->unlink;\n\tconst char __user *fname;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->len || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tun->dfd = READ_ONCE(sqe->fd);\n\n\tun->flags = READ_ONCE(sqe->unlink_flags);\n\tif (un->flags & ~AT_REMOVEDIR)\n\t\treturn -EINVAL;\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tun->filename = getname(fname);\n\tif (IS_ERR(un->filename))\n\t\treturn PTR_ERR(un->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_unlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_unlink *un = &req->unlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (un->flags & AT_REMOVEDIR)\n\t\tret = do_rmdir(un->dfd, un->filename);\n\telse\n\t\tret = do_unlinkat(un->dfd, un->filename);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_mkdirat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_mkdir *mkd = &req->mkdir;\n\tconst char __user *fname;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->rw_flags || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tmkd->dfd = READ_ONCE(sqe->fd);\n\tmkd->mode = READ_ONCE(sqe->len);\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tmkd->filename = getname(fname);\n\tif (IS_ERR(mkd->filename))\n\t\treturn PTR_ERR(mkd->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_mkdirat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_mkdir *mkd = &req->mkdir;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_mkdirat(mkd->dfd, mkd->filename, mkd->mode);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_symlinkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_symlink *sl = &req->symlink;\n\tconst char __user *oldpath, *newpath;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->rw_flags || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tsl->new_dfd = READ_ONCE(sqe->fd);\n\toldpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewpath = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\n\tsl->oldpath = getname(oldpath);\n\tif (IS_ERR(sl->oldpath))\n\t\treturn PTR_ERR(sl->oldpath);\n\n\tsl->newpath = getname(newpath);\n\tif (IS_ERR(sl->newpath)) {\n\t\tputname(sl->oldpath);\n\t\treturn PTR_ERR(sl->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_symlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_symlink *sl = &req->symlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_symlinkat(sl->oldpath, sl->new_dfd, sl->newpath);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_linkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_hardlink *lnk = &req->hardlink;\n\tconst char __user *oldf, *newf;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->rw_flags || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tlnk->old_dfd = READ_ONCE(sqe->fd);\n\tlnk->new_dfd = READ_ONCE(sqe->len);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlnk->flags = READ_ONCE(sqe->hardlink_flags);\n\n\tlnk->oldpath = getname(oldf);\n\tif (IS_ERR(lnk->oldpath))\n\t\treturn PTR_ERR(lnk->oldpath);\n\n\tlnk->newpath = getname(newf);\n\tif (IS_ERR(lnk->newpath)) {\n\t\tputname(lnk->oldpath);\n\t\treturn PTR_ERR(lnk->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_linkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_hardlink *lnk = &req->hardlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_linkat(lnk->old_dfd, lnk->oldpath, lnk->new_dfd,\n\t\t\t\tlnk->newpath, lnk->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_shutdown_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_NET)\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->ioprio || sqe->off || sqe->addr || sqe->rw_flags ||\n\t\t     sqe->buf_index || sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->shutdown.how = READ_ONCE(sqe->len);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_shutdown(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_NET)\n\tstruct socket *sock;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = __sys_shutdown_sock(sock, req->shutdown.how);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int __io_splice_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = &req->splice;\n\tunsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsp->len = READ_ONCE(sqe->len);\n\tsp->flags = READ_ONCE(sqe->splice_flags);\n\tif (unlikely(sp->flags & ~valid_flags))\n\t\treturn -EINVAL;\n\tsp->splice_fd_in = READ_ONCE(sqe->splice_fd_in);\n\treturn 0;\n}\n\nstatic int io_tee_prep(struct io_kiocb *req,\n\t\t       const struct io_uring_sqe *sqe)\n{\n\tif (READ_ONCE(sqe->splice_off_in) || READ_ONCE(sqe->off))\n\t\treturn -EINVAL;\n\treturn __io_splice_prep(req, sqe);\n}\n\nstatic int io_tee(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = &req->splice;\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, IO_URING_F_UNLOCKED);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tif (sp->len)\n\t\tret = do_tee(in, out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tio_put_file(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = &req->splice;\n\n\tsp->off_in = READ_ONCE(sqe->splice_off_in);\n\tsp->off_out = READ_ONCE(sqe->off);\n\treturn __io_splice_prep(req, sqe);\n}\n\nstatic int io_splice(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = &req->splice;\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tloff_t *poff_in, *poff_out;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, IO_URING_F_UNLOCKED);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tpoff_in = (sp->off_in == -1) ? NULL : &sp->off_in;\n\tpoff_out = (sp->off_out == -1) ? NULL : &sp->off_out;\n\n\tif (sp->len)\n\t\tret = do_splice(in, poff_in, out, poff_out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tio_put_file(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\n/*\n * IORING_OP_NOP just posts a completion event, nothing else.\n */\nstatic int io_nop(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\t__io_req_complete(req, issue_flags, 0, 0);\n\treturn 0;\n}\n\nstatic int io_msg_ring_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->rw_flags ||\n\t\t     sqe->splice_fd_in || sqe->buf_index || sqe->personality))\n\t\treturn -EINVAL;\n\n\treq->msg.user_data = READ_ONCE(sqe->off);\n\treq->msg.len = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx;\n\tstruct io_msg *msg = &req->msg;\n\tbool filled;\n\tint ret;\n\n\tret = -EBADFD;\n\tif (req->file->f_op != &io_uring_fops)\n\t\tgoto done;\n\n\tret = -EOVERFLOW;\n\ttarget_ctx = req->file->private_data;\n\n\tspin_lock(&target_ctx->completion_lock);\n\tfilled = io_fill_cqe_aux(target_ctx, msg->user_data, msg->len, 0);\n\tio_commit_cqring(target_ctx);\n\tspin_unlock(&target_ctx->completion_lock);\n\n\tif (filled) {\n\t\tio_cqring_ev_posted(target_ctx);\n\t\tret = 0;\n\t}\n\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_fsync_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index ||\n\t\t     sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->sync.flags = READ_ONCE(sqe->fsync_flags);\n\tif (unlikely(req->sync.flags & ~IORING_FSYNC_DATASYNC))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_fsync(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tloff_t end = req->sync.off + req->sync.len;\n\tint ret;\n\n\t/* fsync always requires a blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = vfs_fsync_range(req->file, req->sync.off,\n\t\t\t\tend > 0 ? end : LLONG_MAX,\n\t\t\t\treq->sync.flags & IORING_FSYNC_DATASYNC);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_fallocate_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n\tif (sqe->ioprio || sqe->buf_index || sqe->rw_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->addr);\n\treq->sync.mode = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_fallocate(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tint ret;\n\n\t/* fallocate always requiring blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\tret = vfs_fallocate(req->file, req->sync.mode, req->sync.off,\n\t\t\t\treq->sync.len);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\telse\n\t\tfsnotify_modify(req->file);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *fname;\n\tint ret;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->ioprio || sqe->buf_index))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\t/* open.how should be already initialised */\n\tif (!(req->open.how.flags & O_PATH) && force_o_largefile())\n\t\treq->open.how.flags |= O_LARGEFILE;\n\n\treq->open.dfd = READ_ONCE(sqe->fd);\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->open.filename = getname(fname);\n\tif (IS_ERR(req->open.filename)) {\n\t\tret = PTR_ERR(req->open.filename);\n\t\treq->open.filename = NULL;\n\t\treturn ret;\n\t}\n\n\treq->open.file_slot = READ_ONCE(sqe->file_index);\n\tif (req->open.file_slot && (req->open.how.flags & O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\treq->open.nofile = rlimit(RLIMIT_NOFILE);\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tu64 mode = READ_ONCE(sqe->len);\n\tu64 flags = READ_ONCE(sqe->open_flags);\n\n\treq->open.how = build_open_how(flags, mode);\n\treturn __io_openat_prep(req, sqe);\n}\n\nstatic int io_openat2_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct open_how __user *how;\n\tsize_t len;\n\tint ret;\n\n\thow = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlen = READ_ONCE(sqe->len);\n\tif (len < OPEN_HOW_SIZE_VER0)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&req->open.how, sizeof(req->open.how), how,\n\t\t\t\t\tlen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __io_openat_prep(req, sqe);\n}\n\nstatic int io_openat2(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct open_flags op;\n\tstruct file *file;\n\tbool resolve_nonblock, nonblock_set;\n\tbool fixed = !!req->open.file_slot;\n\tint ret;\n\n\tret = build_open_flags(&req->open.how, &op);\n\tif (ret)\n\t\tgoto err;\n\tnonblock_set = op.open_flag & O_NONBLOCK;\n\tresolve_nonblock = req->open.how.resolve & RESOLVE_CACHED;\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\t/*\n\t\t * Don't bother trying for O_TRUNC, O_CREAT, or O_TMPFILE open,\n\t\t * it'll always -EAGAIN\n\t\t */\n\t\tif (req->open.how.flags & (O_TRUNC | O_CREAT | O_TMPFILE))\n\t\t\treturn -EAGAIN;\n\t\top.lookup_flags |= LOOKUP_CACHED;\n\t\top.open_flag |= O_NONBLOCK;\n\t}\n\n\tif (!fixed) {\n\t\tret = __get_unused_fd_flags(req->open.how.flags, req->open.nofile);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tfile = do_filp_open(req->open.dfd, req->open.filename, &op);\n\tif (IS_ERR(file)) {\n\t\t/*\n\t\t * We could hang on to this 'fd' on retrying, but seems like\n\t\t * marginal gain for something that is now known to be a slower\n\t\t * path. So just put it, and we'll get a new one when we retry.\n\t\t */\n\t\tif (!fixed)\n\t\t\tput_unused_fd(ret);\n\n\t\tret = PTR_ERR(file);\n\t\t/* only retry if RESOLVE_CACHED wasn't already set by application */\n\t\tif (ret == -EAGAIN &&\n\t\t    (!resolve_nonblock && (issue_flags & IO_URING_F_NONBLOCK)))\n\t\t\treturn -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tif ((issue_flags & IO_URING_F_NONBLOCK) && !nonblock_set)\n\t\tfile->f_flags &= ~O_NONBLOCK;\n\tfsnotify_open(file);\n\n\tif (!fixed)\n\t\tfd_install(ret, file);\n\telse\n\t\tret = io_install_fixed_file(req, file, issue_flags,\n\t\t\t\t\t    req->open.file_slot - 1);\nerr:\n\tputname(req->open.filename);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_openat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\treturn io_openat2(req, issue_flags);\n}\n\nstatic int io_remove_buffers_prep(struct io_kiocb *req,\n\t\t\t\t  const struct io_uring_sqe *sqe)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tu64 tmp;\n\n\tif (sqe->ioprio || sqe->rw_flags || sqe->addr || sqe->len || sqe->off ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttmp = READ_ONCE(sqe->fd);\n\tif (!tmp || tmp > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->nbufs = tmp;\n\tp->bgid = READ_ONCE(sqe->buf_group);\n\treturn 0;\n}\n\nstatic int __io_remove_buffers(struct io_ring_ctx *ctx,\n\t\t\t       struct io_buffer_list *bl, unsigned nbufs)\n{\n\tunsigned i = 0;\n\n\t/* shouldn't happen */\n\tif (!nbufs)\n\t\treturn 0;\n\n\t/* the head kbuf is the list itself */\n\twhile (!list_empty(&bl->buf_list)) {\n\t\tstruct io_buffer *nxt;\n\n\t\tnxt = list_first_entry(&bl->buf_list, struct io_buffer, list);\n\t\tlist_del(&nxt->list);\n\t\tif (++i == nbufs)\n\t\t\treturn i;\n\t\tcond_resched();\n\t}\n\ti++;\n\n\treturn i;\n}\n\nstatic int io_remove_buffers(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tint ret = 0;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tret = -ENOENT;\n\tbl = io_buffer_get_list(ctx, p->bgid);\n\tif (bl)\n\t\tret = __io_remove_buffers(ctx, bl, p->nbufs);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\n\t/* complete before unlock, IOPOLL may need the lock */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn 0;\n}\n\nstatic int io_provide_buffers_prep(struct io_kiocb *req,\n\t\t\t\t   const struct io_uring_sqe *sqe)\n{\n\tunsigned long size, tmp_check;\n\tstruct io_provide_buf *p = &req->pbuf;\n\tu64 tmp;\n\n\tif (sqe->ioprio || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttmp = READ_ONCE(sqe->fd);\n\tif (!tmp || tmp > USHRT_MAX)\n\t\treturn -E2BIG;\n\tp->nbufs = tmp;\n\tp->addr = READ_ONCE(sqe->addr);\n\tp->len = READ_ONCE(sqe->len);\n\n\tif (check_mul_overflow((unsigned long)p->len, (unsigned long)p->nbufs,\n\t\t\t\t&size))\n\t\treturn -EOVERFLOW;\n\tif (check_add_overflow((unsigned long)p->addr, size, &tmp_check))\n\t\treturn -EOVERFLOW;\n\n\tsize = (unsigned long)p->len * p->nbufs;\n\tif (!access_ok(u64_to_user_ptr(p->addr), size))\n\t\treturn -EFAULT;\n\n\tp->bgid = READ_ONCE(sqe->buf_group);\n\ttmp = READ_ONCE(sqe->off);\n\tif (tmp > USHRT_MAX)\n\t\treturn -E2BIG;\n\tp->bid = tmp;\n\treturn 0;\n}\n\nstatic int io_refill_buffer_cache(struct io_ring_ctx *ctx)\n{\n\tstruct io_buffer *buf;\n\tstruct page *page;\n\tint bufs_in_page;\n\n\t/*\n\t * Completions that don't happen inline (eg not under uring_lock) will\n\t * add to ->io_buffers_comp. If we don't have any free buffers, check\n\t * the completion list and splice those entries first.\n\t */\n\tif (!list_empty_careful(&ctx->io_buffers_comp)) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tif (!list_empty(&ctx->io_buffers_comp)) {\n\t\t\tlist_splice_init(&ctx->io_buffers_comp,\n\t\t\t\t\t\t&ctx->io_buffers_cache);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&ctx->completion_lock);\n\t}\n\n\t/*\n\t * No free buffers and no completion entries either. Allocate a new\n\t * page worth of buffer entries and add those to our freelist.\n\t */\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlist_add(&page->lru, &ctx->io_buffers_pages);\n\n\tbuf = page_address(page);\n\tbufs_in_page = PAGE_SIZE / sizeof(*buf);\n\twhile (bufs_in_page) {\n\t\tlist_add_tail(&buf->list, &ctx->io_buffers_cache);\n\t\tbuf++;\n\t\tbufs_in_page--;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_add_buffers(struct io_ring_ctx *ctx, struct io_provide_buf *pbuf,\n\t\t\t  struct io_buffer_list *bl)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tif (list_empty(&ctx->io_buffers_cache) &&\n\t\t    io_refill_buffer_cache(ctx))\n\t\t\tbreak;\n\t\tbuf = list_first_entry(&ctx->io_buffers_cache, struct io_buffer,\n\t\t\t\t\tlist);\n\t\tlist_move_tail(&buf->list, &bl->buf_list);\n\t\tbuf->addr = addr;\n\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);\n\t\tbuf->bid = bid;\n\t\tbuf->bgid = pbuf->bgid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tcond_resched();\n\t}\n\n\treturn i ? 0 : -ENOMEM;\n}\n\nstatic int io_provide_buffers(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tint ret = 0;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbl = io_buffer_get_list(ctx, p->bgid);\n\tif (unlikely(!bl)) {\n\t\tbl = kmalloc(sizeof(*bl), GFP_KERNEL);\n\t\tif (!bl) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tio_buffer_add_list(ctx, bl, p->bgid);\n\t}\n\n\tret = io_add_buffers(ctx, p, bl);\nerr:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t/* complete before unlock, IOPOLL may need the lock */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn 0;\n}\n\nstatic int io_epoll_ctl_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_EPOLL)\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->epoll.epfd = READ_ONCE(sqe->fd);\n\treq->epoll.op = READ_ONCE(sqe->len);\n\treq->epoll.fd = READ_ONCE(sqe->off);\n\n\tif (ep_op_has_event(req->epoll.op)) {\n\t\tstruct epoll_event __user *ev;\n\n\t\tev = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\t\tif (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_epoll_ctl(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_EPOLL)\n\tstruct io_epoll *ie = &req->epoll;\n\tint ret;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tret = do_epoll_ctl(ie->epfd, ie->op, ie->fd, &ie->event, force_nonblock);\n\tif (force_nonblock && ret == -EAGAIN)\n\t\treturn -EAGAIN;\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_madvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)\n\tif (sqe->ioprio || sqe->buf_index || sqe->off || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->madvise.addr = READ_ONCE(sqe->addr);\n\treq->madvise.len = READ_ONCE(sqe->len);\n\treq->madvise.advice = READ_ONCE(sqe->fadvise_advice);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_madvise(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)\n\tstruct io_madvise *ma = &req->madvise;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_madvise(current->mm, ma->addr, ma->len, ma->advice);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_fadvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tif (sqe->ioprio || sqe->buf_index || sqe->addr || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->fadvise.offset = READ_ONCE(sqe->off);\n\treq->fadvise.len = READ_ONCE(sqe->len);\n\treq->fadvise.advice = READ_ONCE(sqe->fadvise_advice);\n\treturn 0;\n}\n\nstatic int io_fadvise(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_fadvise *fa = &req->fadvise;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\tswitch (fa->advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tret = vfs_fadvise(req->file, fa->offset, fa->len, fa->advice);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_statx_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *path;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\treq->statx.dfd = READ_ONCE(sqe->fd);\n\treq->statx.mask = READ_ONCE(sqe->len);\n\tpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->statx.buffer = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\treq->statx.flags = READ_ONCE(sqe->statx_flags);\n\n\treq->statx.filename = getname_flags(path,\n\t\t\t\t\tgetname_statx_lookup_flags(req->statx.flags),\n\t\t\t\t\tNULL);\n\n\tif (IS_ERR(req->statx.filename)) {\n\t\tint ret = PTR_ERR(req->statx.filename);\n\n\t\treq->statx.filename = NULL;\n\t\treturn ret;\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_statx(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_statx *ctx = &req->statx;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_statx(ctx->dfd, ctx->filename, ctx->flags, ctx->mask,\n\t\t       ctx->buffer);\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_close_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->addr || sqe->len ||\n\t    sqe->rw_flags || sqe->buf_index)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\treq->close.fd = READ_ONCE(sqe->fd);\n\treq->close.file_slot = READ_ONCE(sqe->file_index);\n\tif (req->close.file_slot && req->close.fd)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int io_close(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct files_struct *files = current->files;\n\tstruct io_close *close = &req->close;\n\tstruct fdtable *fdt;\n\tstruct file *file = NULL;\n\tint ret = -EBADF;\n\n\tif (req->close.file_slot) {\n\t\tret = io_close_fixed(req, issue_flags);\n\t\tgoto err;\n\t}\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (close->fd >= fdt->max_fds) {\n\t\tspin_unlock(&files->file_lock);\n\t\tgoto err;\n\t}\n\tfile = fdt->fd[close->fd];\n\tif (!file || file->f_op == &io_uring_fops) {\n\t\tspin_unlock(&files->file_lock);\n\t\tfile = NULL;\n\t\tgoto err;\n\t}\n\n\t/* if the file has a flush method, be safe and punt to async */\n\tif (file->f_op->flush && (issue_flags & IO_URING_F_NONBLOCK)) {\n\t\tspin_unlock(&files->file_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tret = __close_fd_get_file(close->fd, &file);\n\tspin_unlock(&files->file_lock);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\n\t/* No ->flush() or already async, safely close from here */\n\tret = filp_close(file, current->files);\nerr:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tif (file)\n\t\tfput(file);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_sfr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index ||\n\t\t     sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->len);\n\treq->sync.flags = READ_ONCE(sqe->sync_range_flags);\n\treturn 0;\n}\n\nstatic int io_sync_file_range(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tint ret;\n\n\t/* sync_file_range always requires a blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = sync_file_range(req->file, req->sync.off, req->sync.len,\n\t\t\t\treq->sync.flags);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\n#if defined(CONFIG_NET)\nstatic int io_setup_async_msg(struct io_kiocb *req,\n\t\t\t      struct io_async_msghdr *kmsg)\n{\n\tstruct io_async_msghdr *async_msg = req->async_data;\n\n\tif (async_msg)\n\t\treturn -EAGAIN;\n\tif (io_alloc_async_data(req)) {\n\t\tkfree(kmsg->free_iov);\n\t\treturn -ENOMEM;\n\t}\n\tasync_msg = req->async_data;\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\tmemcpy(async_msg, kmsg, sizeof(*kmsg));\n\tasync_msg->msg.msg_name = &async_msg->addr;\n\t/* if were using fast_iov, set it to the new one */\n\tif (!async_msg->free_iov)\n\t\tasync_msg->msg.msg_iter.iov = async_msg->fast_iov;\n\n\treturn -EAGAIN;\n}\n\nstatic int io_sendmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tiomsg->msg.msg_name = &iomsg->addr;\n\tiomsg->free_iov = iomsg->fast_iov;\n\treturn sendmsg_copy_msghdr(&iomsg->msg, req->sr_msg.umsg,\n\t\t\t\t   req->sr_msg.msg_flags, &iomsg->free_iov);\n}\n\nstatic int io_sendmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tret = io_sendmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\nstatic int io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\treturn 0;\n}\n\nstatic int io_sendmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_sendmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tflags = req->sr_msg.msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);\n\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t/* fast path, check for non-NULL to avoid function call */\n\tif (kmsg->free_iov)\n\t\tkfree(kmsg->free_iov);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_send(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = import_single_range(WRITE, sr->buf, sr->len, &iov, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\n\tflags = req->sr_msg.msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tmsg.msg_flags = flags;\n\tret = sock_sendmsg(sock, &msg);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int __io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t struct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct iovec __user *uiov;\n\tsize_t iov_len;\n\tint ret;\n\n\tret = __copy_msghdr_from_user(&iomsg->msg, sr->umsg,\n\t\t\t\t\t&iomsg->uaddr, &uiov, &iov_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tif (iov_len > 1)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(iomsg->fast_iov, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\t\tsr->len = iomsg->fast_iov[0].iov_len;\n\t\tiomsg->free_iov = NULL;\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(READ, uiov, iov_len, UIO_FASTIOV,\n\t\t\t\t     &iomsg->free_iov, &iomsg->msg.msg_iter,\n\t\t\t\t     false);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int __io_compat_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t\tstruct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct compat_iovec __user *uiov;\n\tcompat_uptr_t ptr;\n\tcompat_size_t len;\n\tint ret;\n\n\tret = __get_compat_msghdr(&iomsg->msg, sr->umsg_compat, &iomsg->uaddr,\n\t\t\t\t  &ptr, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tuiov = compat_ptr(ptr);\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tcompat_ssize_t clen;\n\n\t\tif (len > 1)\n\t\t\treturn -EINVAL;\n\t\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\t\tif (__get_user(clen, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\t\tif (clen < 0)\n\t\t\treturn -EINVAL;\n\t\tsr->len = clen;\n\t\tiomsg->free_iov = NULL;\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(READ, (struct iovec __user *)uiov, len,\n\t\t\t\t   UIO_FASTIOV, &iomsg->free_iov,\n\t\t\t\t   &iomsg->msg.msg_iter, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tiomsg->msg.msg_name = &iomsg->addr;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\treturn __io_compat_recvmsg_copy_hdr(req, iomsg);\n#endif\n\n\treturn __io_recvmsg_copy_hdr(req, iomsg);\n}\n\nstatic struct io_buffer *io_recv_buffer_select(struct io_kiocb *req,\n\t\t\t\t\t       unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\treturn io_buffer_select(req, &sr->len, sr->bgid, issue_flags);\n}\n\nstatic int io_recvmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tret = io_recvmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\nstatic int io_recvmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->bgid = READ_ONCE(sqe->buf_group);\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\tsr->done_io = 0;\n\treturn 0;\n}\n\nstatic bool io_net_retry(struct socket *sock, int flags)\n{\n\tif (!(flags & MSG_WAITALL))\n\t\treturn false;\n\treturn sock->type == SOCK_STREAM || sock->type == SOCK_SEQPACKET;\n}\n\nstatic int io_recvmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct socket *sock;\n\tstruct io_buffer *kbuf;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_recvmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tkbuf = io_recv_buffer_select(req, issue_flags);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\t\tkmsg->fast_iov[0].iov_base = u64_to_user_ptr(kbuf->addr);\n\t\tkmsg->fast_iov[0].iov_len = req->sr_msg.len;\n\t\tiov_iter_init(&kmsg->msg.msg_iter, READ, kmsg->fast_iov,\n\t\t\t\t1, req->sr_msg.len);\n\t}\n\n\tflags = req->sr_msg.msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tret = __sys_recvmsg_sock(sock, &kmsg->msg, req->sr_msg.umsg,\n\t\t\t\t\tkmsg->uaddr, flags);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\t}\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (kmsg->msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\n\t\treq_set_fail(req);\n\t}\n\n\t/* fast path, check for non-NULL to avoid function call */\n\tif (kmsg->free_iov)\n\t\tkfree(kmsg->free_iov);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\t__io_req_complete(req, issue_flags, ret, io_put_kbuf(req, issue_flags));\n\treturn 0;\n}\n\nstatic int io_recv(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf;\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct msghdr msg;\n\tvoid __user *buf = sr->buf;\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tkbuf = io_recv_buffer_select(req, issue_flags);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\t\tbuf = u64_to_user_ptr(kbuf->addr);\n\t}\n\n\tret = import_single_range(READ, buf, sr->len, &iov, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_flags = 0;\n\n\tflags = req->sr_msg.msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tret = sock_recvmsg(sock, &msg, flags);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->len -= ret;\n\t\t\tsr->buf += ret;\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\nout_free:\n\t\treq_set_fail(req);\n\t}\n\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\t__io_req_complete(req, issue_flags, ret, io_put_kbuf(req, issue_flags));\n\treturn 0;\n}\n\nstatic int io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_accept *accept = &req->accept;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->buf_index)\n\t\treturn -EINVAL;\n\n\taccept->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\taccept->addr_len = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\taccept->flags = READ_ONCE(sqe->accept_flags);\n\taccept->nofile = rlimit(RLIMIT_NOFILE);\n\n\taccept->file_slot = READ_ONCE(sqe->file_index);\n\tif (accept->file_slot && (accept->flags & SOCK_CLOEXEC))\n\t\treturn -EINVAL;\n\tif (accept->flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (accept->flags & SOCK_NONBLOCK))\n\t\taccept->flags = (accept->flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\treturn 0;\n}\n\nstatic int io_accept(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_accept *accept = &req->accept;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tunsigned int file_flags = force_nonblock ? O_NONBLOCK : 0;\n\tbool fixed = !!accept->file_slot;\n\tstruct file *file;\n\tint ret, fd;\n\n\tif (!fixed) {\n\t\tfd = __get_unused_fd_flags(accept->flags, accept->nofile);\n\t\tif (unlikely(fd < 0))\n\t\t\treturn fd;\n\t}\n\tfile = do_accept(req->file, file_flags, accept->addr, accept->addr_len,\n\t\t\t accept->flags);\n\tif (IS_ERR(file)) {\n\t\tif (!fixed)\n\t\t\tput_unused_fd(fd);\n\t\tret = PTR_ERR(file);\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if (!fixed) {\n\t\tfd_install(fd, file);\n\t\tret = fd;\n\t} else {\n\t\tret = io_install_fixed_file(req, file, issue_flags,\n\t\t\t\t\t    accept->file_slot - 1);\n\t}\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_connect_prep_async(struct io_kiocb *req)\n{\n\tstruct io_async_connect *io = req->async_data;\n\tstruct io_connect *conn = &req->connect;\n\n\treturn move_addr_to_kernel(conn->addr, conn->addr_len, &io->address);\n}\n\nstatic int io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_connect *conn = &req->connect;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->buf_index || sqe->rw_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\tconn->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tconn->addr_len =  READ_ONCE(sqe->addr2);\n\treturn 0;\n}\n\nstatic int io_connect(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_connect __io, *io;\n\tunsigned file_flags;\n\tint ret;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tio = req->async_data;\n\t} else {\n\t\tret = move_addr_to_kernel(req->connect.addr,\n\t\t\t\t\t\treq->connect.addr_len,\n\t\t\t\t\t\t&__io.address);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tio = &__io;\n\t}\n\n\tfile_flags = force_nonblock ? O_NONBLOCK : 0;\n\n\tret = __sys_connect_file(req->file, &io->address,\n\t\t\t\t\treq->connect.addr_len, file_flags);\n\tif ((ret == -EAGAIN || ret == -EINPROGRESS) && force_nonblock) {\n\t\tif (req_has_async_data(req))\n\t\t\treturn -EAGAIN;\n\t\tif (io_alloc_async_data(req)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(req->async_data, &__io, sizeof(__io));\n\t\treturn -EAGAIN;\n\t}\n\tif (ret == -ERESTARTSYS)\n\t\tret = -EINTR;\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n#else /* !CONFIG_NET */\n#define IO_NETOP_FN(op)\t\t\t\t\t\t\t\\\nstatic int io_##op(struct io_kiocb *req, unsigned int issue_flags)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\n\n#define IO_NETOP_PREP(op)\t\t\t\t\t\t\\\nIO_NETOP_FN(op)\t\t\t\t\t\t\t\t\\\nstatic int io_##op##_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe) \\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define IO_NETOP_PREP_ASYNC(op)\t\t\t\t\t\t\\\nIO_NETOP_PREP(op)\t\t\t\t\t\t\t\\\nstatic int io_##op##_prep_async(struct io_kiocb *req)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\n\nIO_NETOP_PREP_ASYNC(sendmsg);\nIO_NETOP_PREP_ASYNC(recvmsg);\nIO_NETOP_PREP_ASYNC(connect);\nIO_NETOP_PREP(accept);\nIO_NETOP_FN(send);\nIO_NETOP_FN(recv);\n#endif /* CONFIG_NET */\n\nstruct io_poll_table {\n\tstruct poll_table_struct pt;\n\tstruct io_kiocb *req;\n\tint nr_entries;\n\tint error;\n};\n\n#define IO_POLL_CANCEL_FLAG\tBIT(31)\n#define IO_POLL_REF_MASK\tGENMASK(30, 0)\n\n/*\n * If refs part of ->poll_refs (see IO_POLL_REF_MASK) is 0, it's free. We can\n * bump it and acquire ownership. It's disallowed to modify requests while not\n * owning it, that prevents from races for enqueueing task_work's and b/w\n * arming poll and wakeups.\n */\nstatic inline bool io_poll_get_ownership(struct io_kiocb *req)\n{\n\treturn !(atomic_fetch_inc(&req->poll_refs) & IO_POLL_REF_MASK);\n}\n\nstatic void io_poll_mark_cancelled(struct io_kiocb *req)\n{\n\tatomic_or(IO_POLL_CANCEL_FLAG, &req->poll_refs);\n}\n\nstatic struct io_poll_iocb *io_poll_get_double(struct io_kiocb *req)\n{\n\t/* pure poll stashes this in ->async_data, poll driven retry elsewhere */\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treturn req->async_data;\n\treturn req->apoll->double_poll;\n}\n\nstatic struct io_poll_iocb *io_poll_get_single(struct io_kiocb *req)\n{\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treturn &req->poll;\n\treturn &req->apoll->poll;\n}\n\nstatic void io_poll_req_insert(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct hlist_head *list;\n\n\tlist = &ctx->cancel_hash[hash_long(req->user_data, ctx->cancel_hash_bits)];\n\thlist_add_head(&req->hash_node, list);\n}\n\nstatic void io_init_poll_iocb(struct io_poll_iocb *poll, __poll_t events,\n\t\t\t      wait_queue_func_t wake_func)\n{\n\tpoll->head = NULL;\n#define IO_POLL_UNMASK\t(EPOLLERR|EPOLLHUP|EPOLLNVAL|EPOLLRDHUP)\n\t/* mask in events that we always want/need */\n\tpoll->events = events | IO_POLL_UNMASK;\n\tINIT_LIST_HEAD(&poll->wait.entry);\n\tinit_waitqueue_func_entry(&poll->wait, wake_func);\n}\n\nstatic inline void io_poll_remove_entry(struct io_poll_iocb *poll)\n{\n\tstruct wait_queue_head *head = smp_load_acquire(&poll->head);\n\n\tif (head) {\n\t\tspin_lock_irq(&head->lock);\n\t\tlist_del_init(&poll->wait.entry);\n\t\tpoll->head = NULL;\n\t\tspin_unlock_irq(&head->lock);\n\t}\n}\n\nstatic void io_poll_remove_entries(struct io_kiocb *req)\n{\n\t/*\n\t * Nothing to do if neither of those flags are set. Avoid dipping\n\t * into the poll/apoll/double cachelines if we can.\n\t */\n\tif (!(req->flags & (REQ_F_SINGLE_POLL | REQ_F_DOUBLE_POLL)))\n\t\treturn;\n\n\t/*\n\t * While we hold the waitqueue lock and the waitqueue is nonempty,\n\t * wake_up_pollfree() will wait for us.  However, taking the waitqueue\n\t * lock in the first place can race with the waitqueue being freed.\n\t *\n\t * We solve this as eventpoll does: by taking advantage of the fact that\n\t * all users of wake_up_pollfree() will RCU-delay the actual free.  If\n\t * we enter rcu_read_lock() and see that the pointer to the queue is\n\t * non-NULL, we can then lock it without the memory being freed out from\n\t * under us.\n\t *\n\t * Keep holding rcu_read_lock() as long as we hold the queue lock, in\n\t * case the caller deletes the entry from the queue, leaving it empty.\n\t * In that case, only RCU prevents the queue memory from being freed.\n\t */\n\trcu_read_lock();\n\tif (req->flags & REQ_F_SINGLE_POLL)\n\t\tio_poll_remove_entry(io_poll_get_single(req));\n\tif (req->flags & REQ_F_DOUBLE_POLL)\n\t\tio_poll_remove_entry(io_poll_get_double(req));\n\trcu_read_unlock();\n}\n\n/*\n * All poll tw should go through this. Checks for poll events, manages\n * references, does rewait, etc.\n *\n * Returns a negative error on failure. >0 when no action require, which is\n * either spurious wakeup or multishot CQE is served. 0 when it's done with\n * the request, then the mask is stored in req->result.\n */\nstatic int io_poll_check_events(struct io_kiocb *req, bool locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_poll_iocb *poll = io_poll_get_single(req);\n\tint v;\n\n\t/* req->task == current here, checking PF_EXITING is safe */\n\tif (unlikely(req->task->flags & PF_EXITING))\n\t\tio_poll_mark_cancelled(req);\n\n\tdo {\n\t\tv = atomic_read(&req->poll_refs);\n\n\t\t/* tw handler should be the owner, and so have some references */\n\t\tif (WARN_ON_ONCE(!(v & IO_POLL_REF_MASK)))\n\t\t\treturn 0;\n\t\tif (v & IO_POLL_CANCEL_FLAG)\n\t\t\treturn -ECANCELED;\n\n\t\tif (!req->result) {\n\t\t\tstruct poll_table_struct pt = { ._key = req->cflags };\n\n\t\t\tif (unlikely(!io_assign_file(req, IO_URING_F_UNLOCKED)))\n\t\t\t\treq->result = -EBADF;\n\t\t\telse\n\t\t\t\treq->result = vfs_poll(req->file, &pt) & req->cflags;\n\t\t}\n\n\t\t/* multishot, just fill an CQE and proceed */\n\t\tif (req->result && !(req->cflags & EPOLLONESHOT)) {\n\t\t\t__poll_t mask = mangle_poll(req->result & poll->events);\n\t\t\tbool filled;\n\n\t\t\tspin_lock(&ctx->completion_lock);\n\t\t\tfilled = io_fill_cqe_aux(ctx, req->user_data, mask,\n\t\t\t\t\t\t IORING_CQE_F_MORE);\n\t\t\tio_commit_cqring(ctx);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\tif (unlikely(!filled))\n\t\t\t\treturn -ECANCELED;\n\t\t\tio_cqring_ev_posted(ctx);\n\t\t} else if (req->result) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Release all references, retry if someone tried to restart\n\t\t * task_work while we were executing it.\n\t\t */\n\t} while (atomic_sub_return(v & IO_POLL_REF_MASK, &req->poll_refs));\n\n\treturn 1;\n}\n\nstatic void io_poll_task_func(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tret = io_poll_check_events(req, *locked);\n\tif (ret > 0)\n\t\treturn;\n\n\tif (!ret) {\n\t\treq->result = mangle_poll(req->result & req->poll.events);\n\t} else {\n\t\treq->result = ret;\n\t\treq_set_fail(req);\n\t}\n\n\tio_poll_remove_entries(req);\n\tspin_lock(&ctx->completion_lock);\n\thash_del(&req->hash_node);\n\t__io_req_complete_post(req, req->result, 0);\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic void io_apoll_task_func(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tret = io_poll_check_events(req, *locked);\n\tif (ret > 0)\n\t\treturn;\n\n\tio_poll_remove_entries(req);\n\tspin_lock(&ctx->completion_lock);\n\thash_del(&req->hash_node);\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (!ret)\n\t\tio_req_task_submit(req, locked);\n\telse\n\t\tio_req_complete_failed(req, ret);\n}\n\nstatic void __io_poll_execute(struct io_kiocb *req, int mask, int events)\n{\n\treq->result = mask;\n\t/*\n\t * This is useful for poll that is armed on behalf of another\n\t * request, and where the wakeup path could be on a different\n\t * CPU. We want to avoid pulling in req->apoll->events for that\n\t * case.\n\t */\n\treq->cflags = events;\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treq->io_task_work.func = io_poll_task_func;\n\telse\n\t\treq->io_task_work.func = io_apoll_task_func;\n\n\ttrace_io_uring_task_add(req->ctx, req, req->user_data, req->opcode, mask);\n\tio_req_task_work_add(req, false);\n}\n\nstatic inline void io_poll_execute(struct io_kiocb *req, int res, int events)\n{\n\tif (io_poll_get_ownership(req))\n\t\t__io_poll_execute(req, res, events);\n}\n\nstatic void io_poll_cancel_req(struct io_kiocb *req)\n{\n\tio_poll_mark_cancelled(req);\n\t/* kick tw, which should complete the request */\n\tio_poll_execute(req, 0, 0);\n}\n\n#define wqe_to_req(wait)\t((void *)((unsigned long) (wait)->private & ~1))\n#define wqe_is_double(wait)\t((unsigned long) (wait)->private & 1)\n\nstatic int io_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,\n\t\t\tvoid *key)\n{\n\tstruct io_kiocb *req = wqe_to_req(wait);\n\tstruct io_poll_iocb *poll = container_of(wait, struct io_poll_iocb,\n\t\t\t\t\t\t wait);\n\t__poll_t mask = key_to_poll(key);\n\n\tif (unlikely(mask & POLLFREE)) {\n\t\tio_poll_mark_cancelled(req);\n\t\t/* we have to kick tw in case it's not already */\n\t\tio_poll_execute(req, 0, poll->events);\n\n\t\t/*\n\t\t * If the waitqueue is being freed early but someone is already\n\t\t * holds ownership over it, we have to tear down the request as\n\t\t * best we can. That means immediately removing the request from\n\t\t * its waitqueue and preventing all further accesses to the\n\t\t * waitqueue via the request.\n\t\t */\n\t\tlist_del_init(&poll->wait.entry);\n\n\t\t/*\n\t\t * Careful: this *must* be the last step, since as soon\n\t\t * as req->head is NULL'ed out, the request can be\n\t\t * completed and freed, since aio_poll_complete_work()\n\t\t * will no longer need to take the waitqueue lock.\n\t\t */\n\t\tsmp_store_release(&poll->head, NULL);\n\t\treturn 1;\n\t}\n\n\t/* for instances that support it check for an event match first */\n\tif (mask && !(mask & poll->events))\n\t\treturn 0;\n\n\tif (io_poll_get_ownership(req)) {\n\t\t/* optional, saves extra locking for removal in tw handler */\n\t\tif (mask && poll->events & EPOLLONESHOT) {\n\t\t\tlist_del_init(&poll->wait.entry);\n\t\t\tpoll->head = NULL;\n\t\t\tif (wqe_is_double(wait))\n\t\t\t\treq->flags &= ~REQ_F_DOUBLE_POLL;\n\t\t\telse\n\t\t\t\treq->flags &= ~REQ_F_SINGLE_POLL;\n\t\t}\n\t\t__io_poll_execute(req, mask, poll->events);\n\t}\n\treturn 1;\n}\n\nstatic void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,\n\t\t\t    struct wait_queue_head *head,\n\t\t\t    struct io_poll_iocb **poll_ptr)\n{\n\tstruct io_kiocb *req = pt->req;\n\tunsigned long wqe_private = (unsigned long) req;\n\n\t/*\n\t * The file being polled uses multiple waitqueues for poll handling\n\t * (e.g. one for read, one for write). Setup a separate io_poll_iocb\n\t * if this happens.\n\t */\n\tif (unlikely(pt->nr_entries)) {\n\t\tstruct io_poll_iocb *first = poll;\n\n\t\t/* double add on the same waitqueue head, ignore */\n\t\tif (first->head == head)\n\t\t\treturn;\n\t\t/* already have a 2nd entry, fail a third attempt */\n\t\tif (*poll_ptr) {\n\t\t\tif ((*poll_ptr)->head == head)\n\t\t\t\treturn;\n\t\t\tpt->error = -EINVAL;\n\t\t\treturn;\n\t\t}\n\n\t\tpoll = kmalloc(sizeof(*poll), GFP_ATOMIC);\n\t\tif (!poll) {\n\t\t\tpt->error = -ENOMEM;\n\t\t\treturn;\n\t\t}\n\t\t/* mark as double wq entry */\n\t\twqe_private |= 1;\n\t\treq->flags |= REQ_F_DOUBLE_POLL;\n\t\tio_init_poll_iocb(poll, first->events, first->wait.func);\n\t\t*poll_ptr = poll;\n\t\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\t\treq->flags |= REQ_F_ASYNC_DATA;\n\t}\n\n\treq->flags |= REQ_F_SINGLE_POLL;\n\tpt->nr_entries++;\n\tpoll->head = head;\n\tpoll->wait.private = (void *) wqe_private;\n\n\tif (poll->events & EPOLLEXCLUSIVE)\n\t\tadd_wait_queue_exclusive(head, &poll->wait);\n\telse\n\t\tadd_wait_queue(head, &poll->wait);\n}\n\nstatic void io_poll_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\t\t       struct poll_table_struct *p)\n{\n\tstruct io_poll_table *pt = container_of(p, struct io_poll_table, pt);\n\n\t__io_queue_proc(&pt->req->poll, pt, head,\n\t\t\t(struct io_poll_iocb **) &pt->req->async_data);\n}\n\nstatic int __io_arm_poll_handler(struct io_kiocb *req,\n\t\t\t\t struct io_poll_iocb *poll,\n\t\t\t\t struct io_poll_table *ipt, __poll_t mask)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint v;\n\n\tINIT_HLIST_NODE(&req->hash_node);\n\tio_init_poll_iocb(poll, mask, io_poll_wake);\n\tpoll->file = req->file;\n\n\tipt->pt._key = mask;\n\tipt->req = req;\n\tipt->error = 0;\n\tipt->nr_entries = 0;\n\n\t/*\n\t * Take the ownership to delay any tw execution up until we're done\n\t * with poll arming. see io_poll_get_ownership().\n\t */\n\tatomic_set(&req->poll_refs, 1);\n\tmask = vfs_poll(req->file, &ipt->pt) & poll->events;\n\n\tif (mask && (poll->events & EPOLLONESHOT)) {\n\t\tio_poll_remove_entries(req);\n\t\t/* no one else has access to the req, forget about the ref */\n\t\treturn mask;\n\t}\n\tif (!mask && unlikely(ipt->error || !ipt->nr_entries)) {\n\t\tio_poll_remove_entries(req);\n\t\tif (!ipt->error)\n\t\t\tipt->error = -EINVAL;\n\t\treturn 0;\n\t}\n\n\tspin_lock(&ctx->completion_lock);\n\tio_poll_req_insert(req);\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (mask) {\n\t\t/* can't multishot if failed, just queue the event we've got */\n\t\tif (unlikely(ipt->error || !ipt->nr_entries))\n\t\t\tpoll->events |= EPOLLONESHOT;\n\t\t__io_poll_execute(req, mask, poll->events);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release ownership. If someone tried to queue a tw while it was\n\t * locked, kick it off for them.\n\t */\n\tv = atomic_dec_return(&req->poll_refs);\n\tif (unlikely(v & IO_POLL_REF_MASK))\n\t\t__io_poll_execute(req, 0, poll->events);\n\treturn 0;\n}\n\nstatic void io_async_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\t\t       struct poll_table_struct *p)\n{\n\tstruct io_poll_table *pt = container_of(p, struct io_poll_table, pt);\n\tstruct async_poll *apoll = pt->req->apoll;\n\n\t__io_queue_proc(&apoll->poll, pt, head, &apoll->double_poll);\n}\n\nenum {\n\tIO_APOLL_OK,\n\tIO_APOLL_ABORTED,\n\tIO_APOLL_READY\n};\n\nstatic int io_arm_poll_handler(struct io_kiocb *req, unsigned issue_flags)\n{\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct async_poll *apoll;\n\tstruct io_poll_table ipt;\n\t__poll_t mask = EPOLLONESHOT | POLLERR | POLLPRI;\n\tint ret;\n\n\tif (!def->pollin && !def->pollout)\n\t\treturn IO_APOLL_ABORTED;\n\tif (!file_can_poll(req->file) || (req->flags & REQ_F_POLLED))\n\t\treturn IO_APOLL_ABORTED;\n\n\tif (def->pollin) {\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t\t/* If reading from MSG_ERRQUEUE using recvmsg, ignore POLLIN */\n\t\tif ((req->opcode == IORING_OP_RECVMSG) &&\n\t\t    (req->sr_msg.msg_flags & MSG_ERRQUEUE))\n\t\t\tmask &= ~POLLIN;\n\t} else {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\tif (def->poll_exclusive)\n\t\tmask |= EPOLLEXCLUSIVE;\n\tif (!(issue_flags & IO_URING_F_UNLOCKED) &&\n\t    !list_empty(&ctx->apoll_cache)) {\n\t\tapoll = list_first_entry(&ctx->apoll_cache, struct async_poll,\n\t\t\t\t\t\tpoll.wait.entry);\n\t\tlist_del_init(&apoll->poll.wait.entry);\n\t} else {\n\t\tapoll = kmalloc(sizeof(*apoll), GFP_ATOMIC);\n\t\tif (unlikely(!apoll))\n\t\t\treturn IO_APOLL_ABORTED;\n\t}\n\tapoll->double_poll = NULL;\n\treq->apoll = apoll;\n\treq->flags |= REQ_F_POLLED;\n\tipt.pt._qproc = io_async_queue_proc;\n\n\tio_kbuf_recycle(req, issue_flags);\n\n\tret = __io_arm_poll_handler(req, &apoll->poll, &ipt, mask);\n\tif (ret || ipt.error)\n\t\treturn ret ? IO_APOLL_READY : IO_APOLL_ABORTED;\n\n\ttrace_io_uring_poll_arm(ctx, req, req->user_data, req->opcode,\n\t\t\t\tmask, apoll->poll.events);\n\treturn IO_APOLL_OK;\n}\n\n/*\n * Returns true if we found and killed one or more poll requests\n */\nstatic __cold bool io_poll_remove_all(struct io_ring_ctx *ctx,\n\t\t\t\t      struct task_struct *tsk, bool cancel_all)\n{\n\tstruct hlist_node *tmp;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\tint i;\n\n\tspin_lock(&ctx->completion_lock);\n\tfor (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {\n\t\tstruct hlist_head *list;\n\n\t\tlist = &ctx->cancel_hash[i];\n\t\thlist_for_each_entry_safe(req, tmp, list, hash_node) {\n\t\t\tif (io_match_task_safe(req, tsk, cancel_all)) {\n\t\t\t\thlist_del_init(&req->hash_node);\n\t\t\t\tio_poll_cancel_req(req);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\treturn found;\n}\n\nstatic struct io_kiocb *io_poll_find(struct io_ring_ctx *ctx, __u64 sqe_addr,\n\t\t\t\t     bool poll_only)\n\t__must_hold(&ctx->completion_lock)\n{\n\tstruct hlist_head *list;\n\tstruct io_kiocb *req;\n\n\tlist = &ctx->cancel_hash[hash_long(sqe_addr, ctx->cancel_hash_bits)];\n\thlist_for_each_entry(req, list, hash_node) {\n\t\tif (sqe_addr != req->user_data)\n\t\t\tcontinue;\n\t\tif (poll_only && req->opcode != IORING_OP_POLL_ADD)\n\t\t\tcontinue;\n\t\treturn req;\n\t}\n\treturn NULL;\n}\n\nstatic bool io_poll_disarm(struct io_kiocb *req)\n\t__must_hold(&ctx->completion_lock)\n{\n\tif (!io_poll_get_ownership(req))\n\t\treturn false;\n\tio_poll_remove_entries(req);\n\thash_del(&req->hash_node);\n\treturn true;\n}\n\nstatic int io_poll_cancel(struct io_ring_ctx *ctx, __u64 sqe_addr,\n\t\t\t  bool poll_only)\n\t__must_hold(&ctx->completion_lock)\n{\n\tstruct io_kiocb *req = io_poll_find(ctx, sqe_addr, poll_only);\n\n\tif (!req)\n\t\treturn -ENOENT;\n\tio_poll_cancel_req(req);\n\treturn 0;\n}\n\nstatic __poll_t io_poll_parse_events(const struct io_uring_sqe *sqe,\n\t\t\t\t     unsigned int flags)\n{\n\tu32 events;\n\n\tevents = READ_ONCE(sqe->poll32_events);\n#ifdef __BIG_ENDIAN\n\tevents = swahw32(events);\n#endif\n\tif (!(flags & IORING_POLL_ADD_MULTI))\n\t\tevents |= EPOLLONESHOT;\n\treturn demangle_poll(events) | (events & (EPOLLEXCLUSIVE|EPOLLONESHOT));\n}\n\nstatic int io_poll_update_prep(struct io_kiocb *req,\n\t\t\t       const struct io_uring_sqe *sqe)\n{\n\tstruct io_poll_update *upd = &req->poll_update;\n\tu32 flags;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->len);\n\tif (flags & ~(IORING_POLL_UPDATE_EVENTS | IORING_POLL_UPDATE_USER_DATA |\n\t\t      IORING_POLL_ADD_MULTI))\n\t\treturn -EINVAL;\n\t/* meaningless without update */\n\tif (flags == IORING_POLL_ADD_MULTI)\n\t\treturn -EINVAL;\n\n\tupd->old_user_data = READ_ONCE(sqe->addr);\n\tupd->update_events = flags & IORING_POLL_UPDATE_EVENTS;\n\tupd->update_user_data = flags & IORING_POLL_UPDATE_USER_DATA;\n\n\tupd->new_user_data = READ_ONCE(sqe->off);\n\tif (!upd->update_user_data && upd->new_user_data)\n\t\treturn -EINVAL;\n\tif (upd->update_events)\n\t\tupd->events = io_poll_parse_events(sqe, flags);\n\telse if (sqe->poll32_events)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int io_poll_add_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_poll_iocb *poll = &req->poll;\n\tu32 flags;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->off || sqe->addr)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->len);\n\tif (flags & ~IORING_POLL_ADD_MULTI)\n\t\treturn -EINVAL;\n\tif ((flags & IORING_POLL_ADD_MULTI) && (req->flags & REQ_F_CQE_SKIP))\n\t\treturn -EINVAL;\n\n\tio_req_set_refcount(req);\n\treq->cflags = poll->events = io_poll_parse_events(sqe, flags);\n\treturn 0;\n}\n\nstatic int io_poll_add(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_poll_iocb *poll = &req->poll;\n\tstruct io_poll_table ipt;\n\tint ret;\n\n\tipt.pt._qproc = io_poll_queue_proc;\n\n\tret = __io_arm_poll_handler(req, &req->poll, &ipt, poll->events);\n\tret = ret ?: ipt.error;\n\tif (ret)\n\t\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_poll_update(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *preq;\n\tint ret2, ret = 0;\n\tbool locked;\n\n\tspin_lock(&ctx->completion_lock);\n\tpreq = io_poll_find(ctx, req->poll_update.old_user_data, true);\n\tif (!preq || !io_poll_disarm(preq)) {\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tret = preq ? -EALREADY : -ENOENT;\n\t\tgoto out;\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (req->poll_update.update_events || req->poll_update.update_user_data) {\n\t\t/* only mask one event flags, keep behavior flags */\n\t\tif (req->poll_update.update_events) {\n\t\t\tpreq->poll.events &= ~0xffff;\n\t\t\tpreq->poll.events |= req->poll_update.events & 0xffff;\n\t\t\tpreq->poll.events |= IO_POLL_UNMASK;\n\t\t}\n\t\tif (req->poll_update.update_user_data)\n\t\t\tpreq->user_data = req->poll_update.new_user_data;\n\n\t\tret2 = io_poll_add(preq, issue_flags);\n\t\t/* successfully updated, don't complete poll request */\n\t\tif (!ret2)\n\t\t\tgoto out;\n\t}\n\n\treq_set_fail(preq);\n\tpreq->result = -ECANCELED;\n\tlocked = !(issue_flags & IO_URING_F_UNLOCKED);\n\tio_req_task_complete(preq, &locked);\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t/* complete update request, we're done with it */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic enum hrtimer_restart io_timeout_fn(struct hrtimer *timer)\n{\n\tstruct io_timeout_data *data = container_of(timer,\n\t\t\t\t\t\tstruct io_timeout_data, timer);\n\tstruct io_kiocb *req = data->req;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->timeout_lock, flags);\n\tlist_del_init(&req->timeout.list);\n\tatomic_set(&req->ctx->cq_timeouts,\n\t\tatomic_read(&req->ctx->cq_timeouts) + 1);\n\tspin_unlock_irqrestore(&ctx->timeout_lock, flags);\n\n\tif (!(data->flags & IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treq_set_fail(req);\n\n\treq->result = -ETIME;\n\treq->io_task_work.func = io_req_task_complete;\n\tio_req_task_work_add(req, false);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic struct io_kiocb *io_timeout_extract(struct io_ring_ctx *ctx,\n\t\t\t\t\t   __u64 user_data)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\n\tlist_for_each_entry(req, &ctx->timeout_list, timeout.list) {\n\t\tfound = user_data == req->user_data;\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tio = req->async_data;\n\tif (hrtimer_try_to_cancel(&io->timer) == -1)\n\t\treturn ERR_PTR(-EALREADY);\n\tlist_del_init(&req->timeout.list);\n\treturn req;\n}\n\nstatic int io_timeout_cancel(struct io_ring_ctx *ctx, __u64 user_data)\n\t__must_hold(&ctx->completion_lock)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_kiocb *req = io_timeout_extract(ctx, user_data);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\tio_req_task_queue_fail(req, -ECANCELED);\n\treturn 0;\n}\n\nstatic clockid_t io_timeout_get_clock(struct io_timeout_data *data)\n{\n\tswitch (data->flags & IORING_TIMEOUT_CLOCK_MASK) {\n\tcase IORING_TIMEOUT_BOOTTIME:\n\t\treturn CLOCK_BOOTTIME;\n\tcase IORING_TIMEOUT_REALTIME:\n\t\treturn CLOCK_REALTIME;\n\tdefault:\n\t\t/* can't happen, vetted at prep time */\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase 0:\n\t\treturn CLOCK_MONOTONIC;\n\t}\n}\n\nstatic int io_linked_timeout_update(struct io_ring_ctx *ctx, __u64 user_data,\n\t\t\t\t    struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\n\tlist_for_each_entry(req, &ctx->ltimeout_list, timeout.list) {\n\t\tfound = user_data == req->user_data;\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\tio = req->async_data;\n\tif (hrtimer_try_to_cancel(&io->timer) == -1)\n\t\treturn -EALREADY;\n\thrtimer_init(&io->timer, io_timeout_get_clock(io), mode);\n\tio->timer.function = io_link_timeout_fn;\n\thrtimer_start(&io->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;\n}\n\nstatic int io_timeout_update(struct io_ring_ctx *ctx, __u64 user_data,\n\t\t\t     struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_kiocb *req = io_timeout_extract(ctx, user_data);\n\tstruct io_timeout_data *data;\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->timeout.off = 0; /* noseq */\n\tdata = req->async_data;\n\tlist_add_tail(&req->timeout.list, &ctx->timeout_list);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), mode);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;\n}\n\nstatic int io_timeout_remove_prep(struct io_kiocb *req,\n\t\t\t\t  const struct io_uring_sqe *sqe)\n{\n\tstruct io_timeout_rem *tr = &req->timeout_rem;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttr->ltimeout = false;\n\ttr->addr = READ_ONCE(sqe->addr);\n\ttr->flags = READ_ONCE(sqe->timeout_flags);\n\tif (tr->flags & IORING_TIMEOUT_UPDATE_MASK) {\n\t\tif (hweight32(tr->flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\t\treturn -EINVAL;\n\t\tif (tr->flags & IORING_LINK_TIMEOUT_UPDATE)\n\t\t\ttr->ltimeout = true;\n\t\tif (tr->flags & ~(IORING_TIMEOUT_UPDATE_MASK|IORING_TIMEOUT_ABS))\n\t\t\treturn -EINVAL;\n\t\tif (get_timespec64(&tr->ts, u64_to_user_ptr(sqe->addr2)))\n\t\t\treturn -EFAULT;\n\t\tif (tr->ts.tv_sec < 0 || tr->ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\t} else if (tr->flags) {\n\t\t/* timeout removal doesn't support flags */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline enum hrtimer_mode io_translate_timeout_mode(unsigned int flags)\n{\n\treturn (flags & IORING_TIMEOUT_ABS) ? HRTIMER_MODE_ABS\n\t\t\t\t\t    : HRTIMER_MODE_REL;\n}\n\n/*\n * Remove or update an existing timeout command\n */\nstatic int io_timeout_remove(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_timeout_rem *tr = &req->timeout_rem;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tif (!(req->timeout_rem.flags & IORING_TIMEOUT_UPDATE)) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tret = io_timeout_cancel(ctx, tr->addr);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t\tspin_unlock(&ctx->completion_lock);\n\t} else {\n\t\tenum hrtimer_mode mode = io_translate_timeout_mode(tr->flags);\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tif (tr->ltimeout)\n\t\t\tret = io_linked_timeout_update(ctx, tr->addr, &tr->ts, mode);\n\t\telse\n\t\t\tret = io_timeout_update(ctx, tr->addr, &tr->ts, mode);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t}\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete_post(req, ret, 0);\n\treturn 0;\n}\n\nstatic int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\t/* more than one clock specified is invalid, obviously */\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;\n}\n\nstatic int io_timeout(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_timeout_data *data = req->async_data;\n\tstruct list_head *entry;\n\tu32 tail, off = req->timeout.off;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\n\t/*\n\t * sqe->off holds how many events that need to occur for this\n\t * timeout event to be satisfied. If it isn't set, then this is\n\t * a pure timeout request, sequence isn't used.\n\t */\n\tif (io_is_timeout_noseq(req)) {\n\t\tentry = ctx->timeout_list.prev;\n\t\tgoto add;\n\t}\n\n\ttail = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\treq->timeout.target_seq = tail + off;\n\n\t/* Update the last seq here in case io_flush_timeouts() hasn't.\n\t * This is safe because ->completion_lock is held, and submissions\n\t * and completions are never mixed in the same ->completion_lock section.\n\t */\n\tctx->cq_last_tm_flush = tail;\n\n\t/*\n\t * Insertion sort, ensuring the first entry in the list is always\n\t * the one we need first.\n\t */\n\tlist_for_each_prev(entry, &ctx->timeout_list) {\n\t\tstruct io_kiocb *nxt = list_entry(entry, struct io_kiocb,\n\t\t\t\t\t\t  timeout.list);\n\n\t\tif (io_is_timeout_noseq(nxt))\n\t\t\tcontinue;\n\t\t/* nxt.seq is behind @tail, otherwise would've been completed */\n\t\tif (off >= nxt->timeout.target_seq - tail)\n\t\t\tbreak;\n\t}\nadd:\n\tlist_add(&req->timeout.list, entry);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(data->ts), data->mode);\n\tspin_unlock_irq(&ctx->timeout_lock);\n\treturn 0;\n}\n\nstruct io_cancel_data {\n\tstruct io_ring_ctx *ctx;\n\tu64 user_data;\n};\n\nstatic bool io_cancel_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tstruct io_cancel_data *cd = data;\n\n\treturn req->ctx == cd->ctx && req->user_data == cd->user_data;\n}\n\nstatic int io_async_cancel_one(struct io_uring_task *tctx, u64 user_data,\n\t\t\t       struct io_ring_ctx *ctx)\n{\n\tstruct io_cancel_data data = { .ctx = ctx, .user_data = user_data, };\n\tenum io_wq_cancel cancel_ret;\n\tint ret = 0;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -ENOENT;\n\n\tcancel_ret = io_wq_cancel_cb(tctx->io_wq, io_cancel_cb, &data, false);\n\tswitch (cancel_ret) {\n\tcase IO_WQ_CANCEL_OK:\n\t\tret = 0;\n\t\tbreak;\n\tcase IO_WQ_CANCEL_RUNNING:\n\t\tret = -EALREADY;\n\t\tbreak;\n\tcase IO_WQ_CANCEL_NOTFOUND:\n\t\tret = -ENOENT;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int io_try_cancel_userdata(struct io_kiocb *req, u64 sqe_addr)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tWARN_ON_ONCE(!io_wq_current_is_worker() && req->task != current);\n\n\tret = io_async_cancel_one(req->task->io_uring, sqe_addr, ctx);\n\t/*\n\t * Fall-through even for -EALREADY, as we may have poll armed\n\t * that need unarming.\n\t */\n\tif (!ret)\n\t\treturn 0;\n\n\tspin_lock(&ctx->completion_lock);\n\tret = io_poll_cancel(ctx, sqe_addr, false);\n\tif (ret != -ENOENT)\n\t\tgoto out;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\tret = io_timeout_cancel(ctx, sqe_addr);\n\tspin_unlock_irq(&ctx->timeout_lock);\nout:\n\tspin_unlock(&ctx->completion_lock);\n\treturn ret;\n}\n\nstatic int io_async_cancel_prep(struct io_kiocb *req,\n\t\t\t\tconst struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->len || sqe->cancel_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\treq->cancel.addr = READ_ONCE(sqe->addr);\n\treturn 0;\n}\n\nstatic int io_async_cancel(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tu64 sqe_addr = req->cancel.addr;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\tret = io_try_cancel_userdata(req, sqe_addr);\n\tif (ret != -ENOENT)\n\t\tgoto done;\n\n\t/* slow path, try all io-wq's */\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = -ENOENT;\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\tret = io_async_cancel_one(tctx, req->cancel.addr, ctx);\n\t\tif (ret != -ENOENT)\n\t\t\tbreak;\n\t}\n\tio_ring_submit_unlock(ctx, needs_lock);\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete_post(req, ret, 0);\n\treturn 0;\n}\n\nstatic int io_rsrc_update_prep(struct io_kiocb *req,\n\t\t\t\tconst struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\treq->rsrc_update.offset = READ_ONCE(sqe->off);\n\treq->rsrc_update.nr_args = READ_ONCE(sqe->len);\n\tif (!req->rsrc_update.nr_args)\n\t\treturn -EINVAL;\n\treq->rsrc_update.arg = READ_ONCE(sqe->addr);\n\treturn 0;\n}\n\nstatic int io_files_update(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_uring_rsrc_update2 up;\n\tint ret;\n\n\tup.offset = req->rsrc_update.offset;\n\tup.data = req->rsrc_update.arg;\n\tup.nr = 0;\n\tup.tags = 0;\n\tup.resv = 0;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = __io_register_rsrc_update(ctx, IORING_RSRC_FILE,\n\t\t\t\t\t&up, req->rsrc_update.nr_args);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_req_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\treturn 0;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\tcase IORING_OP_READ:\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\tcase IORING_OP_WRITE:\n\t\treturn io_prep_rw(req, sqe);\n\tcase IORING_OP_POLL_ADD:\n\t\treturn io_poll_add_prep(req, sqe);\n\tcase IORING_OP_POLL_REMOVE:\n\t\treturn io_poll_update_prep(req, sqe);\n\tcase IORING_OP_FSYNC:\n\t\treturn io_fsync_prep(req, sqe);\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\treturn io_sfr_prep(req, sqe);\n\tcase IORING_OP_SENDMSG:\n\tcase IORING_OP_SEND:\n\t\treturn io_sendmsg_prep(req, sqe);\n\tcase IORING_OP_RECVMSG:\n\tcase IORING_OP_RECV:\n\t\treturn io_recvmsg_prep(req, sqe);\n\tcase IORING_OP_CONNECT:\n\t\treturn io_connect_prep(req, sqe);\n\tcase IORING_OP_TIMEOUT:\n\t\treturn io_timeout_prep(req, sqe, false);\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\treturn io_timeout_remove_prep(req, sqe);\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\treturn io_async_cancel_prep(req, sqe);\n\tcase IORING_OP_LINK_TIMEOUT:\n\t\treturn io_timeout_prep(req, sqe, true);\n\tcase IORING_OP_ACCEPT:\n\t\treturn io_accept_prep(req, sqe);\n\tcase IORING_OP_FALLOCATE:\n\t\treturn io_fallocate_prep(req, sqe);\n\tcase IORING_OP_OPENAT:\n\t\treturn io_openat_prep(req, sqe);\n\tcase IORING_OP_CLOSE:\n\t\treturn io_close_prep(req, sqe);\n\tcase IORING_OP_FILES_UPDATE:\n\t\treturn io_rsrc_update_prep(req, sqe);\n\tcase IORING_OP_STATX:\n\t\treturn io_statx_prep(req, sqe);\n\tcase IORING_OP_FADVISE:\n\t\treturn io_fadvise_prep(req, sqe);\n\tcase IORING_OP_MADVISE:\n\t\treturn io_madvise_prep(req, sqe);\n\tcase IORING_OP_OPENAT2:\n\t\treturn io_openat2_prep(req, sqe);\n\tcase IORING_OP_EPOLL_CTL:\n\t\treturn io_epoll_ctl_prep(req, sqe);\n\tcase IORING_OP_SPLICE:\n\t\treturn io_splice_prep(req, sqe);\n\tcase IORING_OP_PROVIDE_BUFFERS:\n\t\treturn io_provide_buffers_prep(req, sqe);\n\tcase IORING_OP_REMOVE_BUFFERS:\n\t\treturn io_remove_buffers_prep(req, sqe);\n\tcase IORING_OP_TEE:\n\t\treturn io_tee_prep(req, sqe);\n\tcase IORING_OP_SHUTDOWN:\n\t\treturn io_shutdown_prep(req, sqe);\n\tcase IORING_OP_RENAMEAT:\n\t\treturn io_renameat_prep(req, sqe);\n\tcase IORING_OP_UNLINKAT:\n\t\treturn io_unlinkat_prep(req, sqe);\n\tcase IORING_OP_MKDIRAT:\n\t\treturn io_mkdirat_prep(req, sqe);\n\tcase IORING_OP_SYMLINKAT:\n\t\treturn io_symlinkat_prep(req, sqe);\n\tcase IORING_OP_LINKAT:\n\t\treturn io_linkat_prep(req, sqe);\n\tcase IORING_OP_MSG_RING:\n\t\treturn io_msg_ring_prep(req, sqe);\n\t}\n\n\tprintk_once(KERN_WARNING \"io_uring: unhandled opcode %d\\n\",\n\t\t\treq->opcode);\n\treturn -EINVAL;\n}\n\nstatic int io_req_prep_async(struct io_kiocb *req)\n{\n\tif (!io_op_defs[req->opcode].needs_async_setup)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -EAGAIN;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_READV:\n\t\treturn io_rw_prep_async(req, READ);\n\tcase IORING_OP_WRITEV:\n\t\treturn io_rw_prep_async(req, WRITE);\n\tcase IORING_OP_SENDMSG:\n\t\treturn io_sendmsg_prep_async(req);\n\tcase IORING_OP_RECVMSG:\n\t\treturn io_recvmsg_prep_async(req);\n\tcase IORING_OP_CONNECT:\n\t\treturn io_connect_prep_async(req);\n\t}\n\tprintk_once(KERN_WARNING \"io_uring: prep_async() bad opcode %d\\n\",\n\t\t    req->opcode);\n\treturn -EFAULT;\n}\n\nstatic u32 io_get_sequence(struct io_kiocb *req)\n{\n\tu32 seq = req->ctx->cached_sq_head;\n\n\t/* need original cached_sq_head, but it was increased for each req */\n\tio_for_each_link(req, req)\n\t\tseq--;\n\treturn seq;\n}\n\nstatic __cold void io_drain_req(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_defer_entry *de;\n\tint ret;\n\tu32 seq = io_get_sequence(req);\n\n\t/* Still need defer if there is pending req in defer list. */\n\tspin_lock(&ctx->completion_lock);\n\tif (!req_need_defer(req, seq) && list_empty_careful(&ctx->defer_list)) {\n\t\tspin_unlock(&ctx->completion_lock);\nqueue:\n\t\tctx->drain_active = false;\n\t\tio_req_task_queue(req);\n\t\treturn;\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\n\tret = io_req_prep_async(req);\n\tif (ret) {\nfail:\n\t\tio_req_complete_failed(req, ret);\n\t\treturn;\n\t}\n\tio_prep_async_link(req);\n\tde = kmalloc(sizeof(*de), GFP_KERNEL);\n\tif (!de) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&ctx->completion_lock);\n\tif (!req_need_defer(req, seq) && list_empty(&ctx->defer_list)) {\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tkfree(de);\n\t\tgoto queue;\n\t}\n\n\ttrace_io_uring_defer(ctx, req, req->user_data, req->opcode);\n\tde->req = req;\n\tde->seq = seq;\n\tlist_add_tail(&de->list, &ctx->defer_list);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic void io_clean_op(struct io_kiocb *req)\n{\n\tif (req->flags & REQ_F_BUFFER_SELECTED) {\n\t\tspin_lock(&req->ctx->completion_lock);\n\t\tio_put_kbuf_comp(req);\n\t\tspin_unlock(&req->ctx->completion_lock);\n\t}\n\n\tif (req->flags & REQ_F_NEED_CLEANUP) {\n\t\tswitch (req->opcode) {\n\t\tcase IORING_OP_READV:\n\t\tcase IORING_OP_READ_FIXED:\n\t\tcase IORING_OP_READ:\n\t\tcase IORING_OP_WRITEV:\n\t\tcase IORING_OP_WRITE_FIXED:\n\t\tcase IORING_OP_WRITE: {\n\t\t\tstruct io_async_rw *io = req->async_data;\n\n\t\t\tkfree(io->free_iovec);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IORING_OP_RECVMSG:\n\t\tcase IORING_OP_SENDMSG: {\n\t\t\tstruct io_async_msghdr *io = req->async_data;\n\n\t\t\tkfree(io->free_iov);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IORING_OP_OPENAT:\n\t\tcase IORING_OP_OPENAT2:\n\t\t\tif (req->open.filename)\n\t\t\t\tputname(req->open.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_RENAMEAT:\n\t\t\tputname(req->rename.oldpath);\n\t\t\tputname(req->rename.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_UNLINKAT:\n\t\t\tputname(req->unlink.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_MKDIRAT:\n\t\t\tputname(req->mkdir.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_SYMLINKAT:\n\t\t\tputname(req->symlink.oldpath);\n\t\t\tputname(req->symlink.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_LINKAT:\n\t\t\tputname(req->hardlink.oldpath);\n\t\t\tputname(req->hardlink.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_STATX:\n\t\t\tif (req->statx.filename)\n\t\t\t\tputname(req->statx.filename);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((req->flags & REQ_F_POLLED) && req->apoll) {\n\t\tkfree(req->apoll->double_poll);\n\t\tkfree(req->apoll);\n\t\treq->apoll = NULL;\n\t}\n\tif (req->flags & REQ_F_CREDS)\n\t\tput_cred(req->creds);\n\tif (req->flags & REQ_F_ASYNC_DATA) {\n\t\tkfree(req->async_data);\n\t\treq->async_data = NULL;\n\t}\n\treq->flags &= ~IO_REQ_CLEAN_FLAGS;\n}\n\nstatic bool io_assign_file(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tif (req->file || !io_op_defs[req->opcode].needs_file)\n\t\treturn true;\n\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treq->file = io_file_get_fixed(req, req->work.fd, issue_flags);\n\telse\n\t\treq->file = io_file_get_normal(req, req->work.fd);\n\tif (req->file)\n\t\treturn true;\n\n\treq_set_fail(req);\n\treq->result = -EBADF;\n\treturn false;\n}\n\nstatic int io_issue_sqe(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tconst struct cred *creds = NULL;\n\tint ret;\n\n\tif (unlikely((req->flags & REQ_F_CREDS) && req->creds != current_cred()))\n\t\tcreds = override_creds(req->creds);\n\n\tif (!io_op_defs[req->opcode].audit_skip)\n\t\taudit_uring_entry(req->opcode);\n\tif (unlikely(!io_assign_file(req, issue_flags)))\n\t\treturn -EBADF;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\tret = io_nop(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\tcase IORING_OP_READ:\n\t\tret = io_read(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\tcase IORING_OP_WRITE:\n\t\tret = io_write(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FSYNC:\n\t\tret = io_fsync(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_POLL_ADD:\n\t\tret = io_poll_add(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_POLL_REMOVE:\n\t\tret = io_poll_update(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\tret = io_sync_file_range(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SENDMSG:\n\t\tret = io_sendmsg(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SEND:\n\t\tret = io_send(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RECVMSG:\n\t\tret = io_recvmsg(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RECV:\n\t\tret = io_recv(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT:\n\t\tret = io_timeout(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\tret = io_timeout_remove(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_ACCEPT:\n\t\tret = io_accept(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_CONNECT:\n\t\tret = io_connect(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\tret = io_async_cancel(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FALLOCATE:\n\t\tret = io_fallocate(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_OPENAT:\n\t\tret = io_openat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_CLOSE:\n\t\tret = io_close(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FILES_UPDATE:\n\t\tret = io_files_update(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_STATX:\n\t\tret = io_statx(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FADVISE:\n\t\tret = io_fadvise(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MADVISE:\n\t\tret = io_madvise(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_OPENAT2:\n\t\tret = io_openat2(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_EPOLL_CTL:\n\t\tret = io_epoll_ctl(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SPLICE:\n\t\tret = io_splice(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_PROVIDE_BUFFERS:\n\t\tret = io_provide_buffers(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_REMOVE_BUFFERS:\n\t\tret = io_remove_buffers(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TEE:\n\t\tret = io_tee(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SHUTDOWN:\n\t\tret = io_shutdown(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RENAMEAT:\n\t\tret = io_renameat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_UNLINKAT:\n\t\tret = io_unlinkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MKDIRAT:\n\t\tret = io_mkdirat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SYMLINKAT:\n\t\tret = io_symlinkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_LINKAT:\n\t\tret = io_linkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MSG_RING:\n\t\tret = io_msg_ring(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!io_op_defs[req->opcode].audit_skip)\n\t\taudit_uring_exit(!ret, ret);\n\n\tif (creds)\n\t\trevert_creds(creds);\n\tif (ret)\n\t\treturn ret;\n\t/* If the op doesn't have a file, we're not polling for it */\n\tif ((req->ctx->flags & IORING_SETUP_IOPOLL) && req->file)\n\t\tio_iopoll_req_issued(req, issue_flags);\n\n\treturn 0;\n}\n\nstatic struct io_wq_work *io_wq_free_work(struct io_wq_work *work)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\n\treq = io_put_req_find_next(req);\n\treturn req ? &req->work : NULL;\n}\n\nstatic void io_wq_submit_work(struct io_wq_work *work)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tunsigned int issue_flags = IO_URING_F_UNLOCKED;\n\tbool needs_poll = false;\n\tstruct io_kiocb *timeout;\n\tint ret = 0, err = -ECANCELED;\n\n\t/* one will be dropped by ->io_free_work() after returning to io-wq */\n\tif (!(req->flags & REQ_F_REFCOUNT))\n\t\t__io_req_set_refcount(req, 2);\n\telse\n\t\treq_ref_get(req);\n\n\ttimeout = io_prep_linked_timeout(req);\n\tif (timeout)\n\t\tio_queue_linked_timeout(timeout);\n\n\tif (!io_assign_file(req, issue_flags)) {\n\t\terr = -EBADF;\n\t\twork->flags |= IO_WQ_WORK_CANCEL;\n\t}\n\n\t/* either cancelled or io-wq is dying, so don't touch tctx->iowq */\n\tif (work->flags & IO_WQ_WORK_CANCEL) {\n\t\tio_req_task_queue_fail(req, err);\n\t\treturn;\n\t}\n\n\tif (req->flags & REQ_F_FORCE_ASYNC) {\n\t\tbool opcode_poll = def->pollin || def->pollout;\n\n\t\tif (opcode_poll && file_can_poll(req->file)) {\n\t\t\tneeds_poll = true;\n\t\t\tissue_flags |= IO_URING_F_NONBLOCK;\n\t\t}\n\t}\n\n\tdo {\n\t\tret = io_issue_sqe(req, issue_flags);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\t/*\n\t\t * We can get EAGAIN for iopolled IO even though we're\n\t\t * forcing a sync submission from here, since we can't\n\t\t * wait for request slots on the block side.\n\t\t */\n\t\tif (!needs_poll) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (io_arm_poll_handler(req, issue_flags) == IO_APOLL_OK)\n\t\t\treturn;\n\t\t/* aborted or ready, in either case retry blocking */\n\t\tneeds_poll = false;\n\t\tissue_flags &= ~IO_URING_F_NONBLOCK;\n\t} while (1);\n\n\t/* avoid locking problems by failing it from a clean context */\n\tif (ret)\n\t\tio_req_task_queue_fail(req, ret);\n}\n\nstatic inline struct io_fixed_file *io_fixed_file_slot(struct io_file_table *table,\n\t\t\t\t\t\t       unsigned i)\n{\n\treturn &table->files[i];\n}\n\nstatic inline struct file *io_file_from_index(struct io_ring_ctx *ctx,\n\t\t\t\t\t      int index)\n{\n\tstruct io_fixed_file *slot = io_fixed_file_slot(&ctx->file_table, index);\n\n\treturn (struct file *) (slot->file_ptr & FFS_MASK);\n}\n\nstatic void io_fixed_file_set(struct io_fixed_file *file_slot, struct file *file)\n{\n\tunsigned long file_ptr = (unsigned long) file;\n\n\tfile_ptr |= io_file_get_flags(file);\n\tfile_slot->file_ptr = file_ptr;\n}\n\nstatic inline struct file *io_file_get_fixed(struct io_kiocb *req, int fd,\n\t\t\t\t\t     unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = NULL;\n\tunsigned long file_ptr;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_lock(&ctx->uring_lock);\n\n\tif (unlikely((unsigned int)fd >= ctx->nr_user_files))\n\t\tgoto out;\n\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\tfile = (struct file *) (file_ptr & FFS_MASK);\n\tfile_ptr &= ~FFS_MASK;\n\t/* mask in overlapping REQ_F and FFS bits */\n\treq->flags |= (file_ptr << REQ_F_SUPPORT_NOWAIT_BIT);\n\tio_req_set_rsrc_node(req, ctx, 0);\nout:\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n\treturn file;\n}\n\n/*\n * Drop the file for requeue operations. Only used of req->file is the\n * io_uring descriptor itself.\n */\nstatic void io_drop_inflight_file(struct io_kiocb *req)\n{\n\tif (unlikely(req->flags & REQ_F_INFLIGHT)) {\n\t\tfput(req->file);\n\t\treq->file = NULL;\n\t\treq->flags &= ~REQ_F_INFLIGHT;\n\t}\n}\n\nstatic struct file *io_file_get_normal(struct io_kiocb *req, int fd)\n{\n\tstruct file *file = fget(fd);\n\n\ttrace_io_uring_file_get(req->ctx, req, req->user_data, fd);\n\n\t/* we don't allow fixed io_uring files */\n\tif (file && file->f_op == &io_uring_fops)\n\t\treq->flags |= REQ_F_INFLIGHT;\n\treturn file;\n}\n\nstatic void io_req_task_link_timeout(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_kiocb *prev = req->timeout.prev;\n\tint ret = -ENOENT;\n\n\tif (prev) {\n\t\tif (!(req->task->flags & PF_EXITING))\n\t\t\tret = io_try_cancel_userdata(req, prev->user_data);\n\t\tio_req_complete_post(req, ret ?: -ETIME, 0);\n\t\tio_put_req(prev);\n\t} else {\n\t\tio_req_complete_post(req, -ETIME, 0);\n\t}\n}\n\nstatic enum hrtimer_restart io_link_timeout_fn(struct hrtimer *timer)\n{\n\tstruct io_timeout_data *data = container_of(timer,\n\t\t\t\t\t\tstruct io_timeout_data, timer);\n\tstruct io_kiocb *prev, *req = data->req;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->timeout_lock, flags);\n\tprev = req->timeout.head;\n\treq->timeout.head = NULL;\n\n\t/*\n\t * We don't expect the list to be empty, that will only happen if we\n\t * race with the completion of the linked work.\n\t */\n\tif (prev) {\n\t\tio_remove_next_linked(prev);\n\t\tif (!req_ref_inc_not_zero(prev))\n\t\t\tprev = NULL;\n\t}\n\tlist_del(&req->timeout.list);\n\treq->timeout.prev = prev;\n\tspin_unlock_irqrestore(&ctx->timeout_lock, flags);\n\n\treq->io_task_work.func = io_req_task_link_timeout;\n\tio_req_task_work_add(req, false);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void io_queue_linked_timeout(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\t/*\n\t * If the back reference is NULL, then our linked request finished\n\t * before we got a chance to setup the timer\n\t */\n\tif (req->timeout.head) {\n\t\tstruct io_timeout_data *data = req->async_data;\n\n\t\tdata->timer.function = io_link_timeout_fn;\n\t\thrtimer_start(&data->timer, timespec64_to_ktime(data->ts),\n\t\t\t\tdata->mode);\n\t\tlist_add_tail(&req->timeout.list, &ctx->ltimeout_list);\n\t}\n\tspin_unlock_irq(&ctx->timeout_lock);\n\t/* drop submission reference */\n\tio_put_req(req);\n}\n\nstatic void io_queue_sqe_arm_apoll(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tstruct io_kiocb *linked_timeout = io_prep_linked_timeout(req);\n\n\tswitch (io_arm_poll_handler(req, 0)) {\n\tcase IO_APOLL_READY:\n\t\tio_req_task_queue(req);\n\t\tbreak;\n\tcase IO_APOLL_ABORTED:\n\t\t/*\n\t\t * Queued up for async execution, worker will release\n\t\t * submit reference when the iocb is actually submitted.\n\t\t */\n\t\tio_queue_async_work(req, NULL);\n\t\tbreak;\n\tcase IO_APOLL_OK:\n\t\tbreak;\n\t}\n\n\tif (linked_timeout)\n\t\tio_queue_linked_timeout(linked_timeout);\n}\n\nstatic inline void __io_queue_sqe(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tstruct io_kiocb *linked_timeout;\n\tint ret;\n\n\tret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);\n\n\tif (req->flags & REQ_F_COMPLETE_INLINE) {\n\t\tio_req_add_compl_list(req);\n\t\treturn;\n\t}\n\t/*\n\t * We async punt it if the file wasn't marked NOWAIT, or if the file\n\t * doesn't support non-blocking read/write attempts\n\t */\n\tif (likely(!ret)) {\n\t\tlinked_timeout = io_prep_linked_timeout(req);\n\t\tif (linked_timeout)\n\t\t\tio_queue_linked_timeout(linked_timeout);\n\t} else if (ret == -EAGAIN && !(req->flags & REQ_F_NOWAIT)) {\n\t\tio_queue_sqe_arm_apoll(req);\n\t} else {\n\t\tio_req_complete_failed(req, ret);\n\t}\n}\n\nstatic void io_queue_sqe_fallback(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tif (req->flags & REQ_F_FAIL) {\n\t\tio_req_complete_fail_submit(req);\n\t} else if (unlikely(req->ctx->drain_active)) {\n\t\tio_drain_req(req);\n\t} else {\n\t\tint ret = io_req_prep_async(req);\n\n\t\tif (unlikely(ret))\n\t\t\tio_req_complete_failed(req, ret);\n\t\telse\n\t\t\tio_queue_async_work(req, NULL);\n\t}\n}\n\nstatic inline void io_queue_sqe(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tif (likely(!(req->flags & (REQ_F_FORCE_ASYNC | REQ_F_FAIL))))\n\t\t__io_queue_sqe(req);\n\telse\n\t\tio_queue_sqe_fallback(req);\n}\n\n/*\n * Check SQE restrictions (opcode and flags).\n *\n * Returns 'true' if SQE is allowed, 'false' otherwise.\n */\nstatic inline bool io_check_restriction(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct io_kiocb *req,\n\t\t\t\t\tunsigned int sqe_flags)\n{\n\tif (!test_bit(req->opcode, ctx->restrictions.sqe_op))\n\t\treturn false;\n\n\tif ((sqe_flags & ctx->restrictions.sqe_flags_required) !=\n\t    ctx->restrictions.sqe_flags_required)\n\t\treturn false;\n\n\tif (sqe_flags & ~(ctx->restrictions.sqe_flags_allowed |\n\t\t\t  ctx->restrictions.sqe_flags_required))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void io_init_req_drain(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *head = ctx->submit_state.link.head;\n\n\tctx->drain_active = true;\n\tif (head) {\n\t\t/*\n\t\t * If we need to drain a request in the middle of a link, drain\n\t\t * the head request and the next request/link after the current\n\t\t * link. Considering sequential execution of links,\n\t\t * REQ_F_IO_DRAIN will be maintained for every request of our\n\t\t * link.\n\t\t */\n\t\thead->flags |= REQ_F_IO_DRAIN | REQ_F_FORCE_ASYNC;\n\t\tctx->drain_next = true;\n\t}\n}\n\nstatic int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,\n\t\t       const struct io_uring_sqe *sqe)\n\t__must_hold(&ctx->uring_lock)\n{\n\tunsigned int sqe_flags;\n\tint personality;\n\tu8 opcode;\n\n\t/* req is partially pre-initialised, see io_preinit_req() */\n\treq->opcode = opcode = READ_ONCE(sqe->opcode);\n\t/* same numerical values with corresponding REQ_F_*, safe to copy */\n\treq->flags = sqe_flags = READ_ONCE(sqe->flags);\n\treq->user_data = READ_ONCE(sqe->user_data);\n\treq->file = NULL;\n\treq->fixed_rsrc_refs = NULL;\n\treq->task = current;\n\n\tif (unlikely(opcode >= IORING_OP_LAST)) {\n\t\treq->opcode = 0;\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(sqe_flags & ~SQE_COMMON_FLAGS)) {\n\t\t/* enforce forwards compatibility on users */\n\t\tif (sqe_flags & ~SQE_VALID_FLAGS)\n\t\t\treturn -EINVAL;\n\t\tif ((sqe_flags & IOSQE_BUFFER_SELECT) &&\n\t\t    !io_op_defs[opcode].buffer_select)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (sqe_flags & IOSQE_CQE_SKIP_SUCCESS)\n\t\t\tctx->drain_disabled = true;\n\t\tif (sqe_flags & IOSQE_IO_DRAIN) {\n\t\t\tif (ctx->drain_disabled)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tio_init_req_drain(req);\n\t\t}\n\t}\n\tif (unlikely(ctx->restricted || ctx->drain_active || ctx->drain_next)) {\n\t\tif (ctx->restricted && !io_check_restriction(ctx, req, sqe_flags))\n\t\t\treturn -EACCES;\n\t\t/* knock it to the slow queue path, will be drained there */\n\t\tif (ctx->drain_active)\n\t\t\treq->flags |= REQ_F_FORCE_ASYNC;\n\t\t/* if there is no link, we're at \"next\" request and need to drain */\n\t\tif (unlikely(ctx->drain_next) && !ctx->submit_state.link.head) {\n\t\t\tctx->drain_next = false;\n\t\t\tctx->drain_active = true;\n\t\t\treq->flags |= REQ_F_IO_DRAIN | REQ_F_FORCE_ASYNC;\n\t\t}\n\t}\n\n\tif (io_op_defs[opcode].needs_file) {\n\t\tstruct io_submit_state *state = &ctx->submit_state;\n\n\t\treq->work.fd = READ_ONCE(sqe->fd);\n\n\t\t/*\n\t\t * Plug now if we have more than 2 IO left after this, and the\n\t\t * target is potentially a read/write to block based storage.\n\t\t */\n\t\tif (state->need_plug && io_op_defs[opcode].plug) {\n\t\t\tstate->plug_started = true;\n\t\t\tstate->need_plug = false;\n\t\t\tblk_start_plug_nr_ios(&state->plug, state->submit_nr);\n\t\t}\n\t}\n\n\tpersonality = READ_ONCE(sqe->personality);\n\tif (personality) {\n\t\tint ret;\n\n\t\treq->creds = xa_load(&ctx->personalities, personality);\n\t\tif (!req->creds)\n\t\t\treturn -EINVAL;\n\t\tget_cred(req->creds);\n\t\tret = security_uring_override_creds(req->creds);\n\t\tif (ret) {\n\t\t\tput_cred(req->creds);\n\t\t\treturn ret;\n\t\t}\n\t\treq->flags |= REQ_F_CREDS;\n\t}\n\n\treturn io_req_prep(req, sqe);\n}\n\nstatic int io_submit_sqe(struct io_ring_ctx *ctx, struct io_kiocb *req,\n\t\t\t const struct io_uring_sqe *sqe)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_submit_link *link = &ctx->submit_state.link;\n\tint ret;\n\n\tret = io_init_req(ctx, req, sqe);\n\tif (unlikely(ret)) {\n\t\ttrace_io_uring_req_failed(sqe, ctx, req, ret);\n\n\t\t/* fail even hard links since we don't submit */\n\t\tif (link->head) {\n\t\t\t/*\n\t\t\t * we can judge a link req is failed or cancelled by if\n\t\t\t * REQ_F_FAIL is set, but the head is an exception since\n\t\t\t * it may be set REQ_F_FAIL because of other req's failure\n\t\t\t * so let's leverage req->result to distinguish if a head\n\t\t\t * is set REQ_F_FAIL because of its failure or other req's\n\t\t\t * failure so that we can set the correct ret code for it.\n\t\t\t * init result here to avoid affecting the normal path.\n\t\t\t */\n\t\t\tif (!(link->head->flags & REQ_F_FAIL))\n\t\t\t\treq_fail_link_node(link->head, -ECANCELED);\n\t\t} else if (!(req->flags & (REQ_F_LINK | REQ_F_HARDLINK))) {\n\t\t\t/*\n\t\t\t * the current req is a normal req, we should return\n\t\t\t * error and thus break the submittion loop.\n\t\t\t */\n\t\t\tio_req_complete_failed(req, ret);\n\t\t\treturn ret;\n\t\t}\n\t\treq_fail_link_node(req, ret);\n\t}\n\n\t/* don't need @sqe from now on */\n\ttrace_io_uring_submit_sqe(ctx, req, req->user_data, req->opcode,\n\t\t\t\t  req->flags, true,\n\t\t\t\t  ctx->flags & IORING_SETUP_SQPOLL);\n\n\t/*\n\t * If we already have a head request, queue this one for async\n\t * submittal once the head completes. If we don't have a head but\n\t * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be\n\t * submitted sync once the chain is complete. If none of those\n\t * conditions are true (normal request), then just queue it.\n\t */\n\tif (link->head) {\n\t\tstruct io_kiocb *head = link->head;\n\n\t\tif (!(req->flags & REQ_F_FAIL)) {\n\t\t\tret = io_req_prep_async(req);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\treq_fail_link_node(req, ret);\n\t\t\t\tif (!(head->flags & REQ_F_FAIL))\n\t\t\t\t\treq_fail_link_node(head, -ECANCELED);\n\t\t\t}\n\t\t}\n\t\ttrace_io_uring_link(ctx, req, head);\n\t\tlink->last->link = req;\n\t\tlink->last = req;\n\n\t\tif (req->flags & (REQ_F_LINK | REQ_F_HARDLINK))\n\t\t\treturn 0;\n\t\t/* last request of a link, enqueue the link */\n\t\tlink->head = NULL;\n\t\treq = head;\n\t} else if (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {\n\t\tlink->head = req;\n\t\tlink->last = req;\n\t\treturn 0;\n\t}\n\n\tio_queue_sqe(req);\n\treturn 0;\n}\n\n/*\n * Batched submission is done, ensure local IO is flushed out.\n */\nstatic void io_submit_state_end(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (state->link.head)\n\t\tio_queue_sqe(state->link.head);\n\t/* flush only after queuing links as they can generate completions */\n\tio_submit_flush_completions(ctx);\n\tif (state->plug_started)\n\t\tblk_finish_plug(&state->plug);\n}\n\n/*\n * Start submission side cache.\n */\nstatic void io_submit_state_start(struct io_submit_state *state,\n\t\t\t\t  unsigned int max_ios)\n{\n\tstate->plug_started = false;\n\tstate->need_plug = max_ios > 2;\n\tstate->submit_nr = max_ios;\n\t/* set only head, no need to init link_last in advance */\n\tstate->link.head = NULL;\n}\n\nstatic void io_commit_sqring(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\n\t/*\n\t * Ensure any loads from the SQEs are done at this point,\n\t * since once we write the new head, the application could\n\t * write new data to them.\n\t */\n\tsmp_store_release(&rings->sq.head, ctx->cached_sq_head);\n}\n\n/*\n * Fetch an sqe, if one is available. Note this returns a pointer to memory\n * that is mapped by userspace. This means that care needs to be taken to\n * ensure that reads are stable, as we cannot rely on userspace always\n * being a good citizen. If members of the sqe are validated and then later\n * used, it's important that those reads are done through READ_ONCE() to\n * prevent a re-load down the line.\n */\nstatic const struct io_uring_sqe *io_get_sqe(struct io_ring_ctx *ctx)\n{\n\tunsigned head, mask = ctx->sq_entries - 1;\n\tunsigned sq_idx = ctx->cached_sq_head++ & mask;\n\n\t/*\n\t * The cached sq head (or cq tail) serves two purposes:\n\t *\n\t * 1) allows us to batch the cost of updating the user visible\n\t *    head updates.\n\t * 2) allows the kernel side to track the head on its own, even\n\t *    though the application is the one updating it.\n\t */\n\thead = READ_ONCE(ctx->sq_array[sq_idx]);\n\tif (likely(head < ctx->sq_entries))\n\t\treturn &ctx->sq_sqes[head];\n\n\t/* drop invalid entries */\n\tctx->cq_extra--;\n\tWRITE_ONCE(ctx->rings->sq_dropped,\n\t\t   READ_ONCE(ctx->rings->sq_dropped) + 1);\n\treturn NULL;\n}\n\nstatic int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr)\n\t__must_hold(&ctx->uring_lock)\n{\n\tunsigned int entries = io_sqring_entries(ctx);\n\tint submitted = 0;\n\n\tif (unlikely(!entries))\n\t\treturn 0;\n\t/* make sure SQ entry isn't read before tail */\n\tnr = min3(nr, ctx->sq_entries, entries);\n\tio_get_task_refs(nr);\n\n\tio_submit_state_start(&ctx->submit_state, nr);\n\tdo {\n\t\tconst struct io_uring_sqe *sqe;\n\t\tstruct io_kiocb *req;\n\n\t\tif (unlikely(!io_alloc_req_refill(ctx))) {\n\t\t\tif (!submitted)\n\t\t\t\tsubmitted = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\treq = io_alloc_req(ctx);\n\t\tsqe = io_get_sqe(ctx);\n\t\tif (unlikely(!sqe)) {\n\t\t\twq_stack_add_head(&req->comp_list, &ctx->submit_state.free_list);\n\t\t\tbreak;\n\t\t}\n\t\t/* will complete beyond this point, count as submitted */\n\t\tsubmitted++;\n\t\tif (io_submit_sqe(ctx, req, sqe)) {\n\t\t\t/*\n\t\t\t * Continue submitting even for sqe failure if the\n\t\t\t * ring was setup with IORING_SETUP_SUBMIT_ALL\n\t\t\t */\n\t\t\tif (!(ctx->flags & IORING_SETUP_SUBMIT_ALL))\n\t\t\t\tbreak;\n\t\t}\n\t} while (submitted < nr);\n\n\tif (unlikely(submitted != nr)) {\n\t\tint ref_used = (submitted == -EAGAIN) ? 0 : submitted;\n\t\tint unused = nr - ref_used;\n\n\t\tcurrent->io_uring->cached_refs += unused;\n\t}\n\n\tio_submit_state_end(ctx);\n\t /* Commit SQ ring head once we've consumed and submitted all SQEs */\n\tio_commit_sqring(ctx);\n\n\treturn submitted;\n}\n\nstatic inline bool io_sqd_events_pending(struct io_sq_data *sqd)\n{\n\treturn READ_ONCE(sqd->state);\n}\n\nstatic inline void io_ring_set_wakeup_flag(struct io_ring_ctx *ctx)\n{\n\t/* Tell userspace we may need a wakeup call */\n\tspin_lock(&ctx->completion_lock);\n\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t   ctx->rings->sq_flags | IORING_SQ_NEED_WAKEUP);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic inline void io_ring_clear_wakeup_flag(struct io_ring_ctx *ctx)\n{\n\tspin_lock(&ctx->completion_lock);\n\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t   ctx->rings->sq_flags & ~IORING_SQ_NEED_WAKEUP);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic int __io_sq_thread(struct io_ring_ctx *ctx, bool cap_entries)\n{\n\tunsigned int to_submit;\n\tint ret = 0;\n\n\tto_submit = io_sqring_entries(ctx);\n\t/* if we're handling multiple rings, cap submit size for fairness */\n\tif (cap_entries && to_submit > IORING_SQPOLL_CAP_ENTRIES_VALUE)\n\t\tto_submit = IORING_SQPOLL_CAP_ENTRIES_VALUE;\n\n\tif (!wq_list_empty(&ctx->iopoll_list) || to_submit) {\n\t\tconst struct cred *creds = NULL;\n\n\t\tif (ctx->sq_creds != current_cred())\n\t\t\tcreds = override_creds(ctx->sq_creds);\n\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tif (!wq_list_empty(&ctx->iopoll_list))\n\t\t\tio_do_iopoll(ctx, true);\n\n\t\t/*\n\t\t * Don't submit if refs are dying, good for io_uring_register(),\n\t\t * but also it is relied upon by io_ring_exit_work()\n\t\t */\n\t\tif (to_submit && likely(!percpu_ref_is_dying(&ctx->refs)) &&\n\t\t    !(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\t\tret = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\t\tif (to_submit && wq_has_sleeper(&ctx->sqo_sq_wait))\n\t\t\twake_up(&ctx->sqo_sq_wait);\n\t\tif (creds)\n\t\t\trevert_creds(creds);\n\t}\n\n\treturn ret;\n}\n\nstatic __cold void io_sqd_update_thread_idle(struct io_sq_data *sqd)\n{\n\tstruct io_ring_ctx *ctx;\n\tunsigned sq_thread_idle = 0;\n\n\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\tsq_thread_idle = max(sq_thread_idle, ctx->sq_thread_idle);\n\tsqd->sq_thread_idle = sq_thread_idle;\n}\n\nstatic bool io_sqd_handle_event(struct io_sq_data *sqd)\n{\n\tbool did_sig = false;\n\tstruct ksignal ksig;\n\n\tif (test_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state) ||\n\t    signal_pending(current)) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tif (signal_pending(current))\n\t\t\tdid_sig = get_signal(&ksig);\n\t\tcond_resched();\n\t\tmutex_lock(&sqd->lock);\n\t}\n\treturn did_sig || test_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state);\n}\n\nstatic int io_sq_thread(void *data)\n{\n\tstruct io_sq_data *sqd = data;\n\tstruct io_ring_ctx *ctx;\n\tunsigned long timeout = 0;\n\tchar buf[TASK_COMM_LEN];\n\tDEFINE_WAIT(wait);\n\n\tsnprintf(buf, sizeof(buf), \"iou-sqp-%d\", sqd->task_pid);\n\tset_task_comm(current, buf);\n\n\tif (sqd->sq_cpu != -1)\n\t\tset_cpus_allowed_ptr(current, cpumask_of(sqd->sq_cpu));\n\telse\n\t\tset_cpus_allowed_ptr(current, cpu_online_mask);\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\taudit_alloc_kernel(current);\n\n\tmutex_lock(&sqd->lock);\n\twhile (1) {\n\t\tbool cap_entries, sqt_spin = false;\n\n\t\tif (io_sqd_events_pending(sqd) || signal_pending(current)) {\n\t\t\tif (io_sqd_handle_event(sqd))\n\t\t\t\tbreak;\n\t\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t\t}\n\n\t\tcap_entries = !list_is_singular(&sqd->ctx_list);\n\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {\n\t\t\tint ret = __io_sq_thread(ctx, cap_entries);\n\n\t\t\tif (!sqt_spin && (ret > 0 || !wq_list_empty(&ctx->iopoll_list)))\n\t\t\t\tsqt_spin = true;\n\t\t}\n\t\tif (io_run_task_work())\n\t\t\tsqt_spin = true;\n\n\t\tif (sqt_spin || !time_after(jiffies, timeout)) {\n\t\t\tcond_resched();\n\t\t\tif (sqt_spin)\n\t\t\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprepare_to_wait(&sqd->wait, &wait, TASK_INTERRUPTIBLE);\n\t\tif (!io_sqd_events_pending(sqd) && !task_work_pending(current)) {\n\t\t\tbool needs_sched = true;\n\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {\n\t\t\t\tio_ring_set_wakeup_flag(ctx);\n\n\t\t\t\tif ((ctx->flags & IORING_SETUP_IOPOLL) &&\n\t\t\t\t    !wq_list_empty(&ctx->iopoll_list)) {\n\t\t\t\t\tneeds_sched = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ensure the store of the wakeup flag is not\n\t\t\t\t * reordered with the load of the SQ tail\n\t\t\t\t */\n\t\t\t\tsmp_mb();\n\n\t\t\t\tif (io_sqring_entries(ctx)) {\n\t\t\t\t\tneeds_sched = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (needs_sched) {\n\t\t\t\tmutex_unlock(&sqd->lock);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&sqd->lock);\n\t\t\t}\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\t\t\tio_ring_clear_wakeup_flag(ctx);\n\t\t}\n\n\t\tfinish_wait(&sqd->wait, &wait);\n\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t}\n\n\tio_uring_cancel_generic(true, sqd);\n\tsqd->thread = NULL;\n\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\tio_ring_set_wakeup_flag(ctx);\n\tio_run_task_work();\n\tmutex_unlock(&sqd->lock);\n\n\taudit_free(current);\n\n\tcomplete(&sqd->exited);\n\tdo_exit(0);\n}\n\nstruct io_wait_queue {\n\tstruct wait_queue_entry wq;\n\tstruct io_ring_ctx *ctx;\n\tunsigned cq_tail;\n\tunsigned nr_timeouts;\n};\n\nstatic inline bool io_should_wake(struct io_wait_queue *iowq)\n{\n\tstruct io_ring_ctx *ctx = iowq->ctx;\n\tint dist = ctx->cached_cq_tail - (int) iowq->cq_tail;\n\n\t/*\n\t * Wake up if we have enough events, or if a timeout occurred since we\n\t * started waiting. For timeouts, we always want to return to userspace,\n\t * regardless of event count.\n\t */\n\treturn dist >= 0 || atomic_read(&ctx->cq_timeouts) != iowq->nr_timeouts;\n}\n\nstatic int io_wake_function(struct wait_queue_entry *curr, unsigned int mode,\n\t\t\t    int wake_flags, void *key)\n{\n\tstruct io_wait_queue *iowq = container_of(curr, struct io_wait_queue,\n\t\t\t\t\t\t\twq);\n\n\t/*\n\t * Cannot safely flush overflowed CQEs from here, ensure we wake up\n\t * the task, and the next invocation will do it.\n\t */\n\tif (io_should_wake(iowq) || test_bit(0, &iowq->ctx->check_cq_overflow))\n\t\treturn autoremove_wake_function(curr, mode, wake_flags, key);\n\treturn -1;\n}\n\nstatic int io_run_task_work_sig(void)\n{\n\tif (io_run_task_work())\n\t\treturn 1;\n\tif (test_thread_flag(TIF_NOTIFY_SIGNAL))\n\t\treturn -ERESTARTSYS;\n\tif (task_sigpending(current))\n\t\treturn -EINTR;\n\treturn 0;\n}\n\n/* when returns >0, the caller should retry */\nstatic inline int io_cqring_wait_schedule(struct io_ring_ctx *ctx,\n\t\t\t\t\t  struct io_wait_queue *iowq,\n\t\t\t\t\t  ktime_t timeout)\n{\n\tint ret;\n\n\t/* make sure we run task_work before checking for signals */\n\tret = io_run_task_work_sig();\n\tif (ret || io_should_wake(iowq))\n\t\treturn ret;\n\t/* let the caller flush overflows, retry */\n\tif (test_bit(0, &ctx->check_cq_overflow))\n\t\treturn 1;\n\n\tif (!schedule_hrtimeout(&timeout, HRTIMER_MODE_ABS))\n\t\treturn -ETIME;\n\treturn 1;\n}\n\n/*\n * Wait until events become available, if we don't already have some. The\n * application must reap them itself, as they reside on the shared cq ring.\n */\nstatic int io_cqring_wait(struct io_ring_ctx *ctx, int min_events,\n\t\t\t  const sigset_t __user *sig, size_t sigsz,\n\t\t\t  struct __kernel_timespec __user *uts)\n{\n\tstruct io_wait_queue iowq;\n\tstruct io_rings *rings = ctx->rings;\n\tktime_t timeout = KTIME_MAX;\n\tint ret;\n\n\tdo {\n\t\tio_cqring_overflow_flush(ctx);\n\t\tif (io_cqring_events(ctx) >= min_events)\n\t\t\treturn 0;\n\t\tif (!io_run_task_work())\n\t\t\tbreak;\n\t} while (1);\n\n\tif (sig) {\n#ifdef CONFIG_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = set_compat_user_sigmask((const compat_sigset_t __user *)sig,\n\t\t\t\t\t\t      sigsz);\n\t\telse\n#endif\n\t\t\tret = set_user_sigmask(sig, sigsz);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (uts) {\n\t\tstruct timespec64 ts;\n\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ktime_add_ns(timespec64_to_ktime(ts), ktime_get_ns());\n\t}\n\n\tinit_waitqueue_func_entry(&iowq.wq, io_wake_function);\n\tiowq.wq.private = current;\n\tINIT_LIST_HEAD(&iowq.wq.entry);\n\tiowq.ctx = ctx;\n\tiowq.nr_timeouts = atomic_read(&ctx->cq_timeouts);\n\tiowq.cq_tail = READ_ONCE(ctx->rings->cq.head) + min_events;\n\n\ttrace_io_uring_cqring_wait(ctx, min_events);\n\tdo {\n\t\t/* if we can't even flush overflow, don't wait for more */\n\t\tif (!io_cqring_overflow_flush(ctx)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait_exclusive(&ctx->cq_wait, &iowq.wq,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tret = io_cqring_wait_schedule(ctx, &iowq, timeout);\n\t\tfinish_wait(&ctx->cq_wait, &iowq.wq);\n\t\tcond_resched();\n\t} while (ret > 0);\n\n\trestore_saved_sigmask_unless(ret == -EINTR);\n\n\treturn READ_ONCE(rings->cq.head) == READ_ONCE(rings->cq.tail) ? ret : 0;\n}\n\nstatic void io_free_page_table(void **table, size_t size)\n{\n\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\n\n\tfor (i = 0; i < nr_tables; i++)\n\t\tkfree(table[i]);\n\tkfree(table);\n}\n\nstatic __cold void **io_alloc_page_table(size_t size)\n{\n\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\n\tsize_t init_size = size;\n\tvoid **table;\n\n\ttable = kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);\n\tif (!table)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tunsigned int this_size = min_t(size_t, size, PAGE_SIZE);\n\n\t\ttable[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);\n\t\tif (!table[i]) {\n\t\t\tio_free_page_table(table, init_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize -= this_size;\n\t}\n\treturn table;\n}\n\nstatic void io_rsrc_node_destroy(struct io_rsrc_node *ref_node)\n{\n\tpercpu_ref_exit(&ref_node->refs);\n\tkfree(ref_node);\n}\n\nstatic __cold void io_rsrc_node_ref_zero(struct percpu_ref *ref)\n{\n\tstruct io_rsrc_node *node = container_of(ref, struct io_rsrc_node, refs);\n\tstruct io_ring_ctx *ctx = node->rsrc_data->ctx;\n\tunsigned long flags;\n\tbool first_add = false;\n\tunsigned long delay = HZ;\n\n\tspin_lock_irqsave(&ctx->rsrc_ref_lock, flags);\n\tnode->done = true;\n\n\t/* if we are mid-quiesce then do not delay */\n\tif (node->rsrc_data->quiesce)\n\t\tdelay = 0;\n\n\twhile (!list_empty(&ctx->rsrc_ref_list)) {\n\t\tnode = list_first_entry(&ctx->rsrc_ref_list,\n\t\t\t\t\t    struct io_rsrc_node, node);\n\t\t/* recycle ref nodes in order */\n\t\tif (!node->done)\n\t\t\tbreak;\n\t\tlist_del(&node->node);\n\t\tfirst_add |= llist_add(&node->llist, &ctx->rsrc_put_llist);\n\t}\n\tspin_unlock_irqrestore(&ctx->rsrc_ref_lock, flags);\n\n\tif (first_add)\n\t\tmod_delayed_work(system_wq, &ctx->rsrc_put_work, delay);\n}\n\nstatic struct io_rsrc_node *io_rsrc_node_alloc(void)\n{\n\tstruct io_rsrc_node *ref_node;\n\n\tref_node = kzalloc(sizeof(*ref_node), GFP_KERNEL);\n\tif (!ref_node)\n\t\treturn NULL;\n\n\tif (percpu_ref_init(&ref_node->refs, io_rsrc_node_ref_zero,\n\t\t\t    0, GFP_KERNEL)) {\n\t\tkfree(ref_node);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&ref_node->node);\n\tINIT_LIST_HEAD(&ref_node->rsrc_list);\n\tref_node->done = false;\n\treturn ref_node;\n}\n\nstatic void io_rsrc_node_switch(struct io_ring_ctx *ctx,\n\t\t\t\tstruct io_rsrc_data *data_to_kill)\n\t__must_hold(&ctx->uring_lock)\n{\n\tWARN_ON_ONCE(!ctx->rsrc_backup_node);\n\tWARN_ON_ONCE(data_to_kill && !ctx->rsrc_node);\n\n\tio_rsrc_refs_drop(ctx);\n\n\tif (data_to_kill) {\n\t\tstruct io_rsrc_node *rsrc_node = ctx->rsrc_node;\n\n\t\trsrc_node->rsrc_data = data_to_kill;\n\t\tspin_lock_irq(&ctx->rsrc_ref_lock);\n\t\tlist_add_tail(&rsrc_node->node, &ctx->rsrc_ref_list);\n\t\tspin_unlock_irq(&ctx->rsrc_ref_lock);\n\n\t\tatomic_inc(&data_to_kill->refs);\n\t\tpercpu_ref_kill(&rsrc_node->refs);\n\t\tctx->rsrc_node = NULL;\n\t}\n\n\tif (!ctx->rsrc_node) {\n\t\tctx->rsrc_node = ctx->rsrc_backup_node;\n\t\tctx->rsrc_backup_node = NULL;\n\t}\n}\n\nstatic int io_rsrc_node_switch_start(struct io_ring_ctx *ctx)\n{\n\tif (ctx->rsrc_backup_node)\n\t\treturn 0;\n\tctx->rsrc_backup_node = io_rsrc_node_alloc();\n\treturn ctx->rsrc_backup_node ? 0 : -ENOMEM;\n}\n\nstatic __cold int io_rsrc_ref_quiesce(struct io_rsrc_data *data,\n\t\t\t\t      struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\t/* As we may drop ->uring_lock, other task may have started quiesce */\n\tif (data->quiesce)\n\t\treturn -ENXIO;\n\n\tdata->quiesce = true;\n\tdo {\n\t\tret = io_rsrc_node_switch_start(ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tio_rsrc_node_switch(ctx, data);\n\n\t\t/* kill initial ref, already quiesced if zero */\n\t\tif (atomic_dec_and_test(&data->refs))\n\t\t\tbreak;\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\tflush_delayed_work(&ctx->rsrc_put_work);\n\t\tret = wait_for_completion_interruptible(&data->done);\n\t\tif (!ret) {\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t\tif (atomic_read(&data->refs) > 0) {\n\t\t\t\t/*\n\t\t\t\t * it has been revived by another thread while\n\t\t\t\t * we were unlocked\n\t\t\t\t */\n\t\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tatomic_inc(&data->refs);\n\t\t/* wait for all works potentially completing data->done */\n\t\tflush_delayed_work(&ctx->rsrc_put_work);\n\t\treinit_completion(&data->done);\n\n\t\tret = io_run_task_work_sig();\n\t\tmutex_lock(&ctx->uring_lock);\n\t} while (ret >= 0);\n\tdata->quiesce = false;\n\n\treturn ret;\n}\n\nstatic u64 *io_get_tag_slot(struct io_rsrc_data *data, unsigned int idx)\n{\n\tunsigned int off = idx & IO_RSRC_TAG_TABLE_MASK;\n\tunsigned int table_idx = idx >> IO_RSRC_TAG_TABLE_SHIFT;\n\n\treturn &data->tags[table_idx][off];\n}\n\nstatic void io_rsrc_data_free(struct io_rsrc_data *data)\n{\n\tsize_t size = data->nr * sizeof(data->tags[0][0]);\n\n\tif (data->tags)\n\t\tio_free_page_table((void **)data->tags, size);\n\tkfree(data);\n}\n\nstatic __cold int io_rsrc_data_alloc(struct io_ring_ctx *ctx, rsrc_put_fn *do_put,\n\t\t\t\t     u64 __user *utags, unsigned nr,\n\t\t\t\t     struct io_rsrc_data **pdata)\n{\n\tstruct io_rsrc_data *data;\n\tint ret = -ENOMEM;\n\tunsigned i;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->tags = (u64 **)io_alloc_page_table(nr * sizeof(data->tags[0][0]));\n\tif (!data->tags) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->nr = nr;\n\tdata->ctx = ctx;\n\tdata->do_put = do_put;\n\tif (utags) {\n\t\tret = -EFAULT;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tu64 *tag_slot = io_get_tag_slot(data, i);\n\n\t\t\tif (copy_from_user(tag_slot, &utags[i],\n\t\t\t\t\t   sizeof(*tag_slot)))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tatomic_set(&data->refs, 1);\n\tinit_completion(&data->done);\n\t*pdata = data;\n\treturn 0;\nfail:\n\tio_rsrc_data_free(data);\n\treturn ret;\n}\n\nstatic bool io_alloc_file_tables(struct io_file_table *table, unsigned nr_files)\n{\n\ttable->files = kvcalloc(nr_files, sizeof(table->files[0]),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\treturn !!table->files;\n}\n\nstatic void io_free_file_tables(struct io_file_table *table)\n{\n\tkvfree(table->files);\n\ttable->files = NULL;\n}\n\nstatic void __io_sqe_files_unregister(struct io_ring_ctx *ctx)\n{\n#if defined(CONFIG_UNIX)\n\tif (ctx->ring_sock) {\n\t\tstruct sock *sock = ctx->ring_sock->sk;\n\t\tstruct sk_buff *skb;\n\n\t\twhile ((skb = skb_dequeue(&sock->sk_receive_queue)) != NULL)\n\t\t\tkfree_skb(skb);\n\t}\n#else\n\tint i;\n\n\tfor (i = 0; i < ctx->nr_user_files; i++) {\n\t\tstruct file *file;\n\n\t\tfile = io_file_from_index(ctx, i);\n\t\tif (file)\n\t\t\tfput(file);\n\t}\n#endif\n\tio_free_file_tables(&ctx->file_table);\n\tio_rsrc_data_free(ctx->file_data);\n\tctx->file_data = NULL;\n\tctx->nr_user_files = 0;\n}\n\nstatic int io_sqe_files_unregister(struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\tif (!ctx->file_data)\n\t\treturn -ENXIO;\n\tret = io_rsrc_ref_quiesce(ctx->file_data, ctx);\n\tif (!ret)\n\t\t__io_sqe_files_unregister(ctx);\n\treturn ret;\n}\n\nstatic void io_sq_thread_unpark(struct io_sq_data *sqd)\n\t__releases(&sqd->lock)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\n\t/*\n\t * Do the dance but not conditional clear_bit() because it'd race with\n\t * other threads incrementing park_pending and setting the bit.\n\t */\n\tclear_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tif (atomic_dec_return(&sqd->park_pending))\n\t\tset_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tmutex_unlock(&sqd->lock);\n}\n\nstatic void io_sq_thread_park(struct io_sq_data *sqd)\n\t__acquires(&sqd->lock)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\n\tatomic_inc(&sqd->park_pending);\n\tset_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tmutex_lock(&sqd->lock);\n\tif (sqd->thread)\n\t\twake_up_process(sqd->thread);\n}\n\nstatic void io_sq_thread_stop(struct io_sq_data *sqd)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\tWARN_ON_ONCE(test_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state));\n\n\tset_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state);\n\tmutex_lock(&sqd->lock);\n\tif (sqd->thread)\n\t\twake_up_process(sqd->thread);\n\tmutex_unlock(&sqd->lock);\n\twait_for_completion(&sqd->exited);\n}\n\nstatic void io_put_sq_data(struct io_sq_data *sqd)\n{\n\tif (refcount_dec_and_test(&sqd->refs)) {\n\t\tWARN_ON_ONCE(atomic_read(&sqd->park_pending));\n\n\t\tio_sq_thread_stop(sqd);\n\t\tkfree(sqd);\n\t}\n}\n\nstatic void io_sq_thread_finish(struct io_ring_ctx *ctx)\n{\n\tstruct io_sq_data *sqd = ctx->sq_data;\n\n\tif (sqd) {\n\t\tio_sq_thread_park(sqd);\n\t\tlist_del_init(&ctx->sqd_list);\n\t\tio_sqd_update_thread_idle(sqd);\n\t\tio_sq_thread_unpark(sqd);\n\n\t\tio_put_sq_data(sqd);\n\t\tctx->sq_data = NULL;\n\t}\n}\n\nstatic struct io_sq_data *io_attach_sq_data(struct io_uring_params *p)\n{\n\tstruct io_ring_ctx *ctx_attach;\n\tstruct io_sq_data *sqd;\n\tstruct fd f;\n\n\tf = fdget(p->wq_fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-ENXIO);\n\tif (f.file->f_op != &io_uring_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tctx_attach = f.file->private_data;\n\tsqd = ctx_attach->sq_data;\n\tif (!sqd) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (sqd->task_tgid != current->tgid) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\trefcount_inc(&sqd->refs);\n\tfdput(f);\n\treturn sqd;\n}\n\nstatic struct io_sq_data *io_get_sq_data(struct io_uring_params *p,\n\t\t\t\t\t bool *attached)\n{\n\tstruct io_sq_data *sqd;\n\n\t*attached = false;\n\tif (p->flags & IORING_SETUP_ATTACH_WQ) {\n\t\tsqd = io_attach_sq_data(p);\n\t\tif (!IS_ERR(sqd)) {\n\t\t\t*attached = true;\n\t\t\treturn sqd;\n\t\t}\n\t\t/* fall through for EPERM case, setup new sqd/task */\n\t\tif (PTR_ERR(sqd) != -EPERM)\n\t\t\treturn sqd;\n\t}\n\n\tsqd = kzalloc(sizeof(*sqd), GFP_KERNEL);\n\tif (!sqd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sqd->park_pending, 0);\n\trefcount_set(&sqd->refs, 1);\n\tINIT_LIST_HEAD(&sqd->ctx_list);\n\tmutex_init(&sqd->lock);\n\tinit_waitqueue_head(&sqd->wait);\n\tinit_completion(&sqd->exited);\n\treturn sqd;\n}\n\n#if defined(CONFIG_UNIX)\n/*\n * Ensure the UNIX gc is aware of our file set, so we are certain that\n * the io_uring can be safely unregistered on process exit, even if we have\n * loops in the file referencing.\n */\nstatic int __io_sqe_files_scm(struct io_ring_ctx *ctx, int nr, int offset)\n{\n\tstruct sock *sk = ctx->ring_sock->sk;\n\tstruct scm_fp_list *fpl;\n\tstruct sk_buff *skb;\n\tint i, nr_files;\n\n\tfpl = kzalloc(sizeof(*fpl), GFP_KERNEL);\n\tif (!fpl)\n\t\treturn -ENOMEM;\n\n\tskb = alloc_skb(0, GFP_KERNEL);\n\tif (!skb) {\n\t\tkfree(fpl);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb->sk = sk;\n\n\tnr_files = 0;\n\tfpl->user = get_uid(current_user());\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct file *file = io_file_from_index(ctx, i + offset);\n\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfpl->fp[nr_files] = get_file(file);\n\t\tunix_inflight(fpl->user, fpl->fp[nr_files]);\n\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->count = nr_files;\n\t\tUNIXCB(skb).fp = fpl;\n\t\tskb->destructor = unix_destruct_scm;\n\t\trefcount_add(skb->truesize, &sk->sk_wmem_alloc);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tstruct file *file = io_file_from_index(ctx, i + offset);\n\n\t\t\tif (file)\n\t\t\t\tfput(file);\n\t\t}\n\t} else {\n\t\tkfree_skb(skb);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n\n\treturn 0;\n}\n\n/*\n * If UNIX sockets are enabled, fd passing can cause a reference cycle which\n * causes regular reference counting to break down. We rely on the UNIX\n * garbage collection to take care of this problem for us.\n */\nstatic int io_sqe_files_scm(struct io_ring_ctx *ctx)\n{\n\tunsigned left, total;\n\tint ret = 0;\n\n\ttotal = 0;\n\tleft = ctx->nr_user_files;\n\twhile (left) {\n\t\tunsigned this_files = min_t(unsigned, left, SCM_MAX_FD);\n\n\t\tret = __io_sqe_files_scm(ctx, this_files, total);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tleft -= this_files;\n\t\ttotal += this_files;\n\t}\n\n\tif (!ret)\n\t\treturn 0;\n\n\twhile (total < ctx->nr_user_files) {\n\t\tstruct file *file = io_file_from_index(ctx, total);\n\n\t\tif (file)\n\t\t\tfput(file);\n\t\ttotal++;\n\t}\n\n\treturn ret;\n}\n#else\nstatic int io_sqe_files_scm(struct io_ring_ctx *ctx)\n{\n\treturn 0;\n}\n#endif\n\nstatic void io_rsrc_file_put(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc)\n{\n\tstruct file *file = prsrc->file;\n#if defined(CONFIG_UNIX)\n\tstruct sock *sock = ctx->ring_sock->sk;\n\tstruct sk_buff_head list, *head = &sock->sk_receive_queue;\n\tstruct sk_buff *skb;\n\tint i;\n\n\t__skb_queue_head_init(&list);\n\n\t/*\n\t * Find the skb that holds this file in its SCM_RIGHTS. When found,\n\t * remove this entry and rearrange the file array.\n\t */\n\tskb = skb_dequeue(head);\n\twhile (skb) {\n\t\tstruct scm_fp_list *fp;\n\n\t\tfp = UNIXCB(skb).fp;\n\t\tfor (i = 0; i < fp->count; i++) {\n\t\t\tint left;\n\n\t\t\tif (fp->fp[i] != file)\n\t\t\t\tcontinue;\n\n\t\t\tunix_notinflight(fp->user, fp->fp[i]);\n\t\t\tleft = fp->count - 1 - i;\n\t\t\tif (left) {\n\t\t\t\tmemmove(&fp->fp[i], &fp->fp[i + 1],\n\t\t\t\t\t\tleft * sizeof(struct file *));\n\t\t\t}\n\t\t\tfp->count--;\n\t\t\tif (!fp->count) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\t__skb_queue_tail(&list, skb);\n\t\t\t}\n\t\t\tfput(file);\n\t\t\tfile = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!file)\n\t\t\tbreak;\n\n\t\t__skb_queue_tail(&list, skb);\n\n\t\tskb = skb_dequeue(head);\n\t}\n\n\tif (skb_peek(&list)) {\n\t\tspin_lock_irq(&head->lock);\n\t\twhile ((skb = __skb_dequeue(&list)) != NULL)\n\t\t\t__skb_queue_tail(head, skb);\n\t\tspin_unlock_irq(&head->lock);\n\t}\n#else\n\tfput(file);\n#endif\n}\n\nstatic void __io_rsrc_put_work(struct io_rsrc_node *ref_node)\n{\n\tstruct io_rsrc_data *rsrc_data = ref_node->rsrc_data;\n\tstruct io_ring_ctx *ctx = rsrc_data->ctx;\n\tstruct io_rsrc_put *prsrc, *tmp;\n\n\tlist_for_each_entry_safe(prsrc, tmp, &ref_node->rsrc_list, list) {\n\t\tlist_del(&prsrc->list);\n\n\t\tif (prsrc->tag) {\n\t\t\tbool lock_ring = ctx->flags & IORING_SETUP_IOPOLL;\n\n\t\t\tio_ring_submit_lock(ctx, lock_ring);\n\t\t\tspin_lock(&ctx->completion_lock);\n\t\t\tio_fill_cqe_aux(ctx, prsrc->tag, 0, 0);\n\t\t\tio_commit_cqring(ctx);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\tio_cqring_ev_posted(ctx);\n\t\t\tio_ring_submit_unlock(ctx, lock_ring);\n\t\t}\n\n\t\trsrc_data->do_put(ctx, prsrc);\n\t\tkfree(prsrc);\n\t}\n\n\tio_rsrc_node_destroy(ref_node);\n\tif (atomic_dec_and_test(&rsrc_data->refs))\n\t\tcomplete(&rsrc_data->done);\n}\n\nstatic void io_rsrc_put_work(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx;\n\tstruct llist_node *node;\n\n\tctx = container_of(work, struct io_ring_ctx, rsrc_put_work.work);\n\tnode = llist_del_all(&ctx->rsrc_put_llist);\n\n\twhile (node) {\n\t\tstruct io_rsrc_node *ref_node;\n\t\tstruct llist_node *next = node->next;\n\n\t\tref_node = llist_entry(node, struct io_rsrc_node, llist);\n\t\t__io_rsrc_put_work(ref_node);\n\t\tnode = next;\n\t}\n}\n\nstatic int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t unsigned nr_args, u64 __user *tags)\n{\n\t__s32 __user *fds = (__s32 __user *) arg;\n\tstruct file *file;\n\tint fd, ret;\n\tunsigned i;\n\n\tif (ctx->file_data)\n\t\treturn -EBUSY;\n\tif (!nr_args)\n\t\treturn -EINVAL;\n\tif (nr_args > IORING_MAX_FIXED_FILES)\n\t\treturn -EMFILE;\n\tif (nr_args > rlimit(RLIMIT_NOFILE))\n\t\treturn -EMFILE;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\treturn ret;\n\tret = io_rsrc_data_alloc(ctx, io_rsrc_file_put, tags, nr_args,\n\t\t\t\t &ctx->file_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tif (!io_alloc_file_tables(&ctx->file_table, nr_args))\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_args; i++, ctx->nr_user_files++) {\n\t\tif (copy_from_user(&fd, &fds[i], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_fput;\n\t\t}\n\t\t/* allow sparse sets */\n\t\tif (fd == -1) {\n\t\t\tret = -EINVAL;\n\t\t\tif (unlikely(*io_get_tag_slot(ctx->file_data, i)))\n\t\t\t\tgoto out_fput;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = fget(fd);\n\t\tret = -EBADF;\n\t\tif (unlikely(!file))\n\t\t\tgoto out_fput;\n\n\t\t/*\n\t\t * Don't allow io_uring instances to be registered. If UNIX\n\t\t * isn't enabled, then this causes a reference cycle and this\n\t\t * instance can never get freed. If UNIX is enabled we'll\n\t\t * handle it just fine, but there's still no point in allowing\n\t\t * a ring fd as it doesn't support regular read/write anyway.\n\t\t */\n\t\tif (file->f_op == &io_uring_fops) {\n\t\t\tfput(file);\n\t\t\tgoto out_fput;\n\t\t}\n\t\tio_fixed_file_set(io_fixed_file_slot(&ctx->file_table, i), file);\n\t}\n\n\tret = io_sqe_files_scm(ctx);\n\tif (ret) {\n\t\t__io_sqe_files_unregister(ctx);\n\t\treturn ret;\n\t}\n\n\tio_rsrc_node_switch(ctx, NULL);\n\treturn ret;\nout_fput:\n\tfor (i = 0; i < ctx->nr_user_files; i++) {\n\t\tfile = io_file_from_index(ctx, i);\n\t\tif (file)\n\t\t\tfput(file);\n\t}\n\tio_free_file_tables(&ctx->file_table);\n\tctx->nr_user_files = 0;\nout_free:\n\tio_rsrc_data_free(ctx->file_data);\n\tctx->file_data = NULL;\n\treturn ret;\n}\n\nstatic int io_sqe_file_register(struct io_ring_ctx *ctx, struct file *file,\n\t\t\t\tint index)\n{\n#if defined(CONFIG_UNIX)\n\tstruct sock *sock = ctx->ring_sock->sk;\n\tstruct sk_buff_head *head = &sock->sk_receive_queue;\n\tstruct sk_buff *skb;\n\n\t/*\n\t * See if we can merge this file into an existing skb SCM_RIGHTS\n\t * file set. If there's no room, fall back to allocating a new skb\n\t * and filling it in.\n\t */\n\tspin_lock_irq(&head->lock);\n\tskb = skb_peek(head);\n\tif (skb) {\n\t\tstruct scm_fp_list *fpl = UNIXCB(skb).fp;\n\n\t\tif (fpl->count < SCM_MAX_FD) {\n\t\t\t__skb_unlink(skb, head);\n\t\t\tspin_unlock_irq(&head->lock);\n\t\t\tfpl->fp[fpl->count] = get_file(file);\n\t\t\tunix_inflight(fpl->user, fpl->fp[fpl->count]);\n\t\t\tfpl->count++;\n\t\t\tspin_lock_irq(&head->lock);\n\t\t\t__skb_queue_head(head, skb);\n\t\t} else {\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\tspin_unlock_irq(&head->lock);\n\n\tif (skb) {\n\t\tfput(file);\n\t\treturn 0;\n\t}\n\n\treturn __io_sqe_files_scm(ctx, 1, index);\n#else\n\treturn 0;\n#endif\n}\n\nstatic int io_queue_rsrc_removal(struct io_rsrc_data *data, unsigned idx,\n\t\t\t\t struct io_rsrc_node *node, void *rsrc)\n{\n\tu64 *tag_slot = io_get_tag_slot(data, idx);\n\tstruct io_rsrc_put *prsrc;\n\n\tprsrc = kzalloc(sizeof(*prsrc), GFP_KERNEL);\n\tif (!prsrc)\n\t\treturn -ENOMEM;\n\n\tprsrc->tag = *tag_slot;\n\t*tag_slot = 0;\n\tprsrc->rsrc = rsrc;\n\tlist_add(&prsrc->list, &node->rsrc_list);\n\treturn 0;\n}\n\nstatic int io_install_fixed_file(struct io_kiocb *req, struct file *file,\n\t\t\t\t unsigned int issue_flags, u32 slot_index)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tbool needs_switch = false;\n\tstruct io_fixed_file *file_slot;\n\tint ret = -EBADF;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tif (file->f_op == &io_uring_fops)\n\t\tgoto err;\n\tret = -ENXIO;\n\tif (!ctx->file_data)\n\t\tgoto err;\n\tret = -EINVAL;\n\tif (slot_index >= ctx->nr_user_files)\n\t\tgoto err;\n\n\tslot_index = array_index_nospec(slot_index, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, slot_index);\n\n\tif (file_slot->file_ptr) {\n\t\tstruct file *old_file;\n\n\t\tret = io_rsrc_node_switch_start(ctx);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\told_file = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\t\tret = io_queue_rsrc_removal(ctx->file_data, slot_index,\n\t\t\t\t\t    ctx->rsrc_node, old_file);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tfile_slot->file_ptr = 0;\n\t\tneeds_switch = true;\n\t}\n\n\t*io_get_tag_slot(ctx->file_data, slot_index) = 0;\n\tio_fixed_file_set(file_slot, file);\n\tret = io_sqe_file_register(ctx, file, slot_index);\n\tif (ret) {\n\t\tfile_slot->file_ptr = 0;\n\t\tgoto err;\n\t}\n\n\tret = 0;\nerr:\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, ctx->file_data);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\tif (ret)\n\t\tfput(file);\n\treturn ret;\n}\n\nstatic int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tunsigned int offset = req->close.file_slot - 1;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_fixed_file *file_slot;\n\tstruct file *file;\n\tint ret;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = -ENXIO;\n\tif (unlikely(!ctx->file_data))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (offset >= ctx->nr_user_files)\n\t\tgoto out;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\tgoto out;\n\n\toffset = array_index_nospec(offset, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, offset);\n\tret = -EBADF;\n\tif (!file_slot->file_ptr)\n\t\tgoto out;\n\n\tfile = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\tret = io_queue_rsrc_removal(ctx->file_data, offset, ctx->rsrc_node, file);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_slot->file_ptr = 0;\n\tio_rsrc_node_switch(ctx, ctx->file_data);\n\tret = 0;\nout:\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn ret;\n}\n\nstatic int __io_sqe_files_update(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_uring_rsrc_update2 *up,\n\t\t\t\t unsigned nr_args)\n{\n\tu64 __user *tags = u64_to_user_ptr(up->tags);\n\t__s32 __user *fds = u64_to_user_ptr(up->data);\n\tstruct io_rsrc_data *data = ctx->file_data;\n\tstruct io_fixed_file *file_slot;\n\tstruct file *file;\n\tint fd, i, err = 0;\n\tunsigned int done;\n\tbool needs_switch = false;\n\n\tif (!ctx->file_data)\n\t\treturn -ENXIO;\n\tif (up->offset + nr_args > ctx->nr_user_files)\n\t\treturn -EINVAL;\n\n\tfor (done = 0; done < nr_args; done++) {\n\t\tu64 tag = 0;\n\n\t\tif ((tags && copy_from_user(&tag, &tags[done], sizeof(tag))) ||\n\t\t    copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((fd == IORING_REGISTER_FILES_SKIP || fd == -1) && tag) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (fd == IORING_REGISTER_FILES_SKIP)\n\t\t\tcontinue;\n\n\t\ti = array_index_nospec(up->offset + done, ctx->nr_user_files);\n\t\tfile_slot = io_fixed_file_slot(&ctx->file_table, i);\n\n\t\tif (file_slot->file_ptr) {\n\t\t\tfile = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\t\t\terr = io_queue_rsrc_removal(data, i, ctx->rsrc_node, file);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tfile_slot->file_ptr = 0;\n\t\t\tneeds_switch = true;\n\t\t}\n\t\tif (fd != -1) {\n\t\t\tfile = fget(fd);\n\t\t\tif (!file) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't allow io_uring instances to be registered. If\n\t\t\t * UNIX isn't enabled, then this causes a reference\n\t\t\t * cycle and this instance can never get freed. If UNIX\n\t\t\t * is enabled we'll handle it just fine, but there's\n\t\t\t * still no point in allowing a ring fd as it doesn't\n\t\t\t * support regular read/write anyway.\n\t\t\t */\n\t\t\tif (file->f_op == &io_uring_fops) {\n\t\t\t\tfput(file);\n\t\t\t\terr = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*io_get_tag_slot(data, i) = tag;\n\t\t\tio_fixed_file_set(file_slot, file);\n\t\t\terr = io_sqe_file_register(ctx, file, i);\n\t\t\tif (err) {\n\t\t\t\tfile_slot->file_ptr = 0;\n\t\t\t\tfput(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, data);\n\treturn done ? done : err;\n}\n\nstatic struct io_wq *io_init_wq_offload(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct io_wq_hash *hash;\n\tstruct io_wq_data data;\n\tunsigned int concurrency;\n\n\tmutex_lock(&ctx->uring_lock);\n\thash = ctx->hash_map;\n\tif (!hash) {\n\t\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\t\tif (!hash) {\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trefcount_set(&hash->refs, 1);\n\t\tinit_waitqueue_head(&hash->wait);\n\t\tctx->hash_map = hash;\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\n\tdata.hash = hash;\n\tdata.task = task;\n\tdata.free_work = io_wq_free_work;\n\tdata.do_work = io_wq_submit_work;\n\n\t/* Do QD, or 4 * CPUS, whatever is smallest */\n\tconcurrency = min(ctx->sq_entries, 4 * num_online_cpus());\n\n\treturn io_wq_create(concurrency, &data);\n}\n\nstatic __cold int io_uring_alloc_task_context(struct task_struct *task,\n\t\t\t\t\t      struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx;\n\tint ret;\n\n\ttctx = kzalloc(sizeof(*tctx), GFP_KERNEL);\n\tif (unlikely(!tctx))\n\t\treturn -ENOMEM;\n\n\ttctx->registered_rings = kcalloc(IO_RINGFD_REG_MAX,\n\t\t\t\t\t sizeof(struct file *), GFP_KERNEL);\n\tif (unlikely(!tctx->registered_rings)) {\n\t\tkfree(tctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = percpu_counter_init(&tctx->inflight, 0, GFP_KERNEL);\n\tif (unlikely(ret)) {\n\t\tkfree(tctx->registered_rings);\n\t\tkfree(tctx);\n\t\treturn ret;\n\t}\n\n\ttctx->io_wq = io_init_wq_offload(ctx, task);\n\tif (IS_ERR(tctx->io_wq)) {\n\t\tret = PTR_ERR(tctx->io_wq);\n\t\tpercpu_counter_destroy(&tctx->inflight);\n\t\tkfree(tctx->registered_rings);\n\t\tkfree(tctx);\n\t\treturn ret;\n\t}\n\n\txa_init(&tctx->xa);\n\tinit_waitqueue_head(&tctx->wait);\n\tatomic_set(&tctx->in_idle, 0);\n\ttask->io_uring = tctx;\n\tspin_lock_init(&tctx->task_lock);\n\tINIT_WQ_LIST(&tctx->task_list);\n\tINIT_WQ_LIST(&tctx->prior_task_list);\n\tinit_task_work(&tctx->task_work, tctx_task_work);\n\treturn 0;\n}\n\nvoid __io_uring_free(struct task_struct *tsk)\n{\n\tstruct io_uring_task *tctx = tsk->io_uring;\n\n\tWARN_ON_ONCE(!xa_empty(&tctx->xa));\n\tWARN_ON_ONCE(tctx->io_wq);\n\tWARN_ON_ONCE(tctx->cached_refs);\n\n\tkfree(tctx->registered_rings);\n\tpercpu_counter_destroy(&tctx->inflight);\n\tkfree(tctx);\n\ttsk->io_uring = NULL;\n}\n\nstatic __cold int io_sq_offload_create(struct io_ring_ctx *ctx,\n\t\t\t\t       struct io_uring_params *p)\n{\n\tint ret;\n\n\t/* Retain compatibility with failing for an invalid attach attempt */\n\tif ((ctx->flags & (IORING_SETUP_ATTACH_WQ | IORING_SETUP_SQPOLL)) ==\n\t\t\t\tIORING_SETUP_ATTACH_WQ) {\n\t\tstruct fd f;\n\n\t\tf = fdget(p->wq_fd);\n\t\tif (!f.file)\n\t\t\treturn -ENXIO;\n\t\tif (f.file->f_op != &io_uring_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfdput(f);\n\t}\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tstruct task_struct *tsk;\n\t\tstruct io_sq_data *sqd;\n\t\tbool attached;\n\n\t\tret = security_uring_sqpoll();\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsqd = io_get_sq_data(p, &attached);\n\t\tif (IS_ERR(sqd)) {\n\t\t\tret = PTR_ERR(sqd);\n\t\t\tgoto err;\n\t\t}\n\n\t\tctx->sq_creds = get_current_cred();\n\t\tctx->sq_data = sqd;\n\t\tctx->sq_thread_idle = msecs_to_jiffies(p->sq_thread_idle);\n\t\tif (!ctx->sq_thread_idle)\n\t\t\tctx->sq_thread_idle = HZ;\n\n\t\tio_sq_thread_park(sqd);\n\t\tlist_add(&ctx->sqd_list, &sqd->ctx_list);\n\t\tio_sqd_update_thread_idle(sqd);\n\t\t/* don't attach to a dying SQPOLL thread, would be racy */\n\t\tret = (attached && !sqd->thread) ? -ENXIO : 0;\n\t\tio_sq_thread_unpark(sqd);\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tif (attached)\n\t\t\treturn 0;\n\n\t\tif (p->flags & IORING_SETUP_SQ_AFF) {\n\t\t\tint cpu = p->sq_thread_cpu;\n\n\t\t\tret = -EINVAL;\n\t\t\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\t\t\tgoto err_sqpoll;\n\t\t\tsqd->sq_cpu = cpu;\n\t\t} else {\n\t\t\tsqd->sq_cpu = -1;\n\t\t}\n\n\t\tsqd->task_pid = current->pid;\n\t\tsqd->task_tgid = current->tgid;\n\t\ttsk = create_io_thread(io_sq_thread, sqd, NUMA_NO_NODE);\n\t\tif (IS_ERR(tsk)) {\n\t\t\tret = PTR_ERR(tsk);\n\t\t\tgoto err_sqpoll;\n\t\t}\n\n\t\tsqd->thread = tsk;\n\t\tret = io_uring_alloc_task_context(tsk, ctx);\n\t\twake_up_new_task(tsk);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (p->flags & IORING_SETUP_SQ_AFF) {\n\t\t/* Can't have SQ_AFF without SQPOLL */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr_sqpoll:\n\tcomplete(&ctx->sq_data->exited);\nerr:\n\tio_sq_thread_finish(ctx);\n\treturn ret;\n}\n\nstatic inline void __io_unaccount_mem(struct user_struct *user,\n\t\t\t\t      unsigned long nr_pages)\n{\n\tatomic_long_sub(nr_pages, &user->locked_vm);\n}\n\nstatic inline int __io_account_mem(struct user_struct *user,\n\t\t\t\t   unsigned long nr_pages)\n{\n\tunsigned long page_limit, cur_pages, new_pages;\n\n\t/* Don't allow more pages than we can safely lock */\n\tpage_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tdo {\n\t\tcur_pages = atomic_long_read(&user->locked_vm);\n\t\tnew_pages = cur_pages + nr_pages;\n\t\tif (new_pages > page_limit)\n\t\t\treturn -ENOMEM;\n\t} while (atomic_long_cmpxchg(&user->locked_vm, cur_pages,\n\t\t\t\t\tnew_pages) != cur_pages);\n\n\treturn 0;\n}\n\nstatic void io_unaccount_mem(struct io_ring_ctx *ctx, unsigned long nr_pages)\n{\n\tif (ctx->user)\n\t\t__io_unaccount_mem(ctx->user, nr_pages);\n\n\tif (ctx->mm_account)\n\t\tatomic64_sub(nr_pages, &ctx->mm_account->pinned_vm);\n}\n\nstatic int io_account_mem(struct io_ring_ctx *ctx, unsigned long nr_pages)\n{\n\tint ret;\n\n\tif (ctx->user) {\n\t\tret = __io_account_mem(ctx->user, nr_pages);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ctx->mm_account)\n\t\tatomic64_add(nr_pages, &ctx->mm_account->pinned_vm);\n\n\treturn 0;\n}\n\nstatic void io_mem_free(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!ptr)\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\tif (put_page_testzero(page))\n\t\tfree_compound_page(page);\n}\n\nstatic void *io_mem_alloc(size_t size)\n{\n\tgfp_t gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;\n\n\treturn (void *) __get_free_pages(gfp, get_order(size));\n}\n\nstatic unsigned long rings_size(unsigned sq_entries, unsigned cq_entries,\n\t\t\t\tsize_t *sq_offset)\n{\n\tstruct io_rings *rings;\n\tsize_t off, sq_array_size;\n\n\toff = struct_size(rings, cqes, cq_entries);\n\tif (off == SIZE_MAX)\n\t\treturn SIZE_MAX;\n\n#ifdef CONFIG_SMP\n\toff = ALIGN(off, SMP_CACHE_BYTES);\n\tif (off == 0)\n\t\treturn SIZE_MAX;\n#endif\n\n\tif (sq_offset)\n\t\t*sq_offset = off;\n\n\tsq_array_size = array_size(sizeof(u32), sq_entries);\n\tif (sq_array_size == SIZE_MAX)\n\t\treturn SIZE_MAX;\n\n\tif (check_add_overflow(off, sq_array_size, &off))\n\t\treturn SIZE_MAX;\n\n\treturn off;\n}\n\nstatic void io_buffer_unmap(struct io_ring_ctx *ctx, struct io_mapped_ubuf **slot)\n{\n\tstruct io_mapped_ubuf *imu = *slot;\n\tunsigned int i;\n\n\tif (imu != ctx->dummy_ubuf) {\n\t\tfor (i = 0; i < imu->nr_bvecs; i++)\n\t\t\tunpin_user_page(imu->bvec[i].bv_page);\n\t\tif (imu->acct_pages)\n\t\t\tio_unaccount_mem(ctx, imu->acct_pages);\n\t\tkvfree(imu);\n\t}\n\t*slot = NULL;\n}\n\nstatic void io_rsrc_buf_put(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc)\n{\n\tio_buffer_unmap(ctx, &prsrc->buf);\n\tprsrc->buf = NULL;\n}\n\nstatic void __io_sqe_buffers_unregister(struct io_ring_ctx *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ctx->nr_user_bufs; i++)\n\t\tio_buffer_unmap(ctx, &ctx->user_bufs[i]);\n\tkfree(ctx->user_bufs);\n\tio_rsrc_data_free(ctx->buf_data);\n\tctx->user_bufs = NULL;\n\tctx->buf_data = NULL;\n\tctx->nr_user_bufs = 0;\n}\n\nstatic int io_sqe_buffers_unregister(struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\tif (!ctx->buf_data)\n\t\treturn -ENXIO;\n\n\tret = io_rsrc_ref_quiesce(ctx->buf_data, ctx);\n\tif (!ret)\n\t\t__io_sqe_buffers_unregister(ctx);\n\treturn ret;\n}\n\nstatic int io_copy_iov(struct io_ring_ctx *ctx, struct iovec *dst,\n\t\t       void __user *arg, unsigned index)\n{\n\tstruct iovec __user *src;\n\n#ifdef CONFIG_COMPAT\n\tif (ctx->compat) {\n\t\tstruct compat_iovec __user *ciovs;\n\t\tstruct compat_iovec ciov;\n\n\t\tciovs = (struct compat_iovec __user *) arg;\n\t\tif (copy_from_user(&ciov, &ciovs[index], sizeof(ciov)))\n\t\t\treturn -EFAULT;\n\n\t\tdst->iov_base = u64_to_user_ptr((u64)ciov.iov_base);\n\t\tdst->iov_len = ciov.iov_len;\n\t\treturn 0;\n\t}\n#endif\n\tsrc = (struct iovec __user *) arg;\n\tif (copy_from_user(dst, &src[index], sizeof(*dst)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * Not super efficient, but this is just a registration time. And we do cache\n * the last compound head, so generally we'll only do a full search if we don't\n * match that one.\n *\n * We check if the given compound head page has already been accounted, to\n * avoid double accounting it. This allows us to account the full size of the\n * page, not just the constituent pages of a huge page.\n */\nstatic bool headpage_already_acct(struct io_ring_ctx *ctx, struct page **pages,\n\t\t\t\t  int nr_pages, struct page *hpage)\n{\n\tint i, j;\n\n\t/* check current page array */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!PageCompound(pages[i]))\n\t\t\tcontinue;\n\t\tif (compound_head(pages[i]) == hpage)\n\t\t\treturn true;\n\t}\n\n\t/* check previously registered pages */\n\tfor (i = 0; i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *imu = ctx->user_bufs[i];\n\n\t\tfor (j = 0; j < imu->nr_bvecs; j++) {\n\t\t\tif (!PageCompound(imu->bvec[j].bv_page))\n\t\t\t\tcontinue;\n\t\t\tif (compound_head(imu->bvec[j].bv_page) == hpage)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int io_buffer_account_pin(struct io_ring_ctx *ctx, struct page **pages,\n\t\t\t\t int nr_pages, struct io_mapped_ubuf *imu,\n\t\t\t\t struct page **last_hpage)\n{\n\tint i, ret;\n\n\timu->acct_pages = 0;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!PageCompound(pages[i])) {\n\t\t\timu->acct_pages++;\n\t\t} else {\n\t\t\tstruct page *hpage;\n\n\t\t\thpage = compound_head(pages[i]);\n\t\t\tif (hpage == *last_hpage)\n\t\t\t\tcontinue;\n\t\t\t*last_hpage = hpage;\n\t\t\tif (headpage_already_acct(ctx, pages, i, hpage))\n\t\t\t\tcontinue;\n\t\t\timu->acct_pages += page_size(hpage) >> PAGE_SHIFT;\n\t\t}\n\t}\n\n\tif (!imu->acct_pages)\n\t\treturn 0;\n\n\tret = io_account_mem(ctx, imu->acct_pages);\n\tif (ret)\n\t\timu->acct_pages = 0;\n\treturn ret;\n}\n\nstatic int io_sqe_buffer_register(struct io_ring_ctx *ctx, struct iovec *iov,\n\t\t\t\t  struct io_mapped_ubuf **pimu,\n\t\t\t\t  struct page **last_hpage)\n{\n\tstruct io_mapped_ubuf *imu = NULL;\n\tstruct vm_area_struct **vmas = NULL;\n\tstruct page **pages = NULL;\n\tunsigned long off, start, end, ubuf;\n\tsize_t size;\n\tint ret, pret, nr_pages, i;\n\n\tif (!iov->iov_base) {\n\t\t*pimu = ctx->dummy_ubuf;\n\t\treturn 0;\n\t}\n\n\tubuf = (unsigned long) iov->iov_base;\n\tend = (ubuf + iov->iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstart = ubuf >> PAGE_SHIFT;\n\tnr_pages = end - start;\n\n\t*pimu = NULL;\n\tret = -ENOMEM;\n\n\tpages = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto done;\n\n\tvmas = kvmalloc_array(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t      GFP_KERNEL);\n\tif (!vmas)\n\t\tgoto done;\n\n\timu = kvmalloc(struct_size(imu, bvec, nr_pages), GFP_KERNEL);\n\tif (!imu)\n\t\tgoto done;\n\n\tret = 0;\n\tmmap_read_lock(current->mm);\n\tpret = pin_user_pages(ubuf, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t      pages, vmas);\n\tif (pret == nr_pages) {\n\t\t/* don't support file backed memory */\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\t\tif (vma_is_shmem(vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_file &&\n\t\t\t    !is_file_hugepages(vma->vm_file)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = pret < 0 ? pret : -EFAULT;\n\t}\n\tmmap_read_unlock(current->mm);\n\tif (ret) {\n\t\t/*\n\t\t * if we did partial map, or found file backed vmas,\n\t\t * release any pages we did get\n\t\t */\n\t\tif (pret > 0)\n\t\t\tunpin_user_pages(pages, pret);\n\t\tgoto done;\n\t}\n\n\tret = io_buffer_account_pin(ctx, pages, pret, imu, last_hpage);\n\tif (ret) {\n\t\tunpin_user_pages(pages, pret);\n\t\tgoto done;\n\t}\n\n\toff = ubuf & ~PAGE_MASK;\n\tsize = iov->iov_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t vec_len;\n\n\t\tvec_len = min_t(size_t, size, PAGE_SIZE - off);\n\t\timu->bvec[i].bv_page = pages[i];\n\t\timu->bvec[i].bv_len = vec_len;\n\t\timu->bvec[i].bv_offset = off;\n\t\toff = 0;\n\t\tsize -= vec_len;\n\t}\n\t/* store original address for later verification */\n\timu->ubuf = ubuf;\n\timu->ubuf_end = ubuf + iov->iov_len;\n\timu->nr_bvecs = nr_pages;\n\t*pimu = imu;\n\tret = 0;\ndone:\n\tif (ret)\n\t\tkvfree(imu);\n\tkvfree(pages);\n\tkvfree(vmas);\n\treturn ret;\n}\n\nstatic int io_buffers_map_alloc(struct io_ring_ctx *ctx, unsigned int nr_args)\n{\n\tctx->user_bufs = kcalloc(nr_args, sizeof(*ctx->user_bufs), GFP_KERNEL);\n\treturn ctx->user_bufs ? 0 : -ENOMEM;\n}\n\nstatic int io_buffer_validate(struct iovec *iov)\n{\n\tunsigned long tmp, acct_len = iov->iov_len + (PAGE_SIZE - 1);\n\n\t/*\n\t * Don't impose further limits on the size and buffer\n\t * constraints here, we'll -EINVAL later when IO is\n\t * submitted if they are wrong.\n\t */\n\tif (!iov->iov_base)\n\t\treturn iov->iov_len ? -EFAULT : 0;\n\tif (!iov->iov_len)\n\t\treturn -EFAULT;\n\n\t/* arbitrary limit, but we need something */\n\tif (iov->iov_len > SZ_1G)\n\t\treturn -EFAULT;\n\n\tif (check_add_overflow((unsigned long)iov->iov_base, acct_len, &tmp))\n\t\treturn -EOVERFLOW;\n\n\treturn 0;\n}\n\nstatic int io_sqe_buffers_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t   unsigned int nr_args, u64 __user *tags)\n{\n\tstruct page *last_hpage = NULL;\n\tstruct io_rsrc_data *data;\n\tint i, ret;\n\tstruct iovec iov;\n\n\tif (ctx->user_bufs)\n\t\treturn -EBUSY;\n\tif (!nr_args || nr_args > IORING_MAX_REG_BUFFERS)\n\t\treturn -EINVAL;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\treturn ret;\n\tret = io_rsrc_data_alloc(ctx, io_rsrc_buf_put, tags, nr_args, &data);\n\tif (ret)\n\t\treturn ret;\n\tret = io_buffers_map_alloc(ctx, nr_args);\n\tif (ret) {\n\t\tio_rsrc_data_free(data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_args; i++, ctx->nr_user_bufs++) {\n\t\tret = io_copy_iov(ctx, &iov, arg, i);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = io_buffer_validate(&iov);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!iov.iov_base && *io_get_tag_slot(data, i)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_sqe_buffer_register(ctx, &iov, &ctx->user_bufs[i],\n\t\t\t\t\t     &last_hpage);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(ctx->buf_data);\n\n\tctx->buf_data = data;\n\tif (ret)\n\t\t__io_sqe_buffers_unregister(ctx);\n\telse\n\t\tio_rsrc_node_switch(ctx, NULL);\n\treturn ret;\n}\n\nstatic int __io_sqe_buffers_update(struct io_ring_ctx *ctx,\n\t\t\t\t   struct io_uring_rsrc_update2 *up,\n\t\t\t\t   unsigned int nr_args)\n{\n\tu64 __user *tags = u64_to_user_ptr(up->tags);\n\tstruct iovec iov, __user *iovs = u64_to_user_ptr(up->data);\n\tstruct page *last_hpage = NULL;\n\tbool needs_switch = false;\n\t__u32 done;\n\tint i, err;\n\n\tif (!ctx->buf_data)\n\t\treturn -ENXIO;\n\tif (up->offset + nr_args > ctx->nr_user_bufs)\n\t\treturn -EINVAL;\n\n\tfor (done = 0; done < nr_args; done++) {\n\t\tstruct io_mapped_ubuf *imu;\n\t\tint offset = up->offset + done;\n\t\tu64 tag = 0;\n\n\t\terr = io_copy_iov(ctx, &iov, iovs, done);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (tags && copy_from_user(&tag, &tags[done], sizeof(tag))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = io_buffer_validate(&iov);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!iov.iov_base && tag) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = io_sqe_buffer_register(ctx, &iov, &imu, &last_hpage);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\ti = array_index_nospec(offset, ctx->nr_user_bufs);\n\t\tif (ctx->user_bufs[i] != ctx->dummy_ubuf) {\n\t\t\terr = io_queue_rsrc_removal(ctx->buf_data, i,\n\t\t\t\t\t\t    ctx->rsrc_node, ctx->user_bufs[i]);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tio_buffer_unmap(ctx, &imu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx->user_bufs[i] = NULL;\n\t\t\tneeds_switch = true;\n\t\t}\n\n\t\tctx->user_bufs[i] = imu;\n\t\t*io_get_tag_slot(ctx->buf_data, offset) = tag;\n\t}\n\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, ctx->buf_data);\n\treturn done ? done : err;\n}\n\nstatic int io_eventfd_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t       unsigned int eventfd_async)\n{\n\tstruct io_ev_fd *ev_fd;\n\t__s32 __user *fds = arg;\n\tint fd;\n\n\tev_fd = rcu_dereference_protected(ctx->io_ev_fd,\n\t\t\t\t\tlockdep_is_held(&ctx->uring_lock));\n\tif (ev_fd)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&fd, fds, sizeof(*fds)))\n\t\treturn -EFAULT;\n\n\tev_fd = kmalloc(sizeof(*ev_fd), GFP_KERNEL);\n\tif (!ev_fd)\n\t\treturn -ENOMEM;\n\n\tev_fd->cq_ev_fd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(ev_fd->cq_ev_fd)) {\n\t\tint ret = PTR_ERR(ev_fd->cq_ev_fd);\n\t\tkfree(ev_fd);\n\t\treturn ret;\n\t}\n\tev_fd->eventfd_async = eventfd_async;\n\tctx->has_evfd = true;\n\trcu_assign_pointer(ctx->io_ev_fd, ev_fd);\n\treturn 0;\n}\n\nstatic void io_eventfd_put(struct rcu_head *rcu)\n{\n\tstruct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);\n\n\teventfd_ctx_put(ev_fd->cq_ev_fd);\n\tkfree(ev_fd);\n}\n\nstatic int io_eventfd_unregister(struct io_ring_ctx *ctx)\n{\n\tstruct io_ev_fd *ev_fd;\n\n\tev_fd = rcu_dereference_protected(ctx->io_ev_fd,\n\t\t\t\t\tlockdep_is_held(&ctx->uring_lock));\n\tif (ev_fd) {\n\t\tctx->has_evfd = false;\n\t\trcu_assign_pointer(ctx->io_ev_fd, NULL);\n\t\tcall_rcu(&ev_fd->rcu, io_eventfd_put);\n\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic void io_destroy_buffers(struct io_ring_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < (1U << IO_BUFFERS_HASH_BITS); i++) {\n\t\tstruct list_head *list = &ctx->io_buffers[i];\n\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct io_buffer_list *bl;\n\n\t\t\tbl = list_first_entry(list, struct io_buffer_list, list);\n\t\t\t__io_remove_buffers(ctx, bl, -1U);\n\t\t\tlist_del(&bl->list);\n\t\t\tkfree(bl);\n\t\t}\n\t}\n\n\twhile (!list_empty(&ctx->io_buffers_pages)) {\n\t\tstruct page *page;\n\n\t\tpage = list_first_entry(&ctx->io_buffers_pages, struct page, lru);\n\t\tlist_del_init(&page->lru);\n\t\t__free_page(page);\n\t}\n}\n\nstatic void io_req_caches_free(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\tint nr = 0;\n\n\tmutex_lock(&ctx->uring_lock);\n\tio_flush_cached_locked_reqs(ctx, state);\n\n\twhile (state->free_list.next) {\n\t\tstruct io_wq_work_node *node;\n\t\tstruct io_kiocb *req;\n\n\t\tnode = wq_stack_extract(&state->free_list);\n\t\treq = container_of(node, struct io_kiocb, comp_list);\n\t\tkmem_cache_free(req_cachep, req);\n\t\tnr++;\n\t}\n\tif (nr)\n\t\tpercpu_ref_put_many(&ctx->refs, nr);\n\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic void io_wait_rsrc_data(struct io_rsrc_data *data)\n{\n\tif (data && !atomic_dec_and_test(&data->refs))\n\t\twait_for_completion(&data->done);\n}\n\nstatic void io_flush_apoll_cache(struct io_ring_ctx *ctx)\n{\n\tstruct async_poll *apoll;\n\n\twhile (!list_empty(&ctx->apoll_cache)) {\n\t\tapoll = list_first_entry(&ctx->apoll_cache, struct async_poll,\n\t\t\t\t\t\tpoll.wait.entry);\n\t\tlist_del(&apoll->poll.wait.entry);\n\t\tkfree(apoll);\n\t}\n}\n\nstatic __cold void io_ring_ctx_free(struct io_ring_ctx *ctx)\n{\n\tio_sq_thread_finish(ctx);\n\n\tif (ctx->mm_account) {\n\t\tmmdrop(ctx->mm_account);\n\t\tctx->mm_account = NULL;\n\t}\n\n\tio_rsrc_refs_drop(ctx);\n\t/* __io_rsrc_put_work() may need uring_lock to progress, wait w/o it */\n\tio_wait_rsrc_data(ctx->buf_data);\n\tio_wait_rsrc_data(ctx->file_data);\n\n\tmutex_lock(&ctx->uring_lock);\n\tif (ctx->buf_data)\n\t\t__io_sqe_buffers_unregister(ctx);\n\tif (ctx->file_data)\n\t\t__io_sqe_files_unregister(ctx);\n\tif (ctx->rings)\n\t\t__io_cqring_overflow_flush(ctx, true);\n\tio_eventfd_unregister(ctx);\n\tio_flush_apoll_cache(ctx);\n\tmutex_unlock(&ctx->uring_lock);\n\tio_destroy_buffers(ctx);\n\tif (ctx->sq_creds)\n\t\tput_cred(ctx->sq_creds);\n\n\t/* there are no registered resources left, nobody uses it */\n\tif (ctx->rsrc_node)\n\t\tio_rsrc_node_destroy(ctx->rsrc_node);\n\tif (ctx->rsrc_backup_node)\n\t\tio_rsrc_node_destroy(ctx->rsrc_backup_node);\n\tflush_delayed_work(&ctx->rsrc_put_work);\n\tflush_delayed_work(&ctx->fallback_work);\n\n\tWARN_ON_ONCE(!list_empty(&ctx->rsrc_ref_list));\n\tWARN_ON_ONCE(!llist_empty(&ctx->rsrc_put_llist));\n\n#if defined(CONFIG_UNIX)\n\tif (ctx->ring_sock) {\n\t\tctx->ring_sock->file = NULL; /* so that iput() is called */\n\t\tsock_release(ctx->ring_sock);\n\t}\n#endif\n\tWARN_ON_ONCE(!list_empty(&ctx->ltimeout_list));\n\n\tio_mem_free(ctx->rings);\n\tio_mem_free(ctx->sq_sqes);\n\n\tpercpu_ref_exit(&ctx->refs);\n\tfree_uid(ctx->user);\n\tio_req_caches_free(ctx);\n\tif (ctx->hash_map)\n\t\tio_wq_put_hash(ctx->hash_map);\n\tkfree(ctx->cancel_hash);\n\tkfree(ctx->dummy_ubuf);\n\tkfree(ctx->io_buffers);\n\tkfree(ctx);\n}\n\nstatic __poll_t io_uring_poll(struct file *file, poll_table *wait)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &ctx->cq_wait, wait);\n\t/*\n\t * synchronizes with barrier from wq_has_sleeper call in\n\t * io_commit_cqring\n\t */\n\tsmp_rmb();\n\tif (!io_sqring_full(ctx))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\t/*\n\t * Don't flush cqring overflow list here, just do a simple check.\n\t * Otherwise there could possible be ABBA deadlock:\n\t *      CPU0                    CPU1\n\t *      ----                    ----\n\t * lock(&ctx->uring_lock);\n\t *                              lock(&ep->mtx);\n\t *                              lock(&ctx->uring_lock);\n\t * lock(&ep->mtx);\n\t *\n\t * Users may get EPOLLIN meanwhile seeing nothing in cqring, this\n\t * pushs them to do the flush.\n\t */\n\tif (io_cqring_events(ctx) || test_bit(0, &ctx->check_cq_overflow))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)\n{\n\tconst struct cred *creds;\n\n\tcreds = xa_erase(&ctx->personalities, id);\n\tif (creds) {\n\t\tput_cred(creds);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstruct io_tctx_exit {\n\tstruct callback_head\t\ttask_work;\n\tstruct completion\t\tcompletion;\n\tstruct io_ring_ctx\t\t*ctx;\n};\n\nstatic __cold void io_tctx_exit_cb(struct callback_head *cb)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_exit *work;\n\n\twork = container_of(cb, struct io_tctx_exit, task_work);\n\t/*\n\t * When @in_idle, we're in cancellation and it's racy to remove the\n\t * node. It'll be removed by the end of cancellation, just ignore it.\n\t */\n\tif (!atomic_read(&tctx->in_idle))\n\t\tio_uring_del_tctx_node((unsigned long)work->ctx);\n\tcomplete(&work->completion);\n}\n\nstatic __cold bool io_cancel_ctx_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\n\treturn req->ctx == data;\n}\n\nstatic __cold void io_ring_exit_work(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx, exit_work);\n\tunsigned long timeout = jiffies + HZ * 60 * 5;\n\tunsigned long interval = HZ / 20;\n\tstruct io_tctx_exit exit;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\t/*\n\t * If we're doing polled IO and end up having requests being\n\t * submitted async (out-of-line), then completions can come in while\n\t * we're waiting for refs to drop. We need to reap these manually,\n\t * as nobody else will be looking for them.\n\t */\n\tdo {\n\t\tio_uring_try_cancel_requests(ctx, NULL, true);\n\t\tif (ctx->sq_data) {\n\t\t\tstruct io_sq_data *sqd = ctx->sq_data;\n\t\t\tstruct task_struct *tsk;\n\n\t\t\tio_sq_thread_park(sqd);\n\t\t\ttsk = sqd->thread;\n\t\t\tif (tsk && tsk->io_uring && tsk->io_uring->io_wq)\n\t\t\t\tio_wq_cancel_cb(tsk->io_uring->io_wq,\n\t\t\t\t\t\tio_cancel_ctx_cb, ctx, true);\n\t\t\tio_sq_thread_unpark(sqd);\n\t\t}\n\n\t\tio_req_caches_free(ctx);\n\n\t\tif (WARN_ON_ONCE(time_after(jiffies, timeout))) {\n\t\t\t/* there is little hope left, don't run it too often */\n\t\t\tinterval = HZ * 60;\n\t\t}\n\t} while (!wait_for_completion_timeout(&ctx->ref_comp, interval));\n\n\tinit_completion(&exit.completion);\n\tinit_task_work(&exit.task_work, io_tctx_exit_cb);\n\texit.ctx = ctx;\n\t/*\n\t * Some may use context even when all refs and requests have been put,\n\t * and they are free to do so while still holding uring_lock or\n\t * completion_lock, see io_req_task_submit(). Apart from other work,\n\t * this lock/unlock section also waits them to finish.\n\t */\n\tmutex_lock(&ctx->uring_lock);\n\twhile (!list_empty(&ctx->tctx_list)) {\n\t\tWARN_ON_ONCE(time_after(jiffies, timeout));\n\n\t\tnode = list_first_entry(&ctx->tctx_list, struct io_tctx_node,\n\t\t\t\t\tctx_node);\n\t\t/* don't spin on a single task if cancellation failed */\n\t\tlist_rotate_left(&ctx->tctx_list);\n\t\tret = task_work_add(node->task, &exit.task_work, TWA_SIGNAL);\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\tcontinue;\n\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\twait_for_completion(&exit.completion);\n\t\tmutex_lock(&ctx->uring_lock);\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\tspin_lock(&ctx->completion_lock);\n\tspin_unlock(&ctx->completion_lock);\n\n\tio_ring_ctx_free(ctx);\n}\n\n/* Returns true if we found and killed one or more timeouts */\nstatic __cold bool io_kill_timeouts(struct io_ring_ctx *ctx,\n\t\t\t\t    struct task_struct *tsk, bool cancel_all)\n{\n\tstruct io_kiocb *req, *tmp;\n\tint canceled = 0;\n\n\tspin_lock(&ctx->completion_lock);\n\tspin_lock_irq(&ctx->timeout_lock);\n\tlist_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {\n\t\tif (io_match_task(req, tsk, cancel_all)) {\n\t\t\tio_kill_timeout(req, -ECANCELED);\n\t\t\tcanceled++;\n\t\t}\n\t}\n\tspin_unlock_irq(&ctx->timeout_lock);\n\tif (canceled != 0)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (canceled != 0)\n\t\tio_cqring_ev_posted(ctx);\n\treturn canceled != 0;\n}\n\nstatic __cold void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)\n{\n\tunsigned long index;\n\tstruct creds *creds;\n\n\tmutex_lock(&ctx->uring_lock);\n\tpercpu_ref_kill(&ctx->refs);\n\tif (ctx->rings)\n\t\t__io_cqring_overflow_flush(ctx, true);\n\txa_for_each(&ctx->personalities, index, creds)\n\t\tio_unregister_personality(ctx, index);\n\tmutex_unlock(&ctx->uring_lock);\n\n\tio_kill_timeouts(ctx, NULL, true);\n\tio_poll_remove_all(ctx, NULL, true);\n\n\t/* if we failed setting up the ctx, we might not have any rings */\n\tio_iopoll_try_reap_events(ctx);\n\n\tINIT_WORK(&ctx->exit_work, io_ring_exit_work);\n\t/*\n\t * Use system_unbound_wq to avoid spawning tons of event kworkers\n\t * if we're exiting a ton of rings at the same time. It just adds\n\t * noise and overhead, there's no discernable change in runtime\n\t * over using system_wq.\n\t */\n\tqueue_work(system_unbound_wq, &ctx->exit_work);\n}\n\nstatic int io_uring_release(struct inode *inode, struct file *file)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\n\tfile->private_data = NULL;\n\tio_ring_ctx_wait_and_kill(ctx);\n\treturn 0;\n}\n\nstruct io_task_cancel {\n\tstruct task_struct *task;\n\tbool all;\n};\n\nstatic bool io_cancel_task_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tstruct io_task_cancel *cancel = data;\n\n\treturn io_match_task_safe(req, cancel->task, cancel->all);\n}\n\nstatic __cold bool io_cancel_defer_files(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct task_struct *task,\n\t\t\t\t\t bool cancel_all)\n{\n\tstruct io_defer_entry *de;\n\tLIST_HEAD(list);\n\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry_reverse(de, &ctx->defer_list, list) {\n\t\tif (io_match_task_safe(de->req, task, cancel_all)) {\n\t\t\tlist_cut_position(&list, &ctx->defer_list, &de->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\tif (list_empty(&list))\n\t\treturn false;\n\n\twhile (!list_empty(&list)) {\n\t\tde = list_first_entry(&list, struct io_defer_entry, list);\n\t\tlist_del_init(&de->list);\n\t\tio_req_complete_failed(de->req, -ECANCELED);\n\t\tkfree(de);\n\t}\n\treturn true;\n}\n\nstatic __cold bool io_uring_try_cancel_iowq(struct io_ring_ctx *ctx)\n{\n\tstruct io_tctx_node *node;\n\tenum io_wq_cancel cret;\n\tbool ret = false;\n\n\tmutex_lock(&ctx->uring_lock);\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\t/*\n\t\t * io_wq will stay alive while we hold uring_lock, because it's\n\t\t * killed after ctx nodes, which requires to take the lock.\n\t\t */\n\t\tif (!tctx || !tctx->io_wq)\n\t\t\tcontinue;\n\t\tcret = io_wq_cancel_cb(tctx->io_wq, io_cancel_ctx_cb, ctx, true);\n\t\tret |= (cret != IO_WQ_CANCEL_NOTFOUND);\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\n\treturn ret;\n}\n\nstatic __cold void io_uring_try_cancel_requests(struct io_ring_ctx *ctx,\n\t\t\t\t\t\tstruct task_struct *task,\n\t\t\t\t\t\tbool cancel_all)\n{\n\tstruct io_task_cancel cancel = { .task = task, .all = cancel_all, };\n\tstruct io_uring_task *tctx = task ? task->io_uring : NULL;\n\n\twhile (1) {\n\t\tenum io_wq_cancel cret;\n\t\tbool ret = false;\n\n\t\tif (!task) {\n\t\t\tret |= io_uring_try_cancel_iowq(ctx);\n\t\t} else if (tctx && tctx->io_wq) {\n\t\t\t/*\n\t\t\t * Cancels requests of all rings, not only @ctx, but\n\t\t\t * it's fine as the task is in exit/exec.\n\t\t\t */\n\t\t\tcret = io_wq_cancel_cb(tctx->io_wq, io_cancel_task_cb,\n\t\t\t\t\t       &cancel, true);\n\t\t\tret |= (cret != IO_WQ_CANCEL_NOTFOUND);\n\t\t}\n\n\t\t/* SQPOLL thread does its own polling */\n\t\tif ((!(ctx->flags & IORING_SETUP_SQPOLL) && cancel_all) ||\n\t\t    (ctx->sq_data && ctx->sq_data->thread == current)) {\n\t\t\twhile (!wq_list_empty(&ctx->iopoll_list)) {\n\t\t\t\tio_iopoll_try_reap_events(ctx);\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\n\t\tret |= io_cancel_defer_files(ctx, task, cancel_all);\n\t\tret |= io_poll_remove_all(ctx, task, cancel_all);\n\t\tret |= io_kill_timeouts(ctx, task, cancel_all);\n\t\tif (task)\n\t\t\tret |= io_run_task_work();\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}\n\nstatic int __io_uring_add_tctx_node(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\tif (unlikely(!tctx)) {\n\t\tret = io_uring_alloc_task_context(current, ctx);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\ttctx = current->io_uring;\n\t\tif (ctx->iowq_limits_set) {\n\t\t\tunsigned int limits[2] = { ctx->iowq_limits[0],\n\t\t\t\t\t\t   ctx->iowq_limits[1], };\n\n\t\t\tret = io_wq_max_workers(tctx->io_wq, limits);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!xa_load(&tctx->xa, (unsigned long)ctx)) {\n\t\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\t\tnode->ctx = ctx;\n\t\tnode->task = current;\n\n\t\tret = xa_err(xa_store(&tctx->xa, (unsigned long)ctx,\n\t\t\t\t\tnode, GFP_KERNEL));\n\t\tif (ret) {\n\t\t\tkfree(node);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tlist_add(&node->ctx_node, &ctx->tctx_list);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\ttctx->last = ctx;\n\treturn 0;\n}\n\n/*\n * Note that this task has used io_uring. We use it for cancelation purposes.\n */\nstatic inline int io_uring_add_tctx_node(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\tif (likely(tctx && tctx->last == ctx))\n\t\treturn 0;\n\treturn __io_uring_add_tctx_node(ctx);\n}\n\n/*\n * Remove this io_uring_file -> task mapping.\n */\nstatic __cold void io_uring_del_tctx_node(unsigned long index)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_node *node;\n\n\tif (!tctx)\n\t\treturn;\n\tnode = xa_erase(&tctx->xa, index);\n\tif (!node)\n\t\treturn;\n\n\tWARN_ON_ONCE(current != node->task);\n\tWARN_ON_ONCE(list_empty(&node->ctx_node));\n\n\tmutex_lock(&node->ctx->uring_lock);\n\tlist_del(&node->ctx_node);\n\tmutex_unlock(&node->ctx->uring_lock);\n\n\tif (tctx->last == node->ctx)\n\t\ttctx->last = NULL;\n\tkfree(node);\n}\n\nstatic __cold void io_uring_clean_tctx(struct io_uring_task *tctx)\n{\n\tstruct io_wq *wq = tctx->io_wq;\n\tstruct io_tctx_node *node;\n\tunsigned long index;\n\n\txa_for_each(&tctx->xa, index, node) {\n\t\tio_uring_del_tctx_node(index);\n\t\tcond_resched();\n\t}\n\tif (wq) {\n\t\t/*\n\t\t * Must be after io_uring_del_tctx_node() (removes nodes under\n\t\t * uring_lock) to avoid race with io_uring_try_cancel_iowq().\n\t\t */\n\t\tio_wq_put_and_exit(wq);\n\t\ttctx->io_wq = NULL;\n\t}\n}\n\nstatic s64 tctx_inflight(struct io_uring_task *tctx, bool tracked)\n{\n\tif (tracked)\n\t\treturn 0;\n\treturn percpu_counter_sum(&tctx->inflight);\n}\n\n/*\n * Find any io_uring ctx that this task has registered or done IO on, and cancel\n * requests. @sqd should be not-null IFF it's an SQPOLL thread cancellation.\n */\nstatic __cold void io_uring_cancel_generic(bool cancel_all,\n\t\t\t\t\t   struct io_sq_data *sqd)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_ring_ctx *ctx;\n\ts64 inflight;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON_ONCE(sqd && sqd->thread != current);\n\n\tif (!current->io_uring)\n\t\treturn;\n\tif (tctx->io_wq)\n\t\tio_wq_exit_start(tctx->io_wq);\n\n\tatomic_inc(&tctx->in_idle);\n\tdo {\n\t\tio_uring_drop_tctx_refs(current);\n\t\t/* read completions before cancelations */\n\t\tinflight = tctx_inflight(tctx, !cancel_all);\n\t\tif (!inflight)\n\t\t\tbreak;\n\n\t\tif (!sqd) {\n\t\t\tstruct io_tctx_node *node;\n\t\t\tunsigned long index;\n\n\t\t\txa_for_each(&tctx->xa, index, node) {\n\t\t\t\t/* sqpoll task will cancel all its requests */\n\t\t\t\tif (node->ctx->sq_data)\n\t\t\t\t\tcontinue;\n\t\t\t\tio_uring_try_cancel_requests(node->ctx, current,\n\t\t\t\t\t\t\t     cancel_all);\n\t\t\t}\n\t\t} else {\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\t\t\tio_uring_try_cancel_requests(ctx, current,\n\t\t\t\t\t\t\t     cancel_all);\n\t\t}\n\n\t\tprepare_to_wait(&tctx->wait, &wait, TASK_INTERRUPTIBLE);\n\t\tio_run_task_work();\n\t\tio_uring_drop_tctx_refs(current);\n\n\t\t/*\n\t\t * If we've seen completions, retry without waiting. This\n\t\t * avoids a race where a completion comes in before we did\n\t\t * prepare_to_wait().\n\t\t */\n\t\tif (inflight == tctx_inflight(tctx, !cancel_all))\n\t\t\tschedule();\n\t\tfinish_wait(&tctx->wait, &wait);\n\t} while (1);\n\n\tio_uring_clean_tctx(tctx);\n\tif (cancel_all) {\n\t\t/*\n\t\t * We shouldn't run task_works after cancel, so just leave\n\t\t * ->in_idle set for normal exit.\n\t\t */\n\t\tatomic_dec(&tctx->in_idle);\n\t\t/* for exec all current's requests should be gone, kill tctx */\n\t\t__io_uring_free(current);\n\t}\n}\n\nvoid __io_uring_cancel(bool cancel_all)\n{\n\tio_uring_cancel_generic(cancel_all, NULL);\n}\n\nvoid io_uring_unreg_ringfd(void)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tint i;\n\n\tfor (i = 0; i < IO_RINGFD_REG_MAX; i++) {\n\t\tif (tctx->registered_rings[i]) {\n\t\t\tfput(tctx->registered_rings[i]);\n\t\t\ttctx->registered_rings[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int io_ring_add_registered_fd(struct io_uring_task *tctx, int fd,\n\t\t\t\t     int start, int end)\n{\n\tstruct file *file;\n\tint offset;\n\n\tfor (offset = start; offset < end; offset++) {\n\t\toffset = array_index_nospec(offset, IO_RINGFD_REG_MAX);\n\t\tif (tctx->registered_rings[offset])\n\t\t\tcontinue;\n\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\treturn -EBADF;\n\t\t} else if (file->f_op != &io_uring_fops) {\n\t\t\tfput(file);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\ttctx->registered_rings[offset] = file;\n\t\treturn offset;\n\t}\n\n\treturn -EBUSY;\n}\n\n/*\n * Register a ring fd to avoid fdget/fdput for each io_uring_enter()\n * invocation. User passes in an array of struct io_uring_rsrc_update\n * with ->data set to the ring_fd, and ->offset given for the desired\n * index. If no index is desired, application may set ->offset == -1U\n * and we'll find an available index. Returns number of entries\n * successfully processed, or < 0 on error if none were processed.\n */\nstatic int io_ringfd_register(struct io_ring_ctx *ctx, void __user *__arg,\n\t\t\t      unsigned nr_args)\n{\n\tstruct io_uring_rsrc_update __user *arg = __arg;\n\tstruct io_uring_rsrc_update reg;\n\tstruct io_uring_task *tctx;\n\tint ret, i;\n\n\tif (!nr_args || nr_args > IO_RINGFD_REG_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_unlock(&ctx->uring_lock);\n\tret = io_uring_add_tctx_node(ctx);\n\tmutex_lock(&ctx->uring_lock);\n\tif (ret)\n\t\treturn ret;\n\n\ttctx = current->io_uring;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tint start, end;\n\n\t\tif (copy_from_user(&reg, &arg[i], sizeof(reg))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (reg.offset == -1U) {\n\t\t\tstart = 0;\n\t\t\tend = IO_RINGFD_REG_MAX;\n\t\t} else {\n\t\t\tif (reg.offset >= IO_RINGFD_REG_MAX) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = reg.offset;\n\t\t\tend = start + 1;\n\t\t}\n\n\t\tret = io_ring_add_registered_fd(tctx, reg.data, start, end);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\treg.offset = ret;\n\t\tif (copy_to_user(&arg[i], &reg, sizeof(reg))) {\n\t\t\tfput(tctx->registered_rings[reg.offset]);\n\t\t\ttctx->registered_rings[reg.offset] = NULL;\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i ? i : ret;\n}\n\nstatic int io_ringfd_unregister(struct io_ring_ctx *ctx, void __user *__arg,\n\t\t\t\tunsigned nr_args)\n{\n\tstruct io_uring_rsrc_update __user *arg = __arg;\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_uring_rsrc_update reg;\n\tint ret = 0, i;\n\n\tif (!nr_args || nr_args > IO_RINGFD_REG_MAX)\n\t\treturn -EINVAL;\n\tif (!tctx)\n\t\treturn 0;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (copy_from_user(&reg, &arg[i], sizeof(reg))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (reg.offset >= IO_RINGFD_REG_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\treg.offset = array_index_nospec(reg.offset, IO_RINGFD_REG_MAX);\n\t\tif (tctx->registered_rings[reg.offset]) {\n\t\t\tfput(tctx->registered_rings[reg.offset]);\n\t\t\ttctx->registered_rings[reg.offset] = NULL;\n\t\t}\n\t}\n\n\treturn i ? i : ret;\n}\n\nstatic void *io_uring_validate_mmap_request(struct file *file,\n\t\t\t\t\t    loff_t pgoff, size_t sz)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\tloff_t offset = pgoff << PAGE_SHIFT;\n\tstruct page *page;\n\tvoid *ptr;\n\n\tswitch (offset) {\n\tcase IORING_OFF_SQ_RING:\n\tcase IORING_OFF_CQ_RING:\n\t\tptr = ctx->rings;\n\t\tbreak;\n\tcase IORING_OFF_SQES:\n\t\tptr = ctx->sq_sqes;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpage = virt_to_head_page(ptr);\n\tif (sz > page_size(page))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ptr;\n}\n\n#ifdef CONFIG_MMU\n\nstatic __cold int io_uring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t sz = vma->vm_end - vma->vm_start;\n\tunsigned long pfn;\n\tvoid *ptr;\n\n\tptr = io_uring_validate_mmap_request(file, vma->vm_pgoff, sz);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tpfn = virt_to_phys(ptr) >> PAGE_SHIFT;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn, sz, vma->vm_page_prot);\n}\n\n#else /* !CONFIG_MMU */\n\nstatic int io_uring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_SHARED | VM_MAYSHARE) ? 0 : -EINVAL;\n}\n\nstatic unsigned int io_uring_nommu_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_DIRECT | NOMMU_MAP_READ | NOMMU_MAP_WRITE;\n}\n\nstatic unsigned long io_uring_nommu_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len,\n\tunsigned long pgoff, unsigned long flags)\n{\n\tvoid *ptr;\n\n\tptr = io_uring_validate_mmap_request(file, pgoff, len);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\treturn (unsigned long) ptr;\n}\n\n#endif /* !CONFIG_MMU */\n\nstatic int io_sqpoll_wait_sq(struct io_ring_ctx *ctx)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tif (!io_sqring_full(ctx))\n\t\t\tbreak;\n\t\tprepare_to_wait(&ctx->sqo_sq_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (!io_sqring_full(ctx))\n\t\t\tbreak;\n\t\tschedule();\n\t} while (!signal_pending(current));\n\n\tfinish_wait(&ctx->sqo_sq_wait, &wait);\n\treturn 0;\n}\n\nstatic int io_get_ext_arg(unsigned flags, const void __user *argp, size_t *argsz,\n\t\t\t  struct __kernel_timespec __user **ts,\n\t\t\t  const sigset_t __user **sig)\n{\n\tstruct io_uring_getevents_arg arg;\n\n\t/*\n\t * If EXT_ARG isn't set, then we have no timespec and the argp pointer\n\t * is just a pointer to the sigset_t.\n\t */\n\tif (!(flags & IORING_ENTER_EXT_ARG)) {\n\t\t*sig = (const sigset_t __user *) argp;\n\t\t*ts = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EXT_ARG is set - ensure we agree on the size of it and copy in our\n\t * timespec and sigset_t pointers if good.\n\t */\n\tif (*argsz != sizeof(arg))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&arg, argp, sizeof(arg)))\n\t\treturn -EFAULT;\n\t*sig = u64_to_user_ptr(arg.sigmask);\n\t*argsz = arg.sigmask_sz;\n\t*ts = u64_to_user_ptr(arg.ts);\n\treturn 0;\n}\n\nSYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,\n\t\tu32, min_complete, u32, flags, const void __user *, argp,\n\t\tsize_t, argsz)\n{\n\tstruct io_ring_ctx *ctx;\n\tint submitted = 0;\n\tstruct fd f;\n\tlong ret;\n\n\tio_run_task_work();\n\n\tif (unlikely(flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |\n\t\t\t       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG |\n\t\t\t       IORING_ENTER_REGISTERED_RING)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ring fd has been registered via IORING_REGISTER_RING_FDS, we\n\t * need only dereference our task private array to find it.\n\t */\n\tif (flags & IORING_ENTER_REGISTERED_RING) {\n\t\tstruct io_uring_task *tctx = current->io_uring;\n\n\t\tif (!tctx || fd >= IO_RINGFD_REG_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = array_index_nospec(fd, IO_RINGFD_REG_MAX);\n\t\tf.file = tctx->registered_rings[fd];\n\t\tif (unlikely(!f.file))\n\t\t\treturn -EBADF;\n\t} else {\n\t\tf = fdget(fd);\n\t\tif (unlikely(!f.file))\n\t\t\treturn -EBADF;\n\t}\n\n\tret = -EOPNOTSUPP;\n\tif (unlikely(f.file->f_op != &io_uring_fops))\n\t\tgoto out_fput;\n\n\tret = -ENXIO;\n\tctx = f.file->private_data;\n\tif (unlikely(!percpu_ref_tryget(&ctx->refs)))\n\t\tgoto out_fput;\n\n\tret = -EBADFD;\n\tif (unlikely(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\tgoto out;\n\n\t/*\n\t * For SQ polling, the thread will do all submissions and completions.\n\t * Just return the requested submit count, and wake the thread if\n\t * we were asked to.\n\t */\n\tret = 0;\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tio_cqring_overflow_flush(ctx);\n\n\t\tif (unlikely(ctx->sq_data->thread == NULL)) {\n\t\t\tret = -EOWNERDEAD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (flags & IORING_ENTER_SQ_WAKEUP)\n\t\t\twake_up(&ctx->sq_data->wait);\n\t\tif (flags & IORING_ENTER_SQ_WAIT) {\n\t\t\tret = io_sqpoll_wait_sq(ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsubmitted = to_submit;\n\t} else if (to_submit) {\n\t\tret = io_uring_add_tctx_node(ctx);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tsubmitted = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\t\tif (submitted != to_submit)\n\t\t\tgoto out;\n\t}\n\tif (flags & IORING_ENTER_GETEVENTS) {\n\t\tconst sigset_t __user *sig;\n\t\tstruct __kernel_timespec __user *ts;\n\n\t\tret = io_get_ext_arg(flags, argp, &argsz, &ts, &sig);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\tmin_complete = min(min_complete, ctx->cq_entries);\n\n\t\t/*\n\t\t * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user\n\t\t * space applications don't need to do io completion events\n\t\t * polling again, they can rely on io_sq_thread to do polling\n\t\t * work, which can reduce cpu usage and uring_lock contention.\n\t\t */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&\n\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\t\tret = io_iopoll_check(ctx, min_complete);\n\t\t} else {\n\t\t\tret = io_cqring_wait(ctx, min_complete, sig, argsz, ts);\n\t\t}\n\t}\n\nout:\n\tpercpu_ref_put(&ctx->refs);\nout_fput:\n\tif (!(flags & IORING_ENTER_REGISTERED_RING))\n\t\tfdput(f);\n\treturn submitted ? submitted : ret;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic __cold int io_uring_show_cred(struct seq_file *m, unsigned int id,\n\t\tconst struct cred *cred)\n{\n\tstruct user_namespace *uns = seq_user_ns(m);\n\tstruct group_info *gi;\n\tkernel_cap_t cap;\n\tunsigned __capi;\n\tint g;\n\n\tseq_printf(m, \"%5d\\n\", id);\n\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));\n\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));\n\tseq_puts(m, \"\\n\\tGroups:\\t\");\n\tgi = cred->group_info;\n\tfor (g = 0; g < gi->ngroups; g++) {\n\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",\n\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));\n\t}\n\tseq_puts(m, \"\\n\\tCapEff:\\t\");\n\tcap = cred->cap_effective;\n\tCAP_FOR_EACH_U32(__capi)\n\t\tseq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic __cold void __io_uring_show_fdinfo(struct io_ring_ctx *ctx,\n\t\t\t\t\t  struct seq_file *m)\n{\n\tstruct io_sq_data *sq = NULL;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int sq_entries, cq_entries;\n\tbool has_lock;\n\tunsigned int i;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - ctx->cached_sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tunsigned int sq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tstruct io_uring_sqe *sqe;\n\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx];\n\t\tseq_printf(m, \"%5u: opcode:%d, fd:%d, flags:%x, user_data:%llu\\n\",\n\t\t\t   sq_idx, sqe->opcode, sqe->fd, sqe->flags,\n\t\t\t   sqe->user_data);\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[entry & cq_mask];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\\n\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tsq = ctx->sq_data;\n\t\tif (!sq->thread)\n\t\t\tsq = NULL;\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(ctx, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"PollList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tfor (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {\n\t\tstruct hlist_head *list = &ctx->cancel_hash[i];\n\t\tstruct io_kiocb *req;\n\n\t\thlist_for_each_entry(req, list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\n\tif (percpu_ref_tryget(&ctx->refs)) {\n\t\t__io_uring_show_fdinfo(ctx, m);\n\t\tpercpu_ref_put(&ctx->refs);\n\t}\n}\n#endif\n\nstatic const struct file_operations io_uring_fops = {\n\t.release\t= io_uring_release,\n\t.mmap\t\t= io_uring_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = io_uring_nommu_get_unmapped_area,\n\t.mmap_capabilities = io_uring_nommu_mmap_capabilities,\n#endif\n\t.poll\t\t= io_uring_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= io_uring_show_fdinfo,\n#endif\n};\n\nstatic __cold int io_allocate_scq_urings(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct io_uring_params *p)\n{\n\tstruct io_rings *rings;\n\tsize_t size, sq_array_offset;\n\n\t/* make sure these are sane, as we already accounted them */\n\tctx->sq_entries = p->sq_entries;\n\tctx->cq_entries = p->cq_entries;\n\n\tsize = rings_size(p->sq_entries, p->cq_entries, &sq_array_offset);\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\n\trings = io_mem_alloc(size);\n\tif (!rings)\n\t\treturn -ENOMEM;\n\n\tctx->rings = rings;\n\tctx->sq_array = (u32 *)((char *)rings + sq_array_offset);\n\trings->sq_ring_mask = p->sq_entries - 1;\n\trings->cq_ring_mask = p->cq_entries - 1;\n\trings->sq_ring_entries = p->sq_entries;\n\trings->cq_ring_entries = p->cq_entries;\n\n\tsize = array_size(sizeof(struct io_uring_sqe), p->sq_entries);\n\tif (size == SIZE_MAX) {\n\t\tio_mem_free(ctx->rings);\n\t\tctx->rings = NULL;\n\t\treturn -EOVERFLOW;\n\t}\n\n\tctx->sq_sqes = io_mem_alloc(size);\n\tif (!ctx->sq_sqes) {\n\t\tio_mem_free(ctx->rings);\n\t\tctx->rings = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_uring_install_fd(struct io_ring_ctx *ctx, struct file *file)\n{\n\tint ret, fd;\n\n\tfd = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = io_uring_add_tctx_node(ctx);\n\tif (ret) {\n\t\tput_unused_fd(fd);\n\t\treturn ret;\n\t}\n\tfd_install(fd, file);\n\treturn fd;\n}\n\n/*\n * Allocate an anonymous fd, this is what constitutes the application\n * visible backing of an io_uring instance. The application mmaps this\n * fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,\n * we have to tie this fd to a socket for file garbage collection purposes.\n */\nstatic struct file *io_uring_get_file(struct io_ring_ctx *ctx)\n{\n\tstruct file *file;\n#if defined(CONFIG_UNIX)\n\tint ret;\n\n\tret = sock_create_kern(&init_net, PF_UNIX, SOCK_RAW, IPPROTO_IP,\n\t\t\t\t&ctx->ring_sock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n#endif\n\n\tfile = anon_inode_getfile_secure(\"[io_uring]\", &io_uring_fops, ctx,\n\t\t\t\t\t O_RDWR | O_CLOEXEC, NULL);\n#if defined(CONFIG_UNIX)\n\tif (IS_ERR(file)) {\n\t\tsock_release(ctx->ring_sock);\n\t\tctx->ring_sock = NULL;\n\t} else {\n\t\tctx->ring_sock->file = file;\n\t}\n#endif\n\treturn file;\n}\n\nstatic __cold int io_uring_create(unsigned entries, struct io_uring_params *p,\n\t\t\t\t  struct io_uring_params __user *params)\n{\n\tstruct io_ring_ctx *ctx;\n\tstruct file *file;\n\tint ret;\n\n\tif (!entries)\n\t\treturn -EINVAL;\n\tif (entries > IORING_MAX_ENTRIES) {\n\t\tif (!(p->flags & IORING_SETUP_CLAMP))\n\t\t\treturn -EINVAL;\n\t\tentries = IORING_MAX_ENTRIES;\n\t}\n\n\t/*\n\t * Use twice as many entries for the CQ ring. It's possible for the\n\t * application to drive a higher depth than the size of the SQ ring,\n\t * since the sqes are only used at submission time. This allows for\n\t * some flexibility in overcommitting a bit. If the application has\n\t * set IORING_SETUP_CQSIZE, it will have passed in the desired number\n\t * of CQ ring entries manually.\n\t */\n\tp->sq_entries = roundup_pow_of_two(entries);\n\tif (p->flags & IORING_SETUP_CQSIZE) {\n\t\t/*\n\t\t * If IORING_SETUP_CQSIZE is set, we do the same roundup\n\t\t * to a power-of-two, if it isn't already. We do NOT impose\n\t\t * any cq vs sq ring sizing.\n\t\t */\n\t\tif (!p->cq_entries)\n\t\t\treturn -EINVAL;\n\t\tif (p->cq_entries > IORING_MAX_CQ_ENTRIES) {\n\t\t\tif (!(p->flags & IORING_SETUP_CLAMP))\n\t\t\t\treturn -EINVAL;\n\t\t\tp->cq_entries = IORING_MAX_CQ_ENTRIES;\n\t\t}\n\t\tp->cq_entries = roundup_pow_of_two(p->cq_entries);\n\t\tif (p->cq_entries < p->sq_entries)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tp->cq_entries = 2 * p->sq_entries;\n\t}\n\n\tctx = io_ring_ctx_alloc(p);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->compat = in_compat_syscall();\n\tif (!capable(CAP_IPC_LOCK))\n\t\tctx->user = get_uid(current_user());\n\n\t/*\n\t * This is just grabbed for accounting purposes. When a process exits,\n\t * the mm is exited and dropped before the files, hence we need to hang\n\t * on to this mm purely for the purposes of being able to unaccount\n\t * memory (locked/pinned vm). It's not used for anything else.\n\t */\n\tmmgrab(current->mm);\n\tctx->mm_account = current->mm;\n\n\tret = io_allocate_scq_urings(ctx, p);\n\tif (ret)\n\t\tgoto err;\n\n\tret = io_sq_offload_create(ctx, p);\n\tif (ret)\n\t\tgoto err;\n\t/* always set a rsrc node */\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\tgoto err;\n\tio_rsrc_node_switch(ctx, NULL);\n\n\tmemset(&p->sq_off, 0, sizeof(p->sq_off));\n\tp->sq_off.head = offsetof(struct io_rings, sq.head);\n\tp->sq_off.tail = offsetof(struct io_rings, sq.tail);\n\tp->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);\n\tp->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);\n\tp->sq_off.flags = offsetof(struct io_rings, sq_flags);\n\tp->sq_off.dropped = offsetof(struct io_rings, sq_dropped);\n\tp->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;\n\n\tmemset(&p->cq_off, 0, sizeof(p->cq_off));\n\tp->cq_off.head = offsetof(struct io_rings, cq.head);\n\tp->cq_off.tail = offsetof(struct io_rings, cq.tail);\n\tp->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);\n\tp->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);\n\tp->cq_off.overflow = offsetof(struct io_rings, cq_overflow);\n\tp->cq_off.cqes = offsetof(struct io_rings, cqes);\n\tp->cq_off.flags = offsetof(struct io_rings, cq_flags);\n\n\tp->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |\n\t\t\tIORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |\n\t\t\tIORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |\n\t\t\tIORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |\n\t\t\tIORING_FEAT_EXT_ARG | IORING_FEAT_NATIVE_WORKERS |\n\t\t\tIORING_FEAT_RSRC_TAGS | IORING_FEAT_CQE_SKIP;\n\n\tif (copy_to_user(params, p, sizeof(*p))) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tfile = io_uring_get_file(ctx);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Install ring fd as the very last thing, so we don't risk someone\n\t * having closed it before we finish setup\n\t */\n\tret = io_uring_install_fd(ctx, file);\n\tif (ret < 0) {\n\t\t/* fput will clean it up */\n\t\tfput(file);\n\t\treturn ret;\n\t}\n\n\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);\n\treturn ret;\nerr:\n\tio_ring_ctx_wait_and_kill(ctx);\n\treturn ret;\n}\n\n/*\n * Sets up an aio uring context, and returns the fd. Applications asks for a\n * ring size, we return the actual sq/cq ring sizes (among other things) in the\n * params structure passed in.\n */\nstatic long io_uring_setup(u32 entries, struct io_uring_params __user *params)\n{\n\tstruct io_uring_params p;\n\tint i;\n\n\tif (copy_from_user(&p, params, sizeof(p)))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {\n\t\tif (p.resv[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |\n\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |\n\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |\n\t\t\tIORING_SETUP_R_DISABLED | IORING_SETUP_SUBMIT_ALL))\n\t\treturn -EINVAL;\n\n\treturn  io_uring_create(entries, &p, params);\n}\n\nSYSCALL_DEFINE2(io_uring_setup, u32, entries,\n\t\tstruct io_uring_params __user *, params)\n{\n\treturn io_uring_setup(entries, params);\n}\n\nstatic __cold int io_probe(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t   unsigned nr_args)\n{\n\tstruct io_uring_probe *p;\n\tsize_t size;\n\tint i, ret;\n\n\tsize = struct_size(p, ops, nr_args);\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\tp = kzalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(p, arg, size))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (memchr_inv(p, 0, size))\n\t\tgoto out;\n\n\tp->last_op = IORING_OP_LAST - 1;\n\tif (nr_args > IORING_OP_LAST)\n\t\tnr_args = IORING_OP_LAST;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tp->ops[i].op = i;\n\t\tif (!io_op_defs[i].not_supported)\n\t\t\tp->ops[i].flags = IO_URING_OP_SUPPORTED;\n\t}\n\tp->ops_len = i;\n\n\tret = 0;\n\tif (copy_to_user(arg, p, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}\n\nstatic int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\n\tcreds = get_current_cred();\n\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tput_cred(creds);\n\t\treturn ret;\n\t}\n\treturn id;\n}\n\nstatic __cold int io_register_restrictions(struct io_ring_ctx *ctx,\n\t\t\t\t\t   void __user *arg, unsigned int nr_args)\n{\n\tstruct io_uring_restriction *res;\n\tsize_t size;\n\tint i, ret;\n\n\t/* Restrictions allowed only if rings started disabled */\n\tif (!(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\treturn -EBADFD;\n\n\t/* We allow only a single restrictions registration */\n\tif (ctx->restrictions.registered)\n\t\treturn -EBUSY;\n\n\tif (!arg || nr_args > IORING_MAX_RESTRICTIONS)\n\t\treturn -EINVAL;\n\n\tsize = array_size(nr_args, sizeof(*res));\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\n\tres = memdup_user(arg, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = 0;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tswitch (res[i].opcode) {\n\t\tcase IORING_RESTRICTION_REGISTER_OP:\n\t\t\tif (res[i].register_op >= IORING_REGISTER_LAST) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t__set_bit(res[i].register_op,\n\t\t\t\t  ctx->restrictions.register_op);\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_OP:\n\t\t\tif (res[i].sqe_op >= IORING_OP_LAST) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t__set_bit(res[i].sqe_op, ctx->restrictions.sqe_op);\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_FLAGS_ALLOWED:\n\t\t\tctx->restrictions.sqe_flags_allowed = res[i].sqe_flags;\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_FLAGS_REQUIRED:\n\t\t\tctx->restrictions.sqe_flags_required = res[i].sqe_flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/* Reset all restrictions if an error happened */\n\tif (ret != 0)\n\t\tmemset(&ctx->restrictions, 0, sizeof(ctx->restrictions));\n\telse\n\t\tctx->restrictions.registered = true;\n\n\tkfree(res);\n\treturn ret;\n}\n\nstatic int io_register_enable_rings(struct io_ring_ctx *ctx)\n{\n\tif (!(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\treturn -EBADFD;\n\n\tif (ctx->restrictions.registered)\n\t\tctx->restricted = 1;\n\n\tctx->flags &= ~IORING_SETUP_R_DISABLED;\n\tif (ctx->sq_data && wq_has_sleeper(&ctx->sq_data->wait))\n\t\twake_up(&ctx->sq_data->wait);\n\treturn 0;\n}\n\nstatic int __io_register_rsrc_update(struct io_ring_ctx *ctx, unsigned type,\n\t\t\t\t     struct io_uring_rsrc_update2 *up,\n\t\t\t\t     unsigned nr_args)\n{\n\t__u32 tmp;\n\tint err;\n\n\tif (up->resv)\n\t\treturn -EINVAL;\n\tif (check_add_overflow(up->offset, nr_args, &tmp))\n\t\treturn -EOVERFLOW;\n\terr = io_rsrc_node_switch_start(ctx);\n\tif (err)\n\t\treturn err;\n\n\tswitch (type) {\n\tcase IORING_RSRC_FILE:\n\t\treturn __io_sqe_files_update(ctx, up, nr_args);\n\tcase IORING_RSRC_BUFFER:\n\t\treturn __io_sqe_buffers_update(ctx, up, nr_args);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int io_register_files_update(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t    unsigned nr_args)\n{\n\tstruct io_uring_rsrc_update2 up;\n\n\tif (!nr_args)\n\t\treturn -EINVAL;\n\tmemset(&up, 0, sizeof(up));\n\tif (copy_from_user(&up, arg, sizeof(struct io_uring_rsrc_update)))\n\t\treturn -EFAULT;\n\treturn __io_register_rsrc_update(ctx, IORING_RSRC_FILE, &up, nr_args);\n}\n\nstatic int io_register_rsrc_update(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t   unsigned size, unsigned type)\n{\n\tstruct io_uring_rsrc_update2 up;\n\n\tif (size != sizeof(up))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&up, arg, sizeof(up)))\n\t\treturn -EFAULT;\n\tif (!up.nr || up.resv)\n\t\treturn -EINVAL;\n\treturn __io_register_rsrc_update(ctx, type, &up, up.nr);\n}\n\nstatic __cold int io_register_rsrc(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t    unsigned int size, unsigned int type)\n{\n\tstruct io_uring_rsrc_register rr;\n\n\t/* keep it extendible */\n\tif (size != sizeof(rr))\n\t\treturn -EINVAL;\n\n\tmemset(&rr, 0, sizeof(rr));\n\tif (copy_from_user(&rr, arg, size))\n\t\treturn -EFAULT;\n\tif (!rr.nr || rr.resv || rr.resv2)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase IORING_RSRC_FILE:\n\t\treturn io_sqe_files_register(ctx, u64_to_user_ptr(rr.data),\n\t\t\t\t\t     rr.nr, u64_to_user_ptr(rr.tags));\n\tcase IORING_RSRC_BUFFER:\n\t\treturn io_sqe_buffers_register(ctx, u64_to_user_ptr(rr.data),\n\t\t\t\t\t       rr.nr, u64_to_user_ptr(rr.tags));\n\t}\n\treturn -EINVAL;\n}\n\nstatic __cold int io_register_iowq_aff(struct io_ring_ctx *ctx,\n\t\t\t\t       void __user *arg, unsigned len)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tcpumask_var_t new_mask;\n\tint ret;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_clear(new_mask);\n\tif (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tif (in_compat_syscall()) {\n\t\tret = compat_get_bitmap(cpumask_bits(new_mask),\n\t\t\t\t\t(const compat_ulong_t __user *)arg,\n\t\t\t\t\tlen * 8 /* CHAR_BIT */);\n\t} else {\n\t\tret = copy_from_user(new_mask, arg, len);\n\t}\n\n\tif (ret) {\n\t\tfree_cpumask_var(new_mask);\n\t\treturn -EFAULT;\n\t}\n\n\tret = io_wq_cpu_affinity(tctx->io_wq, new_mask);\n\tfree_cpumask_var(new_mask);\n\treturn ret;\n}\n\nstatic __cold int io_unregister_iowq_aff(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -EINVAL;\n\n\treturn io_wq_cpu_affinity(tctx->io_wq, NULL);\n}\n\nstatic __cold int io_register_iowq_max_workers(struct io_ring_ctx *ctx,\n\t\t\t\t\t       void __user *arg)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_tctx_node *node;\n\tstruct io_uring_task *tctx = NULL;\n\tstruct io_sq_data *sqd = NULL;\n\t__u32 new_count[2];\n\tint i, ret;\n\n\tif (copy_from_user(new_count, arg, sizeof(new_count)))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\tif (new_count[i] > INT_MAX)\n\t\t\treturn -EINVAL;\n\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tsqd = ctx->sq_data;\n\t\tif (sqd) {\n\t\t\t/*\n\t\t\t * Observe the correct sqd->lock -> ctx->uring_lock\n\t\t\t * ordering. Fine to drop uring_lock here, we hold\n\t\t\t * a ref to the ctx.\n\t\t\t */\n\t\t\trefcount_inc(&sqd->refs);\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tmutex_lock(&sqd->lock);\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t\tif (sqd->thread)\n\t\t\t\ttctx = sqd->thread->io_uring;\n\t\t}\n\t} else {\n\t\ttctx = current->io_uring;\n\t}\n\n\tBUILD_BUG_ON(sizeof(new_count) != sizeof(ctx->iowq_limits));\n\n\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\tif (new_count[i])\n\t\t\tctx->iowq_limits[i] = new_count[i];\n\tctx->iowq_limits_set = true;\n\n\tif (tctx && tctx->io_wq) {\n\t\tret = io_wq_max_workers(tctx->io_wq, new_count);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tmemset(new_count, 0, sizeof(new_count));\n\t}\n\n\tif (sqd) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tio_put_sq_data(sqd);\n\t}\n\n\tif (copy_to_user(arg, new_count, sizeof(new_count)))\n\t\treturn -EFAULT;\n\n\t/* that's it for SQPOLL, only the SQPOLL task creates requests */\n\tif (sqd)\n\t\treturn 0;\n\n\t/* now propagate the restriction to all registered users */\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\tif (WARN_ON_ONCE(!tctx->io_wq))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\t\tnew_count[i] = ctx->iowq_limits[i];\n\t\t/* ignore errors, it always returns zero anyway */\n\t\t(void)io_wq_max_workers(tctx->io_wq, new_count);\n\t}\n\treturn 0;\nerr:\n\tif (sqd) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tio_put_sq_data(sqd);\n\t}\n\treturn ret;\n}\n\nstatic int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,\n\t\t\t       void __user *arg, unsigned nr_args)\n\t__releases(ctx->uring_lock)\n\t__acquires(ctx->uring_lock)\n{\n\tint ret;\n\n\t/*\n\t * We're inside the ring mutex, if the ref is already dying, then\n\t * someone else killed the ctx or is already going through\n\t * io_uring_register().\n\t */\n\tif (percpu_ref_is_dying(&ctx->refs))\n\t\treturn -ENXIO;\n\n\tif (ctx->restricted) {\n\t\tif (opcode >= IORING_REGISTER_LAST)\n\t\t\treturn -EINVAL;\n\t\topcode = array_index_nospec(opcode, IORING_REGISTER_LAST);\n\t\tif (!test_bit(opcode, ctx->restrictions.register_op))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (opcode) {\n\tcase IORING_REGISTER_BUFFERS:\n\t\tret = io_sqe_buffers_register(ctx, arg, nr_args, NULL);\n\t\tbreak;\n\tcase IORING_UNREGISTER_BUFFERS:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_sqe_buffers_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES:\n\t\tret = io_sqe_files_register(ctx, arg, nr_args, NULL);\n\t\tbreak;\n\tcase IORING_UNREGISTER_FILES:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_sqe_files_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES_UPDATE:\n\t\tret = io_register_files_update(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_EVENTFD:\n\t\tret = -EINVAL;\n\t\tif (nr_args != 1)\n\t\t\tbreak;\n\t\tret = io_eventfd_register(ctx, arg, 0);\n\t\tbreak;\n\tcase IORING_REGISTER_EVENTFD_ASYNC:\n\t\tret = -EINVAL;\n\t\tif (nr_args != 1)\n\t\t\tbreak;\n\t\tret = io_eventfd_register(ctx, arg, 1);\n\t\tbreak;\n\tcase IORING_UNREGISTER_EVENTFD:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_eventfd_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_PROBE:\n\t\tret = -EINVAL;\n\t\tif (!arg || nr_args > 256)\n\t\t\tbreak;\n\t\tret = io_probe(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_PERSONALITY:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_register_personality(ctx);\n\t\tbreak;\n\tcase IORING_UNREGISTER_PERSONALITY:\n\t\tret = -EINVAL;\n\t\tif (arg)\n\t\t\tbreak;\n\t\tret = io_unregister_personality(ctx, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_ENABLE_RINGS:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_register_enable_rings(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_RESTRICTIONS:\n\t\tret = io_register_restrictions(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES2:\n\t\tret = io_register_rsrc(ctx, arg, nr_args, IORING_RSRC_FILE);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES_UPDATE2:\n\t\tret = io_register_rsrc_update(ctx, arg, nr_args,\n\t\t\t\t\t      IORING_RSRC_FILE);\n\t\tbreak;\n\tcase IORING_REGISTER_BUFFERS2:\n\t\tret = io_register_rsrc(ctx, arg, nr_args, IORING_RSRC_BUFFER);\n\t\tbreak;\n\tcase IORING_REGISTER_BUFFERS_UPDATE:\n\t\tret = io_register_rsrc_update(ctx, arg, nr_args,\n\t\t\t\t\t      IORING_RSRC_BUFFER);\n\t\tbreak;\n\tcase IORING_REGISTER_IOWQ_AFF:\n\t\tret = -EINVAL;\n\t\tif (!arg || !nr_args)\n\t\t\tbreak;\n\t\tret = io_register_iowq_aff(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_UNREGISTER_IOWQ_AFF:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_unregister_iowq_aff(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_IOWQ_MAX_WORKERS:\n\t\tret = -EINVAL;\n\t\tif (!arg || nr_args != 2)\n\t\t\tbreak;\n\t\tret = io_register_iowq_max_workers(ctx, arg);\n\t\tbreak;\n\tcase IORING_REGISTER_RING_FDS:\n\t\tret = io_ringfd_register(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_UNREGISTER_RING_FDS:\n\t\tret = io_ringfd_unregister(ctx, arg, nr_args);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,\n\t\tvoid __user *, arg, unsigned int, nr_args)\n{\n\tstruct io_ring_ctx *ctx;\n\tlong ret = -EBADF;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -EOPNOTSUPP;\n\tif (f.file->f_op != &io_uring_fops)\n\t\tgoto out_fput;\n\n\tctx = f.file->private_data;\n\n\tio_run_task_work();\n\n\tmutex_lock(&ctx->uring_lock);\n\tret = __io_uring_register(ctx, opcode, arg, nr_args);\n\tmutex_unlock(&ctx->uring_lock);\n\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs, ret);\nout_fput:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int __init io_uring_init(void)\n{\n#define __BUILD_BUG_VERIFY_ELEMENT(stype, eoffset, etype, ename) do { \\\n\tBUILD_BUG_ON(offsetof(stype, ename) != eoffset); \\\n\tBUILD_BUG_ON(sizeof(etype) != sizeof_field(stype, ename)); \\\n} while (0)\n\n#define BUILD_BUG_SQE_ELEM(eoffset, etype, ename) \\\n\t__BUILD_BUG_VERIFY_ELEMENT(struct io_uring_sqe, eoffset, etype, ename)\n\tBUILD_BUG_ON(sizeof(struct io_uring_sqe) != 64);\n\tBUILD_BUG_SQE_ELEM(0,  __u8,   opcode);\n\tBUILD_BUG_SQE_ELEM(1,  __u8,   flags);\n\tBUILD_BUG_SQE_ELEM(2,  __u16,  ioprio);\n\tBUILD_BUG_SQE_ELEM(4,  __s32,  fd);\n\tBUILD_BUG_SQE_ELEM(8,  __u64,  off);\n\tBUILD_BUG_SQE_ELEM(8,  __u64,  addr2);\n\tBUILD_BUG_SQE_ELEM(16, __u64,  addr);\n\tBUILD_BUG_SQE_ELEM(16, __u64,  splice_off_in);\n\tBUILD_BUG_SQE_ELEM(24, __u32,  len);\n\tBUILD_BUG_SQE_ELEM(28,     __kernel_rwf_t, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */   int, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */ __u32, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  fsync_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */ __u16,  poll_events);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  poll32_events);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  sync_range_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  msg_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  timeout_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  accept_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  cancel_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  open_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  statx_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  fadvise_advice);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  splice_flags);\n\tBUILD_BUG_SQE_ELEM(32, __u64,  user_data);\n\tBUILD_BUG_SQE_ELEM(40, __u16,  buf_index);\n\tBUILD_BUG_SQE_ELEM(40, __u16,  buf_group);\n\tBUILD_BUG_SQE_ELEM(42, __u16,  personality);\n\tBUILD_BUG_SQE_ELEM(44, __s32,  splice_fd_in);\n\tBUILD_BUG_SQE_ELEM(44, __u32,  file_index);\n\n\tBUILD_BUG_ON(sizeof(struct io_uring_files_update) !=\n\t\t     sizeof(struct io_uring_rsrc_update));\n\tBUILD_BUG_ON(sizeof(struct io_uring_rsrc_update) >\n\t\t     sizeof(struct io_uring_rsrc_update2));\n\n\t/* ->buf_index is u16 */\n\tBUILD_BUG_ON(IORING_MAX_REG_BUFFERS >= (1u << 16));\n\n\t/* should fit into one byte */\n\tBUILD_BUG_ON(SQE_VALID_FLAGS >= (1 << 8));\n\tBUILD_BUG_ON(SQE_COMMON_FLAGS >= (1 << 8));\n\tBUILD_BUG_ON((SQE_VALID_FLAGS | SQE_COMMON_FLAGS) != SQE_VALID_FLAGS);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(io_op_defs) != IORING_OP_LAST);\n\tBUILD_BUG_ON(__REQ_F_LAST_BIT > 8 * sizeof(int));\n\n\treq_cachep = KMEM_CACHE(io_kiocb, SLAB_HWCACHE_ALIGN | SLAB_PANIC |\n\t\t\t\tSLAB_ACCOUNT);\n\treturn 0;\n};\n__initcall(io_uring_init);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Shared application/kernel submission and completion ring pairs, for\n * supporting fast/efficient IO.\n *\n * A note on the read/write ordering memory barriers that are matched between\n * the application and kernel side.\n *\n * After the application reads the CQ ring tail, it must use an\n * appropriate smp_rmb() to pair with the smp_wmb() the kernel uses\n * before writing the tail (using smp_load_acquire to read the tail will\n * do). It also needs a smp_mb() before updating CQ head (ordering the\n * entry load(s) with the head store), pairing with an implicit barrier\n * through a control-dependency in io_get_cqe (smp_store_release to\n * store head will do). Failure to do so could lead to reading invalid\n * CQ entries.\n *\n * Likewise, the application must use an appropriate smp_wmb() before\n * writing the SQ tail (ordering SQ entry stores with the tail store),\n * which pairs with smp_load_acquire in io_get_sqring (smp_store_release\n * to store the tail will do). And it needs a barrier ordering the SQ\n * head load before writing new SQ entries (smp_load_acquire to read\n * head will do).\n *\n * When using the SQ poll thread (IORING_SETUP_SQPOLL), the application\n * needs to check the SQ flags for IORING_SQ_NEED_WAKEUP *after*\n * updating the SQ tail; a full memory barrier smp_mb() is needed\n * between.\n *\n * Also see the examples in the liburing library:\n *\n *\tgit://git.kernel.dk/liburing\n *\n * io_uring also uses READ/WRITE_ONCE() for _any_ store or load that happens\n * from data shared between the kernel and application. This is done both\n * for ordering purposes, but also to ensure that once a value is loaded from\n * data that the application could potentially modify, it remains stable.\n *\n * Copyright (C) 2018-2019 Jens Axboe\n * Copyright (c) 2018-2019 Christoph Hellwig\n */\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <net/compat.h>\n#include <linux/refcount.h>\n#include <linux/uio.h>\n#include <linux/bits.h>\n\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/blk-mq.h>\n#include <linux/bvec.h>\n#include <linux/net.h>\n#include <net/sock.h>\n#include <net/af_unix.h>\n#include <net/scm.h>\n#include <linux/anon_inodes.h>\n#include <linux/sched/mm.h>\n#include <linux/uaccess.h>\n#include <linux/nospec.h>\n#include <linux/sizes.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/namei.h>\n#include <linux/fsnotify.h>\n#include <linux/fadvise.h>\n#include <linux/eventpoll.h>\n#include <linux/splice.h>\n#include <linux/task_work.h>\n#include <linux/pagemap.h>\n#include <linux/io_uring.h>\n#include <linux/audit.h>\n#include <linux/security.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"internal.h\"\n#include \"io-wq.h\"\n\n#define IORING_MAX_ENTRIES\t32768\n#define IORING_MAX_CQ_ENTRIES\t(2 * IORING_MAX_ENTRIES)\n#define IORING_SQPOLL_CAP_ENTRIES_VALUE 8\n\n/* only define max */\n#define IORING_MAX_FIXED_FILES\t(1U << 15)\n#define IORING_MAX_RESTRICTIONS\t(IORING_RESTRICTION_LAST + \\\n\t\t\t\t IORING_REGISTER_LAST + IORING_OP_LAST)\n\n#define IO_RSRC_TAG_TABLE_SHIFT\t(PAGE_SHIFT - 3)\n#define IO_RSRC_TAG_TABLE_MAX\t(1U << IO_RSRC_TAG_TABLE_SHIFT)\n#define IO_RSRC_TAG_TABLE_MASK\t(IO_RSRC_TAG_TABLE_MAX - 1)\n\n#define IORING_MAX_REG_BUFFERS\t(1U << 14)\n\n#define SQE_COMMON_FLAGS (IOSQE_FIXED_FILE | IOSQE_IO_LINK | \\\n\t\t\t  IOSQE_IO_HARDLINK | IOSQE_ASYNC)\n\n#define SQE_VALID_FLAGS\t(SQE_COMMON_FLAGS | IOSQE_BUFFER_SELECT | \\\n\t\t\tIOSQE_IO_DRAIN | IOSQE_CQE_SKIP_SUCCESS)\n\n#define IO_REQ_CLEAN_FLAGS (REQ_F_BUFFER_SELECTED | REQ_F_NEED_CLEANUP | \\\n\t\t\t\tREQ_F_POLLED | REQ_F_CREDS | REQ_F_ASYNC_DATA)\n\n#define IO_TCTX_REFS_CACHE_NR\t(1U << 10)\n\nstruct io_uring {\n\tu32 head ____cacheline_aligned_in_smp;\n\tu32 tail ____cacheline_aligned_in_smp;\n};\n\n/*\n * This data is shared with the application through the mmap at offsets\n * IORING_OFF_SQ_RING and IORING_OFF_CQ_RING.\n *\n * The offsets to the member fields are published through struct\n * io_sqring_offsets when calling io_uring_setup.\n */\nstruct io_rings {\n\t/*\n\t * Head and tail offsets into the ring; the offsets need to be\n\t * masked to get valid indices.\n\t *\n\t * The kernel controls head of the sq ring and the tail of the cq ring,\n\t * and the application controls tail of the sq ring and the head of the\n\t * cq ring.\n\t */\n\tstruct io_uring\t\tsq, cq;\n\t/*\n\t * Bitmasks to apply to head and tail offsets (constant, equals\n\t * ring_entries - 1)\n\t */\n\tu32\t\t\tsq_ring_mask, cq_ring_mask;\n\t/* Ring sizes (constant, power of 2) */\n\tu32\t\t\tsq_ring_entries, cq_ring_entries;\n\t/*\n\t * Number of invalid entries dropped by the kernel due to\n\t * invalid index stored in array\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application (i.e. get number of \"new events\" by comparing to\n\t * cached value).\n\t *\n\t * After a new SQ head value was read by the application this\n\t * counter includes all submissions that were dropped reaching\n\t * the new SQ head (and possibly more).\n\t */\n\tu32\t\t\tsq_dropped;\n\t/*\n\t * Runtime SQ flags\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application.\n\t *\n\t * The application needs a full memory barrier before checking\n\t * for IORING_SQ_NEED_WAKEUP after updating the sq tail.\n\t */\n\tu32\t\t\tsq_flags;\n\t/*\n\t * Runtime CQ flags\n\t *\n\t * Written by the application, shouldn't be modified by the\n\t * kernel.\n\t */\n\tu32\t\t\tcq_flags;\n\t/*\n\t * Number of completion events lost because the queue was full;\n\t * this should be avoided by the application by making sure\n\t * there are not more requests pending than there is space in\n\t * the completion queue.\n\t *\n\t * Written by the kernel, shouldn't be modified by the\n\t * application (i.e. get number of \"new events\" by comparing to\n\t * cached value).\n\t *\n\t * As completion events come in out of order this counter is not\n\t * ordered with any other data.\n\t */\n\tu32\t\t\tcq_overflow;\n\t/*\n\t * Ring buffer of completion events.\n\t *\n\t * The kernel writes completion events fresh every time they are\n\t * produced, so the application is allowed to modify pending\n\t * entries.\n\t */\n\tstruct io_uring_cqe\tcqes[] ____cacheline_aligned_in_smp;\n};\n\nenum io_uring_cmd_flags {\n\tIO_URING_F_COMPLETE_DEFER\t= 1,\n\tIO_URING_F_UNLOCKED\t\t= 2,\n\t/* int's last bit, sign checks are usually faster than a bit test */\n\tIO_URING_F_NONBLOCK\t\t= INT_MIN,\n};\n\nstruct io_mapped_ubuf {\n\tu64\t\tubuf;\n\tu64\t\tubuf_end;\n\tunsigned int\tnr_bvecs;\n\tunsigned long\tacct_pages;\n\tstruct bio_vec\tbvec[];\n};\n\nstruct io_ring_ctx;\n\nstruct io_overflow_cqe {\n\tstruct io_uring_cqe cqe;\n\tstruct list_head list;\n};\n\nstruct io_fixed_file {\n\t/* file * with additional FFS_* flags */\n\tunsigned long file_ptr;\n};\n\nstruct io_rsrc_put {\n\tstruct list_head list;\n\tu64 tag;\n\tunion {\n\t\tvoid *rsrc;\n\t\tstruct file *file;\n\t\tstruct io_mapped_ubuf *buf;\n\t};\n};\n\nstruct io_file_table {\n\tstruct io_fixed_file *files;\n};\n\nstruct io_rsrc_node {\n\tstruct percpu_ref\t\trefs;\n\tstruct list_head\t\tnode;\n\tstruct list_head\t\trsrc_list;\n\tstruct io_rsrc_data\t\t*rsrc_data;\n\tstruct llist_node\t\tllist;\n\tbool\t\t\t\tdone;\n};\n\ntypedef void (rsrc_put_fn)(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc);\n\nstruct io_rsrc_data {\n\tstruct io_ring_ctx\t\t*ctx;\n\n\tu64\t\t\t\t**tags;\n\tunsigned int\t\t\tnr;\n\trsrc_put_fn\t\t\t*do_put;\n\tatomic_t\t\t\trefs;\n\tstruct completion\t\tdone;\n\tbool\t\t\t\tquiesce;\n};\n\nstruct io_buffer_list {\n\tstruct list_head list;\n\tstruct list_head buf_list;\n\t__u16 bgid;\n};\n\nstruct io_buffer {\n\tstruct list_head list;\n\t__u64 addr;\n\t__u32 len;\n\t__u16 bid;\n\t__u16 bgid;\n};\n\nstruct io_restriction {\n\tDECLARE_BITMAP(register_op, IORING_REGISTER_LAST);\n\tDECLARE_BITMAP(sqe_op, IORING_OP_LAST);\n\tu8 sqe_flags_allowed;\n\tu8 sqe_flags_required;\n\tbool registered;\n};\n\nenum {\n\tIO_SQ_THREAD_SHOULD_STOP = 0,\n\tIO_SQ_THREAD_SHOULD_PARK,\n};\n\nstruct io_sq_data {\n\trefcount_t\t\trefs;\n\tatomic_t\t\tpark_pending;\n\tstruct mutex\t\tlock;\n\n\t/* ctx's that are using this sqd */\n\tstruct list_head\tctx_list;\n\n\tstruct task_struct\t*thread;\n\tstruct wait_queue_head\twait;\n\n\tunsigned\t\tsq_thread_idle;\n\tint\t\t\tsq_cpu;\n\tpid_t\t\t\ttask_pid;\n\tpid_t\t\t\ttask_tgid;\n\n\tunsigned long\t\tstate;\n\tstruct completion\texited;\n};\n\n#define IO_COMPL_BATCH\t\t\t32\n#define IO_REQ_CACHE_SIZE\t\t32\n#define IO_REQ_ALLOC_BATCH\t\t8\n\nstruct io_submit_link {\n\tstruct io_kiocb\t\t*head;\n\tstruct io_kiocb\t\t*last;\n};\n\nstruct io_submit_state {\n\t/* inline/task_work completion list, under ->uring_lock */\n\tstruct io_wq_work_node\tfree_list;\n\t/* batch completion logic */\n\tstruct io_wq_work_list\tcompl_reqs;\n\tstruct io_submit_link\tlink;\n\n\tbool\t\t\tplug_started;\n\tbool\t\t\tneed_plug;\n\tbool\t\t\tflush_cqes;\n\tunsigned short\t\tsubmit_nr;\n\tstruct blk_plug\t\tplug;\n};\n\nstruct io_ev_fd {\n\tstruct eventfd_ctx\t*cq_ev_fd;\n\tunsigned int\t\teventfd_async: 1;\n\tstruct rcu_head\t\trcu;\n};\n\n#define IO_BUFFERS_HASH_BITS\t5\n\nstruct io_ring_ctx {\n\t/* const or read-mostly hot data */\n\tstruct {\n\t\tstruct percpu_ref\trefs;\n\n\t\tstruct io_rings\t\t*rings;\n\t\tunsigned int\t\tflags;\n\t\tunsigned int\t\tcompat: 1;\n\t\tunsigned int\t\tdrain_next: 1;\n\t\tunsigned int\t\trestricted: 1;\n\t\tunsigned int\t\toff_timeout_used: 1;\n\t\tunsigned int\t\tdrain_active: 1;\n\t\tunsigned int\t\tdrain_disabled: 1;\n\t\tunsigned int\t\thas_evfd: 1;\n\t} ____cacheline_aligned_in_smp;\n\n\t/* submission data */\n\tstruct {\n\t\tstruct mutex\t\turing_lock;\n\n\t\t/*\n\t\t * Ring buffer of indices into array of io_uring_sqe, which is\n\t\t * mmapped by the application using the IORING_OFF_SQES offset.\n\t\t *\n\t\t * This indirection could e.g. be used to assign fixed\n\t\t * io_uring_sqe entries to operations and only submit them to\n\t\t * the queue when needed.\n\t\t *\n\t\t * The kernel modifies neither the indices array nor the entries\n\t\t * array.\n\t\t */\n\t\tu32\t\t\t*sq_array;\n\t\tstruct io_uring_sqe\t*sq_sqes;\n\t\tunsigned\t\tcached_sq_head;\n\t\tunsigned\t\tsq_entries;\n\t\tstruct list_head\tdefer_list;\n\n\t\t/*\n\t\t * Fixed resources fast path, should be accessed only under\n\t\t * uring_lock, and updated through io_uring_register(2)\n\t\t */\n\t\tstruct io_rsrc_node\t*rsrc_node;\n\t\tint\t\t\trsrc_cached_refs;\n\t\tstruct io_file_table\tfile_table;\n\t\tunsigned\t\tnr_user_files;\n\t\tunsigned\t\tnr_user_bufs;\n\t\tstruct io_mapped_ubuf\t**user_bufs;\n\n\t\tstruct io_submit_state\tsubmit_state;\n\t\tstruct list_head\ttimeout_list;\n\t\tstruct list_head\tltimeout_list;\n\t\tstruct list_head\tcq_overflow_list;\n\t\tstruct list_head\t*io_buffers;\n\t\tstruct list_head\tio_buffers_cache;\n\t\tstruct list_head\tapoll_cache;\n\t\tstruct xarray\t\tpersonalities;\n\t\tu32\t\t\tpers_next;\n\t\tunsigned\t\tsq_thread_idle;\n\t} ____cacheline_aligned_in_smp;\n\n\t/* IRQ completion list, under ->completion_lock */\n\tstruct io_wq_work_list\tlocked_free_list;\n\tunsigned int\t\tlocked_free_nr;\n\n\tconst struct cred\t*sq_creds;\t/* cred used for __io_sq_thread() */\n\tstruct io_sq_data\t*sq_data;\t/* if using sq thread polling */\n\n\tstruct wait_queue_head\tsqo_sq_wait;\n\tstruct list_head\tsqd_list;\n\n\tunsigned long\t\tcheck_cq_overflow;\n\n\tstruct {\n\t\tunsigned\t\tcached_cq_tail;\n\t\tunsigned\t\tcq_entries;\n\t\tstruct io_ev_fd\t__rcu\t*io_ev_fd;\n\t\tstruct wait_queue_head\tcq_wait;\n\t\tunsigned\t\tcq_extra;\n\t\tatomic_t\t\tcq_timeouts;\n\t\tunsigned\t\tcq_last_tm_flush;\n\t} ____cacheline_aligned_in_smp;\n\n\tstruct {\n\t\tspinlock_t\t\tcompletion_lock;\n\n\t\tspinlock_t\t\ttimeout_lock;\n\n\t\t/*\n\t\t * ->iopoll_list is protected by the ctx->uring_lock for\n\t\t * io_uring instances that don't use IORING_SETUP_SQPOLL.\n\t\t * For SQPOLL, only the single threaded io_sq_thread() will\n\t\t * manipulate the list, hence no extra locking is needed there.\n\t\t */\n\t\tstruct io_wq_work_list\tiopoll_list;\n\t\tstruct hlist_head\t*cancel_hash;\n\t\tunsigned\t\tcancel_hash_bits;\n\t\tbool\t\t\tpoll_multi_queue;\n\n\t\tstruct list_head\tio_buffers_comp;\n\t} ____cacheline_aligned_in_smp;\n\n\tstruct io_restriction\t\trestrictions;\n\n\t/* slow path rsrc auxilary data, used by update/register */\n\tstruct {\n\t\tstruct io_rsrc_node\t\t*rsrc_backup_node;\n\t\tstruct io_mapped_ubuf\t\t*dummy_ubuf;\n\t\tstruct io_rsrc_data\t\t*file_data;\n\t\tstruct io_rsrc_data\t\t*buf_data;\n\n\t\tstruct delayed_work\t\trsrc_put_work;\n\t\tstruct llist_head\t\trsrc_put_llist;\n\t\tstruct list_head\t\trsrc_ref_list;\n\t\tspinlock_t\t\t\trsrc_ref_lock;\n\n\t\tstruct list_head\tio_buffers_pages;\n\t};\n\n\t/* Keep this last, we don't need it for the fast path */\n\tstruct {\n\t\t#if defined(CONFIG_UNIX)\n\t\t\tstruct socket\t\t*ring_sock;\n\t\t#endif\n\t\t/* hashed buffered write serialization */\n\t\tstruct io_wq_hash\t\t*hash_map;\n\n\t\t/* Only used for accounting purposes */\n\t\tstruct user_struct\t\t*user;\n\t\tstruct mm_struct\t\t*mm_account;\n\n\t\t/* ctx exit and cancelation */\n\t\tstruct llist_head\t\tfallback_llist;\n\t\tstruct delayed_work\t\tfallback_work;\n\t\tstruct work_struct\t\texit_work;\n\t\tstruct list_head\t\ttctx_list;\n\t\tstruct completion\t\tref_comp;\n\t\tu32\t\t\t\tiowq_limits[2];\n\t\tbool\t\t\t\tiowq_limits_set;\n\t};\n};\n\n/*\n * Arbitrary limit, can be raised if need be\n */\n#define IO_RINGFD_REG_MAX 16\n\nstruct io_uring_task {\n\t/* submission side */\n\tint\t\t\tcached_refs;\n\tstruct xarray\t\txa;\n\tstruct wait_queue_head\twait;\n\tconst struct io_ring_ctx *last;\n\tstruct io_wq\t\t*io_wq;\n\tstruct percpu_counter\tinflight;\n\tatomic_t\t\tin_idle;\n\n\tspinlock_t\t\ttask_lock;\n\tstruct io_wq_work_list\ttask_list;\n\tstruct io_wq_work_list\tprior_task_list;\n\tstruct callback_head\ttask_work;\n\tstruct file\t\t**registered_rings;\n\tbool\t\t\ttask_running;\n};\n\n/*\n * First field must be the file pointer in all the\n * iocb unions! See also 'struct kiocb' in <linux/fs.h>\n */\nstruct io_poll_iocb {\n\tstruct file\t\t\t*file;\n\tstruct wait_queue_head\t\t*head;\n\t__poll_t\t\t\tevents;\n\tstruct wait_queue_entry\t\twait;\n};\n\nstruct io_poll_update {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\told_user_data;\n\tu64\t\t\t\tnew_user_data;\n\t__poll_t\t\t\tevents;\n\tbool\t\t\t\tupdate_events;\n\tbool\t\t\t\tupdate_user_data;\n};\n\nstruct io_close {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tfd;\n\tu32\t\t\t\tfile_slot;\n};\n\nstruct io_timeout_data {\n\tstruct io_kiocb\t\t\t*req;\n\tstruct hrtimer\t\t\ttimer;\n\tstruct timespec64\t\tts;\n\tenum hrtimer_mode\t\tmode;\n\tu32\t\t\t\tflags;\n};\n\nstruct io_accept {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint __user\t\t\t*addr_len;\n\tint\t\t\t\tflags;\n\tu32\t\t\t\tfile_slot;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_sync {\n\tstruct file\t\t\t*file;\n\tloff_t\t\t\t\tlen;\n\tloff_t\t\t\t\toff;\n\tint\t\t\t\tflags;\n\tint\t\t\t\tmode;\n};\n\nstruct io_cancel {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n};\n\nstruct io_timeout {\n\tstruct file\t\t\t*file;\n\tu32\t\t\t\toff;\n\tu32\t\t\t\ttarget_seq;\n\tstruct list_head\t\tlist;\n\t/* head of the link, used by linked timeouts only */\n\tstruct io_kiocb\t\t\t*head;\n\t/* for linked completions */\n\tstruct io_kiocb\t\t\t*prev;\n};\n\nstruct io_timeout_rem {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n\n\t/* timeout update */\n\tstruct timespec64\t\tts;\n\tu32\t\t\t\tflags;\n\tbool\t\t\t\tltimeout;\n};\n\nstruct io_rw {\n\t/* NOTE: kiocb has the file as the first member, so don't do it here */\n\tstruct kiocb\t\t\tkiocb;\n\tu64\t\t\t\taddr;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tflags;\n};\n\nstruct io_connect {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint\t\t\t\taddr_len;\n};\n\nstruct io_sr_msg {\n\tstruct file\t\t\t*file;\n\tunion {\n\t\tstruct compat_msghdr __user\t*umsg_compat;\n\t\tstruct user_msghdr __user\t*umsg;\n\t\tvoid __user\t\t\t*buf;\n\t};\n\tint\t\t\t\tmsg_flags;\n\tint\t\t\t\tbgid;\n\tsize_t\t\t\t\tlen;\n\tsize_t\t\t\t\tdone_io;\n};\n\nstruct io_open {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tu32\t\t\t\tfile_slot;\n\tstruct filename\t\t\t*filename;\n\tstruct open_how\t\t\thow;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_rsrc_update {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\targ;\n\tu32\t\t\t\tnr_args;\n\tu32\t\t\t\toffset;\n};\n\nstruct io_fadvise {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\toffset;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tadvice;\n};\n\nstruct io_madvise {\n\tstruct file\t\t\t*file;\n\tu64\t\t\t\taddr;\n\tu32\t\t\t\tlen;\n\tu32\t\t\t\tadvice;\n};\n\nstruct io_epoll {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tepfd;\n\tint\t\t\t\top;\n\tint\t\t\t\tfd;\n\tstruct epoll_event\t\tevent;\n};\n\nstruct io_splice {\n\tstruct file\t\t\t*file_out;\n\tloff_t\t\t\t\toff_out;\n\tloff_t\t\t\t\toff_in;\n\tu64\t\t\t\tlen;\n\tint\t\t\t\tsplice_fd_in;\n\tunsigned int\t\t\tflags;\n};\n\nstruct io_provide_buf {\n\tstruct file\t\t\t*file;\n\t__u64\t\t\t\taddr;\n\t__u32\t\t\t\tlen;\n\t__u32\t\t\t\tbgid;\n\t__u16\t\t\t\tnbufs;\n\t__u16\t\t\t\tbid;\n};\n\nstruct io_statx {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tunsigned int\t\t\tmask;\n\tunsigned int\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n\tstruct statx __user\t\t*buffer;\n};\n\nstruct io_shutdown {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\thow;\n};\n\nstruct io_rename {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nstruct io_unlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tint\t\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_mkdir {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tumode_t\t\t\t\tmode;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_symlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n};\n\nstruct io_hardlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tu64 user_data;\n\tu32 len;\n};\n\nstruct io_async_connect {\n\tstruct sockaddr_storage\t\taddress;\n};\n\nstruct io_async_msghdr {\n\tstruct iovec\t\t\tfast_iov[UIO_FASTIOV];\n\t/* points to an allocated iov, if NULL we use fast_iov instead */\n\tstruct iovec\t\t\t*free_iov;\n\tstruct sockaddr __user\t\t*uaddr;\n\tstruct msghdr\t\t\tmsg;\n\tstruct sockaddr_storage\t\taddr;\n};\n\nstruct io_rw_state {\n\tstruct iov_iter\t\t\titer;\n\tstruct iov_iter_state\t\titer_state;\n\tstruct iovec\t\t\tfast_iov[UIO_FASTIOV];\n};\n\nstruct io_async_rw {\n\tstruct io_rw_state\t\ts;\n\tconst struct iovec\t\t*free_iovec;\n\tsize_t\t\t\t\tbytes_done;\n\tstruct wait_page_queue\t\twpq;\n};\n\nenum {\n\tREQ_F_FIXED_FILE_BIT\t= IOSQE_FIXED_FILE_BIT,\n\tREQ_F_IO_DRAIN_BIT\t= IOSQE_IO_DRAIN_BIT,\n\tREQ_F_LINK_BIT\t\t= IOSQE_IO_LINK_BIT,\n\tREQ_F_HARDLINK_BIT\t= IOSQE_IO_HARDLINK_BIT,\n\tREQ_F_FORCE_ASYNC_BIT\t= IOSQE_ASYNC_BIT,\n\tREQ_F_BUFFER_SELECT_BIT\t= IOSQE_BUFFER_SELECT_BIT,\n\tREQ_F_CQE_SKIP_BIT\t= IOSQE_CQE_SKIP_SUCCESS_BIT,\n\n\t/* first byte is taken by user flags, shift it to not overlap */\n\tREQ_F_FAIL_BIT\t\t= 8,\n\tREQ_F_INFLIGHT_BIT,\n\tREQ_F_CUR_POS_BIT,\n\tREQ_F_NOWAIT_BIT,\n\tREQ_F_LINK_TIMEOUT_BIT,\n\tREQ_F_NEED_CLEANUP_BIT,\n\tREQ_F_POLLED_BIT,\n\tREQ_F_BUFFER_SELECTED_BIT,\n\tREQ_F_COMPLETE_INLINE_BIT,\n\tREQ_F_REISSUE_BIT,\n\tREQ_F_CREDS_BIT,\n\tREQ_F_REFCOUNT_BIT,\n\tREQ_F_ARM_LTIMEOUT_BIT,\n\tREQ_F_ASYNC_DATA_BIT,\n\tREQ_F_SKIP_LINK_CQES_BIT,\n\tREQ_F_SINGLE_POLL_BIT,\n\tREQ_F_DOUBLE_POLL_BIT,\n\tREQ_F_PARTIAL_IO_BIT,\n\t/* keep async read/write and isreg together and in order */\n\tREQ_F_SUPPORT_NOWAIT_BIT,\n\tREQ_F_ISREG_BIT,\n\n\t/* not a real bit, just to check we're not overflowing the space */\n\t__REQ_F_LAST_BIT,\n};\n\nenum {\n\t/* ctx owns file */\n\tREQ_F_FIXED_FILE\t= BIT(REQ_F_FIXED_FILE_BIT),\n\t/* drain existing IO first */\n\tREQ_F_IO_DRAIN\t\t= BIT(REQ_F_IO_DRAIN_BIT),\n\t/* linked sqes */\n\tREQ_F_LINK\t\t= BIT(REQ_F_LINK_BIT),\n\t/* doesn't sever on completion < 0 */\n\tREQ_F_HARDLINK\t\t= BIT(REQ_F_HARDLINK_BIT),\n\t/* IOSQE_ASYNC */\n\tREQ_F_FORCE_ASYNC\t= BIT(REQ_F_FORCE_ASYNC_BIT),\n\t/* IOSQE_BUFFER_SELECT */\n\tREQ_F_BUFFER_SELECT\t= BIT(REQ_F_BUFFER_SELECT_BIT),\n\t/* IOSQE_CQE_SKIP_SUCCESS */\n\tREQ_F_CQE_SKIP\t\t= BIT(REQ_F_CQE_SKIP_BIT),\n\n\t/* fail rest of links */\n\tREQ_F_FAIL\t\t= BIT(REQ_F_FAIL_BIT),\n\t/* on inflight list, should be cancelled and waited on exit reliably */\n\tREQ_F_INFLIGHT\t\t= BIT(REQ_F_INFLIGHT_BIT),\n\t/* read/write uses file position */\n\tREQ_F_CUR_POS\t\t= BIT(REQ_F_CUR_POS_BIT),\n\t/* must not punt to workers */\n\tREQ_F_NOWAIT\t\t= BIT(REQ_F_NOWAIT_BIT),\n\t/* has or had linked timeout */\n\tREQ_F_LINK_TIMEOUT\t= BIT(REQ_F_LINK_TIMEOUT_BIT),\n\t/* needs cleanup */\n\tREQ_F_NEED_CLEANUP\t= BIT(REQ_F_NEED_CLEANUP_BIT),\n\t/* already went through poll handler */\n\tREQ_F_POLLED\t\t= BIT(REQ_F_POLLED_BIT),\n\t/* buffer already selected */\n\tREQ_F_BUFFER_SELECTED\t= BIT(REQ_F_BUFFER_SELECTED_BIT),\n\t/* completion is deferred through io_comp_state */\n\tREQ_F_COMPLETE_INLINE\t= BIT(REQ_F_COMPLETE_INLINE_BIT),\n\t/* caller should reissue async */\n\tREQ_F_REISSUE\t\t= BIT(REQ_F_REISSUE_BIT),\n\t/* supports async reads/writes */\n\tREQ_F_SUPPORT_NOWAIT\t= BIT(REQ_F_SUPPORT_NOWAIT_BIT),\n\t/* regular file */\n\tREQ_F_ISREG\t\t= BIT(REQ_F_ISREG_BIT),\n\t/* has creds assigned */\n\tREQ_F_CREDS\t\t= BIT(REQ_F_CREDS_BIT),\n\t/* skip refcounting if not set */\n\tREQ_F_REFCOUNT\t\t= BIT(REQ_F_REFCOUNT_BIT),\n\t/* there is a linked timeout that has to be armed */\n\tREQ_F_ARM_LTIMEOUT\t= BIT(REQ_F_ARM_LTIMEOUT_BIT),\n\t/* ->async_data allocated */\n\tREQ_F_ASYNC_DATA\t= BIT(REQ_F_ASYNC_DATA_BIT),\n\t/* don't post CQEs while failing linked requests */\n\tREQ_F_SKIP_LINK_CQES\t= BIT(REQ_F_SKIP_LINK_CQES_BIT),\n\t/* single poll may be active */\n\tREQ_F_SINGLE_POLL\t= BIT(REQ_F_SINGLE_POLL_BIT),\n\t/* double poll may active */\n\tREQ_F_DOUBLE_POLL\t= BIT(REQ_F_DOUBLE_POLL_BIT),\n\t/* request has already done partial IO */\n\tREQ_F_PARTIAL_IO\t= BIT(REQ_F_PARTIAL_IO_BIT),\n};\n\nstruct async_poll {\n\tstruct io_poll_iocb\tpoll;\n\tstruct io_poll_iocb\t*double_poll;\n};\n\ntypedef void (*io_req_tw_func_t)(struct io_kiocb *req, bool *locked);\n\nstruct io_task_work {\n\tunion {\n\t\tstruct io_wq_work_node\tnode;\n\t\tstruct llist_node\tfallback_node;\n\t};\n\tio_req_tw_func_t\t\tfunc;\n};\n\nenum {\n\tIORING_RSRC_FILE\t\t= 0,\n\tIORING_RSRC_BUFFER\t\t= 1,\n};\n\n/*\n * NOTE! Each of the iocb union members has the file pointer\n * as the first entry in their struct definition. So you can\n * access the file pointer through any of the sub-structs,\n * or directly as just 'file' in this struct.\n */\nstruct io_kiocb {\n\tunion {\n\t\tstruct file\t\t*file;\n\t\tstruct io_rw\t\trw;\n\t\tstruct io_poll_iocb\tpoll;\n\t\tstruct io_poll_update\tpoll_update;\n\t\tstruct io_accept\taccept;\n\t\tstruct io_sync\t\tsync;\n\t\tstruct io_cancel\tcancel;\n\t\tstruct io_timeout\ttimeout;\n\t\tstruct io_timeout_rem\ttimeout_rem;\n\t\tstruct io_connect\tconnect;\n\t\tstruct io_sr_msg\tsr_msg;\n\t\tstruct io_open\t\topen;\n\t\tstruct io_close\t\tclose;\n\t\tstruct io_rsrc_update\trsrc_update;\n\t\tstruct io_fadvise\tfadvise;\n\t\tstruct io_madvise\tmadvise;\n\t\tstruct io_epoll\t\tepoll;\n\t\tstruct io_splice\tsplice;\n\t\tstruct io_provide_buf\tpbuf;\n\t\tstruct io_statx\t\tstatx;\n\t\tstruct io_shutdown\tshutdown;\n\t\tstruct io_rename\trename;\n\t\tstruct io_unlink\tunlink;\n\t\tstruct io_mkdir\t\tmkdir;\n\t\tstruct io_symlink\tsymlink;\n\t\tstruct io_hardlink\thardlink;\n\t\tstruct io_msg\t\tmsg;\n\t};\n\n\tu8\t\t\t\topcode;\n\t/* polled IO has completed */\n\tu8\t\t\t\tiopoll_completed;\n\tu16\t\t\t\tbuf_index;\n\tunsigned int\t\t\tflags;\n\n\tu64\t\t\t\tuser_data;\n\tu32\t\t\t\tresult;\n\tu32\t\t\t\tcflags;\n\n\tstruct io_ring_ctx\t\t*ctx;\n\tstruct task_struct\t\t*task;\n\n\tstruct percpu_ref\t\t*fixed_rsrc_refs;\n\t/* store used ubuf, so we can prevent reloading */\n\tstruct io_mapped_ubuf\t\t*imu;\n\n\t/* used by request caches, completion batching and iopoll */\n\tstruct io_wq_work_node\t\tcomp_list;\n\tatomic_t\t\t\trefs;\n\tatomic_t\t\t\tpoll_refs;\n\tstruct io_task_work\t\tio_task_work;\n\t/* for polled requests, i.e. IORING_OP_POLL_ADD and async armed poll */\n\tstruct hlist_node\t\thash_node;\n\t/* internal polling, see IORING_FEAT_FAST_POLL */\n\tstruct async_poll\t\t*apoll;\n\t/* opcode allocated if it needs to store data for async defer */\n\tvoid\t\t\t\t*async_data;\n\t/* stores selected buf, valid IFF REQ_F_BUFFER_SELECTED is set */\n\tstruct io_buffer\t\t*kbuf;\n\t/* linked requests, IFF REQ_F_HARDLINK or REQ_F_LINK are set */\n\tstruct io_kiocb\t\t\t*link;\n\t/* custom credentials, valid IFF REQ_F_CREDS is set */\n\tconst struct cred\t\t*creds;\n\tstruct io_wq_work\t\twork;\n};\n\nstruct io_tctx_node {\n\tstruct list_head\tctx_node;\n\tstruct task_struct\t*task;\n\tstruct io_ring_ctx\t*ctx;\n};\n\nstruct io_defer_entry {\n\tstruct list_head\tlist;\n\tstruct io_kiocb\t\t*req;\n\tu32\t\t\tseq;\n};\n\nstruct io_op_def {\n\t/* needs req->file assigned */\n\tunsigned\t\tneeds_file : 1;\n\t/* should block plug */\n\tunsigned\t\tplug : 1;\n\t/* hash wq insertion if file is a regular file */\n\tunsigned\t\thash_reg_file : 1;\n\t/* unbound wq insertion if file is a non-regular file */\n\tunsigned\t\tunbound_nonreg_file : 1;\n\t/* set if opcode supports polled \"wait\" */\n\tunsigned\t\tpollin : 1;\n\tunsigned\t\tpollout : 1;\n\tunsigned\t\tpoll_exclusive : 1;\n\t/* op supports buffer selection */\n\tunsigned\t\tbuffer_select : 1;\n\t/* do prep async if is going to be punted */\n\tunsigned\t\tneeds_async_setup : 1;\n\t/* opcode is not supported by this kernel */\n\tunsigned\t\tnot_supported : 1;\n\t/* skip auditing */\n\tunsigned\t\taudit_skip : 1;\n\t/* size of async data needed, if any */\n\tunsigned short\t\tasync_size;\n};\n\nstatic const struct io_op_def io_op_defs[] = {\n\t[IORING_OP_NOP] = {},\n\t[IORING_OP_READV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITEV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_FSYNC] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_READ_FIXED] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITE_FIXED] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_POLL_ADD] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_POLL_REMOVE] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SYNC_FILE_RANGE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SENDMSG] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_msghdr),\n\t},\n\t[IORING_OP_RECVMSG] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_msghdr),\n\t},\n\t[IORING_OP_TIMEOUT] = {\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_timeout_data),\n\t},\n\t[IORING_OP_TIMEOUT_REMOVE] = {\n\t\t/* used by timeout updates' prep() */\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_ACCEPT] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.poll_exclusive\t\t= 1,\n\t},\n\t[IORING_OP_ASYNC_CANCEL] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_LINK_TIMEOUT] = {\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_timeout_data),\n\t},\n\t[IORING_OP_CONNECT] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.needs_async_setup\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_connect),\n\t},\n\t[IORING_OP_FALLOCATE] = {\n\t\t.needs_file\t\t= 1,\n\t},\n\t[IORING_OP_OPENAT] = {},\n\t[IORING_OP_CLOSE] = {},\n\t[IORING_OP_FILES_UPDATE] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_STATX] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_READ] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_WRITE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.plug\t\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t\t.async_size\t\t= sizeof(struct io_async_rw),\n\t},\n\t[IORING_OP_FADVISE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_MADVISE] = {},\n\t[IORING_OP_SEND] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollout\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_RECV] = {\n\t\t.needs_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.pollin\t\t\t= 1,\n\t\t.buffer_select\t\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_OPENAT2] = {\n\t},\n\t[IORING_OP_EPOLL_CTL] = {\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SPLICE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_PROVIDE_BUFFERS] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_REMOVE_BUFFERS] = {\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_TEE] = {\n\t\t.needs_file\t\t= 1,\n\t\t.hash_reg_file\t\t= 1,\n\t\t.unbound_nonreg_file\t= 1,\n\t\t.audit_skip\t\t= 1,\n\t},\n\t[IORING_OP_SHUTDOWN] = {\n\t\t.needs_file\t\t= 1,\n\t},\n\t[IORING_OP_RENAMEAT] = {},\n\t[IORING_OP_UNLINKAT] = {},\n\t[IORING_OP_MKDIRAT] = {},\n\t[IORING_OP_SYMLINKAT] = {},\n\t[IORING_OP_LINKAT] = {},\n\t[IORING_OP_MSG_RING] = {\n\t\t.needs_file\t\t= 1,\n\t},\n};\n\n/* requests with any of those set should undergo io_disarm_next() */\n#define IO_DISARM_MASK (REQ_F_ARM_LTIMEOUT | REQ_F_LINK_TIMEOUT | REQ_F_FAIL)\n\nstatic bool io_disarm_next(struct io_kiocb *req);\nstatic void io_uring_del_tctx_node(unsigned long index);\nstatic void io_uring_try_cancel_requests(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct task_struct *task,\n\t\t\t\t\t bool cancel_all);\nstatic void io_uring_cancel_generic(bool cancel_all, struct io_sq_data *sqd);\n\nstatic void io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags);\n\nstatic void io_put_req(struct io_kiocb *req);\nstatic void io_put_req_deferred(struct io_kiocb *req);\nstatic void io_dismantle_req(struct io_kiocb *req);\nstatic void io_queue_linked_timeout(struct io_kiocb *req);\nstatic int __io_register_rsrc_update(struct io_ring_ctx *ctx, unsigned type,\n\t\t\t\t     struct io_uring_rsrc_update2 *up,\n\t\t\t\t     unsigned nr_args);\nstatic void io_clean_op(struct io_kiocb *req);\nstatic inline struct file *io_file_get_fixed(struct io_kiocb *req, int fd,\n\t\t\t\t\t     unsigned issue_flags);\nstatic inline struct file *io_file_get_normal(struct io_kiocb *req, int fd);\nstatic void io_drop_inflight_file(struct io_kiocb *req);\nstatic bool io_assign_file(struct io_kiocb *req, unsigned int issue_flags);\nstatic void __io_queue_sqe(struct io_kiocb *req);\nstatic void io_rsrc_put_work(struct work_struct *work);\n\nstatic void io_req_task_queue(struct io_kiocb *req);\nstatic void __io_submit_flush_completions(struct io_ring_ctx *ctx);\nstatic int io_req_prep_async(struct io_kiocb *req);\n\nstatic int io_install_fixed_file(struct io_kiocb *req, struct file *file,\n\t\t\t\t unsigned int issue_flags, u32 slot_index);\nstatic int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags);\n\nstatic enum hrtimer_restart io_link_timeout_fn(struct hrtimer *timer);\nstatic void io_eventfd_signal(struct io_ring_ctx *ctx);\n\nstatic struct kmem_cache *req_cachep;\n\nstatic const struct file_operations io_uring_fops;\n\nstruct sock *io_uring_get_socket(struct file *file)\n{\n#if defined(CONFIG_UNIX)\n\tif (file->f_op == &io_uring_fops) {\n\t\tstruct io_ring_ctx *ctx = file->private_data;\n\n\t\treturn ctx->ring_sock->sk;\n\t}\n#endif\n\treturn NULL;\n}\nEXPORT_SYMBOL(io_uring_get_socket);\n\nstatic inline void io_tw_lock(struct io_ring_ctx *ctx, bool *locked)\n{\n\tif (!*locked) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\t*locked = true;\n\t}\n}\n\n#define io_for_each_link(pos, head) \\\n\tfor (pos = (head); pos; pos = pos->link)\n\n/*\n * Shamelessly stolen from the mm implementation of page reference checking,\n * see commit f958d7b528b1 for details.\n */\n#define req_ref_zero_or_close_to_overflow(req)\t\\\n\t((unsigned int) atomic_read(&(req->refs)) + 127u <= 127u)\n\nstatic inline bool req_ref_inc_not_zero(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!(req->flags & REQ_F_REFCOUNT));\n\treturn atomic_inc_not_zero(&req->refs);\n}\n\nstatic inline bool req_ref_put_and_test(struct io_kiocb *req)\n{\n\tif (likely(!(req->flags & REQ_F_REFCOUNT)))\n\t\treturn true;\n\n\tWARN_ON_ONCE(req_ref_zero_or_close_to_overflow(req));\n\treturn atomic_dec_and_test(&req->refs);\n}\n\nstatic inline void req_ref_get(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!(req->flags & REQ_F_REFCOUNT));\n\tWARN_ON_ONCE(req_ref_zero_or_close_to_overflow(req));\n\tatomic_inc(&req->refs);\n}\n\nstatic inline void io_submit_flush_completions(struct io_ring_ctx *ctx)\n{\n\tif (!wq_list_empty(&ctx->submit_state.compl_reqs))\n\t\t__io_submit_flush_completions(ctx);\n}\n\nstatic inline void __io_req_set_refcount(struct io_kiocb *req, int nr)\n{\n\tif (!(req->flags & REQ_F_REFCOUNT)) {\n\t\treq->flags |= REQ_F_REFCOUNT;\n\t\tatomic_set(&req->refs, nr);\n\t}\n}\n\nstatic inline void io_req_set_refcount(struct io_kiocb *req)\n{\n\t__io_req_set_refcount(req, 1);\n}\n\n#define IO_RSRC_REF_BATCH\t100\n\nstatic inline void io_req_put_rsrc_locked(struct io_kiocb *req,\n\t\t\t\t\t  struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct percpu_ref *ref = req->fixed_rsrc_refs;\n\n\tif (ref) {\n\t\tif (ref == &ctx->rsrc_node->refs)\n\t\t\tctx->rsrc_cached_refs++;\n\t\telse\n\t\t\tpercpu_ref_put(ref);\n\t}\n}\n\nstatic inline void io_req_put_rsrc(struct io_kiocb *req, struct io_ring_ctx *ctx)\n{\n\tif (req->fixed_rsrc_refs)\n\t\tpercpu_ref_put(req->fixed_rsrc_refs);\n}\n\nstatic __cold void io_rsrc_refs_drop(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tif (ctx->rsrc_cached_refs) {\n\t\tpercpu_ref_put_many(&ctx->rsrc_node->refs, ctx->rsrc_cached_refs);\n\t\tctx->rsrc_cached_refs = 0;\n\t}\n}\n\nstatic void io_rsrc_refs_refill(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tctx->rsrc_cached_refs += IO_RSRC_REF_BATCH;\n\tpercpu_ref_get_many(&ctx->rsrc_node->refs, IO_RSRC_REF_BATCH);\n}\n\nstatic inline void io_req_set_rsrc_node(struct io_kiocb *req,\n\t\t\t\t\tstruct io_ring_ctx *ctx,\n\t\t\t\t\tunsigned int issue_flags)\n{\n\tif (!req->fixed_rsrc_refs) {\n\t\treq->fixed_rsrc_refs = &ctx->rsrc_node->refs;\n\n\t\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\t\tlockdep_assert_held(&ctx->uring_lock);\n\t\t\tctx->rsrc_cached_refs--;\n\t\t\tif (unlikely(ctx->rsrc_cached_refs < 0))\n\t\t\t\tio_rsrc_refs_refill(ctx);\n\t\t} else {\n\t\t\tpercpu_ref_get(req->fixed_rsrc_refs);\n\t\t}\n\t}\n}\n\nstatic unsigned int __io_put_kbuf(struct io_kiocb *req, struct list_head *list)\n{\n\tstruct io_buffer *kbuf = req->kbuf;\n\tunsigned int cflags;\n\n\tcflags = IORING_CQE_F_BUFFER | (kbuf->bid << IORING_CQE_BUFFER_SHIFT);\n\treq->flags &= ~REQ_F_BUFFER_SELECTED;\n\tlist_add(&kbuf->list, list);\n\treq->kbuf = NULL;\n\treturn cflags;\n}\n\nstatic inline unsigned int io_put_kbuf_comp(struct io_kiocb *req)\n{\n\tlockdep_assert_held(&req->ctx->completion_lock);\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn 0;\n\treturn __io_put_kbuf(req, &req->ctx->io_buffers_comp);\n}\n\nstatic inline unsigned int io_put_kbuf(struct io_kiocb *req,\n\t\t\t\t       unsigned issue_flags)\n{\n\tunsigned int cflags;\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn 0;\n\n\t/*\n\t * We can add this buffer back to two lists:\n\t *\n\t * 1) The io_buffers_cache list. This one is protected by the\n\t *    ctx->uring_lock. If we already hold this lock, add back to this\n\t *    list as we can grab it from issue as well.\n\t * 2) The io_buffers_comp list. This one is protected by the\n\t *    ctx->completion_lock.\n\t *\n\t * We migrate buffers from the comp_list to the issue cache list\n\t * when we need one.\n\t */\n\tif (issue_flags & IO_URING_F_UNLOCKED) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock(&ctx->completion_lock);\n\t\tcflags = __io_put_kbuf(req, &ctx->io_buffers_comp);\n\t\tspin_unlock(&ctx->completion_lock);\n\t} else {\n\t\tlockdep_assert_held(&req->ctx->uring_lock);\n\n\t\tcflags = __io_put_kbuf(req, &req->ctx->io_buffers_cache);\n\t}\n\n\treturn cflags;\n}\n\nstatic struct io_buffer_list *io_buffer_get_list(struct io_ring_ctx *ctx,\n\t\t\t\t\t\t unsigned int bgid)\n{\n\tstruct list_head *hash_list;\n\tstruct io_buffer_list *bl;\n\n\thash_list = &ctx->io_buffers[hash_32(bgid, IO_BUFFERS_HASH_BITS)];\n\tlist_for_each_entry(bl, hash_list, list)\n\t\tif (bl->bgid == bgid || bgid == -1U)\n\t\t\treturn bl;\n\n\treturn NULL;\n}\n\nstatic void io_kbuf_recycle(struct io_kiocb *req, unsigned issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tstruct io_buffer *buf;\n\n\tif (likely(!(req->flags & REQ_F_BUFFER_SELECTED)))\n\t\treturn;\n\t/* don't recycle if we already did IO to this buffer */\n\tif (req->flags & REQ_F_PARTIAL_IO)\n\t\treturn;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_lock(&ctx->uring_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbuf = req->kbuf;\n\tbl = io_buffer_get_list(ctx, buf->bgid);\n\tlist_add(&buf->list, &bl->buf_list);\n\treq->flags &= ~REQ_F_BUFFER_SELECTED;\n\treq->kbuf = NULL;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic bool io_match_task(struct io_kiocb *head, struct task_struct *task,\n\t\t\t  bool cancel_all)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tif (task && head->task != task)\n\t\treturn false;\n\treturn cancel_all;\n}\n\n/*\n * As io_match_task() but protected against racing with linked timeouts.\n * User must not hold timeout_lock.\n */\nstatic bool io_match_task_safe(struct io_kiocb *head, struct task_struct *task,\n\t\t\t       bool cancel_all)\n{\n\tif (task && head->task != task)\n\t\treturn false;\n\treturn cancel_all;\n}\n\nstatic inline bool req_has_async_data(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_ASYNC_DATA;\n}\n\nstatic inline void req_set_fail(struct io_kiocb *req)\n{\n\treq->flags |= REQ_F_FAIL;\n\tif (req->flags & REQ_F_CQE_SKIP) {\n\t\treq->flags &= ~REQ_F_CQE_SKIP;\n\t\treq->flags |= REQ_F_SKIP_LINK_CQES;\n\t}\n}\n\nstatic inline void req_fail_link_node(struct io_kiocb *req, int res)\n{\n\treq_set_fail(req);\n\treq->result = res;\n}\n\nstatic __cold void io_ring_ctx_ref_free(struct percpu_ref *ref)\n{\n\tstruct io_ring_ctx *ctx = container_of(ref, struct io_ring_ctx, refs);\n\n\tcomplete(&ctx->ref_comp);\n}\n\nstatic inline bool io_is_timeout_noseq(struct io_kiocb *req)\n{\n\treturn !req->timeout.off;\n}\n\nstatic __cold void io_fallback_req_func(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx,\n\t\t\t\t\t\tfallback_work.work);\n\tstruct llist_node *node = llist_del_all(&ctx->fallback_llist);\n\tstruct io_kiocb *req, *tmp;\n\tbool locked = false;\n\n\tpercpu_ref_get(&ctx->refs);\n\tllist_for_each_entry_safe(req, tmp, node, io_task_work.fallback_node)\n\t\treq->io_task_work.func(req, &locked);\n\n\tif (locked) {\n\t\tio_submit_flush_completions(ctx);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\tpercpu_ref_put(&ctx->refs);\n}\n\nstatic __cold struct io_ring_ctx *io_ring_ctx_alloc(struct io_uring_params *p)\n{\n\tstruct io_ring_ctx *ctx;\n\tint i, hash_bits;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\t/*\n\t * Use 5 bits less than the max cq entries, that should give us around\n\t * 32 entries per hash list if totally full and uniformly spread.\n\t */\n\thash_bits = ilog2(p->cq_entries);\n\thash_bits -= 5;\n\tif (hash_bits <= 0)\n\t\thash_bits = 1;\n\tctx->cancel_hash_bits = hash_bits;\n\tctx->cancel_hash = kmalloc((1U << hash_bits) * sizeof(struct hlist_head),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ctx->cancel_hash)\n\t\tgoto err;\n\t__hash_init(ctx->cancel_hash, 1U << hash_bits);\n\n\tctx->dummy_ubuf = kzalloc(sizeof(*ctx->dummy_ubuf), GFP_KERNEL);\n\tif (!ctx->dummy_ubuf)\n\t\tgoto err;\n\t/* set invalid range, so io_import_fixed() fails meeting it */\n\tctx->dummy_ubuf->ubuf = -1UL;\n\n\tctx->io_buffers = kcalloc(1U << IO_BUFFERS_HASH_BITS,\n\t\t\t\t\tsizeof(struct list_head), GFP_KERNEL);\n\tif (!ctx->io_buffers)\n\t\tgoto err;\n\tfor (i = 0; i < (1U << IO_BUFFERS_HASH_BITS); i++)\n\t\tINIT_LIST_HEAD(&ctx->io_buffers[i]);\n\n\tif (percpu_ref_init(&ctx->refs, io_ring_ctx_ref_free,\n\t\t\t    PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->flags = p->flags;\n\tinit_waitqueue_head(&ctx->sqo_sq_wait);\n\tINIT_LIST_HEAD(&ctx->sqd_list);\n\tINIT_LIST_HEAD(&ctx->cq_overflow_list);\n\tINIT_LIST_HEAD(&ctx->io_buffers_cache);\n\tINIT_LIST_HEAD(&ctx->apoll_cache);\n\tinit_completion(&ctx->ref_comp);\n\txa_init_flags(&ctx->personalities, XA_FLAGS_ALLOC1);\n\tmutex_init(&ctx->uring_lock);\n\tinit_waitqueue_head(&ctx->cq_wait);\n\tspin_lock_init(&ctx->completion_lock);\n\tspin_lock_init(&ctx->timeout_lock);\n\tINIT_WQ_LIST(&ctx->iopoll_list);\n\tINIT_LIST_HEAD(&ctx->io_buffers_pages);\n\tINIT_LIST_HEAD(&ctx->io_buffers_comp);\n\tINIT_LIST_HEAD(&ctx->defer_list);\n\tINIT_LIST_HEAD(&ctx->timeout_list);\n\tINIT_LIST_HEAD(&ctx->ltimeout_list);\n\tspin_lock_init(&ctx->rsrc_ref_lock);\n\tINIT_LIST_HEAD(&ctx->rsrc_ref_list);\n\tINIT_DELAYED_WORK(&ctx->rsrc_put_work, io_rsrc_put_work);\n\tinit_llist_head(&ctx->rsrc_put_llist);\n\tINIT_LIST_HEAD(&ctx->tctx_list);\n\tctx->submit_state.free_list.next = NULL;\n\tINIT_WQ_LIST(&ctx->locked_free_list);\n\tINIT_DELAYED_WORK(&ctx->fallback_work, io_fallback_req_func);\n\tINIT_WQ_LIST(&ctx->submit_state.compl_reqs);\n\treturn ctx;\nerr:\n\tkfree(ctx->dummy_ubuf);\n\tkfree(ctx->cancel_hash);\n\tkfree(ctx->io_buffers);\n\tkfree(ctx);\n\treturn NULL;\n}\n\nstatic void io_account_cq_overflow(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *r = ctx->rings;\n\n\tWRITE_ONCE(r->cq_overflow, READ_ONCE(r->cq_overflow) + 1);\n\tctx->cq_extra--;\n}\n\nstatic bool req_need_defer(struct io_kiocb *req, u32 seq)\n{\n\tif (unlikely(req->flags & REQ_F_IO_DRAIN)) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\treturn seq + READ_ONCE(ctx->cq_extra) != ctx->cached_cq_tail;\n\t}\n\n\treturn false;\n}\n\n#define FFS_NOWAIT\t\t0x1UL\n#define FFS_ISREG\t\t0x2UL\n#define FFS_MASK\t\t~(FFS_NOWAIT|FFS_ISREG)\n\nstatic inline bool io_req_ffs_set(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_FIXED_FILE;\n}\n\nstatic struct io_kiocb *__io_prep_linked_timeout(struct io_kiocb *req)\n{\n\tif (WARN_ON_ONCE(!req->link))\n\t\treturn NULL;\n\n\treq->flags &= ~REQ_F_ARM_LTIMEOUT;\n\treq->flags |= REQ_F_LINK_TIMEOUT;\n\n\t/* linked timeouts should have two refs once prep'ed */\n\tio_req_set_refcount(req);\n\t__io_req_set_refcount(req->link, 2);\n\treturn req->link;\n}\n\nstatic inline struct io_kiocb *io_prep_linked_timeout(struct io_kiocb *req)\n{\n\tif (likely(!(req->flags & REQ_F_ARM_LTIMEOUT)))\n\t\treturn NULL;\n\treturn __io_prep_linked_timeout(req);\n}\n\nstatic void io_prep_async_work(struct io_kiocb *req)\n{\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!(req->flags & REQ_F_CREDS)) {\n\t\treq->flags |= REQ_F_CREDS;\n\t\treq->creds = get_current_cred();\n\t}\n\n\treq->work.list.next = NULL;\n\treq->work.flags = 0;\n\tif (req->flags & REQ_F_FORCE_ASYNC)\n\t\treq->work.flags |= IO_WQ_WORK_CONCURRENT;\n\n\tif (req->flags & REQ_F_ISREG) {\n\t\tif (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n\t} else if (!req->file || !S_ISBLK(file_inode(req->file)->i_mode)) {\n\t\tif (def->unbound_nonreg_file)\n\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n\t}\n}\n\nstatic void io_prep_async_link(struct io_kiocb *req)\n{\n\tstruct io_kiocb *cur;\n\n\tif (req->flags & REQ_F_LINK_TIMEOUT) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tio_for_each_link(cur, req)\n\t\t\tio_prep_async_work(cur);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t} else {\n\t\tio_for_each_link(cur, req)\n\t\t\tio_prep_async_work(cur);\n\t}\n}\n\nstatic inline void io_req_add_compl_list(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\tctx->submit_state.flush_cqes = true;\n\twq_list_add_tail(&req->comp_list, &state->compl_reqs);\n}\n\nstatic void io_queue_async_work(struct io_kiocb *req, bool *dont_use)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *link = io_prep_linked_timeout(req);\n\tstruct io_uring_task *tctx = req->task->io_uring;\n\n\tBUG_ON(!tctx);\n\tBUG_ON(!tctx->io_wq);\n\n\t/* init ->work of the whole link before punting */\n\tio_prep_async_link(req);\n\n\t/*\n\t * Not expected to happen, but if we do have a bug where this _can_\n\t * happen, catch it here and ensure the request is marked as\n\t * canceled. That will make io-wq go through the usual work cancel\n\t * procedure rather than attempt to run this request (or create a new\n\t * worker for it).\n\t */\n\tif (WARN_ON_ONCE(!same_thread_group(req->task, current)))\n\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n\n\ttrace_io_uring_queue_async_work(ctx, req, req->user_data, req->opcode, req->flags,\n\t\t\t\t\t&req->work, io_wq_is_hashed(&req->work));\n\tio_wq_enqueue(tctx->io_wq, &req->work);\n\tif (link)\n\t\tio_queue_linked_timeout(link);\n}\n\nstatic void io_kill_timeout(struct io_kiocb *req, int status)\n\t__must_hold(&req->ctx->completion_lock)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io = req->async_data;\n\n\tif (hrtimer_try_to_cancel(&io->timer) != -1) {\n\t\tif (status)\n\t\t\treq_set_fail(req);\n\t\tatomic_set(&req->ctx->cq_timeouts,\n\t\t\tatomic_read(&req->ctx->cq_timeouts) + 1);\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_fill_cqe_req(req, status, 0);\n\t\tio_put_req_deferred(req);\n\t}\n}\n\nstatic __cold void io_queue_deferred(struct io_ring_ctx *ctx)\n{\n\twhile (!list_empty(&ctx->defer_list)) {\n\t\tstruct io_defer_entry *de = list_first_entry(&ctx->defer_list,\n\t\t\t\t\t\tstruct io_defer_entry, list);\n\n\t\tif (req_need_defer(de->req, de->seq))\n\t\t\tbreak;\n\t\tlist_del_init(&de->list);\n\t\tio_req_task_queue(de->req);\n\t\tkfree(de);\n\t}\n}\n\nstatic __cold void io_flush_timeouts(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tstruct io_kiocb *req, *tmp;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\tlist_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {\n\t\tu32 events_needed, events_got;\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since seq can easily wrap around over time, subtract\n\t\t * the last seq at which timeouts were flushed before comparing.\n\t\t * Assuming not more than 2^31-1 events have happened since,\n\t\t * these subtractions won't have wrapped, so we can check if\n\t\t * target is in [last_seq, current_seq] by comparing the two.\n\t\t */\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}\n\nstatic inline void io_commit_cqring(struct io_ring_ctx *ctx)\n{\n\t/* order cqe stores with ring update */\n\tsmp_store_release(&ctx->rings->cq.tail, ctx->cached_cq_tail);\n}\n\nstatic void __io_commit_cqring_flush(struct io_ring_ctx *ctx)\n{\n\tif (ctx->off_timeout_used || ctx->drain_active) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tif (ctx->off_timeout_used)\n\t\t\tio_flush_timeouts(ctx);\n\t\tif (ctx->drain_active)\n\t\t\tio_queue_deferred(ctx);\n\t\tio_commit_cqring(ctx);\n\t\tspin_unlock(&ctx->completion_lock);\n\t}\n\tif (ctx->has_evfd)\n\t\tio_eventfd_signal(ctx);\n}\n\nstatic inline bool io_sqring_full(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *r = ctx->rings;\n\n\treturn READ_ONCE(r->sq.tail) - ctx->cached_sq_head == ctx->sq_entries;\n}\n\nstatic inline unsigned int __io_cqring_events(struct io_ring_ctx *ctx)\n{\n\treturn ctx->cached_cq_tail - READ_ONCE(ctx->rings->cq.head);\n}\n\nstatic inline struct io_uring_cqe *io_get_cqe(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\tunsigned tail, mask = ctx->cq_entries - 1;\n\n\t/*\n\t * writes to the cq entry need to come after reading head; the\n\t * control dependency is enough as we're using WRITE_ONCE to\n\t * fill the cq entry\n\t */\n\tif (__io_cqring_events(ctx) == ctx->cq_entries)\n\t\treturn NULL;\n\n\ttail = ctx->cached_cq_tail++;\n\treturn &rings->cqes[tail & mask];\n}\n\nstatic void io_eventfd_signal(struct io_ring_ctx *ctx)\n{\n\tstruct io_ev_fd *ev_fd;\n\n\trcu_read_lock();\n\t/*\n\t * rcu_dereference ctx->io_ev_fd once and use it for both for checking\n\t * and eventfd_signal\n\t */\n\tev_fd = rcu_dereference(ctx->io_ev_fd);\n\n\t/*\n\t * Check again if ev_fd exists incase an io_eventfd_unregister call\n\t * completed between the NULL check of ctx->io_ev_fd at the start of\n\t * the function and rcu_read_lock.\n\t */\n\tif (unlikely(!ev_fd))\n\t\tgoto out;\n\tif (READ_ONCE(ctx->rings->cq_flags) & IORING_CQ_EVENTFD_DISABLED)\n\t\tgoto out;\n\n\tif (!ev_fd->eventfd_async || io_wq_current_is_worker())\n\t\teventfd_signal(ev_fd->cq_ev_fd, 1);\nout:\n\trcu_read_unlock();\n}\n\nstatic inline void io_cqring_wake(struct io_ring_ctx *ctx)\n{\n\t/*\n\t * wake_up_all() may seem excessive, but io_wake_function() and\n\t * io_should_wake() handle the termination of the loop and only\n\t * wake as many waiters as we need to.\n\t */\n\tif (wq_has_sleeper(&ctx->cq_wait))\n\t\twake_up_all(&ctx->cq_wait);\n}\n\n/*\n * This should only get called when at least one event has been posted.\n * Some applications rely on the eventfd notification count only changing\n * IFF a new CQE has been added to the CQ ring. There's no depedency on\n * 1:1 relationship between how many times this function is called (and\n * hence the eventfd count) and number of CQEs posted to the CQ ring.\n */\nstatic inline void io_cqring_ev_posted(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(ctx->off_timeout_used || ctx->drain_active ||\n\t\t     ctx->has_evfd))\n\t\t__io_commit_cqring_flush(ctx);\n\n\tio_cqring_wake(ctx);\n}\n\nstatic void io_cqring_ev_posted_iopoll(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(ctx->off_timeout_used || ctx->drain_active ||\n\t\t     ctx->has_evfd))\n\t\t__io_commit_cqring_flush(ctx);\n\n\tif (ctx->flags & IORING_SETUP_SQPOLL)\n\t\tio_cqring_wake(ctx);\n}\n\n/* Returns true if there are no backlogged entries after the flush */\nstatic bool __io_cqring_overflow_flush(struct io_ring_ctx *ctx, bool force)\n{\n\tbool all_flushed, posted;\n\n\tif (!force && __io_cqring_events(ctx) == ctx->cq_entries)\n\t\treturn false;\n\n\tposted = false;\n\tspin_lock(&ctx->completion_lock);\n\twhile (!list_empty(&ctx->cq_overflow_list)) {\n\t\tstruct io_uring_cqe *cqe = io_get_cqe(ctx);\n\t\tstruct io_overflow_cqe *ocqe;\n\n\t\tif (!cqe && !force)\n\t\t\tbreak;\n\t\tocqe = list_first_entry(&ctx->cq_overflow_list,\n\t\t\t\t\tstruct io_overflow_cqe, list);\n\t\tif (cqe)\n\t\t\tmemcpy(cqe, &ocqe->cqe, sizeof(*cqe));\n\t\telse\n\t\t\tio_account_cq_overflow(ctx);\n\n\t\tposted = true;\n\t\tlist_del(&ocqe->list);\n\t\tkfree(ocqe);\n\t}\n\n\tall_flushed = list_empty(&ctx->cq_overflow_list);\n\tif (all_flushed) {\n\t\tclear_bit(0, &ctx->check_cq_overflow);\n\t\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t\t   ctx->rings->sq_flags & ~IORING_SQ_CQ_OVERFLOW);\n\t}\n\n\tif (posted)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (posted)\n\t\tio_cqring_ev_posted(ctx);\n\treturn all_flushed;\n}\n\nstatic bool io_cqring_overflow_flush(struct io_ring_ctx *ctx)\n{\n\tbool ret = true;\n\n\tif (test_bit(0, &ctx->check_cq_overflow)) {\n\t\t/* iopoll syncs against uring_lock, not completion_lock */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\tret = __io_cqring_overflow_flush(ctx, false);\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\n\treturn ret;\n}\n\n/* must to be called somewhat shortly after putting a request */\nstatic inline void io_put_task(struct task_struct *task, int nr)\n{\n\tstruct io_uring_task *tctx = task->io_uring;\n\n\tif (likely(task == current)) {\n\t\ttctx->cached_refs += nr;\n\t} else {\n\t\tpercpu_counter_sub(&tctx->inflight, nr);\n\t\tif (unlikely(atomic_read(&tctx->in_idle)))\n\t\t\twake_up(&tctx->wait);\n\t\tput_task_struct_many(task, nr);\n\t}\n}\n\nstatic void io_task_refs_refill(struct io_uring_task *tctx)\n{\n\tunsigned int refill = -tctx->cached_refs + IO_TCTX_REFS_CACHE_NR;\n\n\tpercpu_counter_add(&tctx->inflight, refill);\n\trefcount_add(refill, &current->usage);\n\ttctx->cached_refs += refill;\n}\n\nstatic inline void io_get_task_refs(int nr)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\ttctx->cached_refs -= nr;\n\tif (unlikely(tctx->cached_refs < 0))\n\t\tio_task_refs_refill(tctx);\n}\n\nstatic __cold void io_uring_drop_tctx_refs(struct task_struct *task)\n{\n\tstruct io_uring_task *tctx = task->io_uring;\n\tunsigned int refs = tctx->cached_refs;\n\n\tif (refs) {\n\t\ttctx->cached_refs = 0;\n\t\tpercpu_counter_sub(&tctx->inflight, refs);\n\t\tput_task_struct_many(task, refs);\n\t}\n}\n\nstatic bool io_cqring_event_overflow(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tstruct io_overflow_cqe *ocqe;\n\n\tocqe = kmalloc(sizeof(*ocqe), GFP_ATOMIC | __GFP_ACCOUNT);\n\tif (!ocqe) {\n\t\t/*\n\t\t * If we're in ring overflow flush mode, or in task cancel mode,\n\t\t * or cannot allocate an overflow entry, then we need to drop it\n\t\t * on the floor.\n\t\t */\n\t\tio_account_cq_overflow(ctx);\n\t\treturn false;\n\t}\n\tif (list_empty(&ctx->cq_overflow_list)) {\n\t\tset_bit(0, &ctx->check_cq_overflow);\n\t\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t\t   ctx->rings->sq_flags | IORING_SQ_CQ_OVERFLOW);\n\n\t}\n\tocqe->cqe.user_data = user_data;\n\tocqe->cqe.res = res;\n\tocqe->cqe.flags = cflags;\n\tlist_add_tail(&ocqe->list, &ctx->cq_overflow_list);\n\treturn true;\n}\n\nstatic inline bool __io_fill_cqe(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t s32 res, u32 cflags)\n{\n\tstruct io_uring_cqe *cqe;\n\n\t/*\n\t * If we can't get a cq entry, userspace overflowed the\n\t * submission (by quite a lot). Increment the overflow count in\n\t * the ring.\n\t */\n\tcqe = io_get_cqe(ctx);\n\tif (likely(cqe)) {\n\t\tWRITE_ONCE(cqe->user_data, user_data);\n\t\tWRITE_ONCE(cqe->res, res);\n\t\tWRITE_ONCE(cqe->flags, cflags);\n\t\treturn true;\n\t}\n\treturn io_cqring_event_overflow(ctx, user_data, res, cflags);\n}\n\nstatic inline bool __io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags)\n{\n\ttrace_io_uring_complete(req->ctx, req, req->user_data, res, cflags);\n\treturn __io_fill_cqe(req->ctx, req->user_data, res, cflags);\n}\n\nstatic noinline void io_fill_cqe_req(struct io_kiocb *req, s32 res, u32 cflags)\n{\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t__io_fill_cqe_req(req, res, cflags);\n}\n\nstatic noinline bool io_fill_cqe_aux(struct io_ring_ctx *ctx, u64 user_data,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tctx->cq_extra++;\n\ttrace_io_uring_complete(ctx, NULL, user_data, res, cflags);\n\treturn __io_fill_cqe(ctx, user_data, res, cflags);\n}\n\nstatic void __io_req_complete_post(struct io_kiocb *req, s32 res,\n\t\t\t\t   u32 cflags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t__io_fill_cqe_req(req, res, cflags);\n\t/*\n\t * If we're the last reference to this request, add to our locked\n\t * free_list cache.\n\t */\n\tif (req_ref_put_and_test(req)) {\n\t\tif (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {\n\t\t\tif (req->flags & IO_DISARM_MASK)\n\t\t\t\tio_disarm_next(req);\n\t\t\tif (req->link) {\n\t\t\t\tio_req_task_queue(req->link);\n\t\t\t\treq->link = NULL;\n\t\t\t}\n\t\t}\n\t\tio_req_put_rsrc(req, ctx);\n\t\t/*\n\t\t * Selected buffer deallocation in io_clean_op() assumes that\n\t\t * we don't hold ->completion_lock. Clean them here to avoid\n\t\t * deadlocks.\n\t\t */\n\t\tio_put_kbuf_comp(req);\n\t\tio_dismantle_req(req);\n\t\tio_put_task(req->task, 1);\n\t\twq_list_add_head(&req->comp_list, &ctx->locked_free_list);\n\t\tctx->locked_free_nr++;\n\t}\n}\n\nstatic void io_req_complete_post(struct io_kiocb *req, s32 res,\n\t\t\t\t u32 cflags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tspin_lock(&ctx->completion_lock);\n\t__io_req_complete_post(req, res, cflags);\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic inline void io_req_complete_state(struct io_kiocb *req, s32 res,\n\t\t\t\t\t u32 cflags)\n{\n\treq->result = res;\n\treq->cflags = cflags;\n\treq->flags |= REQ_F_COMPLETE_INLINE;\n}\n\nstatic inline void __io_req_complete(struct io_kiocb *req, unsigned issue_flags,\n\t\t\t\t     s32 res, u32 cflags)\n{\n\tif (issue_flags & IO_URING_F_COMPLETE_DEFER)\n\t\tio_req_complete_state(req, res, cflags);\n\telse\n\t\tio_req_complete_post(req, res, cflags);\n}\n\nstatic inline void io_req_complete(struct io_kiocb *req, s32 res)\n{\n\t__io_req_complete(req, 0, res, 0);\n}\n\nstatic void io_req_complete_failed(struct io_kiocb *req, s32 res)\n{\n\treq_set_fail(req);\n\tio_req_complete_post(req, res, io_put_kbuf(req, IO_URING_F_UNLOCKED));\n}\n\nstatic void io_req_complete_fail_submit(struct io_kiocb *req)\n{\n\t/*\n\t * We don't submit, fail them all, for that replace hardlinks with\n\t * normal links. Extra REQ_F_LINK is tolerated.\n\t */\n\treq->flags &= ~REQ_F_HARDLINK;\n\treq->flags |= REQ_F_LINK;\n\tio_req_complete_failed(req, req->result);\n}\n\n/*\n * Don't initialise the fields below on every allocation, but do that in\n * advance and keep them valid across allocations.\n */\nstatic void io_preinit_req(struct io_kiocb *req, struct io_ring_ctx *ctx)\n{\n\treq->ctx = ctx;\n\treq->link = NULL;\n\treq->async_data = NULL;\n\t/* not necessary, but safer to zero */\n\treq->result = 0;\n}\n\nstatic void io_flush_cached_locked_reqs(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct io_submit_state *state)\n{\n\tspin_lock(&ctx->completion_lock);\n\twq_list_splice(&ctx->locked_free_list, &state->free_list);\n\tctx->locked_free_nr = 0;\n\tspin_unlock(&ctx->completion_lock);\n}\n\n/* Returns true IFF there are requests in the cache */\nstatic bool io_flush_cached_reqs(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\t/*\n\t * If we have more than a batch's worth of requests in our IRQ side\n\t * locked cache, grab the lock and move them over to our submission\n\t * side cache.\n\t */\n\tif (READ_ONCE(ctx->locked_free_nr) > IO_COMPL_BATCH)\n\t\tio_flush_cached_locked_reqs(ctx, state);\n\treturn !!state->free_list.next;\n}\n\n/*\n * A request might get retired back into the request caches even before opcode\n * handlers and io_issue_sqe() are done with it, e.g. inline completion path.\n * Because of that, io_alloc_req() should be called only under ->uring_lock\n * and with extra caution to not get a request that is still worked on.\n */\nstatic __cold bool __io_alloc_req_refill(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\n\tvoid *reqs[IO_REQ_ALLOC_BATCH];\n\tstruct io_kiocb *req;\n\tint ret, i;\n\n\tif (likely(state->free_list.next || io_flush_cached_reqs(ctx)))\n\t\treturn true;\n\n\tret = kmem_cache_alloc_bulk(req_cachep, gfp, ARRAY_SIZE(reqs), reqs);\n\n\t/*\n\t * Bulk alloc is all-or-nothing. If we fail to get a batch,\n\t * retry single alloc to be on the safe side.\n\t */\n\tif (unlikely(ret <= 0)) {\n\t\treqs[0] = kmem_cache_alloc(req_cachep, gfp);\n\t\tif (!reqs[0])\n\t\t\treturn false;\n\t\tret = 1;\n\t}\n\n\tpercpu_ref_get_many(&ctx->refs, ret);\n\tfor (i = 0; i < ret; i++) {\n\t\treq = reqs[i];\n\n\t\tio_preinit_req(req, ctx);\n\t\twq_stack_add_head(&req->comp_list, &state->free_list);\n\t}\n\treturn true;\n}\n\nstatic inline bool io_alloc_req_refill(struct io_ring_ctx *ctx)\n{\n\tif (unlikely(!ctx->submit_state.free_list.next))\n\t\treturn __io_alloc_req_refill(ctx);\n\treturn true;\n}\n\nstatic inline struct io_kiocb *io_alloc_req(struct io_ring_ctx *ctx)\n{\n\tstruct io_wq_work_node *node;\n\n\tnode = wq_stack_extract(&ctx->submit_state.free_list);\n\treturn container_of(node, struct io_kiocb, comp_list);\n}\n\nstatic inline void io_put_file(struct file *file)\n{\n\tif (file)\n\t\tfput(file);\n}\n\nstatic inline void io_dismantle_req(struct io_kiocb *req)\n{\n\tunsigned int flags = req->flags;\n\n\tif (unlikely(flags & IO_REQ_CLEAN_FLAGS))\n\t\tio_clean_op(req);\n\tif (!(flags & REQ_F_FIXED_FILE))\n\t\tio_put_file(req->file);\n}\n\nstatic __cold void __io_free_req(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tio_req_put_rsrc(req, ctx);\n\tio_dismantle_req(req);\n\tio_put_task(req->task, 1);\n\n\tspin_lock(&ctx->completion_lock);\n\twq_list_add_head(&req->comp_list, &ctx->locked_free_list);\n\tctx->locked_free_nr++;\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic inline void io_remove_next_linked(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = req->link;\n\n\treq->link = nxt->link;\n\tnxt->link = NULL;\n}\n\nstatic bool io_kill_linked_timeout(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n\t__must_hold(&req->ctx->timeout_lock)\n{\n\tstruct io_kiocb *link = req->link;\n\n\tif (link && link->opcode == IORING_OP_LINK_TIMEOUT) {\n\t\tstruct io_timeout_data *io = link->async_data;\n\n\t\tio_remove_next_linked(req);\n\t\tlink->timeout.head = NULL;\n\t\tif (hrtimer_try_to_cancel(&io->timer) != -1) {\n\t\t\tlist_del(&link->timeout.list);\n\t\t\t/* leave REQ_F_CQE_SKIP to io_fill_cqe_req */\n\t\t\tio_fill_cqe_req(link, -ECANCELED, 0);\n\t\t\tio_put_req_deferred(link);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void io_fail_links(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n{\n\tstruct io_kiocb *nxt, *link = req->link;\n\tbool ignore_cqes = req->flags & REQ_F_SKIP_LINK_CQES;\n\n\treq->link = NULL;\n\twhile (link) {\n\t\tlong res = -ECANCELED;\n\n\t\tif (link->flags & REQ_F_FAIL)\n\t\t\tres = link->result;\n\n\t\tnxt = link->link;\n\t\tlink->link = NULL;\n\n\t\ttrace_io_uring_fail_link(req->ctx, req, req->user_data,\n\t\t\t\t\treq->opcode, link);\n\n\t\tif (!ignore_cqes) {\n\t\t\tlink->flags &= ~REQ_F_CQE_SKIP;\n\t\t\tio_fill_cqe_req(link, res, 0);\n\t\t}\n\t\tio_put_req_deferred(link);\n\t\tlink = nxt;\n\t}\n}\n\nstatic bool io_disarm_next(struct io_kiocb *req)\n\t__must_hold(&req->ctx->completion_lock)\n{\n\tbool posted = false;\n\n\tif (req->flags & REQ_F_ARM_LTIMEOUT) {\n\t\tstruct io_kiocb *link = req->link;\n\n\t\treq->flags &= ~REQ_F_ARM_LTIMEOUT;\n\t\tif (link && link->opcode == IORING_OP_LINK_TIMEOUT) {\n\t\t\tio_remove_next_linked(req);\n\t\t\t/* leave REQ_F_CQE_SKIP to io_fill_cqe_req */\n\t\t\tio_fill_cqe_req(link, -ECANCELED, 0);\n\t\t\tio_put_req_deferred(link);\n\t\t\tposted = true;\n\t\t}\n\t} else if (req->flags & REQ_F_LINK_TIMEOUT) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tposted = io_kill_linked_timeout(req);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t}\n\tif (unlikely((req->flags & REQ_F_FAIL) &&\n\t\t     !(req->flags & REQ_F_HARDLINK))) {\n\t\tposted |= (req->link != NULL);\n\t\tio_fail_links(req);\n\t}\n\treturn posted;\n}\n\nstatic void __io_req_find_next_prep(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool posted;\n\n\tspin_lock(&ctx->completion_lock);\n\tposted = io_disarm_next(req);\n\tif (posted)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (posted)\n\t\tio_cqring_ev_posted(ctx);\n}\n\nstatic inline struct io_kiocb *io_req_find_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt;\n\n\tif (likely(!(req->flags & (REQ_F_LINK|REQ_F_HARDLINK))))\n\t\treturn NULL;\n\t/*\n\t * If LINK is set, we have dependent requests in this chain. If we\n\t * didn't fail this request, queue the first one up, moving any other\n\t * dependencies to the next request. In case of failure, fail the rest\n\t * of the chain.\n\t */\n\tif (unlikely(req->flags & IO_DISARM_MASK))\n\t\t__io_req_find_next_prep(req);\n\tnxt = req->link;\n\treq->link = NULL;\n\treturn nxt;\n}\n\nstatic void ctx_flush_and_put(struct io_ring_ctx *ctx, bool *locked)\n{\n\tif (!ctx)\n\t\treturn;\n\tif (*locked) {\n\t\tio_submit_flush_completions(ctx);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\t*locked = false;\n\t}\n\tpercpu_ref_put(&ctx->refs);\n}\n\nstatic inline void ctx_commit_and_unlock(struct io_ring_ctx *ctx)\n{\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic void handle_prev_tw_list(struct io_wq_work_node *node,\n\t\t\t\tstruct io_ring_ctx **ctx, bool *uring_locked)\n{\n\tif (*ctx && !*uring_locked)\n\t\tspin_lock(&(*ctx)->completion_lock);\n\n\tdo {\n\t\tstruct io_wq_work_node *next = node->next;\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    io_task_work.node);\n\n\t\tprefetch(container_of(next, struct io_kiocb, io_task_work.node));\n\n\t\tif (req->ctx != *ctx) {\n\t\t\tif (unlikely(!*uring_locked && *ctx))\n\t\t\t\tctx_commit_and_unlock(*ctx);\n\n\t\t\tctx_flush_and_put(*ctx, uring_locked);\n\t\t\t*ctx = req->ctx;\n\t\t\t/* if not contended, grab and improve batching */\n\t\t\t*uring_locked = mutex_trylock(&(*ctx)->uring_lock);\n\t\t\tpercpu_ref_get(&(*ctx)->refs);\n\t\t\tif (unlikely(!*uring_locked))\n\t\t\t\tspin_lock(&(*ctx)->completion_lock);\n\t\t}\n\t\tif (likely(*uring_locked))\n\t\t\treq->io_task_work.func(req, uring_locked);\n\t\telse\n\t\t\t__io_req_complete_post(req, req->result,\n\t\t\t\t\t\tio_put_kbuf_comp(req));\n\t\tnode = next;\n\t} while (node);\n\n\tif (unlikely(!*uring_locked))\n\t\tctx_commit_and_unlock(*ctx);\n}\n\nstatic void handle_tw_list(struct io_wq_work_node *node,\n\t\t\t   struct io_ring_ctx **ctx, bool *locked)\n{\n\tdo {\n\t\tstruct io_wq_work_node *next = node->next;\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    io_task_work.node);\n\n\t\tprefetch(container_of(next, struct io_kiocb, io_task_work.node));\n\n\t\tif (req->ctx != *ctx) {\n\t\t\tctx_flush_and_put(*ctx, locked);\n\t\t\t*ctx = req->ctx;\n\t\t\t/* if not contended, grab and improve batching */\n\t\t\t*locked = mutex_trylock(&(*ctx)->uring_lock);\n\t\t\tpercpu_ref_get(&(*ctx)->refs);\n\t\t}\n\t\treq->io_task_work.func(req, locked);\n\t\tnode = next;\n\t} while (node);\n}\n\nstatic void tctx_task_work(struct callback_head *cb)\n{\n\tbool uring_locked = false;\n\tstruct io_ring_ctx *ctx = NULL;\n\tstruct io_uring_task *tctx = container_of(cb, struct io_uring_task,\n\t\t\t\t\t\t  task_work);\n\n\twhile (1) {\n\t\tstruct io_wq_work_node *node1, *node2;\n\n\t\tif (!tctx->task_list.first &&\n\t\t    !tctx->prior_task_list.first && uring_locked)\n\t\t\tio_submit_flush_completions(ctx);\n\n\t\tspin_lock_irq(&tctx->task_lock);\n\t\tnode1 = tctx->prior_task_list.first;\n\t\tnode2 = tctx->task_list.first;\n\t\tINIT_WQ_LIST(&tctx->task_list);\n\t\tINIT_WQ_LIST(&tctx->prior_task_list);\n\t\tif (!node2 && !node1)\n\t\t\ttctx->task_running = false;\n\t\tspin_unlock_irq(&tctx->task_lock);\n\t\tif (!node2 && !node1)\n\t\t\tbreak;\n\n\t\tif (node1)\n\t\t\thandle_prev_tw_list(node1, &ctx, &uring_locked);\n\n\t\tif (node2)\n\t\t\thandle_tw_list(node2, &ctx, &uring_locked);\n\t\tcond_resched();\n\t}\n\n\tctx_flush_and_put(ctx, &uring_locked);\n\n\t/* relaxed read is enough as only the task itself sets ->in_idle */\n\tif (unlikely(atomic_read(&tctx->in_idle)))\n\t\tio_uring_drop_tctx_refs(current);\n}\n\nstatic void io_req_task_work_add(struct io_kiocb *req, bool priority)\n{\n\tstruct task_struct *tsk = req->task;\n\tstruct io_uring_task *tctx = tsk->io_uring;\n\tenum task_work_notify_mode notify;\n\tstruct io_wq_work_node *node;\n\tunsigned long flags;\n\tbool running;\n\n\tWARN_ON_ONCE(!tctx);\n\n\tio_drop_inflight_file(req);\n\n\tspin_lock_irqsave(&tctx->task_lock, flags);\n\tif (priority)\n\t\twq_list_add_tail(&req->io_task_work.node, &tctx->prior_task_list);\n\telse\n\t\twq_list_add_tail(&req->io_task_work.node, &tctx->task_list);\n\trunning = tctx->task_running;\n\tif (!running)\n\t\ttctx->task_running = true;\n\tspin_unlock_irqrestore(&tctx->task_lock, flags);\n\n\t/* task_work already pending, we're done */\n\tif (running)\n\t\treturn;\n\n\t/*\n\t * SQPOLL kernel thread doesn't need notification, just a wakeup. For\n\t * all other cases, use TWA_SIGNAL unconditionally to ensure we're\n\t * processing task_work. There's no reliable way to tell if TWA_RESUME\n\t * will do the job.\n\t */\n\tnotify = (req->ctx->flags & IORING_SETUP_SQPOLL) ? TWA_NONE : TWA_SIGNAL;\n\tif (likely(!task_work_add(tsk, &tctx->task_work, notify))) {\n\t\tif (notify == TWA_NONE)\n\t\t\twake_up_process(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&tctx->task_lock, flags);\n\ttctx->task_running = false;\n\tnode = wq_list_merge(&tctx->prior_task_list, &tctx->task_list);\n\tspin_unlock_irqrestore(&tctx->task_lock, flags);\n\n\twhile (node) {\n\t\treq = container_of(node, struct io_kiocb, io_task_work.node);\n\t\tnode = node->next;\n\t\tif (llist_add(&req->io_task_work.fallback_node,\n\t\t\t      &req->ctx->fallback_llist))\n\t\t\tschedule_delayed_work(&req->ctx->fallback_work, 1);\n\t}\n}\n\nstatic void io_req_task_cancel(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t/* not needed for normal modes, but SQPOLL depends on it */\n\tio_tw_lock(ctx, locked);\n\tio_req_complete_failed(req, req->result);\n}\n\nstatic void io_req_task_submit(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tio_tw_lock(ctx, locked);\n\t/* req->task == current here, checking PF_EXITING is safe */\n\tif (likely(!(req->task->flags & PF_EXITING)))\n\t\t__io_queue_sqe(req);\n\telse\n\t\tio_req_complete_failed(req, -EFAULT);\n}\n\nstatic void io_req_task_queue_fail(struct io_kiocb *req, int ret)\n{\n\treq->result = ret;\n\treq->io_task_work.func = io_req_task_cancel;\n\tio_req_task_work_add(req, false);\n}\n\nstatic void io_req_task_queue(struct io_kiocb *req)\n{\n\treq->io_task_work.func = io_req_task_submit;\n\tio_req_task_work_add(req, false);\n}\n\nstatic void io_req_task_queue_reissue(struct io_kiocb *req)\n{\n\treq->io_task_work.func = io_queue_async_work;\n\tio_req_task_work_add(req, false);\n}\n\nstatic inline void io_queue_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = io_req_find_next(req);\n\n\tif (nxt)\n\t\tio_req_task_queue(nxt);\n}\n\nstatic void io_free_req(struct io_kiocb *req)\n{\n\tio_queue_next(req);\n\t__io_free_req(req);\n}\n\nstatic void io_free_req_work(struct io_kiocb *req, bool *locked)\n{\n\tio_free_req(req);\n}\n\nstatic void io_free_batch_list(struct io_ring_ctx *ctx,\n\t\t\t\tstruct io_wq_work_node *node)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct task_struct *task = NULL;\n\tint task_refs = 0;\n\n\tdo {\n\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    comp_list);\n\n\t\tif (unlikely(req->flags & REQ_F_REFCOUNT)) {\n\t\t\tnode = req->comp_list.next;\n\t\t\tif (!req_ref_put_and_test(req))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tio_req_put_rsrc_locked(req, ctx);\n\t\tio_queue_next(req);\n\t\tio_dismantle_req(req);\n\n\t\tif (req->task != task) {\n\t\t\tif (task)\n\t\t\t\tio_put_task(task, task_refs);\n\t\t\ttask = req->task;\n\t\t\ttask_refs = 0;\n\t\t}\n\t\ttask_refs++;\n\t\tnode = req->comp_list.next;\n\t\twq_stack_add_head(&req->comp_list, &ctx->submit_state.free_list);\n\t} while (node);\n\n\tif (task)\n\t\tio_put_task(task, task_refs);\n}\n\nstatic void __io_submit_flush_completions(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_wq_work_node *node, *prev;\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (state->flush_cqes) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\twq_list_for_each(node, prev, &state->compl_reqs) {\n\t\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,\n\t\t\t\t\t\t    comp_list);\n\n\t\t\tif (!(req->flags & REQ_F_CQE_SKIP))\n\t\t\t\t__io_fill_cqe_req(req, req->result, req->cflags);\n\t\t\tif ((req->flags & REQ_F_POLLED) && req->apoll) {\n\t\t\t\tstruct async_poll *apoll = req->apoll;\n\n\t\t\t\tif (apoll->double_poll)\n\t\t\t\t\tkfree(apoll->double_poll);\n\t\t\t\tlist_add(&apoll->poll.wait.entry,\n\t\t\t\t\t\t&ctx->apoll_cache);\n\t\t\t\treq->flags &= ~REQ_F_POLLED;\n\t\t\t}\n\t\t}\n\n\t\tio_commit_cqring(ctx);\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tio_cqring_ev_posted(ctx);\n\t\tstate->flush_cqes = false;\n\t}\n\n\tio_free_batch_list(ctx, state->compl_reqs.first);\n\tINIT_WQ_LIST(&state->compl_reqs);\n}\n\n/*\n * Drop reference to request, return next in chain (if there is one) if this\n * was the last reference to this request.\n */\nstatic inline struct io_kiocb *io_put_req_find_next(struct io_kiocb *req)\n{\n\tstruct io_kiocb *nxt = NULL;\n\n\tif (req_ref_put_and_test(req)) {\n\t\tnxt = io_req_find_next(req);\n\t\t__io_free_req(req);\n\t}\n\treturn nxt;\n}\n\nstatic inline void io_put_req(struct io_kiocb *req)\n{\n\tif (req_ref_put_and_test(req))\n\t\tio_free_req(req);\n}\n\nstatic inline void io_put_req_deferred(struct io_kiocb *req)\n{\n\tif (req_ref_put_and_test(req)) {\n\t\treq->io_task_work.func = io_free_req_work;\n\t\tio_req_task_work_add(req, false);\n\t}\n}\n\nstatic unsigned io_cqring_events(struct io_ring_ctx *ctx)\n{\n\t/* See comment at the top of this file */\n\tsmp_rmb();\n\treturn __io_cqring_events(ctx);\n}\n\nstatic inline unsigned int io_sqring_entries(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\n\t/* make sure SQ entry isn't read before tail */\n\treturn smp_load_acquire(&rings->sq.tail) - ctx->cached_sq_head;\n}\n\nstatic inline bool io_run_task_work(void)\n{\n\tif (test_thread_flag(TIF_NOTIFY_SIGNAL) || task_work_pending(current)) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tclear_notify_signal();\n\t\tif (task_work_pending(current))\n\t\t\ttask_work_run();\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int io_do_iopoll(struct io_ring_ctx *ctx, bool force_nonspin)\n{\n\tstruct io_wq_work_node *pos, *start, *prev;\n\tunsigned int poll_flags = BLK_POLL_NOSLEEP;\n\tDEFINE_IO_COMP_BATCH(iob);\n\tint nr_events = 0;\n\n\t/*\n\t * Only spin for completions if we don't have multiple devices hanging\n\t * off our complete list.\n\t */\n\tif (ctx->poll_multi_queue || force_nonspin)\n\t\tpoll_flags |= BLK_POLL_ONESHOT;\n\n\twq_list_for_each(pos, start, &ctx->iopoll_list) {\n\t\tstruct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list);\n\t\tstruct kiocb *kiocb = &req->rw.kiocb;\n\t\tint ret;\n\n\t\t/*\n\t\t * Move completed and retryable entries to our local lists.\n\t\t * If we find a request that requires polling, break out\n\t\t * and complete those lists first, if we have entries there.\n\t\t */\n\t\tif (READ_ONCE(req->iopoll_completed))\n\t\t\tbreak;\n\n\t\tret = kiocb->ki_filp->f_op->iopoll(kiocb, &iob, poll_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tpoll_flags |= BLK_POLL_ONESHOT;\n\n\t\t/* iopoll may have completed current req */\n\t\tif (!rq_list_empty(iob.req_list) ||\n\t\t    READ_ONCE(req->iopoll_completed))\n\t\t\tbreak;\n\t}\n\n\tif (!rq_list_empty(iob.req_list))\n\t\tiob.complete(&iob);\n\telse if (!pos)\n\t\treturn 0;\n\n\tprev = start;\n\twq_list_for_each_resume(pos, prev) {\n\t\tstruct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list);\n\n\t\t/* order with io_complete_rw_iopoll(), e.g. ->result updates */\n\t\tif (!smp_load_acquire(&req->iopoll_completed))\n\t\t\tbreak;\n\t\tif (unlikely(req->flags & REQ_F_CQE_SKIP))\n\t\t\tcontinue;\n\n\t\t__io_fill_cqe_req(req, req->result, io_put_kbuf(req, 0));\n\t\tnr_events++;\n\t}\n\n\tif (unlikely(!nr_events))\n\t\treturn 0;\n\n\tio_commit_cqring(ctx);\n\tio_cqring_ev_posted_iopoll(ctx);\n\tpos = start ? start->next : ctx->iopoll_list.first;\n\twq_list_cut(&ctx->iopoll_list, prev, start);\n\tio_free_batch_list(ctx, pos);\n\treturn nr_events;\n}\n\n/*\n * We can't just wait for polled events to come to us, we have to actively\n * find and complete them.\n */\nstatic __cold void io_iopoll_try_reap_events(struct io_ring_ctx *ctx)\n{\n\tif (!(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn;\n\n\tmutex_lock(&ctx->uring_lock);\n\twhile (!wq_list_empty(&ctx->iopoll_list)) {\n\t\t/* let it sleep and repeat later if can't complete a request */\n\t\tif (io_do_iopoll(ctx, true) == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Ensure we allow local-to-the-cpu processing to take place,\n\t\t * in this case we need to ensure that we reap all events.\n\t\t * Also let task_work, etc. to progress by releasing the mutex\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tcond_resched();\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t}\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic int io_iopoll_check(struct io_ring_ctx *ctx, long min)\n{\n\tunsigned int nr_events = 0;\n\tint ret = 0;\n\n\t/*\n\t * We disallow the app entering submit/complete with polling, but we\n\t * still need to lock the ring to prevent racing with polled issue\n\t * that got punted to a workqueue.\n\t */\n\tmutex_lock(&ctx->uring_lock);\n\t/*\n\t * Don't enter poll loop if we already have events pending.\n\t * If we do, we can potentially be spinning for commands that\n\t * already triggered a CQE (eg in error).\n\t */\n\tif (test_bit(0, &ctx->check_cq_overflow))\n\t\t__io_cqring_overflow_flush(ctx, false);\n\tif (io_cqring_events(ctx))\n\t\tgoto out;\n\tdo {\n\t\t/*\n\t\t * If a submit got punted to a workqueue, we can have the\n\t\t * application entering polling for a command before it gets\n\t\t * issued. That app will hold the uring_lock for the duration\n\t\t * of the poll right here, so we need to take a breather every\n\t\t * now and then to ensure that the issue has a chance to add\n\t\t * the poll to the issued list. Otherwise we can spin here\n\t\t * forever, while the workqueue is stuck trying to acquire the\n\t\t * very same mutex.\n\t\t */\n\t\tif (wq_list_empty(&ctx->iopoll_list)) {\n\t\t\tu32 tail = ctx->cached_cq_tail;\n\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tio_run_task_work();\n\t\t\tmutex_lock(&ctx->uring_lock);\n\n\t\t\t/* some requests don't go through iopoll_list */\n\t\t\tif (tail != ctx->cached_cq_tail ||\n\t\t\t    wq_list_empty(&ctx->iopoll_list))\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_do_iopoll(ctx, !min);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tnr_events += ret;\n\t\tret = 0;\n\t} while (nr_events < min && !need_resched());\nout:\n\tmutex_unlock(&ctx->uring_lock);\n\treturn ret;\n}\n\nstatic void kiocb_end_write(struct io_kiocb *req)\n{\n\t/*\n\t * Tell lockdep we inherited freeze protection from submission\n\t * thread.\n\t */\n\tif (req->flags & REQ_F_ISREG) {\n\t\tstruct super_block *sb = file_inode(req->file)->i_sb;\n\n\t\t__sb_writers_acquired(sb, SB_FREEZE_WRITE);\n\t\tsb_end_write(sb);\n\t}\n}\n\n#ifdef CONFIG_BLOCK\nstatic bool io_resubmit_prep(struct io_kiocb *req)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\n\tif (!req_has_async_data(req))\n\t\treturn !io_req_prep_async(req);\n\tiov_iter_restore(&rw->s.iter, &rw->s.iter_state);\n\treturn true;\n}\n\nstatic bool io_rw_should_reissue(struct io_kiocb *req)\n{\n\tumode_t mode = file_inode(req->file)->i_mode;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (!S_ISBLK(mode) && !S_ISREG(mode))\n\t\treturn false;\n\tif ((req->flags & REQ_F_NOWAIT) || (io_wq_current_is_worker() &&\n\t    !(ctx->flags & IORING_SETUP_IOPOLL)))\n\t\treturn false;\n\t/*\n\t * If ref is dying, we might be running poll reap from the exit work.\n\t * Don't attempt to reissue from that path, just let it fail with\n\t * -EAGAIN.\n\t */\n\tif (percpu_ref_is_dying(&ctx->refs))\n\t\treturn false;\n\t/*\n\t * Play it safe and assume not safe to re-import and reissue if we're\n\t * not in the original thread group (or in task context).\n\t */\n\tif (!same_thread_group(req->task, current) || !in_task())\n\t\treturn false;\n\treturn true;\n}\n#else\nstatic bool io_resubmit_prep(struct io_kiocb *req)\n{\n\treturn false;\n}\nstatic bool io_rw_should_reissue(struct io_kiocb *req)\n{\n\treturn false;\n}\n#endif\n\nstatic bool __io_complete_rw_common(struct io_kiocb *req, long res)\n{\n\tif (req->rw.kiocb.ki_flags & IOCB_WRITE) {\n\t\tkiocb_end_write(req);\n\t\tfsnotify_modify(req->file);\n\t} else {\n\t\tfsnotify_access(req->file);\n\t}\n\tif (unlikely(res != req->result)) {\n\t\tif ((res == -EAGAIN || res == -EOPNOTSUPP) &&\n\t\t    io_rw_should_reissue(req)) {\n\t\t\treq->flags |= REQ_F_REISSUE;\n\t\t\treturn true;\n\t\t}\n\t\treq_set_fail(req);\n\t\treq->result = res;\n\t}\n\treturn false;\n}\n\nstatic inline void io_req_task_complete(struct io_kiocb *req, bool *locked)\n{\n\tint res = req->result;\n\n\tif (*locked) {\n\t\tio_req_complete_state(req, res, io_put_kbuf(req, 0));\n\t\tio_req_add_compl_list(req);\n\t} else {\n\t\tio_req_complete_post(req, res,\n\t\t\t\t\tio_put_kbuf(req, IO_URING_F_UNLOCKED));\n\t}\n}\n\nstatic void __io_complete_rw(struct io_kiocb *req, long res,\n\t\t\t     unsigned int issue_flags)\n{\n\tif (__io_complete_rw_common(req, res))\n\t\treturn;\n\t__io_req_complete(req, issue_flags, req->result,\n\t\t\t\tio_put_kbuf(req, issue_flags));\n}\n\nstatic void io_complete_rw(struct kiocb *kiocb, long res)\n{\n\tstruct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);\n\n\tif (__io_complete_rw_common(req, res))\n\t\treturn;\n\treq->result = res;\n\treq->io_task_work.func = io_req_task_complete;\n\tio_req_task_work_add(req, !!(req->ctx->flags & IORING_SETUP_SQPOLL));\n}\n\nstatic void io_complete_rw_iopoll(struct kiocb *kiocb, long res)\n{\n\tstruct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE)\n\t\tkiocb_end_write(req);\n\tif (unlikely(res != req->result)) {\n\t\tif (res == -EAGAIN && io_rw_should_reissue(req)) {\n\t\t\treq->flags |= REQ_F_REISSUE;\n\t\t\treturn;\n\t\t}\n\t\treq->result = res;\n\t}\n\n\t/* order with io_iopoll_complete() checking ->iopoll_completed */\n\tsmp_store_release(&req->iopoll_completed, 1);\n}\n\n/*\n * After the iocb has been issued, it's safe to be found on the poll list.\n * Adding the kiocb to the list AFTER submission ensures that we don't\n * find it from a io_do_iopoll() thread before the issuer is done\n * accessing the kiocb cookie.\n */\nstatic void io_iopoll_req_issued(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tconst bool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\t/* workqueue context doesn't hold uring_lock, grab it now */\n\tif (unlikely(needs_lock))\n\t\tmutex_lock(&ctx->uring_lock);\n\n\t/*\n\t * Track whether we have multiple files in our lists. This will impact\n\t * how we do polling eventually, not spinning if we're on potentially\n\t * different devices.\n\t */\n\tif (wq_list_empty(&ctx->iopoll_list)) {\n\t\tctx->poll_multi_queue = false;\n\t} else if (!ctx->poll_multi_queue) {\n\t\tstruct io_kiocb *list_req;\n\n\t\tlist_req = container_of(ctx->iopoll_list.first, struct io_kiocb,\n\t\t\t\t\tcomp_list);\n\t\tif (list_req->file != req->file)\n\t\t\tctx->poll_multi_queue = true;\n\t}\n\n\t/*\n\t * For fast devices, IO may have already completed. If it has, add\n\t * it to the front so we find it first.\n\t */\n\tif (READ_ONCE(req->iopoll_completed))\n\t\twq_list_add_head(&req->comp_list, &ctx->iopoll_list);\n\telse\n\t\twq_list_add_tail(&req->comp_list, &ctx->iopoll_list);\n\n\tif (unlikely(needs_lock)) {\n\t\t/*\n\t\t * If IORING_SETUP_SQPOLL is enabled, sqes are either handle\n\t\t * in sq thread task context or in io worker task context. If\n\t\t * current task context is sq thread, we don't need to check\n\t\t * whether should wake up sq thread.\n\t\t */\n\t\tif ((ctx->flags & IORING_SETUP_SQPOLL) &&\n\t\t    wq_has_sleeper(&ctx->sq_data->wait))\n\t\t\twake_up(&ctx->sq_data->wait);\n\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n}\n\nstatic bool io_bdev_nowait(struct block_device *bdev)\n{\n\treturn !bdev || blk_queue_nowait(bdev_get_queue(bdev));\n}\n\n/*\n * If we tracked the file through the SCM inflight mechanism, we could support\n * any file. For now, just ensure that anything potentially problematic is done\n * inline.\n */\nstatic bool __io_file_supports_nowait(struct file *file, umode_t mode)\n{\n\tif (S_ISBLK(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(I_BDEV(file->f_mapping->host)))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif (S_ISSOCK(mode))\n\t\treturn true;\n\tif (S_ISREG(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&\n\t\t    file->f_op != &io_uring_fops)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* any ->read/write should understand O_NONBLOCK */\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn true;\n\treturn file->f_mode & FMODE_NOWAIT;\n}\n\n/*\n * If we tracked the file through the SCM inflight mechanism, we could support\n * any file. For now, just ensure that anything potentially problematic is done\n * inline.\n */\nstatic unsigned int io_file_get_flags(struct file *file)\n{\n\tumode_t mode = file_inode(file)->i_mode;\n\tunsigned int res = 0;\n\n\tif (S_ISREG(mode))\n\t\tres |= FFS_ISREG;\n\tif (__io_file_supports_nowait(file, mode))\n\t\tres |= FFS_NOWAIT;\n\treturn res;\n}\n\nstatic inline bool io_file_supports_nowait(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_SUPPORT_NOWAIT;\n}\n\nstatic int io_prep_rw(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tunsigned ioprio;\n\tint ret;\n\n\tkiocb->ki_pos = READ_ONCE(sqe->off);\n\n\tioprio = READ_ONCE(sqe->ioprio);\n\tif (ioprio) {\n\t\tret = ioprio_check_cap(ioprio);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkiocb->ki_ioprio = ioprio;\n\t} else {\n\t\tkiocb->ki_ioprio = get_current_ioprio();\n\t}\n\n\treq->imu = NULL;\n\treq->rw.addr = READ_ONCE(sqe->addr);\n\treq->rw.len = READ_ONCE(sqe->len);\n\treq->rw.flags = READ_ONCE(sqe->rw_flags);\n\treq->buf_index = READ_ONCE(sqe->buf_index);\n\treturn 0;\n}\n\nstatic inline void io_rw_done(struct kiocb *kiocb, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * We can't just restart the syscall, since previously\n\t\t * submitted sqes may already be in progress. Just fail this\n\t\t * IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\tfallthrough;\n\tdefault:\n\t\tkiocb->ki_complete(kiocb, ret);\n\t}\n}\n\nstatic inline loff_t *io_kiocb_update_pos(struct io_kiocb *req)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool is_stream = req->file->f_mode & FMODE_STREAM;\n\n\tif (kiocb->ki_pos == -1) {\n\t\tif (!is_stream) {\n\t\t\treq->flags |= REQ_F_CUR_POS;\n\t\t\tkiocb->ki_pos = req->file->f_pos;\n\t\t\treturn &kiocb->ki_pos;\n\t\t} else {\n\t\t\tkiocb->ki_pos = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn is_stream ? NULL : &kiocb->ki_pos;\n}\n\nstatic void kiocb_done(struct io_kiocb *req, ssize_t ret,\n\t\t       unsigned int issue_flags)\n{\n\tstruct io_async_rw *io = req->async_data;\n\n\t/* add previously done IO, if any */\n\tif (req_has_async_data(req) && io->bytes_done > 0) {\n\t\tif (ret < 0)\n\t\t\tret = io->bytes_done;\n\t\telse\n\t\t\tret += io->bytes_done;\n\t}\n\n\tif (req->flags & REQ_F_CUR_POS)\n\t\treq->file->f_pos = req->rw.kiocb.ki_pos;\n\tif (ret >= 0 && (req->rw.kiocb.ki_complete == io_complete_rw))\n\t\t__io_complete_rw(req, ret, issue_flags);\n\telse\n\t\tio_rw_done(&req->rw.kiocb, ret);\n\n\tif (req->flags & REQ_F_REISSUE) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (io_resubmit_prep(req))\n\t\t\tio_req_task_queue_reissue(req);\n\t\telse\n\t\t\tio_req_task_queue_fail(req, ret);\n\t}\n}\n\nstatic int __io_import_fixed(struct io_kiocb *req, int rw, struct iov_iter *iter,\n\t\t\t     struct io_mapped_ubuf *imu)\n{\n\tsize_t len = req->rw.len;\n\tu64 buf_end, buf_addr = req->rw.addr;\n\tsize_t offset;\n\n\tif (unlikely(check_add_overflow(buf_addr, (u64)len, &buf_end)))\n\t\treturn -EFAULT;\n\t/* not inside the mapped region */\n\tif (unlikely(buf_addr < imu->ubuf || buf_end > imu->ubuf_end))\n\t\treturn -EFAULT;\n\n\t/*\n\t * May not be a start of buffer, set size appropriately\n\t * and advance us to the beginning.\n\t */\n\toffset = buf_addr - imu->ubuf;\n\tiov_iter_bvec(iter, rw, imu->bvec, imu->nr_bvecs, offset + len);\n\n\tif (offset) {\n\t\t/*\n\t\t * Don't use iov_iter_advance() here, as it's really slow for\n\t\t * using the latter parts of a big fixed buffer - it iterates\n\t\t * over each segment manually. We can cheat a bit here, because\n\t\t * we know that:\n\t\t *\n\t\t * 1) it's a BVEC iter, we set it up\n\t\t * 2) all bvecs are PAGE_SIZE in size, except potentially the\n\t\t *    first and last bvec\n\t\t *\n\t\t * So just find our index, and adjust the iterator afterwards.\n\t\t * If the offset is within the first bvec (or the whole first\n\t\t * bvec, just use iov_iter_advance(). This makes it easier\n\t\t * since we can just skip the first segment, which may not\n\t\t * be PAGE_SIZE aligned.\n\t\t */\n\t\tconst struct bio_vec *bvec = imu->bvec;\n\n\t\tif (offset <= bvec->bv_len) {\n\t\t\tiov_iter_advance(iter, offset);\n\t\t} else {\n\t\t\tunsigned long seg_skip;\n\n\t\t\t/* skip first vec */\n\t\t\toffset -= bvec->bv_len;\n\t\t\tseg_skip = 1 + (offset >> PAGE_SHIFT);\n\n\t\t\titer->bvec = bvec + seg_skip;\n\t\t\titer->nr_segs -= seg_skip;\n\t\t\titer->count -= bvec->bv_len + offset;\n\t\t\titer->iov_offset = offset & ~PAGE_MASK;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int io_import_fixed(struct io_kiocb *req, int rw, struct iov_iter *iter,\n\t\t\t   unsigned int issue_flags)\n{\n\tstruct io_mapped_ubuf *imu = req->imu;\n\tu16 index, buf_index = req->buf_index;\n\n\tif (likely(!imu)) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\n\t\tif (unlikely(buf_index >= ctx->nr_user_bufs))\n\t\t\treturn -EFAULT;\n\t\tio_req_set_rsrc_node(req, ctx, issue_flags);\n\t\tindex = array_index_nospec(buf_index, ctx->nr_user_bufs);\n\t\timu = READ_ONCE(ctx->user_bufs[index]);\n\t\treq->imu = imu;\n\t}\n\treturn __io_import_fixed(req, rw, iter, imu);\n}\n\nstatic void io_ring_submit_unlock(struct io_ring_ctx *ctx, bool needs_lock)\n{\n\tif (needs_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic void io_ring_submit_lock(struct io_ring_ctx *ctx, bool needs_lock)\n{\n\t/*\n\t * \"Normal\" inline submissions always hold the uring_lock, since we\n\t * grab it from the system call. Same is true for the SQPOLL offload.\n\t * The only exception is when we've detached the request and issue it\n\t * from an async worker thread, grab the lock for that case.\n\t */\n\tif (needs_lock)\n\t\tmutex_lock(&ctx->uring_lock);\n}\n\nstatic void io_buffer_add_list(struct io_ring_ctx *ctx,\n\t\t\t       struct io_buffer_list *bl, unsigned int bgid)\n{\n\tstruct list_head *list;\n\n\tlist = &ctx->io_buffers[hash_32(bgid, IO_BUFFERS_HASH_BITS)];\n\tINIT_LIST_HEAD(&bl->buf_list);\n\tbl->bgid = bgid;\n\tlist_add(&bl->list, list);\n}\n\nstatic struct io_buffer *io_buffer_select(struct io_kiocb *req, size_t *len,\n\t\t\t\t\t  int bgid, unsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf = req->kbuf;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\n\tif (req->flags & REQ_F_BUFFER_SELECTED)\n\t\treturn kbuf;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbl = io_buffer_get_list(ctx, bgid);\n\tif (bl && !list_empty(&bl->buf_list)) {\n\t\tkbuf = list_first_entry(&bl->buf_list, struct io_buffer, list);\n\t\tlist_del(&kbuf->list);\n\t\tif (*len > kbuf->len)\n\t\t\t*len = kbuf->len;\n\t\treq->flags |= REQ_F_BUFFER_SELECTED;\n\t\treq->kbuf = kbuf;\n\t} else {\n\t\tkbuf = ERR_PTR(-ENOBUFS);\n\t}\n\n\tio_ring_submit_unlock(req->ctx, needs_lock);\n\treturn kbuf;\n}\n\nstatic void __user *io_rw_buffer_select(struct io_kiocb *req, size_t *len,\n\t\t\t\t\tunsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf;\n\tu16 bgid;\n\n\tbgid = req->buf_index;\n\tkbuf = io_buffer_select(req, len, bgid, issue_flags);\n\tif (IS_ERR(kbuf))\n\t\treturn kbuf;\n\treturn u64_to_user_ptr(kbuf->addr);\n}\n\n#ifdef CONFIG_COMPAT\nstatic ssize_t io_compat_import(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\tunsigned int issue_flags)\n{\n\tstruct compat_iovec __user *uiov;\n\tcompat_ssize_t clen;\n\tvoid __user *buf;\n\tssize_t len;\n\n\tuiov = u64_to_user_ptr(req->rw.addr);\n\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\treturn -EFAULT;\n\tif (__get_user(clen, &uiov->iov_len))\n\t\treturn -EFAULT;\n\tif (clen < 0)\n\t\treturn -EINVAL;\n\n\tlen = clen;\n\tbuf = io_rw_buffer_select(req, &len, issue_flags);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = (compat_size_t) len;\n\treturn 0;\n}\n#endif\n\nstatic ssize_t __io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\t      unsigned int issue_flags)\n{\n\tstruct iovec __user *uiov = u64_to_user_ptr(req->rw.addr);\n\tvoid __user *buf;\n\tssize_t len;\n\n\tif (copy_from_user(iov, uiov, sizeof(*uiov)))\n\t\treturn -EFAULT;\n\n\tlen = iov[0].iov_len;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tbuf = io_rw_buffer_select(req, &len, issue_flags);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = len;\n\treturn 0;\n}\n\nstatic ssize_t io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,\n\t\t\t\t    unsigned int issue_flags)\n{\n\tif (req->flags & REQ_F_BUFFER_SELECTED) {\n\t\tstruct io_buffer *kbuf = req->kbuf;\n\n\t\tiov[0].iov_base = u64_to_user_ptr(kbuf->addr);\n\t\tiov[0].iov_len = kbuf->len;\n\t\treturn 0;\n\t}\n\tif (req->rw.len != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\treturn io_compat_import(req, iov, issue_flags);\n#endif\n\n\treturn __io_iov_buffer_select(req, iov, issue_flags);\n}\n\nstatic struct iovec *__io_import_iovec(int rw, struct io_kiocb *req,\n\t\t\t\t       struct io_rw_state *s,\n\t\t\t\t       unsigned int issue_flags)\n{\n\tstruct iov_iter *iter = &s->iter;\n\tu8 opcode = req->opcode;\n\tstruct iovec *iovec;\n\tvoid __user *buf;\n\tsize_t sqe_len;\n\tssize_t ret;\n\n\tif (opcode == IORING_OP_READ_FIXED || opcode == IORING_OP_WRITE_FIXED) {\n\t\tret = io_import_fixed(req, rw, iter, issue_flags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\treturn NULL;\n\t}\n\n\t/* buffer index only valid with fixed read/write, or buffer select  */\n\tif (unlikely(req->buf_index && !(req->flags & REQ_F_BUFFER_SELECT)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbuf = u64_to_user_ptr(req->rw.addr);\n\tsqe_len = req->rw.len;\n\n\tif (opcode == IORING_OP_READ || opcode == IORING_OP_WRITE) {\n\t\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\t\tbuf = io_rw_buffer_select(req, &sqe_len, issue_flags);\n\t\t\tif (IS_ERR(buf))\n\t\t\t\treturn ERR_CAST(buf);\n\t\t\treq->rw.len = sqe_len;\n\t\t}\n\n\t\tret = import_single_range(rw, buf, sqe_len, s->fast_iov, iter);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\treturn NULL;\n\t}\n\n\tiovec = s->fast_iov;\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tret = io_iov_buffer_select(req, iovec, issue_flags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tiov_iter_init(iter, rw, iovec, 1, iovec->iov_len);\n\t\treturn NULL;\n\t}\n\n\tret = __import_iovec(rw, buf, sqe_len, UIO_FASTIOV, &iovec, iter,\n\t\t\t      req->ctx->compat);\n\tif (unlikely(ret < 0))\n\t\treturn ERR_PTR(ret);\n\treturn iovec;\n}\n\nstatic inline int io_import_iovec(int rw, struct io_kiocb *req,\n\t\t\t\t  struct iovec **iovec, struct io_rw_state *s,\n\t\t\t\t  unsigned int issue_flags)\n{\n\t*iovec = __io_import_iovec(rw, req, s, issue_flags);\n\tif (unlikely(IS_ERR(*iovec)))\n\t\treturn PTR_ERR(*iovec);\n\n\tiov_iter_save_state(&s->iter, &s->iter_state);\n\treturn 0;\n}\n\nstatic inline loff_t *io_kiocb_ppos(struct kiocb *kiocb)\n{\n\treturn (kiocb->ki_filp->f_mode & FMODE_STREAM) ? NULL : &kiocb->ki_pos;\n}\n\n/*\n * For files that don't have ->read_iter() and ->write_iter(), handle them\n * by looping over ->read() or ->write() manually.\n */\nstatic ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct file *file = req->file;\n\tssize_t ret = 0;\n\tloff_t *ppos;\n\n\t/*\n\t * Don't support polled IO through this interface, and we can't\n\t * support non-blocking either. For the latter, this just causes\n\t * the kiocb to be handled from an async context.\n\t */\n\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) &&\n\t    !(kiocb->ki_filp->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tppos = io_kiocb_ppos(kiocb);\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec;\n\t\tssize_t nr;\n\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiovec = iov_iter_iovec(iter);\n\t\t} else {\n\t\t\tiovec.iov_base = u64_to_user_ptr(req->rw.addr);\n\t\t\tiovec.iov_len = req->rw.len;\n\t\t}\n\n\t\tif (rw == READ) {\n\t\t\tnr = file->f_op->read(file, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = file->f_op->write(file, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiov_iter_advance(iter, nr);\n\t\t} else {\n\t\t\treq->rw.addr += nr;\n\t\t\treq->rw.len -= nr;\n\t\t\tif (!req->rw.len)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void io_req_map_rw(struct io_kiocb *req, const struct iovec *iovec,\n\t\t\t  const struct iovec *fast_iov, struct iov_iter *iter)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\n\tmemcpy(&rw->s.iter, iter, sizeof(*iter));\n\trw->free_iovec = iovec;\n\trw->bytes_done = 0;\n\t/* can only be fixed buffers, no need to do anything */\n\tif (iov_iter_is_bvec(iter))\n\t\treturn;\n\tif (!iovec) {\n\t\tunsigned iov_off = 0;\n\n\t\trw->s.iter.iov = rw->s.fast_iov;\n\t\tif (iter->iov != fast_iov) {\n\t\t\tiov_off = iter->iov - fast_iov;\n\t\t\trw->s.iter.iov += iov_off;\n\t\t}\n\t\tif (rw->s.fast_iov != fast_iov)\n\t\t\tmemcpy(rw->s.fast_iov + iov_off, fast_iov + iov_off,\n\t\t\t       sizeof(struct iovec) * iter->nr_segs);\n\t} else {\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\t}\n}\n\nstatic inline bool io_alloc_async_data(struct io_kiocb *req)\n{\n\tWARN_ON_ONCE(!io_op_defs[req->opcode].async_size);\n\treq->async_data = kmalloc(io_op_defs[req->opcode].async_size, GFP_KERNEL);\n\tif (req->async_data) {\n\t\treq->flags |= REQ_F_ASYNC_DATA;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int io_setup_async_rw(struct io_kiocb *req, const struct iovec *iovec,\n\t\t\t     struct io_rw_state *s, bool force)\n{\n\tif (!force && !io_op_defs[req->opcode].needs_async_setup)\n\t\treturn 0;\n\tif (!req_has_async_data(req)) {\n\t\tstruct io_async_rw *iorw;\n\n\t\tif (io_alloc_async_data(req)) {\n\t\t\tkfree(iovec);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tio_req_map_rw(req, iovec, s->fast_iov, &s->iter);\n\t\tiorw = req->async_data;\n\t\t/* we've copied and mapped the iter, ensure state is saved */\n\t\tiov_iter_save_state(&iorw->s.iter, &iorw->s.iter_state);\n\t}\n\treturn 0;\n}\n\nstatic inline int io_rw_prep_async(struct io_kiocb *req, int rw)\n{\n\tstruct io_async_rw *iorw = req->async_data;\n\tstruct iovec *iov;\n\tint ret;\n\n\t/* submission path, ->uring_lock should already be taken */\n\tret = io_import_iovec(rw, req, &iov, &iorw->s, 0);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tiorw->bytes_done = 0;\n\tiorw->free_iovec = iov;\n\tif (iov)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\n/*\n * This is our waitqueue callback handler, registered through __folio_lock_async()\n * when we initially tried to do the IO with the iocb armed our waitqueue.\n * This gets called when the page is unlocked, and we generally expect that to\n * happen when the page IO is completed and the page is now uptodate. This will\n * queue a task_work based retry of the operation, attempting to copy the data\n * again. If the latter fails because the page was NOT uptodate, then we will\n * do a thread based blocking retry of the operation. That's the unexpected\n * slow path.\n */\nstatic int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,\n\t\t\t     int sync, void *arg)\n{\n\tstruct wait_page_queue *wpq;\n\tstruct io_kiocb *req = wait->private;\n\tstruct wait_page_key *key = arg;\n\n\twpq = container_of(wait, struct wait_page_queue, wait);\n\n\tif (!wake_page_match(wpq, key))\n\t\treturn 0;\n\n\treq->rw.kiocb.ki_flags &= ~IOCB_WAITQ;\n\tlist_del_init(&wait->entry);\n\tio_req_task_queue(req);\n\treturn 1;\n}\n\n/*\n * This controls whether a given IO request should be armed for async page\n * based retry. If we return false here, the request is handed to the async\n * worker threads for retry. If we're doing buffered reads on a regular file,\n * we prepare a private wait_page_queue entry and retry the operation. This\n * will either succeed because the page is now uptodate and unlocked, or it\n * will register a callback when the page is unlocked at IO completion. Through\n * that callback, io_uring uses task_work to setup a retry of the operation.\n * That retry will attempt the buffered read again. The retry will generally\n * succeed, or in rare cases where it fails, we then fall back to using the\n * async worker threads for a blocking retry.\n */\nstatic bool io_rw_should_retry(struct io_kiocb *req)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\tstruct wait_page_queue *wait = &rw->wpq;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\n\t/* never retry for NOWAIT, we just complete with -EAGAIN */\n\tif (req->flags & REQ_F_NOWAIT)\n\t\treturn false;\n\n\t/* Only for buffered IO */\n\tif (kiocb->ki_flags & (IOCB_DIRECT | IOCB_HIPRI))\n\t\treturn false;\n\n\t/*\n\t * just use poll if we can, and don't attempt if the fs doesn't\n\t * support callback based unlocks\n\t */\n\tif (file_can_poll(req->file) || !(req->file->f_mode & FMODE_BUF_RASYNC))\n\t\treturn false;\n\n\twait->wait.func = io_async_buf_func;\n\twait->wait.private = req;\n\twait->wait.flags = 0;\n\tINIT_LIST_HEAD(&wait->wait.entry);\n\tkiocb->ki_flags |= IOCB_WAITQ;\n\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\tkiocb->ki_waitq = wait;\n\treturn true;\n}\n\nstatic inline int io_iter_do_read(struct io_kiocb *req, struct iov_iter *iter)\n{\n\tif (likely(req->file->f_op->read_iter))\n\t\treturn call_read_iter(req->file, &req->rw.kiocb, iter);\n\telse if (req->file->f_op->read)\n\t\treturn loop_rw_iter(READ, req, iter);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool need_read_all(struct io_kiocb *req)\n{\n\treturn req->flags & REQ_F_ISREG ||\n\t\tS_ISBLK(file_inode(req->file)->i_mode);\n}\n\nstatic int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rw_state __s, *s = &__s;\n\tstruct iovec *iovec;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tstruct io_async_rw *rw;\n\tssize_t ret, ret2;\n\tloff_t *ppos;\n\n\tif (!req_has_async_data(req)) {\n\t\tret = io_import_iovec(READ, req, &iovec, s, issue_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t} else {\n\t\t/*\n\t\t * Safe and required to re-import if we're using provided\n\t\t * buffers, as we dropped the selected one before retry.\n\t\t */\n\t\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\t\tret = io_import_iovec(READ, req, &iovec, s, issue_flags);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t}\n\n\t\trw = req->async_data;\n\t\ts = &rw->s;\n\t\t/*\n\t\t * We come here from an earlier attempt, restore our state to\n\t\t * match in case it doesn't. It's cheap enough that we don't\n\t\t * need to make this conditional.\n\t\t */\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tiovec = NULL;\n\t}\n\tret = io_rw_init_file(req, FMODE_READ);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treq->result = iov_iter_count(&s->iter);\n\n\tif (force_nonblock) {\n\t\t/* If the file doesn't support async, just async punt */\n\t\tif (unlikely(!io_file_supports_nowait(req))) {\n\t\t\tret = io_setup_async_rw(req, iovec, s, true);\n\t\t\treturn ret ?: -EAGAIN;\n\t\t}\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\t} else {\n\t\t/* Ensure we clear previously set non-block flag */\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\t}\n\n\tppos = io_kiocb_update_pos(req);\n\n\tret = rw_verify_area(READ, req->file, ppos, req->result);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\n\tret = io_iter_do_read(req, &s->iter);\n\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\t/* if we can poll, just do that */\n\t\tif (req->opcode == IORING_OP_READ && file_can_poll(req->file))\n\t\t\treturn -EAGAIN;\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret == req->result || ret <= 0 || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !need_read_all(req)) {\n\t\t/* read all, failed, already did sync or don't want to retry */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Don't depend on the iter state matching what was consumed, or being\n\t * untouched in case of error. Restore it and we'll advance it\n\t * manually if we need to.\n\t */\n\tiov_iter_restore(&s->iter, &s->iter_state);\n\n\tret2 = io_setup_async_rw(req, iovec, s, true);\n\tif (ret2)\n\t\treturn ret2;\n\n\tiovec = NULL;\n\trw = req->async_data;\n\ts = &rw->s;\n\t/*\n\t * Now use our persistent iterator and state, if we aren't already.\n\t * We've restored and mapped the iter to match.\n\t */\n\n\tdo {\n\t\t/*\n\t\t * We end up here because of a partial read, either from\n\t\t * above or inside this loop. Advance the iter by the bytes\n\t\t * that were consumed.\n\t\t */\n\t\tiov_iter_advance(&s->iter, ret);\n\t\tif (!iov_iter_count(&s->iter))\n\t\t\tbreak;\n\t\trw->bytes_done += ret;\n\t\tiov_iter_save_state(&s->iter, &s->iter_state);\n\n\t\t/* if we can retry, do so with the callbacks armed */\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If\n\t\t * we get -EIOCBQUEUED, then we'll get a notification when the\n\t\t * desired page gets unlocked. We can also get a partial read\n\t\t * here, and if we do, then just retry at the new offset.\n\t\t */\n\t\tret = io_iter_do_read(req, &s->iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\t/* we got some bytes, but not all. retry. */\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t} while (ret > 0);\ndone:\n\tkiocb_done(req, ret, issue_flags);\nout_free:\n\t/* it's faster to check here then delegate to kfree */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}\n\nstatic int io_write(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rw_state __s, *s = &__s;\n\tstruct iovec *iovec;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tssize_t ret, ret2;\n\tloff_t *ppos;\n\n\tif (!req_has_async_data(req)) {\n\t\tret = io_import_iovec(WRITE, req, &iovec, s, issue_flags);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t} else {\n\t\tstruct io_async_rw *rw = req->async_data;\n\n\t\ts = &rw->s;\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tiovec = NULL;\n\t}\n\tret = io_rw_init_file(req, FMODE_WRITE);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treq->result = iov_iter_count(&s->iter);\n\n\tif (force_nonblock) {\n\t\t/* If the file doesn't support async, just async punt */\n\t\tif (unlikely(!io_file_supports_nowait(req)))\n\t\t\tgoto copy_iov;\n\n\t\t/* file path doesn't support NOWAIT for non-direct_IO */\n\t\tif (force_nonblock && !(kiocb->ki_flags & IOCB_DIRECT) &&\n\t\t    (req->flags & REQ_F_ISREG))\n\t\t\tgoto copy_iov;\n\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\t} else {\n\t\t/* Ensure we clear previously set non-block flag */\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\t}\n\n\tppos = io_kiocb_update_pos(req);\n\n\tret = rw_verify_area(WRITE, req->file, ppos, req->result);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\t/*\n\t * Open-code file_start_write here to grab freeze protection,\n\t * which will be released by another thread in\n\t * io_complete_rw().  Fool lockdep by telling it the lock got\n\t * released so that it doesn't complain about the held lock when\n\t * we return to userspace.\n\t */\n\tif (req->flags & REQ_F_ISREG) {\n\t\tsb_start_write(file_inode(req->file)->i_sb);\n\t\t__sb_writers_release(file_inode(req->file)->i_sb,\n\t\t\t\t\tSB_FREEZE_WRITE);\n\t}\n\tkiocb->ki_flags |= IOCB_WRITE;\n\n\tif (likely(req->file->f_op->write_iter))\n\t\tret2 = call_write_iter(req->file, kiocb, &s->iter);\n\telse if (req->file->f_op->write)\n\t\tret2 = loop_rw_iter(WRITE, req, &s->iter);\n\telse\n\t\tret2 = -EINVAL;\n\n\tif (req->flags & REQ_F_REISSUE) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tret2 = -EAGAIN;\n\t}\n\n\t/*\n\t * Raw bdev writes will return -EOPNOTSUPP for IOCB_NOWAIT. Just\n\t * retry them without IOCB_NOWAIT.\n\t */\n\tif (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT))\n\t\tret2 = -EAGAIN;\n\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\tif (ret2 == -EAGAIN && (req->flags & REQ_F_NOWAIT))\n\t\tgoto done;\n\tif (!force_nonblock || ret2 != -EAGAIN) {\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (ret2 == -EAGAIN && (req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto copy_iov;\ndone:\n\t\tkiocb_done(req, ret2, issue_flags);\n\t} else {\ncopy_iov:\n\t\tiov_iter_restore(&s->iter, &s->iter_state);\n\t\tret = io_setup_async_rw(req, iovec, s, false);\n\t\treturn ret ?: -EAGAIN;\n\t}\nout_free:\n\t/* it's reportedly faster than delegating the null check to kfree() */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn ret;\n}\n\nstatic int io_renameat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_rename *ren = &req->rename;\n\tconst char __user *oldf, *newf;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tren->old_dfd = READ_ONCE(sqe->fd);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tren->new_dfd = READ_ONCE(sqe->len);\n\tren->flags = READ_ONCE(sqe->rename_flags);\n\n\tren->oldpath = getname(oldf);\n\tif (IS_ERR(ren->oldpath))\n\t\treturn PTR_ERR(ren->oldpath);\n\n\tren->newpath = getname(newf);\n\tif (IS_ERR(ren->newpath)) {\n\t\tputname(ren->oldpath);\n\t\treturn PTR_ERR(ren->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_renameat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rename *ren = &req->rename;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_renameat2(ren->old_dfd, ren->oldpath, ren->new_dfd,\n\t\t\t\tren->newpath, ren->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_unlinkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_unlink *un = &req->unlink;\n\tconst char __user *fname;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->len || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tun->dfd = READ_ONCE(sqe->fd);\n\n\tun->flags = READ_ONCE(sqe->unlink_flags);\n\tif (un->flags & ~AT_REMOVEDIR)\n\t\treturn -EINVAL;\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tun->filename = getname(fname);\n\tif (IS_ERR(un->filename))\n\t\treturn PTR_ERR(un->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_unlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_unlink *un = &req->unlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (un->flags & AT_REMOVEDIR)\n\t\tret = do_rmdir(un->dfd, un->filename);\n\telse\n\t\tret = do_unlinkat(un->dfd, un->filename);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_mkdirat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_mkdir *mkd = &req->mkdir;\n\tconst char __user *fname;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->rw_flags || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tmkd->dfd = READ_ONCE(sqe->fd);\n\tmkd->mode = READ_ONCE(sqe->len);\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tmkd->filename = getname(fname);\n\tif (IS_ERR(mkd->filename))\n\t\treturn PTR_ERR(mkd->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_mkdirat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_mkdir *mkd = &req->mkdir;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_mkdirat(mkd->dfd, mkd->filename, mkd->mode);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_symlinkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_symlink *sl = &req->symlink;\n\tconst char __user *oldpath, *newpath;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->rw_flags || sqe->buf_index ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tsl->new_dfd = READ_ONCE(sqe->fd);\n\toldpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewpath = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\n\tsl->oldpath = getname(oldpath);\n\tif (IS_ERR(sl->oldpath))\n\t\treturn PTR_ERR(sl->oldpath);\n\n\tsl->newpath = getname(newpath);\n\tif (IS_ERR(sl->newpath)) {\n\t\tputname(sl->oldpath);\n\t\treturn PTR_ERR(sl->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_symlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_symlink *sl = &req->symlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_symlinkat(sl->oldpath, sl->new_dfd, sl->newpath);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_linkat_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_hardlink *lnk = &req->hardlink;\n\tconst char __user *oldf, *newf;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->rw_flags || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tlnk->old_dfd = READ_ONCE(sqe->fd);\n\tlnk->new_dfd = READ_ONCE(sqe->len);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlnk->flags = READ_ONCE(sqe->hardlink_flags);\n\n\tlnk->oldpath = getname(oldf);\n\tif (IS_ERR(lnk->oldpath))\n\t\treturn PTR_ERR(lnk->oldpath);\n\n\tlnk->newpath = getname(newf);\n\tif (IS_ERR(lnk->newpath)) {\n\t\tputname(lnk->oldpath);\n\t\treturn PTR_ERR(lnk->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_linkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_hardlink *lnk = &req->hardlink;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_linkat(lnk->old_dfd, lnk->oldpath, lnk->new_dfd,\n\t\t\t\tlnk->newpath, lnk->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_shutdown_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_NET)\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->ioprio || sqe->off || sqe->addr || sqe->rw_flags ||\n\t\t     sqe->buf_index || sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->shutdown.how = READ_ONCE(sqe->len);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_shutdown(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_NET)\n\tstruct socket *sock;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = __sys_shutdown_sock(sock, req->shutdown.how);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int __io_splice_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = &req->splice;\n\tunsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsp->len = READ_ONCE(sqe->len);\n\tsp->flags = READ_ONCE(sqe->splice_flags);\n\tif (unlikely(sp->flags & ~valid_flags))\n\t\treturn -EINVAL;\n\tsp->splice_fd_in = READ_ONCE(sqe->splice_fd_in);\n\treturn 0;\n}\n\nstatic int io_tee_prep(struct io_kiocb *req,\n\t\t       const struct io_uring_sqe *sqe)\n{\n\tif (READ_ONCE(sqe->splice_off_in) || READ_ONCE(sqe->off))\n\t\treturn -EINVAL;\n\treturn __io_splice_prep(req, sqe);\n}\n\nstatic int io_tee(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = &req->splice;\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, IO_URING_F_UNLOCKED);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tif (sp->len)\n\t\tret = do_tee(in, out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tio_put_file(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = &req->splice;\n\n\tsp->off_in = READ_ONCE(sqe->splice_off_in);\n\tsp->off_out = READ_ONCE(sqe->off);\n\treturn __io_splice_prep(req, sqe);\n}\n\nstatic int io_splice(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = &req->splice;\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tloff_t *poff_in, *poff_out;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, IO_URING_F_UNLOCKED);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tpoff_in = (sp->off_in == -1) ? NULL : &sp->off_in;\n\tpoff_out = (sp->off_out == -1) ? NULL : &sp->off_out;\n\n\tif (sp->len)\n\t\tret = do_splice(in, poff_in, out, poff_out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tio_put_file(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\n/*\n * IORING_OP_NOP just posts a completion event, nothing else.\n */\nstatic int io_nop(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\t__io_req_complete(req, issue_flags, 0, 0);\n\treturn 0;\n}\n\nstatic int io_msg_ring_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->rw_flags ||\n\t\t     sqe->splice_fd_in || sqe->buf_index || sqe->personality))\n\t\treturn -EINVAL;\n\n\treq->msg.user_data = READ_ONCE(sqe->off);\n\treq->msg.len = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx;\n\tstruct io_msg *msg = &req->msg;\n\tbool filled;\n\tint ret;\n\n\tret = -EBADFD;\n\tif (req->file->f_op != &io_uring_fops)\n\t\tgoto done;\n\n\tret = -EOVERFLOW;\n\ttarget_ctx = req->file->private_data;\n\n\tspin_lock(&target_ctx->completion_lock);\n\tfilled = io_fill_cqe_aux(target_ctx, msg->user_data, msg->len, 0);\n\tio_commit_cqring(target_ctx);\n\tspin_unlock(&target_ctx->completion_lock);\n\n\tif (filled) {\n\t\tio_cqring_ev_posted(target_ctx);\n\t\tret = 0;\n\t}\n\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_fsync_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index ||\n\t\t     sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->sync.flags = READ_ONCE(sqe->fsync_flags);\n\tif (unlikely(req->sync.flags & ~IORING_FSYNC_DATASYNC))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_fsync(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tloff_t end = req->sync.off + req->sync.len;\n\tint ret;\n\n\t/* fsync always requires a blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = vfs_fsync_range(req->file, req->sync.off,\n\t\t\t\tend > 0 ? end : LLONG_MAX,\n\t\t\t\treq->sync.flags & IORING_FSYNC_DATASYNC);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_fallocate_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n\tif (sqe->ioprio || sqe->buf_index || sqe->rw_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->addr);\n\treq->sync.mode = READ_ONCE(sqe->len);\n\treturn 0;\n}\n\nstatic int io_fallocate(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tint ret;\n\n\t/* fallocate always requiring blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\tret = vfs_fallocate(req->file, req->sync.mode, req->sync.off,\n\t\t\t\treq->sync.len);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\telse\n\t\tfsnotify_modify(req->file);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *fname;\n\tint ret;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->ioprio || sqe->buf_index))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\t/* open.how should be already initialised */\n\tif (!(req->open.how.flags & O_PATH) && force_o_largefile())\n\t\treq->open.how.flags |= O_LARGEFILE;\n\n\treq->open.dfd = READ_ONCE(sqe->fd);\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->open.filename = getname(fname);\n\tif (IS_ERR(req->open.filename)) {\n\t\tret = PTR_ERR(req->open.filename);\n\t\treq->open.filename = NULL;\n\t\treturn ret;\n\t}\n\n\treq->open.file_slot = READ_ONCE(sqe->file_index);\n\tif (req->open.file_slot && (req->open.how.flags & O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\treq->open.nofile = rlimit(RLIMIT_NOFILE);\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tu64 mode = READ_ONCE(sqe->len);\n\tu64 flags = READ_ONCE(sqe->open_flags);\n\n\treq->open.how = build_open_how(flags, mode);\n\treturn __io_openat_prep(req, sqe);\n}\n\nstatic int io_openat2_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct open_how __user *how;\n\tsize_t len;\n\tint ret;\n\n\thow = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlen = READ_ONCE(sqe->len);\n\tif (len < OPEN_HOW_SIZE_VER0)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&req->open.how, sizeof(req->open.how), how,\n\t\t\t\t\tlen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __io_openat_prep(req, sqe);\n}\n\nstatic int io_openat2(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct open_flags op;\n\tstruct file *file;\n\tbool resolve_nonblock, nonblock_set;\n\tbool fixed = !!req->open.file_slot;\n\tint ret;\n\n\tret = build_open_flags(&req->open.how, &op);\n\tif (ret)\n\t\tgoto err;\n\tnonblock_set = op.open_flag & O_NONBLOCK;\n\tresolve_nonblock = req->open.how.resolve & RESOLVE_CACHED;\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\t/*\n\t\t * Don't bother trying for O_TRUNC, O_CREAT, or O_TMPFILE open,\n\t\t * it'll always -EAGAIN\n\t\t */\n\t\tif (req->open.how.flags & (O_TRUNC | O_CREAT | O_TMPFILE))\n\t\t\treturn -EAGAIN;\n\t\top.lookup_flags |= LOOKUP_CACHED;\n\t\top.open_flag |= O_NONBLOCK;\n\t}\n\n\tif (!fixed) {\n\t\tret = __get_unused_fd_flags(req->open.how.flags, req->open.nofile);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tfile = do_filp_open(req->open.dfd, req->open.filename, &op);\n\tif (IS_ERR(file)) {\n\t\t/*\n\t\t * We could hang on to this 'fd' on retrying, but seems like\n\t\t * marginal gain for something that is now known to be a slower\n\t\t * path. So just put it, and we'll get a new one when we retry.\n\t\t */\n\t\tif (!fixed)\n\t\t\tput_unused_fd(ret);\n\n\t\tret = PTR_ERR(file);\n\t\t/* only retry if RESOLVE_CACHED wasn't already set by application */\n\t\tif (ret == -EAGAIN &&\n\t\t    (!resolve_nonblock && (issue_flags & IO_URING_F_NONBLOCK)))\n\t\t\treturn -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tif ((issue_flags & IO_URING_F_NONBLOCK) && !nonblock_set)\n\t\tfile->f_flags &= ~O_NONBLOCK;\n\tfsnotify_open(file);\n\n\tif (!fixed)\n\t\tfd_install(ret, file);\n\telse\n\t\tret = io_install_fixed_file(req, file, issue_flags,\n\t\t\t\t\t    req->open.file_slot - 1);\nerr:\n\tputname(req->open.filename);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_openat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\treturn io_openat2(req, issue_flags);\n}\n\nstatic int io_remove_buffers_prep(struct io_kiocb *req,\n\t\t\t\t  const struct io_uring_sqe *sqe)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tu64 tmp;\n\n\tif (sqe->ioprio || sqe->rw_flags || sqe->addr || sqe->len || sqe->off ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttmp = READ_ONCE(sqe->fd);\n\tif (!tmp || tmp > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->nbufs = tmp;\n\tp->bgid = READ_ONCE(sqe->buf_group);\n\treturn 0;\n}\n\nstatic int __io_remove_buffers(struct io_ring_ctx *ctx,\n\t\t\t       struct io_buffer_list *bl, unsigned nbufs)\n{\n\tunsigned i = 0;\n\n\t/* shouldn't happen */\n\tif (!nbufs)\n\t\treturn 0;\n\n\t/* the head kbuf is the list itself */\n\twhile (!list_empty(&bl->buf_list)) {\n\t\tstruct io_buffer *nxt;\n\n\t\tnxt = list_first_entry(&bl->buf_list, struct io_buffer, list);\n\t\tlist_del(&nxt->list);\n\t\tif (++i == nbufs)\n\t\t\treturn i;\n\t\tcond_resched();\n\t}\n\ti++;\n\n\treturn i;\n}\n\nstatic int io_remove_buffers(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tint ret = 0;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tret = -ENOENT;\n\tbl = io_buffer_get_list(ctx, p->bgid);\n\tif (bl)\n\t\tret = __io_remove_buffers(ctx, bl, p->nbufs);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\n\t/* complete before unlock, IOPOLL may need the lock */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn 0;\n}\n\nstatic int io_provide_buffers_prep(struct io_kiocb *req,\n\t\t\t\t   const struct io_uring_sqe *sqe)\n{\n\tunsigned long size, tmp_check;\n\tstruct io_provide_buf *p = &req->pbuf;\n\tu64 tmp;\n\n\tif (sqe->ioprio || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttmp = READ_ONCE(sqe->fd);\n\tif (!tmp || tmp > USHRT_MAX)\n\t\treturn -E2BIG;\n\tp->nbufs = tmp;\n\tp->addr = READ_ONCE(sqe->addr);\n\tp->len = READ_ONCE(sqe->len);\n\n\tif (check_mul_overflow((unsigned long)p->len, (unsigned long)p->nbufs,\n\t\t\t\t&size))\n\t\treturn -EOVERFLOW;\n\tif (check_add_overflow((unsigned long)p->addr, size, &tmp_check))\n\t\treturn -EOVERFLOW;\n\n\tsize = (unsigned long)p->len * p->nbufs;\n\tif (!access_ok(u64_to_user_ptr(p->addr), size))\n\t\treturn -EFAULT;\n\n\tp->bgid = READ_ONCE(sqe->buf_group);\n\ttmp = READ_ONCE(sqe->off);\n\tif (tmp > USHRT_MAX)\n\t\treturn -E2BIG;\n\tp->bid = tmp;\n\treturn 0;\n}\n\nstatic int io_refill_buffer_cache(struct io_ring_ctx *ctx)\n{\n\tstruct io_buffer *buf;\n\tstruct page *page;\n\tint bufs_in_page;\n\n\t/*\n\t * Completions that don't happen inline (eg not under uring_lock) will\n\t * add to ->io_buffers_comp. If we don't have any free buffers, check\n\t * the completion list and splice those entries first.\n\t */\n\tif (!list_empty_careful(&ctx->io_buffers_comp)) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tif (!list_empty(&ctx->io_buffers_comp)) {\n\t\t\tlist_splice_init(&ctx->io_buffers_comp,\n\t\t\t\t\t\t&ctx->io_buffers_cache);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&ctx->completion_lock);\n\t}\n\n\t/*\n\t * No free buffers and no completion entries either. Allocate a new\n\t * page worth of buffer entries and add those to our freelist.\n\t */\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlist_add(&page->lru, &ctx->io_buffers_pages);\n\n\tbuf = page_address(page);\n\tbufs_in_page = PAGE_SIZE / sizeof(*buf);\n\twhile (bufs_in_page) {\n\t\tlist_add_tail(&buf->list, &ctx->io_buffers_cache);\n\t\tbuf++;\n\t\tbufs_in_page--;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_add_buffers(struct io_ring_ctx *ctx, struct io_provide_buf *pbuf,\n\t\t\t  struct io_buffer_list *bl)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tif (list_empty(&ctx->io_buffers_cache) &&\n\t\t    io_refill_buffer_cache(ctx))\n\t\t\tbreak;\n\t\tbuf = list_first_entry(&ctx->io_buffers_cache, struct io_buffer,\n\t\t\t\t\tlist);\n\t\tlist_move_tail(&buf->list, &bl->buf_list);\n\t\tbuf->addr = addr;\n\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);\n\t\tbuf->bid = bid;\n\t\tbuf->bgid = pbuf->bgid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tcond_resched();\n\t}\n\n\treturn i ? 0 : -ENOMEM;\n}\n\nstatic int io_provide_buffers(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_provide_buf *p = &req->pbuf;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_buffer_list *bl;\n\tint ret = 0;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\n\tlockdep_assert_held(&ctx->uring_lock);\n\n\tbl = io_buffer_get_list(ctx, p->bgid);\n\tif (unlikely(!bl)) {\n\t\tbl = kmalloc(sizeof(*bl), GFP_KERNEL);\n\t\tif (!bl) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tio_buffer_add_list(ctx, bl, p->bgid);\n\t}\n\n\tret = io_add_buffers(ctx, p, bl);\nerr:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t/* complete before unlock, IOPOLL may need the lock */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn 0;\n}\n\nstatic int io_epoll_ctl_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_EPOLL)\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->epoll.epfd = READ_ONCE(sqe->fd);\n\treq->epoll.op = READ_ONCE(sqe->len);\n\treq->epoll.fd = READ_ONCE(sqe->off);\n\n\tif (ep_op_has_event(req->epoll.op)) {\n\t\tstruct epoll_event __user *ev;\n\n\t\tev = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\t\tif (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_epoll_ctl(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_EPOLL)\n\tstruct io_epoll *ie = &req->epoll;\n\tint ret;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tret = do_epoll_ctl(ie->epfd, ie->op, ie->fd, &ie->event, force_nonblock);\n\tif (force_nonblock && ret == -EAGAIN)\n\t\treturn -EAGAIN;\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_madvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)\n\tif (sqe->ioprio || sqe->buf_index || sqe->off || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->madvise.addr = READ_ONCE(sqe->addr);\n\treq->madvise.len = READ_ONCE(sqe->len);\n\treq->madvise.advice = READ_ONCE(sqe->fadvise_advice);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_madvise(struct io_kiocb *req, unsigned int issue_flags)\n{\n#if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)\n\tstruct io_madvise *ma = &req->madvise;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_madvise(current->mm, ma->addr, ma->len, ma->advice);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int io_fadvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tif (sqe->ioprio || sqe->buf_index || sqe->addr || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\treq->fadvise.offset = READ_ONCE(sqe->off);\n\treq->fadvise.len = READ_ONCE(sqe->len);\n\treq->fadvise.advice = READ_ONCE(sqe->fadvise_advice);\n\treturn 0;\n}\n\nstatic int io_fadvise(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_fadvise *fa = &req->fadvise;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\tswitch (fa->advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tret = vfs_fadvise(req->file, fa->offset, fa->len, fa->advice);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_statx_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *path;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\treq->statx.dfd = READ_ONCE(sqe->fd);\n\treq->statx.mask = READ_ONCE(sqe->len);\n\tpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->statx.buffer = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\treq->statx.flags = READ_ONCE(sqe->statx_flags);\n\n\treq->statx.filename = getname_flags(path,\n\t\t\t\t\tgetname_statx_lookup_flags(req->statx.flags),\n\t\t\t\t\tNULL);\n\n\tif (IS_ERR(req->statx.filename)) {\n\t\tint ret = PTR_ERR(req->statx.filename);\n\n\t\treq->statx.filename = NULL;\n\t\treturn ret;\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}\n\nstatic int io_statx(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_statx *ctx = &req->statx;\n\tint ret;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = do_statx(ctx->dfd, ctx->filename, ctx->flags, ctx->mask,\n\t\t       ctx->buffer);\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\nstatic int io_close_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->addr || sqe->len ||\n\t    sqe->rw_flags || sqe->buf_index)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\treq->close.fd = READ_ONCE(sqe->fd);\n\treq->close.file_slot = READ_ONCE(sqe->file_index);\n\tif (req->close.file_slot && req->close.fd)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int io_close(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct files_struct *files = current->files;\n\tstruct io_close *close = &req->close;\n\tstruct fdtable *fdt;\n\tstruct file *file = NULL;\n\tint ret = -EBADF;\n\n\tif (req->close.file_slot) {\n\t\tret = io_close_fixed(req, issue_flags);\n\t\tgoto err;\n\t}\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (close->fd >= fdt->max_fds) {\n\t\tspin_unlock(&files->file_lock);\n\t\tgoto err;\n\t}\n\tfile = fdt->fd[close->fd];\n\tif (!file || file->f_op == &io_uring_fops) {\n\t\tspin_unlock(&files->file_lock);\n\t\tfile = NULL;\n\t\tgoto err;\n\t}\n\n\t/* if the file has a flush method, be safe and punt to async */\n\tif (file->f_op->flush && (issue_flags & IO_URING_F_NONBLOCK)) {\n\t\tspin_unlock(&files->file_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tret = __close_fd_get_file(close->fd, &file);\n\tspin_unlock(&files->file_lock);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\n\t/* No ->flush() or already async, safely close from here */\n\tret = filp_close(file, current->files);\nerr:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tif (file)\n\t\tfput(file);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_sfr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tif (unlikely(ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index ||\n\t\t     sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\treq->sync.off = READ_ONCE(sqe->off);\n\treq->sync.len = READ_ONCE(sqe->len);\n\treq->sync.flags = READ_ONCE(sqe->sync_range_flags);\n\treturn 0;\n}\n\nstatic int io_sync_file_range(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tint ret;\n\n\t/* sync_file_range always requires a blocking context */\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tret = sync_file_range(req->file, req->sync.off, req->sync.len,\n\t\t\t\treq->sync.flags);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete(req, ret);\n\treturn 0;\n}\n\n#if defined(CONFIG_NET)\nstatic int io_setup_async_msg(struct io_kiocb *req,\n\t\t\t      struct io_async_msghdr *kmsg)\n{\n\tstruct io_async_msghdr *async_msg = req->async_data;\n\n\tif (async_msg)\n\t\treturn -EAGAIN;\n\tif (io_alloc_async_data(req)) {\n\t\tkfree(kmsg->free_iov);\n\t\treturn -ENOMEM;\n\t}\n\tasync_msg = req->async_data;\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\tmemcpy(async_msg, kmsg, sizeof(*kmsg));\n\tasync_msg->msg.msg_name = &async_msg->addr;\n\t/* if were using fast_iov, set it to the new one */\n\tif (!async_msg->free_iov)\n\t\tasync_msg->msg.msg_iter.iov = async_msg->fast_iov;\n\n\treturn -EAGAIN;\n}\n\nstatic int io_sendmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tiomsg->msg.msg_name = &iomsg->addr;\n\tiomsg->free_iov = iomsg->fast_iov;\n\treturn sendmsg_copy_msghdr(&iomsg->msg, req->sr_msg.umsg,\n\t\t\t\t   req->sr_msg.msg_flags, &iomsg->free_iov);\n}\n\nstatic int io_sendmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tret = io_sendmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\nstatic int io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\treturn 0;\n}\n\nstatic int io_sendmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_sendmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tflags = req->sr_msg.msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);\n\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t/* fast path, check for non-NULL to avoid function call */\n\tif (kmsg->free_iov)\n\t\tkfree(kmsg->free_iov);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_send(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = import_single_range(WRITE, sr->buf, sr->len, &iov, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\n\tflags = req->sr_msg.msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tmsg.msg_flags = flags;\n\tret = sock_sendmsg(sock, &msg);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int __io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t struct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct iovec __user *uiov;\n\tsize_t iov_len;\n\tint ret;\n\n\tret = __copy_msghdr_from_user(&iomsg->msg, sr->umsg,\n\t\t\t\t\t&iomsg->uaddr, &uiov, &iov_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tif (iov_len > 1)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(iomsg->fast_iov, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\t\tsr->len = iomsg->fast_iov[0].iov_len;\n\t\tiomsg->free_iov = NULL;\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(READ, uiov, iov_len, UIO_FASTIOV,\n\t\t\t\t     &iomsg->free_iov, &iomsg->msg.msg_iter,\n\t\t\t\t     false);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int __io_compat_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t\tstruct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct compat_iovec __user *uiov;\n\tcompat_uptr_t ptr;\n\tcompat_size_t len;\n\tint ret;\n\n\tret = __get_compat_msghdr(&iomsg->msg, sr->umsg_compat, &iomsg->uaddr,\n\t\t\t\t  &ptr, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tuiov = compat_ptr(ptr);\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tcompat_ssize_t clen;\n\n\t\tif (len > 1)\n\t\t\treturn -EINVAL;\n\t\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\t\tif (__get_user(clen, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\t\tif (clen < 0)\n\t\t\treturn -EINVAL;\n\t\tsr->len = clen;\n\t\tiomsg->free_iov = NULL;\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(READ, (struct iovec __user *)uiov, len,\n\t\t\t\t   UIO_FASTIOV, &iomsg->free_iov,\n\t\t\t\t   &iomsg->msg.msg_iter, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tiomsg->msg.msg_name = &iomsg->addr;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\treturn __io_compat_recvmsg_copy_hdr(req, iomsg);\n#endif\n\n\treturn __io_recvmsg_copy_hdr(req, iomsg);\n}\n\nstatic struct io_buffer *io_recv_buffer_select(struct io_kiocb *req,\n\t\t\t\t\t       unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\treturn io_buffer_select(req, &sr->len, sr->bgid, issue_flags);\n}\n\nstatic int io_recvmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tret = io_recvmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\nstatic int io_recvmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->bgid = READ_ONCE(sqe->buf_group);\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\tsr->done_io = 0;\n\treturn 0;\n}\n\nstatic bool io_net_retry(struct socket *sock, int flags)\n{\n\tif (!(flags & MSG_WAITALL))\n\t\treturn false;\n\treturn sock->type == SOCK_STREAM || sock->type == SOCK_SEQPACKET;\n}\n\nstatic int io_recvmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct socket *sock;\n\tstruct io_buffer *kbuf;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_recvmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tkbuf = io_recv_buffer_select(req, issue_flags);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\t\tkmsg->fast_iov[0].iov_base = u64_to_user_ptr(kbuf->addr);\n\t\tkmsg->fast_iov[0].iov_len = req->sr_msg.len;\n\t\tiov_iter_init(&kmsg->msg.msg_iter, READ, kmsg->fast_iov,\n\t\t\t\t1, req->sr_msg.len);\n\t}\n\n\tflags = req->sr_msg.msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tret = __sys_recvmsg_sock(sock, &kmsg->msg, req->sr_msg.umsg,\n\t\t\t\t\tkmsg->uaddr, flags);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_msg(req, kmsg);\n\t\t}\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (kmsg->msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\n\t\treq_set_fail(req);\n\t}\n\n\t/* fast path, check for non-NULL to avoid function call */\n\tif (kmsg->free_iov)\n\t\tkfree(kmsg->free_iov);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\t__io_req_complete(req, issue_flags, ret, io_put_kbuf(req, issue_flags));\n\treturn 0;\n}\n\nstatic int io_recv(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf;\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct msghdr msg;\n\tvoid __user *buf = sr->buf;\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tkbuf = io_recv_buffer_select(req, issue_flags);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\t\tbuf = u64_to_user_ptr(kbuf->addr);\n\t}\n\n\tret = import_single_range(READ, buf, sr->len, &iov, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_flags = 0;\n\n\tflags = req->sr_msg.msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tret = sock_recvmsg(sock, &msg, flags);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->len -= ret;\n\t\t\tsr->buf += ret;\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\nout_free:\n\t\treq_set_fail(req);\n\t}\n\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\t__io_req_complete(req, issue_flags, ret, io_put_kbuf(req, issue_flags));\n\treturn 0;\n}\n\nstatic int io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_accept *accept = &req->accept;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->buf_index)\n\t\treturn -EINVAL;\n\n\taccept->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\taccept->addr_len = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\taccept->flags = READ_ONCE(sqe->accept_flags);\n\taccept->nofile = rlimit(RLIMIT_NOFILE);\n\n\taccept->file_slot = READ_ONCE(sqe->file_index);\n\tif (accept->file_slot && (accept->flags & SOCK_CLOEXEC))\n\t\treturn -EINVAL;\n\tif (accept->flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (accept->flags & SOCK_NONBLOCK))\n\t\taccept->flags = (accept->flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\treturn 0;\n}\n\nstatic int io_accept(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_accept *accept = &req->accept;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tunsigned int file_flags = force_nonblock ? O_NONBLOCK : 0;\n\tbool fixed = !!accept->file_slot;\n\tstruct file *file;\n\tint ret, fd;\n\n\tif (!fixed) {\n\t\tfd = __get_unused_fd_flags(accept->flags, accept->nofile);\n\t\tif (unlikely(fd < 0))\n\t\t\treturn fd;\n\t}\n\tfile = do_accept(req->file, file_flags, accept->addr, accept->addr_len,\n\t\t\t accept->flags);\n\tif (IS_ERR(file)) {\n\t\tif (!fixed)\n\t\t\tput_unused_fd(fd);\n\t\tret = PTR_ERR(file);\n\t\tif (ret == -EAGAIN && force_nonblock)\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if (!fixed) {\n\t\tfd_install(fd, file);\n\t\tret = fd;\n\t} else {\n\t\tret = io_install_fixed_file(req, file, issue_flags,\n\t\t\t\t\t    accept->file_slot - 1);\n\t}\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_connect_prep_async(struct io_kiocb *req)\n{\n\tstruct io_async_connect *io = req->async_data;\n\tstruct io_connect *conn = &req->connect;\n\n\treturn move_addr_to_kernel(conn->addr, conn->addr_len, &io->address);\n}\n\nstatic int io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_connect *conn = &req->connect;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->len || sqe->buf_index || sqe->rw_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\tconn->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tconn->addr_len =  READ_ONCE(sqe->addr2);\n\treturn 0;\n}\n\nstatic int io_connect(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_connect __io, *io;\n\tunsigned file_flags;\n\tint ret;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tio = req->async_data;\n\t} else {\n\t\tret = move_addr_to_kernel(req->connect.addr,\n\t\t\t\t\t\treq->connect.addr_len,\n\t\t\t\t\t\t&__io.address);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tio = &__io;\n\t}\n\n\tfile_flags = force_nonblock ? O_NONBLOCK : 0;\n\n\tret = __sys_connect_file(req->file, &io->address,\n\t\t\t\t\treq->connect.addr_len, file_flags);\n\tif ((ret == -EAGAIN || ret == -EINPROGRESS) && force_nonblock) {\n\t\tif (req_has_async_data(req))\n\t\t\treturn -EAGAIN;\n\t\tif (io_alloc_async_data(req)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(req->async_data, &__io, sizeof(__io));\n\t\treturn -EAGAIN;\n\t}\n\tif (ret == -ERESTARTSYS)\n\t\tret = -EINTR;\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n#else /* !CONFIG_NET */\n#define IO_NETOP_FN(op)\t\t\t\t\t\t\t\\\nstatic int io_##op(struct io_kiocb *req, unsigned int issue_flags)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\n\n#define IO_NETOP_PREP(op)\t\t\t\t\t\t\\\nIO_NETOP_FN(op)\t\t\t\t\t\t\t\t\\\nstatic int io_##op##_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe) \\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define IO_NETOP_PREP_ASYNC(op)\t\t\t\t\t\t\\\nIO_NETOP_PREP(op)\t\t\t\t\t\t\t\\\nstatic int io_##op##_prep_async(struct io_kiocb *req)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn -EOPNOTSUPP;\t\t\t\t\t\t\\\n}\n\nIO_NETOP_PREP_ASYNC(sendmsg);\nIO_NETOP_PREP_ASYNC(recvmsg);\nIO_NETOP_PREP_ASYNC(connect);\nIO_NETOP_PREP(accept);\nIO_NETOP_FN(send);\nIO_NETOP_FN(recv);\n#endif /* CONFIG_NET */\n\nstruct io_poll_table {\n\tstruct poll_table_struct pt;\n\tstruct io_kiocb *req;\n\tint nr_entries;\n\tint error;\n};\n\n#define IO_POLL_CANCEL_FLAG\tBIT(31)\n#define IO_POLL_REF_MASK\tGENMASK(30, 0)\n\n/*\n * If refs part of ->poll_refs (see IO_POLL_REF_MASK) is 0, it's free. We can\n * bump it and acquire ownership. It's disallowed to modify requests while not\n * owning it, that prevents from races for enqueueing task_work's and b/w\n * arming poll and wakeups.\n */\nstatic inline bool io_poll_get_ownership(struct io_kiocb *req)\n{\n\treturn !(atomic_fetch_inc(&req->poll_refs) & IO_POLL_REF_MASK);\n}\n\nstatic void io_poll_mark_cancelled(struct io_kiocb *req)\n{\n\tatomic_or(IO_POLL_CANCEL_FLAG, &req->poll_refs);\n}\n\nstatic struct io_poll_iocb *io_poll_get_double(struct io_kiocb *req)\n{\n\t/* pure poll stashes this in ->async_data, poll driven retry elsewhere */\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treturn req->async_data;\n\treturn req->apoll->double_poll;\n}\n\nstatic struct io_poll_iocb *io_poll_get_single(struct io_kiocb *req)\n{\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treturn &req->poll;\n\treturn &req->apoll->poll;\n}\n\nstatic void io_poll_req_insert(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct hlist_head *list;\n\n\tlist = &ctx->cancel_hash[hash_long(req->user_data, ctx->cancel_hash_bits)];\n\thlist_add_head(&req->hash_node, list);\n}\n\nstatic void io_init_poll_iocb(struct io_poll_iocb *poll, __poll_t events,\n\t\t\t      wait_queue_func_t wake_func)\n{\n\tpoll->head = NULL;\n#define IO_POLL_UNMASK\t(EPOLLERR|EPOLLHUP|EPOLLNVAL|EPOLLRDHUP)\n\t/* mask in events that we always want/need */\n\tpoll->events = events | IO_POLL_UNMASK;\n\tINIT_LIST_HEAD(&poll->wait.entry);\n\tinit_waitqueue_func_entry(&poll->wait, wake_func);\n}\n\nstatic inline void io_poll_remove_entry(struct io_poll_iocb *poll)\n{\n\tstruct wait_queue_head *head = smp_load_acquire(&poll->head);\n\n\tif (head) {\n\t\tspin_lock_irq(&head->lock);\n\t\tlist_del_init(&poll->wait.entry);\n\t\tpoll->head = NULL;\n\t\tspin_unlock_irq(&head->lock);\n\t}\n}\n\nstatic void io_poll_remove_entries(struct io_kiocb *req)\n{\n\t/*\n\t * Nothing to do if neither of those flags are set. Avoid dipping\n\t * into the poll/apoll/double cachelines if we can.\n\t */\n\tif (!(req->flags & (REQ_F_SINGLE_POLL | REQ_F_DOUBLE_POLL)))\n\t\treturn;\n\n\t/*\n\t * While we hold the waitqueue lock and the waitqueue is nonempty,\n\t * wake_up_pollfree() will wait for us.  However, taking the waitqueue\n\t * lock in the first place can race with the waitqueue being freed.\n\t *\n\t * We solve this as eventpoll does: by taking advantage of the fact that\n\t * all users of wake_up_pollfree() will RCU-delay the actual free.  If\n\t * we enter rcu_read_lock() and see that the pointer to the queue is\n\t * non-NULL, we can then lock it without the memory being freed out from\n\t * under us.\n\t *\n\t * Keep holding rcu_read_lock() as long as we hold the queue lock, in\n\t * case the caller deletes the entry from the queue, leaving it empty.\n\t * In that case, only RCU prevents the queue memory from being freed.\n\t */\n\trcu_read_lock();\n\tif (req->flags & REQ_F_SINGLE_POLL)\n\t\tio_poll_remove_entry(io_poll_get_single(req));\n\tif (req->flags & REQ_F_DOUBLE_POLL)\n\t\tio_poll_remove_entry(io_poll_get_double(req));\n\trcu_read_unlock();\n}\n\n/*\n * All poll tw should go through this. Checks for poll events, manages\n * references, does rewait, etc.\n *\n * Returns a negative error on failure. >0 when no action require, which is\n * either spurious wakeup or multishot CQE is served. 0 when it's done with\n * the request, then the mask is stored in req->result.\n */\nstatic int io_poll_check_events(struct io_kiocb *req, bool locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_poll_iocb *poll = io_poll_get_single(req);\n\tint v;\n\n\t/* req->task == current here, checking PF_EXITING is safe */\n\tif (unlikely(req->task->flags & PF_EXITING))\n\t\tio_poll_mark_cancelled(req);\n\n\tdo {\n\t\tv = atomic_read(&req->poll_refs);\n\n\t\t/* tw handler should be the owner, and so have some references */\n\t\tif (WARN_ON_ONCE(!(v & IO_POLL_REF_MASK)))\n\t\t\treturn 0;\n\t\tif (v & IO_POLL_CANCEL_FLAG)\n\t\t\treturn -ECANCELED;\n\n\t\tif (!req->result) {\n\t\t\tstruct poll_table_struct pt = { ._key = req->cflags };\n\n\t\t\tif (unlikely(!io_assign_file(req, IO_URING_F_UNLOCKED)))\n\t\t\t\treq->result = -EBADF;\n\t\t\telse\n\t\t\t\treq->result = vfs_poll(req->file, &pt) & req->cflags;\n\t\t}\n\n\t\t/* multishot, just fill an CQE and proceed */\n\t\tif (req->result && !(req->cflags & EPOLLONESHOT)) {\n\t\t\t__poll_t mask = mangle_poll(req->result & poll->events);\n\t\t\tbool filled;\n\n\t\t\tspin_lock(&ctx->completion_lock);\n\t\t\tfilled = io_fill_cqe_aux(ctx, req->user_data, mask,\n\t\t\t\t\t\t IORING_CQE_F_MORE);\n\t\t\tio_commit_cqring(ctx);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\tif (unlikely(!filled))\n\t\t\t\treturn -ECANCELED;\n\t\t\tio_cqring_ev_posted(ctx);\n\t\t} else if (req->result) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Release all references, retry if someone tried to restart\n\t\t * task_work while we were executing it.\n\t\t */\n\t} while (atomic_sub_return(v & IO_POLL_REF_MASK, &req->poll_refs));\n\n\treturn 1;\n}\n\nstatic void io_poll_task_func(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tret = io_poll_check_events(req, *locked);\n\tif (ret > 0)\n\t\treturn;\n\n\tif (!ret) {\n\t\treq->result = mangle_poll(req->result & req->poll.events);\n\t} else {\n\t\treq->result = ret;\n\t\treq_set_fail(req);\n\t}\n\n\tio_poll_remove_entries(req);\n\tspin_lock(&ctx->completion_lock);\n\thash_del(&req->hash_node);\n\t__io_req_complete_post(req, req->result, 0);\n\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tio_cqring_ev_posted(ctx);\n}\n\nstatic void io_apoll_task_func(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tret = io_poll_check_events(req, *locked);\n\tif (ret > 0)\n\t\treturn;\n\n\tio_poll_remove_entries(req);\n\tspin_lock(&ctx->completion_lock);\n\thash_del(&req->hash_node);\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (!ret)\n\t\tio_req_task_submit(req, locked);\n\telse\n\t\tio_req_complete_failed(req, ret);\n}\n\nstatic void __io_poll_execute(struct io_kiocb *req, int mask, int events)\n{\n\treq->result = mask;\n\t/*\n\t * This is useful for poll that is armed on behalf of another\n\t * request, and where the wakeup path could be on a different\n\t * CPU. We want to avoid pulling in req->apoll->events for that\n\t * case.\n\t */\n\treq->cflags = events;\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treq->io_task_work.func = io_poll_task_func;\n\telse\n\t\treq->io_task_work.func = io_apoll_task_func;\n\n\ttrace_io_uring_task_add(req->ctx, req, req->user_data, req->opcode, mask);\n\tio_req_task_work_add(req, false);\n}\n\nstatic inline void io_poll_execute(struct io_kiocb *req, int res, int events)\n{\n\tif (io_poll_get_ownership(req))\n\t\t__io_poll_execute(req, res, events);\n}\n\nstatic void io_poll_cancel_req(struct io_kiocb *req)\n{\n\tio_poll_mark_cancelled(req);\n\t/* kick tw, which should complete the request */\n\tio_poll_execute(req, 0, 0);\n}\n\n#define wqe_to_req(wait)\t((void *)((unsigned long) (wait)->private & ~1))\n#define wqe_is_double(wait)\t((unsigned long) (wait)->private & 1)\n\nstatic int io_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,\n\t\t\tvoid *key)\n{\n\tstruct io_kiocb *req = wqe_to_req(wait);\n\tstruct io_poll_iocb *poll = container_of(wait, struct io_poll_iocb,\n\t\t\t\t\t\t wait);\n\t__poll_t mask = key_to_poll(key);\n\n\tif (unlikely(mask & POLLFREE)) {\n\t\tio_poll_mark_cancelled(req);\n\t\t/* we have to kick tw in case it's not already */\n\t\tio_poll_execute(req, 0, poll->events);\n\n\t\t/*\n\t\t * If the waitqueue is being freed early but someone is already\n\t\t * holds ownership over it, we have to tear down the request as\n\t\t * best we can. That means immediately removing the request from\n\t\t * its waitqueue and preventing all further accesses to the\n\t\t * waitqueue via the request.\n\t\t */\n\t\tlist_del_init(&poll->wait.entry);\n\n\t\t/*\n\t\t * Careful: this *must* be the last step, since as soon\n\t\t * as req->head is NULL'ed out, the request can be\n\t\t * completed and freed, since aio_poll_complete_work()\n\t\t * will no longer need to take the waitqueue lock.\n\t\t */\n\t\tsmp_store_release(&poll->head, NULL);\n\t\treturn 1;\n\t}\n\n\t/* for instances that support it check for an event match first */\n\tif (mask && !(mask & poll->events))\n\t\treturn 0;\n\n\tif (io_poll_get_ownership(req)) {\n\t\t/* optional, saves extra locking for removal in tw handler */\n\t\tif (mask && poll->events & EPOLLONESHOT) {\n\t\t\tlist_del_init(&poll->wait.entry);\n\t\t\tpoll->head = NULL;\n\t\t\tif (wqe_is_double(wait))\n\t\t\t\treq->flags &= ~REQ_F_DOUBLE_POLL;\n\t\t\telse\n\t\t\t\treq->flags &= ~REQ_F_SINGLE_POLL;\n\t\t}\n\t\t__io_poll_execute(req, mask, poll->events);\n\t}\n\treturn 1;\n}\n\nstatic void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,\n\t\t\t    struct wait_queue_head *head,\n\t\t\t    struct io_poll_iocb **poll_ptr)\n{\n\tstruct io_kiocb *req = pt->req;\n\tunsigned long wqe_private = (unsigned long) req;\n\n\t/*\n\t * The file being polled uses multiple waitqueues for poll handling\n\t * (e.g. one for read, one for write). Setup a separate io_poll_iocb\n\t * if this happens.\n\t */\n\tif (unlikely(pt->nr_entries)) {\n\t\tstruct io_poll_iocb *first = poll;\n\n\t\t/* double add on the same waitqueue head, ignore */\n\t\tif (first->head == head)\n\t\t\treturn;\n\t\t/* already have a 2nd entry, fail a third attempt */\n\t\tif (*poll_ptr) {\n\t\t\tif ((*poll_ptr)->head == head)\n\t\t\t\treturn;\n\t\t\tpt->error = -EINVAL;\n\t\t\treturn;\n\t\t}\n\n\t\tpoll = kmalloc(sizeof(*poll), GFP_ATOMIC);\n\t\tif (!poll) {\n\t\t\tpt->error = -ENOMEM;\n\t\t\treturn;\n\t\t}\n\t\t/* mark as double wq entry */\n\t\twqe_private |= 1;\n\t\treq->flags |= REQ_F_DOUBLE_POLL;\n\t\tio_init_poll_iocb(poll, first->events, first->wait.func);\n\t\t*poll_ptr = poll;\n\t\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\t\treq->flags |= REQ_F_ASYNC_DATA;\n\t}\n\n\treq->flags |= REQ_F_SINGLE_POLL;\n\tpt->nr_entries++;\n\tpoll->head = head;\n\tpoll->wait.private = (void *) wqe_private;\n\n\tif (poll->events & EPOLLEXCLUSIVE)\n\t\tadd_wait_queue_exclusive(head, &poll->wait);\n\telse\n\t\tadd_wait_queue(head, &poll->wait);\n}\n\nstatic void io_poll_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\t\t       struct poll_table_struct *p)\n{\n\tstruct io_poll_table *pt = container_of(p, struct io_poll_table, pt);\n\n\t__io_queue_proc(&pt->req->poll, pt, head,\n\t\t\t(struct io_poll_iocb **) &pt->req->async_data);\n}\n\nstatic int __io_arm_poll_handler(struct io_kiocb *req,\n\t\t\t\t struct io_poll_iocb *poll,\n\t\t\t\t struct io_poll_table *ipt, __poll_t mask)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint v;\n\n\tINIT_HLIST_NODE(&req->hash_node);\n\tio_init_poll_iocb(poll, mask, io_poll_wake);\n\tpoll->file = req->file;\n\n\tipt->pt._key = mask;\n\tipt->req = req;\n\tipt->error = 0;\n\tipt->nr_entries = 0;\n\n\t/*\n\t * Take the ownership to delay any tw execution up until we're done\n\t * with poll arming. see io_poll_get_ownership().\n\t */\n\tatomic_set(&req->poll_refs, 1);\n\tmask = vfs_poll(req->file, &ipt->pt) & poll->events;\n\n\tif (mask && (poll->events & EPOLLONESHOT)) {\n\t\tio_poll_remove_entries(req);\n\t\t/* no one else has access to the req, forget about the ref */\n\t\treturn mask;\n\t}\n\tif (!mask && unlikely(ipt->error || !ipt->nr_entries)) {\n\t\tio_poll_remove_entries(req);\n\t\tif (!ipt->error)\n\t\t\tipt->error = -EINVAL;\n\t\treturn 0;\n\t}\n\n\tspin_lock(&ctx->completion_lock);\n\tio_poll_req_insert(req);\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (mask) {\n\t\t/* can't multishot if failed, just queue the event we've got */\n\t\tif (unlikely(ipt->error || !ipt->nr_entries))\n\t\t\tpoll->events |= EPOLLONESHOT;\n\t\t__io_poll_execute(req, mask, poll->events);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release ownership. If someone tried to queue a tw while it was\n\t * locked, kick it off for them.\n\t */\n\tv = atomic_dec_return(&req->poll_refs);\n\tif (unlikely(v & IO_POLL_REF_MASK))\n\t\t__io_poll_execute(req, 0, poll->events);\n\treturn 0;\n}\n\nstatic void io_async_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\t\t       struct poll_table_struct *p)\n{\n\tstruct io_poll_table *pt = container_of(p, struct io_poll_table, pt);\n\tstruct async_poll *apoll = pt->req->apoll;\n\n\t__io_queue_proc(&apoll->poll, pt, head, &apoll->double_poll);\n}\n\nenum {\n\tIO_APOLL_OK,\n\tIO_APOLL_ABORTED,\n\tIO_APOLL_READY\n};\n\nstatic int io_arm_poll_handler(struct io_kiocb *req, unsigned issue_flags)\n{\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct async_poll *apoll;\n\tstruct io_poll_table ipt;\n\t__poll_t mask = EPOLLONESHOT | POLLERR | POLLPRI;\n\tint ret;\n\n\tif (!def->pollin && !def->pollout)\n\t\treturn IO_APOLL_ABORTED;\n\tif (!file_can_poll(req->file) || (req->flags & REQ_F_POLLED))\n\t\treturn IO_APOLL_ABORTED;\n\n\tif (def->pollin) {\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t\t/* If reading from MSG_ERRQUEUE using recvmsg, ignore POLLIN */\n\t\tif ((req->opcode == IORING_OP_RECVMSG) &&\n\t\t    (req->sr_msg.msg_flags & MSG_ERRQUEUE))\n\t\t\tmask &= ~POLLIN;\n\t} else {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\tif (def->poll_exclusive)\n\t\tmask |= EPOLLEXCLUSIVE;\n\tif (!(issue_flags & IO_URING_F_UNLOCKED) &&\n\t    !list_empty(&ctx->apoll_cache)) {\n\t\tapoll = list_first_entry(&ctx->apoll_cache, struct async_poll,\n\t\t\t\t\t\tpoll.wait.entry);\n\t\tlist_del_init(&apoll->poll.wait.entry);\n\t} else {\n\t\tapoll = kmalloc(sizeof(*apoll), GFP_ATOMIC);\n\t\tif (unlikely(!apoll))\n\t\t\treturn IO_APOLL_ABORTED;\n\t}\n\tapoll->double_poll = NULL;\n\treq->apoll = apoll;\n\treq->flags |= REQ_F_POLLED;\n\tipt.pt._qproc = io_async_queue_proc;\n\n\tio_kbuf_recycle(req, issue_flags);\n\n\tret = __io_arm_poll_handler(req, &apoll->poll, &ipt, mask);\n\tif (ret || ipt.error)\n\t\treturn ret ? IO_APOLL_READY : IO_APOLL_ABORTED;\n\n\ttrace_io_uring_poll_arm(ctx, req, req->user_data, req->opcode,\n\t\t\t\tmask, apoll->poll.events);\n\treturn IO_APOLL_OK;\n}\n\n/*\n * Returns true if we found and killed one or more poll requests\n */\nstatic __cold bool io_poll_remove_all(struct io_ring_ctx *ctx,\n\t\t\t\t      struct task_struct *tsk, bool cancel_all)\n{\n\tstruct hlist_node *tmp;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\tint i;\n\n\tspin_lock(&ctx->completion_lock);\n\tfor (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {\n\t\tstruct hlist_head *list;\n\n\t\tlist = &ctx->cancel_hash[i];\n\t\thlist_for_each_entry_safe(req, tmp, list, hash_node) {\n\t\t\tif (io_match_task_safe(req, tsk, cancel_all)) {\n\t\t\t\thlist_del_init(&req->hash_node);\n\t\t\t\tio_poll_cancel_req(req);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\treturn found;\n}\n\nstatic struct io_kiocb *io_poll_find(struct io_ring_ctx *ctx, __u64 sqe_addr,\n\t\t\t\t     bool poll_only)\n\t__must_hold(&ctx->completion_lock)\n{\n\tstruct hlist_head *list;\n\tstruct io_kiocb *req;\n\n\tlist = &ctx->cancel_hash[hash_long(sqe_addr, ctx->cancel_hash_bits)];\n\thlist_for_each_entry(req, list, hash_node) {\n\t\tif (sqe_addr != req->user_data)\n\t\t\tcontinue;\n\t\tif (poll_only && req->opcode != IORING_OP_POLL_ADD)\n\t\t\tcontinue;\n\t\treturn req;\n\t}\n\treturn NULL;\n}\n\nstatic bool io_poll_disarm(struct io_kiocb *req)\n\t__must_hold(&ctx->completion_lock)\n{\n\tif (!io_poll_get_ownership(req))\n\t\treturn false;\n\tio_poll_remove_entries(req);\n\thash_del(&req->hash_node);\n\treturn true;\n}\n\nstatic int io_poll_cancel(struct io_ring_ctx *ctx, __u64 sqe_addr,\n\t\t\t  bool poll_only)\n\t__must_hold(&ctx->completion_lock)\n{\n\tstruct io_kiocb *req = io_poll_find(ctx, sqe_addr, poll_only);\n\n\tif (!req)\n\t\treturn -ENOENT;\n\tio_poll_cancel_req(req);\n\treturn 0;\n}\n\nstatic __poll_t io_poll_parse_events(const struct io_uring_sqe *sqe,\n\t\t\t\t     unsigned int flags)\n{\n\tu32 events;\n\n\tevents = READ_ONCE(sqe->poll32_events);\n#ifdef __BIG_ENDIAN\n\tevents = swahw32(events);\n#endif\n\tif (!(flags & IORING_POLL_ADD_MULTI))\n\t\tevents |= EPOLLONESHOT;\n\treturn demangle_poll(events) | (events & (EPOLLEXCLUSIVE|EPOLLONESHOT));\n}\n\nstatic int io_poll_update_prep(struct io_kiocb *req,\n\t\t\t       const struct io_uring_sqe *sqe)\n{\n\tstruct io_poll_update *upd = &req->poll_update;\n\tu32 flags;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->len);\n\tif (flags & ~(IORING_POLL_UPDATE_EVENTS | IORING_POLL_UPDATE_USER_DATA |\n\t\t      IORING_POLL_ADD_MULTI))\n\t\treturn -EINVAL;\n\t/* meaningless without update */\n\tif (flags == IORING_POLL_ADD_MULTI)\n\t\treturn -EINVAL;\n\n\tupd->old_user_data = READ_ONCE(sqe->addr);\n\tupd->update_events = flags & IORING_POLL_UPDATE_EVENTS;\n\tupd->update_user_data = flags & IORING_POLL_UPDATE_USER_DATA;\n\n\tupd->new_user_data = READ_ONCE(sqe->off);\n\tif (!upd->update_user_data && upd->new_user_data)\n\t\treturn -EINVAL;\n\tif (upd->update_events)\n\t\tupd->events = io_poll_parse_events(sqe, flags);\n\telse if (sqe->poll32_events)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int io_poll_add_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_poll_iocb *poll = &req->poll;\n\tu32 flags;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->off || sqe->addr)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->len);\n\tif (flags & ~IORING_POLL_ADD_MULTI)\n\t\treturn -EINVAL;\n\tif ((flags & IORING_POLL_ADD_MULTI) && (req->flags & REQ_F_CQE_SKIP))\n\t\treturn -EINVAL;\n\n\tio_req_set_refcount(req);\n\treq->cflags = poll->events = io_poll_parse_events(sqe, flags);\n\treturn 0;\n}\n\nstatic int io_poll_add(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_poll_iocb *poll = &req->poll;\n\tstruct io_poll_table ipt;\n\tint ret;\n\n\tipt.pt._qproc = io_poll_queue_proc;\n\n\tret = __io_arm_poll_handler(req, &req->poll, &ipt, poll->events);\n\tret = ret ?: ipt.error;\n\tif (ret)\n\t\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_poll_update(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *preq;\n\tint ret2, ret = 0;\n\tbool locked;\n\n\tspin_lock(&ctx->completion_lock);\n\tpreq = io_poll_find(ctx, req->poll_update.old_user_data, true);\n\tif (!preq || !io_poll_disarm(preq)) {\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tret = preq ? -EALREADY : -ENOENT;\n\t\tgoto out;\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (req->poll_update.update_events || req->poll_update.update_user_data) {\n\t\t/* only mask one event flags, keep behavior flags */\n\t\tif (req->poll_update.update_events) {\n\t\t\tpreq->poll.events &= ~0xffff;\n\t\t\tpreq->poll.events |= req->poll_update.events & 0xffff;\n\t\t\tpreq->poll.events |= IO_POLL_UNMASK;\n\t\t}\n\t\tif (req->poll_update.update_user_data)\n\t\t\tpreq->user_data = req->poll_update.new_user_data;\n\n\t\tret2 = io_poll_add(preq, issue_flags);\n\t\t/* successfully updated, don't complete poll request */\n\t\tif (!ret2)\n\t\t\tgoto out;\n\t}\n\n\treq_set_fail(preq);\n\tpreq->result = -ECANCELED;\n\tlocked = !(issue_flags & IO_URING_F_UNLOCKED);\n\tio_req_task_complete(preq, &locked);\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t/* complete update request, we're done with it */\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic enum hrtimer_restart io_timeout_fn(struct hrtimer *timer)\n{\n\tstruct io_timeout_data *data = container_of(timer,\n\t\t\t\t\t\tstruct io_timeout_data, timer);\n\tstruct io_kiocb *req = data->req;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->timeout_lock, flags);\n\tlist_del_init(&req->timeout.list);\n\tatomic_set(&req->ctx->cq_timeouts,\n\t\tatomic_read(&req->ctx->cq_timeouts) + 1);\n\tspin_unlock_irqrestore(&ctx->timeout_lock, flags);\n\n\tif (!(data->flags & IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treq_set_fail(req);\n\n\treq->result = -ETIME;\n\treq->io_task_work.func = io_req_task_complete;\n\tio_req_task_work_add(req, false);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic struct io_kiocb *io_timeout_extract(struct io_ring_ctx *ctx,\n\t\t\t\t\t   __u64 user_data)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\n\tlist_for_each_entry(req, &ctx->timeout_list, timeout.list) {\n\t\tfound = user_data == req->user_data;\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tio = req->async_data;\n\tif (hrtimer_try_to_cancel(&io->timer) == -1)\n\t\treturn ERR_PTR(-EALREADY);\n\tlist_del_init(&req->timeout.list);\n\treturn req;\n}\n\nstatic int io_timeout_cancel(struct io_ring_ctx *ctx, __u64 user_data)\n\t__must_hold(&ctx->completion_lock)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_kiocb *req = io_timeout_extract(ctx, user_data);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\tio_req_task_queue_fail(req, -ECANCELED);\n\treturn 0;\n}\n\nstatic clockid_t io_timeout_get_clock(struct io_timeout_data *data)\n{\n\tswitch (data->flags & IORING_TIMEOUT_CLOCK_MASK) {\n\tcase IORING_TIMEOUT_BOOTTIME:\n\t\treturn CLOCK_BOOTTIME;\n\tcase IORING_TIMEOUT_REALTIME:\n\t\treturn CLOCK_REALTIME;\n\tdefault:\n\t\t/* can't happen, vetted at prep time */\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase 0:\n\t\treturn CLOCK_MONOTONIC;\n\t}\n}\n\nstatic int io_linked_timeout_update(struct io_ring_ctx *ctx, __u64 user_data,\n\t\t\t\t    struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\n\tlist_for_each_entry(req, &ctx->ltimeout_list, timeout.list) {\n\t\tfound = user_data == req->user_data;\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\tio = req->async_data;\n\tif (hrtimer_try_to_cancel(&io->timer) == -1)\n\t\treturn -EALREADY;\n\thrtimer_init(&io->timer, io_timeout_get_clock(io), mode);\n\tio->timer.function = io_link_timeout_fn;\n\thrtimer_start(&io->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;\n}\n\nstatic int io_timeout_update(struct io_ring_ctx *ctx, __u64 user_data,\n\t\t\t     struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_kiocb *req = io_timeout_extract(ctx, user_data);\n\tstruct io_timeout_data *data;\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->timeout.off = 0; /* noseq */\n\tdata = req->async_data;\n\tlist_add_tail(&req->timeout.list, &ctx->timeout_list);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), mode);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;\n}\n\nstatic int io_timeout_remove_prep(struct io_kiocb *req,\n\t\t\t\t  const struct io_uring_sqe *sqe)\n{\n\tstruct io_timeout_rem *tr = &req->timeout_rem;\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\ttr->ltimeout = false;\n\ttr->addr = READ_ONCE(sqe->addr);\n\ttr->flags = READ_ONCE(sqe->timeout_flags);\n\tif (tr->flags & IORING_TIMEOUT_UPDATE_MASK) {\n\t\tif (hweight32(tr->flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\t\treturn -EINVAL;\n\t\tif (tr->flags & IORING_LINK_TIMEOUT_UPDATE)\n\t\t\ttr->ltimeout = true;\n\t\tif (tr->flags & ~(IORING_TIMEOUT_UPDATE_MASK|IORING_TIMEOUT_ABS))\n\t\t\treturn -EINVAL;\n\t\tif (get_timespec64(&tr->ts, u64_to_user_ptr(sqe->addr2)))\n\t\t\treturn -EFAULT;\n\t\tif (tr->ts.tv_sec < 0 || tr->ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\t} else if (tr->flags) {\n\t\t/* timeout removal doesn't support flags */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline enum hrtimer_mode io_translate_timeout_mode(unsigned int flags)\n{\n\treturn (flags & IORING_TIMEOUT_ABS) ? HRTIMER_MODE_ABS\n\t\t\t\t\t    : HRTIMER_MODE_REL;\n}\n\n/*\n * Remove or update an existing timeout command\n */\nstatic int io_timeout_remove(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_timeout_rem *tr = &req->timeout_rem;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tif (!(req->timeout_rem.flags & IORING_TIMEOUT_UPDATE)) {\n\t\tspin_lock(&ctx->completion_lock);\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tret = io_timeout_cancel(ctx, tr->addr);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t\tspin_unlock(&ctx->completion_lock);\n\t} else {\n\t\tenum hrtimer_mode mode = io_translate_timeout_mode(tr->flags);\n\n\t\tspin_lock_irq(&ctx->timeout_lock);\n\t\tif (tr->ltimeout)\n\t\t\tret = io_linked_timeout_update(ctx, tr->addr, &tr->ts, mode);\n\t\telse\n\t\t\tret = io_timeout_update(ctx, tr->addr, &tr->ts, mode);\n\t\tspin_unlock_irq(&ctx->timeout_lock);\n\t}\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete_post(req, ret, 0);\n\treturn 0;\n}\n\nstatic int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\t/* more than one clock specified is invalid, obviously */\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;\n}\n\nstatic int io_timeout(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_timeout_data *data = req->async_data;\n\tstruct list_head *entry;\n\tu32 tail, off = req->timeout.off;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\n\t/*\n\t * sqe->off holds how many events that need to occur for this\n\t * timeout event to be satisfied. If it isn't set, then this is\n\t * a pure timeout request, sequence isn't used.\n\t */\n\tif (io_is_timeout_noseq(req)) {\n\t\tentry = ctx->timeout_list.prev;\n\t\tgoto add;\n\t}\n\n\ttail = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\treq->timeout.target_seq = tail + off;\n\n\t/* Update the last seq here in case io_flush_timeouts() hasn't.\n\t * This is safe because ->completion_lock is held, and submissions\n\t * and completions are never mixed in the same ->completion_lock section.\n\t */\n\tctx->cq_last_tm_flush = tail;\n\n\t/*\n\t * Insertion sort, ensuring the first entry in the list is always\n\t * the one we need first.\n\t */\n\tlist_for_each_prev(entry, &ctx->timeout_list) {\n\t\tstruct io_kiocb *nxt = list_entry(entry, struct io_kiocb,\n\t\t\t\t\t\t  timeout.list);\n\n\t\tif (io_is_timeout_noseq(nxt))\n\t\t\tcontinue;\n\t\t/* nxt.seq is behind @tail, otherwise would've been completed */\n\t\tif (off >= nxt->timeout.target_seq - tail)\n\t\t\tbreak;\n\t}\nadd:\n\tlist_add(&req->timeout.list, entry);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(data->ts), data->mode);\n\tspin_unlock_irq(&ctx->timeout_lock);\n\treturn 0;\n}\n\nstruct io_cancel_data {\n\tstruct io_ring_ctx *ctx;\n\tu64 user_data;\n};\n\nstatic bool io_cancel_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tstruct io_cancel_data *cd = data;\n\n\treturn req->ctx == cd->ctx && req->user_data == cd->user_data;\n}\n\nstatic int io_async_cancel_one(struct io_uring_task *tctx, u64 user_data,\n\t\t\t       struct io_ring_ctx *ctx)\n{\n\tstruct io_cancel_data data = { .ctx = ctx, .user_data = user_data, };\n\tenum io_wq_cancel cancel_ret;\n\tint ret = 0;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -ENOENT;\n\n\tcancel_ret = io_wq_cancel_cb(tctx->io_wq, io_cancel_cb, &data, false);\n\tswitch (cancel_ret) {\n\tcase IO_WQ_CANCEL_OK:\n\t\tret = 0;\n\t\tbreak;\n\tcase IO_WQ_CANCEL_RUNNING:\n\t\tret = -EALREADY;\n\t\tbreak;\n\tcase IO_WQ_CANCEL_NOTFOUND:\n\t\tret = -ENOENT;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int io_try_cancel_userdata(struct io_kiocb *req, u64 sqe_addr)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tWARN_ON_ONCE(!io_wq_current_is_worker() && req->task != current);\n\n\tret = io_async_cancel_one(req->task->io_uring, sqe_addr, ctx);\n\t/*\n\t * Fall-through even for -EALREADY, as we may have poll armed\n\t * that need unarming.\n\t */\n\tif (!ret)\n\t\treturn 0;\n\n\tspin_lock(&ctx->completion_lock);\n\tret = io_poll_cancel(ctx, sqe_addr, false);\n\tif (ret != -ENOENT)\n\t\tgoto out;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\tret = io_timeout_cancel(ctx, sqe_addr);\n\tspin_unlock_irq(&ctx->timeout_lock);\nout:\n\tspin_unlock(&ctx->completion_lock);\n\treturn ret;\n}\n\nstatic int io_async_cancel_prep(struct io_kiocb *req,\n\t\t\t\tconst struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->off || sqe->len || sqe->cancel_flags ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\treq->cancel.addr = READ_ONCE(sqe->addr);\n\treturn 0;\n}\n\nstatic int io_async_cancel(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tu64 sqe_addr = req->cancel.addr;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\tret = io_try_cancel_userdata(req, sqe_addr);\n\tif (ret != -ENOENT)\n\t\tgoto done;\n\n\t/* slow path, try all io-wq's */\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = -ENOENT;\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\tret = io_async_cancel_one(tctx, req->cancel.addr, ctx);\n\t\tif (ret != -ENOENT)\n\t\t\tbreak;\n\t}\n\tio_ring_submit_unlock(ctx, needs_lock);\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_complete_post(req, ret, 0);\n\treturn 0;\n}\n\nstatic int io_rsrc_update_prep(struct io_kiocb *req,\n\t\t\t\tconst struct io_uring_sqe *sqe)\n{\n\tif (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\treq->rsrc_update.offset = READ_ONCE(sqe->off);\n\treq->rsrc_update.nr_args = READ_ONCE(sqe->len);\n\tif (!req->rsrc_update.nr_args)\n\t\treturn -EINVAL;\n\treq->rsrc_update.arg = READ_ONCE(sqe->addr);\n\treturn 0;\n}\n\nstatic int io_files_update(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_uring_rsrc_update2 up;\n\tint ret;\n\n\tup.offset = req->rsrc_update.offset;\n\tup.data = req->rsrc_update.arg;\n\tup.nr = 0;\n\tup.tags = 0;\n\tup.resv = 0;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = __io_register_rsrc_update(ctx, IORING_RSRC_FILE,\n\t\t\t\t\t&up, req->rsrc_update.nr_args);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t__io_req_complete(req, issue_flags, ret, 0);\n\treturn 0;\n}\n\nstatic int io_req_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\treturn 0;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\tcase IORING_OP_READ:\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\tcase IORING_OP_WRITE:\n\t\treturn io_prep_rw(req, sqe);\n\tcase IORING_OP_POLL_ADD:\n\t\treturn io_poll_add_prep(req, sqe);\n\tcase IORING_OP_POLL_REMOVE:\n\t\treturn io_poll_update_prep(req, sqe);\n\tcase IORING_OP_FSYNC:\n\t\treturn io_fsync_prep(req, sqe);\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\treturn io_sfr_prep(req, sqe);\n\tcase IORING_OP_SENDMSG:\n\tcase IORING_OP_SEND:\n\t\treturn io_sendmsg_prep(req, sqe);\n\tcase IORING_OP_RECVMSG:\n\tcase IORING_OP_RECV:\n\t\treturn io_recvmsg_prep(req, sqe);\n\tcase IORING_OP_CONNECT:\n\t\treturn io_connect_prep(req, sqe);\n\tcase IORING_OP_TIMEOUT:\n\t\treturn io_timeout_prep(req, sqe, false);\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\treturn io_timeout_remove_prep(req, sqe);\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\treturn io_async_cancel_prep(req, sqe);\n\tcase IORING_OP_LINK_TIMEOUT:\n\t\treturn io_timeout_prep(req, sqe, true);\n\tcase IORING_OP_ACCEPT:\n\t\treturn io_accept_prep(req, sqe);\n\tcase IORING_OP_FALLOCATE:\n\t\treturn io_fallocate_prep(req, sqe);\n\tcase IORING_OP_OPENAT:\n\t\treturn io_openat_prep(req, sqe);\n\tcase IORING_OP_CLOSE:\n\t\treturn io_close_prep(req, sqe);\n\tcase IORING_OP_FILES_UPDATE:\n\t\treturn io_rsrc_update_prep(req, sqe);\n\tcase IORING_OP_STATX:\n\t\treturn io_statx_prep(req, sqe);\n\tcase IORING_OP_FADVISE:\n\t\treturn io_fadvise_prep(req, sqe);\n\tcase IORING_OP_MADVISE:\n\t\treturn io_madvise_prep(req, sqe);\n\tcase IORING_OP_OPENAT2:\n\t\treturn io_openat2_prep(req, sqe);\n\tcase IORING_OP_EPOLL_CTL:\n\t\treturn io_epoll_ctl_prep(req, sqe);\n\tcase IORING_OP_SPLICE:\n\t\treturn io_splice_prep(req, sqe);\n\tcase IORING_OP_PROVIDE_BUFFERS:\n\t\treturn io_provide_buffers_prep(req, sqe);\n\tcase IORING_OP_REMOVE_BUFFERS:\n\t\treturn io_remove_buffers_prep(req, sqe);\n\tcase IORING_OP_TEE:\n\t\treturn io_tee_prep(req, sqe);\n\tcase IORING_OP_SHUTDOWN:\n\t\treturn io_shutdown_prep(req, sqe);\n\tcase IORING_OP_RENAMEAT:\n\t\treturn io_renameat_prep(req, sqe);\n\tcase IORING_OP_UNLINKAT:\n\t\treturn io_unlinkat_prep(req, sqe);\n\tcase IORING_OP_MKDIRAT:\n\t\treturn io_mkdirat_prep(req, sqe);\n\tcase IORING_OP_SYMLINKAT:\n\t\treturn io_symlinkat_prep(req, sqe);\n\tcase IORING_OP_LINKAT:\n\t\treturn io_linkat_prep(req, sqe);\n\tcase IORING_OP_MSG_RING:\n\t\treturn io_msg_ring_prep(req, sqe);\n\t}\n\n\tprintk_once(KERN_WARNING \"io_uring: unhandled opcode %d\\n\",\n\t\t\treq->opcode);\n\treturn -EINVAL;\n}\n\nstatic int io_req_prep_async(struct io_kiocb *req)\n{\n\tif (!io_op_defs[req->opcode].needs_async_setup)\n\t\treturn 0;\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -EAGAIN;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_READV:\n\t\treturn io_rw_prep_async(req, READ);\n\tcase IORING_OP_WRITEV:\n\t\treturn io_rw_prep_async(req, WRITE);\n\tcase IORING_OP_SENDMSG:\n\t\treturn io_sendmsg_prep_async(req);\n\tcase IORING_OP_RECVMSG:\n\t\treturn io_recvmsg_prep_async(req);\n\tcase IORING_OP_CONNECT:\n\t\treturn io_connect_prep_async(req);\n\t}\n\tprintk_once(KERN_WARNING \"io_uring: prep_async() bad opcode %d\\n\",\n\t\t    req->opcode);\n\treturn -EFAULT;\n}\n\nstatic u32 io_get_sequence(struct io_kiocb *req)\n{\n\tu32 seq = req->ctx->cached_sq_head;\n\n\t/* need original cached_sq_head, but it was increased for each req */\n\tio_for_each_link(req, req)\n\t\tseq--;\n\treturn seq;\n}\n\nstatic __cold void io_drain_req(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_defer_entry *de;\n\tint ret;\n\tu32 seq = io_get_sequence(req);\n\n\t/* Still need defer if there is pending req in defer list. */\n\tspin_lock(&ctx->completion_lock);\n\tif (!req_need_defer(req, seq) && list_empty_careful(&ctx->defer_list)) {\n\t\tspin_unlock(&ctx->completion_lock);\nqueue:\n\t\tctx->drain_active = false;\n\t\tio_req_task_queue(req);\n\t\treturn;\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\n\tret = io_req_prep_async(req);\n\tif (ret) {\nfail:\n\t\tio_req_complete_failed(req, ret);\n\t\treturn;\n\t}\n\tio_prep_async_link(req);\n\tde = kmalloc(sizeof(*de), GFP_KERNEL);\n\tif (!de) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&ctx->completion_lock);\n\tif (!req_need_defer(req, seq) && list_empty(&ctx->defer_list)) {\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tkfree(de);\n\t\tgoto queue;\n\t}\n\n\ttrace_io_uring_defer(ctx, req, req->user_data, req->opcode);\n\tde->req = req;\n\tde->seq = seq;\n\tlist_add_tail(&de->list, &ctx->defer_list);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic void io_clean_op(struct io_kiocb *req)\n{\n\tif (req->flags & REQ_F_BUFFER_SELECTED) {\n\t\tspin_lock(&req->ctx->completion_lock);\n\t\tio_put_kbuf_comp(req);\n\t\tspin_unlock(&req->ctx->completion_lock);\n\t}\n\n\tif (req->flags & REQ_F_NEED_CLEANUP) {\n\t\tswitch (req->opcode) {\n\t\tcase IORING_OP_READV:\n\t\tcase IORING_OP_READ_FIXED:\n\t\tcase IORING_OP_READ:\n\t\tcase IORING_OP_WRITEV:\n\t\tcase IORING_OP_WRITE_FIXED:\n\t\tcase IORING_OP_WRITE: {\n\t\t\tstruct io_async_rw *io = req->async_data;\n\n\t\t\tkfree(io->free_iovec);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IORING_OP_RECVMSG:\n\t\tcase IORING_OP_SENDMSG: {\n\t\t\tstruct io_async_msghdr *io = req->async_data;\n\n\t\t\tkfree(io->free_iov);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IORING_OP_OPENAT:\n\t\tcase IORING_OP_OPENAT2:\n\t\t\tif (req->open.filename)\n\t\t\t\tputname(req->open.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_RENAMEAT:\n\t\t\tputname(req->rename.oldpath);\n\t\t\tputname(req->rename.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_UNLINKAT:\n\t\t\tputname(req->unlink.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_MKDIRAT:\n\t\t\tputname(req->mkdir.filename);\n\t\t\tbreak;\n\t\tcase IORING_OP_SYMLINKAT:\n\t\t\tputname(req->symlink.oldpath);\n\t\t\tputname(req->symlink.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_LINKAT:\n\t\t\tputname(req->hardlink.oldpath);\n\t\t\tputname(req->hardlink.newpath);\n\t\t\tbreak;\n\t\tcase IORING_OP_STATX:\n\t\t\tif (req->statx.filename)\n\t\t\t\tputname(req->statx.filename);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((req->flags & REQ_F_POLLED) && req->apoll) {\n\t\tkfree(req->apoll->double_poll);\n\t\tkfree(req->apoll);\n\t\treq->apoll = NULL;\n\t}\n\tif (req->flags & REQ_F_CREDS)\n\t\tput_cred(req->creds);\n\tif (req->flags & REQ_F_ASYNC_DATA) {\n\t\tkfree(req->async_data);\n\t\treq->async_data = NULL;\n\t}\n\treq->flags &= ~IO_REQ_CLEAN_FLAGS;\n}\n\nstatic bool io_assign_file(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tif (req->file || !io_op_defs[req->opcode].needs_file)\n\t\treturn true;\n\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treq->file = io_file_get_fixed(req, req->work.fd, issue_flags);\n\telse\n\t\treq->file = io_file_get_normal(req, req->work.fd);\n\tif (req->file)\n\t\treturn true;\n\n\treq_set_fail(req);\n\treq->result = -EBADF;\n\treturn false;\n}\n\nstatic int io_issue_sqe(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tconst struct cred *creds = NULL;\n\tint ret;\n\n\tif (unlikely((req->flags & REQ_F_CREDS) && req->creds != current_cred()))\n\t\tcreds = override_creds(req->creds);\n\n\tif (!io_op_defs[req->opcode].audit_skip)\n\t\taudit_uring_entry(req->opcode);\n\tif (unlikely(!io_assign_file(req, issue_flags)))\n\t\treturn -EBADF;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\tret = io_nop(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\tcase IORING_OP_READ:\n\t\tret = io_read(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\tcase IORING_OP_WRITE:\n\t\tret = io_write(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FSYNC:\n\t\tret = io_fsync(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_POLL_ADD:\n\t\tret = io_poll_add(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_POLL_REMOVE:\n\t\tret = io_poll_update(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\tret = io_sync_file_range(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SENDMSG:\n\t\tret = io_sendmsg(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SEND:\n\t\tret = io_send(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RECVMSG:\n\t\tret = io_recvmsg(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RECV:\n\t\tret = io_recv(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT:\n\t\tret = io_timeout(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\tret = io_timeout_remove(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_ACCEPT:\n\t\tret = io_accept(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_CONNECT:\n\t\tret = io_connect(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\tret = io_async_cancel(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FALLOCATE:\n\t\tret = io_fallocate(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_OPENAT:\n\t\tret = io_openat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_CLOSE:\n\t\tret = io_close(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FILES_UPDATE:\n\t\tret = io_files_update(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_STATX:\n\t\tret = io_statx(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_FADVISE:\n\t\tret = io_fadvise(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MADVISE:\n\t\tret = io_madvise(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_OPENAT2:\n\t\tret = io_openat2(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_EPOLL_CTL:\n\t\tret = io_epoll_ctl(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SPLICE:\n\t\tret = io_splice(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_PROVIDE_BUFFERS:\n\t\tret = io_provide_buffers(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_REMOVE_BUFFERS:\n\t\tret = io_remove_buffers(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_TEE:\n\t\tret = io_tee(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SHUTDOWN:\n\t\tret = io_shutdown(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_RENAMEAT:\n\t\tret = io_renameat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_UNLINKAT:\n\t\tret = io_unlinkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MKDIRAT:\n\t\tret = io_mkdirat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_SYMLINKAT:\n\t\tret = io_symlinkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_LINKAT:\n\t\tret = io_linkat(req, issue_flags);\n\t\tbreak;\n\tcase IORING_OP_MSG_RING:\n\t\tret = io_msg_ring(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!io_op_defs[req->opcode].audit_skip)\n\t\taudit_uring_exit(!ret, ret);\n\n\tif (creds)\n\t\trevert_creds(creds);\n\tif (ret)\n\t\treturn ret;\n\t/* If the op doesn't have a file, we're not polling for it */\n\tif ((req->ctx->flags & IORING_SETUP_IOPOLL) && req->file)\n\t\tio_iopoll_req_issued(req, issue_flags);\n\n\treturn 0;\n}\n\nstatic struct io_wq_work *io_wq_free_work(struct io_wq_work *work)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\n\treq = io_put_req_find_next(req);\n\treturn req ? &req->work : NULL;\n}\n\nstatic void io_wq_submit_work(struct io_wq_work *work)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n\tunsigned int issue_flags = IO_URING_F_UNLOCKED;\n\tbool needs_poll = false;\n\tstruct io_kiocb *timeout;\n\tint ret = 0, err = -ECANCELED;\n\n\t/* one will be dropped by ->io_free_work() after returning to io-wq */\n\tif (!(req->flags & REQ_F_REFCOUNT))\n\t\t__io_req_set_refcount(req, 2);\n\telse\n\t\treq_ref_get(req);\n\n\ttimeout = io_prep_linked_timeout(req);\n\tif (timeout)\n\t\tio_queue_linked_timeout(timeout);\n\n\tif (!io_assign_file(req, issue_flags)) {\n\t\terr = -EBADF;\n\t\twork->flags |= IO_WQ_WORK_CANCEL;\n\t}\n\n\t/* either cancelled or io-wq is dying, so don't touch tctx->iowq */\n\tif (work->flags & IO_WQ_WORK_CANCEL) {\n\t\tio_req_task_queue_fail(req, err);\n\t\treturn;\n\t}\n\n\tif (req->flags & REQ_F_FORCE_ASYNC) {\n\t\tbool opcode_poll = def->pollin || def->pollout;\n\n\t\tif (opcode_poll && file_can_poll(req->file)) {\n\t\t\tneeds_poll = true;\n\t\t\tissue_flags |= IO_URING_F_NONBLOCK;\n\t\t}\n\t}\n\n\tdo {\n\t\tret = io_issue_sqe(req, issue_flags);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\t/*\n\t\t * We can get EAGAIN for iopolled IO even though we're\n\t\t * forcing a sync submission from here, since we can't\n\t\t * wait for request slots on the block side.\n\t\t */\n\t\tif (!needs_poll) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (io_arm_poll_handler(req, issue_flags) == IO_APOLL_OK)\n\t\t\treturn;\n\t\t/* aborted or ready, in either case retry blocking */\n\t\tneeds_poll = false;\n\t\tissue_flags &= ~IO_URING_F_NONBLOCK;\n\t} while (1);\n\n\t/* avoid locking problems by failing it from a clean context */\n\tif (ret)\n\t\tio_req_task_queue_fail(req, ret);\n}\n\nstatic inline struct io_fixed_file *io_fixed_file_slot(struct io_file_table *table,\n\t\t\t\t\t\t       unsigned i)\n{\n\treturn &table->files[i];\n}\n\nstatic inline struct file *io_file_from_index(struct io_ring_ctx *ctx,\n\t\t\t\t\t      int index)\n{\n\tstruct io_fixed_file *slot = io_fixed_file_slot(&ctx->file_table, index);\n\n\treturn (struct file *) (slot->file_ptr & FFS_MASK);\n}\n\nstatic void io_fixed_file_set(struct io_fixed_file *file_slot, struct file *file)\n{\n\tunsigned long file_ptr = (unsigned long) file;\n\n\tfile_ptr |= io_file_get_flags(file);\n\tfile_slot->file_ptr = file_ptr;\n}\n\nstatic inline struct file *io_file_get_fixed(struct io_kiocb *req, int fd,\n\t\t\t\t\t     unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = NULL;\n\tunsigned long file_ptr;\n\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_lock(&ctx->uring_lock);\n\n\tif (unlikely((unsigned int)fd >= ctx->nr_user_files))\n\t\tgoto out;\n\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\tfile = (struct file *) (file_ptr & FFS_MASK);\n\tfile_ptr &= ~FFS_MASK;\n\t/* mask in overlapping REQ_F and FFS bits */\n\treq->flags |= (file_ptr << REQ_F_SUPPORT_NOWAIT_BIT);\n\tio_req_set_rsrc_node(req, ctx, 0);\nout:\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n\treturn file;\n}\n\n/*\n * Drop the file for requeue operations. Only used of req->file is the\n * io_uring descriptor itself.\n */\nstatic void io_drop_inflight_file(struct io_kiocb *req)\n{\n\tif (unlikely(req->flags & REQ_F_INFLIGHT)) {\n\t\tfput(req->file);\n\t\treq->file = NULL;\n\t\treq->flags &= ~REQ_F_INFLIGHT;\n\t}\n}\n\nstatic struct file *io_file_get_normal(struct io_kiocb *req, int fd)\n{\n\tstruct file *file = fget(fd);\n\n\ttrace_io_uring_file_get(req->ctx, req, req->user_data, fd);\n\n\t/* we don't allow fixed io_uring files */\n\tif (file && file->f_op == &io_uring_fops)\n\t\treq->flags |= REQ_F_INFLIGHT;\n\treturn file;\n}\n\nstatic void io_req_task_link_timeout(struct io_kiocb *req, bool *locked)\n{\n\tstruct io_kiocb *prev = req->timeout.prev;\n\tint ret = -ENOENT;\n\n\tif (prev) {\n\t\tif (!(req->task->flags & PF_EXITING))\n\t\t\tret = io_try_cancel_userdata(req, prev->user_data);\n\t\tio_req_complete_post(req, ret ?: -ETIME, 0);\n\t\tio_put_req(prev);\n\t} else {\n\t\tio_req_complete_post(req, -ETIME, 0);\n\t}\n}\n\nstatic enum hrtimer_restart io_link_timeout_fn(struct hrtimer *timer)\n{\n\tstruct io_timeout_data *data = container_of(timer,\n\t\t\t\t\t\tstruct io_timeout_data, timer);\n\tstruct io_kiocb *prev, *req = data->req;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->timeout_lock, flags);\n\tprev = req->timeout.head;\n\treq->timeout.head = NULL;\n\n\t/*\n\t * We don't expect the list to be empty, that will only happen if we\n\t * race with the completion of the linked work.\n\t */\n\tif (prev) {\n\t\tio_remove_next_linked(prev);\n\t\tif (!req_ref_inc_not_zero(prev))\n\t\t\tprev = NULL;\n\t}\n\tlist_del(&req->timeout.list);\n\treq->timeout.prev = prev;\n\tspin_unlock_irqrestore(&ctx->timeout_lock, flags);\n\n\treq->io_task_work.func = io_req_task_link_timeout;\n\tio_req_task_work_add(req, false);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void io_queue_linked_timeout(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\t/*\n\t * If the back reference is NULL, then our linked request finished\n\t * before we got a chance to setup the timer\n\t */\n\tif (req->timeout.head) {\n\t\tstruct io_timeout_data *data = req->async_data;\n\n\t\tdata->timer.function = io_link_timeout_fn;\n\t\thrtimer_start(&data->timer, timespec64_to_ktime(data->ts),\n\t\t\t\tdata->mode);\n\t\tlist_add_tail(&req->timeout.list, &ctx->ltimeout_list);\n\t}\n\tspin_unlock_irq(&ctx->timeout_lock);\n\t/* drop submission reference */\n\tio_put_req(req);\n}\n\nstatic void io_queue_sqe_arm_apoll(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tstruct io_kiocb *linked_timeout = io_prep_linked_timeout(req);\n\n\tswitch (io_arm_poll_handler(req, 0)) {\n\tcase IO_APOLL_READY:\n\t\tio_req_task_queue(req);\n\t\tbreak;\n\tcase IO_APOLL_ABORTED:\n\t\t/*\n\t\t * Queued up for async execution, worker will release\n\t\t * submit reference when the iocb is actually submitted.\n\t\t */\n\t\tio_queue_async_work(req, NULL);\n\t\tbreak;\n\tcase IO_APOLL_OK:\n\t\tbreak;\n\t}\n\n\tif (linked_timeout)\n\t\tio_queue_linked_timeout(linked_timeout);\n}\n\nstatic inline void __io_queue_sqe(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tstruct io_kiocb *linked_timeout;\n\tint ret;\n\n\tret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);\n\n\tif (req->flags & REQ_F_COMPLETE_INLINE) {\n\t\tio_req_add_compl_list(req);\n\t\treturn;\n\t}\n\t/*\n\t * We async punt it if the file wasn't marked NOWAIT, or if the file\n\t * doesn't support non-blocking read/write attempts\n\t */\n\tif (likely(!ret)) {\n\t\tlinked_timeout = io_prep_linked_timeout(req);\n\t\tif (linked_timeout)\n\t\t\tio_queue_linked_timeout(linked_timeout);\n\t} else if (ret == -EAGAIN && !(req->flags & REQ_F_NOWAIT)) {\n\t\tio_queue_sqe_arm_apoll(req);\n\t} else {\n\t\tio_req_complete_failed(req, ret);\n\t}\n}\n\nstatic void io_queue_sqe_fallback(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tif (req->flags & REQ_F_FAIL) {\n\t\tio_req_complete_fail_submit(req);\n\t} else if (unlikely(req->ctx->drain_active)) {\n\t\tio_drain_req(req);\n\t} else {\n\t\tint ret = io_req_prep_async(req);\n\n\t\tif (unlikely(ret))\n\t\t\tio_req_complete_failed(req, ret);\n\t\telse\n\t\t\tio_queue_async_work(req, NULL);\n\t}\n}\n\nstatic inline void io_queue_sqe(struct io_kiocb *req)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tif (likely(!(req->flags & (REQ_F_FORCE_ASYNC | REQ_F_FAIL))))\n\t\t__io_queue_sqe(req);\n\telse\n\t\tio_queue_sqe_fallback(req);\n}\n\n/*\n * Check SQE restrictions (opcode and flags).\n *\n * Returns 'true' if SQE is allowed, 'false' otherwise.\n */\nstatic inline bool io_check_restriction(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct io_kiocb *req,\n\t\t\t\t\tunsigned int sqe_flags)\n{\n\tif (!test_bit(req->opcode, ctx->restrictions.sqe_op))\n\t\treturn false;\n\n\tif ((sqe_flags & ctx->restrictions.sqe_flags_required) !=\n\t    ctx->restrictions.sqe_flags_required)\n\t\treturn false;\n\n\tif (sqe_flags & ~(ctx->restrictions.sqe_flags_allowed |\n\t\t\t  ctx->restrictions.sqe_flags_required))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void io_init_req_drain(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *head = ctx->submit_state.link.head;\n\n\tctx->drain_active = true;\n\tif (head) {\n\t\t/*\n\t\t * If we need to drain a request in the middle of a link, drain\n\t\t * the head request and the next request/link after the current\n\t\t * link. Considering sequential execution of links,\n\t\t * REQ_F_IO_DRAIN will be maintained for every request of our\n\t\t * link.\n\t\t */\n\t\thead->flags |= REQ_F_IO_DRAIN | REQ_F_FORCE_ASYNC;\n\t\tctx->drain_next = true;\n\t}\n}\n\nstatic int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,\n\t\t       const struct io_uring_sqe *sqe)\n\t__must_hold(&ctx->uring_lock)\n{\n\tunsigned int sqe_flags;\n\tint personality;\n\tu8 opcode;\n\n\t/* req is partially pre-initialised, see io_preinit_req() */\n\treq->opcode = opcode = READ_ONCE(sqe->opcode);\n\t/* same numerical values with corresponding REQ_F_*, safe to copy */\n\treq->flags = sqe_flags = READ_ONCE(sqe->flags);\n\treq->user_data = READ_ONCE(sqe->user_data);\n\treq->file = NULL;\n\treq->fixed_rsrc_refs = NULL;\n\treq->task = current;\n\n\tif (unlikely(opcode >= IORING_OP_LAST)) {\n\t\treq->opcode = 0;\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(sqe_flags & ~SQE_COMMON_FLAGS)) {\n\t\t/* enforce forwards compatibility on users */\n\t\tif (sqe_flags & ~SQE_VALID_FLAGS)\n\t\t\treturn -EINVAL;\n\t\tif ((sqe_flags & IOSQE_BUFFER_SELECT) &&\n\t\t    !io_op_defs[opcode].buffer_select)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (sqe_flags & IOSQE_CQE_SKIP_SUCCESS)\n\t\t\tctx->drain_disabled = true;\n\t\tif (sqe_flags & IOSQE_IO_DRAIN) {\n\t\t\tif (ctx->drain_disabled)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tio_init_req_drain(req);\n\t\t}\n\t}\n\tif (unlikely(ctx->restricted || ctx->drain_active || ctx->drain_next)) {\n\t\tif (ctx->restricted && !io_check_restriction(ctx, req, sqe_flags))\n\t\t\treturn -EACCES;\n\t\t/* knock it to the slow queue path, will be drained there */\n\t\tif (ctx->drain_active)\n\t\t\treq->flags |= REQ_F_FORCE_ASYNC;\n\t\t/* if there is no link, we're at \"next\" request and need to drain */\n\t\tif (unlikely(ctx->drain_next) && !ctx->submit_state.link.head) {\n\t\t\tctx->drain_next = false;\n\t\t\tctx->drain_active = true;\n\t\t\treq->flags |= REQ_F_IO_DRAIN | REQ_F_FORCE_ASYNC;\n\t\t}\n\t}\n\n\tif (io_op_defs[opcode].needs_file) {\n\t\tstruct io_submit_state *state = &ctx->submit_state;\n\n\t\treq->work.fd = READ_ONCE(sqe->fd);\n\n\t\t/*\n\t\t * Plug now if we have more than 2 IO left after this, and the\n\t\t * target is potentially a read/write to block based storage.\n\t\t */\n\t\tif (state->need_plug && io_op_defs[opcode].plug) {\n\t\t\tstate->plug_started = true;\n\t\t\tstate->need_plug = false;\n\t\t\tblk_start_plug_nr_ios(&state->plug, state->submit_nr);\n\t\t}\n\t}\n\n\tpersonality = READ_ONCE(sqe->personality);\n\tif (personality) {\n\t\tint ret;\n\n\t\treq->creds = xa_load(&ctx->personalities, personality);\n\t\tif (!req->creds)\n\t\t\treturn -EINVAL;\n\t\tget_cred(req->creds);\n\t\tret = security_uring_override_creds(req->creds);\n\t\tif (ret) {\n\t\t\tput_cred(req->creds);\n\t\t\treturn ret;\n\t\t}\n\t\treq->flags |= REQ_F_CREDS;\n\t}\n\n\treturn io_req_prep(req, sqe);\n}\n\nstatic int io_submit_sqe(struct io_ring_ctx *ctx, struct io_kiocb *req,\n\t\t\t const struct io_uring_sqe *sqe)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_submit_link *link = &ctx->submit_state.link;\n\tint ret;\n\n\tret = io_init_req(ctx, req, sqe);\n\tif (unlikely(ret)) {\n\t\ttrace_io_uring_req_failed(sqe, ctx, req, ret);\n\n\t\t/* fail even hard links since we don't submit */\n\t\tif (link->head) {\n\t\t\t/*\n\t\t\t * we can judge a link req is failed or cancelled by if\n\t\t\t * REQ_F_FAIL is set, but the head is an exception since\n\t\t\t * it may be set REQ_F_FAIL because of other req's failure\n\t\t\t * so let's leverage req->result to distinguish if a head\n\t\t\t * is set REQ_F_FAIL because of its failure or other req's\n\t\t\t * failure so that we can set the correct ret code for it.\n\t\t\t * init result here to avoid affecting the normal path.\n\t\t\t */\n\t\t\tif (!(link->head->flags & REQ_F_FAIL))\n\t\t\t\treq_fail_link_node(link->head, -ECANCELED);\n\t\t} else if (!(req->flags & (REQ_F_LINK | REQ_F_HARDLINK))) {\n\t\t\t/*\n\t\t\t * the current req is a normal req, we should return\n\t\t\t * error and thus break the submittion loop.\n\t\t\t */\n\t\t\tio_req_complete_failed(req, ret);\n\t\t\treturn ret;\n\t\t}\n\t\treq_fail_link_node(req, ret);\n\t}\n\n\t/* don't need @sqe from now on */\n\ttrace_io_uring_submit_sqe(ctx, req, req->user_data, req->opcode,\n\t\t\t\t  req->flags, true,\n\t\t\t\t  ctx->flags & IORING_SETUP_SQPOLL);\n\n\t/*\n\t * If we already have a head request, queue this one for async\n\t * submittal once the head completes. If we don't have a head but\n\t * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be\n\t * submitted sync once the chain is complete. If none of those\n\t * conditions are true (normal request), then just queue it.\n\t */\n\tif (link->head) {\n\t\tstruct io_kiocb *head = link->head;\n\n\t\tif (!(req->flags & REQ_F_FAIL)) {\n\t\t\tret = io_req_prep_async(req);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\treq_fail_link_node(req, ret);\n\t\t\t\tif (!(head->flags & REQ_F_FAIL))\n\t\t\t\t\treq_fail_link_node(head, -ECANCELED);\n\t\t\t}\n\t\t}\n\t\ttrace_io_uring_link(ctx, req, head);\n\t\tlink->last->link = req;\n\t\tlink->last = req;\n\n\t\tif (req->flags & (REQ_F_LINK | REQ_F_HARDLINK))\n\t\t\treturn 0;\n\t\t/* last request of a link, enqueue the link */\n\t\tlink->head = NULL;\n\t\treq = head;\n\t} else if (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {\n\t\tlink->head = req;\n\t\tlink->last = req;\n\t\treturn 0;\n\t}\n\n\tio_queue_sqe(req);\n\treturn 0;\n}\n\n/*\n * Batched submission is done, ensure local IO is flushed out.\n */\nstatic void io_submit_state_end(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\n\tif (state->link.head)\n\t\tio_queue_sqe(state->link.head);\n\t/* flush only after queuing links as they can generate completions */\n\tio_submit_flush_completions(ctx);\n\tif (state->plug_started)\n\t\tblk_finish_plug(&state->plug);\n}\n\n/*\n * Start submission side cache.\n */\nstatic void io_submit_state_start(struct io_submit_state *state,\n\t\t\t\t  unsigned int max_ios)\n{\n\tstate->plug_started = false;\n\tstate->need_plug = max_ios > 2;\n\tstate->submit_nr = max_ios;\n\t/* set only head, no need to init link_last in advance */\n\tstate->link.head = NULL;\n}\n\nstatic void io_commit_sqring(struct io_ring_ctx *ctx)\n{\n\tstruct io_rings *rings = ctx->rings;\n\n\t/*\n\t * Ensure any loads from the SQEs are done at this point,\n\t * since once we write the new head, the application could\n\t * write new data to them.\n\t */\n\tsmp_store_release(&rings->sq.head, ctx->cached_sq_head);\n}\n\n/*\n * Fetch an sqe, if one is available. Note this returns a pointer to memory\n * that is mapped by userspace. This means that care needs to be taken to\n * ensure that reads are stable, as we cannot rely on userspace always\n * being a good citizen. If members of the sqe are validated and then later\n * used, it's important that those reads are done through READ_ONCE() to\n * prevent a re-load down the line.\n */\nstatic const struct io_uring_sqe *io_get_sqe(struct io_ring_ctx *ctx)\n{\n\tunsigned head, mask = ctx->sq_entries - 1;\n\tunsigned sq_idx = ctx->cached_sq_head++ & mask;\n\n\t/*\n\t * The cached sq head (or cq tail) serves two purposes:\n\t *\n\t * 1) allows us to batch the cost of updating the user visible\n\t *    head updates.\n\t * 2) allows the kernel side to track the head on its own, even\n\t *    though the application is the one updating it.\n\t */\n\thead = READ_ONCE(ctx->sq_array[sq_idx]);\n\tif (likely(head < ctx->sq_entries))\n\t\treturn &ctx->sq_sqes[head];\n\n\t/* drop invalid entries */\n\tctx->cq_extra--;\n\tWRITE_ONCE(ctx->rings->sq_dropped,\n\t\t   READ_ONCE(ctx->rings->sq_dropped) + 1);\n\treturn NULL;\n}\n\nstatic int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr)\n\t__must_hold(&ctx->uring_lock)\n{\n\tunsigned int entries = io_sqring_entries(ctx);\n\tint submitted = 0;\n\n\tif (unlikely(!entries))\n\t\treturn 0;\n\t/* make sure SQ entry isn't read before tail */\n\tnr = min3(nr, ctx->sq_entries, entries);\n\tio_get_task_refs(nr);\n\n\tio_submit_state_start(&ctx->submit_state, nr);\n\tdo {\n\t\tconst struct io_uring_sqe *sqe;\n\t\tstruct io_kiocb *req;\n\n\t\tif (unlikely(!io_alloc_req_refill(ctx))) {\n\t\t\tif (!submitted)\n\t\t\t\tsubmitted = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\treq = io_alloc_req(ctx);\n\t\tsqe = io_get_sqe(ctx);\n\t\tif (unlikely(!sqe)) {\n\t\t\twq_stack_add_head(&req->comp_list, &ctx->submit_state.free_list);\n\t\t\tbreak;\n\t\t}\n\t\t/* will complete beyond this point, count as submitted */\n\t\tsubmitted++;\n\t\tif (io_submit_sqe(ctx, req, sqe)) {\n\t\t\t/*\n\t\t\t * Continue submitting even for sqe failure if the\n\t\t\t * ring was setup with IORING_SETUP_SUBMIT_ALL\n\t\t\t */\n\t\t\tif (!(ctx->flags & IORING_SETUP_SUBMIT_ALL))\n\t\t\t\tbreak;\n\t\t}\n\t} while (submitted < nr);\n\n\tif (unlikely(submitted != nr)) {\n\t\tint ref_used = (submitted == -EAGAIN) ? 0 : submitted;\n\t\tint unused = nr - ref_used;\n\n\t\tcurrent->io_uring->cached_refs += unused;\n\t}\n\n\tio_submit_state_end(ctx);\n\t /* Commit SQ ring head once we've consumed and submitted all SQEs */\n\tio_commit_sqring(ctx);\n\n\treturn submitted;\n}\n\nstatic inline bool io_sqd_events_pending(struct io_sq_data *sqd)\n{\n\treturn READ_ONCE(sqd->state);\n}\n\nstatic inline void io_ring_set_wakeup_flag(struct io_ring_ctx *ctx)\n{\n\t/* Tell userspace we may need a wakeup call */\n\tspin_lock(&ctx->completion_lock);\n\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t   ctx->rings->sq_flags | IORING_SQ_NEED_WAKEUP);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic inline void io_ring_clear_wakeup_flag(struct io_ring_ctx *ctx)\n{\n\tspin_lock(&ctx->completion_lock);\n\tWRITE_ONCE(ctx->rings->sq_flags,\n\t\t   ctx->rings->sq_flags & ~IORING_SQ_NEED_WAKEUP);\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic int __io_sq_thread(struct io_ring_ctx *ctx, bool cap_entries)\n{\n\tunsigned int to_submit;\n\tint ret = 0;\n\n\tto_submit = io_sqring_entries(ctx);\n\t/* if we're handling multiple rings, cap submit size for fairness */\n\tif (cap_entries && to_submit > IORING_SQPOLL_CAP_ENTRIES_VALUE)\n\t\tto_submit = IORING_SQPOLL_CAP_ENTRIES_VALUE;\n\n\tif (!wq_list_empty(&ctx->iopoll_list) || to_submit) {\n\t\tconst struct cred *creds = NULL;\n\n\t\tif (ctx->sq_creds != current_cred())\n\t\t\tcreds = override_creds(ctx->sq_creds);\n\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tif (!wq_list_empty(&ctx->iopoll_list))\n\t\t\tio_do_iopoll(ctx, true);\n\n\t\t/*\n\t\t * Don't submit if refs are dying, good for io_uring_register(),\n\t\t * but also it is relied upon by io_ring_exit_work()\n\t\t */\n\t\tif (to_submit && likely(!percpu_ref_is_dying(&ctx->refs)) &&\n\t\t    !(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\t\tret = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\t\tif (to_submit && wq_has_sleeper(&ctx->sqo_sq_wait))\n\t\t\twake_up(&ctx->sqo_sq_wait);\n\t\tif (creds)\n\t\t\trevert_creds(creds);\n\t}\n\n\treturn ret;\n}\n\nstatic __cold void io_sqd_update_thread_idle(struct io_sq_data *sqd)\n{\n\tstruct io_ring_ctx *ctx;\n\tunsigned sq_thread_idle = 0;\n\n\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\tsq_thread_idle = max(sq_thread_idle, ctx->sq_thread_idle);\n\tsqd->sq_thread_idle = sq_thread_idle;\n}\n\nstatic bool io_sqd_handle_event(struct io_sq_data *sqd)\n{\n\tbool did_sig = false;\n\tstruct ksignal ksig;\n\n\tif (test_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state) ||\n\t    signal_pending(current)) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tif (signal_pending(current))\n\t\t\tdid_sig = get_signal(&ksig);\n\t\tcond_resched();\n\t\tmutex_lock(&sqd->lock);\n\t}\n\treturn did_sig || test_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state);\n}\n\nstatic int io_sq_thread(void *data)\n{\n\tstruct io_sq_data *sqd = data;\n\tstruct io_ring_ctx *ctx;\n\tunsigned long timeout = 0;\n\tchar buf[TASK_COMM_LEN];\n\tDEFINE_WAIT(wait);\n\n\tsnprintf(buf, sizeof(buf), \"iou-sqp-%d\", sqd->task_pid);\n\tset_task_comm(current, buf);\n\n\tif (sqd->sq_cpu != -1)\n\t\tset_cpus_allowed_ptr(current, cpumask_of(sqd->sq_cpu));\n\telse\n\t\tset_cpus_allowed_ptr(current, cpu_online_mask);\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\taudit_alloc_kernel(current);\n\n\tmutex_lock(&sqd->lock);\n\twhile (1) {\n\t\tbool cap_entries, sqt_spin = false;\n\n\t\tif (io_sqd_events_pending(sqd) || signal_pending(current)) {\n\t\t\tif (io_sqd_handle_event(sqd))\n\t\t\t\tbreak;\n\t\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t\t}\n\n\t\tcap_entries = !list_is_singular(&sqd->ctx_list);\n\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {\n\t\t\tint ret = __io_sq_thread(ctx, cap_entries);\n\n\t\t\tif (!sqt_spin && (ret > 0 || !wq_list_empty(&ctx->iopoll_list)))\n\t\t\t\tsqt_spin = true;\n\t\t}\n\t\tif (io_run_task_work())\n\t\t\tsqt_spin = true;\n\n\t\tif (sqt_spin || !time_after(jiffies, timeout)) {\n\t\t\tcond_resched();\n\t\t\tif (sqt_spin)\n\t\t\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprepare_to_wait(&sqd->wait, &wait, TASK_INTERRUPTIBLE);\n\t\tif (!io_sqd_events_pending(sqd) && !task_work_pending(current)) {\n\t\t\tbool needs_sched = true;\n\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {\n\t\t\t\tio_ring_set_wakeup_flag(ctx);\n\n\t\t\t\tif ((ctx->flags & IORING_SETUP_IOPOLL) &&\n\t\t\t\t    !wq_list_empty(&ctx->iopoll_list)) {\n\t\t\t\t\tneeds_sched = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ensure the store of the wakeup flag is not\n\t\t\t\t * reordered with the load of the SQ tail\n\t\t\t\t */\n\t\t\t\tsmp_mb();\n\n\t\t\t\tif (io_sqring_entries(ctx)) {\n\t\t\t\t\tneeds_sched = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (needs_sched) {\n\t\t\t\tmutex_unlock(&sqd->lock);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&sqd->lock);\n\t\t\t}\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\t\t\tio_ring_clear_wakeup_flag(ctx);\n\t\t}\n\n\t\tfinish_wait(&sqd->wait, &wait);\n\t\ttimeout = jiffies + sqd->sq_thread_idle;\n\t}\n\n\tio_uring_cancel_generic(true, sqd);\n\tsqd->thread = NULL;\n\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\tio_ring_set_wakeup_flag(ctx);\n\tio_run_task_work();\n\tmutex_unlock(&sqd->lock);\n\n\taudit_free(current);\n\n\tcomplete(&sqd->exited);\n\tdo_exit(0);\n}\n\nstruct io_wait_queue {\n\tstruct wait_queue_entry wq;\n\tstruct io_ring_ctx *ctx;\n\tunsigned cq_tail;\n\tunsigned nr_timeouts;\n};\n\nstatic inline bool io_should_wake(struct io_wait_queue *iowq)\n{\n\tstruct io_ring_ctx *ctx = iowq->ctx;\n\tint dist = ctx->cached_cq_tail - (int) iowq->cq_tail;\n\n\t/*\n\t * Wake up if we have enough events, or if a timeout occurred since we\n\t * started waiting. For timeouts, we always want to return to userspace,\n\t * regardless of event count.\n\t */\n\treturn dist >= 0 || atomic_read(&ctx->cq_timeouts) != iowq->nr_timeouts;\n}\n\nstatic int io_wake_function(struct wait_queue_entry *curr, unsigned int mode,\n\t\t\t    int wake_flags, void *key)\n{\n\tstruct io_wait_queue *iowq = container_of(curr, struct io_wait_queue,\n\t\t\t\t\t\t\twq);\n\n\t/*\n\t * Cannot safely flush overflowed CQEs from here, ensure we wake up\n\t * the task, and the next invocation will do it.\n\t */\n\tif (io_should_wake(iowq) || test_bit(0, &iowq->ctx->check_cq_overflow))\n\t\treturn autoremove_wake_function(curr, mode, wake_flags, key);\n\treturn -1;\n}\n\nstatic int io_run_task_work_sig(void)\n{\n\tif (io_run_task_work())\n\t\treturn 1;\n\tif (test_thread_flag(TIF_NOTIFY_SIGNAL))\n\t\treturn -ERESTARTSYS;\n\tif (task_sigpending(current))\n\t\treturn -EINTR;\n\treturn 0;\n}\n\n/* when returns >0, the caller should retry */\nstatic inline int io_cqring_wait_schedule(struct io_ring_ctx *ctx,\n\t\t\t\t\t  struct io_wait_queue *iowq,\n\t\t\t\t\t  ktime_t timeout)\n{\n\tint ret;\n\n\t/* make sure we run task_work before checking for signals */\n\tret = io_run_task_work_sig();\n\tif (ret || io_should_wake(iowq))\n\t\treturn ret;\n\t/* let the caller flush overflows, retry */\n\tif (test_bit(0, &ctx->check_cq_overflow))\n\t\treturn 1;\n\n\tif (!schedule_hrtimeout(&timeout, HRTIMER_MODE_ABS))\n\t\treturn -ETIME;\n\treturn 1;\n}\n\n/*\n * Wait until events become available, if we don't already have some. The\n * application must reap them itself, as they reside on the shared cq ring.\n */\nstatic int io_cqring_wait(struct io_ring_ctx *ctx, int min_events,\n\t\t\t  const sigset_t __user *sig, size_t sigsz,\n\t\t\t  struct __kernel_timespec __user *uts)\n{\n\tstruct io_wait_queue iowq;\n\tstruct io_rings *rings = ctx->rings;\n\tktime_t timeout = KTIME_MAX;\n\tint ret;\n\n\tdo {\n\t\tio_cqring_overflow_flush(ctx);\n\t\tif (io_cqring_events(ctx) >= min_events)\n\t\t\treturn 0;\n\t\tif (!io_run_task_work())\n\t\t\tbreak;\n\t} while (1);\n\n\tif (sig) {\n#ifdef CONFIG_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = set_compat_user_sigmask((const compat_sigset_t __user *)sig,\n\t\t\t\t\t\t      sigsz);\n\t\telse\n#endif\n\t\t\tret = set_user_sigmask(sig, sigsz);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (uts) {\n\t\tstruct timespec64 ts;\n\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ktime_add_ns(timespec64_to_ktime(ts), ktime_get_ns());\n\t}\n\n\tinit_waitqueue_func_entry(&iowq.wq, io_wake_function);\n\tiowq.wq.private = current;\n\tINIT_LIST_HEAD(&iowq.wq.entry);\n\tiowq.ctx = ctx;\n\tiowq.nr_timeouts = atomic_read(&ctx->cq_timeouts);\n\tiowq.cq_tail = READ_ONCE(ctx->rings->cq.head) + min_events;\n\n\ttrace_io_uring_cqring_wait(ctx, min_events);\n\tdo {\n\t\t/* if we can't even flush overflow, don't wait for more */\n\t\tif (!io_cqring_overflow_flush(ctx)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait_exclusive(&ctx->cq_wait, &iowq.wq,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tret = io_cqring_wait_schedule(ctx, &iowq, timeout);\n\t\tfinish_wait(&ctx->cq_wait, &iowq.wq);\n\t\tcond_resched();\n\t} while (ret > 0);\n\n\trestore_saved_sigmask_unless(ret == -EINTR);\n\n\treturn READ_ONCE(rings->cq.head) == READ_ONCE(rings->cq.tail) ? ret : 0;\n}\n\nstatic void io_free_page_table(void **table, size_t size)\n{\n\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\n\n\tfor (i = 0; i < nr_tables; i++)\n\t\tkfree(table[i]);\n\tkfree(table);\n}\n\nstatic __cold void **io_alloc_page_table(size_t size)\n{\n\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\n\tsize_t init_size = size;\n\tvoid **table;\n\n\ttable = kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);\n\tif (!table)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tunsigned int this_size = min_t(size_t, size, PAGE_SIZE);\n\n\t\ttable[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);\n\t\tif (!table[i]) {\n\t\t\tio_free_page_table(table, init_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize -= this_size;\n\t}\n\treturn table;\n}\n\nstatic void io_rsrc_node_destroy(struct io_rsrc_node *ref_node)\n{\n\tpercpu_ref_exit(&ref_node->refs);\n\tkfree(ref_node);\n}\n\nstatic __cold void io_rsrc_node_ref_zero(struct percpu_ref *ref)\n{\n\tstruct io_rsrc_node *node = container_of(ref, struct io_rsrc_node, refs);\n\tstruct io_ring_ctx *ctx = node->rsrc_data->ctx;\n\tunsigned long flags;\n\tbool first_add = false;\n\tunsigned long delay = HZ;\n\n\tspin_lock_irqsave(&ctx->rsrc_ref_lock, flags);\n\tnode->done = true;\n\n\t/* if we are mid-quiesce then do not delay */\n\tif (node->rsrc_data->quiesce)\n\t\tdelay = 0;\n\n\twhile (!list_empty(&ctx->rsrc_ref_list)) {\n\t\tnode = list_first_entry(&ctx->rsrc_ref_list,\n\t\t\t\t\t    struct io_rsrc_node, node);\n\t\t/* recycle ref nodes in order */\n\t\tif (!node->done)\n\t\t\tbreak;\n\t\tlist_del(&node->node);\n\t\tfirst_add |= llist_add(&node->llist, &ctx->rsrc_put_llist);\n\t}\n\tspin_unlock_irqrestore(&ctx->rsrc_ref_lock, flags);\n\n\tif (first_add)\n\t\tmod_delayed_work(system_wq, &ctx->rsrc_put_work, delay);\n}\n\nstatic struct io_rsrc_node *io_rsrc_node_alloc(void)\n{\n\tstruct io_rsrc_node *ref_node;\n\n\tref_node = kzalloc(sizeof(*ref_node), GFP_KERNEL);\n\tif (!ref_node)\n\t\treturn NULL;\n\n\tif (percpu_ref_init(&ref_node->refs, io_rsrc_node_ref_zero,\n\t\t\t    0, GFP_KERNEL)) {\n\t\tkfree(ref_node);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&ref_node->node);\n\tINIT_LIST_HEAD(&ref_node->rsrc_list);\n\tref_node->done = false;\n\treturn ref_node;\n}\n\nstatic void io_rsrc_node_switch(struct io_ring_ctx *ctx,\n\t\t\t\tstruct io_rsrc_data *data_to_kill)\n\t__must_hold(&ctx->uring_lock)\n{\n\tWARN_ON_ONCE(!ctx->rsrc_backup_node);\n\tWARN_ON_ONCE(data_to_kill && !ctx->rsrc_node);\n\n\tio_rsrc_refs_drop(ctx);\n\n\tif (data_to_kill) {\n\t\tstruct io_rsrc_node *rsrc_node = ctx->rsrc_node;\n\n\t\trsrc_node->rsrc_data = data_to_kill;\n\t\tspin_lock_irq(&ctx->rsrc_ref_lock);\n\t\tlist_add_tail(&rsrc_node->node, &ctx->rsrc_ref_list);\n\t\tspin_unlock_irq(&ctx->rsrc_ref_lock);\n\n\t\tatomic_inc(&data_to_kill->refs);\n\t\tpercpu_ref_kill(&rsrc_node->refs);\n\t\tctx->rsrc_node = NULL;\n\t}\n\n\tif (!ctx->rsrc_node) {\n\t\tctx->rsrc_node = ctx->rsrc_backup_node;\n\t\tctx->rsrc_backup_node = NULL;\n\t}\n}\n\nstatic int io_rsrc_node_switch_start(struct io_ring_ctx *ctx)\n{\n\tif (ctx->rsrc_backup_node)\n\t\treturn 0;\n\tctx->rsrc_backup_node = io_rsrc_node_alloc();\n\treturn ctx->rsrc_backup_node ? 0 : -ENOMEM;\n}\n\nstatic __cold int io_rsrc_ref_quiesce(struct io_rsrc_data *data,\n\t\t\t\t      struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\t/* As we may drop ->uring_lock, other task may have started quiesce */\n\tif (data->quiesce)\n\t\treturn -ENXIO;\n\n\tdata->quiesce = true;\n\tdo {\n\t\tret = io_rsrc_node_switch_start(ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tio_rsrc_node_switch(ctx, data);\n\n\t\t/* kill initial ref, already quiesced if zero */\n\t\tif (atomic_dec_and_test(&data->refs))\n\t\t\tbreak;\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\tflush_delayed_work(&ctx->rsrc_put_work);\n\t\tret = wait_for_completion_interruptible(&data->done);\n\t\tif (!ret) {\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t\tif (atomic_read(&data->refs) > 0) {\n\t\t\t\t/*\n\t\t\t\t * it has been revived by another thread while\n\t\t\t\t * we were unlocked\n\t\t\t\t */\n\t\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tatomic_inc(&data->refs);\n\t\t/* wait for all works potentially completing data->done */\n\t\tflush_delayed_work(&ctx->rsrc_put_work);\n\t\treinit_completion(&data->done);\n\n\t\tret = io_run_task_work_sig();\n\t\tmutex_lock(&ctx->uring_lock);\n\t} while (ret >= 0);\n\tdata->quiesce = false;\n\n\treturn ret;\n}\n\nstatic u64 *io_get_tag_slot(struct io_rsrc_data *data, unsigned int idx)\n{\n\tunsigned int off = idx & IO_RSRC_TAG_TABLE_MASK;\n\tunsigned int table_idx = idx >> IO_RSRC_TAG_TABLE_SHIFT;\n\n\treturn &data->tags[table_idx][off];\n}\n\nstatic void io_rsrc_data_free(struct io_rsrc_data *data)\n{\n\tsize_t size = data->nr * sizeof(data->tags[0][0]);\n\n\tif (data->tags)\n\t\tio_free_page_table((void **)data->tags, size);\n\tkfree(data);\n}\n\nstatic __cold int io_rsrc_data_alloc(struct io_ring_ctx *ctx, rsrc_put_fn *do_put,\n\t\t\t\t     u64 __user *utags, unsigned nr,\n\t\t\t\t     struct io_rsrc_data **pdata)\n{\n\tstruct io_rsrc_data *data;\n\tint ret = -ENOMEM;\n\tunsigned i;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->tags = (u64 **)io_alloc_page_table(nr * sizeof(data->tags[0][0]));\n\tif (!data->tags) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->nr = nr;\n\tdata->ctx = ctx;\n\tdata->do_put = do_put;\n\tif (utags) {\n\t\tret = -EFAULT;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tu64 *tag_slot = io_get_tag_slot(data, i);\n\n\t\t\tif (copy_from_user(tag_slot, &utags[i],\n\t\t\t\t\t   sizeof(*tag_slot)))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tatomic_set(&data->refs, 1);\n\tinit_completion(&data->done);\n\t*pdata = data;\n\treturn 0;\nfail:\n\tio_rsrc_data_free(data);\n\treturn ret;\n}\n\nstatic bool io_alloc_file_tables(struct io_file_table *table, unsigned nr_files)\n{\n\ttable->files = kvcalloc(nr_files, sizeof(table->files[0]),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\treturn !!table->files;\n}\n\nstatic void io_free_file_tables(struct io_file_table *table)\n{\n\tkvfree(table->files);\n\ttable->files = NULL;\n}\n\nstatic void __io_sqe_files_unregister(struct io_ring_ctx *ctx)\n{\n#if defined(CONFIG_UNIX)\n\tif (ctx->ring_sock) {\n\t\tstruct sock *sock = ctx->ring_sock->sk;\n\t\tstruct sk_buff *skb;\n\n\t\twhile ((skb = skb_dequeue(&sock->sk_receive_queue)) != NULL)\n\t\t\tkfree_skb(skb);\n\t}\n#else\n\tint i;\n\n\tfor (i = 0; i < ctx->nr_user_files; i++) {\n\t\tstruct file *file;\n\n\t\tfile = io_file_from_index(ctx, i);\n\t\tif (file)\n\t\t\tfput(file);\n\t}\n#endif\n\tio_free_file_tables(&ctx->file_table);\n\tio_rsrc_data_free(ctx->file_data);\n\tctx->file_data = NULL;\n\tctx->nr_user_files = 0;\n}\n\nstatic int io_sqe_files_unregister(struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\tif (!ctx->file_data)\n\t\treturn -ENXIO;\n\tret = io_rsrc_ref_quiesce(ctx->file_data, ctx);\n\tif (!ret)\n\t\t__io_sqe_files_unregister(ctx);\n\treturn ret;\n}\n\nstatic void io_sq_thread_unpark(struct io_sq_data *sqd)\n\t__releases(&sqd->lock)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\n\t/*\n\t * Do the dance but not conditional clear_bit() because it'd race with\n\t * other threads incrementing park_pending and setting the bit.\n\t */\n\tclear_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tif (atomic_dec_return(&sqd->park_pending))\n\t\tset_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tmutex_unlock(&sqd->lock);\n}\n\nstatic void io_sq_thread_park(struct io_sq_data *sqd)\n\t__acquires(&sqd->lock)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\n\tatomic_inc(&sqd->park_pending);\n\tset_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state);\n\tmutex_lock(&sqd->lock);\n\tif (sqd->thread)\n\t\twake_up_process(sqd->thread);\n}\n\nstatic void io_sq_thread_stop(struct io_sq_data *sqd)\n{\n\tWARN_ON_ONCE(sqd->thread == current);\n\tWARN_ON_ONCE(test_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state));\n\n\tset_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state);\n\tmutex_lock(&sqd->lock);\n\tif (sqd->thread)\n\t\twake_up_process(sqd->thread);\n\tmutex_unlock(&sqd->lock);\n\twait_for_completion(&sqd->exited);\n}\n\nstatic void io_put_sq_data(struct io_sq_data *sqd)\n{\n\tif (refcount_dec_and_test(&sqd->refs)) {\n\t\tWARN_ON_ONCE(atomic_read(&sqd->park_pending));\n\n\t\tio_sq_thread_stop(sqd);\n\t\tkfree(sqd);\n\t}\n}\n\nstatic void io_sq_thread_finish(struct io_ring_ctx *ctx)\n{\n\tstruct io_sq_data *sqd = ctx->sq_data;\n\n\tif (sqd) {\n\t\tio_sq_thread_park(sqd);\n\t\tlist_del_init(&ctx->sqd_list);\n\t\tio_sqd_update_thread_idle(sqd);\n\t\tio_sq_thread_unpark(sqd);\n\n\t\tio_put_sq_data(sqd);\n\t\tctx->sq_data = NULL;\n\t}\n}\n\nstatic struct io_sq_data *io_attach_sq_data(struct io_uring_params *p)\n{\n\tstruct io_ring_ctx *ctx_attach;\n\tstruct io_sq_data *sqd;\n\tstruct fd f;\n\n\tf = fdget(p->wq_fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-ENXIO);\n\tif (f.file->f_op != &io_uring_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tctx_attach = f.file->private_data;\n\tsqd = ctx_attach->sq_data;\n\tif (!sqd) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (sqd->task_tgid != current->tgid) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\trefcount_inc(&sqd->refs);\n\tfdput(f);\n\treturn sqd;\n}\n\nstatic struct io_sq_data *io_get_sq_data(struct io_uring_params *p,\n\t\t\t\t\t bool *attached)\n{\n\tstruct io_sq_data *sqd;\n\n\t*attached = false;\n\tif (p->flags & IORING_SETUP_ATTACH_WQ) {\n\t\tsqd = io_attach_sq_data(p);\n\t\tif (!IS_ERR(sqd)) {\n\t\t\t*attached = true;\n\t\t\treturn sqd;\n\t\t}\n\t\t/* fall through for EPERM case, setup new sqd/task */\n\t\tif (PTR_ERR(sqd) != -EPERM)\n\t\t\treturn sqd;\n\t}\n\n\tsqd = kzalloc(sizeof(*sqd), GFP_KERNEL);\n\tif (!sqd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sqd->park_pending, 0);\n\trefcount_set(&sqd->refs, 1);\n\tINIT_LIST_HEAD(&sqd->ctx_list);\n\tmutex_init(&sqd->lock);\n\tinit_waitqueue_head(&sqd->wait);\n\tinit_completion(&sqd->exited);\n\treturn sqd;\n}\n\n#if defined(CONFIG_UNIX)\n/*\n * Ensure the UNIX gc is aware of our file set, so we are certain that\n * the io_uring can be safely unregistered on process exit, even if we have\n * loops in the file referencing.\n */\nstatic int __io_sqe_files_scm(struct io_ring_ctx *ctx, int nr, int offset)\n{\n\tstruct sock *sk = ctx->ring_sock->sk;\n\tstruct scm_fp_list *fpl;\n\tstruct sk_buff *skb;\n\tint i, nr_files;\n\n\tfpl = kzalloc(sizeof(*fpl), GFP_KERNEL);\n\tif (!fpl)\n\t\treturn -ENOMEM;\n\n\tskb = alloc_skb(0, GFP_KERNEL);\n\tif (!skb) {\n\t\tkfree(fpl);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb->sk = sk;\n\n\tnr_files = 0;\n\tfpl->user = get_uid(current_user());\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct file *file = io_file_from_index(ctx, i + offset);\n\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfpl->fp[nr_files] = get_file(file);\n\t\tunix_inflight(fpl->user, fpl->fp[nr_files]);\n\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->count = nr_files;\n\t\tUNIXCB(skb).fp = fpl;\n\t\tskb->destructor = unix_destruct_scm;\n\t\trefcount_add(skb->truesize, &sk->sk_wmem_alloc);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tstruct file *file = io_file_from_index(ctx, i + offset);\n\n\t\t\tif (file)\n\t\t\t\tfput(file);\n\t\t}\n\t} else {\n\t\tkfree_skb(skb);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n\n\treturn 0;\n}\n\n/*\n * If UNIX sockets are enabled, fd passing can cause a reference cycle which\n * causes regular reference counting to break down. We rely on the UNIX\n * garbage collection to take care of this problem for us.\n */\nstatic int io_sqe_files_scm(struct io_ring_ctx *ctx)\n{\n\tunsigned left, total;\n\tint ret = 0;\n\n\ttotal = 0;\n\tleft = ctx->nr_user_files;\n\twhile (left) {\n\t\tunsigned this_files = min_t(unsigned, left, SCM_MAX_FD);\n\n\t\tret = __io_sqe_files_scm(ctx, this_files, total);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tleft -= this_files;\n\t\ttotal += this_files;\n\t}\n\n\tif (!ret)\n\t\treturn 0;\n\n\twhile (total < ctx->nr_user_files) {\n\t\tstruct file *file = io_file_from_index(ctx, total);\n\n\t\tif (file)\n\t\t\tfput(file);\n\t\ttotal++;\n\t}\n\n\treturn ret;\n}\n#else\nstatic int io_sqe_files_scm(struct io_ring_ctx *ctx)\n{\n\treturn 0;\n}\n#endif\n\nstatic void io_rsrc_file_put(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc)\n{\n\tstruct file *file = prsrc->file;\n#if defined(CONFIG_UNIX)\n\tstruct sock *sock = ctx->ring_sock->sk;\n\tstruct sk_buff_head list, *head = &sock->sk_receive_queue;\n\tstruct sk_buff *skb;\n\tint i;\n\n\t__skb_queue_head_init(&list);\n\n\t/*\n\t * Find the skb that holds this file in its SCM_RIGHTS. When found,\n\t * remove this entry and rearrange the file array.\n\t */\n\tskb = skb_dequeue(head);\n\twhile (skb) {\n\t\tstruct scm_fp_list *fp;\n\n\t\tfp = UNIXCB(skb).fp;\n\t\tfor (i = 0; i < fp->count; i++) {\n\t\t\tint left;\n\n\t\t\tif (fp->fp[i] != file)\n\t\t\t\tcontinue;\n\n\t\t\tunix_notinflight(fp->user, fp->fp[i]);\n\t\t\tleft = fp->count - 1 - i;\n\t\t\tif (left) {\n\t\t\t\tmemmove(&fp->fp[i], &fp->fp[i + 1],\n\t\t\t\t\t\tleft * sizeof(struct file *));\n\t\t\t}\n\t\t\tfp->count--;\n\t\t\tif (!fp->count) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\t__skb_queue_tail(&list, skb);\n\t\t\t}\n\t\t\tfput(file);\n\t\t\tfile = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!file)\n\t\t\tbreak;\n\n\t\t__skb_queue_tail(&list, skb);\n\n\t\tskb = skb_dequeue(head);\n\t}\n\n\tif (skb_peek(&list)) {\n\t\tspin_lock_irq(&head->lock);\n\t\twhile ((skb = __skb_dequeue(&list)) != NULL)\n\t\t\t__skb_queue_tail(head, skb);\n\t\tspin_unlock_irq(&head->lock);\n\t}\n#else\n\tfput(file);\n#endif\n}\n\nstatic void __io_rsrc_put_work(struct io_rsrc_node *ref_node)\n{\n\tstruct io_rsrc_data *rsrc_data = ref_node->rsrc_data;\n\tstruct io_ring_ctx *ctx = rsrc_data->ctx;\n\tstruct io_rsrc_put *prsrc, *tmp;\n\n\tlist_for_each_entry_safe(prsrc, tmp, &ref_node->rsrc_list, list) {\n\t\tlist_del(&prsrc->list);\n\n\t\tif (prsrc->tag) {\n\t\t\tbool lock_ring = ctx->flags & IORING_SETUP_IOPOLL;\n\n\t\t\tio_ring_submit_lock(ctx, lock_ring);\n\t\t\tspin_lock(&ctx->completion_lock);\n\t\t\tio_fill_cqe_aux(ctx, prsrc->tag, 0, 0);\n\t\t\tio_commit_cqring(ctx);\n\t\t\tspin_unlock(&ctx->completion_lock);\n\t\t\tio_cqring_ev_posted(ctx);\n\t\t\tio_ring_submit_unlock(ctx, lock_ring);\n\t\t}\n\n\t\trsrc_data->do_put(ctx, prsrc);\n\t\tkfree(prsrc);\n\t}\n\n\tio_rsrc_node_destroy(ref_node);\n\tif (atomic_dec_and_test(&rsrc_data->refs))\n\t\tcomplete(&rsrc_data->done);\n}\n\nstatic void io_rsrc_put_work(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx;\n\tstruct llist_node *node;\n\n\tctx = container_of(work, struct io_ring_ctx, rsrc_put_work.work);\n\tnode = llist_del_all(&ctx->rsrc_put_llist);\n\n\twhile (node) {\n\t\tstruct io_rsrc_node *ref_node;\n\t\tstruct llist_node *next = node->next;\n\n\t\tref_node = llist_entry(node, struct io_rsrc_node, llist);\n\t\t__io_rsrc_put_work(ref_node);\n\t\tnode = next;\n\t}\n}\n\nstatic int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t unsigned nr_args, u64 __user *tags)\n{\n\t__s32 __user *fds = (__s32 __user *) arg;\n\tstruct file *file;\n\tint fd, ret;\n\tunsigned i;\n\n\tif (ctx->file_data)\n\t\treturn -EBUSY;\n\tif (!nr_args)\n\t\treturn -EINVAL;\n\tif (nr_args > IORING_MAX_FIXED_FILES)\n\t\treturn -EMFILE;\n\tif (nr_args > rlimit(RLIMIT_NOFILE))\n\t\treturn -EMFILE;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\treturn ret;\n\tret = io_rsrc_data_alloc(ctx, io_rsrc_file_put, tags, nr_args,\n\t\t\t\t &ctx->file_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tif (!io_alloc_file_tables(&ctx->file_table, nr_args))\n\t\tgoto out_free;\n\n\tfor (i = 0; i < nr_args; i++, ctx->nr_user_files++) {\n\t\tif (copy_from_user(&fd, &fds[i], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_fput;\n\t\t}\n\t\t/* allow sparse sets */\n\t\tif (fd == -1) {\n\t\t\tret = -EINVAL;\n\t\t\tif (unlikely(*io_get_tag_slot(ctx->file_data, i)))\n\t\t\t\tgoto out_fput;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = fget(fd);\n\t\tret = -EBADF;\n\t\tif (unlikely(!file))\n\t\t\tgoto out_fput;\n\n\t\t/*\n\t\t * Don't allow io_uring instances to be registered. If UNIX\n\t\t * isn't enabled, then this causes a reference cycle and this\n\t\t * instance can never get freed. If UNIX is enabled we'll\n\t\t * handle it just fine, but there's still no point in allowing\n\t\t * a ring fd as it doesn't support regular read/write anyway.\n\t\t */\n\t\tif (file->f_op == &io_uring_fops) {\n\t\t\tfput(file);\n\t\t\tgoto out_fput;\n\t\t}\n\t\tio_fixed_file_set(io_fixed_file_slot(&ctx->file_table, i), file);\n\t}\n\n\tret = io_sqe_files_scm(ctx);\n\tif (ret) {\n\t\t__io_sqe_files_unregister(ctx);\n\t\treturn ret;\n\t}\n\n\tio_rsrc_node_switch(ctx, NULL);\n\treturn ret;\nout_fput:\n\tfor (i = 0; i < ctx->nr_user_files; i++) {\n\t\tfile = io_file_from_index(ctx, i);\n\t\tif (file)\n\t\t\tfput(file);\n\t}\n\tio_free_file_tables(&ctx->file_table);\n\tctx->nr_user_files = 0;\nout_free:\n\tio_rsrc_data_free(ctx->file_data);\n\tctx->file_data = NULL;\n\treturn ret;\n}\n\nstatic int io_sqe_file_register(struct io_ring_ctx *ctx, struct file *file,\n\t\t\t\tint index)\n{\n#if defined(CONFIG_UNIX)\n\tstruct sock *sock = ctx->ring_sock->sk;\n\tstruct sk_buff_head *head = &sock->sk_receive_queue;\n\tstruct sk_buff *skb;\n\n\t/*\n\t * See if we can merge this file into an existing skb SCM_RIGHTS\n\t * file set. If there's no room, fall back to allocating a new skb\n\t * and filling it in.\n\t */\n\tspin_lock_irq(&head->lock);\n\tskb = skb_peek(head);\n\tif (skb) {\n\t\tstruct scm_fp_list *fpl = UNIXCB(skb).fp;\n\n\t\tif (fpl->count < SCM_MAX_FD) {\n\t\t\t__skb_unlink(skb, head);\n\t\t\tspin_unlock_irq(&head->lock);\n\t\t\tfpl->fp[fpl->count] = get_file(file);\n\t\t\tunix_inflight(fpl->user, fpl->fp[fpl->count]);\n\t\t\tfpl->count++;\n\t\t\tspin_lock_irq(&head->lock);\n\t\t\t__skb_queue_head(head, skb);\n\t\t} else {\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\tspin_unlock_irq(&head->lock);\n\n\tif (skb) {\n\t\tfput(file);\n\t\treturn 0;\n\t}\n\n\treturn __io_sqe_files_scm(ctx, 1, index);\n#else\n\treturn 0;\n#endif\n}\n\nstatic int io_queue_rsrc_removal(struct io_rsrc_data *data, unsigned idx,\n\t\t\t\t struct io_rsrc_node *node, void *rsrc)\n{\n\tu64 *tag_slot = io_get_tag_slot(data, idx);\n\tstruct io_rsrc_put *prsrc;\n\n\tprsrc = kzalloc(sizeof(*prsrc), GFP_KERNEL);\n\tif (!prsrc)\n\t\treturn -ENOMEM;\n\n\tprsrc->tag = *tag_slot;\n\t*tag_slot = 0;\n\tprsrc->rsrc = rsrc;\n\tlist_add(&prsrc->list, &node->rsrc_list);\n\treturn 0;\n}\n\nstatic int io_install_fixed_file(struct io_kiocb *req, struct file *file,\n\t\t\t\t unsigned int issue_flags, u32 slot_index)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tbool needs_switch = false;\n\tstruct io_fixed_file *file_slot;\n\tint ret = -EBADF;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tif (file->f_op == &io_uring_fops)\n\t\tgoto err;\n\tret = -ENXIO;\n\tif (!ctx->file_data)\n\t\tgoto err;\n\tret = -EINVAL;\n\tif (slot_index >= ctx->nr_user_files)\n\t\tgoto err;\n\n\tslot_index = array_index_nospec(slot_index, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, slot_index);\n\n\tif (file_slot->file_ptr) {\n\t\tstruct file *old_file;\n\n\t\tret = io_rsrc_node_switch_start(ctx);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\told_file = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\t\tret = io_queue_rsrc_removal(ctx->file_data, slot_index,\n\t\t\t\t\t    ctx->rsrc_node, old_file);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tfile_slot->file_ptr = 0;\n\t\tneeds_switch = true;\n\t}\n\n\t*io_get_tag_slot(ctx->file_data, slot_index) = 0;\n\tio_fixed_file_set(file_slot, file);\n\tret = io_sqe_file_register(ctx, file, slot_index);\n\tif (ret) {\n\t\tfile_slot->file_ptr = 0;\n\t\tgoto err;\n\t}\n\n\tret = 0;\nerr:\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, ctx->file_data);\n\tio_ring_submit_unlock(ctx, needs_lock);\n\tif (ret)\n\t\tfput(file);\n\treturn ret;\n}\n\nstatic int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tunsigned int offset = req->close.file_slot - 1;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tbool needs_lock = issue_flags & IO_URING_F_UNLOCKED;\n\tstruct io_fixed_file *file_slot;\n\tstruct file *file;\n\tint ret;\n\n\tio_ring_submit_lock(ctx, needs_lock);\n\tret = -ENXIO;\n\tif (unlikely(!ctx->file_data))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (offset >= ctx->nr_user_files)\n\t\tgoto out;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\tgoto out;\n\n\toffset = array_index_nospec(offset, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, offset);\n\tret = -EBADF;\n\tif (!file_slot->file_ptr)\n\t\tgoto out;\n\n\tfile = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\tret = io_queue_rsrc_removal(ctx->file_data, offset, ctx->rsrc_node, file);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_slot->file_ptr = 0;\n\tio_rsrc_node_switch(ctx, ctx->file_data);\n\tret = 0;\nout:\n\tio_ring_submit_unlock(ctx, needs_lock);\n\treturn ret;\n}\n\nstatic int __io_sqe_files_update(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_uring_rsrc_update2 *up,\n\t\t\t\t unsigned nr_args)\n{\n\tu64 __user *tags = u64_to_user_ptr(up->tags);\n\t__s32 __user *fds = u64_to_user_ptr(up->data);\n\tstruct io_rsrc_data *data = ctx->file_data;\n\tstruct io_fixed_file *file_slot;\n\tstruct file *file;\n\tint fd, i, err = 0;\n\tunsigned int done;\n\tbool needs_switch = false;\n\n\tif (!ctx->file_data)\n\t\treturn -ENXIO;\n\tif (up->offset + nr_args > ctx->nr_user_files)\n\t\treturn -EINVAL;\n\n\tfor (done = 0; done < nr_args; done++) {\n\t\tu64 tag = 0;\n\n\t\tif ((tags && copy_from_user(&tag, &tags[done], sizeof(tag))) ||\n\t\t    copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((fd == IORING_REGISTER_FILES_SKIP || fd == -1) && tag) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (fd == IORING_REGISTER_FILES_SKIP)\n\t\t\tcontinue;\n\n\t\ti = array_index_nospec(up->offset + done, ctx->nr_user_files);\n\t\tfile_slot = io_fixed_file_slot(&ctx->file_table, i);\n\n\t\tif (file_slot->file_ptr) {\n\t\t\tfile = (struct file *)(file_slot->file_ptr & FFS_MASK);\n\t\t\terr = io_queue_rsrc_removal(data, i, ctx->rsrc_node, file);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tfile_slot->file_ptr = 0;\n\t\t\tneeds_switch = true;\n\t\t}\n\t\tif (fd != -1) {\n\t\t\tfile = fget(fd);\n\t\t\tif (!file) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't allow io_uring instances to be registered. If\n\t\t\t * UNIX isn't enabled, then this causes a reference\n\t\t\t * cycle and this instance can never get freed. If UNIX\n\t\t\t * is enabled we'll handle it just fine, but there's\n\t\t\t * still no point in allowing a ring fd as it doesn't\n\t\t\t * support regular read/write anyway.\n\t\t\t */\n\t\t\tif (file->f_op == &io_uring_fops) {\n\t\t\t\tfput(file);\n\t\t\t\terr = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*io_get_tag_slot(data, i) = tag;\n\t\t\tio_fixed_file_set(file_slot, file);\n\t\t\terr = io_sqe_file_register(ctx, file, i);\n\t\t\tif (err) {\n\t\t\t\tfile_slot->file_ptr = 0;\n\t\t\t\tfput(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, data);\n\treturn done ? done : err;\n}\n\nstatic struct io_wq *io_init_wq_offload(struct io_ring_ctx *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct io_wq_hash *hash;\n\tstruct io_wq_data data;\n\tunsigned int concurrency;\n\n\tmutex_lock(&ctx->uring_lock);\n\thash = ctx->hash_map;\n\tif (!hash) {\n\t\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\t\tif (!hash) {\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trefcount_set(&hash->refs, 1);\n\t\tinit_waitqueue_head(&hash->wait);\n\t\tctx->hash_map = hash;\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\n\tdata.hash = hash;\n\tdata.task = task;\n\tdata.free_work = io_wq_free_work;\n\tdata.do_work = io_wq_submit_work;\n\n\t/* Do QD, or 4 * CPUS, whatever is smallest */\n\tconcurrency = min(ctx->sq_entries, 4 * num_online_cpus());\n\n\treturn io_wq_create(concurrency, &data);\n}\n\nstatic __cold int io_uring_alloc_task_context(struct task_struct *task,\n\t\t\t\t\t      struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx;\n\tint ret;\n\n\ttctx = kzalloc(sizeof(*tctx), GFP_KERNEL);\n\tif (unlikely(!tctx))\n\t\treturn -ENOMEM;\n\n\ttctx->registered_rings = kcalloc(IO_RINGFD_REG_MAX,\n\t\t\t\t\t sizeof(struct file *), GFP_KERNEL);\n\tif (unlikely(!tctx->registered_rings)) {\n\t\tkfree(tctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = percpu_counter_init(&tctx->inflight, 0, GFP_KERNEL);\n\tif (unlikely(ret)) {\n\t\tkfree(tctx->registered_rings);\n\t\tkfree(tctx);\n\t\treturn ret;\n\t}\n\n\ttctx->io_wq = io_init_wq_offload(ctx, task);\n\tif (IS_ERR(tctx->io_wq)) {\n\t\tret = PTR_ERR(tctx->io_wq);\n\t\tpercpu_counter_destroy(&tctx->inflight);\n\t\tkfree(tctx->registered_rings);\n\t\tkfree(tctx);\n\t\treturn ret;\n\t}\n\n\txa_init(&tctx->xa);\n\tinit_waitqueue_head(&tctx->wait);\n\tatomic_set(&tctx->in_idle, 0);\n\ttask->io_uring = tctx;\n\tspin_lock_init(&tctx->task_lock);\n\tINIT_WQ_LIST(&tctx->task_list);\n\tINIT_WQ_LIST(&tctx->prior_task_list);\n\tinit_task_work(&tctx->task_work, tctx_task_work);\n\treturn 0;\n}\n\nvoid __io_uring_free(struct task_struct *tsk)\n{\n\tstruct io_uring_task *tctx = tsk->io_uring;\n\n\tWARN_ON_ONCE(!xa_empty(&tctx->xa));\n\tWARN_ON_ONCE(tctx->io_wq);\n\tWARN_ON_ONCE(tctx->cached_refs);\n\n\tkfree(tctx->registered_rings);\n\tpercpu_counter_destroy(&tctx->inflight);\n\tkfree(tctx);\n\ttsk->io_uring = NULL;\n}\n\nstatic __cold int io_sq_offload_create(struct io_ring_ctx *ctx,\n\t\t\t\t       struct io_uring_params *p)\n{\n\tint ret;\n\n\t/* Retain compatibility with failing for an invalid attach attempt */\n\tif ((ctx->flags & (IORING_SETUP_ATTACH_WQ | IORING_SETUP_SQPOLL)) ==\n\t\t\t\tIORING_SETUP_ATTACH_WQ) {\n\t\tstruct fd f;\n\n\t\tf = fdget(p->wq_fd);\n\t\tif (!f.file)\n\t\t\treturn -ENXIO;\n\t\tif (f.file->f_op != &io_uring_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfdput(f);\n\t}\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tstruct task_struct *tsk;\n\t\tstruct io_sq_data *sqd;\n\t\tbool attached;\n\n\t\tret = security_uring_sqpoll();\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsqd = io_get_sq_data(p, &attached);\n\t\tif (IS_ERR(sqd)) {\n\t\t\tret = PTR_ERR(sqd);\n\t\t\tgoto err;\n\t\t}\n\n\t\tctx->sq_creds = get_current_cred();\n\t\tctx->sq_data = sqd;\n\t\tctx->sq_thread_idle = msecs_to_jiffies(p->sq_thread_idle);\n\t\tif (!ctx->sq_thread_idle)\n\t\t\tctx->sq_thread_idle = HZ;\n\n\t\tio_sq_thread_park(sqd);\n\t\tlist_add(&ctx->sqd_list, &sqd->ctx_list);\n\t\tio_sqd_update_thread_idle(sqd);\n\t\t/* don't attach to a dying SQPOLL thread, would be racy */\n\t\tret = (attached && !sqd->thread) ? -ENXIO : 0;\n\t\tio_sq_thread_unpark(sqd);\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tif (attached)\n\t\t\treturn 0;\n\n\t\tif (p->flags & IORING_SETUP_SQ_AFF) {\n\t\t\tint cpu = p->sq_thread_cpu;\n\n\t\t\tret = -EINVAL;\n\t\t\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\t\t\tgoto err_sqpoll;\n\t\t\tsqd->sq_cpu = cpu;\n\t\t} else {\n\t\t\tsqd->sq_cpu = -1;\n\t\t}\n\n\t\tsqd->task_pid = current->pid;\n\t\tsqd->task_tgid = current->tgid;\n\t\ttsk = create_io_thread(io_sq_thread, sqd, NUMA_NO_NODE);\n\t\tif (IS_ERR(tsk)) {\n\t\t\tret = PTR_ERR(tsk);\n\t\t\tgoto err_sqpoll;\n\t\t}\n\n\t\tsqd->thread = tsk;\n\t\tret = io_uring_alloc_task_context(tsk, ctx);\n\t\twake_up_new_task(tsk);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (p->flags & IORING_SETUP_SQ_AFF) {\n\t\t/* Can't have SQ_AFF without SQPOLL */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr_sqpoll:\n\tcomplete(&ctx->sq_data->exited);\nerr:\n\tio_sq_thread_finish(ctx);\n\treturn ret;\n}\n\nstatic inline void __io_unaccount_mem(struct user_struct *user,\n\t\t\t\t      unsigned long nr_pages)\n{\n\tatomic_long_sub(nr_pages, &user->locked_vm);\n}\n\nstatic inline int __io_account_mem(struct user_struct *user,\n\t\t\t\t   unsigned long nr_pages)\n{\n\tunsigned long page_limit, cur_pages, new_pages;\n\n\t/* Don't allow more pages than we can safely lock */\n\tpage_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tdo {\n\t\tcur_pages = atomic_long_read(&user->locked_vm);\n\t\tnew_pages = cur_pages + nr_pages;\n\t\tif (new_pages > page_limit)\n\t\t\treturn -ENOMEM;\n\t} while (atomic_long_cmpxchg(&user->locked_vm, cur_pages,\n\t\t\t\t\tnew_pages) != cur_pages);\n\n\treturn 0;\n}\n\nstatic void io_unaccount_mem(struct io_ring_ctx *ctx, unsigned long nr_pages)\n{\n\tif (ctx->user)\n\t\t__io_unaccount_mem(ctx->user, nr_pages);\n\n\tif (ctx->mm_account)\n\t\tatomic64_sub(nr_pages, &ctx->mm_account->pinned_vm);\n}\n\nstatic int io_account_mem(struct io_ring_ctx *ctx, unsigned long nr_pages)\n{\n\tint ret;\n\n\tif (ctx->user) {\n\t\tret = __io_account_mem(ctx->user, nr_pages);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ctx->mm_account)\n\t\tatomic64_add(nr_pages, &ctx->mm_account->pinned_vm);\n\n\treturn 0;\n}\n\nstatic void io_mem_free(void *ptr)\n{\n\tstruct page *page;\n\n\tif (!ptr)\n\t\treturn;\n\n\tpage = virt_to_head_page(ptr);\n\tif (put_page_testzero(page))\n\t\tfree_compound_page(page);\n}\n\nstatic void *io_mem_alloc(size_t size)\n{\n\tgfp_t gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;\n\n\treturn (void *) __get_free_pages(gfp, get_order(size));\n}\n\nstatic unsigned long rings_size(unsigned sq_entries, unsigned cq_entries,\n\t\t\t\tsize_t *sq_offset)\n{\n\tstruct io_rings *rings;\n\tsize_t off, sq_array_size;\n\n\toff = struct_size(rings, cqes, cq_entries);\n\tif (off == SIZE_MAX)\n\t\treturn SIZE_MAX;\n\n#ifdef CONFIG_SMP\n\toff = ALIGN(off, SMP_CACHE_BYTES);\n\tif (off == 0)\n\t\treturn SIZE_MAX;\n#endif\n\n\tif (sq_offset)\n\t\t*sq_offset = off;\n\n\tsq_array_size = array_size(sizeof(u32), sq_entries);\n\tif (sq_array_size == SIZE_MAX)\n\t\treturn SIZE_MAX;\n\n\tif (check_add_overflow(off, sq_array_size, &off))\n\t\treturn SIZE_MAX;\n\n\treturn off;\n}\n\nstatic void io_buffer_unmap(struct io_ring_ctx *ctx, struct io_mapped_ubuf **slot)\n{\n\tstruct io_mapped_ubuf *imu = *slot;\n\tunsigned int i;\n\n\tif (imu != ctx->dummy_ubuf) {\n\t\tfor (i = 0; i < imu->nr_bvecs; i++)\n\t\t\tunpin_user_page(imu->bvec[i].bv_page);\n\t\tif (imu->acct_pages)\n\t\t\tio_unaccount_mem(ctx, imu->acct_pages);\n\t\tkvfree(imu);\n\t}\n\t*slot = NULL;\n}\n\nstatic void io_rsrc_buf_put(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc)\n{\n\tio_buffer_unmap(ctx, &prsrc->buf);\n\tprsrc->buf = NULL;\n}\n\nstatic void __io_sqe_buffers_unregister(struct io_ring_ctx *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ctx->nr_user_bufs; i++)\n\t\tio_buffer_unmap(ctx, &ctx->user_bufs[i]);\n\tkfree(ctx->user_bufs);\n\tio_rsrc_data_free(ctx->buf_data);\n\tctx->user_bufs = NULL;\n\tctx->buf_data = NULL;\n\tctx->nr_user_bufs = 0;\n}\n\nstatic int io_sqe_buffers_unregister(struct io_ring_ctx *ctx)\n{\n\tint ret;\n\n\tif (!ctx->buf_data)\n\t\treturn -ENXIO;\n\n\tret = io_rsrc_ref_quiesce(ctx->buf_data, ctx);\n\tif (!ret)\n\t\t__io_sqe_buffers_unregister(ctx);\n\treturn ret;\n}\n\nstatic int io_copy_iov(struct io_ring_ctx *ctx, struct iovec *dst,\n\t\t       void __user *arg, unsigned index)\n{\n\tstruct iovec __user *src;\n\n#ifdef CONFIG_COMPAT\n\tif (ctx->compat) {\n\t\tstruct compat_iovec __user *ciovs;\n\t\tstruct compat_iovec ciov;\n\n\t\tciovs = (struct compat_iovec __user *) arg;\n\t\tif (copy_from_user(&ciov, &ciovs[index], sizeof(ciov)))\n\t\t\treturn -EFAULT;\n\n\t\tdst->iov_base = u64_to_user_ptr((u64)ciov.iov_base);\n\t\tdst->iov_len = ciov.iov_len;\n\t\treturn 0;\n\t}\n#endif\n\tsrc = (struct iovec __user *) arg;\n\tif (copy_from_user(dst, &src[index], sizeof(*dst)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * Not super efficient, but this is just a registration time. And we do cache\n * the last compound head, so generally we'll only do a full search if we don't\n * match that one.\n *\n * We check if the given compound head page has already been accounted, to\n * avoid double accounting it. This allows us to account the full size of the\n * page, not just the constituent pages of a huge page.\n */\nstatic bool headpage_already_acct(struct io_ring_ctx *ctx, struct page **pages,\n\t\t\t\t  int nr_pages, struct page *hpage)\n{\n\tint i, j;\n\n\t/* check current page array */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!PageCompound(pages[i]))\n\t\t\tcontinue;\n\t\tif (compound_head(pages[i]) == hpage)\n\t\t\treturn true;\n\t}\n\n\t/* check previously registered pages */\n\tfor (i = 0; i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *imu = ctx->user_bufs[i];\n\n\t\tfor (j = 0; j < imu->nr_bvecs; j++) {\n\t\t\tif (!PageCompound(imu->bvec[j].bv_page))\n\t\t\t\tcontinue;\n\t\t\tif (compound_head(imu->bvec[j].bv_page) == hpage)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int io_buffer_account_pin(struct io_ring_ctx *ctx, struct page **pages,\n\t\t\t\t int nr_pages, struct io_mapped_ubuf *imu,\n\t\t\t\t struct page **last_hpage)\n{\n\tint i, ret;\n\n\timu->acct_pages = 0;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!PageCompound(pages[i])) {\n\t\t\timu->acct_pages++;\n\t\t} else {\n\t\t\tstruct page *hpage;\n\n\t\t\thpage = compound_head(pages[i]);\n\t\t\tif (hpage == *last_hpage)\n\t\t\t\tcontinue;\n\t\t\t*last_hpage = hpage;\n\t\t\tif (headpage_already_acct(ctx, pages, i, hpage))\n\t\t\t\tcontinue;\n\t\t\timu->acct_pages += page_size(hpage) >> PAGE_SHIFT;\n\t\t}\n\t}\n\n\tif (!imu->acct_pages)\n\t\treturn 0;\n\n\tret = io_account_mem(ctx, imu->acct_pages);\n\tif (ret)\n\t\timu->acct_pages = 0;\n\treturn ret;\n}\n\nstatic int io_sqe_buffer_register(struct io_ring_ctx *ctx, struct iovec *iov,\n\t\t\t\t  struct io_mapped_ubuf **pimu,\n\t\t\t\t  struct page **last_hpage)\n{\n\tstruct io_mapped_ubuf *imu = NULL;\n\tstruct vm_area_struct **vmas = NULL;\n\tstruct page **pages = NULL;\n\tunsigned long off, start, end, ubuf;\n\tsize_t size;\n\tint ret, pret, nr_pages, i;\n\n\tif (!iov->iov_base) {\n\t\t*pimu = ctx->dummy_ubuf;\n\t\treturn 0;\n\t}\n\n\tubuf = (unsigned long) iov->iov_base;\n\tend = (ubuf + iov->iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstart = ubuf >> PAGE_SHIFT;\n\tnr_pages = end - start;\n\n\t*pimu = NULL;\n\tret = -ENOMEM;\n\n\tpages = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto done;\n\n\tvmas = kvmalloc_array(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t      GFP_KERNEL);\n\tif (!vmas)\n\t\tgoto done;\n\n\timu = kvmalloc(struct_size(imu, bvec, nr_pages), GFP_KERNEL);\n\tif (!imu)\n\t\tgoto done;\n\n\tret = 0;\n\tmmap_read_lock(current->mm);\n\tpret = pin_user_pages(ubuf, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t      pages, vmas);\n\tif (pret == nr_pages) {\n\t\t/* don't support file backed memory */\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\t\tif (vma_is_shmem(vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_file &&\n\t\t\t    !is_file_hugepages(vma->vm_file)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = pret < 0 ? pret : -EFAULT;\n\t}\n\tmmap_read_unlock(current->mm);\n\tif (ret) {\n\t\t/*\n\t\t * if we did partial map, or found file backed vmas,\n\t\t * release any pages we did get\n\t\t */\n\t\tif (pret > 0)\n\t\t\tunpin_user_pages(pages, pret);\n\t\tgoto done;\n\t}\n\n\tret = io_buffer_account_pin(ctx, pages, pret, imu, last_hpage);\n\tif (ret) {\n\t\tunpin_user_pages(pages, pret);\n\t\tgoto done;\n\t}\n\n\toff = ubuf & ~PAGE_MASK;\n\tsize = iov->iov_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t vec_len;\n\n\t\tvec_len = min_t(size_t, size, PAGE_SIZE - off);\n\t\timu->bvec[i].bv_page = pages[i];\n\t\timu->bvec[i].bv_len = vec_len;\n\t\timu->bvec[i].bv_offset = off;\n\t\toff = 0;\n\t\tsize -= vec_len;\n\t}\n\t/* store original address for later verification */\n\timu->ubuf = ubuf;\n\timu->ubuf_end = ubuf + iov->iov_len;\n\timu->nr_bvecs = nr_pages;\n\t*pimu = imu;\n\tret = 0;\ndone:\n\tif (ret)\n\t\tkvfree(imu);\n\tkvfree(pages);\n\tkvfree(vmas);\n\treturn ret;\n}\n\nstatic int io_buffers_map_alloc(struct io_ring_ctx *ctx, unsigned int nr_args)\n{\n\tctx->user_bufs = kcalloc(nr_args, sizeof(*ctx->user_bufs), GFP_KERNEL);\n\treturn ctx->user_bufs ? 0 : -ENOMEM;\n}\n\nstatic int io_buffer_validate(struct iovec *iov)\n{\n\tunsigned long tmp, acct_len = iov->iov_len + (PAGE_SIZE - 1);\n\n\t/*\n\t * Don't impose further limits on the size and buffer\n\t * constraints here, we'll -EINVAL later when IO is\n\t * submitted if they are wrong.\n\t */\n\tif (!iov->iov_base)\n\t\treturn iov->iov_len ? -EFAULT : 0;\n\tif (!iov->iov_len)\n\t\treturn -EFAULT;\n\n\t/* arbitrary limit, but we need something */\n\tif (iov->iov_len > SZ_1G)\n\t\treturn -EFAULT;\n\n\tif (check_add_overflow((unsigned long)iov->iov_base, acct_len, &tmp))\n\t\treturn -EOVERFLOW;\n\n\treturn 0;\n}\n\nstatic int io_sqe_buffers_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t   unsigned int nr_args, u64 __user *tags)\n{\n\tstruct page *last_hpage = NULL;\n\tstruct io_rsrc_data *data;\n\tint i, ret;\n\tstruct iovec iov;\n\n\tif (ctx->user_bufs)\n\t\treturn -EBUSY;\n\tif (!nr_args || nr_args > IORING_MAX_REG_BUFFERS)\n\t\treturn -EINVAL;\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\treturn ret;\n\tret = io_rsrc_data_alloc(ctx, io_rsrc_buf_put, tags, nr_args, &data);\n\tif (ret)\n\t\treturn ret;\n\tret = io_buffers_map_alloc(ctx, nr_args);\n\tif (ret) {\n\t\tio_rsrc_data_free(data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_args; i++, ctx->nr_user_bufs++) {\n\t\tret = io_copy_iov(ctx, &iov, arg, i);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = io_buffer_validate(&iov);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!iov.iov_base && *io_get_tag_slot(data, i)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_sqe_buffer_register(ctx, &iov, &ctx->user_bufs[i],\n\t\t\t\t\t     &last_hpage);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(ctx->buf_data);\n\n\tctx->buf_data = data;\n\tif (ret)\n\t\t__io_sqe_buffers_unregister(ctx);\n\telse\n\t\tio_rsrc_node_switch(ctx, NULL);\n\treturn ret;\n}\n\nstatic int __io_sqe_buffers_update(struct io_ring_ctx *ctx,\n\t\t\t\t   struct io_uring_rsrc_update2 *up,\n\t\t\t\t   unsigned int nr_args)\n{\n\tu64 __user *tags = u64_to_user_ptr(up->tags);\n\tstruct iovec iov, __user *iovs = u64_to_user_ptr(up->data);\n\tstruct page *last_hpage = NULL;\n\tbool needs_switch = false;\n\t__u32 done;\n\tint i, err;\n\n\tif (!ctx->buf_data)\n\t\treturn -ENXIO;\n\tif (up->offset + nr_args > ctx->nr_user_bufs)\n\t\treturn -EINVAL;\n\n\tfor (done = 0; done < nr_args; done++) {\n\t\tstruct io_mapped_ubuf *imu;\n\t\tint offset = up->offset + done;\n\t\tu64 tag = 0;\n\n\t\terr = io_copy_iov(ctx, &iov, iovs, done);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (tags && copy_from_user(&tag, &tags[done], sizeof(tag))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = io_buffer_validate(&iov);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!iov.iov_base && tag) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = io_sqe_buffer_register(ctx, &iov, &imu, &last_hpage);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\ti = array_index_nospec(offset, ctx->nr_user_bufs);\n\t\tif (ctx->user_bufs[i] != ctx->dummy_ubuf) {\n\t\t\terr = io_queue_rsrc_removal(ctx->buf_data, i,\n\t\t\t\t\t\t    ctx->rsrc_node, ctx->user_bufs[i]);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tio_buffer_unmap(ctx, &imu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx->user_bufs[i] = NULL;\n\t\t\tneeds_switch = true;\n\t\t}\n\n\t\tctx->user_bufs[i] = imu;\n\t\t*io_get_tag_slot(ctx->buf_data, offset) = tag;\n\t}\n\n\tif (needs_switch)\n\t\tio_rsrc_node_switch(ctx, ctx->buf_data);\n\treturn done ? done : err;\n}\n\nstatic int io_eventfd_register(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t       unsigned int eventfd_async)\n{\n\tstruct io_ev_fd *ev_fd;\n\t__s32 __user *fds = arg;\n\tint fd;\n\n\tev_fd = rcu_dereference_protected(ctx->io_ev_fd,\n\t\t\t\t\tlockdep_is_held(&ctx->uring_lock));\n\tif (ev_fd)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&fd, fds, sizeof(*fds)))\n\t\treturn -EFAULT;\n\n\tev_fd = kmalloc(sizeof(*ev_fd), GFP_KERNEL);\n\tif (!ev_fd)\n\t\treturn -ENOMEM;\n\n\tev_fd->cq_ev_fd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(ev_fd->cq_ev_fd)) {\n\t\tint ret = PTR_ERR(ev_fd->cq_ev_fd);\n\t\tkfree(ev_fd);\n\t\treturn ret;\n\t}\n\tev_fd->eventfd_async = eventfd_async;\n\tctx->has_evfd = true;\n\trcu_assign_pointer(ctx->io_ev_fd, ev_fd);\n\treturn 0;\n}\n\nstatic void io_eventfd_put(struct rcu_head *rcu)\n{\n\tstruct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);\n\n\teventfd_ctx_put(ev_fd->cq_ev_fd);\n\tkfree(ev_fd);\n}\n\nstatic int io_eventfd_unregister(struct io_ring_ctx *ctx)\n{\n\tstruct io_ev_fd *ev_fd;\n\n\tev_fd = rcu_dereference_protected(ctx->io_ev_fd,\n\t\t\t\t\tlockdep_is_held(&ctx->uring_lock));\n\tif (ev_fd) {\n\t\tctx->has_evfd = false;\n\t\trcu_assign_pointer(ctx->io_ev_fd, NULL);\n\t\tcall_rcu(&ev_fd->rcu, io_eventfd_put);\n\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic void io_destroy_buffers(struct io_ring_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < (1U << IO_BUFFERS_HASH_BITS); i++) {\n\t\tstruct list_head *list = &ctx->io_buffers[i];\n\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct io_buffer_list *bl;\n\n\t\t\tbl = list_first_entry(list, struct io_buffer_list, list);\n\t\t\t__io_remove_buffers(ctx, bl, -1U);\n\t\t\tlist_del(&bl->list);\n\t\t\tkfree(bl);\n\t\t}\n\t}\n\n\twhile (!list_empty(&ctx->io_buffers_pages)) {\n\t\tstruct page *page;\n\n\t\tpage = list_first_entry(&ctx->io_buffers_pages, struct page, lru);\n\t\tlist_del_init(&page->lru);\n\t\t__free_page(page);\n\t}\n}\n\nstatic void io_req_caches_free(struct io_ring_ctx *ctx)\n{\n\tstruct io_submit_state *state = &ctx->submit_state;\n\tint nr = 0;\n\n\tmutex_lock(&ctx->uring_lock);\n\tio_flush_cached_locked_reqs(ctx, state);\n\n\twhile (state->free_list.next) {\n\t\tstruct io_wq_work_node *node;\n\t\tstruct io_kiocb *req;\n\n\t\tnode = wq_stack_extract(&state->free_list);\n\t\treq = container_of(node, struct io_kiocb, comp_list);\n\t\tkmem_cache_free(req_cachep, req);\n\t\tnr++;\n\t}\n\tif (nr)\n\t\tpercpu_ref_put_many(&ctx->refs, nr);\n\tmutex_unlock(&ctx->uring_lock);\n}\n\nstatic void io_wait_rsrc_data(struct io_rsrc_data *data)\n{\n\tif (data && !atomic_dec_and_test(&data->refs))\n\t\twait_for_completion(&data->done);\n}\n\nstatic void io_flush_apoll_cache(struct io_ring_ctx *ctx)\n{\n\tstruct async_poll *apoll;\n\n\twhile (!list_empty(&ctx->apoll_cache)) {\n\t\tapoll = list_first_entry(&ctx->apoll_cache, struct async_poll,\n\t\t\t\t\t\tpoll.wait.entry);\n\t\tlist_del(&apoll->poll.wait.entry);\n\t\tkfree(apoll);\n\t}\n}\n\nstatic __cold void io_ring_ctx_free(struct io_ring_ctx *ctx)\n{\n\tio_sq_thread_finish(ctx);\n\n\tif (ctx->mm_account) {\n\t\tmmdrop(ctx->mm_account);\n\t\tctx->mm_account = NULL;\n\t}\n\n\tio_rsrc_refs_drop(ctx);\n\t/* __io_rsrc_put_work() may need uring_lock to progress, wait w/o it */\n\tio_wait_rsrc_data(ctx->buf_data);\n\tio_wait_rsrc_data(ctx->file_data);\n\n\tmutex_lock(&ctx->uring_lock);\n\tif (ctx->buf_data)\n\t\t__io_sqe_buffers_unregister(ctx);\n\tif (ctx->file_data)\n\t\t__io_sqe_files_unregister(ctx);\n\tif (ctx->rings)\n\t\t__io_cqring_overflow_flush(ctx, true);\n\tio_eventfd_unregister(ctx);\n\tio_flush_apoll_cache(ctx);\n\tmutex_unlock(&ctx->uring_lock);\n\tio_destroy_buffers(ctx);\n\tif (ctx->sq_creds)\n\t\tput_cred(ctx->sq_creds);\n\n\t/* there are no registered resources left, nobody uses it */\n\tif (ctx->rsrc_node)\n\t\tio_rsrc_node_destroy(ctx->rsrc_node);\n\tif (ctx->rsrc_backup_node)\n\t\tio_rsrc_node_destroy(ctx->rsrc_backup_node);\n\tflush_delayed_work(&ctx->rsrc_put_work);\n\tflush_delayed_work(&ctx->fallback_work);\n\n\tWARN_ON_ONCE(!list_empty(&ctx->rsrc_ref_list));\n\tWARN_ON_ONCE(!llist_empty(&ctx->rsrc_put_llist));\n\n#if defined(CONFIG_UNIX)\n\tif (ctx->ring_sock) {\n\t\tctx->ring_sock->file = NULL; /* so that iput() is called */\n\t\tsock_release(ctx->ring_sock);\n\t}\n#endif\n\tWARN_ON_ONCE(!list_empty(&ctx->ltimeout_list));\n\n\tio_mem_free(ctx->rings);\n\tio_mem_free(ctx->sq_sqes);\n\n\tpercpu_ref_exit(&ctx->refs);\n\tfree_uid(ctx->user);\n\tio_req_caches_free(ctx);\n\tif (ctx->hash_map)\n\t\tio_wq_put_hash(ctx->hash_map);\n\tkfree(ctx->cancel_hash);\n\tkfree(ctx->dummy_ubuf);\n\tkfree(ctx->io_buffers);\n\tkfree(ctx);\n}\n\nstatic __poll_t io_uring_poll(struct file *file, poll_table *wait)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &ctx->cq_wait, wait);\n\t/*\n\t * synchronizes with barrier from wq_has_sleeper call in\n\t * io_commit_cqring\n\t */\n\tsmp_rmb();\n\tif (!io_sqring_full(ctx))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\t/*\n\t * Don't flush cqring overflow list here, just do a simple check.\n\t * Otherwise there could possible be ABBA deadlock:\n\t *      CPU0                    CPU1\n\t *      ----                    ----\n\t * lock(&ctx->uring_lock);\n\t *                              lock(&ep->mtx);\n\t *                              lock(&ctx->uring_lock);\n\t * lock(&ep->mtx);\n\t *\n\t * Users may get EPOLLIN meanwhile seeing nothing in cqring, this\n\t * pushs them to do the flush.\n\t */\n\tif (io_cqring_events(ctx) || test_bit(0, &ctx->check_cq_overflow))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)\n{\n\tconst struct cred *creds;\n\n\tcreds = xa_erase(&ctx->personalities, id);\n\tif (creds) {\n\t\tput_cred(creds);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstruct io_tctx_exit {\n\tstruct callback_head\t\ttask_work;\n\tstruct completion\t\tcompletion;\n\tstruct io_ring_ctx\t\t*ctx;\n};\n\nstatic __cold void io_tctx_exit_cb(struct callback_head *cb)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_exit *work;\n\n\twork = container_of(cb, struct io_tctx_exit, task_work);\n\t/*\n\t * When @in_idle, we're in cancellation and it's racy to remove the\n\t * node. It'll be removed by the end of cancellation, just ignore it.\n\t */\n\tif (!atomic_read(&tctx->in_idle))\n\t\tio_uring_del_tctx_node((unsigned long)work->ctx);\n\tcomplete(&work->completion);\n}\n\nstatic __cold bool io_cancel_ctx_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\n\treturn req->ctx == data;\n}\n\nstatic __cold void io_ring_exit_work(struct work_struct *work)\n{\n\tstruct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx, exit_work);\n\tunsigned long timeout = jiffies + HZ * 60 * 5;\n\tunsigned long interval = HZ / 20;\n\tstruct io_tctx_exit exit;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\t/*\n\t * If we're doing polled IO and end up having requests being\n\t * submitted async (out-of-line), then completions can come in while\n\t * we're waiting for refs to drop. We need to reap these manually,\n\t * as nobody else will be looking for them.\n\t */\n\tdo {\n\t\tio_uring_try_cancel_requests(ctx, NULL, true);\n\t\tif (ctx->sq_data) {\n\t\t\tstruct io_sq_data *sqd = ctx->sq_data;\n\t\t\tstruct task_struct *tsk;\n\n\t\t\tio_sq_thread_park(sqd);\n\t\t\ttsk = sqd->thread;\n\t\t\tif (tsk && tsk->io_uring && tsk->io_uring->io_wq)\n\t\t\t\tio_wq_cancel_cb(tsk->io_uring->io_wq,\n\t\t\t\t\t\tio_cancel_ctx_cb, ctx, true);\n\t\t\tio_sq_thread_unpark(sqd);\n\t\t}\n\n\t\tio_req_caches_free(ctx);\n\n\t\tif (WARN_ON_ONCE(time_after(jiffies, timeout))) {\n\t\t\t/* there is little hope left, don't run it too often */\n\t\t\tinterval = HZ * 60;\n\t\t}\n\t} while (!wait_for_completion_timeout(&ctx->ref_comp, interval));\n\n\tinit_completion(&exit.completion);\n\tinit_task_work(&exit.task_work, io_tctx_exit_cb);\n\texit.ctx = ctx;\n\t/*\n\t * Some may use context even when all refs and requests have been put,\n\t * and they are free to do so while still holding uring_lock or\n\t * completion_lock, see io_req_task_submit(). Apart from other work,\n\t * this lock/unlock section also waits them to finish.\n\t */\n\tmutex_lock(&ctx->uring_lock);\n\twhile (!list_empty(&ctx->tctx_list)) {\n\t\tWARN_ON_ONCE(time_after(jiffies, timeout));\n\n\t\tnode = list_first_entry(&ctx->tctx_list, struct io_tctx_node,\n\t\t\t\t\tctx_node);\n\t\t/* don't spin on a single task if cancellation failed */\n\t\tlist_rotate_left(&ctx->tctx_list);\n\t\tret = task_work_add(node->task, &exit.task_work, TWA_SIGNAL);\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\tcontinue;\n\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\twait_for_completion(&exit.completion);\n\t\tmutex_lock(&ctx->uring_lock);\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\tspin_lock(&ctx->completion_lock);\n\tspin_unlock(&ctx->completion_lock);\n\n\tio_ring_ctx_free(ctx);\n}\n\n/* Returns true if we found and killed one or more timeouts */\nstatic __cold bool io_kill_timeouts(struct io_ring_ctx *ctx,\n\t\t\t\t    struct task_struct *tsk, bool cancel_all)\n{\n\tstruct io_kiocb *req, *tmp;\n\tint canceled = 0;\n\n\tspin_lock(&ctx->completion_lock);\n\tspin_lock_irq(&ctx->timeout_lock);\n\tlist_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {\n\t\tif (io_match_task(req, tsk, cancel_all)) {\n\t\t\tio_kill_timeout(req, -ECANCELED);\n\t\t\tcanceled++;\n\t\t}\n\t}\n\tspin_unlock_irq(&ctx->timeout_lock);\n\tif (canceled != 0)\n\t\tio_commit_cqring(ctx);\n\tspin_unlock(&ctx->completion_lock);\n\tif (canceled != 0)\n\t\tio_cqring_ev_posted(ctx);\n\treturn canceled != 0;\n}\n\nstatic __cold void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)\n{\n\tunsigned long index;\n\tstruct creds *creds;\n\n\tmutex_lock(&ctx->uring_lock);\n\tpercpu_ref_kill(&ctx->refs);\n\tif (ctx->rings)\n\t\t__io_cqring_overflow_flush(ctx, true);\n\txa_for_each(&ctx->personalities, index, creds)\n\t\tio_unregister_personality(ctx, index);\n\tmutex_unlock(&ctx->uring_lock);\n\n\tio_kill_timeouts(ctx, NULL, true);\n\tio_poll_remove_all(ctx, NULL, true);\n\n\t/* if we failed setting up the ctx, we might not have any rings */\n\tio_iopoll_try_reap_events(ctx);\n\n\tINIT_WORK(&ctx->exit_work, io_ring_exit_work);\n\t/*\n\t * Use system_unbound_wq to avoid spawning tons of event kworkers\n\t * if we're exiting a ton of rings at the same time. It just adds\n\t * noise and overhead, there's no discernable change in runtime\n\t * over using system_wq.\n\t */\n\tqueue_work(system_unbound_wq, &ctx->exit_work);\n}\n\nstatic int io_uring_release(struct inode *inode, struct file *file)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\n\tfile->private_data = NULL;\n\tio_ring_ctx_wait_and_kill(ctx);\n\treturn 0;\n}\n\nstruct io_task_cancel {\n\tstruct task_struct *task;\n\tbool all;\n};\n\nstatic bool io_cancel_task_cb(struct io_wq_work *work, void *data)\n{\n\tstruct io_kiocb *req = container_of(work, struct io_kiocb, work);\n\tstruct io_task_cancel *cancel = data;\n\n\treturn io_match_task_safe(req, cancel->task, cancel->all);\n}\n\nstatic __cold bool io_cancel_defer_files(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct task_struct *task,\n\t\t\t\t\t bool cancel_all)\n{\n\tstruct io_defer_entry *de;\n\tLIST_HEAD(list);\n\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry_reverse(de, &ctx->defer_list, list) {\n\t\tif (io_match_task_safe(de->req, task, cancel_all)) {\n\t\t\tlist_cut_position(&list, &ctx->defer_list, &de->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\tif (list_empty(&list))\n\t\treturn false;\n\n\twhile (!list_empty(&list)) {\n\t\tde = list_first_entry(&list, struct io_defer_entry, list);\n\t\tlist_del_init(&de->list);\n\t\tio_req_complete_failed(de->req, -ECANCELED);\n\t\tkfree(de);\n\t}\n\treturn true;\n}\n\nstatic __cold bool io_uring_try_cancel_iowq(struct io_ring_ctx *ctx)\n{\n\tstruct io_tctx_node *node;\n\tenum io_wq_cancel cret;\n\tbool ret = false;\n\n\tmutex_lock(&ctx->uring_lock);\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\t/*\n\t\t * io_wq will stay alive while we hold uring_lock, because it's\n\t\t * killed after ctx nodes, which requires to take the lock.\n\t\t */\n\t\tif (!tctx || !tctx->io_wq)\n\t\t\tcontinue;\n\t\tcret = io_wq_cancel_cb(tctx->io_wq, io_cancel_ctx_cb, ctx, true);\n\t\tret |= (cret != IO_WQ_CANCEL_NOTFOUND);\n\t}\n\tmutex_unlock(&ctx->uring_lock);\n\n\treturn ret;\n}\n\nstatic __cold void io_uring_try_cancel_requests(struct io_ring_ctx *ctx,\n\t\t\t\t\t\tstruct task_struct *task,\n\t\t\t\t\t\tbool cancel_all)\n{\n\tstruct io_task_cancel cancel = { .task = task, .all = cancel_all, };\n\tstruct io_uring_task *tctx = task ? task->io_uring : NULL;\n\n\twhile (1) {\n\t\tenum io_wq_cancel cret;\n\t\tbool ret = false;\n\n\t\tif (!task) {\n\t\t\tret |= io_uring_try_cancel_iowq(ctx);\n\t\t} else if (tctx && tctx->io_wq) {\n\t\t\t/*\n\t\t\t * Cancels requests of all rings, not only @ctx, but\n\t\t\t * it's fine as the task is in exit/exec.\n\t\t\t */\n\t\t\tcret = io_wq_cancel_cb(tctx->io_wq, io_cancel_task_cb,\n\t\t\t\t\t       &cancel, true);\n\t\t\tret |= (cret != IO_WQ_CANCEL_NOTFOUND);\n\t\t}\n\n\t\t/* SQPOLL thread does its own polling */\n\t\tif ((!(ctx->flags & IORING_SETUP_SQPOLL) && cancel_all) ||\n\t\t    (ctx->sq_data && ctx->sq_data->thread == current)) {\n\t\t\twhile (!wq_list_empty(&ctx->iopoll_list)) {\n\t\t\t\tio_iopoll_try_reap_events(ctx);\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\n\t\tret |= io_cancel_defer_files(ctx, task, cancel_all);\n\t\tret |= io_poll_remove_all(ctx, task, cancel_all);\n\t\tret |= io_kill_timeouts(ctx, task, cancel_all);\n\t\tif (task)\n\t\t\tret |= io_run_task_work();\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}\n\nstatic int __io_uring_add_tctx_node(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_node *node;\n\tint ret;\n\n\tif (unlikely(!tctx)) {\n\t\tret = io_uring_alloc_task_context(current, ctx);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\ttctx = current->io_uring;\n\t\tif (ctx->iowq_limits_set) {\n\t\t\tunsigned int limits[2] = { ctx->iowq_limits[0],\n\t\t\t\t\t\t   ctx->iowq_limits[1], };\n\n\t\t\tret = io_wq_max_workers(tctx->io_wq, limits);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!xa_load(&tctx->xa, (unsigned long)ctx)) {\n\t\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\t\tnode->ctx = ctx;\n\t\tnode->task = current;\n\n\t\tret = xa_err(xa_store(&tctx->xa, (unsigned long)ctx,\n\t\t\t\t\tnode, GFP_KERNEL));\n\t\tif (ret) {\n\t\t\tkfree(node);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tlist_add(&node->ctx_node, &ctx->tctx_list);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\ttctx->last = ctx;\n\treturn 0;\n}\n\n/*\n * Note that this task has used io_uring. We use it for cancelation purposes.\n */\nstatic inline int io_uring_add_tctx_node(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\tif (likely(tctx && tctx->last == ctx))\n\t\treturn 0;\n\treturn __io_uring_add_tctx_node(ctx);\n}\n\n/*\n * Remove this io_uring_file -> task mapping.\n */\nstatic __cold void io_uring_del_tctx_node(unsigned long index)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_tctx_node *node;\n\n\tif (!tctx)\n\t\treturn;\n\tnode = xa_erase(&tctx->xa, index);\n\tif (!node)\n\t\treturn;\n\n\tWARN_ON_ONCE(current != node->task);\n\tWARN_ON_ONCE(list_empty(&node->ctx_node));\n\n\tmutex_lock(&node->ctx->uring_lock);\n\tlist_del(&node->ctx_node);\n\tmutex_unlock(&node->ctx->uring_lock);\n\n\tif (tctx->last == node->ctx)\n\t\ttctx->last = NULL;\n\tkfree(node);\n}\n\nstatic __cold void io_uring_clean_tctx(struct io_uring_task *tctx)\n{\n\tstruct io_wq *wq = tctx->io_wq;\n\tstruct io_tctx_node *node;\n\tunsigned long index;\n\n\txa_for_each(&tctx->xa, index, node) {\n\t\tio_uring_del_tctx_node(index);\n\t\tcond_resched();\n\t}\n\tif (wq) {\n\t\t/*\n\t\t * Must be after io_uring_del_tctx_node() (removes nodes under\n\t\t * uring_lock) to avoid race with io_uring_try_cancel_iowq().\n\t\t */\n\t\tio_wq_put_and_exit(wq);\n\t\ttctx->io_wq = NULL;\n\t}\n}\n\nstatic s64 tctx_inflight(struct io_uring_task *tctx, bool tracked)\n{\n\tif (tracked)\n\t\treturn 0;\n\treturn percpu_counter_sum(&tctx->inflight);\n}\n\n/*\n * Find any io_uring ctx that this task has registered or done IO on, and cancel\n * requests. @sqd should be not-null IFF it's an SQPOLL thread cancellation.\n */\nstatic __cold void io_uring_cancel_generic(bool cancel_all,\n\t\t\t\t\t   struct io_sq_data *sqd)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_ring_ctx *ctx;\n\ts64 inflight;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON_ONCE(sqd && sqd->thread != current);\n\n\tif (!current->io_uring)\n\t\treturn;\n\tif (tctx->io_wq)\n\t\tio_wq_exit_start(tctx->io_wq);\n\n\tatomic_inc(&tctx->in_idle);\n\tdo {\n\t\tio_uring_drop_tctx_refs(current);\n\t\t/* read completions before cancelations */\n\t\tinflight = tctx_inflight(tctx, !cancel_all);\n\t\tif (!inflight)\n\t\t\tbreak;\n\n\t\tif (!sqd) {\n\t\t\tstruct io_tctx_node *node;\n\t\t\tunsigned long index;\n\n\t\t\txa_for_each(&tctx->xa, index, node) {\n\t\t\t\t/* sqpoll task will cancel all its requests */\n\t\t\t\tif (node->ctx->sq_data)\n\t\t\t\t\tcontinue;\n\t\t\t\tio_uring_try_cancel_requests(node->ctx, current,\n\t\t\t\t\t\t\t     cancel_all);\n\t\t\t}\n\t\t} else {\n\t\t\tlist_for_each_entry(ctx, &sqd->ctx_list, sqd_list)\n\t\t\t\tio_uring_try_cancel_requests(ctx, current,\n\t\t\t\t\t\t\t     cancel_all);\n\t\t}\n\n\t\tprepare_to_wait(&tctx->wait, &wait, TASK_INTERRUPTIBLE);\n\t\tio_run_task_work();\n\t\tio_uring_drop_tctx_refs(current);\n\n\t\t/*\n\t\t * If we've seen completions, retry without waiting. This\n\t\t * avoids a race where a completion comes in before we did\n\t\t * prepare_to_wait().\n\t\t */\n\t\tif (inflight == tctx_inflight(tctx, !cancel_all))\n\t\t\tschedule();\n\t\tfinish_wait(&tctx->wait, &wait);\n\t} while (1);\n\n\tio_uring_clean_tctx(tctx);\n\tif (cancel_all) {\n\t\t/*\n\t\t * We shouldn't run task_works after cancel, so just leave\n\t\t * ->in_idle set for normal exit.\n\t\t */\n\t\tatomic_dec(&tctx->in_idle);\n\t\t/* for exec all current's requests should be gone, kill tctx */\n\t\t__io_uring_free(current);\n\t}\n}\n\nvoid __io_uring_cancel(bool cancel_all)\n{\n\tio_uring_cancel_generic(cancel_all, NULL);\n}\n\nvoid io_uring_unreg_ringfd(void)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tint i;\n\n\tfor (i = 0; i < IO_RINGFD_REG_MAX; i++) {\n\t\tif (tctx->registered_rings[i]) {\n\t\t\tfput(tctx->registered_rings[i]);\n\t\t\ttctx->registered_rings[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int io_ring_add_registered_fd(struct io_uring_task *tctx, int fd,\n\t\t\t\t     int start, int end)\n{\n\tstruct file *file;\n\tint offset;\n\n\tfor (offset = start; offset < end; offset++) {\n\t\toffset = array_index_nospec(offset, IO_RINGFD_REG_MAX);\n\t\tif (tctx->registered_rings[offset])\n\t\t\tcontinue;\n\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\treturn -EBADF;\n\t\t} else if (file->f_op != &io_uring_fops) {\n\t\t\tfput(file);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\ttctx->registered_rings[offset] = file;\n\t\treturn offset;\n\t}\n\n\treturn -EBUSY;\n}\n\n/*\n * Register a ring fd to avoid fdget/fdput for each io_uring_enter()\n * invocation. User passes in an array of struct io_uring_rsrc_update\n * with ->data set to the ring_fd, and ->offset given for the desired\n * index. If no index is desired, application may set ->offset == -1U\n * and we'll find an available index. Returns number of entries\n * successfully processed, or < 0 on error if none were processed.\n */\nstatic int io_ringfd_register(struct io_ring_ctx *ctx, void __user *__arg,\n\t\t\t      unsigned nr_args)\n{\n\tstruct io_uring_rsrc_update __user *arg = __arg;\n\tstruct io_uring_rsrc_update reg;\n\tstruct io_uring_task *tctx;\n\tint ret, i;\n\n\tif (!nr_args || nr_args > IO_RINGFD_REG_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_unlock(&ctx->uring_lock);\n\tret = io_uring_add_tctx_node(ctx);\n\tmutex_lock(&ctx->uring_lock);\n\tif (ret)\n\t\treturn ret;\n\n\ttctx = current->io_uring;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tint start, end;\n\n\t\tif (copy_from_user(&reg, &arg[i], sizeof(reg))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (reg.offset == -1U) {\n\t\t\tstart = 0;\n\t\t\tend = IO_RINGFD_REG_MAX;\n\t\t} else {\n\t\t\tif (reg.offset >= IO_RINGFD_REG_MAX) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = reg.offset;\n\t\t\tend = start + 1;\n\t\t}\n\n\t\tret = io_ring_add_registered_fd(tctx, reg.data, start, end);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\treg.offset = ret;\n\t\tif (copy_to_user(&arg[i], &reg, sizeof(reg))) {\n\t\t\tfput(tctx->registered_rings[reg.offset]);\n\t\t\ttctx->registered_rings[reg.offset] = NULL;\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i ? i : ret;\n}\n\nstatic int io_ringfd_unregister(struct io_ring_ctx *ctx, void __user *__arg,\n\t\t\t\tunsigned nr_args)\n{\n\tstruct io_uring_rsrc_update __user *arg = __arg;\n\tstruct io_uring_task *tctx = current->io_uring;\n\tstruct io_uring_rsrc_update reg;\n\tint ret = 0, i;\n\n\tif (!nr_args || nr_args > IO_RINGFD_REG_MAX)\n\t\treturn -EINVAL;\n\tif (!tctx)\n\t\treturn 0;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (copy_from_user(&reg, &arg[i], sizeof(reg))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (reg.offset >= IO_RINGFD_REG_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\treg.offset = array_index_nospec(reg.offset, IO_RINGFD_REG_MAX);\n\t\tif (tctx->registered_rings[reg.offset]) {\n\t\t\tfput(tctx->registered_rings[reg.offset]);\n\t\t\ttctx->registered_rings[reg.offset] = NULL;\n\t\t}\n\t}\n\n\treturn i ? i : ret;\n}\n\nstatic void *io_uring_validate_mmap_request(struct file *file,\n\t\t\t\t\t    loff_t pgoff, size_t sz)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\tloff_t offset = pgoff << PAGE_SHIFT;\n\tstruct page *page;\n\tvoid *ptr;\n\n\tswitch (offset) {\n\tcase IORING_OFF_SQ_RING:\n\tcase IORING_OFF_CQ_RING:\n\t\tptr = ctx->rings;\n\t\tbreak;\n\tcase IORING_OFF_SQES:\n\t\tptr = ctx->sq_sqes;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpage = virt_to_head_page(ptr);\n\tif (sz > page_size(page))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ptr;\n}\n\n#ifdef CONFIG_MMU\n\nstatic __cold int io_uring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t sz = vma->vm_end - vma->vm_start;\n\tunsigned long pfn;\n\tvoid *ptr;\n\n\tptr = io_uring_validate_mmap_request(file, vma->vm_pgoff, sz);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tpfn = virt_to_phys(ptr) >> PAGE_SHIFT;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn, sz, vma->vm_page_prot);\n}\n\n#else /* !CONFIG_MMU */\n\nstatic int io_uring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_SHARED | VM_MAYSHARE) ? 0 : -EINVAL;\n}\n\nstatic unsigned int io_uring_nommu_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_DIRECT | NOMMU_MAP_READ | NOMMU_MAP_WRITE;\n}\n\nstatic unsigned long io_uring_nommu_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len,\n\tunsigned long pgoff, unsigned long flags)\n{\n\tvoid *ptr;\n\n\tptr = io_uring_validate_mmap_request(file, pgoff, len);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\treturn (unsigned long) ptr;\n}\n\n#endif /* !CONFIG_MMU */\n\nstatic int io_sqpoll_wait_sq(struct io_ring_ctx *ctx)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tif (!io_sqring_full(ctx))\n\t\t\tbreak;\n\t\tprepare_to_wait(&ctx->sqo_sq_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (!io_sqring_full(ctx))\n\t\t\tbreak;\n\t\tschedule();\n\t} while (!signal_pending(current));\n\n\tfinish_wait(&ctx->sqo_sq_wait, &wait);\n\treturn 0;\n}\n\nstatic int io_get_ext_arg(unsigned flags, const void __user *argp, size_t *argsz,\n\t\t\t  struct __kernel_timespec __user **ts,\n\t\t\t  const sigset_t __user **sig)\n{\n\tstruct io_uring_getevents_arg arg;\n\n\t/*\n\t * If EXT_ARG isn't set, then we have no timespec and the argp pointer\n\t * is just a pointer to the sigset_t.\n\t */\n\tif (!(flags & IORING_ENTER_EXT_ARG)) {\n\t\t*sig = (const sigset_t __user *) argp;\n\t\t*ts = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * EXT_ARG is set - ensure we agree on the size of it and copy in our\n\t * timespec and sigset_t pointers if good.\n\t */\n\tif (*argsz != sizeof(arg))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&arg, argp, sizeof(arg)))\n\t\treturn -EFAULT;\n\t*sig = u64_to_user_ptr(arg.sigmask);\n\t*argsz = arg.sigmask_sz;\n\t*ts = u64_to_user_ptr(arg.ts);\n\treturn 0;\n}\n\nSYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,\n\t\tu32, min_complete, u32, flags, const void __user *, argp,\n\t\tsize_t, argsz)\n{\n\tstruct io_ring_ctx *ctx;\n\tint submitted = 0;\n\tstruct fd f;\n\tlong ret;\n\n\tio_run_task_work();\n\n\tif (unlikely(flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |\n\t\t\t       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG |\n\t\t\t       IORING_ENTER_REGISTERED_RING)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ring fd has been registered via IORING_REGISTER_RING_FDS, we\n\t * need only dereference our task private array to find it.\n\t */\n\tif (flags & IORING_ENTER_REGISTERED_RING) {\n\t\tstruct io_uring_task *tctx = current->io_uring;\n\n\t\tif (!tctx || fd >= IO_RINGFD_REG_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = array_index_nospec(fd, IO_RINGFD_REG_MAX);\n\t\tf.file = tctx->registered_rings[fd];\n\t\tif (unlikely(!f.file))\n\t\t\treturn -EBADF;\n\t} else {\n\t\tf = fdget(fd);\n\t\tif (unlikely(!f.file))\n\t\t\treturn -EBADF;\n\t}\n\n\tret = -EOPNOTSUPP;\n\tif (unlikely(f.file->f_op != &io_uring_fops))\n\t\tgoto out_fput;\n\n\tret = -ENXIO;\n\tctx = f.file->private_data;\n\tif (unlikely(!percpu_ref_tryget(&ctx->refs)))\n\t\tgoto out_fput;\n\n\tret = -EBADFD;\n\tif (unlikely(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\tgoto out;\n\n\t/*\n\t * For SQ polling, the thread will do all submissions and completions.\n\t * Just return the requested submit count, and wake the thread if\n\t * we were asked to.\n\t */\n\tret = 0;\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tio_cqring_overflow_flush(ctx);\n\n\t\tif (unlikely(ctx->sq_data->thread == NULL)) {\n\t\t\tret = -EOWNERDEAD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (flags & IORING_ENTER_SQ_WAKEUP)\n\t\t\twake_up(&ctx->sq_data->wait);\n\t\tif (flags & IORING_ENTER_SQ_WAIT) {\n\t\t\tret = io_sqpoll_wait_sq(ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsubmitted = to_submit;\n\t} else if (to_submit) {\n\t\tret = io_uring_add_tctx_node(ctx);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tsubmitted = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\t\tif (submitted != to_submit)\n\t\t\tgoto out;\n\t}\n\tif (flags & IORING_ENTER_GETEVENTS) {\n\t\tconst sigset_t __user *sig;\n\t\tstruct __kernel_timespec __user *ts;\n\n\t\tret = io_get_ext_arg(flags, argp, &argsz, &ts, &sig);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\tmin_complete = min(min_complete, ctx->cq_entries);\n\n\t\t/*\n\t\t * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user\n\t\t * space applications don't need to do io completion events\n\t\t * polling again, they can rely on io_sq_thread to do polling\n\t\t * work, which can reduce cpu usage and uring_lock contention.\n\t\t */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&\n\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\t\tret = io_iopoll_check(ctx, min_complete);\n\t\t} else {\n\t\t\tret = io_cqring_wait(ctx, min_complete, sig, argsz, ts);\n\t\t}\n\t}\n\nout:\n\tpercpu_ref_put(&ctx->refs);\nout_fput:\n\tif (!(flags & IORING_ENTER_REGISTERED_RING))\n\t\tfdput(f);\n\treturn submitted ? submitted : ret;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic __cold int io_uring_show_cred(struct seq_file *m, unsigned int id,\n\t\tconst struct cred *cred)\n{\n\tstruct user_namespace *uns = seq_user_ns(m);\n\tstruct group_info *gi;\n\tkernel_cap_t cap;\n\tunsigned __capi;\n\tint g;\n\n\tseq_printf(m, \"%5d\\n\", id);\n\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));\n\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));\n\tseq_puts(m, \"\\n\\tGroups:\\t\");\n\tgi = cred->group_info;\n\tfor (g = 0; g < gi->ngroups; g++) {\n\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",\n\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));\n\t}\n\tseq_puts(m, \"\\n\\tCapEff:\\t\");\n\tcap = cred->cap_effective;\n\tCAP_FOR_EACH_U32(__capi)\n\t\tseq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic __cold void __io_uring_show_fdinfo(struct io_ring_ctx *ctx,\n\t\t\t\t\t  struct seq_file *m)\n{\n\tstruct io_sq_data *sq = NULL;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int sq_entries, cq_entries;\n\tbool has_lock;\n\tunsigned int i;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - ctx->cached_sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tunsigned int sq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tstruct io_uring_sqe *sqe;\n\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx];\n\t\tseq_printf(m, \"%5u: opcode:%d, fd:%d, flags:%x, user_data:%llu\\n\",\n\t\t\t   sq_idx, sqe->opcode, sqe->fd, sqe->flags,\n\t\t\t   sqe->user_data);\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[entry & cq_mask];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\\n\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tsq = ctx->sq_data;\n\t\tif (!sq->thread)\n\t\t\tsq = NULL;\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(ctx, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"PollList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tfor (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {\n\t\tstruct hlist_head *list = &ctx->cancel_hash[i];\n\t\tstruct io_kiocb *req;\n\n\t\thlist_for_each_entry(req, list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}\n\nstatic __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\n\tif (percpu_ref_tryget(&ctx->refs)) {\n\t\t__io_uring_show_fdinfo(ctx, m);\n\t\tpercpu_ref_put(&ctx->refs);\n\t}\n}\n#endif\n\nstatic const struct file_operations io_uring_fops = {\n\t.release\t= io_uring_release,\n\t.mmap\t\t= io_uring_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = io_uring_nommu_get_unmapped_area,\n\t.mmap_capabilities = io_uring_nommu_mmap_capabilities,\n#endif\n\t.poll\t\t= io_uring_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= io_uring_show_fdinfo,\n#endif\n};\n\nstatic __cold int io_allocate_scq_urings(struct io_ring_ctx *ctx,\n\t\t\t\t\t struct io_uring_params *p)\n{\n\tstruct io_rings *rings;\n\tsize_t size, sq_array_offset;\n\n\t/* make sure these are sane, as we already accounted them */\n\tctx->sq_entries = p->sq_entries;\n\tctx->cq_entries = p->cq_entries;\n\n\tsize = rings_size(p->sq_entries, p->cq_entries, &sq_array_offset);\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\n\trings = io_mem_alloc(size);\n\tif (!rings)\n\t\treturn -ENOMEM;\n\n\tctx->rings = rings;\n\tctx->sq_array = (u32 *)((char *)rings + sq_array_offset);\n\trings->sq_ring_mask = p->sq_entries - 1;\n\trings->cq_ring_mask = p->cq_entries - 1;\n\trings->sq_ring_entries = p->sq_entries;\n\trings->cq_ring_entries = p->cq_entries;\n\n\tsize = array_size(sizeof(struct io_uring_sqe), p->sq_entries);\n\tif (size == SIZE_MAX) {\n\t\tio_mem_free(ctx->rings);\n\t\tctx->rings = NULL;\n\t\treturn -EOVERFLOW;\n\t}\n\n\tctx->sq_sqes = io_mem_alloc(size);\n\tif (!ctx->sq_sqes) {\n\t\tio_mem_free(ctx->rings);\n\t\tctx->rings = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int io_uring_install_fd(struct io_ring_ctx *ctx, struct file *file)\n{\n\tint ret, fd;\n\n\tfd = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = io_uring_add_tctx_node(ctx);\n\tif (ret) {\n\t\tput_unused_fd(fd);\n\t\treturn ret;\n\t}\n\tfd_install(fd, file);\n\treturn fd;\n}\n\n/*\n * Allocate an anonymous fd, this is what constitutes the application\n * visible backing of an io_uring instance. The application mmaps this\n * fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,\n * we have to tie this fd to a socket for file garbage collection purposes.\n */\nstatic struct file *io_uring_get_file(struct io_ring_ctx *ctx)\n{\n\tstruct file *file;\n#if defined(CONFIG_UNIX)\n\tint ret;\n\n\tret = sock_create_kern(&init_net, PF_UNIX, SOCK_RAW, IPPROTO_IP,\n\t\t\t\t&ctx->ring_sock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n#endif\n\n\tfile = anon_inode_getfile_secure(\"[io_uring]\", &io_uring_fops, ctx,\n\t\t\t\t\t O_RDWR | O_CLOEXEC, NULL);\n#if defined(CONFIG_UNIX)\n\tif (IS_ERR(file)) {\n\t\tsock_release(ctx->ring_sock);\n\t\tctx->ring_sock = NULL;\n\t} else {\n\t\tctx->ring_sock->file = file;\n\t}\n#endif\n\treturn file;\n}\n\nstatic __cold int io_uring_create(unsigned entries, struct io_uring_params *p,\n\t\t\t\t  struct io_uring_params __user *params)\n{\n\tstruct io_ring_ctx *ctx;\n\tstruct file *file;\n\tint ret;\n\n\tif (!entries)\n\t\treturn -EINVAL;\n\tif (entries > IORING_MAX_ENTRIES) {\n\t\tif (!(p->flags & IORING_SETUP_CLAMP))\n\t\t\treturn -EINVAL;\n\t\tentries = IORING_MAX_ENTRIES;\n\t}\n\n\t/*\n\t * Use twice as many entries for the CQ ring. It's possible for the\n\t * application to drive a higher depth than the size of the SQ ring,\n\t * since the sqes are only used at submission time. This allows for\n\t * some flexibility in overcommitting a bit. If the application has\n\t * set IORING_SETUP_CQSIZE, it will have passed in the desired number\n\t * of CQ ring entries manually.\n\t */\n\tp->sq_entries = roundup_pow_of_two(entries);\n\tif (p->flags & IORING_SETUP_CQSIZE) {\n\t\t/*\n\t\t * If IORING_SETUP_CQSIZE is set, we do the same roundup\n\t\t * to a power-of-two, if it isn't already. We do NOT impose\n\t\t * any cq vs sq ring sizing.\n\t\t */\n\t\tif (!p->cq_entries)\n\t\t\treturn -EINVAL;\n\t\tif (p->cq_entries > IORING_MAX_CQ_ENTRIES) {\n\t\t\tif (!(p->flags & IORING_SETUP_CLAMP))\n\t\t\t\treturn -EINVAL;\n\t\t\tp->cq_entries = IORING_MAX_CQ_ENTRIES;\n\t\t}\n\t\tp->cq_entries = roundup_pow_of_two(p->cq_entries);\n\t\tif (p->cq_entries < p->sq_entries)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tp->cq_entries = 2 * p->sq_entries;\n\t}\n\n\tctx = io_ring_ctx_alloc(p);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->compat = in_compat_syscall();\n\tif (!capable(CAP_IPC_LOCK))\n\t\tctx->user = get_uid(current_user());\n\n\t/*\n\t * This is just grabbed for accounting purposes. When a process exits,\n\t * the mm is exited and dropped before the files, hence we need to hang\n\t * on to this mm purely for the purposes of being able to unaccount\n\t * memory (locked/pinned vm). It's not used for anything else.\n\t */\n\tmmgrab(current->mm);\n\tctx->mm_account = current->mm;\n\n\tret = io_allocate_scq_urings(ctx, p);\n\tif (ret)\n\t\tgoto err;\n\n\tret = io_sq_offload_create(ctx, p);\n\tif (ret)\n\t\tgoto err;\n\t/* always set a rsrc node */\n\tret = io_rsrc_node_switch_start(ctx);\n\tif (ret)\n\t\tgoto err;\n\tio_rsrc_node_switch(ctx, NULL);\n\n\tmemset(&p->sq_off, 0, sizeof(p->sq_off));\n\tp->sq_off.head = offsetof(struct io_rings, sq.head);\n\tp->sq_off.tail = offsetof(struct io_rings, sq.tail);\n\tp->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);\n\tp->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);\n\tp->sq_off.flags = offsetof(struct io_rings, sq_flags);\n\tp->sq_off.dropped = offsetof(struct io_rings, sq_dropped);\n\tp->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;\n\n\tmemset(&p->cq_off, 0, sizeof(p->cq_off));\n\tp->cq_off.head = offsetof(struct io_rings, cq.head);\n\tp->cq_off.tail = offsetof(struct io_rings, cq.tail);\n\tp->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);\n\tp->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);\n\tp->cq_off.overflow = offsetof(struct io_rings, cq_overflow);\n\tp->cq_off.cqes = offsetof(struct io_rings, cqes);\n\tp->cq_off.flags = offsetof(struct io_rings, cq_flags);\n\n\tp->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |\n\t\t\tIORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |\n\t\t\tIORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |\n\t\t\tIORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |\n\t\t\tIORING_FEAT_EXT_ARG | IORING_FEAT_NATIVE_WORKERS |\n\t\t\tIORING_FEAT_RSRC_TAGS | IORING_FEAT_CQE_SKIP;\n\n\tif (copy_to_user(params, p, sizeof(*p))) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tfile = io_uring_get_file(ctx);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Install ring fd as the very last thing, so we don't risk someone\n\t * having closed it before we finish setup\n\t */\n\tret = io_uring_install_fd(ctx, file);\n\tif (ret < 0) {\n\t\t/* fput will clean it up */\n\t\tfput(file);\n\t\treturn ret;\n\t}\n\n\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);\n\treturn ret;\nerr:\n\tio_ring_ctx_wait_and_kill(ctx);\n\treturn ret;\n}\n\n/*\n * Sets up an aio uring context, and returns the fd. Applications asks for a\n * ring size, we return the actual sq/cq ring sizes (among other things) in the\n * params structure passed in.\n */\nstatic long io_uring_setup(u32 entries, struct io_uring_params __user *params)\n{\n\tstruct io_uring_params p;\n\tint i;\n\n\tif (copy_from_user(&p, params, sizeof(p)))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {\n\t\tif (p.resv[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |\n\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |\n\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |\n\t\t\tIORING_SETUP_R_DISABLED | IORING_SETUP_SUBMIT_ALL))\n\t\treturn -EINVAL;\n\n\treturn  io_uring_create(entries, &p, params);\n}\n\nSYSCALL_DEFINE2(io_uring_setup, u32, entries,\n\t\tstruct io_uring_params __user *, params)\n{\n\treturn io_uring_setup(entries, params);\n}\n\nstatic __cold int io_probe(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t   unsigned nr_args)\n{\n\tstruct io_uring_probe *p;\n\tsize_t size;\n\tint i, ret;\n\n\tsize = struct_size(p, ops, nr_args);\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\tp = kzalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(p, arg, size))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (memchr_inv(p, 0, size))\n\t\tgoto out;\n\n\tp->last_op = IORING_OP_LAST - 1;\n\tif (nr_args > IORING_OP_LAST)\n\t\tnr_args = IORING_OP_LAST;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tp->ops[i].op = i;\n\t\tif (!io_op_defs[i].not_supported)\n\t\t\tp->ops[i].flags = IO_URING_OP_SUPPORTED;\n\t}\n\tp->ops_len = i;\n\n\tret = 0;\n\tif (copy_to_user(arg, p, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}\n\nstatic int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\n\tcreds = get_current_cred();\n\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tput_cred(creds);\n\t\treturn ret;\n\t}\n\treturn id;\n}\n\nstatic __cold int io_register_restrictions(struct io_ring_ctx *ctx,\n\t\t\t\t\t   void __user *arg, unsigned int nr_args)\n{\n\tstruct io_uring_restriction *res;\n\tsize_t size;\n\tint i, ret;\n\n\t/* Restrictions allowed only if rings started disabled */\n\tif (!(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\treturn -EBADFD;\n\n\t/* We allow only a single restrictions registration */\n\tif (ctx->restrictions.registered)\n\t\treturn -EBUSY;\n\n\tif (!arg || nr_args > IORING_MAX_RESTRICTIONS)\n\t\treturn -EINVAL;\n\n\tsize = array_size(nr_args, sizeof(*res));\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\n\tres = memdup_user(arg, size);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tret = 0;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tswitch (res[i].opcode) {\n\t\tcase IORING_RESTRICTION_REGISTER_OP:\n\t\t\tif (res[i].register_op >= IORING_REGISTER_LAST) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t__set_bit(res[i].register_op,\n\t\t\t\t  ctx->restrictions.register_op);\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_OP:\n\t\t\tif (res[i].sqe_op >= IORING_OP_LAST) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t__set_bit(res[i].sqe_op, ctx->restrictions.sqe_op);\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_FLAGS_ALLOWED:\n\t\t\tctx->restrictions.sqe_flags_allowed = res[i].sqe_flags;\n\t\t\tbreak;\n\t\tcase IORING_RESTRICTION_SQE_FLAGS_REQUIRED:\n\t\t\tctx->restrictions.sqe_flags_required = res[i].sqe_flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/* Reset all restrictions if an error happened */\n\tif (ret != 0)\n\t\tmemset(&ctx->restrictions, 0, sizeof(ctx->restrictions));\n\telse\n\t\tctx->restrictions.registered = true;\n\n\tkfree(res);\n\treturn ret;\n}\n\nstatic int io_register_enable_rings(struct io_ring_ctx *ctx)\n{\n\tif (!(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\treturn -EBADFD;\n\n\tif (ctx->restrictions.registered)\n\t\tctx->restricted = 1;\n\n\tctx->flags &= ~IORING_SETUP_R_DISABLED;\n\tif (ctx->sq_data && wq_has_sleeper(&ctx->sq_data->wait))\n\t\twake_up(&ctx->sq_data->wait);\n\treturn 0;\n}\n\nstatic int __io_register_rsrc_update(struct io_ring_ctx *ctx, unsigned type,\n\t\t\t\t     struct io_uring_rsrc_update2 *up,\n\t\t\t\t     unsigned nr_args)\n{\n\t__u32 tmp;\n\tint err;\n\n\tif (up->resv)\n\t\treturn -EINVAL;\n\tif (check_add_overflow(up->offset, nr_args, &tmp))\n\t\treturn -EOVERFLOW;\n\terr = io_rsrc_node_switch_start(ctx);\n\tif (err)\n\t\treturn err;\n\n\tswitch (type) {\n\tcase IORING_RSRC_FILE:\n\t\treturn __io_sqe_files_update(ctx, up, nr_args);\n\tcase IORING_RSRC_BUFFER:\n\t\treturn __io_sqe_buffers_update(ctx, up, nr_args);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int io_register_files_update(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t    unsigned nr_args)\n{\n\tstruct io_uring_rsrc_update2 up;\n\n\tif (!nr_args)\n\t\treturn -EINVAL;\n\tmemset(&up, 0, sizeof(up));\n\tif (copy_from_user(&up, arg, sizeof(struct io_uring_rsrc_update)))\n\t\treturn -EFAULT;\n\treturn __io_register_rsrc_update(ctx, IORING_RSRC_FILE, &up, nr_args);\n}\n\nstatic int io_register_rsrc_update(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t\t   unsigned size, unsigned type)\n{\n\tstruct io_uring_rsrc_update2 up;\n\n\tif (size != sizeof(up))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&up, arg, sizeof(up)))\n\t\treturn -EFAULT;\n\tif (!up.nr || up.resv)\n\t\treturn -EINVAL;\n\treturn __io_register_rsrc_update(ctx, type, &up, up.nr);\n}\n\nstatic __cold int io_register_rsrc(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t    unsigned int size, unsigned int type)\n{\n\tstruct io_uring_rsrc_register rr;\n\n\t/* keep it extendible */\n\tif (size != sizeof(rr))\n\t\treturn -EINVAL;\n\n\tmemset(&rr, 0, sizeof(rr));\n\tif (copy_from_user(&rr, arg, size))\n\t\treturn -EFAULT;\n\tif (!rr.nr || rr.resv || rr.resv2)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase IORING_RSRC_FILE:\n\t\treturn io_sqe_files_register(ctx, u64_to_user_ptr(rr.data),\n\t\t\t\t\t     rr.nr, u64_to_user_ptr(rr.tags));\n\tcase IORING_RSRC_BUFFER:\n\t\treturn io_sqe_buffers_register(ctx, u64_to_user_ptr(rr.data),\n\t\t\t\t\t       rr.nr, u64_to_user_ptr(rr.tags));\n\t}\n\treturn -EINVAL;\n}\n\nstatic __cold int io_register_iowq_aff(struct io_ring_ctx *ctx,\n\t\t\t\t       void __user *arg, unsigned len)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\tcpumask_var_t new_mask;\n\tint ret;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_clear(new_mask);\n\tif (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tif (in_compat_syscall()) {\n\t\tret = compat_get_bitmap(cpumask_bits(new_mask),\n\t\t\t\t\t(const compat_ulong_t __user *)arg,\n\t\t\t\t\tlen * 8 /* CHAR_BIT */);\n\t} else {\n\t\tret = copy_from_user(new_mask, arg, len);\n\t}\n\n\tif (ret) {\n\t\tfree_cpumask_var(new_mask);\n\t\treturn -EFAULT;\n\t}\n\n\tret = io_wq_cpu_affinity(tctx->io_wq, new_mask);\n\tfree_cpumask_var(new_mask);\n\treturn ret;\n}\n\nstatic __cold int io_unregister_iowq_aff(struct io_ring_ctx *ctx)\n{\n\tstruct io_uring_task *tctx = current->io_uring;\n\n\tif (!tctx || !tctx->io_wq)\n\t\treturn -EINVAL;\n\n\treturn io_wq_cpu_affinity(tctx->io_wq, NULL);\n}\n\nstatic __cold int io_register_iowq_max_workers(struct io_ring_ctx *ctx,\n\t\t\t\t\t       void __user *arg)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_tctx_node *node;\n\tstruct io_uring_task *tctx = NULL;\n\tstruct io_sq_data *sqd = NULL;\n\t__u32 new_count[2];\n\tint i, ret;\n\n\tif (copy_from_user(new_count, arg, sizeof(new_count)))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\tif (new_count[i] > INT_MAX)\n\t\t\treturn -EINVAL;\n\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tsqd = ctx->sq_data;\n\t\tif (sqd) {\n\t\t\t/*\n\t\t\t * Observe the correct sqd->lock -> ctx->uring_lock\n\t\t\t * ordering. Fine to drop uring_lock here, we hold\n\t\t\t * a ref to the ctx.\n\t\t\t */\n\t\t\trefcount_inc(&sqd->refs);\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t\tmutex_lock(&sqd->lock);\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t\tif (sqd->thread)\n\t\t\t\ttctx = sqd->thread->io_uring;\n\t\t}\n\t} else {\n\t\ttctx = current->io_uring;\n\t}\n\n\tBUILD_BUG_ON(sizeof(new_count) != sizeof(ctx->iowq_limits));\n\n\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\tif (new_count[i])\n\t\t\tctx->iowq_limits[i] = new_count[i];\n\tctx->iowq_limits_set = true;\n\n\tif (tctx && tctx->io_wq) {\n\t\tret = io_wq_max_workers(tctx->io_wq, new_count);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tmemset(new_count, 0, sizeof(new_count));\n\t}\n\n\tif (sqd) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tio_put_sq_data(sqd);\n\t}\n\n\tif (copy_to_user(arg, new_count, sizeof(new_count)))\n\t\treturn -EFAULT;\n\n\t/* that's it for SQPOLL, only the SQPOLL task creates requests */\n\tif (sqd)\n\t\treturn 0;\n\n\t/* now propagate the restriction to all registered users */\n\tlist_for_each_entry(node, &ctx->tctx_list, ctx_node) {\n\t\tstruct io_uring_task *tctx = node->task->io_uring;\n\n\t\tif (WARN_ON_ONCE(!tctx->io_wq))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(new_count); i++)\n\t\t\tnew_count[i] = ctx->iowq_limits[i];\n\t\t/* ignore errors, it always returns zero anyway */\n\t\t(void)io_wq_max_workers(tctx->io_wq, new_count);\n\t}\n\treturn 0;\nerr:\n\tif (sqd) {\n\t\tmutex_unlock(&sqd->lock);\n\t\tio_put_sq_data(sqd);\n\t}\n\treturn ret;\n}\n\nstatic int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,\n\t\t\t       void __user *arg, unsigned nr_args)\n\t__releases(ctx->uring_lock)\n\t__acquires(ctx->uring_lock)\n{\n\tint ret;\n\n\t/*\n\t * We're inside the ring mutex, if the ref is already dying, then\n\t * someone else killed the ctx or is already going through\n\t * io_uring_register().\n\t */\n\tif (percpu_ref_is_dying(&ctx->refs))\n\t\treturn -ENXIO;\n\n\tif (ctx->restricted) {\n\t\tif (opcode >= IORING_REGISTER_LAST)\n\t\t\treturn -EINVAL;\n\t\topcode = array_index_nospec(opcode, IORING_REGISTER_LAST);\n\t\tif (!test_bit(opcode, ctx->restrictions.register_op))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (opcode) {\n\tcase IORING_REGISTER_BUFFERS:\n\t\tret = io_sqe_buffers_register(ctx, arg, nr_args, NULL);\n\t\tbreak;\n\tcase IORING_UNREGISTER_BUFFERS:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_sqe_buffers_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES:\n\t\tret = io_sqe_files_register(ctx, arg, nr_args, NULL);\n\t\tbreak;\n\tcase IORING_UNREGISTER_FILES:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_sqe_files_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES_UPDATE:\n\t\tret = io_register_files_update(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_EVENTFD:\n\t\tret = -EINVAL;\n\t\tif (nr_args != 1)\n\t\t\tbreak;\n\t\tret = io_eventfd_register(ctx, arg, 0);\n\t\tbreak;\n\tcase IORING_REGISTER_EVENTFD_ASYNC:\n\t\tret = -EINVAL;\n\t\tif (nr_args != 1)\n\t\t\tbreak;\n\t\tret = io_eventfd_register(ctx, arg, 1);\n\t\tbreak;\n\tcase IORING_UNREGISTER_EVENTFD:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_eventfd_unregister(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_PROBE:\n\t\tret = -EINVAL;\n\t\tif (!arg || nr_args > 256)\n\t\t\tbreak;\n\t\tret = io_probe(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_PERSONALITY:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_register_personality(ctx);\n\t\tbreak;\n\tcase IORING_UNREGISTER_PERSONALITY:\n\t\tret = -EINVAL;\n\t\tif (arg)\n\t\t\tbreak;\n\t\tret = io_unregister_personality(ctx, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_ENABLE_RINGS:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_register_enable_rings(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_RESTRICTIONS:\n\t\tret = io_register_restrictions(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES2:\n\t\tret = io_register_rsrc(ctx, arg, nr_args, IORING_RSRC_FILE);\n\t\tbreak;\n\tcase IORING_REGISTER_FILES_UPDATE2:\n\t\tret = io_register_rsrc_update(ctx, arg, nr_args,\n\t\t\t\t\t      IORING_RSRC_FILE);\n\t\tbreak;\n\tcase IORING_REGISTER_BUFFERS2:\n\t\tret = io_register_rsrc(ctx, arg, nr_args, IORING_RSRC_BUFFER);\n\t\tbreak;\n\tcase IORING_REGISTER_BUFFERS_UPDATE:\n\t\tret = io_register_rsrc_update(ctx, arg, nr_args,\n\t\t\t\t\t      IORING_RSRC_BUFFER);\n\t\tbreak;\n\tcase IORING_REGISTER_IOWQ_AFF:\n\t\tret = -EINVAL;\n\t\tif (!arg || !nr_args)\n\t\t\tbreak;\n\t\tret = io_register_iowq_aff(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_UNREGISTER_IOWQ_AFF:\n\t\tret = -EINVAL;\n\t\tif (arg || nr_args)\n\t\t\tbreak;\n\t\tret = io_unregister_iowq_aff(ctx);\n\t\tbreak;\n\tcase IORING_REGISTER_IOWQ_MAX_WORKERS:\n\t\tret = -EINVAL;\n\t\tif (!arg || nr_args != 2)\n\t\t\tbreak;\n\t\tret = io_register_iowq_max_workers(ctx, arg);\n\t\tbreak;\n\tcase IORING_REGISTER_RING_FDS:\n\t\tret = io_ringfd_register(ctx, arg, nr_args);\n\t\tbreak;\n\tcase IORING_UNREGISTER_RING_FDS:\n\t\tret = io_ringfd_unregister(ctx, arg, nr_args);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,\n\t\tvoid __user *, arg, unsigned int, nr_args)\n{\n\tstruct io_ring_ctx *ctx;\n\tlong ret = -EBADF;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -EOPNOTSUPP;\n\tif (f.file->f_op != &io_uring_fops)\n\t\tgoto out_fput;\n\n\tctx = f.file->private_data;\n\n\tio_run_task_work();\n\n\tmutex_lock(&ctx->uring_lock);\n\tret = __io_uring_register(ctx, opcode, arg, nr_args);\n\tmutex_unlock(&ctx->uring_lock);\n\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs, ret);\nout_fput:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int __init io_uring_init(void)\n{\n#define __BUILD_BUG_VERIFY_ELEMENT(stype, eoffset, etype, ename) do { \\\n\tBUILD_BUG_ON(offsetof(stype, ename) != eoffset); \\\n\tBUILD_BUG_ON(sizeof(etype) != sizeof_field(stype, ename)); \\\n} while (0)\n\n#define BUILD_BUG_SQE_ELEM(eoffset, etype, ename) \\\n\t__BUILD_BUG_VERIFY_ELEMENT(struct io_uring_sqe, eoffset, etype, ename)\n\tBUILD_BUG_ON(sizeof(struct io_uring_sqe) != 64);\n\tBUILD_BUG_SQE_ELEM(0,  __u8,   opcode);\n\tBUILD_BUG_SQE_ELEM(1,  __u8,   flags);\n\tBUILD_BUG_SQE_ELEM(2,  __u16,  ioprio);\n\tBUILD_BUG_SQE_ELEM(4,  __s32,  fd);\n\tBUILD_BUG_SQE_ELEM(8,  __u64,  off);\n\tBUILD_BUG_SQE_ELEM(8,  __u64,  addr2);\n\tBUILD_BUG_SQE_ELEM(16, __u64,  addr);\n\tBUILD_BUG_SQE_ELEM(16, __u64,  splice_off_in);\n\tBUILD_BUG_SQE_ELEM(24, __u32,  len);\n\tBUILD_BUG_SQE_ELEM(28,     __kernel_rwf_t, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */   int, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */ __u32, rw_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  fsync_flags);\n\tBUILD_BUG_SQE_ELEM(28, /* compat */ __u16,  poll_events);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  poll32_events);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  sync_range_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  msg_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  timeout_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  accept_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  cancel_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  open_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  statx_flags);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  fadvise_advice);\n\tBUILD_BUG_SQE_ELEM(28, __u32,  splice_flags);\n\tBUILD_BUG_SQE_ELEM(32, __u64,  user_data);\n\tBUILD_BUG_SQE_ELEM(40, __u16,  buf_index);\n\tBUILD_BUG_SQE_ELEM(40, __u16,  buf_group);\n\tBUILD_BUG_SQE_ELEM(42, __u16,  personality);\n\tBUILD_BUG_SQE_ELEM(44, __s32,  splice_fd_in);\n\tBUILD_BUG_SQE_ELEM(44, __u32,  file_index);\n\n\tBUILD_BUG_ON(sizeof(struct io_uring_files_update) !=\n\t\t     sizeof(struct io_uring_rsrc_update));\n\tBUILD_BUG_ON(sizeof(struct io_uring_rsrc_update) >\n\t\t     sizeof(struct io_uring_rsrc_update2));\n\n\t/* ->buf_index is u16 */\n\tBUILD_BUG_ON(IORING_MAX_REG_BUFFERS >= (1u << 16));\n\n\t/* should fit into one byte */\n\tBUILD_BUG_ON(SQE_VALID_FLAGS >= (1 << 8));\n\tBUILD_BUG_ON(SQE_COMMON_FLAGS >= (1 << 8));\n\tBUILD_BUG_ON((SQE_VALID_FLAGS | SQE_COMMON_FLAGS) != SQE_VALID_FLAGS);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(io_op_defs) != IORING_OP_LAST);\n\tBUILD_BUG_ON(__REQ_F_LAST_BIT > 8 * sizeof(int));\n\n\treq_cachep = KMEM_CACHE(io_kiocb, SLAB_HWCACHE_ALIGN | SLAB_PANIC |\n\t\t\t\tSLAB_ACCOUNT);\n\treturn 0;\n};\n__initcall(io_uring_init);\n"], "filenames": ["fs/io_uring.c"], "buggy_code_start_loc": [1738], "buggy_code_end_loc": [6630], "fixing_code_start_loc": [1739], "fixing_code_end_loc": [6630], "type": "CWE-416", "message": "In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due to a race condition in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace; however, the race condition perhaps can only be exploited infrequently.", "other": {"cve": {"id": "CVE-2022-29582", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-22T16:15:09.393", "lastModified": "2022-10-26T02:33:58.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due to a race condition in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace; however, the race condition perhaps can only be exploited infrequently."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 5.17.3, el archivo fs/io_uring.c presenta un uso de memoria previamente liberada debido a una condici\u00f3n de carrera en la funci\u00f3n io_uring timeouts. Esto puede ser desencadenado por un usuario local que no tenga acceso a ning\u00fan espacio de nombres de usuario; sin embargo, la condici\u00f3n de carrera quiz\u00e1s s\u00f3lo pueda ser explotada con poca frecuencia"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.3", "matchCriteriaId": "68AC7372-D098-4584-A82A-1F7CD731042F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/04/22/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/08/08/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.3", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e677edbcabee849bfdd43f1602bccbecf736a646", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/Ruia-ruia/CVE-2022-29582-Exploit", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/e677edbcabee849bfdd43f1602bccbecf736a646", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/04/22/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e677edbcabee849bfdd43f1602bccbecf736a646"}}