{"buggy_code": ["/*\n * The two pass scaling function is based on:\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n *\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\t\n\tFor image rotations, the optimized versions have a lazy antialiasing for \n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <assert.h>\n\n#define NDEBUG 1 /* TODO: disable/enable assertions in configure. */\n#include <assert.h>\n\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_intern.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <emmintrin.h>\n#endif\n\nstatic gdImagePtr gdImageScaleBilinear(gdImagePtr im, \n                                       const unsigned int new_width,\n                                       const unsigned int new_height);\nstatic gdImagePtr gdImageScaleBicubicFixed(gdImagePtr src,\n                                           const unsigned int width,\n                                           const unsigned int height);\nstatic gdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im,\n                                               const unsigned int width,\n                                               const unsigned int height);\nstatic gdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src,\n                                                const float degrees,\n                                                const int bgColor);\nstatic gdImagePtr gdImageRotateBilinear(gdImagePtr src, const float degrees,\n                                        const int bgColor);\nstatic gdImagePtr gdImageRotateBicubicFixed(gdImagePtr src, const float degrees,\n                                            const int bgColor);\nstatic gdImagePtr gdImageRotateGeneric(gdImagePtr src, const float degrees,\n                                       const int bgColor);\n\n\n#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) ((x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) (((x) << 8) / (y))\n\ntypedef struct\n{\n\tdouble *Weights;  /* Normalized weights of neighboring pixels */\n\tint Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n\tContributionType *ContribRow; /* Row (or column) of contribution weights */\n\tunsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t     LineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\n/* Each core filter has its own radius */\n#define DEFAULT_FILTER_BICUBIC\t\t\t\t3.0\n#define DEFAULT_FILTER_BOX\t\t\t\t\t0.5\n#define DEFAULT_FILTER_GENERALIZED_CUBIC\t0.5\n#define DEFAULT_FILTER_RADIUS\t\t\t\t1.0\n#define DEFAULT_LANCZOS8_RADIUS\t\t\t\t8.0\n#define DEFAULT_LANCZOS3_RADIUS\t\t\t\t3.0\n#define DEFAULT_HERMITE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BOX_RADIUS\t\t\t\t\t0.5\n#define DEFAULT_TRIANGLE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BELL_RADIUS\t\t\t\t\t1.5\n#define DEFAULT_CUBICSPLINE_RADIUS\t\t\t2.0\n#define DEFAULT_MITCHELL_RADIUS\t\t\t\t2.0\n#define DEFAULT_COSINE_RADIUS\t\t\t\t1.0\n#define DEFAULT_CATMULLROM_RADIUS\t\t\t2.0\n#define DEFAULT_QUADRATIC_RADIUS\t\t\t1.5\n#define DEFAULT_QUADRATICBSPLINE_RADIUS\t\t1.5\n#define DEFAULT_CUBICCONVOLUTION_RADIUS\t\t3.0\n#define DEFAULT_GAUSSIAN_RADIUS\t\t\t\t1.0\n#define DEFAULT_HANNING_RADIUS\t\t\t\t1.0\n#define DEFAULT_HAMMING_RADIUS\t\t\t\t1.0\n#define DEFAULT_SINC_RADIUS\t\t\t\t\t1.0\n#define DEFAULT_WELSH_RADIUS\t\t\t\t1.0\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\t\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_bessel(const double x)\n{\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x)\n{\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\n/**\n * Bicubic interpolation kernel (a=-1):\n  \\verbatim\n          /\n         | 1-2|t|**2+|t|**3          , if |t| < 1\n  h(t) = | 4-8|t|+5|t|**2-|t|**3     , if 1<=|t|<2\n         | 0                         , otherwise\n          \\\n  \\endverbatim\n * ***bd*** 2.2004\n */\nstatic double filter_bicubic(const double t)\n{\n\tconst double abs_t = (double)fabs(t);\n\tconst double abs_t_sq = abs_t * abs_t;\n\tif (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n\tif (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n\treturn 0;\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n#endif\n\nstatic double filter_box(double x) {\n\tif (x < - DEFAULT_FILTER_BOX)\n\t\treturn 0.0f;\n\tif (x < DEFAULT_FILTER_BOX)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x)\n{\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS8_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R) {\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI/ R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos3 filter, default radius 3 */\nstatic double filter_lanczos3(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS3_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R)\n\t{\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI / R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x)\n{\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\treturn(0.0f);\n}\n\n\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n#endif\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x)\n{\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n#endif\n\nstatic double filter_gaussian(const double x)\n{\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x)\n{\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x)\n{\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x)\n{\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_sinc(const double x)\n{\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_welsh(const double x)\n{\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n#endif\n\n#if defined(_MSC_VER) && !defined(inline)\n# define inline __inline\n#endif \n\n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n\tconst int src_alpha = gdTrueColorGetAlpha(src);\n\n\tif( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n\nstatic inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = gdImageGetPixel(im, x,  im->cy2);\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, y);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = gdImageGetPixel(im, im->cx2, y);\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn colorIndex2RGBcustomA(border, 127);\n\t\t}\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tif (im->trueColor) {\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\t} else {\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\n\t}\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * InternalFunction: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nint getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)((x) < 0 ? x - 1: x);\n\tconst int yi=(int)((y) < 0 ? y - 1: y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_BILINEAR_FIXED || im->interpolation_id == GD_BICUBIC_FIXED || im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tif (im->trueColor == 1) {\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\n\t\t} else {\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\n\t\t}\n\t}\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t}\n\treturn res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstatic inline void\n_gdScaleOneAxis(gdImagePtr pSrc, gdImagePtr dst,\n\t\t\t\tunsigned int dst_len, unsigned int row, LineContribType *contrib,\n\t\t\t\tgdAxis axis)\n{\n\tunsigned int ndx;\n\n\tfor (ndx = 0; ndx < dst_len; ndx++) {\n\t\tdouble r = 0, g = 0, b = 0, a = 0;\n\t\tconst int left = contrib->ContribRow[ndx].Left;\n\t\tconst int right = contrib->ContribRow[ndx].Right;\n\t\tint *dest = (axis == HORIZONTAL) ? \n\t\t\t&dst->tpixels[row][ndx] : \n\t\t\t&dst->tpixels[ndx][row];\n\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = left; i <= right; i++) {\n\t\t\tconst int left_channel = i - left;\n\t\t\tconst int srcpx = (axis == HORIZONTAL) ?\n\t\t\t\tpSrc->tpixels[row][i] : \n\t\t\t\tpSrc->tpixels[i][row];\n\n\t\t\tr += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetRed(srcpx));\n\t\t\tg += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetGreen(srcpx));\n\t\t\tb += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetBlue(srcpx));\n\t\t\ta += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetAlpha(srcpx));\n\t\t}/* for */\n\n\t\t*dest = gdTrueColorAlpha(uchar_clamp(r, 0xFF), uchar_clamp(g, 0xFF),\n                                 uchar_clamp(b, 0xFF),\n                                 uchar_clamp(a, 0x7F)); /* alpha is 0..127 */\n\t}/* for */\n}/* _gdScaleOneAxis*/\n\n\nstatic inline int\n_gdScalePass(const gdImagePtr pSrc, const unsigned int src_len,\n             const gdImagePtr pDst, const unsigned int dst_len,\n             const unsigned int num_lines,\n             const gdAxis axis)\n{\n\tunsigned int line_ndx;\n\tLineContribType * contrib;\n\n    /* Same dim, just copy it. */\n    assert(dst_len != src_len); // TODO: caller should handle this.\n\n\tcontrib = _gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n                                   pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Scale each line */\n    for (line_ndx = 0; line_ndx < num_lines; line_ndx++) {\n        _gdScaleOneAxis(pSrc, pDst, dst_len, line_ndx, contrib, axis);\n\t}\n\t_gdContributionsFree (contrib);\n\n    return 1;\n}/* _gdScalePass*/\n\n\nstatic gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }/* if .. else*/\n\n    /* If vertical sizes match, we're done. */\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }/* if */\n\n    /* Otherwise, we need to scale vertically. */\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }/* if */\n\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }/* if */\n\n\treturn dst;\n}/* gdImageScaleTwoPass*/\n\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are\n\trewamped versions of the implementation in CBitmapEx\n\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\n\tInteger only implementation, good to have for common usages like\n\tpre scale very large images before using another interpolation\n\tmethods for the last step.\n*/\nstatic gdImagePtr\ngdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\nstatic inline int getPixelOverflowColorTC(gdImagePtr im, const int x, const int y, const int color)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* zero for the background color, nothig gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst char red = (char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst char green = (char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst char blue = (char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst char alpha = (char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst gdFixed m = gd_fxtoi(f_a);\n\t\t\tconst gdFixed n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor, nothing gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width,\n                     const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\nstatic gdImagePtr\ngdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width,\n                         const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tif (m < 1) {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 1) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 2) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, new_width, new_height);\n\t\t\tbreak;\n\t}\n\n\treturn im_scaled;\n}\n\nstatic gdImagePtr \ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees,\n                              const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tconst gdFixed f_slop_y = f_sin;\n\tconst gdFixed f_slop_x = f_cos;\n\tconst gdFixed f_slop = f_slop_x > 0 && f_slop_x > 0 ?\n\t\t\t\t\t\t\tf_slop_x > f_slop_y ? gd_divfx(f_slop_y, f_slop_x) : gd_divfx(f_slop_x, f_slop_y)\n\t\t\t\t\t\t: 0;\n\n\tif (bgColor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((n <= 0) || (m <= 0) || (m >= src_h) || (n >= src_w)) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else if ((n <= 1) || (m <= 1) || (m >= src_h - 1) || (n >= src_w - 1)) {\n\t\t\t\tregister int c = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t\tc = c | (( gdTrueColorGetAlpha(c) + ((int)(127* gd_fxtof(f_slop)))) << 24);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = _color_blend(bgColor, c);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateBilinear(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst unsigned int src_w = gdImageSX(src);\n\tconst unsigned int src_h = gdImageSY(src);\n\tunsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tunsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tunsigned int i;\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int src_offset_x, src_offset_y;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst unsigned int m = gd_fxtoi(f_m);\n\t\t\tconst unsigned int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w - 1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\n\t\t\t\tif (n < src_w - 1) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < src_h - 1) {\n\t\t\t\t\tsrc_offset_x = n;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\n\t\t\t\tif (!((n >= src_w - 1) || (m >= src_h - 1))) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tconst int pixel1 = src->tpixels[src_offset_y][src_offset_x];\n\t\t\t\t\tregister int pixel2, pixel3, pixel4;\n\n\t\t\t\t\tif (src_offset_y + 1 >= src_h) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else if (src_offset_x + 1 >= src_w) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t    pixel2 = src->tpixels[src_offset_y][src_offset_x + 1];\n\t\t\t\t\t\tpixel3 = src->tpixels[src_offset_y + 1][src_offset_x];\n\t\t\t\t\t\tpixel4 = src->tpixels[src_offset_y + 1][src_offset_x + 1];\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tconst gdFixed f_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\t\t\t\tconst gdFixed f_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\t\t\t\tconst gdFixed f_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\t\t\t\tconst gdFixed f_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\t\t\t\tconst gdFixed f_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\t\t\t\tconst gdFixed f_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\t\t\t\tconst gdFixed f_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\t\t\t\tconst gdFixed f_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\t\t\t\tconst gdFixed f_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\t\t\t\tconst gdFixed f_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\t\t\t\tconst gdFixed f_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\t\t\t\tconst gdFixed f_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\t\t\t\tconst gdFixed f_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\t\t\t\tconst gdFixed f_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\t\t\t\tconst gdFixed f_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\t\t\t\tconst gdFixed f_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t\t\t\tconst gdFixed f_red = gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4);\n\t\t\t\t\t\tconst gdFixed f_green = gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4);\n\t\t\t\t\t\tconst gdFixed f_blue = gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4);\n\t\t\t\t\t\tconst gdFixed f_alpha = gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4);\n\n\t\t\t\t\t\tconst unsigned char red   = (unsigned char) CLAMP(gd_fxtoi(f_red),   0, 255);\n\t\t\t\t\t\tconst unsigned char green = (unsigned char) CLAMP(gd_fxtoi(f_green), 0, 255);\n\t\t\t\t\t\tconst unsigned char blue  = (unsigned char) CLAMP(gd_fxtoi(f_blue),  0, 255);\n\t\t\t\t\t\tconst unsigned char alpha = (unsigned char) CLAMP(gd_fxtoi(f_alpha), 0, 127);\n\n\t\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateBicubicFixed(gdImagePtr src, const float degrees,const int bgColor)\n{\n\tconst float _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tconst unsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gama = gd_ftofx(1.04f);\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst int m = gd_fxtoi(f_m);\n\t\t\tconst int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\t\tunsigned char red, green, blue, alpha;\n\t\t\t\tgdFixed f_red=0, f_green=0, f_blue=0, f_alpha=0;\n\t\t\t\tint k;\n\n\t\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < 1) {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[2] = - 1;\n\t\t\t\t\tsrc_offset_y[2] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\t\tsrc_offset_y[2] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[3] = - 1;\n\t\t\t\t\tsrc_offset_y[3] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[3] = m ;\n\t\t\t\t}\n\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tsrc_offset_x[4] = - 1;\n\t\t\t\t\tsrc_offset_y[4] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t\t}\n\n\t\t\t\tsrc_offset_x[5] = n;\n\t\t\t\tsrc_offset_y[5] = m;\n\t\t\t\tif (n >= src_w-1) {\n\t\t\t\t\tsrc_offset_x[6] = - 1;\n\t\t\t\t\tsrc_offset_y[6] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t\t}\n\n\t\t\t\tif (n >= src_w-2) {\n\t\t\t\t\tsrc_offset_x[7] = - 1;\n\t\t\t\t\tsrc_offset_y[7] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-1) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[10] = - 1;\n\t\t\t\t\tsrc_offset_y[10] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[11] = - 1;\n\t\t\t\t\tsrc_offset_y[11] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[12] = - 1;\n\t\t\t\t\tsrc_offset_y[12] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-2) {\n\t\t\t\t\tsrc_offset_x[13] = - 1;\n\t\t\t\t\tsrc_offset_y[13] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w - 1)) {\n\t\t\t\t\tsrc_offset_x[14] = - 1;\n\t\t\t\t\tsrc_offset_y[14] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[15] = - 1;\n\t\t\t\t\tsrc_offset_y[15] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t\t}\n\n\t\t\t\tfor (k=-1; k<3; k++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tgdFixed f_a = 0, f_b = 0,f_c = 0, f_d = 0;\n\t\t\t\t\tgdFixed f_RY;\n\t\t\t\t\tint l;\n\n\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t}\n\t\t\t\t\tf_RY = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\t\tfor (l=-1;  l< 3; l++) {\n\t\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\t\tgdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\t\tgdFixed f_RX, f_R;\n\t\t\t\t\t\tconst int _k = ((k + 1) * 4) + (l + 1);\n\t\t\t\t\t\tregister gdFixed f_rs, f_gs, f_bs, f_as;\n\t\t\t\t\t\tregister int c;\n\n\t\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_RX = gd_divfx((f_a - gd_mulfx(f_4, f_b) + gd_mulfx(f_6, f_c) - gd_mulfx(f_4, f_d)), f_6);\n\t\t\t\t\t\tf_R = gd_mulfx(f_RY, f_RX);\n\n\t\t\t\t\t\tif ((src_offset_x[_k] <= 0) || (src_offset_y[_k] <= 0) || (src_offset_y[_k] >= src_h) || (src_offset_x[_k] >= src_w)) {\n\t\t\t\t\t\t\tc = bgColor;\n\t\t\t\t\t\t} else if ((src_offset_x[_k] <= 1) || (src_offset_y[_k] <= 1) || (src_offset_y[_k] >= (int)src_h - 1) || (src_offset_x[_k] >= (int)src_w - 1)) {\n\t\t\t\t\t\t\tgdFixed f_127 = gd_itofx(127);\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t\tc = c | (( (int) (gd_fxtof(gd_mulfx(f_R, f_127)) + 50.5f)) << 24);\n\t\t\t\t\t\t\tc = _color_blend(bgColor, c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\t\tf_as = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\t\tf_red   += gd_mulfx(f_rs, f_R);\n\t\t\t\t\t\tf_green += gd_mulfx(f_gs, f_R);\n\t\t\t\t\t\tf_blue  += gd_mulfx(f_bs, f_R);\n\t\t\t\t\t\tf_alpha += gd_mulfx(f_as, f_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tred   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red, f_gama)),   0, 255);\n\t\t\t\tgreen = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gama)), 0, 255);\n\t\t\t\tblue  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue, f_gama)),  0, 255);\n\t\t\t\talpha = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha, f_gama)), 0, 127);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  bgColor;\n\t\t\t}\n\t\t\tdst_offset_x++;\n\t\t}\n\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles \n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\n\t   slow animations, f.e. */\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* 0 && 90 degrees multiple rotation, 0 rotation simply clones the return image and convert it\n\t   to truecolor, as we must return truecolor image. */\n\tswitch (angle_rounded) {\n\t\tcase    0: {\n\t\t\tgdImagePtr dst = gdImageClone(src);\n\n\t\t\tif (dst == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dst->trueColor == 0) {\n\t\t\t\tgdImagePaletteToTrueColor(dst);\n\t\t\t}\n\t\t\treturn dst;\n\t\t}\n\n\t\tcase -27000:\n\t\tcase   9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\n\t\tcase -18000:\n\t\tcase  18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\n\t\tcase  -9000:\n\t\tcase  27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n\n/**\n * Title: Affine transformation\n **/\n\n/**\n * Group: Transform\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\nvoid gdDumpRect(const char *msg, gdRectPtr r)\n{\n\tprintf(\"%s (%i, %i) (%i, %i)\\n\", msg, r->x, r->y, r->width, r->height);\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\t\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\t\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\n\tbbox->height = (int) floor(max.y - min.y);\n\treturn GD_TRUE;\n}\n\nBGD_DECLARE(int) gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_DEFAULT:\n\t\t\tid = GD_BILINEAR_FIXED;\n\t\t/* Optimized versions */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n\n/* Return the interpolation mode set in 'im'.  This is here so that\n * the value can be read via a language or VM with an FFI but no\n * (portable) way to extract the value from the struct. */\nBGD_DECLARE(gdInterpolationMethod) gdImageGetInterpolationMethod(gdImagePtr im)\n{\n    return im->interpolation_id;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n"], "fixing_code": ["/*\n * The two pass scaling function is based on:\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n *\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\t\n\tFor image rotations, the optimized versions have a lazy antialiasing for \n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <assert.h>\n\n#define NDEBUG 1 /* TODO: disable/enable assertions in configure. */\n#include <assert.h>\n\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_intern.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <emmintrin.h>\n#endif\n\nstatic gdImagePtr gdImageScaleBilinear(gdImagePtr im, \n                                       const unsigned int new_width,\n                                       const unsigned int new_height);\nstatic gdImagePtr gdImageScaleBicubicFixed(gdImagePtr src,\n                                           const unsigned int width,\n                                           const unsigned int height);\nstatic gdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im,\n                                               const unsigned int width,\n                                               const unsigned int height);\nstatic gdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src,\n                                                const float degrees,\n                                                const int bgColor);\nstatic gdImagePtr gdImageRotateBilinear(gdImagePtr src, const float degrees,\n                                        const int bgColor);\nstatic gdImagePtr gdImageRotateBicubicFixed(gdImagePtr src, const float degrees,\n                                            const int bgColor);\nstatic gdImagePtr gdImageRotateGeneric(gdImagePtr src, const float degrees,\n                                       const int bgColor);\n\n\n#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) ((x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) (((x) << 8) / (y))\n\ntypedef struct\n{\n\tdouble *Weights;  /* Normalized weights of neighboring pixels */\n\tint Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n\tContributionType *ContribRow; /* Row (or column) of contribution weights */\n\tunsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t     LineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\n/* Each core filter has its own radius */\n#define DEFAULT_FILTER_BICUBIC\t\t\t\t3.0\n#define DEFAULT_FILTER_BOX\t\t\t\t\t0.5\n#define DEFAULT_FILTER_GENERALIZED_CUBIC\t0.5\n#define DEFAULT_FILTER_RADIUS\t\t\t\t1.0\n#define DEFAULT_LANCZOS8_RADIUS\t\t\t\t8.0\n#define DEFAULT_LANCZOS3_RADIUS\t\t\t\t3.0\n#define DEFAULT_HERMITE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BOX_RADIUS\t\t\t\t\t0.5\n#define DEFAULT_TRIANGLE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BELL_RADIUS\t\t\t\t\t1.5\n#define DEFAULT_CUBICSPLINE_RADIUS\t\t\t2.0\n#define DEFAULT_MITCHELL_RADIUS\t\t\t\t2.0\n#define DEFAULT_COSINE_RADIUS\t\t\t\t1.0\n#define DEFAULT_CATMULLROM_RADIUS\t\t\t2.0\n#define DEFAULT_QUADRATIC_RADIUS\t\t\t1.5\n#define DEFAULT_QUADRATICBSPLINE_RADIUS\t\t1.5\n#define DEFAULT_CUBICCONVOLUTION_RADIUS\t\t3.0\n#define DEFAULT_GAUSSIAN_RADIUS\t\t\t\t1.0\n#define DEFAULT_HANNING_RADIUS\t\t\t\t1.0\n#define DEFAULT_HAMMING_RADIUS\t\t\t\t1.0\n#define DEFAULT_SINC_RADIUS\t\t\t\t\t1.0\n#define DEFAULT_WELSH_RADIUS\t\t\t\t1.0\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\t\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_bessel(const double x)\n{\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x)\n{\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\n/**\n * Bicubic interpolation kernel (a=-1):\n  \\verbatim\n          /\n         | 1-2|t|**2+|t|**3          , if |t| < 1\n  h(t) = | 4-8|t|+5|t|**2-|t|**3     , if 1<=|t|<2\n         | 0                         , otherwise\n          \\\n  \\endverbatim\n * ***bd*** 2.2004\n */\nstatic double filter_bicubic(const double t)\n{\n\tconst double abs_t = (double)fabs(t);\n\tconst double abs_t_sq = abs_t * abs_t;\n\tif (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n\tif (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n\treturn 0;\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n#endif\n\nstatic double filter_box(double x) {\n\tif (x < - DEFAULT_FILTER_BOX)\n\t\treturn 0.0f;\n\tif (x < DEFAULT_FILTER_BOX)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x)\n{\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS8_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R) {\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI/ R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos3 filter, default radius 3 */\nstatic double filter_lanczos3(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS3_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R)\n\t{\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI / R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x)\n{\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\treturn(0.0f);\n}\n\n\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n#endif\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x)\n{\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n#endif\n\nstatic double filter_gaussian(const double x)\n{\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x)\n{\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x)\n{\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x)\n{\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_sinc(const double x)\n{\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_welsh(const double x)\n{\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n#endif\n\n#if defined(_MSC_VER) && !defined(inline)\n# define inline __inline\n#endif \n\n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n\tconst int src_alpha = gdTrueColorGetAlpha(src);\n\n\tif( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n\nstatic inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = gdImageGetPixel(im, x,  im->cy2);\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, y);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = gdImageGetPixel(im, im->cx2, y);\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn colorIndex2RGBcustomA(border, 127);\n\t\t}\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tif (im->trueColor) {\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\t} else {\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\n\t}\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * InternalFunction: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nint getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)((x) < 0 ? x - 1: x);\n\tconst int yi=(int)((y) < 0 ? y - 1: y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_BILINEAR_FIXED || im->interpolation_id == GD_BICUBIC_FIXED || im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tif (im->trueColor == 1) {\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\n\t\t} else {\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\n\t\t}\n\t}\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t}\n\treturn res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstatic inline void\n_gdScaleOneAxis(gdImagePtr pSrc, gdImagePtr dst,\n\t\t\t\tunsigned int dst_len, unsigned int row, LineContribType *contrib,\n\t\t\t\tgdAxis axis)\n{\n\tunsigned int ndx;\n\n\tfor (ndx = 0; ndx < dst_len; ndx++) {\n\t\tdouble r = 0, g = 0, b = 0, a = 0;\n\t\tconst int left = contrib->ContribRow[ndx].Left;\n\t\tconst int right = contrib->ContribRow[ndx].Right;\n\t\tint *dest = (axis == HORIZONTAL) ? \n\t\t\t&dst->tpixels[row][ndx] : \n\t\t\t&dst->tpixels[ndx][row];\n\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = left; i <= right; i++) {\n\t\t\tconst int left_channel = i - left;\n\t\t\tconst int srcpx = (axis == HORIZONTAL) ?\n\t\t\t\tpSrc->tpixels[row][i] : \n\t\t\t\tpSrc->tpixels[i][row];\n\n\t\t\tr += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetRed(srcpx));\n\t\t\tg += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetGreen(srcpx));\n\t\t\tb += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetBlue(srcpx));\n\t\t\ta += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetAlpha(srcpx));\n\t\t}/* for */\n\n\t\t*dest = gdTrueColorAlpha(uchar_clamp(r, 0xFF), uchar_clamp(g, 0xFF),\n                                 uchar_clamp(b, 0xFF),\n                                 uchar_clamp(a, 0x7F)); /* alpha is 0..127 */\n\t}/* for */\n}/* _gdScaleOneAxis*/\n\n\nstatic inline int\n_gdScalePass(const gdImagePtr pSrc, const unsigned int src_len,\n             const gdImagePtr pDst, const unsigned int dst_len,\n             const unsigned int num_lines,\n             const gdAxis axis)\n{\n\tunsigned int line_ndx;\n\tLineContribType * contrib;\n\n    /* Same dim, just copy it. */\n    assert(dst_len != src_len); // TODO: caller should handle this.\n\n\tcontrib = _gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n                                   pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Scale each line */\n    for (line_ndx = 0; line_ndx < num_lines; line_ndx++) {\n        _gdScaleOneAxis(pSrc, pDst, dst_len, line_ndx, contrib, axis);\n\t}\n\t_gdContributionsFree (contrib);\n\n    return 1;\n}/* _gdScalePass*/\n\n\nstatic gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }/* if .. else*/\n\n    /* If vertical sizes match, we're done. */\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }/* if */\n\n    /* Otherwise, we need to scale vertically. */\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }/* if */\n\n    if (src != tmp_im) {\n        gdImageDestroy(tmp_im);\n    }/* if */\n\n\treturn dst;\n}/* gdImageScaleTwoPass*/\n\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are\n\trewamped versions of the implementation in CBitmapEx\n\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\n\tInteger only implementation, good to have for common usages like\n\tpre scale very large images before using another interpolation\n\tmethods for the last step.\n*/\nstatic gdImagePtr\ngdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\nstatic inline int getPixelOverflowColorTC(gdImagePtr im, const int x, const int y, const int color)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* zero for the background color, nothig gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst char red = (char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst char green = (char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst char blue = (char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst char alpha = (char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst gdFixed m = gd_fxtoi(f_a);\n\t\t\tconst gdFixed n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor, nothing gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width,\n                     const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\nstatic gdImagePtr\ngdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width,\n                         const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tif (m < 1) {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 1) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 2) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, new_width, new_height);\n\t\t\tbreak;\n\t}\n\n\treturn im_scaled;\n}\n\nstatic gdImagePtr \ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees,\n                              const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tconst gdFixed f_slop_y = f_sin;\n\tconst gdFixed f_slop_x = f_cos;\n\tconst gdFixed f_slop = f_slop_x > 0 && f_slop_x > 0 ?\n\t\t\t\t\t\t\tf_slop_x > f_slop_y ? gd_divfx(f_slop_y, f_slop_x) : gd_divfx(f_slop_x, f_slop_y)\n\t\t\t\t\t\t: 0;\n\n\tif (bgColor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((n <= 0) || (m <= 0) || (m >= src_h) || (n >= src_w)) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else if ((n <= 1) || (m <= 1) || (m >= src_h - 1) || (n >= src_w - 1)) {\n\t\t\t\tregister int c = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t\tc = c | (( gdTrueColorGetAlpha(c) + ((int)(127* gd_fxtof(f_slop)))) << 24);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = _color_blend(bgColor, c);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateBilinear(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst unsigned int src_w = gdImageSX(src);\n\tconst unsigned int src_h = gdImageSY(src);\n\tunsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tunsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tunsigned int i;\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int src_offset_x, src_offset_y;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst unsigned int m = gd_fxtoi(f_m);\n\t\t\tconst unsigned int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w - 1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\n\t\t\t\tif (n < src_w - 1) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < src_h - 1) {\n\t\t\t\t\tsrc_offset_x = n;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\n\t\t\t\tif (!((n >= src_w - 1) || (m >= src_h - 1))) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tconst int pixel1 = src->tpixels[src_offset_y][src_offset_x];\n\t\t\t\t\tregister int pixel2, pixel3, pixel4;\n\n\t\t\t\t\tif (src_offset_y + 1 >= src_h) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else if (src_offset_x + 1 >= src_w) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t    pixel2 = src->tpixels[src_offset_y][src_offset_x + 1];\n\t\t\t\t\t\tpixel3 = src->tpixels[src_offset_y + 1][src_offset_x];\n\t\t\t\t\t\tpixel4 = src->tpixels[src_offset_y + 1][src_offset_x + 1];\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tconst gdFixed f_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\t\t\t\tconst gdFixed f_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\t\t\t\tconst gdFixed f_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\t\t\t\tconst gdFixed f_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\t\t\t\tconst gdFixed f_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\t\t\t\tconst gdFixed f_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\t\t\t\tconst gdFixed f_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\t\t\t\tconst gdFixed f_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\t\t\t\tconst gdFixed f_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\t\t\t\tconst gdFixed f_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\t\t\t\tconst gdFixed f_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\t\t\t\tconst gdFixed f_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\t\t\t\tconst gdFixed f_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\t\t\t\tconst gdFixed f_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\t\t\t\tconst gdFixed f_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\t\t\t\tconst gdFixed f_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t\t\t\tconst gdFixed f_red = gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4);\n\t\t\t\t\t\tconst gdFixed f_green = gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4);\n\t\t\t\t\t\tconst gdFixed f_blue = gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4);\n\t\t\t\t\t\tconst gdFixed f_alpha = gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4);\n\n\t\t\t\t\t\tconst unsigned char red   = (unsigned char) CLAMP(gd_fxtoi(f_red),   0, 255);\n\t\t\t\t\t\tconst unsigned char green = (unsigned char) CLAMP(gd_fxtoi(f_green), 0, 255);\n\t\t\t\t\t\tconst unsigned char blue  = (unsigned char) CLAMP(gd_fxtoi(f_blue),  0, 255);\n\t\t\t\t\t\tconst unsigned char alpha = (unsigned char) CLAMP(gd_fxtoi(f_alpha), 0, 127);\n\n\t\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateBicubicFixed(gdImagePtr src, const float degrees,const int bgColor)\n{\n\tconst float _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tconst unsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gama = gd_ftofx(1.04f);\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst int m = gd_fxtoi(f_m);\n\t\t\tconst int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\t\tunsigned char red, green, blue, alpha;\n\t\t\t\tgdFixed f_red=0, f_green=0, f_blue=0, f_alpha=0;\n\t\t\t\tint k;\n\n\t\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < 1) {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[2] = - 1;\n\t\t\t\t\tsrc_offset_y[2] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\t\tsrc_offset_y[2] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[3] = - 1;\n\t\t\t\t\tsrc_offset_y[3] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[3] = m ;\n\t\t\t\t}\n\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tsrc_offset_x[4] = - 1;\n\t\t\t\t\tsrc_offset_y[4] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t\t}\n\n\t\t\t\tsrc_offset_x[5] = n;\n\t\t\t\tsrc_offset_y[5] = m;\n\t\t\t\tif (n >= src_w-1) {\n\t\t\t\t\tsrc_offset_x[6] = - 1;\n\t\t\t\t\tsrc_offset_y[6] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t\t}\n\n\t\t\t\tif (n >= src_w-2) {\n\t\t\t\t\tsrc_offset_x[7] = - 1;\n\t\t\t\t\tsrc_offset_y[7] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-1) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[10] = - 1;\n\t\t\t\t\tsrc_offset_y[10] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[11] = - 1;\n\t\t\t\t\tsrc_offset_y[11] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[12] = - 1;\n\t\t\t\t\tsrc_offset_y[12] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-2) {\n\t\t\t\t\tsrc_offset_x[13] = - 1;\n\t\t\t\t\tsrc_offset_y[13] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w - 1)) {\n\t\t\t\t\tsrc_offset_x[14] = - 1;\n\t\t\t\t\tsrc_offset_y[14] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[15] = - 1;\n\t\t\t\t\tsrc_offset_y[15] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t\t}\n\n\t\t\t\tfor (k=-1; k<3; k++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tgdFixed f_a = 0, f_b = 0,f_c = 0, f_d = 0;\n\t\t\t\t\tgdFixed f_RY;\n\t\t\t\t\tint l;\n\n\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t}\n\t\t\t\t\tf_RY = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\t\tfor (l=-1;  l< 3; l++) {\n\t\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\t\tgdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\t\tgdFixed f_RX, f_R;\n\t\t\t\t\t\tconst int _k = ((k + 1) * 4) + (l + 1);\n\t\t\t\t\t\tregister gdFixed f_rs, f_gs, f_bs, f_as;\n\t\t\t\t\t\tregister int c;\n\n\t\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_RX = gd_divfx((f_a - gd_mulfx(f_4, f_b) + gd_mulfx(f_6, f_c) - gd_mulfx(f_4, f_d)), f_6);\n\t\t\t\t\t\tf_R = gd_mulfx(f_RY, f_RX);\n\n\t\t\t\t\t\tif ((src_offset_x[_k] <= 0) || (src_offset_y[_k] <= 0) || (src_offset_y[_k] >= src_h) || (src_offset_x[_k] >= src_w)) {\n\t\t\t\t\t\t\tc = bgColor;\n\t\t\t\t\t\t} else if ((src_offset_x[_k] <= 1) || (src_offset_y[_k] <= 1) || (src_offset_y[_k] >= (int)src_h - 1) || (src_offset_x[_k] >= (int)src_w - 1)) {\n\t\t\t\t\t\t\tgdFixed f_127 = gd_itofx(127);\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t\tc = c | (( (int) (gd_fxtof(gd_mulfx(f_R, f_127)) + 50.5f)) << 24);\n\t\t\t\t\t\t\tc = _color_blend(bgColor, c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\t\tf_as = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\t\tf_red   += gd_mulfx(f_rs, f_R);\n\t\t\t\t\t\tf_green += gd_mulfx(f_gs, f_R);\n\t\t\t\t\t\tf_blue  += gd_mulfx(f_bs, f_R);\n\t\t\t\t\t\tf_alpha += gd_mulfx(f_as, f_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tred   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red, f_gama)),   0, 255);\n\t\t\t\tgreen = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gama)), 0, 255);\n\t\t\t\tblue  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue, f_gama)),  0, 255);\n\t\t\t\talpha = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha, f_gama)), 0, 127);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  bgColor;\n\t\t\t}\n\t\t\tdst_offset_x++;\n\t\t}\n\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles \n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\n\t   slow animations, f.e. */\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* 0 && 90 degrees multiple rotation, 0 rotation simply clones the return image and convert it\n\t   to truecolor, as we must return truecolor image. */\n\tswitch (angle_rounded) {\n\t\tcase    0: {\n\t\t\tgdImagePtr dst = gdImageClone(src);\n\n\t\t\tif (dst == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dst->trueColor == 0) {\n\t\t\t\tgdImagePaletteToTrueColor(dst);\n\t\t\t}\n\t\t\treturn dst;\n\t\t}\n\n\t\tcase -27000:\n\t\tcase   9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\n\t\tcase -18000:\n\t\tcase  18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\n\t\tcase  -9000:\n\t\tcase  27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n\n/**\n * Title: Affine transformation\n **/\n\n/**\n * Group: Transform\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\nvoid gdDumpRect(const char *msg, gdRectPtr r)\n{\n\tprintf(\"%s (%i, %i) (%i, %i)\\n\", msg, r->x, r->y, r->width, r->height);\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\t\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\t\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\n\tbbox->height = (int) floor(max.y - min.y);\n\treturn GD_TRUE;\n}\n\nBGD_DECLARE(int) gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_DEFAULT:\n\t\t\tid = GD_BILINEAR_FIXED;\n\t\t/* Optimized versions */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n\n/* Return the interpolation mode set in 'im'.  This is here so that\n * the value can be read via a language or VM with an FFI but no\n * (portable) way to extract the value from the struct. */\nBGD_DECLARE(gdInterpolationMethod) gdImageGetInterpolationMethod(gdImagePtr im)\n{\n    return im->interpolation_id;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n"], "filenames": ["src/gd_interpolation.c"], "buggy_code_start_loc": [1090], "buggy_code_end_loc": [1091], "fixing_code_start_loc": [1090], "fixing_code_end_loc": [1091], "type": "CWE-399", "message": "The gdImageScaleTwoPass function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in PHP before 5.6.12, uses inconsistent allocate and free approaches, which allows remote attackers to cause a denial of service (memory consumption) via a crafted call, as demonstrated by a call to the PHP imagescale function.", "other": {"cve": {"id": "CVE-2015-8877", "sourceIdentifier": "cve@mitre.org", "published": "2016-05-22T01:59:09.023", "lastModified": "2018-01-05T02:30:23.540", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The gdImageScaleTwoPass function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in PHP before 5.6.12, uses inconsistent allocate and free approaches, which allows remote attackers to cause a denial of service (memory consumption) via a crafted call, as demonstrated by a call to the PHP imagescale function."}, {"lang": "es", "value": "La funci\u00f3n gdImageScaleTwoPass en gd_interpolation.c en el GD Graphics Library (tambi\u00e9n conocido como libgd) en versiones anteriores a 2.2.0, como es utilizado en PHP en versiones anteriores a 5.6.12, usa asignaciones inconsistentes y enfoques libres, lo que permite a atacantes remotos provocar una denegaci\u00f3n del servicio (consumo de memoria) a trav\u00e9s de una llamada manipulada, seg\u00fan lo demostrado mediante una llamada a la funci\u00f3n PHP imagescale."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.1", "matchCriteriaId": "B4AB6FB9-E6DD-4FBC-9BC6-594384030CCE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.6.11", "matchCriteriaId": "F78D523C-90F6-476A-AC95-390E0862C413"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3587", "source": "cve@mitre.org"}, {"url": "http://www.php.net/ChangeLog-5.php", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2987-1", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=70064", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/libgd/libgd/commit/4751b606fa38edc456d627140898a7ec679fcc24", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/libgd/libgd/issues/173", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/4751b606fa38edc456d627140898a7ec679fcc24"}}