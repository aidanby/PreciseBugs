{"buggy_code": ["## v4.0.0\n- `Callback` class addeed.\n- When possible, `reference.get()` will return a function proxy instead of a `Reference`.\n- `reference.get()` will no longer return inherited properties by default.\n- `result` property on `eval` and `evalClosure` has been removed. The result is now just the return\nvalue.\n- All `isolated-vm` class prototypes, and most instances are frozen.\n- `isolate.cpuTime` and `isolate.wallTime` now return bigints.\n", "[![npm version](https://badgen.now.sh/npm/v/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n[![isc license](https://badgen.now.sh/npm/license/isolated-vm)](https://github.com/laverdet/isolated-vm/blob/main/LICENSE)\n[![travis build](https://badgen.now.sh/travis/laverdet/isolated-vm/main)](https://travis-ci.org/laverdet/isolated-vm)\n[![npm downloads](https://badgen.now.sh/npm/dm/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n\nisolated-vm -- Access to multiple isolates in nodejs\n====================================================\n\n[![NPM](https://nodei.co/npm/isolated-vm.png)](https://www.npmjs.com/package/isolated-vm)\n\n`isolated-vm` is a library for nodejs which gives you access to v8's `Isolate` interface. This\nallows you to create JavaScript environments which are completely *isolated* from each other. You\nmight find this module useful if you need to run some untrusted code in a secure way. You may also\nfind this module useful if you need to run some JavaScript simultaneously in multiple threads. You\nmay find this project *very* useful if you need to do both at the same time!\n\n* [Requirements](#requirements)\n* [Who Is Using isolated-vm](#who-is-using-isolated-vm)\n* [API Documentation](#api-documentation)\n\t* [Isolate](#class-isolate-transferable)\n\t* [Context](#class-context-transferable)\n\t* [Script](#class-script-transferable)\n\t* [Module](#class-module-transferable)\n\t* [Reference](#class-reference-transferable)\n\t* [ExternalCopy](#class-externalcopy-transferable)\n* [Examples](#examples)\n* [Alternatives](#alternatives)\n\n\nREQUIREMENTS\n------------\n\nThis project requires nodejs LTS version 10.4.0 (or later).\n\nFurthermore, to install this module you will need a compiler installed. If you run into errors while\nrunning `npm install isolated-vm` it is likely you don't have a compiler set up, or your compiler is\ntoo old.\n\n* Windows + OS X users should follow the instuctions here: [node-gyp](https://github.com/nodejs/node-gyp)\n* Ubuntu users should run: `sudo apt-get install python g++ build-essential`\n* Alpine users should run: `sudo apk add python make g++`\n* Amazon Linux AMI users should run: `sudo yum install gcc72 gcc72-c++`\n* Arch Linux users should run: `sudo pacman -S make gcc python`\n\nWHO IS USING ISOLATED-VM\n------------------------\n\n* [Screeps](https://screeps.com/) - Screeps is an online JavaScript-based MMO+RPG game. They are\nusing isolated-vm to run arbitrary player-supplied code in secure enviroments which can persistent\nfor several days at a time.\n\n* [Fly](https://fly.io/) - Fly is a programmable CDN which hosts dynamic endpoints as opposed to\njust static resources. They are using isolated-vm to run globally distributed applications, where\neach application may have wildly different traffic patterns.\n\n* [Algolia](https://www.algolia.com) - Algolia is a Search as a Service provider. They use\n`isolated-vm` to power their [Custom Crawler](https://www.algolia.com/products/crawler/) product,\nwhich allows them to safely execute user-provided code for content extraction.\n\n* [Tripadvisor](https://www.tripadvisor.com) - Tripadvisor is the world\u2019s largest travel platform.\nThey use `isolated-vm` to server-side render thousands of React pages per second.\n\nAPI DOCUMENTATION\n-----------------\n\nSince isolates share no resources with each other, most of this API is built to provide primitives\nwhich make marshalling data between many isolates quick and easy. The only way to pass data from one\nisolate to another is to first make that data *transferable*. Primitives (except for `Symbol`) are\nalways transferable. This means if you invoke a function in a different isolate with a number or\nstring as the argument, it will work fine. If you need to pass more complex information you will\nhave to first make the data transferable with one of the methods here.\n\nMost methods will provide both a synchronous and an asynchronous version. Calling the synchronous\nfunctions will block your thread while the method runs and eventually returns a value. The\nasynchronous functions will return a\n[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\nwhile the work runs in a separate thread pool.\n\nThere are some rules about which functions may be called from certain contexts:\n\n1. Asynchronous functions may be called at any time\n2. Synchronous functions usually may not be called from an asynchronous function\n3. You may call a synchronous function from an asynchronous function as long as that function\n\tbelongs to current isolate\n4. You may call a synchronous function belonging to the default nodejs isolate at any time\n\nAdditionally, some methods will provide an \"ignored\" version which runs asynchronously but returns\nno promise. This can be a good option when the calling isolate would ignore the promise anyway,\nsince the ignored versions can skip an extra thread synchronization. Just be careful because this\nswallows any thrown exceptions which might make problems hard to track down.\n\nIt's also worth noting that all asynchronous invocations will run in the order they were queued,\nregardless of whether or not you wait on them. So, for instance, you could call several \"ignored\"\nmethods in a row and then `await` on a final async method to observe some side-effect of the\nignored methods.\n\n\n### Class: `Isolate` *[transferable]*\nThis is the main reference to an isolate. Every handle to an isolate is transferable, which means\nyou can give isolates references to each other. An isolate will remain valid as long as someone\nholds a handle to the isolate or anything created inside that isolate. Once an isolate is lost the\ngarbage collector should eventually find it and clean up its memory. Since an isolate and all it\ncontains can represent quite a large chunk of memory though you may want to explicitly call the\n`dispose()` method on isolates that you are finished with to get that memory back immediately.\n\n##### `new ivm.Isolate(options)`\n* `options` *[object]*\n\t* `memoryLimit` *[number]* - Memory limit that this isolate may use, in MB. Note that this is more\n\tof a guideline instead of a strict limit. A determined attacker could use 2-3 times this limit\n\tbefore their script is terminated. Against non-hostile code this limit should be pretty close. The\n\tdefault is 128MB and the mimium is 8MB.\n\t* `inspector` *[boolean]* - Enable v8 inspector support in this isolate. See\n\t`inspector-example.js` in this repository for an example of how to use this.\n\t* `snapshot` *[ExternalCopy[ArrayBuffer]]* - This is an optional snapshot created from\n\t`createSnapshot` which will be used to initialize the heap of this isolate.\n\n##### `ivm.Isolate.createSnapshot(scripts, warmup_script)`\n* `scripts` *[array]*\n\t* `code` *[string]* - Source code to set up this snapshot\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n* `warmup_script` *[string]* - Optional script to \"warmup\" the snapshot by triggering code\ncompilation\n\nIsolate snapshots are a very useful feature if you intend to create several isolates running common\nlibraries between them. A snapshot serializes the entire v8 heap including parsed code, global\nvariables, and compiled code. Check out the examples section for tips on using this.\n\n**Note**: `createSnapshot` does not provide the same isolate protection like the rest of\nisolated-vm. If the script passed to `createSnapshot` uses too much memory the process will crash,\nand if it has an infinite loop it will stall the process. Furthermore newer v8 features may simply\nfail when attempting to take a snapshot that uses them. It is best to snapshot code that only\ndefines functions, class, and simple data structures.\n\n**Please note that versions of nodejs 10.4.0 - 10.9.0 may crash while using the snapshot feature.\n\n##### `isolate.compileScript(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileScriptSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Script`](#class-script-transferable) object.\n\nNote that a [`Script`](#class-script-transferable) can only run in the isolate which created it.\n\n##### `isolate.compileModule(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileModuleSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Module`](#class-module-transferable) object.\n\nNote that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `isolate.createContext()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.createContextSync()`\n* `options` *[object]*\n\t* `inspector` *[boolean]* - Enable the v8 inspector for this context. The inspector must have been\n\t\tenabled for the isolate as well.\n\n* **return** A [`Context`](#class-context-transferable) object.\n\n##### `isolate.dispose()`\nDestroys this isolate and invalidates all references obtained from it.\n\n##### `isolate.getHeapStatistics()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.getHeapStatisticsSync()`\n* **return** [object]\n\nReturns heap statistics from v8. The return value is almost identical to the nodejs function\n[v8.getHeapStatistics()](https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics).\nThis function returns one additional property: `externally_allocated_size` which is the total amount\nof currently allocated memory which is not included in the v8 heap but counts against this isolate's\n`memoryLimit`. ArrayBuffer instances over a certain size are externally allocated and will be\ncounted here.\n\n##### `isolate.cpuTime` *bigint*\n##### `isolate.wallTime` *bigint*\nThe total CPU and wall time spent in this isolate, in nanoseconds. CPU time is the amount of time\nthe isolate has spent actively doing work on the CPU. Wall time is the amount of time the isolate\nhas been running, including passive time spent waiting (think \"wall\" like a clock on the wall). For\ninstance, if an isolate makes a call into another isolate, wall time will continue increasing while\nCPU time will remain the same.\n\nNote that in nodejs v10.x the return value is a regular number, since bigint isn't supported on\nearlier versions.\n\nAlso note that CPU time may vary drastically if there is contention for the CPU. This could occur if\nother processes are trying to do work, or if you have more than `require('os').cpus().length`\nisolates currently doing work in the same nodejs process.\n\n##### `isolate.isDisposed` *[boolean]*\nFlag that indicates whether this isolate has been disposed.\n\n##### `isolate.referenceCount` *[number]*\nReturns the total count of active `Reference` instances that belong to this isolate. Note that in\ncertain cases many `Reference` instances in JavaScript will point to the same underlying reference\nhandle, in which case this number will only reflect the underlying reference handle. This happens\nwhen you transfer a `Reference` instance via some method which accepts transferable values. This\nwill also include underlying reference handles created by isolated-vm like `Script` or `Context`\nobjects.\n\n\n### Class: `Context` *[transferable]*\nA context is a sandboxed execution environment within an isolate. Each context contains its own\nbuilt-in objects and global space.\n\n##### `context.global` *[`Reference`](#class-reference-transferable)*\n[`Reference`](#class-reference-transferable) to this context's global object. Note that if you call\n`context.release()` the global reference will be released as well.\n\n##### `context.eval(code, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalIgnored(code, options)`\n##### `context.evalSync(code, options)`\n* `code` *[string]* - The code to run\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nCompiles and executes a script within a context. This will return the last value evaluated, as long\nas that value was transferable, otherwise `undefined` will be returned.\n\n##### `context.evalClosure(code, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalClosureIgnored(code, arguments, options)`\n##### `context.evalClosureSync(code, arguments, options)`\n* `code` *[string]* - The code to run\n* `arguments` *[array]` - Arguments to pass to this code\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** `*[transferable]*\n\nCompiles and runs code as if it were inside a function, similar to the seldom-used `new\nFunction(code)` constructor. You can pass arguments to the function and they will be available as\n`$0`, `$1`, and so on. You can also use `return` from the code.\n\n##### `context.release()`\n\nReleases this reference to the context. You can call this to free up v8 resources immediately, or\nyou can let the garbage collector handle it when it feels like it. Note that if there are other\nreferences to this context it will not be disposed. This only affects this reference to the context.\n\n\n### Class: `Script` *[transferable]*\nA script is a compiled chunk of JavaScript which can be executed in any context within a single\nisolate.\n\n##### `script.release()`\n\nReleases the reference to this script, allowing the script data to be garbage collected. Functions\nand data created in the isolate by previous invocations to `script.run(...)` will still be alive in\ntheir respective contexts-- this only means that you can't invoke `script.run(...)` again with this\nreference.\n\n##### `script.run(context, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `script.runIgnored(context, options)`\n##### `script.runSync(context, options)`\n* `context` *[`Context`](#class-context-transferable)* - The context in which this script will run.\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nRuns a given script within a context. This will return the last value evaluated in a given script,\nas long as that value was transferable, otherwise `undefined` will be returned. For instance if your\nscript was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value will be 3 because that\nis the last expression.\n\n\n### Class: `Module` *[transferable]*\nA JavaScript module. Note that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `module.dependencySpecifiers`\nA read-only array of all dependency specifiers the module has.\n\n\t\tconst code = `import something from './something';`;\n\t\tconst module = await isolate.compileModule(code);\n\t\tconst dependencySpecifiers = module.dependencySpecifiers;\n\t\t// dependencySpecifiers => [\"./something\"];\n\n##### `module.namespace`\nReturns a [`Reference`](#class-reference-transferable) containing all exported values.\n\n##### `module.instantiate(context, resolveCallback)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.instantiateSync(context, resolveCallback)`\n* `context` *[`Context`](#class-context-transferable)* - The context the module should use.\n* `resolveCallback` - This callback is responsible for resolving all direct and indirect\ndependencies of this module. It accepts two parameters: `specifier` and `referrer`. It must return a\n`Module` instance which will be used to satisfy the dependency. The asynchronous version of\n`instantiate` may return a promise from `resolveCallback`.\n\nInstantiate the module together with all its dependencies. Calling this more than once on a single\nmodule will have no effect.\n\n##### `module.evaluate(options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.evaluateSync(options)`\n* `options` *[object]* - Optional.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this module is allowed to\n\trun before execution is canceled. Default is no timeout.\n* **return** *[transferable]*\n\nEvaluate the module and return the last expression (same as script.run). If `evaluate` is called\nmore than once on the same module the return value from the first invocation will be returned (or\nthrown).\n\n**Note:** nodejs v14.8.0 enabled top-level await by default which has the effect of breaking the\nreturn value of this function.\n\n\n### Class: `Callback` *[transferable]*\nCallbacks can be used to create cross-isolate references to simple functions. This can be easier and\nsafer than dealing with the more flexible [`Reference`](#class-reference-transferable) class.\nArguments passed to and returned from callbacks are always copied using the same method as\n[`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate, instances\nof `Callback` will turn into a plain old function. Callbacks are created automatically when passing\nfunctions to most isolated-vm functions.\n\n##### `new ivm.Callback(fn, options)`\n* `options` *[object]*\n\t* `async` *[boolean]* - Function will invoke the callback in \"async\" mode, which immediately\n\t\treturns a promise.\n\t* `ignored` *[boolean]* - Function will invoke the callback in \"ignored\" mode, which immediately\n\t\treturns `undefined` and ignores the result of the function (including thrown exceptions)\n\t* `sync` *[boolean]* - Function will invoke the callback in \"sync\" mode, blocking for a response\n\t\t(default).\n\n\n### Class: `Reference` *[transferable]*\nA instance of [`Reference`](#class-reference-transferable) is a pointer to a value stored in any isolate.\n\n##### `new ivm.Reference(value, options)`\n* `value` - The value to create a reference to.\n* `options` *[object]*\n  * `inheritUnsafe` *[boolean]* - If enabled then the `get` family of functions will follow the\n    object's prototype chain. References created with this option should never be given to untrusted\n    code.\n\n##### `reference.typeof` *[string]*\n\nThis is the typeof the referenced value, and is available at any time from any isolate. Note that\nthis differs from the real `typeof` operator in that `null` is \"null\", and Symbols are \"object\".\n\n##### `reference.copy()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.copySync()`\n* **return** JavaScript value of the reference.\n\nCreates a copy of the referenced value and internalizes it into this isolate. This uses the same\ncopy rules as [`ExternalCopy`](#class-externalcopy-transferable).\n\n##### `reference.deref()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** The value referenced by this handle.\n\nWill attempt to return the actual value or object pointed to by this reference. Note that in order\nto call this function the reference must be owned by the current isolate, otherwise an error will be\nthrown.\n\n##### `reference.derefInto()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to dereference the\nhandle.\n\n##### `reference.release()`\n\nReleases this reference. If you're passing around a lot of references between isolates it's wise to\nrelease the references when you are done. Otherwise you may run into issues with isolates running\nout of memory because other isolates haven't garbage collected recently. After calling this method\nall attempts to access the reference will throw an error.\n\n##### `reference.delete(property)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.deleteIgnored(property)`\n##### `reference.deleteSync(property)`\n* `property` *[transferable]* - The property to access on this object.\n* **return** `true` or `false`\n\nDelete a property from this reference, as if using `delete reference[property]`\n\n##### `reference.get(property, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.getSync(property, options)`\n* `property` *[transferable]* - The property to access on this object.\n* `options` *[object]*\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** A [`Reference`](#class-reference-transferable) object.\n\nWill access a reference as if using `reference[property]` and transfer the value out.\n\n##### `reference.set(property, value, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.setIgnored(property, value, options)`\n##### `reference.setSync(property, value, options)`\n* `property` *[transferable]* - The property to set on this object.\n* `value` *[transferable]* - The value to set on this object.\n* `options` *[object]*\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** `true` or `false`\n\nReturns a boolean indicating whether or not this operation succeeded. I'm actually not really sure\nwhen `false` would be returned, I'm just giving you the result back straight from the v8 API.\n\n##### `reference.apply(receiver, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.applyIgnored(receiver, arguments, options)`\n##### `reference.applySync(receiver, arguments, options)`\n##### `reference.applySyncPromise(receiver, arguments, options)`\n* `receiver` *[transferable]* - The value which will be `this`.\n* `arguments` *[array]* - Array of transferables which will be passed to the function.\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this function is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nWill attempt to invoke an object as if it were a function. If the return value is transferable it\nwill be returned to the caller of `apply`, otherwise it will return an instance of `Reference`. This\nbehavior can be changed with the `result` options.\n\n`applySyncPromise` is a special version of `applySync` which may only be invoked on functions\nbelonging to the default isolate AND may only be invoked from a non-default thread. Functions\ninvoked in this way may return a promise and the invoking isolate will wait for that promise to\nresolve before resuming execution. You can use this to implement functions like `readFileSync` in a\nway that doesn't block the default isolate. Note that the invoking isolate will not respond to any\nasync functions until this promise is resolved, however synchronous functions will still function\ncorrectly. Misuse of this feature may result in deadlocked isolates, though the default isolate\nwill never be at risk of a deadlock.\n\n\n### Class: `ExternalCopy` *[transferable]*\nInstances of this class represent some value that is stored outside of any v8 isolate. This value\ncan then be quickly copied into any isolate without any extra thread synchronization.\n\n##### `new ivm.ExternalCopy(value, options)`\n* `value` - The value to copy.\n* `options` *[object]*\n\t* `transferList` *[boolean]* - An array of `ArrayBuffer` instances to transfer ownership. This\n\t\tbehaves in a similar way to\n\t\t[`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t* `transferOut` *[boolean]* - If true this will release ownership of the given resource from this\n\t\tisolate. This operation completes in constant time since it doesn't have to copy an arbitrarily\n\t\tlarge object. This only applies to ArrayBuffer and TypedArray instances.\n\nPrimitive values can be copied exactly as they are. Date objects will be copied as as Dates.\nArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format. SharedArrayBuffers\nwill simply copy a reference to the existing memory and when copied into another isolate the new\nSharedArrayBuffer will point to the same underlying data. After passing a SharedArrayBuffer to\nExternalCopy for the first time isolated-vm will take over management of the underlying memory\nblock, so a \"copied\" SharedArrayBuffer can outlive the isolate that created the memory originally.\n\nAll other objects will be copied in seralized form using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n`ExternalCopy` can copy objects with deeply nested *transferable* objects. For example:\n\n```js\nlet isolate = new ivm.Isolate;\nlet context = isolate.createContextSync();\nlet global = context.global;\nlet data = new ExternalCopy({ isolate, context, global });\n```\n\n##### `ExternalCopy.totalExternalSize` *[number]*\n\nThis is a static property which will return the total number of bytes that isolated-vm has allocated\noutside of v8 due to instances of `ExternalCopy`.\n\n##### `externalCopy.copy(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** - JavaScript value of the external copy.\n\nInternalizes the ExternalCopy data into this isolate.\n\n##### `externalCopy.copyInto(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to internalize a\ncopy of this value.\n\n#### `externalCopy.release()`\n\nReleases the reference to this copy. If there are other references to this copy elsewhere the copy\nwill still remain in memory, but this handle will no longer be active. Disposing ExternalCopy\ninstances isn't super important, v8 is a lot better at cleaning these up automatically because\nthere's no inter-isolate dependencies.\n\n\n### Shared Options\nMany methods in this library accept common options between them. They are documented here instead of\nbeing colocated with each instance.\n\n##### `CachedDataOptions`\n* `cachedData` *[ExternalCopy[ArrayBuffer]]* - This will consume cached compilation data from a\n\tprevious call to this function. `cachedDataRejected` will be set to `true` if the supplied data\n\twas rejected by V8.\n* `produceCachedData` *[boolean]* - Produce V8 cache data. Similar to the\n\t[VM.Script](https://nodejs.org/api/vm.html) option of the same name. If this is true then the\n\treturned object will have `cachedData` set to an ExternalCopy handle. Note that this differs from\n\tthe VM.Script option slightly in that `cachedDataProduced` is never set.\n\nMost functions which compile or run code can produce and consume cached data. You can produce cached\ndata and use the data in later invocations to drastically speed up parsing of the same script. You\ncan even save this data to disk and use it in a different process. You can set both `cachedData` and\n`produceCachedData`, in which case new cached data will only be produced if the data supplied was\ninvalid.\n\n##### `ScriptOrigin`\n* `filename` *[string]* - Filename of this source code\n* `columnOffset` *[number]* - Column offset of this source code\n* `lineOffset` *[number]* - Line offset of this source code\n\nYou may optionally specify information on compiled code's filename. This is used in various\ndebugging contexts within v8, including stack traces and the inspector. It is recommended to use a\nvalid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools may\nmalfunction.\n\n##### `TransferOptions`\n* `copy` *[boolean]* - Automatically deep copy value\n* `externalCopy` *[boolean]* - Automatically wrap value in `ExternalCopy` instance\n* `reference` *[boolean]* - Automatically wrap value in `Reference` instance\n* `promise` *[boolean]* - Automatically proxy any returned promises between isolates. This can be\n\tused in combination with the other transfer options.\n\nAny function which moves data between isolates will accept these transfer options. By default only\n*[transferable]* values may pass between isolates. Without specifying one of these options the\nfunction may ignore the value, throw, or wrap it in a reference depending on the context.\n\nMore advanced situations like transferring ownership of `ArrayBuffer` instances will require direct\nuse of [`ExternalCopy`](#class-externalcopy-transferable) or\n[`Reference`](#class-reference-transferable).\n\n\nSECURITY\n--------\n\nUse of `isolated-vm` to run untrusted code does not automatically make your application safe.\nThrough carelessness or misuse of the library it can be possible to leak sensitive data or grant\nundesired privileges to an isolate.\n\nAt a minimum you should take care not to leak any instances of `isolated-vm` objects (`Reference`,\n`ExternalCopy`, etc) to untrusted code. It is usually trivial for an attacker to use these instances\nas a springboard back into the nodejs isolate which will yield complete control over a process.\nSimply wrapping these instances in closures is usually enough to keep the internal objects safe. An\nexample of a safe logging function follows:\n\n```js\ncontext.evalClosureSync(\n\t`globalThis.log = (...args) =>\n\t\t$0.applyIgnored(undefined, args, { arguments: { copy: true } });`,\n\t[ (...args) => console.log(...args) ],\n\t{ arguments: { reference: true } });\n```\n\nAgainst potentially hostile code you should also consider turning on [v8 untrusted code\nmitigations](https://v8.dev/docs/untrusted-code-mitigations), which addresses the class of\nspeculative execution attacks known as Spectre and Meltdown. You can enable this feature by running\n`node` with the `--untrusted-code-mitigations` flag. This feature comes with a slight performance\ncost and must be enabled per-process, therefore nodejs disables it by default.\n\nv8 is a relatively robust runtime, but there are always new and exciting ways to crash, hang, or\notherwise disrupt a process with plain old JavaScript. Your application must be resilient to these\nkinds of issues. It's a good idea to keep instances of `isolated-vm` in a different nodejs process\nthan other critical infrastructure.\n\n\nEXAMPLES\n--------\n\nBelow is a sample program which shows basic usage of the library.\n\n```js\n// Create a new isolate limited to 128MB\nconst ivm = require('isolated-vm');\nconst isolate = new ivm.Isolate({ memoryLimit: 128 });\n\n// Create a new context within this isolate. Each context has its own copy of all the builtin\n// Objects. So for instance if one context does Object.prototype.foo = 1 this would not affect any\n// other contexts.\nconst context = isolate.createContextSync();\n\n// Get a Reference{} to the global object within the context.\nconst jail = context.global;\n\n// This makes the global object available in the context as `global`. We use `derefInto()` here\n// because otherwise `global` would actually be a Reference{} object in the new isolate.\njail.setSync('global', jail.derefInto());\n\n// We will create a basic `log` function for the new isolate to use.\njail.setSync('log', function(...args) {\n\tconsole.log(...args);\n});\n\n// And let's test it out:\ncontext.evalSync('log(\"hello world\")');\n// > hello world\n\n// Let's see what happens when we try to blow the isolate's memory\nconst hostile = isolate.compileScriptSync(`\n\tconst storage = [];\n\tconst twoMegabytes = 1024 * 1024 * 2;\n\twhile (true) {\n\t\tconst array = new Uint8Array(twoMegabytes);\n\t\tfor (let ii = 0; ii < twoMegabytes; ii += 4096) {\n\t\t\tarray[ii] = 1; // we have to put something in the array to flush to real memory\n\t\t}\n\t\tstorage.push(array);\n\t\tlog('I\\\\'ve wasted '+ (storage.length * 2)+ 'MB');\n\t}\n`);\n\n// Using the async version of `run` so that calls to `log` will get to the main node isolate\nhostile.run(context).catch(err => console.error(err));\n// I've wasted 2MB\n// I've wasted 4MB\n// ...\n// I've wasted 130MB\n// I've wasted 132MB\n// RangeError: Array buffer allocation failed\n```\n\nAnother example which shows how calls to the asynchronous methods will execute in separate threads\nproviding you with parallelism. Note that each isolate only \"owns\" a thread while it is executing.\nSo you could have hundreds of isolates sitting idle and they would not be using a thread.\n```js\n// A simple function to sum a range of numbers. This can also be expressed as:\n// (max * (max - 1) - min * (min - 1)) / 2\n// But this is an easy way to show off the async features of the module.\nfunction sum(min, max) {\n\tlet sum = 0;\n\tfor (let ii = min; ii < max; ++ii) {\n\t\tsum += ii;\n\t}\n\treturn sum;\n}\n\n// I chose this number because it's big but also small enough that we don't go past JS's integer\n// limit.\nlet num = Math.pow(2, 27);\n\n// First we execute a single thread run\nlet start1 = new Date;\nlet result = sum(0, num);\nconsole.log('Calculated '+ result+ ' in '+ (Date.now() - start1)+ 'ms');\n\n// Now we do the same thing over 4 threads\nlet start2 = new Date;\nlet ivm = require('isolated-vm');\nlet numThreads = 4;\nlet promises = Array(numThreads).fill().map(async function(_, ii) {\n\n\t// Set up 4 isolates with the `sum` function from above\n\tlet isolate = new ivm.Isolate();\n\tlet context = await isolate.createContext();\n\tlet script = await isolate.compileScript(sum+ '');\n\tawait script.run(context);\n\tlet fnReference = await context.global.get('sum');\n\n\t// Run one slice of the sum loop\n\tlet min = Math.floor(num / numThreads * ii);\n\tlet max = Math.floor(num / numThreads * (ii + 1));\n\treturn await fnReference.apply(undefined, [ min, max ]);\n});\nPromise.all(promises).then(function(sums) {\n\tlet result = sums.reduce((a, b) => a + b, 0);\n\tconsole.log('Calculated '+ result+ ' in '+ (Date.now() - start2)+ 'ms');\n});\n// They get the same answer but the async version can do it much faster! Even\n// with the overhead of building 4 isolates\n// > Calculated 9007199187632128 in 1485ms\n// > Calculated 9007199187632128 in 439ms\n```\n\nIncluded in the repository is an example of how you can write quicksort using a SharedArrayBuffer to\nsort over multiple threads. See: [parallel-sort-example.js](https://github.com/laverdet/isolated-vm/blob/main/parallel-sort-example.js).\n\nALTERNATIVES\n------------\n\nThe primary goal of isolated-vm is to create a powerful and secure environment for running untrusted\nJavaScript code. isolated-vm is also a good way to build single-process multithreaded JavaScript\napplications, though if parallelism of trusted code is your only goal then there are probably better\noptions out there.\n\nBelow is a quick summary of some other options available on nodejs and how they differ from\nisolated-vm. The table headers are defined as follows:\n\n* **Secure**: Safely run untrusted code\n* **Memory Limits**: Possible to set memory limits / safe against heap overflow DoS attacks\n* **Isolated**: Is garbage collection, heap, etc isolated from application\n* **Multithreaded**: Run code on many threads from a single process\n* **Module Support**: Is `require` supported out of the box\n* **Inspector Support**: Chrome DevTools supported\n\n| Module                                                                       | Secure | Memory Limits | Isolated | Multithreaded | Module Support | Inspector Support |\n| ---------------------------------------------------------------------------- | :----: | :-----------: | :------: | :-----------: | :------------: | :---------------: |\n| [vm](https://nodejs.org/api/vm.html)                                         |        |               |          |               |       \u2705       |        \u2705         |\n| [worker_threads](https://nodejs.org/api/worker_threads.html)                 |        |               |    \u2705    |      \u2705       |       \u2705       |        \u2705         |\n| [vm2](https://github.com/patriksimek/vm2)                                    |   \u2705   |               |          |               |       \u2705       |        \u2705         |\n| [tiny-worker](https://github.com/avoidwork/tiny-worker)                      |        |               |    \u2705    |               |       \u2705       |                   |\n| isolated-vm                                                                  |   \u2705   |       \u2705      |    \u2705    |      \u2705       |                |        \u2705         |\n", "declare module \"isolated-vm\" {\n\texport type Transferable =\n\t\t| null\n\t\t| undefined\n\t\t| string\n\t\t| number\n\t\t| boolean\n\t\t| Isolate\n\t\t| Context\n\t\t| Script\n\t\t| ExternalCopy<any>\n\t\t| Copy<any>\n\t\t| Reference<any>\n\t\t| Dereference<any>\n\t\t| Module\n\t\t| typeof import(\"isolated-vm\");\n\n\t/**\n\t * This is the main reference to an isolate. Every handle to an isolate is transferable, which\n\t * means you can give isolates references to each other. An isolate will remain valid as long as\n\t * someone holds a handle to the isolate or anything created inside that isolate. Once an isolate\n\t * is lost the garbage collector should eventually find it and clean up its memory. Since an\n\t * isolate and all it contains can represent quite a large chunk of memory though you may want to\n\t * explicitly call the `dispose()` method on isolates that you are finished with to get that memory\n\t * back immediately.\n\t */\n\texport class Isolate {\n\t\tprivate __ivm_isolate: undefined;\n\t\tconstructor(options?: IsolateOptions);\n\n\t\t/**\n\t\t * The total CPU time spent in this isolate. CPU time is the amount of time the isolate has\n\t\t * spent actively doing work on the CPU.\n\t\t *\n\t\t * Note that CPU time may vary drastically if there is contention for the CPU. This could occur\n\t\t * if other processes are trying to do work, or if you have more than\n\t\t * require('os').cpus().length isolates currently doing work in the same nodejs process.\n\t\t */\n\t\treadonly cpuTime: bigint;\n\n\t\t/**\n\t\t * Flag that indicates whether this isolate has been disposed.\n\t\t */\n\t\treadonly isDisposed: boolean;\n\n\t\t/**\n\t\t * The total wall time spent in this isolate. Wall time is the amount of time the isolate has\n\t\t * been running, including passive time spent waiting (think \"wall\" like a clock on the wall).\n\t\t * For instance, if an isolate makes a call into another isolate, wall time will continue\n\t\t * increasing while CPU time will remain the same.\n\t\t */\n\t\treadonly wallTime: bigint;\n\n\t\t/**\n\t\t * Returns the total count of active `Reference` instances that belong to this isolate. Note\n\t\t * that in certain cases many `Reference` instances in JavaScript will point to the same\n\t\t * underlying reference handle, in which case this number will only reflect the underlying\n\t\t * reference handle. This happens when you transfer a `Reference` instance via some method which\n\t\t * accepts transferable values. This will also include underlying reference handles created by\n\t\t * isolated-vm like `Script` or `Context` objects.\n\t\t */\n\t\treadonly referenceCount: number;\n\n\t\t/**\n\t\t * Isolate snapshots are a very useful feature if you intend to create several isolates running\n\t\t * common libraries between them. A snapshot serializes the entire v8 heap including parsed code,\n\t\t * global variables, and compiled code. Check out the examples section for tips on using this.\n\t\t *\n\t\t * **Please note that versions of nodejs 10.4.0 - 10.9.0 may crash while using the snapshot\n\t\t * feature.**\n\t\t *\n\t\t * @param warmup_script - Optional script to \"warmup\" the snapshot by triggering code compilation\n\t\t */\n\t\tstatic createSnapshot(scripts: SnapshotScriptInfo[], warmup_script?: string): ExternalCopy<ArrayBuffer>;\n\n\t\tcompileScript(code: string, scriptInfo?: ScriptInfo): Promise<Script>;\n\t\tcompileScriptSync(code: string, scriptInfo?: ScriptInfo): Script;\n\n\t\tcompileModule(code: string, scriptInfo?: ScriptInfo): Promise<Module>;\n\t\tcompileModuleSync(code: string, scriptInfo?: ScriptInfo): Module;\n\n\t\tcreateContext(options?: ContextOptions): Promise<Context>;\n\t\tcreateContextSync(options?: ContextOptions): Context;\n\n\t\tcreateInspectorSession(): InspectorSession;\n\n\t\t/**\n\t\t * Destroys this isolate and invalidates all references obtained from it.\n\t\t */\n\t\tdispose(): void;\n\n\t\t/**\n\t\t * Returns heap statistics from v8.\n\t\t *\n\t\t * The return value is almost identical to the nodejs function v8.getHeapStatistics().\n\t\t *\n\t\t * See: https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics.\n\t\t *\n\t\t * This function returns one additional property: \"externally_allocated_size\" which is the total\n\t\t * amount of currently allocated memory which is not included in the v8 heap but counts against\n\t\t * this isolate's \"memoryLimit\".\n\t\t *\n\t\t * ArrayBuffer instances over a certain size are externally allocated and will be counted here.\n\t\t */\n\t\tgetHeapStatistics(): Promise<HeapStatistics>;\n\t\tgetHeapStatisticsSync(): HeapStatistics;\n\t}\n\n\texport type IsolateOptions = {\n\t\t/**\n\t\t * Memory limit that this isolate may use, in MB. Note that this is more of a guideline\n\t\t * instead of a strict limit. A determined attacker could use 2-3 times this limit before\n\t\t * their script is terminated. Against non-hostile code this limit should be pretty close. The\n\t\t * default is 128MB and the mimium is 8MB.\n\t\t */\n\t\tmemoryLimit?: number;\n\n\t\t/**\n\t\t * Enable v8 inspector support in this isolate. See `inspector-example.js` in this repository\n\t\t * for an example of how to use this.\n\t\t */\n\t\tinspector?: boolean;\n\n\t\t/**\n\t\t * This is an optional snapshot created from `createSnapshot` which will be used to initialize\n\t\t * the heap of this isolate.\n\t\t */\n\t\tsnapshot?: ExternalCopy<ArrayBuffer>;\n\t};\n\n\texport type ContextOptions = {\n\t\tinspector?: boolean;\n\t};\n\n\texport type HeapStatistics = {\n\t\ttotal_heap_size: number;\n\t\ttotal_heap_size_executable: number;\n\t\ttotal_physical_size: number;\n\t\ttotal_available_size: number;\n\t\tused_heap_size: number;\n\t\theap_size_limit: number;\n\t\tmalloced_memory: number;\n\t\tpeak_malloced_memory: number;\n\t\tdoes_zap_garbage: number;\n\n\t\t/**\n\t\t * The total amount of currently allocated memory which is not included in the v8 heap but\n\t\t * counts against this isolate's \"memoryLimit\".\n\t\t */\n\t\texternally_allocated_size: number;\n\t};\n\n\t/**\n\t * A context is a sandboxed execution environment within an isolate. Each context contains its own\n\t * built-in objects and global space.\n\t */\n\texport class Context {\n\t\tprivate __ivm_context: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * `Reference` to this context's global object. Note that if you call `context.release()` the\n\t\t * global reference will be released as well.\n\t\t */\n\t\treadonly global: Reference<Record<number | string | symbol, any>>;\n\n\t\t/**\n\t\t * Compiles and executes a script within a context. This will return the last value evaluated,\n\t\t * as long as that value was transferable, otherwise `undefined` will be returned.\n\t\t */\n\t\teval<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): Promise<ResultTypeSync<Options>>; // `ResultTypeSync` used intentionally\n\t\tevalIgnored(code: string, options?: ContextEvalOptions): void\n\t\tevalSync<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): ResultTypeSync<Options>;\n\n\t\t/**\n\t\t * Compiles and runs code as if it were inside a function, similar to the seldom-used `new\n\t\t * Function(code)` constructor. You can pass arguments to the function and they will be\n\t\t * available as `$0`, `$1`, and so on. You can also use `return` from the code.\n\t\t */\n\t\tevalClosure<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): Promise<ResultTypeBidirectionalSync<Options>>; // `ResultTypeBidirectionalSync` used intentionally\n\t\tevalClosureIgnored<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): void\n\t\tevalClosureSync<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): ResultTypeBidirectionalSync<Options>;\n\n\t\t/**\n\t\t * Releases this reference to the context. You can call this to free up v8 resources\n\t\t * immediately, or you can let the garbage collector handle it when it feels like it. Note that\n\t\t * if there are other references to this context it will not be disposed. This only affects this\n\t\t * reference to the context.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\texport type ContextEvalOptions = RunOptions & TransferOptions;\n\texport type ContextEvalClosureOptions = RunOptions & TransferOptionsBidirectional;\n\n\t/**\n\t * A script is a compiled chunk of JavaScript which can be executed in any context within a single\n\t * isolate.\n\t */\n\texport class Script {\n\t\tprivate __ivm_script: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * Releases the reference to this script, allowing the script data to be garbage collected.\n\t\t * Functions and data created in the isolate by previous invocations to `script.run(...)` will\n\t\t * still be alive in their respective contexts-- this only means that you can't invoke\n\t\t * `script.run(...)` again with this reference.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Runs a given script within a context. This will return the last value evaluated in a given\n\t\t * script, as long as that value was transferable, otherwise `undefined` will be returned. For\n\t\t * instance if your script was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value\n\t\t * will be 3 because that is the last expression.\n\t\t */\n\t\trun<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeAsync<Options>;\n\t\trunIgnored(context: Context, options?: ScriptRunOptions): void;\n\t\trunSync<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeSync<Options>;\n\t}\n\n\texport type ScriptRunOptions = RunOptions & ReleaseOptions & TransferOptions;\n\n\t/**\n\t * A JavaScript module. Note that a Module can only run in the isolate which created it.\n\t */\n\texport class Module {\n\t\tprivate __ivm_module: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * A read-only array of all dependency specifiers the module has.\n\t\t */\n\t\treadonly dependencySpecifiers: string[];\n\n\t\t/**\n\t\t * Returns a Reference containing all exported values.\n\t\t */\n\t\treadonly namespace: Reference<any>;\n\n\t\t/**\n\t\t * Instantiate the module together with all its dependencies. Calling this more than once on a\n\t\t * single module will have no effect.\n\t\t * @param context The context the module should use.\n\t\t * @param resolveCallback This callback is responsible for resolving all direct and indirect\n\t\t * dependencies of this module. It accepts two parameters: specifier and referrer. It must\n\t\t * return a Module instance or a promise which will be used to satisfy the dependency.\n\t\t */\n\t\tinstantiate(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (\n\t\t\t\tspecifier: string,\n\t\t\t\treferrer: Module\n\t\t\t) => Module | Promise<Module>\n\t\t): Promise<void>;\n\t\tinstantiateSync(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (specifier: string, referrer: Module) => Module\n\t\t): void;\n\n\t\t/**\n\t\t * Evaluate the module and return the last expression (same as script.run). If evaluate is\n\t\t * called more than once on the same module the return value from the first invocation will be\n\t\t * returned (or thrown).\n\t\t * @param options Optional\n\t\t */\n\t\tevaluate(options?: ScriptRunOptions): Promise<Transferable>;\n\t\tevaluateSync(options?: ScriptRunOptions): Transferable;\n\t}\n\n\t/**\n\t * A instance of Reference is a pointer to a value stored in any isolate.\n\t */\n\texport class Reference<T = any> {\n\t\tprivate __ivm_reference: T;\n\t\tconstructor(value: T, options?: { inheritUnsafe?: boolean });\n\n\t\t/**\n\t\t * This is the typeof the referenced value, and is available at any time\n\t\t * from any isolate. Note that this differs from the real typeof operator in\n\t\t * that null is \"null\", and Symbols are \"object\".\n\t\t */\n\t\treadonly typeof: string;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t */\n\t\tcopy(): Promise<T>;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t *\n\t\t * @return JavaScript value of the reference.\n\t\t */\n\t\tcopySync(): T;\n\n\t\t/**\n\t\t * Will attempt to return the actual value or object pointed to by this reference. Note that in\n\t\t * order to call this function the reference must be owned by the current isolate, otherwise an\n\t\t * error will be thrown.\n\t\t */\n\t\tderef(options?: ReleaseOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * dereference the handle.\n\t\t */\n\t\tderefInto(options?: ReleaseOptions): Dereference<T>;\n\n\t\t/**\n\t\t * Releases this reference. If you're passing around a lot of references between isolates it's\n\t\t * wise to release the references when you are done. Otherwise you may run into issues with\n\t\t * isolates running out of memory because other isolates haven't garbage collected recently.\n\t\t * After calling this method all attempts to access the reference will throw an error.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Delete a property from this reference, as if using `delete reference[property]`\n\t\t */\n\t\t delete(property: keyof T): Promise<boolean>;\n\t\t deleteIgnored(property: keyof T): void;\n\t\t deleteSync(property: keyof T): boolean;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t */\n\t\tget<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeAsync<Options & AsReference, T[Key]>;\n\t\tgetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeSync<Options & AsReference, T[Key]>;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t *\n\t\t * @return {boolean} Indicating whether or not this operation succeeded. I'm actually not really\n\t\t * sure when false would be returned, I'm just giving you the result back straight from the v8\n\t\t * API.\n\t\t */\n\t\tset<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): Promise<boolean>;\n\t\tsetIgnored<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n\t\tsetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): boolean;\n\n\t\t/**\n\t\t * Will attempt to invoke an object as if it were a function. If the return\n\t\t * value is transferable it will be returned to the called of apply,\n\t\t * otherwise an error will be thrown.\n\t\t */\n\t\tapply<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalAsync<Options & ApplyAsReference, ApplyResult<T>>;\n\t\tapplyIgnored<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options & ApplyAsReference, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): void;\n\t\tapplySync<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & ApplyAsReference, ApplyResult<T>>;\n\n\t\t/**\n\t\t * `applySyncPromise` is a special version of `applySync` which may only be invoked on functions\n\t\t * belonging to the default isolate AND may only be invoked from a non-default thread. Functions\n\t\t * invoked in this way may return a promise and the invoking isolate will wait for that promise\n\t\t * to resolve before resuming execution. You can use this to implement functions like\n\t\t * readFileSync in a way that doesn't block the default isolate. Note that the invoking isolate\n\t\t * will not respond to any async functions until this promise is resolved, however synchronous\n\t\t * functions will still function correctly. Misuse of this feature may result in deadlocked\n\t\t * isolates, though the default isolate will never be at risk of a deadlock.\n\t\t */\n\t\tapplySyncPromise<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & ApplyAsReference, ApplyResult<T>>;\n\t}\n\n\t/**\n\t * Dummy type referencing a type dereferenced into a different Isolate.\n\t */\n\texport class Dereference<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_deref: T;\n\t}\n\n\texport type ReferenceApplyOptions = RunOptions & TransferOptionsBidirectional;\n\n\t/**\n\t * Instances of this class represent some value that is stored outside of any v8\n\t * isolate. This value can then be quickly copied into any isolate.\n\t */\n\texport class ExternalCopy<T = any> {\n\t\tprivate __ivm_external_copy: T;\n\n\t\t/**\n\t\t * Primitive values can be copied exactly as they are. Date objects will be copied as as Dates.\n\t\t * ArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format.\n\t\t * SharedArrayBuffers will simply copy a reference to the existing memory and when copied into\n\t\t * another isolate the new SharedArrayBuffer will point to the same underlying data. After\n\t\t * passing a SharedArrayBuffer to ExternalCopy for the first time isolated-vm will take over\n\t\t * management of the underlying memory block, so a \"copied\" SharedArrayBuffer can outlive the\n\t\t * isolate that created the memory originally.\n\t\t *\n\t\t * All other objects will be copied in seralized form using the [structured clone\n\t\t * algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n\t\t *\n\t\t * `ExternalCopy` can copy objects with deeply nested *transferable* objects.\n\t\t */\n\t\tconstructor(value: T, options?: ExternalCopyOptions);\n\n\t\t/**\n\t\t * Static property which will return the total number of bytes that isolated-vm has allocated\n\t\t * outside of v8 due to instances of `ExternalCopy`.\n\t\t */\n\t\tstatic readonly totalExternalSize: number;\n\n\t\t/**\n\t\t * Internalizes the ExternalCopy data into this isolate.\n\t\t *\n\t\t * @return JavaScript value of the external copy.\n\t\t */\n\t\tcopy(options?: ExternalCopyCopyOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * internalize a copy of this value.\n\t\t */\n\t\tcopyInto(options?: ExternalCopyCopyOptions): Copy<T>;\n\n\t\t/**\n\t\t * Releases the reference to this copy. If there are other references to this copy elsewhere the\n\t\t * copy will still remain in memory, but this handle will no longer be active. Disposing\n\t\t * ExternalCopy instances isn't super important, v8 is a lot better at cleaning these up\n\t\t * automatically because there's no inter-isolate dependencies.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\t/**\n\t * Dummy type referencing a type copied into a different Isolate.\n\t */\n\texport class Copy<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_copy: T;\n\t}\n\n\texport type ExternalCopyOptions = {\n\t\t/**\n\t\t * An array of `ArrayBuffer` instances to transfer ownership. This behaves in a similar way to\n\t\t * [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t\t */\n\t\ttransferList?: any[];\n\t\t/**\n\t\t * If true this will release ownership of the given resource from this isolate. This operation\n\t\t * completes in constant time since it doesn't have to copy an arbitrarily large object. This\n\t\t * only applies to ArrayBuffer and TypedArray instances.\n\t\t */\n\t\ttransferOut?: boolean;\n\t};\n\n\texport type ExternalCopyCopyOptions = ReleaseOptions & {\n\t\t/**\n\t\t * If true this will transfer the resource directly into this isolate, invalidating the\n\t\t * ExternalCopy handle.\n\t\t */\n\t\ttransferIn?: boolean;\n\t};\n\n\t/**\n   * Callbacks can be used to create cross-isolate references to simple functions. This can be\n\t * easier and safer than dealing with the more flexible\n\t * [`Reference`](#class-reference-transferable) class. Arguments passed to and returned from\n\t * callbacks are always copied using the same method as\n\t * [`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate,\n\t * instances of `Callback` will turn into a plain old function. Callbacks are created\n\t * automatically when passing functions to most isolated-vm functions.\n\t */\n\t export class Callback<T extends (...args: any[]) => any = any> {\n\t\tprivate __ivm_callback: T;\n\n\t\tconstructor(value: T, options?: CallbackOptions);\n\t}\n\n\texport type CallbackOptions = {\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a promise.\n\t\t */\n\t\tasync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a value (default).\n\t\t */\n\t\tsync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will ignore the result (including exceptions).\n\t\t */\n\t\tignored?: boolean;\n\n\t\t// The following ensures only 1 invocation option is given.\n\t} & ({\n\t\tasync?: true;\n\t\tsync?: never;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: true;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: never;\n\t\tignored?: true;\n\t});\n\n\t/**\n\t * C++ native module for v8 representation.\n\t */\n\texport class NativeModule {\n\t\tprivate __ivm_native_module: undefined;\n\n\t\t/**\n\t\t * Instantiate a native module with the full path to the compiled library.\n\t\t * For instance, filename would represent the path to a .node file\n\t\t * compiled using node-gyp.\n\t\t *\n\t\t * @param filename Full path to compiled library.\n\t\t */\n\t\tconstructor(filename: string);\n\n\t\t/**\n\t\t * Instantiates the module with a Context by running the `InitForContext`\n\t\t * symbol, throws if that symbol is not present.\n\t\t *\n\t\t * Returned Reference<NativeModule> should be dereferenced into a context\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreate(context: Context): Promise<Reference<any>>;\n\n\t\t/**\n\t\t * Synchronous version of `create`\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreateSync(context: Context): Reference<any>;\n\t}\n\n\texport type InspectorSession = {\n\t\tdispatchProtocolMessage(message: string): void;\n\t\tdispose(): void;\n\t\tonNotification: (message: string) => void;\n\t\tonResponse: (callId: number, message: string) => void;\n\t};\n\n\t/**\n\t * Most functions which compile or run code can produce and consume cached data. You can produce\n\t * cached data and use the data in later invocations to drastically speed up parsing of the same\n\t * script. You can even save this data to disk and use it in a different process. You can set both\n\t * `cachedData` and `produceCachedData`, in which case new cached data will only be produced if\n\t * the data supplied was invalid.\n\t */\n\texport type CachedDataOptions = {\n\t\t/**\n\t\t * This will consume cached compilation data from a previous call to this function. Please don't\n\t\t * use `produceCachedData` and `cachedData` options at the same time. `cachedDataRejected` will\n\t\t * be set to `true` if the supplied data was rejected by V8.\n\t\t */\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\t/**\n\t\t * Produce V8 cache data. Similar to the [VM.Script](https://nodejs.org/api/vm.html) option of\n\t\t * the same name. If this is true then the returned object will have `cachedData` set to an\n\t\t * ExternalCopy handle. Note that this differs from the VM.Script option slightly in that\n\t\t * `cachedDataProduced` is never set.\n\t\t */\n\t\tproduceCachedData?: boolean;\n\t};\n\n\texport type CachedDataResult = {\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\tproducedCacheData?: boolean;\n\t};\n\n\texport type ReleaseOptions = {\n\t\t/**\n\t\t * If true release() will automatically be called on this instance.\n\t\t */\n\t\trelease?: boolean;\n\t};\n\n\texport type RunOptions = {\n\t\t/**\n\t\t * Maximum amount of time in milliseconds this script is allowed to run before execution is\n\t\t * canceled. Default is no timeout.\n\t\t */\n\t\ttimeout?: number;\n\t};\n\n\t/**\n\t * You may optionally specify information on compiled code's filename. This is used in various\n\t * debugging contexts within v8, including stack traces and the inspector. It is recommended to\n\t * use a valid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools\n\t * may malfunction.\n\t */\n\texport type ScriptOrigin = {\n\t\t/**\n\t\t * Filename of this source code\n\t\t */\n\t\tfilename?: string;\n\n\t\t/**\n\t\t * Column offset of this source code\n\t\t */\n\t\tcolumnOffset?: number;\n\n\t\t/**\n\t\t * Line offset of this source code\n\t\t */\n\t\tlineOffset?: number;\n\t};\n\n\texport type SnapshotScriptInfo = ScriptOrigin & {\n\t\t/**\n\t\t * Source code to set up this snapshot\n\t\t */\n\t\tcode: string;\n\t};\n\texport type ScriptInfo = CachedDataOptions & ScriptOrigin;\n\n\t/**\n\t * Any function which moves data between isolates will accept these transfer options. By default\n\t * only *[transferable]* values may pass between isolates. Without specifying one of these options\n\t * the function may ignore the value, throw, or wrap it in a reference depending on the context.\n\t *\n\t * More advanced situations like transferring ownership of `ArrayBuffer` instances will require\n\t * direct use of `ExternalCopy` or `Reference`.\n\t */\n\texport type TransferOptions = {\n\t\t/**\n\t\t * Automatically proxy any returned promises between isolates. This can be used in combination\n\t\t * with the other transfer options.\n\t\t */\n\t\tpromise?: boolean;\n\n\t\t/**\n\t\t * Automatically deep copy value\n\t\t */\n\t\tcopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `ExternalCopy` instance\n\t\t */\n\t\texternalCopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `Reference` instance\n\t\t */\n\t\treference?: boolean;\n\n\t\t// The following ensures only 1 transfer option is given.\n\t} & ({\n\t\t copy?: true;\n\t\t externalCopy?: never;\n\t\t reference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: true;\n\t\treference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: never;\n\t\treference?: true;\n\t });\n\n\texport type TransferOptionsBidirectional = {\n\t\t/**\n\t\t * `TransferOptions` for the values going *into* this isolate.\n\t\t */\n\t\targuments?: TransferOptions;\n\t\t/**\n\t\t * `TransferOptions` for the values coming *out* of this isolate.\n\t\t */\n\t\tresult?: TransferOptions;\n\t};\n\n\t// Discriminating types for TransferOptions\n\ttype WithPromise = { promise: true };\n\ttype AsCopy = { copy: true };\n\ttype AsExternal = { externalCopy: true };\n\ttype AsReference = { reference: true };\n\ttype ApplyAsReference = { result: AsReference };\n\ttype WithTransfer = AsCopy | AsExternal | AsReference;\n\n\t// Wraps a type in Promise<> if the options specify { promise: true }\n\ttype CheckPromise<Options, Result> = Options extends WithPromise ? Promise<Result> : Result;\n\n\t// Type of a single argument for functions that accept TransferOptions\n\ttype ArgumentType<Options, Type> =\n\t\t(Options extends WithTransfer ? Type | CheckPromise<Options, Type> :\n\t\tType extends Transferable ? Type | CheckPromise<Options, Type> :\n\t\tTransferable | CheckPromise<Options, Transferable>) |\n\t\tCopy<Type> | Dereference<Type>;\n\n\t// Return type for functions that accept TransferOptions\n\ttype ResultTypeBase<Options, Result> =\n\t\tOptions extends AsCopy ? Result :\n\t\tOptions extends AsExternal ? ExternalCopy<Result> :\n\t\tOptions extends AsReference ? Reference<Result> :\n\t\tResult extends Transferable ? Result :\n\t\tResult extends void ? void :\n\t\tTransferable;\n\ttype ResultTypeAsync<Options extends TransferOptions, Result = any> = Promise<ResultTypeBase<Options, Result>>;\n\ttype ResultTypeSync<Options extends TransferOptions, Result = any> = CheckPromise<Options, ResultTypeBase<Options, Result>>;\n\n\t// Arguments type for functions that accept TransferOptionsBidirectional\n\ttype ArgumentsTypeBidirectional<Options extends TransferOptionsBidirectional, Args extends any[] = any[]> = {\n\t\t[Key in keyof Args]: ArgumentType<Options['arguments'] extends TransferOptions ? Options['arguments'] : {}, Args[Key]>\n\t};\n\n\t// Result type for functions that accept TransferOptionsBidirectional\n\ttype ResultTypeBidirectionalBase<Options extends TransferOptionsBidirectional, Result> =\n\t\tResultTypeBase<Options['result'] extends TransferOptions ? Options['result'] : {}, Result>;\n\ttype ResultTypeBidirectionalAsync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tPromise<ResultTypeBidirectionalBase<Options, Result>>;\n\ttype ResultTypeBidirectionalSync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tCheckPromise<Options['result'], ResultTypeBidirectionalBase<Options, Result>>;\n\n\t// Types for `Reference.apply`\n\ttype ApplyArguments<Value> = Value extends (...args: infer Args) => unknown ? Args : any[];\n\ttype ApplyArgumentThis<Value> = Value extends (this: infer This, ...args: any) => unknown ? This : undefined | null;\n\ttype ApplyResult<Value> = Value extends (...args: any) => infer Result ? Result : unknown;\n}\n", "#pragma once\n#include \"isolate/generic/error.h\"\n#include \"isolate/generic/handle_cast.h\"\n#include <v8.h>\n\nnamespace ivm {\n\nclass StringTable {\n\tpublic:\n\t\tclass String {\n\t\t\tpublic:\n\t\t\t\tString(const char* value) : value{value} {} // NOLINT(hicpp-explicit-conversions)\n\t\t\t\tString(const String&) = delete;\n\t\t\t\tString(String&&) = delete;\n\t\t\t\t~String() = default;\n\t\t\t\tauto operator=(const String&) = delete;\n\t\t\t\tauto operator=(String&&) = delete;\n\n\t\t\t\toperator v8::Local<v8::Name>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\treturn v8::Local<v8::String>{*this}.As<v8::Name>();\n\t\t\t\t}\n\n\t\t\t\toperator v8::Local<v8::Value>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\treturn v8::Local<v8::String>{*this}.As<v8::Value>();\n\t\t\t\t}\n\n\t\t\t\toperator v8::Local<v8::String>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\tauto* isolate = v8::Isolate::GetCurrent();\n\t\t\t\t\tif (handle.IsEmpty()) {\n\t\t\t\t\t\tauto local = Unmaybe(v8::String::NewFromOneByte(\n\t\t\t\t\t\t\tisolate, (const uint8_t*)value, v8::NewStringType::kInternalized));\n\t\t\t\t\t\thandle.Set(isolate, local);\n\t\t\t\t\t\treturn local;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn handle.Get(isolate);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tprivate:\n\t\t\t\tconst char* value;\n\t\t\t\tv8::Eternal<v8::String> handle;\n\t\t};\n\n\t\tstatic auto Get() -> auto&;\n\n\t\t// StringTable::Get().\n\t\tString arguments{\"arguments\"};\n\t\tString async{\"async\"};\n\t\tString boolean{\"boolean\"};\n\t\tString cachedData{\"cachedData\"};\n\t\tString cachedDataRejected{\"cachedDataRejected\"};\n\t\tString code{\"code\"};\n\t\tString colonSpace{\": \"};\n\t\tString columnOffset{\"columnOffset\"};\n\t\tString copy{\"copy\"};\n\t\tString externalCopy{\"externalCopy\"};\n\t\tString filename{\"filename\"};\n\t\tString function{\"function\"};\n\t\tString global{\"global\"};\n\t\tString ignored{\"ignored\"};\n\t\tString inheritUnsafe{\"inheritUnsafe\"};\n\t\tString inspector{\"inspector\"};\n\t\tString isolateIsDisposed{\"Isolate is disposed\"};\n\t\tString isolatedVm{\"isolated-vm\"};\n\t\tString length{\"length\"};\n\t\tString lineOffset{\"lineOffset\"};\n\t\tString message{\"message\"};\n\t\tString name{\"name\"};\n\t\tString null{\"null\"};\n\t\tString number{\"number\"};\n\t\tString object{\"object\"};\n\t\tString produceCachedData{\"produceCachedData\"};\n\t\tString promise{\"promise\"};\n\t\tString reference{\"reference\"};\n\t\tString release{\"release\"};\n\t\tString result{\"result\"};\n\t\tString snapshot{\"snapshot\"};\n\t\tString stack{\"stack\"};\n\t\tString string{\"string\"};\n\t\tString timeout{\"timeout\"};\n\t\tString transferIn{\"transferIn\"};\n\t\tString transferList{\"transferList\"};\n\t\tString transferOut{\"transferOut\"};\n\t\tString undefined{\"undefined\"};\n\n\t\tString does_zap_garbage{\"does_zap_garbage\"};\n\t\tString externally_allocated_size{\"externally_allocated_size\"};\n\t\tString heap_size_limit{\"heap_size_limit\"};\n\t\tString malloced_memory{\"malloced_memory\"};\n\t\tString peak_malloced_memory{\"peak_malloced_memory\"};\n\t\tString total_available_size{\"total_available_size\"};\n\t\tString total_heap_size{\"total_heap_size\"};\n\t\tString total_heap_size_executable{\"total_heap_size_executable\"};\n\t\tString total_physical_size{\"total_physical_size\"};\n\t\tString used_heap_size{\"used_heap_size\"};\n};\n\ninline auto HandleCastImpl(\n\t\tStringTable::String& value, const HandleCastArguments& /*arguments*/, HandleCastTag<v8::Local<v8::String>> /*tag*/) {\n\treturn v8::Local<v8::String>{value};\n}\n\n} // namespace ivm\n", "#include \"reference_handle.h\"\n#include \"external_copy/external_copy.h\"\n#include \"isolate/run_with_timeout.h\"\n#include \"isolate/three_phase_task.h\"\n#include \"transferable.h\"\n#include <array>\n\nusing namespace v8;\nusing std::shared_ptr;\nusing std::unique_ptr;\n\nnamespace ivm {\nnamespace {\n\nusing TypeOf = detail::ReferenceData::TypeOf;\nauto InferTypeOf(Local<Value> value) -> TypeOf {\n\tif (value->IsNull()) {\n\t\treturn TypeOf::Null;\n\t} else if (value->IsUndefined()) {\n\t\treturn TypeOf::Undefined;\n\t} else if (value->IsNumber()) {\n\t\treturn TypeOf::Number;\n\t} else if (value->IsString()) {\n\t\treturn TypeOf::String;\n\t} else if (value->IsBoolean()) {\n\t\treturn TypeOf::Boolean;\n\t} else if (value->IsFunction()) {\n\t\treturn TypeOf::Function;\n\t} else {\n\t\treturn TypeOf::Object;\n\t}\n}\n\n/**\n * The return value for .derefInto()\n */\nclass DereferenceHandleTransferable : public Transferable {\n\tpublic:\n\t\tDereferenceHandleTransferable(shared_ptr<IsolateHolder> isolate, RemoteHandle<v8::Value> reference) :\n\t\t\tisolate{std::move(isolate)}, reference{std::move(reference)} {}\n\n\t\tauto TransferIn() -> v8::Local<v8::Value> final {\n\t\t\tif (isolate == IsolateEnvironment::GetCurrentHolder()) {\n\t\t\t\treturn Deref(reference);\n\t\t\t} else {\n\t\t\t\tthrow RuntimeTypeError(\"Cannot dereference this into target isolate\");\n\t\t\t}\n\t\t}\n\n\tprivate:\n\t\tshared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n};\n\nclass DereferenceHandle : public TransferableHandle {\n\tpublic:\n\t\tDereferenceHandle(shared_ptr<IsolateHolder> isolate, RemoteHandle<v8::Value> reference) :\n\t\t\tisolate{std::move(isolate)}, reference{std::move(reference)} {}\n\n\t\tstatic auto Definition() -> v8::Local<v8::FunctionTemplate> {\n\t\t\treturn Inherit<TransferableHandle>(MakeClass(\"Dereference\", nullptr));\n\t\t}\n\n\t\tauto TransferOut() -> std::unique_ptr<Transferable> final {\n\t\t\tif (!reference) {\n\t\t\t\tthrow RuntimeGenericError(\"The return value of `derefInto()` should only be used once\");\n\t\t\t}\n\t\t\treturn std::make_unique<DereferenceHandleTransferable>(std::move(isolate), std::move(reference));\n\t\t}\n\n\tprivate:\n\t\tshared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n};\n\n} // anonymous namespace\n\nnamespace detail {\n\nReferenceData::ReferenceData(Local<Value> value, bool inherit) : ReferenceData{\n\t\tIsolateEnvironment::GetCurrentHolder(),\n\t\tRemoteHandle<Value>(value),\n\t\tRemoteHandle<Context>(Isolate::GetCurrent()->GetCurrentContext()),\n\t\tInferTypeOf(value),\n\t\tinherit} {}\n\nReferenceData::ReferenceData(\n\tshared_ptr<IsolateHolder> isolate,\n\tRemoteHandle<Value> reference,\n\tRemoteHandle<Context> context,\n\tTypeOf type_of,\n\tbool inherit\n) :\n\tisolate{std::move(isolate)},\n\treference{std::move(reference)},\n\tcontext{std::move(context)},\n\ttype_of{type_of},\n\tinherit{inherit} {}\n\n} // namespace detail\n\n/**\n * ReferenceHandle implementation\n */\nauto ReferenceHandle::Definition() -> Local<FunctionTemplate> {\n\treturn Inherit<TransferableHandle>(MakeClass(\n\t\t\"Reference\", ConstructorFunction<decltype(&New), &New>{},\n\t\t\"deref\", MemberFunction<decltype(&ReferenceHandle::Deref), &ReferenceHandle::Deref>{},\n\t\t\"derefInto\", MemberFunction<decltype(&ReferenceHandle::DerefInto), &ReferenceHandle::DerefInto>{},\n\t\t\"release\", MemberFunction<decltype(&ReferenceHandle::Release), &ReferenceHandle::Release>{},\n\t\t\"copy\", MemberFunction<decltype(&ReferenceHandle::Copy<1>), &ReferenceHandle::Copy<1>>{},\n\t\t\"copySync\", MemberFunction<decltype(&ReferenceHandle::Copy<0>), &ReferenceHandle::Copy<0>>{},\n\t\t\"delete\", MemberFunction<decltype(&ReferenceHandle::Delete<1>), &ReferenceHandle::Delete<1>>{},\n\t\t\"deleteIgnored\", MemberFunction<decltype(&ReferenceHandle::Delete<2>), &ReferenceHandle::Delete<2>>{},\n\t\t\"deleteSync\", MemberFunction<decltype(&ReferenceHandle::Delete<0>), &ReferenceHandle::Delete<0>>{},\n\t\t\"get\", MemberFunction<decltype(&ReferenceHandle::Get<1>), &ReferenceHandle::Get<1>>{},\n\t\t\"getSync\", MemberFunction<decltype(&ReferenceHandle::Get<0>), &ReferenceHandle::Get<0>>{},\n\t\t\"set\", MemberFunction<decltype(&ReferenceHandle::Set<1>), &ReferenceHandle::Set<1>>{},\n\t\t\"setIgnored\", MemberFunction<decltype(&ReferenceHandle::Set<2>), &ReferenceHandle::Set<2>>{},\n\t\t\"setSync\", MemberFunction<decltype(&ReferenceHandle::Set<0>), &ReferenceHandle::Set<0>>{},\n\t\t\"apply\", MemberFunction<decltype(&ReferenceHandle::Apply<1>), &ReferenceHandle::Apply<1>>{},\n\t\t\"applyIgnored\", MemberFunction<decltype(&ReferenceHandle::Apply<2>), &ReferenceHandle::Apply<2>>{},\n\t\t\"applySync\", MemberFunction<decltype(&ReferenceHandle::Apply<0>), &ReferenceHandle::Apply<0>>{},\n\t\t\"applySyncPromise\", MemberFunction<decltype(&ReferenceHandle::Apply<4>), &ReferenceHandle::Apply<4>>{},\n\t\t\"typeof\", MemberAccessor<decltype(&ReferenceHandle::TypeOfGetter), &ReferenceHandle::TypeOfGetter>{}\n\t));\n}\n\nauto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}\n\nauto ReferenceHandle::TransferOut() -> unique_ptr<Transferable> {\n\treturn std::make_unique<ReferenceHandleTransferable>(*this);\n}\n\n/**\n * Getter for typeof property.\n */\nauto ReferenceHandle::TypeOfGetter() -> Local<Value> {\n\tCheckDisposed();\n\tswitch (type_of) {\n\t\tcase TypeOf::Null:\n\t\t\treturn StringTable::Get().null;\n\t\tcase TypeOf::Undefined:\n\t\t\treturn StringTable::Get().undefined;\n\t\tcase TypeOf::Number:\n\t\t\treturn StringTable::Get().number;\n\t\tcase TypeOf::String:\n\t\t\treturn StringTable::Get().string;\n\t\tcase TypeOf::Boolean:\n\t\t\treturn StringTable::Get().boolean;\n\t\tcase TypeOf::Object:\n\t\t\treturn StringTable::Get().object;\n\t\tcase TypeOf::Function:\n\t\t\treturn StringTable::Get().function;\n\t}\n\tstd::terminate();\n}\n\n/**\n * Attempt to return this handle to the current context.\n */\nauto ReferenceHandle::Deref(MaybeLocal<Object> maybe_options) -> Local<Value> {\n\tCheckDisposed();\n\tif (isolate.get() != IsolateEnvironment::GetCurrentHolder().get()) {\n\t\tthrow RuntimeTypeError(\"Cannot dereference this from current isolate\");\n\t}\n\tbool release = ReadOption<bool>(maybe_options, StringTable::Get().release, false);\n\tLocal<Value> ret = ivm::Deref(reference);\n\tif (release) {\n\t\tRelease();\n\t}\n\treturn ret;\n}\n\n/**\n * Return a handle which will dereference itself when passing into another isolate.\n */\nauto ReferenceHandle::DerefInto(MaybeLocal<Object> maybe_options) -> Local<Value> {\n\tCheckDisposed();\n\tbool release = ReadOption<bool>(maybe_options, StringTable::Get().release, false);\n\tLocal<Value> ret = ClassHandle::NewInstance<DereferenceHandle>(isolate, reference);\n\tif (release) {\n\t\tRelease();\n\t}\n\treturn ret;\n}\n\n/**\n * Release this reference.\n */\nauto ReferenceHandle::Release() -> Local<Value> {\n\tCheckDisposed();\n\tisolate.reset();\n\treference = {};\n\tcontext = {};\n\treturn Undefined(Isolate::GetCurrent());\n}\n\n/**\n * Call a function, like Function.prototype.apply\n */\nclass ApplyRunner : public ThreePhaseTask {\n\tpublic:\n\t\tApplyRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tMaybeLocal<Value> recv_handle,\n\t\t\tMaybe<ArrayRange> maybe_arguments,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\tcontext{that.context}, reference{that.reference}\n\t\t{\n\t\t\tthat.CheckDisposed();\n\n\t\t\t// Get receiver, holder, this, whatever\n\t\t\tLocal<Value> recv_local;\n\t\t\tif (recv_handle.ToLocal(&recv_local)) {\n\t\t\t\trecv = TransferOut(recv_local);\n\t\t\t}\n\n\t\t\t// Get run options\n\t\t\tTransferOptions arguments_transfer_options;\n\t\t\tLocal<Object> options;\n\t\t\tif (maybe_options.ToLocal(&options)) {\n\t\t\t\ttimeout = ReadOption<int32_t>(options, StringTable::Get().timeout, 0);\n\t\t\t\targuments_transfer_options = TransferOptions{\n\t\t\t\t\tReadOption<MaybeLocal<Object>>(options, StringTable::Get().arguments, {})};\n\t\t\t\treturn_transfer_options = TransferOptions{\n\t\t\t\t\tReadOption<MaybeLocal<Object>>(options, StringTable::Get().result, {}),\n\t\t\t\t\tTransferOptions::Type::Reference};\n\t\t\t}\n\n\t\t\t// Externalize all arguments\n\t\t\tArrayRange arguments;\n\t\t\tif (maybe_arguments.To(&arguments)) {\n\t\t\t\targv.reserve(std::distance(arguments.begin(), arguments.end()));\n\t\t\t\tfor (auto argument : arguments) {\n\t\t\t\t\targv.push_back(TransferOut(argument, arguments_transfer_options));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\t// Invoke in the isolate\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> fn = Deref(reference);\n\t\t\tif (!fn->IsFunction()) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not a function\");\n\t\t\t}\n\t\t\tstd::vector<Local<Value>> argv_inner = TransferArguments();\n\t\t\tLocal<Value> recv_inner = recv->TransferIn();\n\t\t\tLocal<Value> result = RunWithTimeout(timeout,\n\t\t\t\t[&fn, &context_handle, &recv_inner, &argv_inner]() {\n\t\t\t\t\treturn fn.As<Function>()->Call(context_handle, recv_inner, argv_inner.size(), argv_inner.empty() ? nullptr : &argv_inner[0]);\n\t\t\t\t}\n\t\t\t);\n\t\t\tret = TransferOut(result, return_transfer_options);\n\t\t}\n\n\t\tauto Phase2Async(Scheduler::AsyncWait& wait) -> bool final {\n\t\t\t// Same as regular `Phase2()` but if it returns a promise we will wait on it\n\t\t\tif (!(return_transfer_options == TransferOptions{TransferOptions::Type::Reference})) {\n\t\t\t\tthrow RuntimeTypeError(\"`result` options are not available for `applySyncPromise`\");\n\t\t\t}\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> fn = Deref(reference);\n\t\t\tif (!fn->IsFunction()) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not a function\");\n\t\t\t}\n\t\t\tLocal<Value> recv_inner = recv->TransferIn();\n\t\t\tstd::vector<Local<Value>> argv_inner = TransferArguments();\n\t\t\tLocal<Value> value = RunWithTimeout(\n\t\t\t\ttimeout,\n\t\t\t\t[&fn, &context_handle, &recv_inner, &argv_inner]() {\n\t\t\t\t\treturn fn.As<Function>()->Call(context_handle, recv_inner, argv_inner.size(), argv_inner.empty() ? nullptr : &argv_inner[0]);\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (value->IsPromise()) {\n\t\t\t\tIsolate* isolate = Isolate::GetCurrent();\n\t\t\t\t// This is only called from the default isolate, so we don't need an IsolateSpecific\n\t\t\t\tstatic Persistent<Function> callback_persistent{isolate, CompileAsyncWrapper()};\n\t\t\t\tLocal<Function> callback_fn = Deref(callback_persistent);\n\t\t\t\tdid_finish = std::make_shared<bool>(false);\n\t\t\t\tstd::array<Local<Value>, 3> argv;\n\t\t\t\targv[0] = External::New(isolate, reinterpret_cast<void*>(this));\n\t\t\t\targv[1] = External::New(isolate, reinterpret_cast<void*>(new shared_ptr<bool>(did_finish)));\n\t\t\t\targv[2] = value;\n\t\t\t\tasync_wait = &wait;\n\t\t\t\tUnmaybe(callback_fn->Call(context_handle, callback_fn, 3, &argv.front()));\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tret = TransferOut(value, return_transfer_options);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\tif (did_finish && !*did_finish) {\n\t\t\t\t*did_finish = true;\n\t\t\t\tthrow RuntimeGenericError(\"Script execution timed out.\");\n\t\t\t} else if (async_error) {\n\t\t\t\tIsolate::GetCurrent()->ThrowException(async_error->CopyInto());\n\t\t\t\tthrow RuntimeError();\n\t\t\t} else {\n\t\t\t\treturn ret->TransferIn();\n\t\t\t}\n\t\t}\n\n\tprivate:\n\t\t/**\n\t\t * This is an internal callback that will be called after a Promise returned from\n\t\t * `applySyncPromise` has resolved\n\t\t */\n\t\tstatic void AsyncCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n\t\t\t// It's possible the invocation timed out, in which case the ApplyRunner will be dead. The\n\t\t\t// shared_ptr<bool> here will be marked as true and we can exit early.\n\t\t\tunique_ptr<shared_ptr<bool>> did_finish{reinterpret_cast<shared_ptr<bool>*>(info[1].As<External>()->Value())};\n\t\t\tif (**did_finish) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tApplyRunner& self = *reinterpret_cast<ApplyRunner*>(info[0].As<External>()->Value());\n\t\t\tif (info.Length() == 3) {\n\t\t\t\t// Resolved\n\t\t\t\tFunctorRunners::RunCatchExternal(IsolateEnvironment::GetCurrent()->DefaultContext(), [&self, &info]() {\n\t\t\t\t\tself.ret = TransferOut(info[2]);\n\t\t\t\t}, [&self](unique_ptr<ExternalCopy> error) {\n\t\t\t\t\tself.async_error = std::move(error);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Rejected\n\t\t\t\tself.async_error = ExternalCopy::CopyThrownValue(info[3]);\n\t\t\t}\n\t\t\t*self.did_finish = true;\n\t\t\tself.async_wait->Wake();\n\t\t}\n\n\t\t/**\n\t\t * The C++ promise interface is a little clumsy so this does some work in JS for us. This function\n\t\t * is called once and returns a JS function that will be reused.\n\t\t */\n\t\tstatic auto CompileAsyncWrapper() -> Local<Function> {\n\t\t\tIsolate* isolate = Isolate::GetCurrent();\n\t\t\tLocal<Context> context = IsolateEnvironment::GetCurrent()->DefaultContext();\n\t\t\tLocal<Script> script = Unmaybe(Script::Compile(context, v8_string(\n\t\t\t\t\"'use strict';\"\n\t\t\t\t\"(function(AsyncCallback) {\"\n\t\t\t\t\t\"return function(ptr, did_finish, promise) {\"\n\t\t\t\t\t\t\"promise.then(function(val) {\"\n\t\t\t\t\t\t\t\"AsyncCallback(ptr, did_finish, val);\"\n\t\t\t\t\t\t\"}, function(err) {\"\n\t\t\t\t\t\t\t\"AsyncCallback(ptr, did_finish, null, err);\"\n\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\"};\"\n\t\t\t\t\"})\"\n\t\t\t)));\n\t\t\tLocal<Value> outer_fn = Unmaybe(script->Run(context));\n\t\t\tassert(outer_fn->IsFunction());\n\t\t\tLocal<Value> callback_fn = Unmaybe(FunctionTemplate::New(isolate, AsyncCallback)->GetFunction(context));\n\t\t\tLocal<Value> inner_fn = Unmaybe(outer_fn.As<Function>()->Call(context, Undefined(isolate), 1, &callback_fn));\n\t\t\tassert(inner_fn->IsFunction());\n\t\t\treturn inner_fn.As<Function>();\n\t\t}\n\n\t\tauto TransferArguments() -> std::vector<Local<Value>> {\n\t\t\tstd::vector<Local<Value>> argv_inner;\n\t\t\tsize_t argc = argv.size();\n\t\t\targv_inner.reserve(argc);\n\t\t\tfor (size_t ii = 0; ii < argc; ++ii) {\n\t\t\t\targv_inner.emplace_back(argv[ii]->TransferIn());\n\t\t\t}\n\t\t\treturn argv_inner;\n\t\t}\n\n\t\tstd::vector<unique_ptr<Transferable>> argv;\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tunique_ptr<Transferable> recv;\n\t\tunique_ptr<Transferable> ret;\n\t\tuint32_t timeout = 0;\n\t\t// Only used in the AsyncPhase2 case\n\t\tshared_ptr<bool> did_finish;\n\t\tTransferOptions return_transfer_options{TransferOptions::Type::Reference};\n\t\tunique_ptr<ExternalCopy> async_error;\n\t\tScheduler::AsyncWait* async_wait = nullptr;\n};\ntemplate <int async>\nauto ReferenceHandle::Apply(MaybeLocal<Value> recv_handle, Maybe<ArrayRange> maybe_arguments, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, ApplyRunner>(*isolate, *this, recv_handle, maybe_arguments, maybe_options);\n}\n\n/**\n * Copy this reference's value into this isolate\n */\nclass CopyRunner : public ThreePhaseTask {\n\tpublic:\n\t\tCopyRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tRemoteHandle<Context> context,\n\t\t\tRemoteHandle<Value> reference\n\t\t) : context{std::move(context)}, reference{std::move(reference)} {\n\t\t\tthat.CheckDisposed();\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\tContext::Scope context_scope{Deref(context)};\n\t\t\tLocal<Value> value = Deref(reference);\n\t\t\tcopy = ExternalCopy::Copy(value);\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn copy->TransferIn();\n\t\t}\n\n\tprivate:\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tunique_ptr<Transferable> copy;\n};\n\ntemplate <int async>\nauto ReferenceHandle::Copy() -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, CopyRunner>(*isolate, *this, context, reference);\n}\n\n/**\n * Get a property from this reference, returned as another reference\n */\nclass GetRunner : public ThreePhaseTask {\n\tpublic:\n\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn ret->TransferIn();\n\t\t}\n\n\tprivate:\n\t\tunique_ptr<ExternalCopy> key;\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tunique_ptr<Transferable> ret;\n\t\tTransferOptions options;\n\t\tbool inherit;\n};\ntemplate <int async>\nauto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}\n\n/**\n * Delete a property on this reference\n */\nclass DeleteRunner : public ThreePhaseTask {\n\tpublic:\n\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}\n\n\tprivate:\n\t\tunique_ptr<ExternalCopy> key;\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tbool result = false;\n};\ntemplate <int async>\nauto ReferenceHandle::Delete(Local<Value> key_handle) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, DeleteRunner>(*isolate, *this, key_handle);\n}\n\n/**\n * Attempt to set a property on this reference\n */\nclass SetRunner : public ThreePhaseTask {\n\tpublic:\n\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}\n\n\tprivate:\n\t\tunique_ptr<ExternalCopy> key;\n\t\tunique_ptr<Transferable> val;\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tbool did_set = false;\n};\ntemplate <int async>\nauto ReferenceHandle::Set(Local<Value> key_handle, Local<Value> val_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, SetRunner>(*isolate, *this, key_handle, val_handle, maybe_options);\n}\n\nvoid ReferenceHandle::CheckDisposed() const {\n\tif (!reference) {\n\t\tthrow RuntimeGenericError(\"Reference has been released\");\n\t}\n}\n\n/**\n * ReferenceHandleTransferable implementation\n */\nauto ReferenceHandleTransferable::TransferIn() -> Local<Value> {\n\treturn ClassHandle::NewInstance<ReferenceHandle>(std::move(*this));\n}\n\n} // namespace ivm\n", "#pragma once\n#include \"isolate/remote_handle.h\"\n#include \"transferable.h\"\n#include <v8.h>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace ivm {\nnamespace detail {\n\n/**\n * Holds common data for ReferenceHandle and ReferenceHandleTransferable\n */\nclass ReferenceData {\n\tpublic:\n\t\tenum class TypeOf { Null, Undefined, Number, String, Boolean, Object, Function };\n\n\t\texplicit ReferenceData(v8::Local<v8::Value> value, bool inherit = false);\n\t\tReferenceData(\n\t\t\tstd::shared_ptr<IsolateHolder> isolate,\n\t\t\tRemoteHandle<v8::Value> reference,\n\t\t\tRemoteHandle<v8::Context> context,\n\t\t\tTypeOf type_of,\n\t\t\tbool inherit = false\n\t\t);\n\n\tprotected:\n\t\tstd::shared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n\t\tRemoteHandle<v8::Context> context;\n\t\tTypeOf type_of;\n\t\tbool inherit;\n};\n\n} // namespace detail\n\n/**\n * This will be a reference to any v8 Value in any isolate.\n */\nclass ReferenceHandle : public TransferableHandle, public detail::ReferenceData {\n\tfriend class ApplyRunner;\n\tfriend class CopyRunner;\n\tfriend class GetRunner;\n\tfriend class DeleteRunner;\n\tfriend class SetRunner;\n\tpublic:\n\t\tusing TypeOf = detail::ReferenceData::TypeOf;\n\n\t\ttemplate <class ...Args>\n\t\texplicit ReferenceHandle(Args&&... args) : ReferenceData{std::forward<Args>(args)...} {}\n\n\t\tstatic auto Definition() -> v8::Local<v8::FunctionTemplate>;\n\t\tstatic auto New(v8::Local<v8::Value> value, v8::MaybeLocal<v8::Object> options)\n\t\t\t-> std::unique_ptr<ReferenceHandle>;\n\t\tauto TransferOut() -> std::unique_ptr<Transferable> final;\n\n\t\tauto Deref(v8::MaybeLocal<v8::Object> maybe_options) -> v8::Local<v8::Value>;\n\t\tauto DerefInto(v8::MaybeLocal<v8::Object> maybe_options) -> v8::Local<v8::Value>;\n\t\tauto Release() -> v8::Local<v8::Value>;\n\t\tauto TypeOfGetter() -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Apply(\n\t\t\tv8::MaybeLocal<v8::Value> recv_handle,\n\t\t\tv8::Maybe<ArrayRange> maybe_arguments,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Copy() -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Get(\n\t\t\tv8::Local<v8::Value> key_handle,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Delete(v8::Local<v8::Value> key_handle) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Set(\n\t\t\tv8::Local<v8::Value> key_handle,\n\t\t\tv8::Local<v8::Value> val_handle,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\tprivate:\n\t\tvoid CheckDisposed() const;\n};\n\n/**\n * Instances of this turn into a ReferenceHandle when they are transferred in\n */\nclass ReferenceHandleTransferable : public Transferable, public detail::ReferenceData {\n\tpublic:\n\t\ttemplate <class ...Args>\n\t\texplicit ReferenceHandleTransferable(Args&&... args) : ReferenceData{std::forward<Args>(args)...} {}\n\n\t\tauto TransferIn() -> v8::Local<v8::Value> final;\n};\n\n} // namespace ivm\n", "const ivm = require('isolated-vm');\nconst { strictEqual } = require('assert');\n\nconst foo = { foo: 1 };\nconst bar = Object.create(foo);\nbar.bar = 2;\nconst etc = Object.create(bar);\netc.etc = bar;\n{\n\tconst ref = new ivm.Reference(etc);\n\tstrictEqual(ref.getSync('bar'), undefined);\n\tstrictEqual(ref.getSync('etc').getSync('foo'), undefined);\n\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n}\n{\n\tconst ref = new ivm.Reference(etc, { inheritUnsafe: true });\n\tstrictEqual(ref.getSync('bar'), 2);\n\tstrictEqual(ref.getSync('etc').getSync('foo'), 1);\n\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n}\n\nconsole.log('pass');\n"], "fixing_code": ["## v4.0.0\n- `Callback` class addeed.\n- When possible, `reference.get()` will return a function delegate instead of a `Reference`.\n- `reference.get()` will no longer return inherited properties by default.\n- `result` property on `eval` and `evalClosure` has been removed. The result is now just the return\nvalue.\n- All `isolated-vm` class prototypes, and most instances are frozen.\n- `isolate.cpuTime` and `isolate.wallTime` now return bigints.\n- Proxies and accessors are no longer tolerated via `reference.get`, and related functions.\n", "[![npm version](https://badgen.now.sh/npm/v/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n[![isc license](https://badgen.now.sh/npm/license/isolated-vm)](https://github.com/laverdet/isolated-vm/blob/main/LICENSE)\n[![travis build](https://badgen.now.sh/travis/laverdet/isolated-vm/main)](https://travis-ci.org/laverdet/isolated-vm)\n[![npm downloads](https://badgen.now.sh/npm/dm/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n\nisolated-vm -- Access to multiple isolates in nodejs\n====================================================\n\n[![NPM](https://nodei.co/npm/isolated-vm.png)](https://www.npmjs.com/package/isolated-vm)\n\n`isolated-vm` is a library for nodejs which gives you access to v8's `Isolate` interface. This\nallows you to create JavaScript environments which are completely *isolated* from each other. You\nmight find this module useful if you need to run some untrusted code in a secure way. You may also\nfind this module useful if you need to run some JavaScript simultaneously in multiple threads. You\nmay find this project *very* useful if you need to do both at the same time!\n\n* [Requirements](#requirements)\n* [Who Is Using isolated-vm](#who-is-using-isolated-vm)\n* [API Documentation](#api-documentation)\n\t* [Isolate](#class-isolate-transferable)\n\t* [Context](#class-context-transferable)\n\t* [Script](#class-script-transferable)\n\t* [Module](#class-module-transferable)\n\t* [Reference](#class-reference-transferable)\n\t* [ExternalCopy](#class-externalcopy-transferable)\n* [Examples](#examples)\n* [Alternatives](#alternatives)\n\n\nREQUIREMENTS\n------------\n\nThis project requires nodejs LTS version 10.4.0 (or later).\n\nFurthermore, to install this module you will need a compiler installed. If you run into errors while\nrunning `npm install isolated-vm` it is likely you don't have a compiler set up, or your compiler is\ntoo old.\n\n* Windows + OS X users should follow the instuctions here: [node-gyp](https://github.com/nodejs/node-gyp)\n* Ubuntu users should run: `sudo apt-get install python g++ build-essential`\n* Alpine users should run: `sudo apk add python make g++`\n* Amazon Linux AMI users should run: `sudo yum install gcc72 gcc72-c++`\n* Arch Linux users should run: `sudo pacman -S make gcc python`\n\nWHO IS USING ISOLATED-VM\n------------------------\n\n* [Screeps](https://screeps.com/) - Screeps is an online JavaScript-based MMO+RPG game. They are\nusing isolated-vm to run arbitrary player-supplied code in secure enviroments which can persistent\nfor several days at a time.\n\n* [Fly](https://fly.io/) - Fly is a programmable CDN which hosts dynamic endpoints as opposed to\njust static resources. They are using isolated-vm to run globally distributed applications, where\neach application may have wildly different traffic patterns.\n\n* [Algolia](https://www.algolia.com) - Algolia is a Search as a Service provider. They use\n`isolated-vm` to power their [Custom Crawler](https://www.algolia.com/products/crawler/) product,\nwhich allows them to safely execute user-provided code for content extraction.\n\n* [Tripadvisor](https://www.tripadvisor.com) - Tripadvisor is the world\u2019s largest travel platform.\nThey use `isolated-vm` to server-side render thousands of React pages per second.\n\nAPI DOCUMENTATION\n-----------------\n\nSince isolates share no resources with each other, most of this API is built to provide primitives\nwhich make marshalling data between many isolates quick and easy. The only way to pass data from one\nisolate to another is to first make that data *transferable*. Primitives (except for `Symbol`) are\nalways transferable. This means if you invoke a function in a different isolate with a number or\nstring as the argument, it will work fine. If you need to pass more complex information you will\nhave to first make the data transferable with one of the methods here.\n\nMost methods will provide both a synchronous and an asynchronous version. Calling the synchronous\nfunctions will block your thread while the method runs and eventually returns a value. The\nasynchronous functions will return a\n[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\nwhile the work runs in a separate thread pool.\n\nThere are some rules about which functions may be called from certain contexts:\n\n1. Asynchronous functions may be called at any time\n2. Synchronous functions usually may not be called from an asynchronous function\n3. You may call a synchronous function from an asynchronous function as long as that function\n\tbelongs to current isolate\n4. You may call a synchronous function belonging to the default nodejs isolate at any time\n\nAdditionally, some methods will provide an \"ignored\" version which runs asynchronously but returns\nno promise. This can be a good option when the calling isolate would ignore the promise anyway,\nsince the ignored versions can skip an extra thread synchronization. Just be careful because this\nswallows any thrown exceptions which might make problems hard to track down.\n\nIt's also worth noting that all asynchronous invocations will run in the order they were queued,\nregardless of whether or not you wait on them. So, for instance, you could call several \"ignored\"\nmethods in a row and then `await` on a final async method to observe some side-effect of the\nignored methods.\n\n\n### Class: `Isolate` *[transferable]*\nThis is the main reference to an isolate. Every handle to an isolate is transferable, which means\nyou can give isolates references to each other. An isolate will remain valid as long as someone\nholds a handle to the isolate or anything created inside that isolate. Once an isolate is lost the\ngarbage collector should eventually find it and clean up its memory. Since an isolate and all it\ncontains can represent quite a large chunk of memory though you may want to explicitly call the\n`dispose()` method on isolates that you are finished with to get that memory back immediately.\n\n##### `new ivm.Isolate(options)`\n* `options` *[object]*\n\t* `memoryLimit` *[number]* - Memory limit that this isolate may use, in MB. Note that this is more\n\tof a guideline instead of a strict limit. A determined attacker could use 2-3 times this limit\n\tbefore their script is terminated. Against non-hostile code this limit should be pretty close. The\n\tdefault is 128MB and the mimium is 8MB.\n\t* `inspector` *[boolean]* - Enable v8 inspector support in this isolate. See\n\t`inspector-example.js` in this repository for an example of how to use this.\n\t* `snapshot` *[ExternalCopy[ArrayBuffer]]* - This is an optional snapshot created from\n\t`createSnapshot` which will be used to initialize the heap of this isolate.\n\n##### `ivm.Isolate.createSnapshot(scripts, warmup_script)`\n* `scripts` *[array]*\n\t* `code` *[string]* - Source code to set up this snapshot\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n* `warmup_script` *[string]* - Optional script to \"warmup\" the snapshot by triggering code\ncompilation\n\nIsolate snapshots are a very useful feature if you intend to create several isolates running common\nlibraries between them. A snapshot serializes the entire v8 heap including parsed code, global\nvariables, and compiled code. Check out the examples section for tips on using this.\n\n**Note**: `createSnapshot` does not provide the same isolate protection like the rest of\nisolated-vm. If the script passed to `createSnapshot` uses too much memory the process will crash,\nand if it has an infinite loop it will stall the process. Furthermore newer v8 features may simply\nfail when attempting to take a snapshot that uses them. It is best to snapshot code that only\ndefines functions, class, and simple data structures.\n\n**Please note that versions of nodejs 10.4.0 - 10.9.0 may crash while using the snapshot feature.\n\n##### `isolate.compileScript(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileScriptSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Script`](#class-script-transferable) object.\n\nNote that a [`Script`](#class-script-transferable) can only run in the isolate which created it.\n\n##### `isolate.compileModule(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileModuleSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Module`](#class-module-transferable) object.\n\nNote that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `isolate.createContext()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.createContextSync()`\n* `options` *[object]*\n\t* `inspector` *[boolean]* - Enable the v8 inspector for this context. The inspector must have been\n\t\tenabled for the isolate as well.\n\n* **return** A [`Context`](#class-context-transferable) object.\n\n##### `isolate.dispose()`\nDestroys this isolate and invalidates all references obtained from it.\n\n##### `isolate.getHeapStatistics()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.getHeapStatisticsSync()`\n* **return** [object]\n\nReturns heap statistics from v8. The return value is almost identical to the nodejs function\n[v8.getHeapStatistics()](https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics).\nThis function returns one additional property: `externally_allocated_size` which is the total amount\nof currently allocated memory which is not included in the v8 heap but counts against this isolate's\n`memoryLimit`. ArrayBuffer instances over a certain size are externally allocated and will be\ncounted here.\n\n##### `isolate.cpuTime` *bigint*\n##### `isolate.wallTime` *bigint*\nThe total CPU and wall time spent in this isolate, in nanoseconds. CPU time is the amount of time\nthe isolate has spent actively doing work on the CPU. Wall time is the amount of time the isolate\nhas been running, including passive time spent waiting (think \"wall\" like a clock on the wall). For\ninstance, if an isolate makes a call into another isolate, wall time will continue increasing while\nCPU time will remain the same.\n\nNote that in nodejs v10.x the return value is a regular number, since bigint isn't supported on\nearlier versions.\n\nAlso note that CPU time may vary drastically if there is contention for the CPU. This could occur if\nother processes are trying to do work, or if you have more than `require('os').cpus().length`\nisolates currently doing work in the same nodejs process.\n\n##### `isolate.isDisposed` *[boolean]*\nFlag that indicates whether this isolate has been disposed.\n\n##### `isolate.referenceCount` *[number]*\nReturns the total count of active `Reference` instances that belong to this isolate. Note that in\ncertain cases many `Reference` instances in JavaScript will point to the same underlying reference\nhandle, in which case this number will only reflect the underlying reference handle. This happens\nwhen you transfer a `Reference` instance via some method which accepts transferable values. This\nwill also include underlying reference handles created by isolated-vm like `Script` or `Context`\nobjects.\n\n\n### Class: `Context` *[transferable]*\nA context is a sandboxed execution environment within an isolate. Each context contains its own\nbuilt-in objects and global space.\n\n##### `context.global` *[`Reference`](#class-reference-transferable)*\n[`Reference`](#class-reference-transferable) to this context's global object. Note that if you call\n`context.release()` the global reference will be released as well.\n\n##### `context.eval(code, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalIgnored(code, options)`\n##### `context.evalSync(code, options)`\n* `code` *[string]* - The code to run\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nCompiles and executes a script within a context. This will return the last value evaluated, as long\nas that value was transferable, otherwise `undefined` will be returned.\n\n##### `context.evalClosure(code, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalClosureIgnored(code, arguments, options)`\n##### `context.evalClosureSync(code, arguments, options)`\n* `code` *[string]* - The code to run\n* `arguments` *[array]` - Arguments to pass to this code\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** `*[transferable]*\n\nCompiles and runs code as if it were inside a function, similar to the seldom-used `new\nFunction(code)` constructor. You can pass arguments to the function and they will be available as\n`$0`, `$1`, and so on. You can also use `return` from the code.\n\n##### `context.release()`\n\nReleases this reference to the context. You can call this to free up v8 resources immediately, or\nyou can let the garbage collector handle it when it feels like it. Note that if there are other\nreferences to this context it will not be disposed. This only affects this reference to the context.\n\n\n### Class: `Script` *[transferable]*\nA script is a compiled chunk of JavaScript which can be executed in any context within a single\nisolate.\n\n##### `script.release()`\n\nReleases the reference to this script, allowing the script data to be garbage collected. Functions\nand data created in the isolate by previous invocations to `script.run(...)` will still be alive in\ntheir respective contexts-- this only means that you can't invoke `script.run(...)` again with this\nreference.\n\n##### `script.run(context, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `script.runIgnored(context, options)`\n##### `script.runSync(context, options)`\n* `context` *[`Context`](#class-context-transferable)* - The context in which this script will run.\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nRuns a given script within a context. This will return the last value evaluated in a given script,\nas long as that value was transferable, otherwise `undefined` will be returned. For instance if your\nscript was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value will be 3 because that\nis the last expression.\n\n\n### Class: `Module` *[transferable]*\nA JavaScript module. Note that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `module.dependencySpecifiers`\nA read-only array of all dependency specifiers the module has.\n\n\t\tconst code = `import something from './something';`;\n\t\tconst module = await isolate.compileModule(code);\n\t\tconst dependencySpecifiers = module.dependencySpecifiers;\n\t\t// dependencySpecifiers => [\"./something\"];\n\n##### `module.namespace`\nReturns a [`Reference`](#class-reference-transferable) containing all exported values.\n\n##### `module.instantiate(context, resolveCallback)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.instantiateSync(context, resolveCallback)`\n* `context` *[`Context`](#class-context-transferable)* - The context the module should use.\n* `resolveCallback` - This callback is responsible for resolving all direct and indirect\ndependencies of this module. It accepts two parameters: `specifier` and `referrer`. It must return a\n`Module` instance which will be used to satisfy the dependency. The asynchronous version of\n`instantiate` may return a promise from `resolveCallback`.\n\nInstantiate the module together with all its dependencies. Calling this more than once on a single\nmodule will have no effect.\n\n##### `module.evaluate(options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.evaluateSync(options)`\n* `options` *[object]* - Optional.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this module is allowed to\n\trun before execution is canceled. Default is no timeout.\n* **return** *[transferable]*\n\nEvaluate the module and return the last expression (same as script.run). If `evaluate` is called\nmore than once on the same module the return value from the first invocation will be returned (or\nthrown).\n\n**Note:** nodejs v14.8.0 enabled top-level await by default which has the effect of breaking the\nreturn value of this function.\n\n\n### Class: `Callback` *[transferable]*\nCallbacks can be used to create cross-isolate references to simple functions. This can be easier and\nsafer than dealing with the more flexible [`Reference`](#class-reference-transferable) class.\nArguments passed to and returned from callbacks are always copied using the same method as\n[`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate, instances\nof `Callback` will turn into a plain old function. Callbacks are created automatically when passing\nfunctions to most isolated-vm functions.\n\n##### `new ivm.Callback(fn, options)`\n* `options` *[object]*\n\t* `async` *[boolean]* - Function will invoke the callback in \"async\" mode, which immediately\n\t\treturns a promise.\n\t* `ignored` *[boolean]* - Function will invoke the callback in \"ignored\" mode, which immediately\n\t\treturns `undefined` and ignores the result of the function (including thrown exceptions)\n\t* `sync` *[boolean]* - Function will invoke the callback in \"sync\" mode, blocking for a response\n\t\t(default).\n\n\n### Class: `Reference` *[transferable]*\nA instance of [`Reference`](#class-reference-transferable) is a pointer to a value stored in any isolate.\n\n##### `new ivm.Reference(value, options)`\n* `value` - The value to create a reference to.\n* `options` *[object]*\n  * `unsafeInherit` *[boolean]* - If enabled then the `get` family of functions will follow the\n    object's prototype chain. References created with this option should never be given to untrusted\n    code.\n\n##### `reference.typeof` *[string]*\n\nThis is the typeof the referenced value, and is available at any time from any isolate. Note that\nthis differs from the real `typeof` operator in that `null` is \"null\", and Symbols are \"object\".\n\n##### `reference.copy()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.copySync()`\n* **return** JavaScript value of the reference.\n\nCreates a copy of the referenced value and internalizes it into this isolate. This uses the same\ncopy rules as [`ExternalCopy`](#class-externalcopy-transferable).\n\n##### `reference.deref()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** The value referenced by this handle.\n\nWill attempt to return the actual value or object pointed to by this reference. Note that in order\nto call this function the reference must be owned by the current isolate, otherwise an error will be\nthrown.\n\n##### `reference.derefInto()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to dereference the\nhandle.\n\n##### `reference.release()`\n\nReleases this reference. If you're passing around a lot of references between isolates it's wise to\nrelease the references when you are done. Otherwise you may run into issues with isolates running\nout of memory because other isolates haven't garbage collected recently. After calling this method\nall attempts to access the reference will throw an error.\n\n##### `reference.delete(property)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.deleteIgnored(property)`\n##### `reference.deleteSync(property)`\n* `property` *[transferable]* - The property to access on this object.\n\nDelete a property from this reference, as if using `delete reference[property]`\n\n##### `reference.get(property, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.getSync(property, options)`\n* `property` *[transferable]* - The property to access on this object.\n* `options` *[object]*\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** A [`Reference`](#class-reference-transferable) object.\n\nWill access a reference as if using `reference[property]` and transfer the value out.\n\nIf the object is a proxy, or if the property is a getter, this method will throw.\n\n##### `reference.set(property, value, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.setIgnored(property, value, options)`\n##### `reference.setSync(property, value, options)`\n* `property` *[transferable]* - The property to set on this object.\n* `value` *[transferable]* - The value to set on this object.\n* `options` *[object]*\n\t* [`{ ...TransferOptions }`](#transferoptions)\n\n##### `reference.apply(receiver, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.applyIgnored(receiver, arguments, options)`\n##### `reference.applySync(receiver, arguments, options)`\n##### `reference.applySyncPromise(receiver, arguments, options)`\n* `receiver` *[transferable]* - The value which will be `this`.\n* `arguments` *[array]* - Array of transferables which will be passed to the function.\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this function is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nWill attempt to invoke an object as if it were a function. If the return value is transferable it\nwill be returned to the caller of `apply`, otherwise it will return an instance of `Reference`. This\nbehavior can be changed with the `result` options.\n\n`applySyncPromise` is a special version of `applySync` which may only be invoked on functions\nbelonging to the default isolate AND may only be invoked from a non-default thread. Functions\ninvoked in this way may return a promise and the invoking isolate will wait for that promise to\nresolve before resuming execution. You can use this to implement functions like `readFileSync` in a\nway that doesn't block the default isolate. Note that the invoking isolate will not respond to any\nasync functions until this promise is resolved, however synchronous functions will still function\ncorrectly. Misuse of this feature may result in deadlocked isolates, though the default isolate\nwill never be at risk of a deadlock.\n\n\n### Class: `ExternalCopy` *[transferable]*\nInstances of this class represent some value that is stored outside of any v8 isolate. This value\ncan then be quickly copied into any isolate without any extra thread synchronization.\n\n##### `new ivm.ExternalCopy(value, options)`\n* `value` - The value to copy.\n* `options` *[object]*\n\t* `transferList` *[boolean]* - An array of `ArrayBuffer` instances to transfer ownership. This\n\t\tbehaves in a similar way to\n\t\t[`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t* `transferOut` *[boolean]* - If true this will release ownership of the given resource from this\n\t\tisolate. This operation completes in constant time since it doesn't have to copy an arbitrarily\n\t\tlarge object. This only applies to ArrayBuffer and TypedArray instances.\n\nPrimitive values can be copied exactly as they are. Date objects will be copied as as Dates.\nArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format. SharedArrayBuffers\nwill simply copy a reference to the existing memory and when copied into another isolate the new\nSharedArrayBuffer will point to the same underlying data. After passing a SharedArrayBuffer to\nExternalCopy for the first time isolated-vm will take over management of the underlying memory\nblock, so a \"copied\" SharedArrayBuffer can outlive the isolate that created the memory originally.\n\nAll other objects will be copied in seralized form using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n`ExternalCopy` can copy objects with deeply nested *transferable* objects. For example:\n\n```js\nlet isolate = new ivm.Isolate;\nlet context = isolate.createContextSync();\nlet global = context.global;\nlet data = new ExternalCopy({ isolate, context, global });\n```\n\n##### `ExternalCopy.totalExternalSize` *[number]*\n\nThis is a static property which will return the total number of bytes that isolated-vm has allocated\noutside of v8 due to instances of `ExternalCopy`.\n\n##### `externalCopy.copy(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** - JavaScript value of the external copy.\n\nInternalizes the ExternalCopy data into this isolate.\n\n##### `externalCopy.copyInto(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to internalize a\ncopy of this value.\n\n#### `externalCopy.release()`\n\nReleases the reference to this copy. If there are other references to this copy elsewhere the copy\nwill still remain in memory, but this handle will no longer be active. Disposing ExternalCopy\ninstances isn't super important, v8 is a lot better at cleaning these up automatically because\nthere's no inter-isolate dependencies.\n\n\n### Shared Options\nMany methods in this library accept common options between them. They are documented here instead of\nbeing colocated with each instance.\n\n##### `CachedDataOptions`\n* `cachedData` *[ExternalCopy[ArrayBuffer]]* - This will consume cached compilation data from a\n\tprevious call to this function. `cachedDataRejected` will be set to `true` if the supplied data\n\twas rejected by V8.\n* `produceCachedData` *[boolean]* - Produce V8 cache data. Similar to the\n\t[VM.Script](https://nodejs.org/api/vm.html) option of the same name. If this is true then the\n\treturned object will have `cachedData` set to an ExternalCopy handle. Note that this differs from\n\tthe VM.Script option slightly in that `cachedDataProduced` is never set.\n\nMost functions which compile or run code can produce and consume cached data. You can produce cached\ndata and use the data in later invocations to drastically speed up parsing of the same script. You\ncan even save this data to disk and use it in a different process. You can set both `cachedData` and\n`produceCachedData`, in which case new cached data will only be produced if the data supplied was\ninvalid.\n\n##### `ScriptOrigin`\n* `filename` *[string]* - Filename of this source code\n* `columnOffset` *[number]* - Column offset of this source code\n* `lineOffset` *[number]* - Line offset of this source code\n\nYou may optionally specify information on compiled code's filename. This is used in various\ndebugging contexts within v8, including stack traces and the inspector. It is recommended to use a\nvalid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools may\nmalfunction.\n\n##### `TransferOptions`\n* `copy` *[boolean]* - Automatically deep copy value\n* `externalCopy` *[boolean]* - Automatically wrap value in `ExternalCopy` instance\n* `reference` *[boolean]* - Automatically wrap value in `Reference` instance\n* `promise` *[boolean]* - Automatically proxy any returned promises between isolates. This can be\n\tused in combination with the other transfer options.\n\nAny function which moves data between isolates will accept these transfer options. By default only\n*[transferable]* values may pass between isolates. Without specifying one of these options the\nfunction may ignore the value, throw, or wrap it in a reference depending on the context.\n\nMore advanced situations like transferring ownership of `ArrayBuffer` instances will require direct\nuse of [`ExternalCopy`](#class-externalcopy-transferable) or\n[`Reference`](#class-reference-transferable).\n\n\nSECURITY\n--------\n\nUse of `isolated-vm` to run untrusted code does not automatically make your application safe.\nThrough carelessness or misuse of the library it can be possible to leak sensitive data or grant\nundesired privileges to an isolate.\n\nAt a minimum you should take care not to leak any instances of `isolated-vm` objects (`Reference`,\n`ExternalCopy`, etc) to untrusted code. It is usually trivial for an attacker to use these instances\nas a springboard back into the nodejs isolate which will yield complete control over a process.\nSimply wrapping these instances in closures is usually enough to keep the internal objects safe. An\nexample of a safe logging function follows:\n\n```js\ncontext.evalClosureSync(\n\t`globalThis.log = (...args) =>\n\t\t$0.applyIgnored(undefined, args, { arguments: { copy: true } });`,\n\t[ (...args) => console.log(...args) ],\n\t{ arguments: { reference: true } });\n```\n\nAgainst potentially hostile code you should also consider turning on [v8 untrusted code\nmitigations](https://v8.dev/docs/untrusted-code-mitigations), which addresses the class of\nspeculative execution attacks known as Spectre and Meltdown. You can enable this feature by running\n`node` with the `--untrusted-code-mitigations` flag. This feature comes with a slight performance\ncost and must be enabled per-process, therefore nodejs disables it by default.\n\nv8 is a relatively robust runtime, but there are always new and exciting ways to crash, hang, or\notherwise disrupt a process with plain old JavaScript. Your application must be resilient to these\nkinds of issues. It's a good idea to keep instances of `isolated-vm` in a different nodejs process\nthan other critical infrastructure.\n\n\nEXAMPLES\n--------\n\nBelow is a sample program which shows basic usage of the library.\n\n```js\n// Create a new isolate limited to 128MB\nconst ivm = require('isolated-vm');\nconst isolate = new ivm.Isolate({ memoryLimit: 128 });\n\n// Create a new context within this isolate. Each context has its own copy of all the builtin\n// Objects. So for instance if one context does Object.prototype.foo = 1 this would not affect any\n// other contexts.\nconst context = isolate.createContextSync();\n\n// Get a Reference{} to the global object within the context.\nconst jail = context.global;\n\n// This makes the global object available in the context as `global`. We use `derefInto()` here\n// because otherwise `global` would actually be a Reference{} object in the new isolate.\njail.setSync('global', jail.derefInto());\n\n// We will create a basic `log` function for the new isolate to use.\njail.setSync('log', function(...args) {\n\tconsole.log(...args);\n});\n\n// And let's test it out:\ncontext.evalSync('log(\"hello world\")');\n// > hello world\n\n// Let's see what happens when we try to blow the isolate's memory\nconst hostile = isolate.compileScriptSync(`\n\tconst storage = [];\n\tconst twoMegabytes = 1024 * 1024 * 2;\n\twhile (true) {\n\t\tconst array = new Uint8Array(twoMegabytes);\n\t\tfor (let ii = 0; ii < twoMegabytes; ii += 4096) {\n\t\t\tarray[ii] = 1; // we have to put something in the array to flush to real memory\n\t\t}\n\t\tstorage.push(array);\n\t\tlog('I\\\\'ve wasted '+ (storage.length * 2)+ 'MB');\n\t}\n`);\n\n// Using the async version of `run` so that calls to `log` will get to the main node isolate\nhostile.run(context).catch(err => console.error(err));\n// I've wasted 2MB\n// I've wasted 4MB\n// ...\n// I've wasted 130MB\n// I've wasted 132MB\n// RangeError: Array buffer allocation failed\n```\n\nAnother example which shows how calls to the asynchronous methods will execute in separate threads\nproviding you with parallelism. Note that each isolate only \"owns\" a thread while it is executing.\nSo you could have hundreds of isolates sitting idle and they would not be using a thread.\n```js\n// A simple function to sum a range of numbers. This can also be expressed as:\n// (max * (max - 1) - min * (min - 1)) / 2\n// But this is an easy way to show off the async features of the module.\nfunction sum(min, max) {\n\tlet sum = 0;\n\tfor (let ii = min; ii < max; ++ii) {\n\t\tsum += ii;\n\t}\n\treturn sum;\n}\n\n// I chose this number because it's big but also small enough that we don't go past JS's integer\n// limit.\nlet num = Math.pow(2, 27);\n\n// First we execute a single thread run\nlet start1 = new Date;\nlet result = sum(0, num);\nconsole.log('Calculated '+ result+ ' in '+ (Date.now() - start1)+ 'ms');\n\n// Now we do the same thing over 4 threads\nlet start2 = new Date;\nlet ivm = require('isolated-vm');\nlet numThreads = 4;\nlet promises = Array(numThreads).fill().map(async function(_, ii) {\n\n\t// Set up 4 isolates with the `sum` function from above\n\tlet isolate = new ivm.Isolate();\n\tlet context = await isolate.createContext();\n\tlet script = await isolate.compileScript(sum+ '');\n\tawait script.run(context);\n\tlet fnReference = await context.global.get('sum');\n\n\t// Run one slice of the sum loop\n\tlet min = Math.floor(num / numThreads * ii);\n\tlet max = Math.floor(num / numThreads * (ii + 1));\n\treturn await fnReference.apply(undefined, [ min, max ]);\n});\nPromise.all(promises).then(function(sums) {\n\tlet result = sums.reduce((a, b) => a + b, 0);\n\tconsole.log('Calculated '+ result+ ' in '+ (Date.now() - start2)+ 'ms');\n});\n// They get the same answer but the async version can do it much faster! Even\n// with the overhead of building 4 isolates\n// > Calculated 9007199187632128 in 1485ms\n// > Calculated 9007199187632128 in 439ms\n```\n\nIncluded in the repository is an example of how you can write quicksort using a SharedArrayBuffer to\nsort over multiple threads. See: [parallel-sort-example.js](https://github.com/laverdet/isolated-vm/blob/main/parallel-sort-example.js).\n\nALTERNATIVES\n------------\n\nThe primary goal of isolated-vm is to create a powerful and secure environment for running untrusted\nJavaScript code. isolated-vm is also a good way to build single-process multithreaded JavaScript\napplications, though if parallelism of trusted code is your only goal then there are probably better\noptions out there.\n\nBelow is a quick summary of some other options available on nodejs and how they differ from\nisolated-vm. The table headers are defined as follows:\n\n* **Secure**: Safely run untrusted code\n* **Memory Limits**: Possible to set memory limits / safe against heap overflow DoS attacks\n* **Isolated**: Is garbage collection, heap, etc isolated from application\n* **Multithreaded**: Run code on many threads from a single process\n* **Module Support**: Is `require` supported out of the box\n* **Inspector Support**: Chrome DevTools supported\n\n| Module                                                                       | Secure | Memory Limits | Isolated | Multithreaded | Module Support | Inspector Support |\n| ---------------------------------------------------------------------------- | :----: | :-----------: | :------: | :-----------: | :------------: | :---------------: |\n| [vm](https://nodejs.org/api/vm.html)                                         |        |               |          |               |       \u2705       |        \u2705         |\n| [worker_threads](https://nodejs.org/api/worker_threads.html)                 |        |               |    \u2705    |      \u2705       |       \u2705       |        \u2705         |\n| [vm2](https://github.com/patriksimek/vm2)                                    |   \u2705   |               |          |               |       \u2705       |        \u2705         |\n| [tiny-worker](https://github.com/avoidwork/tiny-worker)                      |        |               |    \u2705    |               |       \u2705       |                   |\n| isolated-vm                                                                  |   \u2705   |       \u2705      |    \u2705    |      \u2705       |                |        \u2705         |\n", "declare module \"isolated-vm\" {\n\texport type Transferable =\n\t\t| null\n\t\t| undefined\n\t\t| string\n\t\t| number\n\t\t| boolean\n\t\t| Isolate\n\t\t| Context\n\t\t| Script\n\t\t| ExternalCopy<any>\n\t\t| Callback<any>\n\t\t| Copy<any>\n\t\t| Reference<any>\n\t\t| Dereference<any>\n\t\t| Module\n\t\t| ((...args: any[]) => any)\n\t\t| typeof import(\"isolated-vm\");\n\n\t/**\n\t * This is the main reference to an isolate. Every handle to an isolate is transferable, which\n\t * means you can give isolates references to each other. An isolate will remain valid as long as\n\t * someone holds a handle to the isolate or anything created inside that isolate. Once an isolate\n\t * is lost the garbage collector should eventually find it and clean up its memory. Since an\n\t * isolate and all it contains can represent quite a large chunk of memory though you may want to\n\t * explicitly call the `dispose()` method on isolates that you are finished with to get that memory\n\t * back immediately.\n\t */\n\texport class Isolate {\n\t\tprivate __ivm_isolate: undefined;\n\t\tconstructor(options?: IsolateOptions);\n\n\t\t/**\n\t\t * The total CPU time spent in this isolate. CPU time is the amount of time the isolate has\n\t\t * spent actively doing work on the CPU.\n\t\t *\n\t\t * Note that CPU time may vary drastically if there is contention for the CPU. This could occur\n\t\t * if other processes are trying to do work, or if you have more than\n\t\t * require('os').cpus().length isolates currently doing work in the same nodejs process.\n\t\t */\n\t\treadonly cpuTime: bigint;\n\n\t\t/**\n\t\t * Flag that indicates whether this isolate has been disposed.\n\t\t */\n\t\treadonly isDisposed: boolean;\n\n\t\t/**\n\t\t * The total wall time spent in this isolate. Wall time is the amount of time the isolate has\n\t\t * been running, including passive time spent waiting (think \"wall\" like a clock on the wall).\n\t\t * For instance, if an isolate makes a call into another isolate, wall time will continue\n\t\t * increasing while CPU time will remain the same.\n\t\t */\n\t\treadonly wallTime: bigint;\n\n\t\t/**\n\t\t * Returns the total count of active `Reference` instances that belong to this isolate. Note\n\t\t * that in certain cases many `Reference` instances in JavaScript will point to the same\n\t\t * underlying reference handle, in which case this number will only reflect the underlying\n\t\t * reference handle. This happens when you transfer a `Reference` instance via some method which\n\t\t * accepts transferable values. This will also include underlying reference handles created by\n\t\t * isolated-vm like `Script` or `Context` objects.\n\t\t */\n\t\treadonly referenceCount: number;\n\n\t\t/**\n\t\t * Isolate snapshots are a very useful feature if you intend to create several isolates running\n\t\t * common libraries between them. A snapshot serializes the entire v8 heap including parsed code,\n\t\t * global variables, and compiled code. Check out the examples section for tips on using this.\n\t\t *\n\t\t * **Please note that versions of nodejs 10.4.0 - 10.9.0 may crash while using the snapshot\n\t\t * feature.**\n\t\t *\n\t\t * @param warmup_script - Optional script to \"warmup\" the snapshot by triggering code compilation\n\t\t */\n\t\tstatic createSnapshot(scripts: SnapshotScriptInfo[], warmup_script?: string): ExternalCopy<ArrayBuffer>;\n\n\t\tcompileScript(code: string, scriptInfo?: ScriptInfo): Promise<Script>;\n\t\tcompileScriptSync(code: string, scriptInfo?: ScriptInfo): Script;\n\n\t\tcompileModule(code: string, scriptInfo?: ScriptInfo): Promise<Module>;\n\t\tcompileModuleSync(code: string, scriptInfo?: ScriptInfo): Module;\n\n\t\tcreateContext(options?: ContextOptions): Promise<Context>;\n\t\tcreateContextSync(options?: ContextOptions): Context;\n\n\t\tcreateInspectorSession(): InspectorSession;\n\n\t\t/**\n\t\t * Destroys this isolate and invalidates all references obtained from it.\n\t\t */\n\t\tdispose(): void;\n\n\t\t/**\n\t\t * Returns heap statistics from v8.\n\t\t *\n\t\t * The return value is almost identical to the nodejs function v8.getHeapStatistics().\n\t\t *\n\t\t * See: https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics.\n\t\t *\n\t\t * This function returns one additional property: \"externally_allocated_size\" which is the total\n\t\t * amount of currently allocated memory which is not included in the v8 heap but counts against\n\t\t * this isolate's \"memoryLimit\".\n\t\t *\n\t\t * ArrayBuffer instances over a certain size are externally allocated and will be counted here.\n\t\t */\n\t\tgetHeapStatistics(): Promise<HeapStatistics>;\n\t\tgetHeapStatisticsSync(): HeapStatistics;\n\t}\n\n\texport type IsolateOptions = {\n\t\t/**\n\t\t * Memory limit that this isolate may use, in MB. Note that this is more of a guideline\n\t\t * instead of a strict limit. A determined attacker could use 2-3 times this limit before\n\t\t * their script is terminated. Against non-hostile code this limit should be pretty close. The\n\t\t * default is 128MB and the mimium is 8MB.\n\t\t */\n\t\tmemoryLimit?: number;\n\n\t\t/**\n\t\t * Enable v8 inspector support in this isolate. See `inspector-example.js` in this repository\n\t\t * for an example of how to use this.\n\t\t */\n\t\tinspector?: boolean;\n\n\t\t/**\n\t\t * This is an optional snapshot created from `createSnapshot` which will be used to initialize\n\t\t * the heap of this isolate.\n\t\t */\n\t\tsnapshot?: ExternalCopy<ArrayBuffer>;\n\t};\n\n\texport type ContextOptions = {\n\t\tinspector?: boolean;\n\t};\n\n\texport type HeapStatistics = {\n\t\ttotal_heap_size: number;\n\t\ttotal_heap_size_executable: number;\n\t\ttotal_physical_size: number;\n\t\ttotal_available_size: number;\n\t\tused_heap_size: number;\n\t\theap_size_limit: number;\n\t\tmalloced_memory: number;\n\t\tpeak_malloced_memory: number;\n\t\tdoes_zap_garbage: number;\n\n\t\t/**\n\t\t * The total amount of currently allocated memory which is not included in the v8 heap but\n\t\t * counts against this isolate's \"memoryLimit\".\n\t\t */\n\t\texternally_allocated_size: number;\n\t};\n\n\t/**\n\t * A context is a sandboxed execution environment within an isolate. Each context contains its own\n\t * built-in objects and global space.\n\t */\n\texport class Context {\n\t\tprivate __ivm_context: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * `Reference` to this context's global object. Note that if you call `context.release()` the\n\t\t * global reference will be released as well.\n\t\t */\n\t\treadonly global: Reference<Record<number | string | symbol, any>>;\n\n\t\t/**\n\t\t * Compiles and executes a script within a context. This will return the last value evaluated,\n\t\t * as long as that value was transferable, otherwise `undefined` will be returned.\n\t\t */\n\t\teval<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): Promise<ResultTypeSync<Options>>; // `ResultTypeSync` used intentionally\n\t\tevalIgnored(code: string, options?: ContextEvalOptions): void\n\t\tevalSync<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): ResultTypeSync<Options>;\n\n\t\t/**\n\t\t * Compiles and runs code as if it were inside a function, similar to the seldom-used `new\n\t\t * Function(code)` constructor. You can pass arguments to the function and they will be\n\t\t * available as `$0`, `$1`, and so on. You can also use `return` from the code.\n\t\t */\n\t\tevalClosure<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): Promise<ResultTypeBidirectionalSync<Options>>; // `ResultTypeBidirectionalSync` used intentionally\n\t\tevalClosureIgnored<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): void\n\t\tevalClosureSync<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): ResultTypeBidirectionalSync<Options>;\n\n\t\t/**\n\t\t * Releases this reference to the context. You can call this to free up v8 resources\n\t\t * immediately, or you can let the garbage collector handle it when it feels like it. Note that\n\t\t * if there are other references to this context it will not be disposed. This only affects this\n\t\t * reference to the context.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\texport type ContextEvalOptions = RunOptions & TransferOptions;\n\texport type ContextEvalClosureOptions = RunOptions & TransferOptionsBidirectional;\n\n\t/**\n\t * A script is a compiled chunk of JavaScript which can be executed in any context within a single\n\t * isolate.\n\t */\n\texport class Script {\n\t\tprivate __ivm_script: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * Releases the reference to this script, allowing the script data to be garbage collected.\n\t\t * Functions and data created in the isolate by previous invocations to `script.run(...)` will\n\t\t * still be alive in their respective contexts-- this only means that you can't invoke\n\t\t * `script.run(...)` again with this reference.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Runs a given script within a context. This will return the last value evaluated in a given\n\t\t * script, as long as that value was transferable, otherwise `undefined` will be returned. For\n\t\t * instance if your script was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value\n\t\t * will be 3 because that is the last expression.\n\t\t */\n\t\trun<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeAsync<Options>;\n\t\trunIgnored(context: Context, options?: ScriptRunOptions): void;\n\t\trunSync<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeSync<Options>;\n\t}\n\n\texport type ScriptRunOptions = RunOptions & ReleaseOptions & TransferOptions;\n\n\t/**\n\t * A JavaScript module. Note that a Module can only run in the isolate which created it.\n\t */\n\texport class Module {\n\t\tprivate __ivm_module: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * A read-only array of all dependency specifiers the module has.\n\t\t */\n\t\treadonly dependencySpecifiers: string[];\n\n\t\t/**\n\t\t * Returns a Reference containing all exported values.\n\t\t */\n\t\treadonly namespace: Reference<any>;\n\n\t\t/**\n\t\t * Instantiate the module together with all its dependencies. Calling this more than once on a\n\t\t * single module will have no effect.\n\t\t * @param context The context the module should use.\n\t\t * @param resolveCallback This callback is responsible for resolving all direct and indirect\n\t\t * dependencies of this module. It accepts two parameters: specifier and referrer. It must\n\t\t * return a Module instance or a promise which will be used to satisfy the dependency.\n\t\t */\n\t\tinstantiate(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (\n\t\t\t\tspecifier: string,\n\t\t\t\treferrer: Module\n\t\t\t) => Module | Promise<Module>\n\t\t): Promise<void>;\n\t\tinstantiateSync(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (specifier: string, referrer: Module) => Module\n\t\t): void;\n\n\t\t/**\n\t\t * Evaluate the module and return the last expression (same as script.run). If evaluate is\n\t\t * called more than once on the same module the return value from the first invocation will be\n\t\t * returned (or thrown).\n\t\t * @param options Optional\n\t\t */\n\t\tevaluate(options?: ScriptRunOptions): Promise<Transferable>;\n\t\tevaluateSync(options?: ScriptRunOptions): Transferable;\n\t}\n\n\t/**\n\t * A instance of Reference is a pointer to a value stored in any isolate.\n\t */\n\texport class Reference<T = any> {\n\t\tprivate __ivm_reference: T;\n\t\tconstructor(value: T, options?: { unsafeInherit?: boolean });\n\n\t\t/**\n\t\t * This is the typeof the referenced value, and is available at any time\n\t\t * from any isolate. Note that this differs from the real typeof operator in\n\t\t * that null is \"null\", and Symbols are \"object\".\n\t\t */\n\t\treadonly typeof: string;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t */\n\t\tcopy(): Promise<T>;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t *\n\t\t * @return JavaScript value of the reference.\n\t\t */\n\t\tcopySync(): T;\n\n\t\t/**\n\t\t * Will attempt to return the actual value or object pointed to by this reference. Note that in\n\t\t * order to call this function the reference must be owned by the current isolate, otherwise an\n\t\t * error will be thrown.\n\t\t */\n\t\tderef(options?: ReleaseOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * dereference the handle.\n\t\t */\n\t\tderefInto(options?: ReleaseOptions): Dereference<T>;\n\n\t\t/**\n\t\t * Releases this reference. If you're passing around a lot of references between isolates it's\n\t\t * wise to release the references when you are done. Otherwise you may run into issues with\n\t\t * isolates running out of memory because other isolates haven't garbage collected recently.\n\t\t * After calling this method all attempts to access the reference will throw an error.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Delete a property from this reference, as if using `delete reference[property]`\n\t\t */\n\t\t delete(property: keyof T): Promise<void>;\n\t\t deleteIgnored(property: keyof T): void;\n\t\t deleteSync(property: keyof T): void;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t *\n\t\t * If the object is a proxy, or if the property is a getter, this method will throw.\n\t\t */\n\t\tget<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeAsync<Options & FallbackReference, T[Key]>;\n\t\tgetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeSync<Options & FallbackReference, T[Key]>;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t */\n\t\tset<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): Promise<void>;\n\t\tsetIgnored<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n\t\tsetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n\n\t\t/**\n\t\t * Will attempt to invoke an object as if it were a function. If the return\n\t\t * value is transferable it will be returned to the called of apply,\n\t\t * otherwise an error will be thrown.\n\t\t */\n\t\tapply<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalAsync<Options & FallbackReference, ApplyResult<T>>;\n\t\tapplyIgnored<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options & FallbackReference, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): void;\n\t\tapplySync<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n\n\t\t/**\n\t\t * `applySyncPromise` is a special version of `applySync` which may only be invoked on functions\n\t\t * belonging to the default isolate AND may only be invoked from a non-default thread. Functions\n\t\t * invoked in this way may return a promise and the invoking isolate will wait for that promise\n\t\t * to resolve before resuming execution. You can use this to implement functions like\n\t\t * readFileSync in a way that doesn't block the default isolate. Note that the invoking isolate\n\t\t * will not respond to any async functions until this promise is resolved, however synchronous\n\t\t * functions will still function correctly. Misuse of this feature may result in deadlocked\n\t\t * isolates, though the default isolate will never be at risk of a deadlock.\n\t\t */\n\t\tapplySyncPromise<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n\t}\n\n\t/**\n\t * Dummy type referencing a type dereferenced into a different Isolate.\n\t */\n\texport class Dereference<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_deref: T;\n\t}\n\n\texport type ReferenceApplyOptions = RunOptions & TransferOptionsBidirectional;\n\n\t/**\n\t * Instances of this class represent some value that is stored outside of any v8\n\t * isolate. This value can then be quickly copied into any isolate.\n\t */\n\texport class ExternalCopy<T = any> {\n\t\tprivate __ivm_external_copy: T;\n\n\t\t/**\n\t\t * Primitive values can be copied exactly as they are. Date objects will be copied as as Dates.\n\t\t * ArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format.\n\t\t * SharedArrayBuffers will simply copy a reference to the existing memory and when copied into\n\t\t * another isolate the new SharedArrayBuffer will point to the same underlying data. After\n\t\t * passing a SharedArrayBuffer to ExternalCopy for the first time isolated-vm will take over\n\t\t * management of the underlying memory block, so a \"copied\" SharedArrayBuffer can outlive the\n\t\t * isolate that created the memory originally.\n\t\t *\n\t\t * All other objects will be copied in seralized form using the [structured clone\n\t\t * algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n\t\t *\n\t\t * `ExternalCopy` can copy objects with deeply nested *transferable* objects.\n\t\t */\n\t\tconstructor(value: T, options?: ExternalCopyOptions);\n\n\t\t/**\n\t\t * Static property which will return the total number of bytes that isolated-vm has allocated\n\t\t * outside of v8 due to instances of `ExternalCopy`.\n\t\t */\n\t\tstatic readonly totalExternalSize: number;\n\n\t\t/**\n\t\t * Internalizes the ExternalCopy data into this isolate.\n\t\t *\n\t\t * @return JavaScript value of the external copy.\n\t\t */\n\t\tcopy(options?: ExternalCopyCopyOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * internalize a copy of this value.\n\t\t */\n\t\tcopyInto(options?: ExternalCopyCopyOptions): Copy<T>;\n\n\t\t/**\n\t\t * Releases the reference to this copy. If there are other references to this copy elsewhere the\n\t\t * copy will still remain in memory, but this handle will no longer be active. Disposing\n\t\t * ExternalCopy instances isn't super important, v8 is a lot better at cleaning these up\n\t\t * automatically because there's no inter-isolate dependencies.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\t/**\n\t * Dummy type referencing a type copied into a different Isolate.\n\t */\n\texport class Copy<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_copy: T;\n\t}\n\n\texport type ExternalCopyOptions = {\n\t\t/**\n\t\t * An array of `ArrayBuffer` instances to transfer ownership. This behaves in a similar way to\n\t\t * [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t\t */\n\t\ttransferList?: any[];\n\t\t/**\n\t\t * If true this will release ownership of the given resource from this isolate. This operation\n\t\t * completes in constant time since it doesn't have to copy an arbitrarily large object. This\n\t\t * only applies to ArrayBuffer and TypedArray instances.\n\t\t */\n\t\ttransferOut?: boolean;\n\t};\n\n\texport type ExternalCopyCopyOptions = ReleaseOptions & {\n\t\t/**\n\t\t * If true this will transfer the resource directly into this isolate, invalidating the\n\t\t * ExternalCopy handle.\n\t\t */\n\t\ttransferIn?: boolean;\n\t};\n\n\t/**\n   * Callbacks can be used to create cross-isolate references to simple functions. This can be\n\t * easier and safer than dealing with the more flexible\n\t * [`Reference`](#class-reference-transferable) class. Arguments passed to and returned from\n\t * callbacks are always copied using the same method as\n\t * [`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate,\n\t * instances of `Callback` will turn into a plain old function. Callbacks are created\n\t * automatically when passing functions to most isolated-vm functions.\n\t */\n\t export class Callback<T extends (...args: any[]) => any = any> {\n\t\tprivate __ivm_callback: T;\n\n\t\tconstructor(value: T, options?: CallbackOptions);\n\t}\n\n\texport type CallbackOptions = {\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a promise.\n\t\t */\n\t\tasync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a value (default).\n\t\t */\n\t\tsync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will ignore the result (including exceptions).\n\t\t */\n\t\tignored?: boolean;\n\n\t\t// The following ensures only 1 invocation option is given.\n\t} & ({\n\t\tasync?: true;\n\t\tsync?: never;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: true;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: never;\n\t\tignored?: true;\n\t});\n\n\t/**\n\t * C++ native module for v8 representation.\n\t */\n\texport class NativeModule {\n\t\tprivate __ivm_native_module: undefined;\n\n\t\t/**\n\t\t * Instantiate a native module with the full path to the compiled library.\n\t\t * For instance, filename would represent the path to a .node file\n\t\t * compiled using node-gyp.\n\t\t *\n\t\t * @param filename Full path to compiled library.\n\t\t */\n\t\tconstructor(filename: string);\n\n\t\t/**\n\t\t * Instantiates the module with a Context by running the `InitForContext`\n\t\t * symbol, throws if that symbol is not present.\n\t\t *\n\t\t * Returned Reference<NativeModule> should be dereferenced into a context\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreate(context: Context): Promise<Reference<any>>;\n\n\t\t/**\n\t\t * Synchronous version of `create`\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreateSync(context: Context): Reference<any>;\n\t}\n\n\texport type InspectorSession = {\n\t\tdispatchProtocolMessage(message: string): void;\n\t\tdispose(): void;\n\t\tonNotification: (message: string) => void;\n\t\tonResponse: (callId: number, message: string) => void;\n\t};\n\n\t/**\n\t * Most functions which compile or run code can produce and consume cached data. You can produce\n\t * cached data and use the data in later invocations to drastically speed up parsing of the same\n\t * script. You can even save this data to disk and use it in a different process. You can set both\n\t * `cachedData` and `produceCachedData`, in which case new cached data will only be produced if\n\t * the data supplied was invalid.\n\t */\n\texport type CachedDataOptions = {\n\t\t/**\n\t\t * This will consume cached compilation data from a previous call to this function. Please don't\n\t\t * use `produceCachedData` and `cachedData` options at the same time. `cachedDataRejected` will\n\t\t * be set to `true` if the supplied data was rejected by V8.\n\t\t */\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\t/**\n\t\t * Produce V8 cache data. Similar to the [VM.Script](https://nodejs.org/api/vm.html) option of\n\t\t * the same name. If this is true then the returned object will have `cachedData` set to an\n\t\t * ExternalCopy handle. Note that this differs from the VM.Script option slightly in that\n\t\t * `cachedDataProduced` is never set.\n\t\t */\n\t\tproduceCachedData?: boolean;\n\t};\n\n\texport type CachedDataResult = {\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\tproducedCacheData?: boolean;\n\t};\n\n\texport type ReleaseOptions = {\n\t\t/**\n\t\t * If true release() will automatically be called on this instance.\n\t\t */\n\t\trelease?: boolean;\n\t};\n\n\texport type RunOptions = {\n\t\t/**\n\t\t * Maximum amount of time in milliseconds this script is allowed to run before execution is\n\t\t * canceled. Default is no timeout.\n\t\t */\n\t\ttimeout?: number;\n\t};\n\n\t/**\n\t * You may optionally specify information on compiled code's filename. This is used in various\n\t * debugging contexts within v8, including stack traces and the inspector. It is recommended to\n\t * use a valid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools\n\t * may malfunction.\n\t */\n\texport type ScriptOrigin = {\n\t\t/**\n\t\t * Filename of this source code\n\t\t */\n\t\tfilename?: string;\n\n\t\t/**\n\t\t * Column offset of this source code\n\t\t */\n\t\tcolumnOffset?: number;\n\n\t\t/**\n\t\t * Line offset of this source code\n\t\t */\n\t\tlineOffset?: number;\n\t};\n\n\texport type SnapshotScriptInfo = ScriptOrigin & {\n\t\t/**\n\t\t * Source code to set up this snapshot\n\t\t */\n\t\tcode: string;\n\t};\n\texport type ScriptInfo = CachedDataOptions & ScriptOrigin;\n\n\t/**\n\t * Any function which moves data between isolates will accept these transfer options. By default\n\t * only *[transferable]* values may pass between isolates. Without specifying one of these options\n\t * the function may ignore the value, throw, or wrap it in a reference depending on the context.\n\t *\n\t * More advanced situations like transferring ownership of `ArrayBuffer` instances will require\n\t * direct use of `ExternalCopy` or `Reference`.\n\t */\n\texport type TransferOptions = {\n\t\t/**\n\t\t * Automatically proxy any returned promises between isolates. This can be used in combination\n\t\t * with the other transfer options.\n\t\t */\n\t\tpromise?: boolean;\n\n\t\t/**\n\t\t * Automatically deep copy value\n\t\t */\n\t\tcopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `ExternalCopy` instance\n\t\t */\n\t\texternalCopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `Reference` instance\n\t\t */\n\t\treference?: boolean;\n\n\t\t// The following ensures only 1 transfer option is given.\n\t} & ({\n\t\t copy?: true;\n\t\t externalCopy?: never;\n\t\t reference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: true;\n\t\treference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: never;\n\t\treference?: true;\n\t });\n\n\texport type TransferOptionsBidirectional = {\n\t\t/**\n\t\t * `TransferOptions` for the values going *into* this isolate.\n\t\t */\n\t\targuments?: TransferOptions;\n\t\t/**\n\t\t * `TransferOptions` for the values coming *out* of this isolate.\n\t\t */\n\t\tresult?: TransferOptions;\n\t};\n\n\t// Discriminating types for TransferOptions\n\ttype WithPromise = { promise: true };\n\ttype AsCopy = { copy: true };\n\ttype AsExternal = { externalCopy: true };\n\ttype AsReference = { reference: true };\n\ttype FallbackReference = { _reference: true };\n\ttype ApplyAsReference = { result: AsReference };\n\ttype WithTransfer = AsCopy | AsExternal | AsReference;\n\n\t// Wraps a type in Promise<> if the options specify { promise: true }\n\ttype CheckPromise<Options, Result> = Options extends WithPromise ? Promise<Result> : Result;\n\n\t// Type of a single argument for functions that accept TransferOptions\n\ttype ArgumentType<Options, Type> =\n\t\t(Options extends WithTransfer ? Type | CheckPromise<Options, Type> :\n\t\tType extends Transferable ? Type | CheckPromise<Options, Type> :\n\t\tTransferable | CheckPromise<Options, Transferable>) |\n\t\tCopy<Type> | Dereference<Type>;\n\n\t// Return type for functions that accept TransferOptions\n\ttype ResultTypeBase<Options, Result> =\n\t\tOptions extends AsCopy ? Result :\n\t\tOptions extends AsExternal ? ExternalCopy<Result> :\n\t\tOptions extends AsReference ? Reference<Result> :\n\t\tResult extends Transferable ? Result :\n\t\tResult extends void ? void :\n\t\tOptions extends FallbackReference ? Reference<Result> :\n\t\tTransferable;\n\ttype ResultTypeAsync<Options extends TransferOptions, Result = any> = Promise<ResultTypeBase<Options, Result>>;\n\ttype ResultTypeSync<Options extends TransferOptions, Result = any> = CheckPromise<Options, ResultTypeBase<Options, Result>>;\n\n\t// Arguments type for functions that accept TransferOptionsBidirectional\n\ttype ArgumentsTypeBidirectional<Options extends TransferOptionsBidirectional, Args extends any[] = any[]> = {\n\t\t[Key in keyof Args]: ArgumentType<Options['arguments'] extends TransferOptions ? Options['arguments'] : {}, Args[Key]>\n\t};\n\n\t// Result type for functions that accept TransferOptionsBidirectional\n\ttype ResultTypeBidirectionalBase<Options extends TransferOptionsBidirectional, Result> =\n\t\tResultTypeBase<Options['result'] extends TransferOptions ? Options['result'] : {}, Result>;\n\ttype ResultTypeBidirectionalAsync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tPromise<ResultTypeBidirectionalBase<Options, Result>>;\n\ttype ResultTypeBidirectionalSync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tCheckPromise<Options['result'], ResultTypeBidirectionalBase<Options, Result>>;\n\n\t// Types for `Reference.apply`\n\ttype ApplyArguments<Value> = Value extends (...args: infer Args) => unknown ? Args : any[];\n\ttype ApplyArgumentThis<Value> = Value extends (this: infer This, ...args: any) => unknown ? This : undefined | null;\n\ttype ApplyResult<Value> = Value extends (...args: any) => infer Result ? Result : unknown;\n}\n", "#pragma once\n#include \"isolate/generic/error.h\"\n#include \"isolate/generic/handle_cast.h\"\n#include <v8.h>\n\nnamespace ivm {\n\nclass StringTable {\n\tpublic:\n\t\tclass String {\n\t\t\tpublic:\n\t\t\t\tString(const char* value) : value{value} {} // NOLINT(hicpp-explicit-conversions)\n\t\t\t\tString(const String&) = delete;\n\t\t\t\tString(String&&) = delete;\n\t\t\t\t~String() = default;\n\t\t\t\tauto operator=(const String&) = delete;\n\t\t\t\tauto operator=(String&&) = delete;\n\n\t\t\t\toperator v8::Local<v8::Name>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\treturn v8::Local<v8::String>{*this}.As<v8::Name>();\n\t\t\t\t}\n\n\t\t\t\toperator v8::Local<v8::Value>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\treturn v8::Local<v8::String>{*this}.As<v8::Value>();\n\t\t\t\t}\n\n\t\t\t\toperator v8::Local<v8::String>() { // NOLINT(hicpp-explicit-conversions)\n\t\t\t\t\tauto* isolate = v8::Isolate::GetCurrent();\n\t\t\t\t\tif (handle.IsEmpty()) {\n\t\t\t\t\t\tauto local = Unmaybe(v8::String::NewFromOneByte(\n\t\t\t\t\t\t\tisolate, (const uint8_t*)value, v8::NewStringType::kInternalized));\n\t\t\t\t\t\thandle.Set(isolate, local);\n\t\t\t\t\t\treturn local;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn handle.Get(isolate);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tprivate:\n\t\t\t\tconst char* value;\n\t\t\t\tv8::Eternal<v8::String> handle;\n\t\t};\n\n\t\tstatic auto Get() -> auto&;\n\n\t\t// StringTable::Get().\n\t\tString arguments{\"arguments\"};\n\t\tString async{\"async\"};\n\t\tString boolean{\"boolean\"};\n\t\tString cachedData{\"cachedData\"};\n\t\tString cachedDataRejected{\"cachedDataRejected\"};\n\t\tString code{\"code\"};\n\t\tString colonSpace{\": \"};\n\t\tString columnOffset{\"columnOffset\"};\n\t\tString copy{\"copy\"};\n\t\tString externalCopy{\"externalCopy\"};\n\t\tString filename{\"filename\"};\n\t\tString function{\"function\"};\n\t\tString global{\"global\"};\n\t\tString ignored{\"ignored\"};\n\t\tString inspector{\"inspector\"};\n\t\tString isolateIsDisposed{\"Isolate is disposed\"};\n\t\tString isolatedVm{\"isolated-vm\"};\n\t\tString length{\"length\"};\n\t\tString lineOffset{\"lineOffset\"};\n\t\tString message{\"message\"};\n\t\tString name{\"name\"};\n\t\tString null{\"null\"};\n\t\tString number{\"number\"};\n\t\tString object{\"object\"};\n\t\tString produceCachedData{\"produceCachedData\"};\n\t\tString promise{\"promise\"};\n\t\tString reference{\"reference\"};\n\t\tString release{\"release\"};\n\t\tString result{\"result\"};\n\t\tString snapshot{\"snapshot\"};\n\t\tString stack{\"stack\"};\n\t\tString string{\"string\"};\n\t\tString timeout{\"timeout\"};\n\t\tString transferIn{\"transferIn\"};\n\t\tString transferList{\"transferList\"};\n\t\tString transferOut{\"transferOut\"};\n\t\tString undefined{\"undefined\"};\n\t\tString unsafeInherit{\"unsafeInherit\"};\n\n\t\tString does_zap_garbage{\"does_zap_garbage\"};\n\t\tString externally_allocated_size{\"externally_allocated_size\"};\n\t\tString heap_size_limit{\"heap_size_limit\"};\n\t\tString malloced_memory{\"malloced_memory\"};\n\t\tString peak_malloced_memory{\"peak_malloced_memory\"};\n\t\tString total_available_size{\"total_available_size\"};\n\t\tString total_heap_size{\"total_heap_size\"};\n\t\tString total_heap_size_executable{\"total_heap_size_executable\"};\n\t\tString total_physical_size{\"total_physical_size\"};\n\t\tString used_heap_size{\"used_heap_size\"};\n};\n\ninline auto HandleCastImpl(\n\t\tStringTable::String& value, const HandleCastArguments& /*arguments*/, HandleCastTag<v8::Local<v8::String>> /*tag*/) {\n\treturn v8::Local<v8::String>{value};\n}\n\n} // namespace ivm\n", "#include \"reference_handle.h\"\n#include \"external_copy/external_copy.h\"\n#include \"isolate/run_with_timeout.h\"\n#include \"isolate/three_phase_task.h\"\n#include \"transferable.h\"\n#include <array>\n\nusing namespace v8;\nusing std::shared_ptr;\nusing std::unique_ptr;\n\nnamespace ivm {\nnamespace {\n\nusing TypeOf = detail::ReferenceData::TypeOf;\nauto InferTypeOf(Local<Value> value) -> TypeOf {\n\tif (value->IsNull()) {\n\t\treturn TypeOf::Null;\n\t} else if (value->IsUndefined()) {\n\t\treturn TypeOf::Undefined;\n\t} else if (value->IsNumber()) {\n\t\treturn TypeOf::Number;\n\t} else if (value->IsString()) {\n\t\treturn TypeOf::String;\n\t} else if (value->IsBoolean()) {\n\t\treturn TypeOf::Boolean;\n\t} else if (value->IsFunction()) {\n\t\treturn TypeOf::Function;\n\t} else {\n\t\treturn TypeOf::Object;\n\t}\n}\n\n/**\n * The return value for .derefInto()\n */\nclass DereferenceHandleTransferable : public Transferable {\n\tpublic:\n\t\tDereferenceHandleTransferable(shared_ptr<IsolateHolder> isolate, RemoteHandle<v8::Value> reference) :\n\t\t\tisolate{std::move(isolate)}, reference{std::move(reference)} {}\n\n\t\tauto TransferIn() -> v8::Local<v8::Value> final {\n\t\t\tif (isolate == IsolateEnvironment::GetCurrentHolder()) {\n\t\t\t\treturn Deref(reference);\n\t\t\t} else {\n\t\t\t\tthrow RuntimeTypeError(\"Cannot dereference this into target isolate\");\n\t\t\t}\n\t\t}\n\n\tprivate:\n\t\tshared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n};\n\nclass DereferenceHandle : public TransferableHandle {\n\tpublic:\n\t\tDereferenceHandle(shared_ptr<IsolateHolder> isolate, RemoteHandle<v8::Value> reference) :\n\t\t\tisolate{std::move(isolate)}, reference{std::move(reference)} {}\n\n\t\tstatic auto Definition() -> v8::Local<v8::FunctionTemplate> {\n\t\t\treturn Inherit<TransferableHandle>(MakeClass(\"Dereference\", nullptr));\n\t\t}\n\n\t\tauto TransferOut() -> std::unique_ptr<Transferable> final {\n\t\t\tif (!reference) {\n\t\t\t\tthrow RuntimeGenericError(\"The return value of `derefInto()` should only be used once\");\n\t\t\t}\n\t\t\treturn std::make_unique<DereferenceHandleTransferable>(std::move(isolate), std::move(reference));\n\t\t}\n\n\tprivate:\n\t\tshared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n};\n\n} // anonymous namespace\n\nnamespace detail {\n\nReferenceData::ReferenceData(Local<Value> value, bool inherit) : ReferenceData{\n\t\tIsolateEnvironment::GetCurrentHolder(),\n\t\tRemoteHandle<Value>(value),\n\t\tRemoteHandle<Context>(Isolate::GetCurrent()->GetCurrentContext()),\n\t\tInferTypeOf(value),\n\t\tinherit} {}\n\nReferenceData::ReferenceData(\n\tshared_ptr<IsolateHolder> isolate,\n\tRemoteHandle<Value> reference,\n\tRemoteHandle<Context> context,\n\tTypeOf type_of,\n\tbool inherit\n) :\n\tisolate{std::move(isolate)},\n\treference{std::move(reference)},\n\tcontext{std::move(context)},\n\ttype_of{type_of},\n\tinherit{inherit} {}\n\n} // namespace detail\n\n/**\n * ReferenceHandle implementation\n */\nauto ReferenceHandle::Definition() -> Local<FunctionTemplate> {\n\treturn Inherit<TransferableHandle>(MakeClass(\n\t\t\"Reference\", ConstructorFunction<decltype(&New), &New>{},\n\t\t\"deref\", MemberFunction<decltype(&ReferenceHandle::Deref), &ReferenceHandle::Deref>{},\n\t\t\"derefInto\", MemberFunction<decltype(&ReferenceHandle::DerefInto), &ReferenceHandle::DerefInto>{},\n\t\t\"release\", MemberFunction<decltype(&ReferenceHandle::Release), &ReferenceHandle::Release>{},\n\t\t\"copy\", MemberFunction<decltype(&ReferenceHandle::Copy<1>), &ReferenceHandle::Copy<1>>{},\n\t\t\"copySync\", MemberFunction<decltype(&ReferenceHandle::Copy<0>), &ReferenceHandle::Copy<0>>{},\n\t\t\"delete\", MemberFunction<decltype(&ReferenceHandle::Delete<1>), &ReferenceHandle::Delete<1>>{},\n\t\t\"deleteIgnored\", MemberFunction<decltype(&ReferenceHandle::Delete<2>), &ReferenceHandle::Delete<2>>{},\n\t\t\"deleteSync\", MemberFunction<decltype(&ReferenceHandle::Delete<0>), &ReferenceHandle::Delete<0>>{},\n\t\t\"get\", MemberFunction<decltype(&ReferenceHandle::Get<1>), &ReferenceHandle::Get<1>>{},\n\t\t\"getSync\", MemberFunction<decltype(&ReferenceHandle::Get<0>), &ReferenceHandle::Get<0>>{},\n\t\t\"set\", MemberFunction<decltype(&ReferenceHandle::Set<1>), &ReferenceHandle::Set<1>>{},\n\t\t\"setIgnored\", MemberFunction<decltype(&ReferenceHandle::Set<2>), &ReferenceHandle::Set<2>>{},\n\t\t\"setSync\", MemberFunction<decltype(&ReferenceHandle::Set<0>), &ReferenceHandle::Set<0>>{},\n\t\t\"apply\", MemberFunction<decltype(&ReferenceHandle::Apply<1>), &ReferenceHandle::Apply<1>>{},\n\t\t\"applyIgnored\", MemberFunction<decltype(&ReferenceHandle::Apply<2>), &ReferenceHandle::Apply<2>>{},\n\t\t\"applySync\", MemberFunction<decltype(&ReferenceHandle::Apply<0>), &ReferenceHandle::Apply<0>>{},\n\t\t\"applySyncPromise\", MemberFunction<decltype(&ReferenceHandle::Apply<4>), &ReferenceHandle::Apply<4>>{},\n\t\t\"typeof\", MemberAccessor<decltype(&ReferenceHandle::TypeOfGetter), &ReferenceHandle::TypeOfGetter>{}\n\t));\n}\n\nauto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}\n\nauto ReferenceHandle::TransferOut() -> unique_ptr<Transferable> {\n\treturn std::make_unique<ReferenceHandleTransferable>(*this);\n}\n\n/**\n * Getter for typeof property.\n */\nauto ReferenceHandle::TypeOfGetter() -> Local<Value> {\n\tCheckDisposed();\n\tswitch (type_of) {\n\t\tcase TypeOf::Null:\n\t\t\treturn StringTable::Get().null;\n\t\tcase TypeOf::Undefined:\n\t\t\treturn StringTable::Get().undefined;\n\t\tcase TypeOf::Number:\n\t\t\treturn StringTable::Get().number;\n\t\tcase TypeOf::String:\n\t\t\treturn StringTable::Get().string;\n\t\tcase TypeOf::Boolean:\n\t\t\treturn StringTable::Get().boolean;\n\t\tcase TypeOf::Object:\n\t\t\treturn StringTable::Get().object;\n\t\tcase TypeOf::Function:\n\t\t\treturn StringTable::Get().function;\n\t}\n\tstd::terminate();\n}\n\n/**\n * Attempt to return this handle to the current context.\n */\nauto ReferenceHandle::Deref(MaybeLocal<Object> maybe_options) -> Local<Value> {\n\tCheckDisposed();\n\tif (isolate.get() != IsolateEnvironment::GetCurrentHolder().get()) {\n\t\tthrow RuntimeTypeError(\"Cannot dereference this from current isolate\");\n\t}\n\tbool release = ReadOption<bool>(maybe_options, StringTable::Get().release, false);\n\tLocal<Value> ret = ivm::Deref(reference);\n\tif (release) {\n\t\tRelease();\n\t}\n\treturn ret;\n}\n\n/**\n * Return a handle which will dereference itself when passing into another isolate.\n */\nauto ReferenceHandle::DerefInto(MaybeLocal<Object> maybe_options) -> Local<Value> {\n\tCheckDisposed();\n\tbool release = ReadOption<bool>(maybe_options, StringTable::Get().release, false);\n\tLocal<Value> ret = ClassHandle::NewInstance<DereferenceHandle>(isolate, reference);\n\tif (release) {\n\t\tRelease();\n\t}\n\treturn ret;\n}\n\n/**\n * Release this reference.\n */\nauto ReferenceHandle::Release() -> Local<Value> {\n\tCheckDisposed();\n\tisolate.reset();\n\treference = {};\n\tcontext = {};\n\treturn Undefined(Isolate::GetCurrent());\n}\n\n/**\n * Call a function, like Function.prototype.apply\n */\nclass ApplyRunner : public ThreePhaseTask {\n\tpublic:\n\t\tApplyRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tMaybeLocal<Value> recv_handle,\n\t\t\tMaybe<ArrayRange> maybe_arguments,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\tcontext{that.context}, reference{that.reference}\n\t\t{\n\t\t\tthat.CheckDisposed();\n\n\t\t\t// Get receiver, holder, this, whatever\n\t\t\tLocal<Value> recv_local;\n\t\t\tif (recv_handle.ToLocal(&recv_local)) {\n\t\t\t\trecv = TransferOut(recv_local);\n\t\t\t}\n\n\t\t\t// Get run options\n\t\t\tTransferOptions arguments_transfer_options;\n\t\t\tLocal<Object> options;\n\t\t\tif (maybe_options.ToLocal(&options)) {\n\t\t\t\ttimeout = ReadOption<int32_t>(options, StringTable::Get().timeout, 0);\n\t\t\t\targuments_transfer_options = TransferOptions{\n\t\t\t\t\tReadOption<MaybeLocal<Object>>(options, StringTable::Get().arguments, {})};\n\t\t\t\treturn_transfer_options = TransferOptions{\n\t\t\t\t\tReadOption<MaybeLocal<Object>>(options, StringTable::Get().result, {}),\n\t\t\t\t\tTransferOptions::Type::Reference};\n\t\t\t}\n\n\t\t\t// Externalize all arguments\n\t\t\tArrayRange arguments;\n\t\t\tif (maybe_arguments.To(&arguments)) {\n\t\t\t\targv.reserve(std::distance(arguments.begin(), arguments.end()));\n\t\t\t\tfor (auto argument : arguments) {\n\t\t\t\t\targv.push_back(TransferOut(argument, arguments_transfer_options));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\t// Invoke in the isolate\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> fn = Deref(reference);\n\t\t\tif (!fn->IsFunction()) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not a function\");\n\t\t\t}\n\t\t\tstd::vector<Local<Value>> argv_inner = TransferArguments();\n\t\t\tLocal<Value> recv_inner = recv->TransferIn();\n\t\t\tLocal<Value> result = RunWithTimeout(timeout,\n\t\t\t\t[&fn, &context_handle, &recv_inner, &argv_inner]() {\n\t\t\t\t\treturn fn.As<Function>()->Call(context_handle, recv_inner, argv_inner.size(), argv_inner.empty() ? nullptr : &argv_inner[0]);\n\t\t\t\t}\n\t\t\t);\n\t\t\tret = TransferOut(result, return_transfer_options);\n\t\t}\n\n\t\tauto Phase2Async(Scheduler::AsyncWait& wait) -> bool final {\n\t\t\t// Same as regular `Phase2()` but if it returns a promise we will wait on it\n\t\t\tif (!(return_transfer_options == TransferOptions{TransferOptions::Type::Reference})) {\n\t\t\t\tthrow RuntimeTypeError(\"`result` options are not available for `applySyncPromise`\");\n\t\t\t}\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> fn = Deref(reference);\n\t\t\tif (!fn->IsFunction()) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not a function\");\n\t\t\t}\n\t\t\tLocal<Value> recv_inner = recv->TransferIn();\n\t\t\tstd::vector<Local<Value>> argv_inner = TransferArguments();\n\t\t\tLocal<Value> value = RunWithTimeout(\n\t\t\t\ttimeout,\n\t\t\t\t[&fn, &context_handle, &recv_inner, &argv_inner]() {\n\t\t\t\t\treturn fn.As<Function>()->Call(context_handle, recv_inner, argv_inner.size(), argv_inner.empty() ? nullptr : &argv_inner[0]);\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (value->IsPromise()) {\n\t\t\t\tIsolate* isolate = Isolate::GetCurrent();\n\t\t\t\t// This is only called from the default isolate, so we don't need an IsolateSpecific\n\t\t\t\tstatic Persistent<Function> callback_persistent{isolate, CompileAsyncWrapper()};\n\t\t\t\tLocal<Function> callback_fn = Deref(callback_persistent);\n\t\t\t\tdid_finish = std::make_shared<bool>(false);\n\t\t\t\tstd::array<Local<Value>, 3> argv;\n\t\t\t\targv[0] = External::New(isolate, reinterpret_cast<void*>(this));\n\t\t\t\targv[1] = External::New(isolate, reinterpret_cast<void*>(new shared_ptr<bool>(did_finish)));\n\t\t\t\targv[2] = value;\n\t\t\t\tasync_wait = &wait;\n\t\t\t\tUnmaybe(callback_fn->Call(context_handle, callback_fn, 3, &argv.front()));\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tret = TransferOut(value, return_transfer_options);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\tif (did_finish && !*did_finish) {\n\t\t\t\t*did_finish = true;\n\t\t\t\tthrow RuntimeGenericError(\"Script execution timed out.\");\n\t\t\t} else if (async_error) {\n\t\t\t\tIsolate::GetCurrent()->ThrowException(async_error->CopyInto());\n\t\t\t\tthrow RuntimeError();\n\t\t\t} else {\n\t\t\t\treturn ret->TransferIn();\n\t\t\t}\n\t\t}\n\n\tprivate:\n\t\t/**\n\t\t * This is an internal callback that will be called after a Promise returned from\n\t\t * `applySyncPromise` has resolved\n\t\t */\n\t\tstatic void AsyncCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n\t\t\t// It's possible the invocation timed out, in which case the ApplyRunner will be dead. The\n\t\t\t// shared_ptr<bool> here will be marked as true and we can exit early.\n\t\t\tunique_ptr<shared_ptr<bool>> did_finish{reinterpret_cast<shared_ptr<bool>*>(info[1].As<External>()->Value())};\n\t\t\tif (**did_finish) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tApplyRunner& self = *reinterpret_cast<ApplyRunner*>(info[0].As<External>()->Value());\n\t\t\tif (info.Length() == 3) {\n\t\t\t\t// Resolved\n\t\t\t\tFunctorRunners::RunCatchExternal(IsolateEnvironment::GetCurrent()->DefaultContext(), [&self, &info]() {\n\t\t\t\t\tself.ret = TransferOut(info[2]);\n\t\t\t\t}, [&self](unique_ptr<ExternalCopy> error) {\n\t\t\t\t\tself.async_error = std::move(error);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Rejected\n\t\t\t\tself.async_error = ExternalCopy::CopyThrownValue(info[3]);\n\t\t\t}\n\t\t\t*self.did_finish = true;\n\t\t\tself.async_wait->Wake();\n\t\t}\n\n\t\t/**\n\t\t * The C++ promise interface is a little clumsy so this does some work in JS for us. This function\n\t\t * is called once and returns a JS function that will be reused.\n\t\t */\n\t\tstatic auto CompileAsyncWrapper() -> Local<Function> {\n\t\t\tIsolate* isolate = Isolate::GetCurrent();\n\t\t\tLocal<Context> context = IsolateEnvironment::GetCurrent()->DefaultContext();\n\t\t\tLocal<Script> script = Unmaybe(Script::Compile(context, v8_string(\n\t\t\t\t\"'use strict';\"\n\t\t\t\t\"(function(AsyncCallback) {\"\n\t\t\t\t\t\"return function(ptr, did_finish, promise) {\"\n\t\t\t\t\t\t\"promise.then(function(val) {\"\n\t\t\t\t\t\t\t\"AsyncCallback(ptr, did_finish, val);\"\n\t\t\t\t\t\t\"}, function(err) {\"\n\t\t\t\t\t\t\t\"AsyncCallback(ptr, did_finish, null, err);\"\n\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\"};\"\n\t\t\t\t\"})\"\n\t\t\t)));\n\t\t\tLocal<Value> outer_fn = Unmaybe(script->Run(context));\n\t\t\tassert(outer_fn->IsFunction());\n\t\t\tLocal<Value> callback_fn = Unmaybe(FunctionTemplate::New(isolate, AsyncCallback)->GetFunction(context));\n\t\t\tLocal<Value> inner_fn = Unmaybe(outer_fn.As<Function>()->Call(context, Undefined(isolate), 1, &callback_fn));\n\t\t\tassert(inner_fn->IsFunction());\n\t\t\treturn inner_fn.As<Function>();\n\t\t}\n\n\t\tauto TransferArguments() -> std::vector<Local<Value>> {\n\t\t\tstd::vector<Local<Value>> argv_inner;\n\t\t\tsize_t argc = argv.size();\n\t\t\targv_inner.reserve(argc);\n\t\t\tfor (size_t ii = 0; ii < argc; ++ii) {\n\t\t\t\targv_inner.emplace_back(argv[ii]->TransferIn());\n\t\t\t}\n\t\t\treturn argv_inner;\n\t\t}\n\n\t\tstd::vector<unique_ptr<Transferable>> argv;\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tunique_ptr<Transferable> recv;\n\t\tunique_ptr<Transferable> ret;\n\t\tuint32_t timeout = 0;\n\t\t// Only used in the AsyncPhase2 case\n\t\tshared_ptr<bool> did_finish;\n\t\tTransferOptions return_transfer_options{TransferOptions::Type::Reference};\n\t\tunique_ptr<ExternalCopy> async_error;\n\t\tScheduler::AsyncWait* async_wait = nullptr;\n};\ntemplate <int async>\nauto ReferenceHandle::Apply(MaybeLocal<Value> recv_handle, Maybe<ArrayRange> maybe_arguments, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, ApplyRunner>(*isolate, *this, recv_handle, maybe_arguments, maybe_options);\n}\n\n/**\n * Copy this reference's value into this isolate\n */\nclass CopyRunner : public ThreePhaseTask {\n\tpublic:\n\t\tCopyRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tRemoteHandle<Context> context,\n\t\t\tRemoteHandle<Value> reference\n\t\t) : context{std::move(context)}, reference{std::move(reference)} {\n\t\t\tthat.CheckDisposed();\n\t\t}\n\n\t\tvoid Phase2() final {\n\t\t\tContext::Scope context_scope{Deref(context)};\n\t\t\tLocal<Value> value = Deref(reference);\n\t\t\tcopy = ExternalCopy::Copy(value);\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn copy->TransferIn();\n\t\t}\n\n\tprivate:\n\t\tRemoteHandle<Context> context;\n\t\tRemoteHandle<Value> reference;\n\t\tunique_ptr<Transferable> copy;\n};\n\ntemplate <int async>\nauto ReferenceHandle::Copy() -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, CopyRunner>(*isolate, *this, context, reference);\n}\n\n/**\n * Base class for get, set, and delete runners\n */\nclass AccessorRunner : public ThreePhaseTask {\n\tpublic:\n\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n\t\tcontext{target.context},\n\t\ttarget{target.reference},\n\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n\t\t\ttarget.CheckDisposed();\n\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n\t\t\t}\n\t\t}\n\n\tprotected:\n\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n\t\t\tauto object = Local<Object>::Cast(Deref(target));\n\t\t\tif (HasProxy(object)) {\n\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\n\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n\t\t\tauto key_inner = key->CopyInto();\n\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n\t\t}\n\n\t\tRemoteHandle<Context> context;\n\n\tprivate:\n\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n\t\t\tif (object->IsProxy()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tauto proto = object->GetPrototype();\n\t\t\t\tif (proto->IsNullOrUndefined()) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn HasProxy(proto.As<Object>());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tRemoteHandle<Value> target;\n\t\tunique_ptr<ExternalCopy> key;\n};\n\n/**\n * Get a property from this reference, returned as another reference\n */\nclass GetRunner final : public AccessorRunner {\n\tpublic:\n\t\tGetRunner(ReferenceHandle& target, Local<Value> key_handle, MaybeLocal<Object> maybe_options) :\n\t\tAccessorRunner{target, key_handle},\n\t\toptions{maybe_options, target.inherit ?\n\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\tinherit{target.inherit} {}\n\n\t\tvoid Phase2() final {\n\t\t\t// Setup\n\t\t\tauto* isolate = Isolate::GetCurrent();\n\t\t\tauto context = Deref(this->context);\n\t\t\tContext::Scope context_scope{context};\n\t\t\tauto name = GetKey(context);\n\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n\n\t\t\t// Get property\n\t\t\tret = TransferOut([&]() {\n\t\t\t\tif (inherit) {\n\t\t\t\t\t// To avoid accessors I guess we have to walk the prototype chain ourselves\n\t\t\t\t\tauto target = object;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (Unmaybe(target->HasOwnProperty(context, name))) {\n\t\t\t\t\t\t\tif (Unmaybe(target->HasRealNamedCallbackProperty(context, name))) {\n\t\t\t\t\t\t\t\tthrow RuntimeTypeError(\"Property is getter\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn Unmaybe(target->GetRealNamedProperty(context, name));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next = target->GetPrototype();\n\t\t\t\t\t\tif (next->IsNullOrUndefined()) {\n\t\t\t\t\t\t\treturn Undefined(isolate).As<Value>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttarget = next.As<Object>();\n\t\t\t\t\t} while (true);\n\t\t\t\t} else if (!Unmaybe(object->HasOwnProperty(context, name))) {\n\t\t\t\t\treturn Undefined(isolate).As<Value>();\n\t\t\t\t} else if (Unmaybe(object->HasRealNamedCallbackProperty(context, name))) {\n\t\t\t\t\tthrow RuntimeTypeError(\"Property is getter\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Unmaybe(object->Get(context, name));\n\t\t\t\t}\n\t\t\t}(), options);\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn ret->TransferIn();\n\t\t}\n\n\tprivate:\n\t\tunique_ptr<Transferable> ret;\n\t\tTransferOptions options;\n\t\tbool inherit;\n};\ntemplate <int async>\nauto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options);\n}\n\n/**\n * Delete a property on this reference\n */\nclass DeleteRunner final : public AccessorRunner {\n\tpublic:\n\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\tAccessorRunner{that, key_handle} {}\n\n\t\tvoid Phase2() final {\n\t\t\tauto context = Deref(this->context);\n\t\t\tContext::Scope context_scope{context};\n\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n\t\t\tif (!Unmaybe(object->Delete(context, GetKey(context)))) {\n\t\t\t\tthrow RuntimeTypeError(\"Delete failed\");\n\t\t\t}\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}\n};\ntemplate <int async>\nauto ReferenceHandle::Delete(Local<Value> key_handle) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, DeleteRunner>(*isolate, *this, key_handle);\n}\n\n/**\n * Attempt to set a property on this reference\n */\nclass SetRunner final : public AccessorRunner {\n\tpublic:\n\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\tAccessorRunner{that, key_handle},\n\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}\n\n\t\tvoid Phase2() final {\n\t\t\tauto context = Deref(this->context);\n\t\t\tContext::Scope context_scope{context};\n\t\t\tauto name = GetKey(context);\n\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n\t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n\t\t\tUnmaybe(object->Delete(context, name));\n\t\t\tauto val_inner = val->TransferIn();\n\t\t\tif (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {\n\t\t\t\tthrow RuntimeTypeError(\"Set failed\");\n\t\t\t}\n\t\t}\n\n\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}\n\n\tprivate:\n\t\tunique_ptr<Transferable> val;\n};\ntemplate <int async>\nauto ReferenceHandle::Set(Local<Value> key_handle, Local<Value> val_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, SetRunner>(*isolate, *this, key_handle, val_handle, maybe_options);\n}\n\nvoid ReferenceHandle::CheckDisposed() const {\n\tif (!reference) {\n\t\tthrow RuntimeGenericError(\"Reference has been released\");\n\t}\n}\n\n/**\n * ReferenceHandleTransferable implementation\n */\nauto ReferenceHandleTransferable::TransferIn() -> Local<Value> {\n\treturn ClassHandle::NewInstance<ReferenceHandle>(std::move(*this));\n}\n\n} // namespace ivm\n", "#pragma once\n#include \"isolate/remote_handle.h\"\n#include \"transferable.h\"\n#include <v8.h>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace ivm {\nnamespace detail {\n\n/**\n * Holds common data for ReferenceHandle and ReferenceHandleTransferable\n */\nclass ReferenceData {\n\tfriend class AccessorRunner;\n\tpublic:\n\t\tenum class TypeOf { Null, Undefined, Number, String, Boolean, Object, Function };\n\n\t\texplicit ReferenceData(v8::Local<v8::Value> value, bool inherit = false);\n\t\tReferenceData(\n\t\t\tstd::shared_ptr<IsolateHolder> isolate,\n\t\t\tRemoteHandle<v8::Value> reference,\n\t\t\tRemoteHandle<v8::Context> context,\n\t\t\tTypeOf type_of,\n\t\t\tbool inherit = false\n\t\t);\n\n\tprotected:\n\t\tstd::shared_ptr<IsolateHolder> isolate;\n\t\tRemoteHandle<v8::Value> reference;\n\t\tRemoteHandle<v8::Context> context;\n\t\tTypeOf type_of;\n\t\tbool inherit;\n};\n\n} // namespace detail\n\n/**\n * This will be a reference to any v8 Value in any isolate.\n */\nclass ReferenceHandle : public TransferableHandle, public detail::ReferenceData {\n\tfriend class ApplyRunner;\n\tfriend class CopyRunner;\n\tfriend class AccessorRunner;\n\tfriend class GetRunner;\n\tpublic:\n\t\tusing TypeOf = detail::ReferenceData::TypeOf;\n\n\t\ttemplate <class ...Args>\n\t\texplicit ReferenceHandle(Args&&... args) : ReferenceData{std::forward<Args>(args)...} {}\n\n\t\tstatic auto Definition() -> v8::Local<v8::FunctionTemplate>;\n\t\tstatic auto New(v8::Local<v8::Value> value, v8::MaybeLocal<v8::Object> options)\n\t\t\t-> std::unique_ptr<ReferenceHandle>;\n\t\tauto TransferOut() -> std::unique_ptr<Transferable> final;\n\n\t\tauto Deref(v8::MaybeLocal<v8::Object> maybe_options) -> v8::Local<v8::Value>;\n\t\tauto DerefInto(v8::MaybeLocal<v8::Object> maybe_options) -> v8::Local<v8::Value>;\n\t\tauto Release() -> v8::Local<v8::Value>;\n\t\tauto TypeOfGetter() -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Apply(\n\t\t\tv8::MaybeLocal<v8::Value> recv_handle,\n\t\t\tv8::Maybe<ArrayRange> maybe_arguments,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Copy() -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Get(\n\t\t\tv8::Local<v8::Value> key_handle,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Delete(v8::Local<v8::Value> key_handle) -> v8::Local<v8::Value>;\n\n\t\ttemplate <int async>\n\t\tauto Set(\n\t\t\tv8::Local<v8::Value> key_handle,\n\t\t\tv8::Local<v8::Value> val_handle,\n\t\t\tv8::MaybeLocal<v8::Object> maybe_options\n\t\t) -> v8::Local<v8::Value>;\n\n\tprivate:\n\t\tvoid CheckDisposed() const;\n};\n\n/**\n * Instances of this turn into a ReferenceHandle when they are transferred in\n */\nclass ReferenceHandleTransferable : public Transferable, public detail::ReferenceData {\n\tpublic:\n\t\ttemplate <class ...Args>\n\t\texplicit ReferenceHandleTransferable(Args&&... args) : ReferenceData{std::forward<Args>(args)...} {}\n\n\t\tauto TransferIn() -> v8::Local<v8::Value> final;\n};\n\n} // namespace ivm\n", "'use strict';\nconst ivm = require('isolated-vm');\nconst { strictEqual, throws } = require('assert');\nlet trap = false;\n\n{\n\t// Set up inheritance\n\tconst foo = { foo: 1 };\n\tconst bar = Object.create(foo);\n\tbar.bar = 2;\n\tconst etc = Object.create(bar);\n\tetc.etc = bar;\n\n\t{\n\t\t// Test without inheritance\n\t\tconst ref = new ivm.Reference(etc);\n\t\tstrictEqual(ref.getSync('bar'), undefined);\n\t\tstrictEqual(ref.getSync('etc').getSync('foo'), undefined);\n\t\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n\t\tref.setSync('prop', 1);\n\t\tstrictEqual(ref.getSync('prop'), 1);\n\t\tref.deleteSync('prop');\n\t\tstrictEqual(ref.getSync('prop'), undefined);\n\t}\n\n\t{\n\t\t// Test with inheritance\n\t\tconst ref = new ivm.Reference(etc, { unsafeInherit: true });\n\t\tstrictEqual(ref.getSync('bar'), 2);\n\t\tstrictEqual(ref.getSync('etc').getSync('foo'), 1);\n\t\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n\t\tref.getSync('etc').setSync('prop', 1);\n\t\tref.setSync('prop', 2);\n\t\tstrictEqual(ref.getSync('prop'), 2);\n\t\tref.deleteSync('prop');\n\t\tstrictEqual(ref.getSync('prop'), 1);\n\t}\n}\n\n{\n\t// Set up getter / setters\n\tlet setter = 0;\n\tconst foo = {\n\t\tget str() { trap = true; return 'got' },\n\t\tset str(_) { trap = true },\n\t};\n\tObject.defineProperty(foo, 0, {\n\t\tget() { trap = true; return 'got' },\n\t\tset() { trap = true },\n\t});\n\n\t{\n\t\t// Test plain accessors\n\t\tconst ref = new ivm.Reference(foo);\n\t\tthrows(() => ref.getSync('str'));\n\t\tthrows(() => ref.getSync(0));\n\t\tthrows(() => ref.setSync(0, undefined));\n\t}\n\n\t{\n\t\t// Test accessors + inheritance\n\t\tconst ref = new ivm.Reference(Object.create(foo), { unsafeInherit: true });\n\t\tthrows(() => ref.getSync('str'));\n\t\tref.setSync('str', undefined);\n\t\tthrows(() => ref.getSync(0));\n\t}\n}\n\n{\n\t// Set up evil proxy\n\tconst val = { prop: 1 };\n\tconst prox = new Proxy(val, {\n\t\tget() { trap = true },\n    set() { trap = true },\n    getOwnPropertyDescriptor() { trap = true },\n    getPrototypeOf() { trap = true },\n    has() { trap = true },\n    ownKeys() { trap = true },\n\t});\n\tconst inherited = Object.create(prox);\n\n\t{\n\t\t// Test proxy\n\t\tconst ref = new ivm.Reference(prox);\n\t\tthrows(() => ref.getSync('prop'));\n\t}\n\n\t{\n\t\t// Test inherited proxy\n\t\tconst ref = new ivm.Reference(inherited);\n\t\tthrows(() => ref.getSync('prop'),);\n\t}\n\n\t{\n\t\t// Test deep inherited proxy\n\t\tconst ref = new ivm.Reference(inherited, { unsafeInherit: true });\n\t\tthrows(() => ref.getSync('prop'));\n\t}\n}\n\n{\n\t// Test Array (numeric indices)\n\tconst val = [ 1, 2, 3 ];\n\tObject.defineProperty(val, 1, { get() { trap = true; return 'got' }});\n\tconst ref = new ivm.Reference(val);\n\tstrictEqual(ref.getSync(0), 1);\n\tthrows(() => ref.getSync(1));\n}\n\n{\n\t// Test ArrayBuffer (numeric indices)\n\tconst val = new Uint8Array([ 1, 2, 3 ]);\n\tconst ref = new ivm.Reference(val);\n\tstrictEqual(ref.getSync(0), 1);\n}\n\nif (trap) {\n\tconsole.log('fail');\n}\nconsole.log('pass');\n"], "filenames": ["CHANGELOG.md", "README.md", "isolated-vm.d.ts", "src/isolate/strings.h", "src/module/reference_handle.cc", "src/module/reference_handle.h", "tests/reference.js"], "buggy_code_start_loc": [3, 347, 11, 61, 130, 15, 0], "buggy_code_end_loc": [8, 415, 729, 84, 570, 47, 21], "fixing_code_start_loc": [3, 347, 12, 60, 130, 16, 1], "fixing_code_end_loc": [10, 411, 732, 85, 599, 46, 120], "type": "CWE-913", "message": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.", "other": {"cve": {"id": "CVE-2021-21413", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-30T23:15:14.190", "lastModified": "2021-04-07T14:56:50.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes."}, {"lang": "es", "value": "isolated-vm es una biblioteca para nodejs que le da acceso a la interfaz Isolate de v8.&#xa0;Las versiones de isolated-vm anteriores a v4.0.0 presentan unas limitaciones de la API que puede facilitar a implementadores una exposici\u00f3n de supuestos aislamientos seguros para los permisos del aislamiento de nodejs principal.&#xa0;Los objetos de referencia permiten el acceso a la cadena de prototipos completa de la referencia subyacente.&#xa0;En un entorno donde el implementador ha expuesto una instancia de Referencia a un atacante, podr\u00eda ser capaz de usarla para adquirir una Referencia al objeto de Funci\u00f3n del contexto de nodejs.&#xa0;Se podr\u00edan realizar ataques espec\u00edficos de aplicaciones similares al modificar el prototipo local de otros objetos API.&#xa0;Un acceso a los objetos NativeModule podr\u00eda permitir a un atacante cargar y ejecutar c\u00f3digo nativo desde cualquier lugar del sistema de archivos.&#xa0;Si es combinado con, por ejemplo,&#xa0;una API de carga de archivos, esto permitir\u00eda una ejecuci\u00f3n de c\u00f3digo arbitrario.&#xa0;Esto es abordado en versi\u00f3n v4.0.0 mediante una serie de cambios relacionados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.5, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-913"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:isolated-vm_project:isolated-vm:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.0.0", "matchCriteriaId": "6050FC4E-0C96-4300-8F43-78C1C6E27A0E"}]}]}], "references": [{"url": "https://github.com/laverdet/isolated-vm/blob/main/CHANGELOG.md#v400", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laverdet/isolated-vm/commit/27151bfecc260e96714443613880e3b2e6596704", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laverdet/isolated-vm/security/advisories/GHSA-mmhj-4w6j-76h7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15"}}