{"buggy_code": ["// SPDX-FileCopyrightText: 2020 The CC: Tweaked Developers\n//\n// SPDX-License-Identifier: MPL-2.0\n\npackage dan200.computercraft.core.apis.http.options;\n\nimport com.google.common.net.InetAddresses;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.regex.Pattern;\n\n/**\n * A predicate on an address. Matches against a domain and an ip address.\n *\n * @see AddressRule#apply(Iterable, String, InetSocketAddress) for the actual handling of this rule.\n */\ninterface AddressPredicate {\n    default boolean matches(String domain) {\n        return false;\n    }\n\n    default boolean matches(InetAddress socketAddress) {\n        return false;\n    }\n\n    final class HostRange implements AddressPredicate {\n        private final byte[] min;\n        private final byte[] max;\n\n        HostRange(byte[] min, byte[] max) {\n            this.min = min;\n            this.max = max;\n        }\n\n        @Override\n        public boolean matches(InetAddress address) {\n            var entry = address.getAddress();\n            if (entry.length != min.length) return false;\n\n            for (var i = 0; i < entry.length; i++) {\n                var value = 0xFF & entry[i];\n                if (value < (0xFF & min[i]) || value > (0xFF & max[i])) return false;\n            }\n\n            return true;\n        }\n\n        public static HostRange parse(String addressStr, String prefixSizeStr) {\n            int prefixSize;\n            try {\n                prefixSize = Integer.parseInt(prefixSizeStr);\n            } catch (NumberFormatException e) {\n                throw new InvalidRuleException(String.format(\n                    \"Invalid host host '%s': Cannot extract size of CIDR mask from '%s'.\",\n                    addressStr + '/' + prefixSizeStr, prefixSizeStr\n                ));\n            }\n\n            InetAddress address;\n            try {\n                address = InetAddresses.forString(addressStr);\n            } catch (IllegalArgumentException e) {\n                throw new InvalidRuleException(String.format(\n                    \"Invalid host '%s': Cannot extract IP address from '%s'.\",\n                    addressStr + '/' + prefixSizeStr, addressStr\n                ));\n            }\n\n            // Mask the bytes of the IP address.\n            byte[] minBytes = address.getAddress(), maxBytes = address.getAddress();\n            var size = prefixSize;\n            for (var i = 0; i < minBytes.length; i++) {\n                if (size <= 0) {\n                    minBytes[i] = (byte) 0;\n                    maxBytes[i] = (byte) 0xFF;\n                } else if (size < 8) {\n                    minBytes[i] = (byte) (minBytes[i] & 0xFF << (8 - size));\n                    maxBytes[i] = (byte) (maxBytes[i] | ~(0xFF << (8 - size)));\n                }\n\n                size -= 8;\n            }\n\n            return new HostRange(minBytes, maxBytes);\n        }\n    }\n\n    final class DomainPattern implements AddressPredicate {\n        private final Pattern pattern;\n\n        DomainPattern(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(String domain) {\n            return pattern.matcher(domain).matches();\n        }\n\n        @Override\n        public boolean matches(InetAddress socketAddress) {\n            return pattern.matcher(socketAddress.getHostAddress()).matches();\n        }\n    }\n\n    final class PrivatePattern implements AddressPredicate {\n        static final PrivatePattern INSTANCE = new PrivatePattern();\n\n        @Override\n        public boolean matches(InetAddress socketAddress) {\n            return socketAddress.isAnyLocalAddress()\n                || socketAddress.isLoopbackAddress()\n                || socketAddress.isLinkLocalAddress()\n                || socketAddress.isSiteLocalAddress();\n        }\n    }\n\n}\n", "// SPDX-FileCopyrightText: 2020 The CC: Tweaked Developers\n//\n// SPDX-License-Identifier: MPL-2.0\n\npackage dan200.computercraft.core.apis.http.options;\n\nimport dan200.computercraft.core.CoreConfig;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.OptionalInt;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AddressRuleTest {\n    @Test\n    public void matchesPort() {\n        Iterable<AddressRule> rules = Collections.singletonList(AddressRule.parse(\n            \"127.0.0.1\", OptionalInt.of(8080),\n            Action.ALLOW.toPartial()\n        ));\n\n        assertEquals(apply(rules, \"localhost\", 8080).action, Action.ALLOW);\n        assertEquals(apply(rules, \"localhost\", 8081).action, Action.DENY);\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\n        \"0.0.0.0\", \"[::]\",\n        \"localhost\", \"127.0.0.1.nip.io\", \"127.0.0.1\", \"[::1]\",\n        \"172.17.0.1\", \"192.168.1.114\", \"[0:0:0:0:0:ffff:c0a8:172]\", \"10.0.0.1\"\n    })\n    public void blocksLocalDomains(String domain) {\n        assertEquals(apply(CoreConfig.httpRules, domain, 80).action, Action.DENY);\n    }\n\n    private Options apply(Iterable<AddressRule> rules, String host, int port) {\n        return AddressRule.apply(rules, host, new InetSocketAddress(host, port));\n    }\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2020 The CC: Tweaked Developers\n//\n// SPDX-License-Identifier: MPL-2.0\n\npackage dan200.computercraft.core.apis.http.options;\n\nimport com.google.common.net.InetAddresses;\n\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * A predicate on an address. Matches against a domain and an ip address.\n *\n * @see AddressRule#apply(Iterable, String, InetSocketAddress) for the actual handling of this rule.\n */\ninterface AddressPredicate {\n    default boolean matches(String domain) {\n        return false;\n    }\n\n    default boolean matches(InetAddress socketAddress) {\n        return false;\n    }\n\n    final class HostRange implements AddressPredicate {\n        private final byte[] min;\n        private final byte[] max;\n\n        HostRange(byte[] min, byte[] max) {\n            this.min = min;\n            this.max = max;\n        }\n\n        @Override\n        public boolean matches(InetAddress address) {\n            var entry = address.getAddress();\n            if (entry.length != min.length) return false;\n\n            for (var i = 0; i < entry.length; i++) {\n                var value = 0xFF & entry[i];\n                if (value < (0xFF & min[i]) || value > (0xFF & max[i])) return false;\n            }\n\n            return true;\n        }\n\n        public static HostRange parse(String addressStr, String prefixSizeStr) {\n            int prefixSize;\n            try {\n                prefixSize = Integer.parseInt(prefixSizeStr);\n            } catch (NumberFormatException e) {\n                throw new InvalidRuleException(String.format(\n                    \"Invalid host host '%s': Cannot extract size of CIDR mask from '%s'.\",\n                    addressStr + '/' + prefixSizeStr, prefixSizeStr\n                ));\n            }\n\n            InetAddress address;\n            try {\n                address = InetAddresses.forString(addressStr);\n            } catch (IllegalArgumentException e) {\n                throw new InvalidRuleException(String.format(\n                    \"Invalid host '%s': Cannot extract IP address from '%s'.\",\n                    addressStr + '/' + prefixSizeStr, addressStr\n                ));\n            }\n\n            // Mask the bytes of the IP address.\n            byte[] minBytes = address.getAddress(), maxBytes = address.getAddress();\n            var size = prefixSize;\n            for (var i = 0; i < minBytes.length; i++) {\n                if (size <= 0) {\n                    minBytes[i] = (byte) 0;\n                    maxBytes[i] = (byte) 0xFF;\n                } else if (size < 8) {\n                    minBytes[i] = (byte) (minBytes[i] & 0xFF << (8 - size));\n                    maxBytes[i] = (byte) (maxBytes[i] | ~(0xFF << (8 - size)));\n                }\n\n                size -= 8;\n            }\n\n            return new HostRange(minBytes, maxBytes);\n        }\n    }\n\n    final class DomainPattern implements AddressPredicate {\n        private final Pattern pattern;\n\n        DomainPattern(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(String domain) {\n            return pattern.matcher(domain).matches();\n        }\n\n        @Override\n        public boolean matches(InetAddress socketAddress) {\n            return pattern.matcher(socketAddress.getHostAddress()).matches();\n        }\n    }\n\n    final class PrivatePattern implements AddressPredicate {\n        static final PrivatePattern INSTANCE = new PrivatePattern();\n\n        private static final Set<InetAddress> additionalAddresses = Arrays.stream(new String[]{\n            // Block various cloud providers internal IPs.\n            \"100.100.100.200\", // Alibaba\n            \"192.0.0.192\", // Oracle\n        }).map(InetAddresses::forString).collect(Collectors.toUnmodifiableSet());\n\n        @Override\n        public boolean matches(InetAddress socketAddress) {\n            return\n                socketAddress.isAnyLocalAddress()      // 0.0.0.0, ::0\n                || socketAddress.isLoopbackAddress()   // 127.0.0.0/8, ::1\n                || socketAddress.isLinkLocalAddress()  // 169.254.0.0/16, fe80::/10\n                || socketAddress.isSiteLocalAddress()  // 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fec0::/10\n                || socketAddress.isMulticastAddress()  // 224.0.0.0/4, ff00::/8\n                || isUniqueLocalAddress(socketAddress) // fd00::/8\n                || additionalAddresses.contains(socketAddress);\n        }\n\n        /**\n         * Determine if an IP address lives inside the ULA address range.\n         *\n         * @param address The IP address to test.\n         * @return Whether this address sits in the ULA address range.\n         * @see <a href=\"https://en.wikipedia.org/wiki/Unique_local_address\">Unique local address on Wikipedia</a>\n         */\n        private boolean isUniqueLocalAddress(InetAddress address) {\n            // ULA is actually defined as fc00::/7 (so both fc00::/8 and fd00::/8). However, only the latter is actually\n            // defined right now, so let's be conservative.\n            return address instanceof Inet6Address && (address.getAddress()[0] & 0xff) == 0xfd;\n        }\n    }\n\n}\n", "// SPDX-FileCopyrightText: 2020 The CC: Tweaked Developers\n//\n// SPDX-License-Identifier: MPL-2.0\n\npackage dan200.computercraft.core.apis.http.options;\n\nimport dan200.computercraft.core.CoreConfig;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.OptionalInt;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AddressRuleTest {\n    @Test\n    public void matchesPort() {\n        Iterable<AddressRule> rules = Collections.singletonList(AddressRule.parse(\n            \"127.0.0.1\", OptionalInt.of(8080),\n            Action.ALLOW.toPartial()\n        ));\n\n        assertEquals(apply(rules, \"localhost\", 8080).action, Action.ALLOW);\n        assertEquals(apply(rules, \"localhost\", 8081).action, Action.DENY);\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\n        \"0.0.0.0\", \"[::]\",\n        \"localhost\", \"127.0.0.1.nip.io\", \"127.0.0.1\", \"[::1]\",\n        \"172.17.0.1\", \"192.168.1.114\", \"[0:0:0:0:0:ffff:c0a8:172]\", \"10.0.0.1\",\n        // Multicast\n        \"224.0.0.1\", \"ff02::1\",\n        // Cloud metadata providers\n        \"100.100.100.200\", // Alibaba\n        \"192.0.0.192\", // Oracle\n        \"fd00:ec2::254\", // AWS\n        \"169.254.169.254\", // AWS, Digital Ocean, GCP, etc..\n    })\n    public void blocksLocalDomains(String domain) {\n        assertEquals(apply(CoreConfig.httpRules, domain, 80).action, Action.DENY);\n    }\n\n    private Options apply(Iterable<AddressRule> rules, String host, int port) {\n        return AddressRule.apply(rules, host, new InetSocketAddress(host, port));\n    }\n}\n"], "filenames": ["projects/core/src/main/java/dan200/computercraft/core/apis/http/options/AddressPredicate.java", "projects/core/src/test/java/dan200/computercraft/core/apis/http/options/AddressRuleTest.java"], "buggy_code_start_loc": [8, 34], "buggy_code_end_loc": [116, 35], "fixing_code_start_loc": [9, 34], "fixing_code_end_loc": [143, 42], "type": "CWE-918", "message": "CC: Tweaked is a mod for Minecraft which adds programmable computers, turtles, and more to the game. Prior to versions 1.20.1-1.106.0, 1.19.4-1.106.0, 1.19.2-1.101.3, 1.18.2-1.101.3, and 1.16.5-1.101.3, if the cc-tweaked plugin is running on a Minecraft server hosted on a popular cloud hosting providers, like AWS, GCP, and Azure, those metadata services API endpoints are not forbidden (aka \"blacklisted\") by default. As such, any player can gain access to sensitive information exposed via those metadata servers, potentially allowing them to pivot or privilege escalate into the hosting provider. Versions 1.20.1-1.106.0, 1.19.4-1.106.0, 1.19.2-1.101.3, 1.18.2-1.101.3, and 1.16.5-1.101.3 contain a fix for this issue.", "other": {"cve": {"id": "CVE-2023-37262", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-07T21:15:09.393", "lastModified": "2023-07-18T18:12:57.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CC: Tweaked is a mod for Minecraft which adds programmable computers, turtles, and more to the game. Prior to versions 1.20.1-1.106.0, 1.19.4-1.106.0, 1.19.2-1.101.3, 1.18.2-1.101.3, and 1.16.5-1.101.3, if the cc-tweaked plugin is running on a Minecraft server hosted on a popular cloud hosting providers, like AWS, GCP, and Azure, those metadata services API endpoints are not forbidden (aka \"blacklisted\") by default. As such, any player can gain access to sensitive information exposed via those metadata servers, potentially allowing them to pivot or privilege escalate into the hosting provider. Versions 1.20.1-1.106.0, 1.19.4-1.106.0, 1.19.2-1.101.3, 1.18.2-1.101.3, and 1.16.5-1.101.3 contain a fix for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tweaked:cc-tweaked:*:*:*:*:*:minecraft:*:*", "versionEndExcluding": "1.16.5-1.101.3", "matchCriteriaId": "6543780A-8A9B-4562-932C-60B6FC60C221"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tweaked:cc-tweaked:*:*:*:*:*:minecraft:*:*", "versionStartIncluding": "1.17.1-1.98.1", "versionEndExcluding": "1.18.2-1.101.3", "matchCriteriaId": "0C935D89-E88C-4143-BD3B-6F4D18DD2C28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tweaked:cc-tweaked:*:*:*:*:*:minecraft:*:*", "versionStartIncluding": "1.19.1-1.100.9", "versionEndExcluding": "1.19.2-1.101.3", "matchCriteriaId": "9FE5FF3D-BA6E-410F-8249-C52F8DB30893"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tweaked:cc-tweaked:*:*:*:*:*:minecraft:*:*", "versionStartIncluding": "1.19.3-1.102.0", "versionEndExcluding": "1.19.4-1.106.0", "matchCriteriaId": "A75D740A-E648-4BB6-8E19-833273F0F0EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tweaked:cc-tweaked:*:*:*:*:*:minecraft:*:*", "versionStartIncluding": "1.20.1-1.105.0", "versionEndExcluding": "1.20.1-1.106.0", "matchCriteriaId": "C4E8E115-C213-4CCF-80D2-B6BDF733DE3E"}]}]}], "references": [{"url": "https://github.com/MightyPirates/OpenComputers/security/advisories/GHSA-vvfj-xh7c-j2cm", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/cc-tweaked/CC-Tweaked/blob/96847bb8c28df51e5e49f2dd2978ff6cc4e2821b/projects/core/src/main/java/dan200/computercraft/core/apis/http/options/AddressPredicate.java#L116-L126", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/cc-tweaked/CC-Tweaked/commit/4bbde8c50c00bc572578ab2cff609b3443d10ddf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/cc-tweaked/CC-Tweaked/security/advisories/GHSA-7p4w-mv69-2wm2", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/dan200/ComputerCraft/issues/170", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/cc-tweaked/CC-Tweaked/commit/4bbde8c50c00bc572578ab2cff609b3443d10ddf"}}