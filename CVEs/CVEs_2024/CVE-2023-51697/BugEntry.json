{"buggy_code": ["const Logger = require('../Logger')\nconst SocketAuthority = require('../SocketAuthority')\nconst Database = require('../Database')\n\nconst fs = require('../libs/fsExtra')\n\nconst { getPodcastFeed, findMatchingEpisodes } = require('../utils/podcastUtils')\nconst { getFileTimestampsWithIno, filePathToPOSIX } = require('../utils/fileUtils')\n\nconst Scanner = require('../scanner/Scanner')\nconst CoverManager = require('../managers/CoverManager')\n\nconst LibraryItem = require('../objects/LibraryItem')\n\nclass PodcastController {\n\n  async create(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to create podcast`)\n      return res.sendStatus(403)\n    }\n    const payload = req.body\n\n    const library = await Database.libraryModel.getOldById(payload.libraryId)\n    if (!library) {\n      Logger.error(`[PodcastController] Create: Library not found \"${payload.libraryId}\"`)\n      return res.status(404).send('Library not found')\n    }\n\n    const folder = library.folders.find(fold => fold.id === payload.folderId)\n    if (!folder) {\n      Logger.error(`[PodcastController] Create: Folder not found \"${payload.folderId}\"`)\n      return res.status(404).send('Folder not found')\n    }\n\n    const podcastPath = filePathToPOSIX(payload.path)\n\n    // Check if a library item with this podcast folder exists already\n    const existingLibraryItem = (await Database.libraryItemModel.count({\n      where: {\n        path: podcastPath\n      }\n    })) > 0\n    if (existingLibraryItem) {\n      Logger.error(`[PodcastController] Podcast already exists at path \"${podcastPath}\"`)\n      return res.status(400).send('Podcast already exists')\n    }\n\n    const success = await fs.ensureDir(podcastPath).then(() => true).catch((error) => {\n      Logger.error(`[PodcastController] Failed to ensure podcast dir \"${podcastPath}\"`, error)\n      return false\n    })\n    if (!success) return res.status(400).send('Invalid podcast path')\n\n    const libraryItemFolderStats = await getFileTimestampsWithIno(podcastPath)\n\n    let relPath = payload.path.replace(folder.fullPath, '')\n    if (relPath.startsWith('/')) relPath = relPath.slice(1)\n\n    const libraryItemPayload = {\n      path: podcastPath,\n      relPath,\n      folderId: payload.folderId,\n      libraryId: payload.libraryId,\n      ino: libraryItemFolderStats.ino,\n      mtimeMs: libraryItemFolderStats.mtimeMs || 0,\n      ctimeMs: libraryItemFolderStats.ctimeMs || 0,\n      birthtimeMs: libraryItemFolderStats.birthtimeMs || 0,\n      media: payload.media\n    }\n\n    const libraryItem = new LibraryItem()\n    libraryItem.setData('podcast', libraryItemPayload)\n\n    // Download and save cover image\n    if (payload.media.metadata.imageUrl) {\n      // TODO: Scan cover image to library files\n      // Podcast cover will always go into library item folder\n      const coverResponse = await CoverManager.downloadCoverFromUrl(libraryItem, payload.media.metadata.imageUrl, true)\n      if (coverResponse) {\n        if (coverResponse.error) {\n          Logger.error(`[PodcastController] Download cover error from \"${payload.media.metadata.imageUrl}\": ${coverResponse.error}`)\n        } else if (coverResponse.cover) {\n          libraryItem.media.coverPath = coverResponse.cover\n        }\n      }\n    }\n\n    await Database.createLibraryItem(libraryItem)\n    SocketAuthority.emitter('item_added', libraryItem.toJSONExpanded())\n\n    res.json(libraryItem.toJSONExpanded())\n\n    if (payload.episodesToDownload?.length) {\n      Logger.info(`[PodcastController] Podcast created now starting ${payload.episodesToDownload.length} episode downloads`)\n      this.podcastManager.downloadPodcastEpisodes(libraryItem, payload.episodesToDownload)\n    }\n\n    // Turn on podcast auto download cron if not already on\n    if (libraryItem.media.autoDownloadEpisodes) {\n      this.cronManager.checkUpdatePodcastCron(libraryItem)\n    }\n  }\n\n  async getPodcastFeed(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to get podcast feed`)\n      return res.sendStatus(403)\n    }\n\n    var url = req.body.rssFeed\n    if (!url) {\n      return res.status(400).send('Bad request')\n    }\n\n    const podcast = await getPodcastFeed(url)\n    if (!podcast) {\n      return res.status(404).send('Podcast RSS feed request failed or invalid response data')\n    }\n    res.json({ podcast })\n  }\n\n  async getFeedsFromOPMLText(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to get feeds from opml`)\n      return res.sendStatus(403)\n    }\n\n    if (!req.body.opmlText) {\n      return res.sendStatus(400)\n    }\n\n    const rssFeedsData = await this.podcastManager.getOPMLFeeds(req.body.opmlText)\n    res.json(rssFeedsData)\n  }\n\n  async checkNewEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to check/download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n\n    var libraryItem = req.libraryItem\n    if (!libraryItem.media.metadata.feedUrl) {\n      Logger.error(`[PodcastController] checkNewEpisodes no feed url for item ${libraryItem.id}`)\n      return res.status(500).send('Podcast has no rss feed url')\n    }\n\n    const maxEpisodesToDownload = !isNaN(req.query.limit) ? Number(req.query.limit) : 3\n\n    var newEpisodes = await this.podcastManager.checkAndDownloadNewEpisodes(libraryItem, maxEpisodesToDownload)\n    res.json({\n      episodes: newEpisodes || []\n    })\n  }\n\n  clearEpisodeDownloadQueue(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempting to clear download queue \"${req.user.username}\"`)\n      return res.sendStatus(403)\n    }\n    this.podcastManager.clearDownloadQueue(req.params.id)\n    res.sendStatus(200)\n  }\n\n  getEpisodeDownloads(req, res) {\n    var libraryItem = req.libraryItem\n\n    var downloadsInQueue = this.podcastManager.getEpisodeDownloadsInQueue(libraryItem.id)\n    res.json({\n      downloads: downloadsInQueue.map(d => d.toJSONForClient())\n    })\n  }\n\n  async findEpisode(req, res) {\n    const rssFeedUrl = req.libraryItem.media.metadata.feedUrl\n    if (!rssFeedUrl) {\n      Logger.error(`[PodcastController] findEpisode: Podcast has no feed url`)\n      return res.status(500).send('Podcast does not have an RSS feed URL')\n    }\n\n    var searchTitle = req.query.title\n    if (!searchTitle) {\n      return res.sendStatus(500)\n    }\n    const episodes = await findMatchingEpisodes(rssFeedUrl, searchTitle)\n    res.json({\n      episodes: episodes || []\n    })\n  }\n\n  async downloadEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n    const libraryItem = req.libraryItem\n    const episodes = req.body\n    if (!episodes?.length) {\n      return res.sendStatus(400)\n    }\n\n    this.podcastManager.downloadPodcastEpisodes(libraryItem, episodes)\n    res.sendStatus(200)\n  }\n\n  // POST: api/podcasts/:id/match-episodes\n  async quickMatchEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n\n    const overrideDetails = req.query.override === '1'\n    const episodesUpdated = await Scanner.quickMatchPodcastEpisodes(req.libraryItem, { overrideDetails })\n    if (episodesUpdated) {\n      await Database.updateLibraryItem(req.libraryItem)\n      SocketAuthority.emitter('item_updated', req.libraryItem.toJSONExpanded())\n    }\n\n    res.json({\n      numEpisodesUpdated: episodesUpdated\n    })\n  }\n\n  async updateEpisode(req, res) {\n    const libraryItem = req.libraryItem\n\n    var episodeId = req.params.episodeId\n    if (!libraryItem.media.checkHasEpisode(episodeId)) {\n      return res.status(404).send('Episode not found')\n    }\n\n    if (libraryItem.media.updateEpisode(episodeId, req.body)) {\n      await Database.updateLibraryItem(libraryItem)\n      SocketAuthority.emitter('item_updated', libraryItem.toJSONExpanded())\n    }\n\n    res.json(libraryItem.toJSONExpanded())\n  }\n\n  // GET: api/podcasts/:id/episode/:episodeId\n  async getEpisode(req, res) {\n    const episodeId = req.params.episodeId\n    const libraryItem = req.libraryItem\n\n    const episode = libraryItem.media.episodes.find(ep => ep.id === episodeId)\n    if (!episode) {\n      Logger.error(`[PodcastController] getEpisode episode ${episodeId} not found for item ${libraryItem.id}`)\n      return res.sendStatus(404)\n    }\n\n    res.json(episode)\n  }\n\n  // DELETE: api/podcasts/:id/episode/:episodeId\n  async removeEpisode(req, res) {\n    const episodeId = req.params.episodeId\n    const libraryItem = req.libraryItem\n    const hardDelete = req.query.hard === '1'\n\n    const episode = libraryItem.media.episodes.find(ep => ep.id === episodeId)\n    if (!episode) {\n      Logger.error(`[PodcastController] removeEpisode episode ${episodeId} not found for item ${libraryItem.id}`)\n      return res.sendStatus(404)\n    }\n\n    if (hardDelete) {\n      const audioFile = episode.audioFile\n      // TODO: this will trigger the watcher. should maybe handle this gracefully\n      await fs.remove(audioFile.metadata.path).then(() => {\n        Logger.info(`[PodcastController] Hard deleted episode file at \"${audioFile.metadata.path}\"`)\n      }).catch((error) => {\n        Logger.error(`[PodcastController] Failed to hard delete episode file at \"${audioFile.metadata.path}\"`, error)\n      })\n    }\n\n    // Remove episode from Podcast and library file\n    const episodeRemoved = libraryItem.media.removeEpisode(episodeId)\n    if (episodeRemoved?.audioFile) {\n      libraryItem.removeLibraryFile(episodeRemoved.audioFile.ino)\n    }\n\n    // Update/remove playlists that had this podcast episode\n    const playlistMediaItems = await Database.playlistMediaItemModel.findAll({\n      where: {\n        mediaItemId: episodeId\n      },\n      include: {\n        model: Database.playlistModel,\n        include: Database.playlistMediaItemModel\n      }\n    })\n    for (const pmi of playlistMediaItems) {\n      const numItems = pmi.playlist.playlistMediaItems.length - 1\n\n      if (!numItems) {\n        Logger.info(`[PodcastController] Playlist \"${pmi.playlist.name}\" has no more items - removing it`)\n        const jsonExpanded = await pmi.playlist.getOldJsonExpanded()\n        SocketAuthority.clientEmitter(pmi.playlist.userId, 'playlist_removed', jsonExpanded)\n        await pmi.playlist.destroy()\n      } else {\n        await pmi.destroy()\n        const jsonExpanded = await pmi.playlist.getOldJsonExpanded()\n        SocketAuthority.clientEmitter(pmi.playlist.userId, 'playlist_updated', jsonExpanded)\n      }\n    }\n\n    // Remove media progress for this episode\n    const mediaProgressRemoved = await Database.mediaProgressModel.destroy({\n      where: {\n        mediaItemId: episode.id\n      }\n    })\n    if (mediaProgressRemoved) {\n      Logger.info(`[PodcastController] Removed ${mediaProgressRemoved} media progress for episode ${episode.id}`)\n    }\n\n    await Database.updateLibraryItem(libraryItem)\n    SocketAuthority.emitter('item_updated', libraryItem.toJSONExpanded())\n    res.json(libraryItem.toJSON())\n  }\n\n  async middleware(req, res, next) {\n    const item = await Database.libraryItemModel.getOldById(req.params.id)\n    if (!item?.media) return res.sendStatus(404)\n\n    if (!item.isPodcast) {\n      return res.sendStatus(500)\n    }\n\n    // Check user can access this library item\n    if (!req.user.checkCanAccessLibraryItem(item)) {\n      return res.sendStatus(403)\n    }\n\n    if (req.method == 'DELETE' && !req.user.canDelete) {\n      Logger.warn(`[PodcastController] User attempted to delete without permission`, req.user.username)\n      return res.sendStatus(403)\n    } else if ((req.method == 'PATCH' || req.method == 'POST') && !req.user.canUpdate) {\n      Logger.warn('[PodcastController] User attempted to update without permission', req.user.username)\n      return res.sendStatus(403)\n    }\n\n    req.libraryItem = item\n    next()\n  }\n}\nmodule.exports = new PodcastController()\n", "const Path = require('path')\nconst Logger = require('../Logger')\nconst { parseString } = require(\"xml2js\")\nconst areEquivalent = require('./areEquivalent')\n\nconst levenshteinDistance = (str1, str2, caseSensitive = false) => {\n  str1 = String(str1)\n  str2 = String(str2)\n  if (!caseSensitive) {\n    str1 = str1.toLowerCase()\n    str2 = str2.toLowerCase()\n  }\n  const track = Array(str2.length + 1).fill(null).map(() =>\n    Array(str1.length + 1).fill(null));\n  for (let i = 0; i <= str1.length; i += 1) {\n    track[0][i] = i;\n  }\n  for (let j = 0; j <= str2.length; j += 1) {\n    track[j][0] = j;\n  }\n  for (let j = 1; j <= str2.length; j += 1) {\n    for (let i = 1; i <= str1.length; i += 1) {\n      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      track[j][i] = Math.min(\n        track[j][i - 1] + 1, // deletion\n        track[j - 1][i] + 1, // insertion\n        track[j - 1][i - 1] + indicator, // substitution\n      );\n    }\n  }\n  return track[str2.length][str1.length];\n}\nmodule.exports.levenshteinDistance = levenshteinDistance\n\nmodule.exports.isObject = (val) => {\n  return val !== null && typeof val === 'object'\n}\n\nmodule.exports.comparePaths = (path1, path2) => {\n  return path1 === path2 || Path.normalize(path1) === Path.normalize(path2)\n}\n\nmodule.exports.isNullOrNaN = (num) => {\n  return num === null || isNaN(num)\n}\n\nconst xmlToJSON = (xml) => {\n  return new Promise((resolve, reject) => {\n    parseString(xml, (err, results) => {\n      if (err) {\n        Logger.error(`[xmlToJSON] Error`, err)\n        resolve(null)\n      } else {\n        resolve(results)\n      }\n    })\n  })\n}\nmodule.exports.xmlToJSON = xmlToJSON\n\nmodule.exports.getId = (prepend = '') => {\n  var _id = Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8)\n  if (prepend) return prepend + '_' + _id\n  return _id\n}\n\nfunction elapsedPretty(seconds) {\n  if (seconds > 0 && seconds < 1) {\n    return `${Math.floor(seconds * 1000)} ms`\n  }\n  if (seconds < 60) {\n    return `${Math.floor(seconds)} sec`\n  }\n  var minutes = Math.floor(seconds / 60)\n  if (minutes < 70) {\n    return `${minutes} min`\n  }\n  var hours = Math.floor(minutes / 60)\n  minutes -= hours * 60\n  if (!minutes) {\n    return `${hours} hr`\n  }\n  return `${hours} hr ${minutes} min`\n}\nmodule.exports.elapsedPretty = elapsedPretty\n\nfunction secondsToTimestamp(seconds, includeMs = false, alwaysIncludeHours = false) {\n  var _seconds = seconds\n  var _minutes = Math.floor(seconds / 60)\n  _seconds -= _minutes * 60\n  var _hours = Math.floor(_minutes / 60)\n  _minutes -= _hours * 60\n\n  var ms = _seconds - Math.floor(seconds)\n  _seconds = Math.floor(_seconds)\n\n  var msString = '.' + (includeMs ? ms.toFixed(3) : '0.0').split('.')[1]\n  if (alwaysIncludeHours) {\n    return `${_hours.toString().padStart(2, '0')}:${_minutes.toString().padStart(2, '0')}:${_seconds.toString().padStart(2, '0')}${msString}`\n  }\n  if (!_hours) {\n    return `${_minutes}:${_seconds.toString().padStart(2, '0')}${msString}`\n  }\n  return `${_hours}:${_minutes.toString().padStart(2, '0')}:${_seconds.toString().padStart(2, '0')}${msString}`\n}\nmodule.exports.secondsToTimestamp = secondsToTimestamp\n\nmodule.exports.reqSupportsWebp = (req) => {\n  if (!req || !req.headers || !req.headers.accept) return false\n  return req.headers.accept.includes('image/webp') || req.headers.accept === '*/*'\n}\n\nmodule.exports.areEquivalent = areEquivalent\n\nmodule.exports.copyValue = (val) => {\n  if (!val) return val === false ? false : null\n  if (!this.isObject(val)) return val\n\n  if (Array.isArray(val)) {\n    return val.map(this.copyValue)\n  } else {\n    var final = {}\n    for (const key in val) {\n      final[key] = this.copyValue(val[key])\n    }\n    return final\n  }\n}\n\nmodule.exports.toNumber = (val, fallback = 0) => {\n  if (isNaN(val) || val === null) return fallback\n  return Number(val)\n}\n\nmodule.exports.cleanStringForSearch = (str) => {\n  if (!str) return ''\n  // Remove ' . ` \" ,\n  return str.toLowerCase().replace(/[\\'\\.\\`\\\",]/g, '').trim()\n}\n\nconst getTitleParts = (title) => {\n  if (!title) return ['', null]\n  const prefixesToIgnore = global.ServerSettings.sortingPrefixes || []\n  for (const prefix of prefixesToIgnore) {\n    // e.g. for prefix \"the\". If title is \"The Book\" return \"Book, The\"\n    if (title.toLowerCase().startsWith(`${prefix} `)) {\n      return [title.substr(prefix.length + 1), `${prefix.substr(0, 1).toUpperCase() + prefix.substr(1)}`]\n    }\n  }\n  return [title, null]\n}\n\n/**\n * Remove sortingPrefixes from title\n * @example \"The Good Book\" => \"Good Book\"\n * @param {string} title \n * @returns {string}\n */\nmodule.exports.getTitleIgnorePrefix = (title) => {\n  return getTitleParts(title)[0]\n}\n\n/**\n * Put sorting prefix at the end of title \n * @example \"The Good Book\" => \"Good Book, The\"\n * @param {string} title \n * @returns {string}\n */\nmodule.exports.getTitlePrefixAtEnd = (title) => {\n  let [sort, prefix] = getTitleParts(title)\n  return prefix ? `${sort}, ${prefix}` : title\n}\n\n/**\n * to lower case for only ascii characters\n * used to handle sqlite that doesnt support unicode lower\n * @see https://github.com/advplyr/audiobookshelf/issues/2187\n * \n * @param {string} str \n * @returns {string}\n */\nmodule.exports.asciiOnlyToLowerCase = (str) => {\n  if (!str) return ''\n\n  let temp = ''\n  for (let chars of str) {\n    let value = chars.charCodeAt()\n    if (value >= 65 && value <= 90) {\n      temp += String.fromCharCode(value + 32)\n    } else {\n      temp += chars\n    }\n  }\n  return temp\n}\n\n/**\n * Escape string used in RegExp\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n * \n * @param {string} str \n * @returns {string}\n */\nmodule.exports.escapeRegExp = (str) => {\n  if (typeof str !== 'string') return ''\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}", "const Logger = require('../Logger')\nconst axios = require('axios')\nconst { xmlToJSON, levenshteinDistance } = require('./index')\nconst htmlSanitizer = require('../utils/htmlSanitizer')\n\nfunction extractFirstArrayItem(json, key) {\n  if (!json[key]?.length) return null\n  return json[key][0]\n}\n\nfunction extractImage(channel) {\n  if (!channel.image || !channel.image.url || !channel.image.url.length) {\n    if (!channel['itunes:image'] || !channel['itunes:image'].length || !channel['itunes:image'][0]['$']) {\n      return null\n    }\n    var itunesImage = channel['itunes:image'][0]['$']\n    return itunesImage.href || null\n  }\n  return channel.image.url[0] || null\n}\n\nfunction extractCategories(channel) {\n  if (!channel['itunes:category'] || !channel['itunes:category'].length) return []\n  var categories = channel['itunes:category']\n  var cleanedCats = []\n  categories.forEach((cat) => {\n    if (!cat['$'] || !cat['$'].text) return\n    var cattext = cat['$'].text\n    if (cat['itunes:category']) {\n      var subcats = extractCategories(cat)\n      if (subcats.length) {\n        cleanedCats = cleanedCats.concat(subcats.map((subcat) => `${cattext}:${subcat}`))\n      } else {\n        cleanedCats.push(cattext)\n      }\n    } else {\n      cleanedCats.push(cattext)\n    }\n  })\n  return cleanedCats\n}\n\nfunction extractPodcastMetadata(channel) {\n  const metadata = {\n    image: extractImage(channel),\n    categories: extractCategories(channel),\n    feedUrl: null,\n    description: null,\n    descriptionPlain: null,\n    type: null\n  }\n\n  if (channel['itunes:new-feed-url']) {\n    metadata.feedUrl = extractFirstArrayItem(channel, 'itunes:new-feed-url')\n  } else if (channel['atom:link'] && channel['atom:link'].length && channel['atom:link'][0]['$']) {\n    metadata.feedUrl = channel['atom:link'][0]['$'].href || null\n  }\n\n  if (channel['description']) {\n    const rawDescription = extractFirstArrayItem(channel, 'description') || ''\n    metadata.description = htmlSanitizer.sanitize(rawDescription)\n    metadata.descriptionPlain = htmlSanitizer.stripAllTags(rawDescription)\n  }\n\n  const arrayFields = ['title', 'language', 'itunes:explicit', 'itunes:author', 'pubDate', 'link', 'itunes:type']\n  arrayFields.forEach((key) => {\n    const cleanKey = key.split(':').pop()\n    let value = extractFirstArrayItem(channel, key)\n    if (value?.['_']) value = value['_']\n    metadata[cleanKey] = value\n  })\n  return metadata\n}\n\nfunction extractEpisodeData(item) {\n  // Episode must have url\n  if (!item.enclosure?.[0]?.['$']?.url) {\n    Logger.error(`[podcastUtils] Invalid podcast episode data`)\n    return null\n  }\n\n  const episode = {\n    enclosure: {\n      ...item.enclosure[0]['$']\n    }\n  }\n\n  episode.enclosure.url = episode.enclosure.url.trim()\n\n  // Full description with html\n  if (item['content:encoded']) {\n    const rawDescription = (extractFirstArrayItem(item, 'content:encoded') || '').trim()\n    episode.description = htmlSanitizer.sanitize(rawDescription)\n  }\n\n  // Extract chapters\n  if (item['podcast:chapters']?.[0]?.['$']?.url) {\n    episode.chaptersUrl = item['podcast:chapters'][0]['$'].url\n    episode.chaptersType = item['podcast:chapters'][0]['$'].type || 'application/json'\n  }\n\n  // Supposed to be the plaintext description but not always followed\n  if (item['description']) {\n    const rawDescription = extractFirstArrayItem(item, 'description') || ''\n    if (!episode.description) episode.description = htmlSanitizer.sanitize(rawDescription)\n    episode.descriptionPlain = htmlSanitizer.stripAllTags(rawDescription)\n  }\n\n  if (item['pubDate']) {\n    const pubDate = extractFirstArrayItem(item, 'pubDate')\n    if (typeof pubDate === 'string') {\n      episode.pubDate = pubDate\n    } else if (typeof pubDate?._ === 'string') {\n      episode.pubDate = pubDate._\n    } else {\n      Logger.error(`[podcastUtils] Invalid pubDate ${item['pubDate']} for ${episode.enclosure.url}`)\n    }\n  }\n\n  if (item['guid']) {\n    const guidItem = extractFirstArrayItem(item, 'guid')\n    if (typeof guidItem === 'string') {\n      episode.guid = guidItem\n    } else if (typeof guidItem?._ === 'string') {\n      episode.guid = guidItem._\n    } else {\n      Logger.error(`[podcastUtils] Invalid guid ${item['guid']} for ${episode.enclosure.url}`)\n    }\n  }\n\n  const arrayFields = ['title', 'itunes:episodeType', 'itunes:season', 'itunes:episode', 'itunes:author', 'itunes:duration', 'itunes:explicit', 'itunes:subtitle']\n  arrayFields.forEach((key) => {\n    const cleanKey = key.split(':').pop()\n    let value = extractFirstArrayItem(item, key)\n    if (value?.['_']) value = value['_']\n    episode[cleanKey] = value\n  })\n  return episode\n}\n\nfunction cleanEpisodeData(data) {\n  const pubJsDate = data.pubDate ? new Date(data.pubDate) : null\n  const publishedAt = pubJsDate && !isNaN(pubJsDate) ? pubJsDate.valueOf() : null\n  return {\n    title: data.title,\n    subtitle: data.subtitle || '',\n    description: data.description || '',\n    descriptionPlain: data.descriptionPlain || '',\n    pubDate: data.pubDate || '',\n    episodeType: data.episodeType || '',\n    season: data.season || '',\n    episode: data.episode || '',\n    author: data.author || '',\n    duration: data.duration || '',\n    explicit: data.explicit || '',\n    publishedAt,\n    enclosure: data.enclosure,\n    guid: data.guid || null,\n    chaptersUrl: data.chaptersUrl || null,\n    chaptersType: data.chaptersType || null\n  }\n}\n\nfunction extractPodcastEpisodes(items) {\n  const episodes = []\n  items.forEach((item) => {\n    const extracted = extractEpisodeData(item)\n    if (extracted) {\n      episodes.push(cleanEpisodeData(extracted))\n    }\n  })\n  return episodes\n}\n\nfunction cleanPodcastJson(rssJson, excludeEpisodeMetadata) {\n  if (!rssJson.channel?.length) {\n    Logger.error(`[podcastUtil] Invalid podcast no channel object`)\n    return null\n  }\n  const channel = rssJson.channel[0]\n  if (!channel.item?.length) {\n    Logger.error(`[podcastUtil] Invalid podcast no episodes`)\n    return null\n  }\n  const podcast = {\n    metadata: extractPodcastMetadata(channel)\n  }\n  if (!excludeEpisodeMetadata) {\n    podcast.episodes = extractPodcastEpisodes(channel.item)\n  } else {\n    podcast.numEpisodes = channel.item.length\n  }\n  return podcast\n}\n\nmodule.exports.parsePodcastRssFeedXml = async (xml, excludeEpisodeMetadata = false, includeRaw = false) => {\n  if (!xml) return null\n  const json = await xmlToJSON(xml)\n  if (!json?.rss) {\n    Logger.error('[podcastUtils] Invalid XML or RSS feed')\n    return null\n  }\n\n  const podcast = cleanPodcastJson(json.rss, excludeEpisodeMetadata)\n  if (!podcast) return null\n\n  if (includeRaw) {\n    return {\n      podcast,\n      rawJson: json\n    }\n  } else {\n    return {\n      podcast\n    }\n  }\n}\n\nmodule.exports.getPodcastFeed = (feedUrl, excludeEpisodeMetadata = false) => {\n  Logger.debug(`[podcastUtils] getPodcastFeed for \"${feedUrl}\"`)\n  return axios.get(feedUrl, { timeout: 12000, responseType: 'arraybuffer', headers: { Accept: 'application/rss+xml' } }).then(async (data) => {\n\n    // Adding support for ios-8859-1 encoded RSS feeds.\n    //  See: https://github.com/advplyr/audiobookshelf/issues/1489\n    const contentType = data.headers?.['content-type'] || '' // e.g. text/xml; charset=iso-8859-1\n    if (contentType.toLowerCase().includes('iso-8859-1')) {\n      data.data = data.data.toString('latin1')\n    } else {\n      data.data = data.data.toString()\n    }\n\n    if (!data?.data) {\n      Logger.error(`[podcastUtils] getPodcastFeed: Invalid podcast feed request response (${feedUrl})`)\n      return false\n    }\n    Logger.debug(`[podcastUtils] getPodcastFeed for \"${feedUrl}\" success - parsing xml`)\n    const payload = await this.parsePodcastRssFeedXml(data.data, excludeEpisodeMetadata)\n    if (!payload) {\n      return false\n    }\n\n    // RSS feed may be a private RSS feed\n    payload.podcast.metadata.feedUrl = feedUrl\n\n    return payload.podcast\n  }).catch((error) => {\n    Logger.error('[podcastUtils] getPodcastFeed Error', error)\n    return false\n  })\n}\n\n// Return array of episodes ordered by closest match (Levenshtein distance of 6 or less)\nmodule.exports.findMatchingEpisodes = async (feedUrl, searchTitle) => {\n  const feed = await this.getPodcastFeed(feedUrl).catch(() => {\n    return null\n  })\n\n  return this.findMatchingEpisodesInFeed(feed, searchTitle)\n}\n\nmodule.exports.findMatchingEpisodesInFeed = (feed, searchTitle) => {\n  searchTitle = searchTitle.toLowerCase().trim()\n  if (!feed?.episodes) {\n    return null\n  }\n\n  const matches = []\n  feed.episodes.forEach(ep => {\n    if (!ep.title) return\n\n    const epTitle = ep.title.toLowerCase().trim()\n    if (epTitle === searchTitle) {\n      matches.push({\n        episode: ep,\n        levenshtein: 0\n      })\n    } else {\n      const levenshtein = levenshteinDistance(searchTitle, epTitle, true)\n      if (levenshtein <= 6 && epTitle.length > levenshtein) {\n        matches.push({\n          episode: ep,\n          levenshtein\n        })\n      }\n    }\n  })\n  return matches.sort((a, b) => a.levenshtein - b.levenshtein)\n}\n"], "fixing_code": ["const Logger = require('../Logger')\nconst SocketAuthority = require('../SocketAuthority')\nconst Database = require('../Database')\n\nconst fs = require('../libs/fsExtra')\n\nconst { getPodcastFeed, findMatchingEpisodes } = require('../utils/podcastUtils')\nconst { getFileTimestampsWithIno, filePathToPOSIX } = require('../utils/fileUtils')\nconst { validateUrl } = require('../utils/index')\n\nconst Scanner = require('../scanner/Scanner')\nconst CoverManager = require('../managers/CoverManager')\n\nconst LibraryItem = require('../objects/LibraryItem')\n\nclass PodcastController {\n\n  async create(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to create podcast`)\n      return res.sendStatus(403)\n    }\n    const payload = req.body\n\n    const library = await Database.libraryModel.getOldById(payload.libraryId)\n    if (!library) {\n      Logger.error(`[PodcastController] Create: Library not found \"${payload.libraryId}\"`)\n      return res.status(404).send('Library not found')\n    }\n\n    const folder = library.folders.find(fold => fold.id === payload.folderId)\n    if (!folder) {\n      Logger.error(`[PodcastController] Create: Folder not found \"${payload.folderId}\"`)\n      return res.status(404).send('Folder not found')\n    }\n\n    const podcastPath = filePathToPOSIX(payload.path)\n\n    // Check if a library item with this podcast folder exists already\n    const existingLibraryItem = (await Database.libraryItemModel.count({\n      where: {\n        path: podcastPath\n      }\n    })) > 0\n    if (existingLibraryItem) {\n      Logger.error(`[PodcastController] Podcast already exists at path \"${podcastPath}\"`)\n      return res.status(400).send('Podcast already exists')\n    }\n\n    const success = await fs.ensureDir(podcastPath).then(() => true).catch((error) => {\n      Logger.error(`[PodcastController] Failed to ensure podcast dir \"${podcastPath}\"`, error)\n      return false\n    })\n    if (!success) return res.status(400).send('Invalid podcast path')\n\n    const libraryItemFolderStats = await getFileTimestampsWithIno(podcastPath)\n\n    let relPath = payload.path.replace(folder.fullPath, '')\n    if (relPath.startsWith('/')) relPath = relPath.slice(1)\n\n    const libraryItemPayload = {\n      path: podcastPath,\n      relPath,\n      folderId: payload.folderId,\n      libraryId: payload.libraryId,\n      ino: libraryItemFolderStats.ino,\n      mtimeMs: libraryItemFolderStats.mtimeMs || 0,\n      ctimeMs: libraryItemFolderStats.ctimeMs || 0,\n      birthtimeMs: libraryItemFolderStats.birthtimeMs || 0,\n      media: payload.media\n    }\n\n    const libraryItem = new LibraryItem()\n    libraryItem.setData('podcast', libraryItemPayload)\n\n    // Download and save cover image\n    if (payload.media.metadata.imageUrl) {\n      // TODO: Scan cover image to library files\n      // Podcast cover will always go into library item folder\n      const coverResponse = await CoverManager.downloadCoverFromUrl(libraryItem, payload.media.metadata.imageUrl, true)\n      if (coverResponse) {\n        if (coverResponse.error) {\n          Logger.error(`[PodcastController] Download cover error from \"${payload.media.metadata.imageUrl}\": ${coverResponse.error}`)\n        } else if (coverResponse.cover) {\n          libraryItem.media.coverPath = coverResponse.cover\n        }\n      }\n    }\n\n    await Database.createLibraryItem(libraryItem)\n    SocketAuthority.emitter('item_added', libraryItem.toJSONExpanded())\n\n    res.json(libraryItem.toJSONExpanded())\n\n    if (payload.episodesToDownload?.length) {\n      Logger.info(`[PodcastController] Podcast created now starting ${payload.episodesToDownload.length} episode downloads`)\n      this.podcastManager.downloadPodcastEpisodes(libraryItem, payload.episodesToDownload)\n    }\n\n    // Turn on podcast auto download cron if not already on\n    if (libraryItem.media.autoDownloadEpisodes) {\n      this.cronManager.checkUpdatePodcastCron(libraryItem)\n    }\n  }\n\n  /**\n   * POST: /api/podcasts/feed\n   * \n   * @typedef getPodcastFeedReqBody\n   * @property {string} rssFeed\n   * \n   * @param {import('express').Request<{}, {}, getPodcastFeedReqBody, {}} req \n   * @param {import('express').Response} res \n   */\n  async getPodcastFeed(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to get podcast feed`)\n      return res.sendStatus(403)\n    }\n\n    const url = validateUrl(req.body.rssFeed)\n    if (!url) {\n      return res.status(400).send('Invalid request body. \"rssFeed\" must be a valid URL')\n    }\n\n    const podcast = await getPodcastFeed(url)\n    if (!podcast) {\n      return res.status(404).send('Podcast RSS feed request failed or invalid response data')\n    }\n    res.json({ podcast })\n  }\n\n  async getFeedsFromOPMLText(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user \"${req.user.username}\" attempted to get feeds from opml`)\n      return res.sendStatus(403)\n    }\n\n    if (!req.body.opmlText) {\n      return res.sendStatus(400)\n    }\n\n    const rssFeedsData = await this.podcastManager.getOPMLFeeds(req.body.opmlText)\n    res.json(rssFeedsData)\n  }\n\n  async checkNewEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to check/download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n\n    var libraryItem = req.libraryItem\n    if (!libraryItem.media.metadata.feedUrl) {\n      Logger.error(`[PodcastController] checkNewEpisodes no feed url for item ${libraryItem.id}`)\n      return res.status(500).send('Podcast has no rss feed url')\n    }\n\n    const maxEpisodesToDownload = !isNaN(req.query.limit) ? Number(req.query.limit) : 3\n\n    var newEpisodes = await this.podcastManager.checkAndDownloadNewEpisodes(libraryItem, maxEpisodesToDownload)\n    res.json({\n      episodes: newEpisodes || []\n    })\n  }\n\n  clearEpisodeDownloadQueue(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempting to clear download queue \"${req.user.username}\"`)\n      return res.sendStatus(403)\n    }\n    this.podcastManager.clearDownloadQueue(req.params.id)\n    res.sendStatus(200)\n  }\n\n  getEpisodeDownloads(req, res) {\n    var libraryItem = req.libraryItem\n\n    var downloadsInQueue = this.podcastManager.getEpisodeDownloadsInQueue(libraryItem.id)\n    res.json({\n      downloads: downloadsInQueue.map(d => d.toJSONForClient())\n    })\n  }\n\n  async findEpisode(req, res) {\n    const rssFeedUrl = req.libraryItem.media.metadata.feedUrl\n    if (!rssFeedUrl) {\n      Logger.error(`[PodcastController] findEpisode: Podcast has no feed url`)\n      return res.status(500).send('Podcast does not have an RSS feed URL')\n    }\n\n    var searchTitle = req.query.title\n    if (!searchTitle) {\n      return res.sendStatus(500)\n    }\n    const episodes = await findMatchingEpisodes(rssFeedUrl, searchTitle)\n    res.json({\n      episodes: episodes || []\n    })\n  }\n\n  async downloadEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n    const libraryItem = req.libraryItem\n    const episodes = req.body\n    if (!episodes?.length) {\n      return res.sendStatus(400)\n    }\n\n    this.podcastManager.downloadPodcastEpisodes(libraryItem, episodes)\n    res.sendStatus(200)\n  }\n\n  // POST: api/podcasts/:id/match-episodes\n  async quickMatchEpisodes(req, res) {\n    if (!req.user.isAdminOrUp) {\n      Logger.error(`[PodcastController] Non-admin user attempted to download episodes`, req.user)\n      return res.sendStatus(403)\n    }\n\n    const overrideDetails = req.query.override === '1'\n    const episodesUpdated = await Scanner.quickMatchPodcastEpisodes(req.libraryItem, { overrideDetails })\n    if (episodesUpdated) {\n      await Database.updateLibraryItem(req.libraryItem)\n      SocketAuthority.emitter('item_updated', req.libraryItem.toJSONExpanded())\n    }\n\n    res.json({\n      numEpisodesUpdated: episodesUpdated\n    })\n  }\n\n  async updateEpisode(req, res) {\n    const libraryItem = req.libraryItem\n\n    var episodeId = req.params.episodeId\n    if (!libraryItem.media.checkHasEpisode(episodeId)) {\n      return res.status(404).send('Episode not found')\n    }\n\n    if (libraryItem.media.updateEpisode(episodeId, req.body)) {\n      await Database.updateLibraryItem(libraryItem)\n      SocketAuthority.emitter('item_updated', libraryItem.toJSONExpanded())\n    }\n\n    res.json(libraryItem.toJSONExpanded())\n  }\n\n  // GET: api/podcasts/:id/episode/:episodeId\n  async getEpisode(req, res) {\n    const episodeId = req.params.episodeId\n    const libraryItem = req.libraryItem\n\n    const episode = libraryItem.media.episodes.find(ep => ep.id === episodeId)\n    if (!episode) {\n      Logger.error(`[PodcastController] getEpisode episode ${episodeId} not found for item ${libraryItem.id}`)\n      return res.sendStatus(404)\n    }\n\n    res.json(episode)\n  }\n\n  // DELETE: api/podcasts/:id/episode/:episodeId\n  async removeEpisode(req, res) {\n    const episodeId = req.params.episodeId\n    const libraryItem = req.libraryItem\n    const hardDelete = req.query.hard === '1'\n\n    const episode = libraryItem.media.episodes.find(ep => ep.id === episodeId)\n    if (!episode) {\n      Logger.error(`[PodcastController] removeEpisode episode ${episodeId} not found for item ${libraryItem.id}`)\n      return res.sendStatus(404)\n    }\n\n    if (hardDelete) {\n      const audioFile = episode.audioFile\n      // TODO: this will trigger the watcher. should maybe handle this gracefully\n      await fs.remove(audioFile.metadata.path).then(() => {\n        Logger.info(`[PodcastController] Hard deleted episode file at \"${audioFile.metadata.path}\"`)\n      }).catch((error) => {\n        Logger.error(`[PodcastController] Failed to hard delete episode file at \"${audioFile.metadata.path}\"`, error)\n      })\n    }\n\n    // Remove episode from Podcast and library file\n    const episodeRemoved = libraryItem.media.removeEpisode(episodeId)\n    if (episodeRemoved?.audioFile) {\n      libraryItem.removeLibraryFile(episodeRemoved.audioFile.ino)\n    }\n\n    // Update/remove playlists that had this podcast episode\n    const playlistMediaItems = await Database.playlistMediaItemModel.findAll({\n      where: {\n        mediaItemId: episodeId\n      },\n      include: {\n        model: Database.playlistModel,\n        include: Database.playlistMediaItemModel\n      }\n    })\n    for (const pmi of playlistMediaItems) {\n      const numItems = pmi.playlist.playlistMediaItems.length - 1\n\n      if (!numItems) {\n        Logger.info(`[PodcastController] Playlist \"${pmi.playlist.name}\" has no more items - removing it`)\n        const jsonExpanded = await pmi.playlist.getOldJsonExpanded()\n        SocketAuthority.clientEmitter(pmi.playlist.userId, 'playlist_removed', jsonExpanded)\n        await pmi.playlist.destroy()\n      } else {\n        await pmi.destroy()\n        const jsonExpanded = await pmi.playlist.getOldJsonExpanded()\n        SocketAuthority.clientEmitter(pmi.playlist.userId, 'playlist_updated', jsonExpanded)\n      }\n    }\n\n    // Remove media progress for this episode\n    const mediaProgressRemoved = await Database.mediaProgressModel.destroy({\n      where: {\n        mediaItemId: episode.id\n      }\n    })\n    if (mediaProgressRemoved) {\n      Logger.info(`[PodcastController] Removed ${mediaProgressRemoved} media progress for episode ${episode.id}`)\n    }\n\n    await Database.updateLibraryItem(libraryItem)\n    SocketAuthority.emitter('item_updated', libraryItem.toJSONExpanded())\n    res.json(libraryItem.toJSON())\n  }\n\n  async middleware(req, res, next) {\n    const item = await Database.libraryItemModel.getOldById(req.params.id)\n    if (!item?.media) return res.sendStatus(404)\n\n    if (!item.isPodcast) {\n      return res.sendStatus(500)\n    }\n\n    // Check user can access this library item\n    if (!req.user.checkCanAccessLibraryItem(item)) {\n      return res.sendStatus(403)\n    }\n\n    if (req.method == 'DELETE' && !req.user.canDelete) {\n      Logger.warn(`[PodcastController] User attempted to delete without permission`, req.user.username)\n      return res.sendStatus(403)\n    } else if ((req.method == 'PATCH' || req.method == 'POST') && !req.user.canUpdate) {\n      Logger.warn('[PodcastController] User attempted to update without permission', req.user.username)\n      return res.sendStatus(403)\n    }\n\n    req.libraryItem = item\n    next()\n  }\n}\nmodule.exports = new PodcastController()\n", "const Path = require('path')\nconst Logger = require('../Logger')\nconst { parseString } = require(\"xml2js\")\nconst areEquivalent = require('./areEquivalent')\n\nconst levenshteinDistance = (str1, str2, caseSensitive = false) => {\n  str1 = String(str1)\n  str2 = String(str2)\n  if (!caseSensitive) {\n    str1 = str1.toLowerCase()\n    str2 = str2.toLowerCase()\n  }\n  const track = Array(str2.length + 1).fill(null).map(() =>\n    Array(str1.length + 1).fill(null))\n  for (let i = 0; i <= str1.length; i += 1) {\n    track[0][i] = i\n  }\n  for (let j = 0; j <= str2.length; j += 1) {\n    track[j][0] = j\n  }\n  for (let j = 1; j <= str2.length; j += 1) {\n    for (let i = 1; i <= str1.length; i += 1) {\n      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1\n      track[j][i] = Math.min(\n        track[j][i - 1] + 1, // deletion\n        track[j - 1][i] + 1, // insertion\n        track[j - 1][i - 1] + indicator, // substitution\n      )\n    }\n  }\n  return track[str2.length][str1.length]\n}\nmodule.exports.levenshteinDistance = levenshteinDistance\n\nmodule.exports.isObject = (val) => {\n  return val !== null && typeof val === 'object'\n}\n\nmodule.exports.comparePaths = (path1, path2) => {\n  return path1 === path2 || Path.normalize(path1) === Path.normalize(path2)\n}\n\nmodule.exports.isNullOrNaN = (num) => {\n  return num === null || isNaN(num)\n}\n\nconst xmlToJSON = (xml) => {\n  return new Promise((resolve, reject) => {\n    parseString(xml, (err, results) => {\n      if (err) {\n        Logger.error(`[xmlToJSON] Error`, err)\n        resolve(null)\n      } else {\n        resolve(results)\n      }\n    })\n  })\n}\nmodule.exports.xmlToJSON = xmlToJSON\n\nmodule.exports.getId = (prepend = '') => {\n  var _id = Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8)\n  if (prepend) return prepend + '_' + _id\n  return _id\n}\n\nfunction elapsedPretty(seconds) {\n  if (seconds > 0 && seconds < 1) {\n    return `${Math.floor(seconds * 1000)} ms`\n  }\n  if (seconds < 60) {\n    return `${Math.floor(seconds)} sec`\n  }\n  var minutes = Math.floor(seconds / 60)\n  if (minutes < 70) {\n    return `${minutes} min`\n  }\n  var hours = Math.floor(minutes / 60)\n  minutes -= hours * 60\n  if (!minutes) {\n    return `${hours} hr`\n  }\n  return `${hours} hr ${minutes} min`\n}\nmodule.exports.elapsedPretty = elapsedPretty\n\nfunction secondsToTimestamp(seconds, includeMs = false, alwaysIncludeHours = false) {\n  var _seconds = seconds\n  var _minutes = Math.floor(seconds / 60)\n  _seconds -= _minutes * 60\n  var _hours = Math.floor(_minutes / 60)\n  _minutes -= _hours * 60\n\n  var ms = _seconds - Math.floor(seconds)\n  _seconds = Math.floor(_seconds)\n\n  var msString = '.' + (includeMs ? ms.toFixed(3) : '0.0').split('.')[1]\n  if (alwaysIncludeHours) {\n    return `${_hours.toString().padStart(2, '0')}:${_minutes.toString().padStart(2, '0')}:${_seconds.toString().padStart(2, '0')}${msString}`\n  }\n  if (!_hours) {\n    return `${_minutes}:${_seconds.toString().padStart(2, '0')}${msString}`\n  }\n  return `${_hours}:${_minutes.toString().padStart(2, '0')}:${_seconds.toString().padStart(2, '0')}${msString}`\n}\nmodule.exports.secondsToTimestamp = secondsToTimestamp\n\nmodule.exports.reqSupportsWebp = (req) => {\n  if (!req || !req.headers || !req.headers.accept) return false\n  return req.headers.accept.includes('image/webp') || req.headers.accept === '*/*'\n}\n\nmodule.exports.areEquivalent = areEquivalent\n\nmodule.exports.copyValue = (val) => {\n  if (!val) return val === false ? false : null\n  if (!this.isObject(val)) return val\n\n  if (Array.isArray(val)) {\n    return val.map(this.copyValue)\n  } else {\n    var final = {}\n    for (const key in val) {\n      final[key] = this.copyValue(val[key])\n    }\n    return final\n  }\n}\n\nmodule.exports.toNumber = (val, fallback = 0) => {\n  if (isNaN(val) || val === null) return fallback\n  return Number(val)\n}\n\nmodule.exports.cleanStringForSearch = (str) => {\n  if (!str) return ''\n  // Remove ' . ` \" ,\n  return str.toLowerCase().replace(/[\\'\\.\\`\\\",]/g, '').trim()\n}\n\nconst getTitleParts = (title) => {\n  if (!title) return ['', null]\n  const prefixesToIgnore = global.ServerSettings.sortingPrefixes || []\n  for (const prefix of prefixesToIgnore) {\n    // e.g. for prefix \"the\". If title is \"The Book\" return \"Book, The\"\n    if (title.toLowerCase().startsWith(`${prefix} `)) {\n      return [title.substr(prefix.length + 1), `${prefix.substr(0, 1).toUpperCase() + prefix.substr(1)}`]\n    }\n  }\n  return [title, null]\n}\n\n/**\n * Remove sortingPrefixes from title\n * @example \"The Good Book\" => \"Good Book\"\n * @param {string} title \n * @returns {string}\n */\nmodule.exports.getTitleIgnorePrefix = (title) => {\n  return getTitleParts(title)[0]\n}\n\n/**\n * Put sorting prefix at the end of title \n * @example \"The Good Book\" => \"Good Book, The\"\n * @param {string} title \n * @returns {string}\n */\nmodule.exports.getTitlePrefixAtEnd = (title) => {\n  let [sort, prefix] = getTitleParts(title)\n  return prefix ? `${sort}, ${prefix}` : title\n}\n\n/**\n * to lower case for only ascii characters\n * used to handle sqlite that doesnt support unicode lower\n * @see https://github.com/advplyr/audiobookshelf/issues/2187\n * \n * @param {string} str \n * @returns {string}\n */\nmodule.exports.asciiOnlyToLowerCase = (str) => {\n  if (!str) return ''\n\n  let temp = ''\n  for (let chars of str) {\n    let value = chars.charCodeAt()\n    if (value >= 65 && value <= 90) {\n      temp += String.fromCharCode(value + 32)\n    } else {\n      temp += chars\n    }\n  }\n  return temp\n}\n\n/**\n * Escape string used in RegExp\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n * \n * @param {string} str \n * @returns {string}\n */\nmodule.exports.escapeRegExp = (str) => {\n  if (typeof str !== 'string') return ''\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\n/**\n * Validate url string with URL class\n * \n * @param {string} rawUrl \n * @returns {string} null if invalid\n */\nmodule.exports.validateUrl = (rawUrl) => {\n  if (!rawUrl || typeof rawUrl !== 'string') return null\n  try {\n    return new URL(rawUrl).toString()\n  } catch (error) {\n    Logger.error(`Invalid URL \"${rawUrl}\"`, error)\n    return null\n  }\n}", "const axios = require('axios')\nconst ssrfFilter = require('ssrf-req-filter')\nconst Logger = require('../Logger')\nconst { xmlToJSON, levenshteinDistance } = require('./index')\nconst htmlSanitizer = require('../utils/htmlSanitizer')\n\nfunction extractFirstArrayItem(json, key) {\n  if (!json[key]?.length) return null\n  return json[key][0]\n}\n\nfunction extractImage(channel) {\n  if (!channel.image || !channel.image.url || !channel.image.url.length) {\n    if (!channel['itunes:image'] || !channel['itunes:image'].length || !channel['itunes:image'][0]['$']) {\n      return null\n    }\n    var itunesImage = channel['itunes:image'][0]['$']\n    return itunesImage.href || null\n  }\n  return channel.image.url[0] || null\n}\n\nfunction extractCategories(channel) {\n  if (!channel['itunes:category'] || !channel['itunes:category'].length) return []\n  var categories = channel['itunes:category']\n  var cleanedCats = []\n  categories.forEach((cat) => {\n    if (!cat['$'] || !cat['$'].text) return\n    var cattext = cat['$'].text\n    if (cat['itunes:category']) {\n      var subcats = extractCategories(cat)\n      if (subcats.length) {\n        cleanedCats = cleanedCats.concat(subcats.map((subcat) => `${cattext}:${subcat}`))\n      } else {\n        cleanedCats.push(cattext)\n      }\n    } else {\n      cleanedCats.push(cattext)\n    }\n  })\n  return cleanedCats\n}\n\nfunction extractPodcastMetadata(channel) {\n  const metadata = {\n    image: extractImage(channel),\n    categories: extractCategories(channel),\n    feedUrl: null,\n    description: null,\n    descriptionPlain: null,\n    type: null\n  }\n\n  if (channel['itunes:new-feed-url']) {\n    metadata.feedUrl = extractFirstArrayItem(channel, 'itunes:new-feed-url')\n  } else if (channel['atom:link'] && channel['atom:link'].length && channel['atom:link'][0]['$']) {\n    metadata.feedUrl = channel['atom:link'][0]['$'].href || null\n  }\n\n  if (channel['description']) {\n    const rawDescription = extractFirstArrayItem(channel, 'description') || ''\n    metadata.description = htmlSanitizer.sanitize(rawDescription)\n    metadata.descriptionPlain = htmlSanitizer.stripAllTags(rawDescription)\n  }\n\n  const arrayFields = ['title', 'language', 'itunes:explicit', 'itunes:author', 'pubDate', 'link', 'itunes:type']\n  arrayFields.forEach((key) => {\n    const cleanKey = key.split(':').pop()\n    let value = extractFirstArrayItem(channel, key)\n    if (value?.['_']) value = value['_']\n    metadata[cleanKey] = value\n  })\n  return metadata\n}\n\nfunction extractEpisodeData(item) {\n  // Episode must have url\n  if (!item.enclosure?.[0]?.['$']?.url) {\n    Logger.error(`[podcastUtils] Invalid podcast episode data`)\n    return null\n  }\n\n  const episode = {\n    enclosure: {\n      ...item.enclosure[0]['$']\n    }\n  }\n\n  episode.enclosure.url = episode.enclosure.url.trim()\n\n  // Full description with html\n  if (item['content:encoded']) {\n    const rawDescription = (extractFirstArrayItem(item, 'content:encoded') || '').trim()\n    episode.description = htmlSanitizer.sanitize(rawDescription)\n  }\n\n  // Extract chapters\n  if (item['podcast:chapters']?.[0]?.['$']?.url) {\n    episode.chaptersUrl = item['podcast:chapters'][0]['$'].url\n    episode.chaptersType = item['podcast:chapters'][0]['$'].type || 'application/json'\n  }\n\n  // Supposed to be the plaintext description but not always followed\n  if (item['description']) {\n    const rawDescription = extractFirstArrayItem(item, 'description') || ''\n    if (!episode.description) episode.description = htmlSanitizer.sanitize(rawDescription)\n    episode.descriptionPlain = htmlSanitizer.stripAllTags(rawDescription)\n  }\n\n  if (item['pubDate']) {\n    const pubDate = extractFirstArrayItem(item, 'pubDate')\n    if (typeof pubDate === 'string') {\n      episode.pubDate = pubDate\n    } else if (typeof pubDate?._ === 'string') {\n      episode.pubDate = pubDate._\n    } else {\n      Logger.error(`[podcastUtils] Invalid pubDate ${item['pubDate']} for ${episode.enclosure.url}`)\n    }\n  }\n\n  if (item['guid']) {\n    const guidItem = extractFirstArrayItem(item, 'guid')\n    if (typeof guidItem === 'string') {\n      episode.guid = guidItem\n    } else if (typeof guidItem?._ === 'string') {\n      episode.guid = guidItem._\n    } else {\n      Logger.error(`[podcastUtils] Invalid guid ${item['guid']} for ${episode.enclosure.url}`)\n    }\n  }\n\n  const arrayFields = ['title', 'itunes:episodeType', 'itunes:season', 'itunes:episode', 'itunes:author', 'itunes:duration', 'itunes:explicit', 'itunes:subtitle']\n  arrayFields.forEach((key) => {\n    const cleanKey = key.split(':').pop()\n    let value = extractFirstArrayItem(item, key)\n    if (value?.['_']) value = value['_']\n    episode[cleanKey] = value\n  })\n  return episode\n}\n\nfunction cleanEpisodeData(data) {\n  const pubJsDate = data.pubDate ? new Date(data.pubDate) : null\n  const publishedAt = pubJsDate && !isNaN(pubJsDate) ? pubJsDate.valueOf() : null\n  return {\n    title: data.title,\n    subtitle: data.subtitle || '',\n    description: data.description || '',\n    descriptionPlain: data.descriptionPlain || '',\n    pubDate: data.pubDate || '',\n    episodeType: data.episodeType || '',\n    season: data.season || '',\n    episode: data.episode || '',\n    author: data.author || '',\n    duration: data.duration || '',\n    explicit: data.explicit || '',\n    publishedAt,\n    enclosure: data.enclosure,\n    guid: data.guid || null,\n    chaptersUrl: data.chaptersUrl || null,\n    chaptersType: data.chaptersType || null\n  }\n}\n\nfunction extractPodcastEpisodes(items) {\n  const episodes = []\n  items.forEach((item) => {\n    const extracted = extractEpisodeData(item)\n    if (extracted) {\n      episodes.push(cleanEpisodeData(extracted))\n    }\n  })\n  return episodes\n}\n\nfunction cleanPodcastJson(rssJson, excludeEpisodeMetadata) {\n  if (!rssJson.channel?.length) {\n    Logger.error(`[podcastUtil] Invalid podcast no channel object`)\n    return null\n  }\n  const channel = rssJson.channel[0]\n  if (!channel.item?.length) {\n    Logger.error(`[podcastUtil] Invalid podcast no episodes`)\n    return null\n  }\n  const podcast = {\n    metadata: extractPodcastMetadata(channel)\n  }\n  if (!excludeEpisodeMetadata) {\n    podcast.episodes = extractPodcastEpisodes(channel.item)\n  } else {\n    podcast.numEpisodes = channel.item.length\n  }\n  return podcast\n}\n\nmodule.exports.parsePodcastRssFeedXml = async (xml, excludeEpisodeMetadata = false, includeRaw = false) => {\n  if (!xml) return null\n  const json = await xmlToJSON(xml)\n  if (!json?.rss) {\n    Logger.error('[podcastUtils] Invalid XML or RSS feed')\n    return null\n  }\n\n  const podcast = cleanPodcastJson(json.rss, excludeEpisodeMetadata)\n  if (!podcast) return null\n\n  if (includeRaw) {\n    return {\n      podcast,\n      rawJson: json\n    }\n  } else {\n    return {\n      podcast\n    }\n  }\n}\n\n/**\n * Get podcast RSS feed as JSON\n * Uses SSRF filter to prevent internal URLs\n * \n * @param {string} feedUrl \n * @param {boolean} [excludeEpisodeMetadata=false]\n * @returns {Promise}\n */\nmodule.exports.getPodcastFeed = (feedUrl, excludeEpisodeMetadata = false) => {\n  Logger.debug(`[podcastUtils] getPodcastFeed for \"${feedUrl}\"`)\n\n  return axios({\n    url: feedUrl,\n    method: 'GET',\n    timeout: 12000,\n    responseType: 'arraybuffer',\n    headers: { Accept: 'application/rss+xml' },\n    httpAgent: ssrfFilter(feedUrl),\n    httpsAgent: ssrfFilter(feedUrl)\n  }).then(async (data) => {\n\n    // Adding support for ios-8859-1 encoded RSS feeds.\n    //  See: https://github.com/advplyr/audiobookshelf/issues/1489\n    const contentType = data.headers?.['content-type'] || '' // e.g. text/xml; charset=iso-8859-1\n    if (contentType.toLowerCase().includes('iso-8859-1')) {\n      data.data = data.data.toString('latin1')\n    } else {\n      data.data = data.data.toString()\n    }\n\n    if (!data?.data) {\n      Logger.error(`[podcastUtils] getPodcastFeed: Invalid podcast feed request response (${feedUrl})`)\n      return null\n    }\n    Logger.debug(`[podcastUtils] getPodcastFeed for \"${feedUrl}\" success - parsing xml`)\n    const payload = await this.parsePodcastRssFeedXml(data.data, excludeEpisodeMetadata)\n    if (!payload) {\n      return null\n    }\n\n    // RSS feed may be a private RSS feed\n    payload.podcast.metadata.feedUrl = feedUrl\n\n    return payload.podcast\n  }).catch((error) => {\n    Logger.error('[podcastUtils] getPodcastFeed Error', error)\n    return null\n  })\n}\n\n// Return array of episodes ordered by closest match (Levenshtein distance of 6 or less)\nmodule.exports.findMatchingEpisodes = async (feedUrl, searchTitle) => {\n  const feed = await this.getPodcastFeed(feedUrl).catch(() => {\n    return null\n  })\n\n  return this.findMatchingEpisodesInFeed(feed, searchTitle)\n}\n\nmodule.exports.findMatchingEpisodesInFeed = (feed, searchTitle) => {\n  searchTitle = searchTitle.toLowerCase().trim()\n  if (!feed?.episodes) {\n    return null\n  }\n\n  const matches = []\n  feed.episodes.forEach(ep => {\n    if (!ep.title) return\n\n    const epTitle = ep.title.toLowerCase().trim()\n    if (epTitle === searchTitle) {\n      matches.push({\n        episode: ep,\n        levenshtein: 0\n      })\n    } else {\n      const levenshtein = levenshteinDistance(searchTitle, epTitle, true)\n      if (levenshtein <= 6 && epTitle.length > levenshtein) {\n        matches.push({\n          episode: ep,\n          levenshtein\n        })\n      }\n    }\n  })\n  return matches.sort((a, b) => a.levenshtein - b.levenshtein)\n}\n"], "filenames": ["server/controllers/PodcastController.js", "server/utils/index.js", "server/utils/podcastUtils.js"], "buggy_code_start_loc": [8, 14, 0], "buggy_code_end_loc": [114, 206, 249], "fixing_code_start_loc": [9, 14, 1], "fixing_code_end_loc": [124, 223, 267], "type": "CWE-918", "message": "Audiobookshelf is a self-hosted audiobook and podcast server. Prior to 2.7.0, Audiobookshelf is vulnerable to unauthenticated blind server-side request (SSRF) vulnerability in `podcastUtils.js`. This vulnerability has been addressed in version 2.7.0. There are no known workarounds for this vulnerability.\n\n", "other": {"cve": {"id": "CVE-2023-51697", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-27T18:15:23.487", "lastModified": "2024-01-05T15:03:13.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Audiobookshelf is a self-hosted audiobook and podcast server. Prior to 2.7.0, Audiobookshelf is vulnerable to unauthenticated blind server-side request (SSRF) vulnerability in `podcastUtils.js`. This vulnerability has been addressed in version 2.7.0. There are no known workarounds for this vulnerability.\n\n"}, {"lang": "es", "value": "Audiobookshelf es un servidor de podcasts y audiolibros autohospedado. Antes de 2.7.0, Audiobookshelf era afectado por una vulnerabilidad de blind server-side request (SSRF) no autenticada en `podcastUtils.js`. Esta vulnerabilidad se ha solucionado en la versi\u00f3n 2.7.0. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiobookshelf:audiobookshelf:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.0", "matchCriteriaId": "13B62B03-BF78-4428-B064-B6186947CE61"}]}]}], "references": [{"url": "https://github.com/advplyr/audiobookshelf/commit/f2f2ea161ca0701e1405e737b0df0f96296e4f64", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/advplyr/audiobookshelf/security/advisories/GHSA-jhjx-c3wx-q2x7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/advplyr/audiobookshelf/commit/f2f2ea161ca0701e1405e737b0df0f96296e4f64"}}