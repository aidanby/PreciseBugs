{"buggy_code": ["package captcha\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// captchaRepo captcha repository\ntype captchaRepo struct {\n\tdata *data.Data\n}\n\n// NewCaptchaRepo new repository\nfunc NewCaptchaRepo(data *data.Data) action.CaptchaRepo {\n\treturn &captchaRepo{\n\t\tdata: data,\n\t}\n}\n\nfunc (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\terr = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\tres, err := cr.data.Cache.GetInt64(ctx, cacheKey)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn int(res), nil\n}\n\nfunc (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\terr = cr.data.Cache.Del(ctx, cacheKey)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// SetCaptcha set captcha to cache\nfunc (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {\n\terr = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetCaptcha get captcha from cache\nfunc (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {\n\tcaptcha, err = cr.data.Cache.GetString(ctx, key)\n\tif err != nil {\n\t\tlog.Debug(err)\n\t}\n\treturn captcha, nil\n}\n", "package action\n\nimport (\n\t\"context\"\n\t\"image/color\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/mojocn/base64Captcha\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// CaptchaRepo captcha repository\ntype CaptchaRepo interface {\n\tSetCaptcha(ctx context.Context, key, captcha string) (err error)\n\tGetCaptcha(ctx context.Context, key string) (captcha string, err error)\n\tSetActionType(ctx context.Context, ip, actionType string, amount int) (err error)\n\tGetActionType(ctx context.Context, ip, actionType string) (amount int, err error)\n\tDelActionType(ctx context.Context, ip, actionType string) (err error)\n}\n\n// CaptchaService kit service\ntype CaptchaService struct {\n\tcaptchaRepo CaptchaRepo\n}\n\n// NewCaptchaService captcha service\nfunc NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {\n\treturn &CaptchaService{\n\t\tcaptchaRepo: captchaRepo,\n\t}\n}\n\n// ActionRecord action record\nfunc (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {\n\tresp = &schema.ActionRecordResp{}\n\tnum, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)\n\tif err != nil {\n\t\tnum = 0\n\t}\n\t// TODO config num to config file\n\tif num >= 3 {\n\t\tresp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)\n\t\tresp.Verify = true\n\t}\n\treturn\n}\n\nfunc (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {\n\tresp = &schema.ActionRecordResp{}\n\tresp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)\n\tresp.Verify = true\n\treturn\n}\n\nfunc (cs *CaptchaService) UserRegisterVerifyCaptcha(\n\tctx context.Context, id string, VerifyValue string,\n) bool {\n\tif id == \"\" || VerifyValue == \"\" {\n\t\treturn false\n\t}\n\tpass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn pass\n}\n\n// ActionRecordVerifyCaptcha\n// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct\nfunc (cs *CaptchaService) ActionRecordVerifyCaptcha(\n\tctx context.Context, actionType string, ip string, id string, VerifyValue string,\n) bool {\n\tnum, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)\n\tif cahceErr != nil {\n\t\treturn true\n\t}\n\tif num >= 3 {\n\t\tif id == \"\" || VerifyValue == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tpass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn pass\n\t}\n\treturn true\n}\n\nfunc (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {\n\tvar err error\n\tnum, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)\n\tif cahceErr != nil {\n\t\tlog.Error(err)\n\t}\n\tnum++\n\terr = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn num, nil\n}\n\nfunc (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {\n\terr := cs.captchaRepo.DelActionType(ctx, ip, actionType)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\n// GenerateCaptcha generate captcha\nfunc (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {\n\tdriverString := base64Captcha.DriverString{\n\t\tHeight:          40,\n\t\tWidth:           100,\n\t\tNoiseCount:      0,\n\t\tShowLineOptions: 2 | 4,\n\t\tLength:          4,\n\t\tSource:          \"1234567890qwertyuioplkjhgfdsazxcvbnm\",\n\t\tBgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},\n\t\tFonts:           []string{\"wqy-microhei.ttc\"},\n\t}\n\tdriver := driverString.ConvertFonts()\n\n\tid, content, answer := driver.GenerateIdQuestionAnswer()\n\titem, err := driver.DrawCaptcha(content)\n\tif err != nil {\n\t\treturn \"\", \"\", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()\n\t}\n\terr = cs.captchaRepo.SetCaptcha(ctx, id, answer)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptchaBase64 = item.EncodeB64string()\n\treturn id, captchaBase64, nil\n}\n\n// VerifyCaptcha generate captcha\nfunc (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {\n\trealCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)\n\tif err != nil {\n\t\treturn false, nil\n\t}\n\treturn strings.TrimSpace(captcha) == realCaptcha, nil\n}\n"], "fixing_code": ["package captcha\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// captchaRepo captcha repository\ntype captchaRepo struct {\n\tdata *data.Data\n}\n\n// NewCaptchaRepo new repository\nfunc NewCaptchaRepo(data *data.Data) action.CaptchaRepo {\n\treturn &captchaRepo{\n\t\tdata: data,\n\t}\n}\n\nfunc (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\terr = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\tres, err := cr.data.Cache.GetInt64(ctx, cacheKey)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn int(res), nil\n}\n\nfunc (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {\n\tcacheKey := fmt.Sprintf(\"ActionRecord:%s@\", ip)\n\terr = cr.data.Cache.Del(ctx, cacheKey)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// SetCaptcha set captcha to cache\nfunc (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {\n\terr = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetCaptcha get captcha from cache\nfunc (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {\n\tcaptcha, err = cr.data.Cache.GetString(ctx, key)\n\tif err != nil {\n\t\tlog.Debug(err)\n\t}\n\treturn captcha, nil\n}\n\nfunc (cr *captchaRepo) DelCaptcha(ctx context.Context, key string) (err error) {\n\terr = cr.data.Cache.Del(ctx, key)\n\tif err != nil {\n\t\tlog.Debug(err)\n\t}\n\treturn nil\n}\n", "package action\n\nimport (\n\t\"context\"\n\t\"image/color\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/mojocn/base64Captcha\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// CaptchaRepo captcha repository\ntype CaptchaRepo interface {\n\tSetCaptcha(ctx context.Context, key, captcha string) (err error)\n\tGetCaptcha(ctx context.Context, key string) (captcha string, err error)\n\tDelCaptcha(ctx context.Context, key string) (err error)\n\tSetActionType(ctx context.Context, ip, actionType string, amount int) (err error)\n\tGetActionType(ctx context.Context, ip, actionType string) (amount int, err error)\n\tDelActionType(ctx context.Context, ip, actionType string) (err error)\n}\n\n// CaptchaService kit service\ntype CaptchaService struct {\n\tcaptchaRepo CaptchaRepo\n}\n\n// NewCaptchaService captcha service\nfunc NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {\n\treturn &CaptchaService{\n\t\tcaptchaRepo: captchaRepo,\n\t}\n}\n\n// ActionRecord action record\nfunc (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {\n\tresp = &schema.ActionRecordResp{}\n\tnum, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)\n\tif err != nil {\n\t\tnum = 0\n\t}\n\t// TODO config num to config file\n\tif num >= 3 {\n\t\tresp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)\n\t\tresp.Verify = true\n\t}\n\treturn\n}\n\nfunc (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {\n\tresp = &schema.ActionRecordResp{}\n\tresp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)\n\tresp.Verify = true\n\treturn\n}\n\nfunc (cs *CaptchaService) UserRegisterVerifyCaptcha(\n\tctx context.Context, id string, VerifyValue string,\n) bool {\n\tif id == \"\" || VerifyValue == \"\" {\n\t\treturn false\n\t}\n\tpass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn pass\n}\n\n// ActionRecordVerifyCaptcha\n// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct\nfunc (cs *CaptchaService) ActionRecordVerifyCaptcha(\n\tctx context.Context, actionType string, ip string, id string, VerifyValue string,\n) bool {\n\tnum, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)\n\tif cahceErr != nil {\n\t\treturn true\n\t}\n\tif num >= 3 {\n\t\tif id == \"\" || VerifyValue == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tpass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn pass\n\t}\n\treturn true\n}\n\nfunc (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {\n\tvar err error\n\tnum, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)\n\tif cahceErr != nil {\n\t\tlog.Error(err)\n\t}\n\tnum++\n\terr = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn num, nil\n}\n\nfunc (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {\n\terr := cs.captchaRepo.DelActionType(ctx, ip, actionType)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\n// GenerateCaptcha generate captcha\nfunc (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {\n\tdriverString := base64Captcha.DriverString{\n\t\tHeight:          40,\n\t\tWidth:           100,\n\t\tNoiseCount:      0,\n\t\tShowLineOptions: 2 | 4,\n\t\tLength:          4,\n\t\tSource:          \"1234567890qwertyuioplkjhgfdsazxcvbnm\",\n\t\tBgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},\n\t\tFonts:           []string{\"wqy-microhei.ttc\"},\n\t}\n\tdriver := driverString.ConvertFonts()\n\n\tid, content, answer := driver.GenerateIdQuestionAnswer()\n\titem, err := driver.DrawCaptcha(content)\n\tif err != nil {\n\t\treturn \"\", \"\", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()\n\t}\n\terr = cs.captchaRepo.SetCaptcha(ctx, id, answer)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptchaBase64 = item.EncodeB64string()\n\treturn id, captchaBase64, nil\n}\n\n// VerifyCaptcha generate captcha\nfunc (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {\n\trealCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)\n\tif err != nil {\n\t\tlog.Error(\"VerifyCaptcha GetCaptcha Error\", err.Error())\n\t\treturn false, nil\n\t}\n\terr = cs.captchaRepo.DelCaptcha(ctx, key)\n\tif err != nil {\n\t\tlog.Error(\"VerifyCaptcha DelCaptcha Error\", err.Error())\n\t\treturn false, nil\n\t}\n\treturn strings.TrimSpace(captcha) == realCaptcha, nil\n}\n"], "filenames": ["internal/repo/captcha/captcha.go", "internal/service/action/captcha_service.go"], "buggy_code_start_loc": [70, 18], "buggy_code_end_loc": [70, 145], "fixing_code_start_loc": [71, 19], "fixing_code_end_loc": [79, 153], "type": "CWE-203", "message": "Observable Timing Discrepancy in GitHub repository answerdev/answer prior to 1.0.6.", "other": {"cve": {"id": "CVE-2023-1538", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-21T05:15:09.813", "lastModified": "2023-03-23T15:14:37.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Observable Timing Discrepancy in GitHub repository answerdev/answer prior to 1.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.6", "matchCriteriaId": "BC30C65B-0A27-4181-94A2-75BDAD7D7145"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/813ad0b9894673b1bdd489a2e9ab60a44fe990af", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/ac0271eb-660f-4966-8b57-4bc660a9a1a0", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/813ad0b9894673b1bdd489a2e9ab60a44fe990af"}}