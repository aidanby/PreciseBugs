{"buggy_code": ["// This file implements methods from the QPDF class that involve\n// encryption.\n\n#include <qpdf/QPDF.hh>\n\n#include <qpdf/QPDFExc.hh>\n\n#include <qpdf/QTC.hh>\n#include <qpdf/QUtil.hh>\n#include <qpdf/Pl_RC4.hh>\n#include <qpdf/Pl_AES_PDF.hh>\n#include <qpdf/Pl_Buffer.hh>\n#include <qpdf/Pl_SHA2.hh>\n#include <qpdf/RC4.hh>\n#include <qpdf/MD5.hh>\n\n#include <algorithm>\n#include <assert.h>\n#include <string.h>\n\nstatic unsigned char const padding_string[] = {\n    0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,\n    0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,\n    0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,\n    0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a\n};\n\nstatic unsigned int const key_bytes = 32;\n\n// V4 key lengths apply to V <= 4\nstatic unsigned int const OU_key_bytes_V4 = sizeof(MD5::Digest);\n\nstatic unsigned int const OU_key_bytes_V5 = 48;\nstatic unsigned int const OUE_key_bytes_V5 = 32;\nstatic unsigned int const Perms_key_bytes_V5 = 16;\n\nint\nQPDF::EncryptionData::getV() const\n{\n    return this->V;\n}\n\nint\nQPDF::EncryptionData::getR() const\n{\n    return this->R;\n}\n\nint\nQPDF::EncryptionData::getLengthBytes() const\n{\n    return this->Length_bytes;\n}\n\nint\nQPDF::EncryptionData::getP() const\n{\n    return this->P;\n}\n\nstd::string const&\nQPDF::EncryptionData::getO() const\n{\n    return this->O;\n}\n\nstd::string const&\nQPDF::EncryptionData::getU() const\n{\n    return this->U;\n}\n\nstd::string const&\nQPDF::EncryptionData::getOE() const\n{\n    return this->OE;\n}\n\nstd::string const&\nQPDF::EncryptionData::getUE() const\n{\n    return this->UE;\n}\n\nstd::string const&\nQPDF::EncryptionData::getPerms() const\n{\n    return this->Perms;\n}\n\nstd::string const&\nQPDF::EncryptionData::getId1() const\n{\n    return this->id1;\n}\n\nbool\nQPDF::EncryptionData::getEncryptMetadata() const\n{\n    return this->encrypt_metadata;\n}\n\nvoid\nQPDF::EncryptionData::setO(std::string const& O)\n{\n    this->O = O;\n}\n\nvoid\nQPDF::EncryptionData::setU(std::string const& U)\n{\n    this->U = U;\n}\n\nvoid\nQPDF::EncryptionData::setV5EncryptionParameters(\n    std::string const& O,\n    std::string const& OE,\n    std::string const& U,\n    std::string const& UE,\n    std::string const& Perms)\n{\n    this->O = O;\n    this->OE = OE;\n    this->U = U;\n    this->UE = UE;\n    this->Perms = Perms;\n}\n\nstatic void\npad_or_truncate_password_V4(std::string const& password, char k1[key_bytes])\n{\n    int password_bytes = std::min(static_cast<size_t>(key_bytes),\n                                  password.length());\n    int pad_bytes = key_bytes - password_bytes;\n    memcpy(k1, password.c_str(), password_bytes);\n    memcpy(k1 + password_bytes, padding_string, pad_bytes);\n}\n\nvoid\nQPDF::trim_user_password(std::string& user_password)\n{\n    // Although unnecessary, this routine trims the padding string\n    // from the end of a user password.  Its only purpose is for\n    // recovery of user passwords which is done in the test suite.\n    char const* cstr = user_password.c_str();\n    size_t len = user_password.length();\n    if (len < key_bytes)\n    {\n\treturn;\n    }\n\n    char const* p1 = cstr;\n    char const* p2 = 0;\n    while ((p2 = strchr(p1, '\\x28')) != 0)\n    {\n\tif (memcmp(p2, padding_string, len - (p2 - cstr)) == 0)\n\t{\n\t    user_password = user_password.substr(0, p2 - cstr);\n\t    return;\n\t}\n        else\n        {\n            QTC::TC(\"qpdf\", \"QPDF_encryption skip 0x28\");\n            p1 = p2 + 1;\n        }\n    }\n}\n\nstatic std::string\npad_or_truncate_password_V4(std::string const& password)\n{\n    char k1[key_bytes];\n    pad_or_truncate_password_V4(password, k1);\n    return std::string(k1, key_bytes);\n}\n\nstatic std::string\ntruncate_password_V5(std::string const& password)\n{\n    return password.substr(\n        0, std::min(static_cast<size_t>(127), password.length()));\n}\n\nstatic void\niterate_md5_digest(MD5& md5, MD5::Digest& digest, int iterations)\n{\n    md5.digest(digest);\n\n    for (int i = 0; i < iterations; ++i)\n    {\n\tMD5 m;\n\tm.encodeDataIncrementally(reinterpret_cast<char*>(digest),\n                                  sizeof(digest));\n\tm.digest(digest);\n    }\n}\n\n\nstatic void\niterate_rc4(unsigned char* data, int data_len,\n\t    unsigned char* okey, int key_len,\n\t    int iterations, bool reverse)\n{\n    unsigned char* key = new unsigned char[key_len];\n    for (int i = 0; i < iterations; ++i)\n    {\n\tint const xor_value = (reverse ? iterations - 1 - i : i);\n\tfor (int j = 0; j < key_len; ++j)\n\t{\n\t    key[j] = okey[j] ^ xor_value;\n\t}\n\tRC4 rc4(key, key_len);\n\trc4.process(data, data_len);\n    }\n    delete [] key;\n}\n\nstatic std::string\nprocess_with_aes(std::string const& key,\n                 bool encrypt,\n                 std::string const& data,\n                 size_t outlength = 0,\n                 unsigned int repetitions = 1,\n                 unsigned char const* iv = 0,\n                 size_t iv_length = 0)\n{\n    Pl_Buffer buffer(\"buffer\");\n    Pl_AES_PDF aes(\"aes\", &buffer, encrypt,\n                   QUtil::unsigned_char_pointer(key),\n                   key.length());\n    if (iv)\n    {\n        aes.setIV(iv, iv_length);\n    }\n    else\n    {\n        aes.useZeroIV();\n    }\n    aes.disablePadding();\n    for (unsigned int i = 0; i < repetitions; ++i)\n    {\n        aes.write(QUtil::unsigned_char_pointer(data), data.length());\n    }\n    aes.finish();\n    PointerHolder<Buffer> bufp = buffer.getBuffer();\n    if (outlength == 0)\n    {\n        outlength = bufp->getSize();\n    }\n    else\n    {\n        outlength = std::min(outlength, bufp->getSize());\n    }\n    return std::string(reinterpret_cast<char*>(bufp->getBuffer()), outlength);\n}\n\nstatic std::string\nhash_V5(std::string const& password,\n        std::string const& salt,\n        std::string const& udata,\n        QPDF::EncryptionData const& data)\n{\n    Pl_SHA2 hash(256);\n    hash.write(QUtil::unsigned_char_pointer(password), password.length());\n    hash.write(QUtil::unsigned_char_pointer(salt), salt.length());\n    hash.write(QUtil::unsigned_char_pointer(udata), udata.length());\n    hash.finish();\n    std::string K = hash.getRawDigest();\n\n    std::string result;\n    if (data.getR() < 6)\n    {\n        result = K;\n    }\n    else\n    {\n        // Algorithm 2.B from ISO 32000-1 chapter 7: Computing a hash\n\n        int round_number = 0;\n        bool done = false;\n        while (! done)\n        {\n            // The hash algorithm has us setting K initially to the R5\n            // value and then repeating a series of steps 64 times\n            // before starting with the termination case testing.  The\n            // wording of the specification is very unclear as to the\n            // exact number of times it should be run since the\n            // wording about whether the initial setup counts as round\n            // 0 or not is ambiguous.  This code counts the initial\n            // setup (R5) value as round 0, which appears to be\n            // correct.  This was determined to be correct by\n            // increasing or decreasing the number of rounds by 1 or 2\n            // from this value and generating 20 test files.  In this\n            // interpretation, all the test files worked with Adobe\n            // Reader X.  In the other configurations, many of the\n            // files did not work, and we were accurately able to\n            // predict which files didn't work by looking at the\n            // conditions under which we terminated repetition.\n\n            ++round_number;\n            std::string K1 = password + K + udata;\n            assert(K.length() >= 32);\n            std::string E = process_with_aes(\n                K.substr(0, 16), true, K1, 0, 64,\n                QUtil::unsigned_char_pointer(K.substr(16, 16)), 16);\n\n            // E_mod_3 is supposed to be mod 3 of the first 16 bytes\n            // of E taken as as a (128-bit) big-endian number.  Since\n            // (xy mod n) is equal to ((x mod n) + (y mod n)) mod n\n            // and since 256 mod n is 1, we can just take the sums of\n            // the the mod 3s of each byte to get the same result.\n            int E_mod_3 = 0;\n            for (unsigned int i = 0; i < 16; ++i)\n            {\n                E_mod_3 += static_cast<unsigned char>(E.at(i));\n            }\n            E_mod_3 %= 3;\n            int next_hash = ((E_mod_3 == 0) ? 256 :\n                             (E_mod_3 == 1) ? 384 :\n                             512);\n            Pl_SHA2 hash(next_hash);\n            hash.write(QUtil::unsigned_char_pointer(E), E.length());\n            hash.finish();\n            K = hash.getRawDigest();\n\n            if (round_number >= 64)\n            {\n                unsigned int ch = static_cast<unsigned char>(*(E.rbegin()));\n\n                if (ch <= static_cast<unsigned int>(round_number - 32))\n                {\n                    done = true;\n                }\n            }\n        }\n        result = K.substr(0, 32);\n    }\n\n    return result;\n}\n\nstatic\nvoid pad_short_parameter(std::string& param, unsigned int max_len)\n{\n    if (param.length() < max_len)\n    {\n        QTC::TC(\"qpdf\", \"QPDF_encryption pad short parameter\");\n        param.append(max_len - param.length(), '\\0');\n    }\n}\n\nstd::string\nQPDF::compute_data_key(std::string const& encryption_key,\n\t\t       int objid, int generation, bool use_aes,\n                       int encryption_V, int encryption_R)\n{\n    // Algorithm 3.1 from the PDF 1.7 Reference Manual\n\n    std::string result = encryption_key;\n\n    if (encryption_V >= 5)\n    {\n        // Algorithm 3.1a (PDF 1.7 extension level 3): just use\n        // encryption key straight.\n        return result;\n    }\n\n    // Append low three bytes of object ID and low two bytes of generation\n    result += static_cast<char>(objid & 0xff);\n    result += static_cast<char>((objid >> 8) & 0xff);\n    result += static_cast<char>((objid >> 16) & 0xff);\n    result += static_cast<char>(generation & 0xff);\n    result += static_cast<char>((generation >> 8) & 0xff);\n    if (use_aes)\n    {\n\tresult += \"sAlT\";\n    }\n\n    MD5 md5;\n    md5.encodeDataIncrementally(result.c_str(), result.length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    return std::string(reinterpret_cast<char*>(digest),\n\t\t       std::min(result.length(), static_cast<size_t>(16)));\n}\n\nstd::string\nQPDF::compute_encryption_key(\n    std::string const& password, EncryptionData const& data)\n{\n    if (data.getV() >= 5)\n    {\n        // For V >= 5, the encryption key is generated and stored in\n        // the file, encrypted separately with both user and owner\n        // passwords.\n        return recover_encryption_key_with_password(password, data);\n    }\n    else\n    {\n        // For V < 5, the encryption key is derived from the user\n        // password.\n        return compute_encryption_key_from_password(password, data);\n    }\n}\n\nstd::string\nQPDF::compute_encryption_key_from_password(\n    std::string const& password, EncryptionData const& data)\n{\n    // Algorithm 3.2 from the PDF 1.7 Reference Manual\n\n    // This code does not properly handle Unicode passwords.\n    // Passwords are supposed to be converted from OS codepage\n    // characters to PDFDocEncoding.  Unicode passwords are supposed\n    // to be converted to OS codepage before converting to\n    // PDFDocEncoding.  We instead require the password to be\n    // presented in its final form.\n\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(password).c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getO().c_str(), key_bytes);\n    char pbytes[4];\n    int P = data.getP();\n    pbytes[0] = static_cast<char>(P & 0xff);\n    pbytes[1] = static_cast<char>((P >> 8) & 0xff);\n    pbytes[2] = static_cast<char>((P >> 16) & 0xff);\n    pbytes[3] = static_cast<char>((P >> 24) & 0xff);\n    md5.encodeDataIncrementally(pbytes, 4);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    if ((data.getR() >= 4) && (! data.getEncryptMetadata()))\n    {\n\tchar bytes[4];\n\tmemset(bytes, 0xff, 4);\n\tmd5.encodeDataIncrementally(bytes, 4);\n    }\n    MD5::Digest digest;\n    iterate_md5_digest(md5, digest, ((data.getR() >= 3) ? 50 : 0));\n    return std::string(reinterpret_cast<char*>(digest),\n                       std::min(static_cast<int>(sizeof(digest)),\n                                data.getLengthBytes()));\n}\n\nstatic void\ncompute_O_rc4_key(std::string const& user_password,\n\t\t  std::string const& owner_password,\n\t\t  QPDF::EncryptionData const& data,\n\t\t  unsigned char key[OU_key_bytes_V4])\n{\n    if (data.getV() >= 5)\n    {\n\tthrow std::logic_error(\n\t    \"compute_O_rc4_key called for file with V >= 5\");\n    }\n    std::string password = owner_password;\n    if (password.empty())\n    {\n\tpassword = user_password;\n    }\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(password).c_str(), key_bytes);\n    MD5::Digest digest;\n    iterate_md5_digest(md5, digest, ((data.getR() >= 3) ? 50 : 0));\n    memcpy(key, digest, OU_key_bytes_V4);\n}\n\nstatic std::string\ncompute_O_value(std::string const& user_password,\n\t\tstd::string const& owner_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    // Algorithm 3.3 from the PDF 1.7 Reference Manual\n\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}\n\nstatic\nstd::string\ncompute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}\n\nstatic\nstd::string\ncompute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.5 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    // pad with arbitrary data -- make it consistent for the sake of\n    // testing\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}\n\nstatic std::string\ncompute_U_value(std::string const& user_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    if (data.getR() >= 3)\n    {\n\treturn compute_U_value_R3(user_password, data);\n    }\n\n    return compute_U_value_R2(user_password, data);\n}\n\nstatic bool\ncheck_user_password_V4(std::string const& user_password,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.6 from the PDF 1.7 Reference Manual\n\n    std::string u_value = compute_U_value(user_password, data);\n    int to_compare = ((data.getR() >= 3) ? sizeof(MD5::Digest)\n                      : key_bytes);\n    return (memcmp(data.getU().c_str(), u_value.c_str(), to_compare) == 0);\n}\n\nstatic bool\ncheck_user_password_V5(std::string const& user_password,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.11 from the PDF 1.7 extension level 3\n\n    std::string user_data = data.getU().substr(0, 32);\n    std::string validation_salt = data.getU().substr(32, 8);\n    std::string password = truncate_password_V5(user_password);\n    return (hash_V5(password, validation_salt, \"\", data) == user_data);\n}\n\nstatic bool\ncheck_user_password(std::string const& user_password,\n\t\t    QPDF::EncryptionData const& data)\n{\n    if (data.getV() < 5)\n    {\n        return check_user_password_V4(user_password, data);\n    }\n    else\n    {\n        return check_user_password_V5(user_password, data);\n    }\n}\n\nstatic bool\ncheck_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}\n\nstatic bool\ncheck_owner_password_V5(std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.12 from the PDF 1.7 extension level 3\n\n    std::string user_data = data.getU().substr(0, 48);\n    std::string owner_data = data.getO().substr(0, 32);\n    std::string validation_salt = data.getO().substr(32, 8);\n    std::string password = truncate_password_V5(owner_password);\n    return (hash_V5(password, validation_salt, user_data,\n                    data) == owner_data);\n}\n\nstatic bool\ncheck_owner_password(std::string& user_password,\n\t\t     std::string const& owner_password,\n\t\t     QPDF::EncryptionData const& data)\n{\n    if (data.getV() < 5)\n    {\n        return check_owner_password_V4(user_password, owner_password, data);\n    }\n    else\n    {\n        return check_owner_password_V5(owner_password, data);\n    }\n}\n\nstd::string\nQPDF::recover_encryption_key_with_password(\n    std::string const& password, EncryptionData const& data)\n{\n    // Disregard whether Perms is valid.\n    bool disregard;\n    return recover_encryption_key_with_password(password, data, disregard);\n}\n\nstatic void\ncompute_U_UE_value_V5(std::string const& user_password,\n                      std::string const& encryption_key,\n                      QPDF::EncryptionData const& data,\n                      std::string& U, std::string& UE)\n{\n    // Algorithm 3.8 from the PDF 1.7 extension level 3\n    char k[16];\n    QUtil::initializeWithRandomBytes(\n        QUtil::unsigned_char_pointer(k), sizeof(k));\n    std::string validation_salt(k, 8);\n    std::string key_salt(k + 8, 8);\n    U = hash_V5(user_password, validation_salt, \"\", data) +\n        validation_salt + key_salt;\n    std::string intermediate_key = hash_V5(user_password, key_salt, \"\", data);\n    UE = process_with_aes(intermediate_key, true, encryption_key);\n}\n\nstatic void\ncompute_O_OE_value_V5(std::string const& owner_password,\n                      std::string const& encryption_key,\n                      QPDF::EncryptionData const& data,\n                      std::string const& U,\n                      std::string& O, std::string& OE)\n{\n    // Algorithm 3.9 from the PDF 1.7 extension level 3\n    char k[16];\n    QUtil::initializeWithRandomBytes(\n        QUtil::unsigned_char_pointer(k), sizeof(k));\n    std::string validation_salt(k, 8);\n    std::string key_salt(k + 8, 8);\n    O = hash_V5(owner_password, validation_salt, U, data) +\n        validation_salt + key_salt;\n    std::string intermediate_key = hash_V5(owner_password, key_salt, U, data);\n    OE = process_with_aes(intermediate_key, true, encryption_key);\n}\n\nvoid\ncompute_Perms_value_V5_clear(std::string const& encryption_key,\n                             QPDF::EncryptionData const& data,\n                             unsigned char k[16])\n{\n    // From algorithm 3.10 from the PDF 1.7 extension level 3\n    unsigned long long extended_perms = 0xffffffff00000000LL | data.getP();\n    for (int i = 0; i < 8; ++i)\n    {\n        k[i] = static_cast<unsigned char>(extended_perms & 0xff);\n        extended_perms >>= 8;\n    }\n    k[8] = data.getEncryptMetadata() ? 'T' : 'F';\n    k[9] = 'a';\n    k[10] = 'd';\n    k[11] = 'b';\n    QUtil::initializeWithRandomBytes(k + 12, 4);\n}\n\nstatic std::string\ncompute_Perms_value_V5(std::string const& encryption_key,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.10 from the PDF 1.7 extension level 3\n    unsigned char k[16];\n    compute_Perms_value_V5_clear(encryption_key, data, k);\n    return process_with_aes(\n        encryption_key, true,\n        std::string(reinterpret_cast<char*>(k), sizeof(k)));\n}\n\nstd::string\nQPDF::recover_encryption_key_with_password(\n    std::string const& password, EncryptionData const& data,\n    bool& perms_valid)\n{\n    // Algorithm 3.2a from the PDF 1.7 extension level 3\n\n    // This code does not handle Unicode passwords correctly.\n    // Empirical evidence suggests that most viewers don't.  We are\n    // supposed to process the input string with the SASLprep (RFC\n    // 4013) profile of stringprep (RFC 3454) and then convert the\n    // result to UTF-8.\n\n    perms_valid = false;\n    std::string key_password = truncate_password_V5(password);\n    std::string key_salt;\n    std::string user_data;\n    std::string encrypted_file_key;\n    if (check_owner_password_V5(key_password, data))\n    {\n        key_salt = data.getO().substr(40, 8);\n        user_data = data.getU().substr(0, 48);\n        encrypted_file_key = data.getOE().substr(0, 32);\n    }\n    else if (check_user_password_V5(key_password, data))\n    {\n        key_salt = data.getU().substr(40, 8);\n        encrypted_file_key = data.getUE().substr(0, 32);\n    }\n    std::string intermediate_key =\n        hash_V5(key_password, key_salt, user_data, data);\n    std::string file_key =\n        process_with_aes(intermediate_key, false, encrypted_file_key);\n\n    // Decrypt Perms and check against expected value\n    std::string perms_check =\n        process_with_aes(file_key, false, data.getPerms(), 12);\n    unsigned char k[16];\n    compute_Perms_value_V5_clear(file_key, data, k);\n    perms_valid = (memcmp(perms_check.c_str(), k, 12) == 0);\n\n    return file_key;\n}\n\nQPDF::encryption_method_e\nQPDF::interpretCF(QPDFObjectHandle cf)\n{\n    if (cf.isName())\n    {\n\tstd::string filter = cf.getName();\n\tif (this->m->crypt_filters.count(filter) != 0)\n\t{\n\t    return this->m->crypt_filters[filter];\n\t}\n\telse if (filter == \"/Identity\")\n\t{\n\t    return e_none;\n\t}\n\telse\n\t{\n\t    return e_unknown;\n\t}\n    }\n    else\n    {\n\t// Default: /Identity\n\treturn e_none;\n    }\n}\n\nvoid\nQPDF::initializeEncryption()\n{\n    if (this->m->encryption_initialized)\n    {\n\treturn;\n    }\n    this->m->encryption_initialized = true;\n\n    // After we initialize encryption parameters, we must used stored\n    // key information and never look at /Encrypt again.  Otherwise,\n    // things could go wrong if someone mutates the encryption\n    // dictionary.\n\n    if (! this->m->trailer.hasKey(\"/Encrypt\"))\n    {\n\treturn;\n    }\n\n    // Go ahead and set this->m->encrypted here.  That way, isEncrypted\n    // will return true even if there were errors reading the\n    // encryption dictionary.\n    this->m->encrypted = true;\n\n    std::string id1;\n    QPDFObjectHandle id_obj = this->m->trailer.getKey(\"/ID\");\n    if ((id_obj.isArray() &&\n         (id_obj.getArrayNItems() == 2) &&\n         id_obj.getArrayItem(0).isString()))\n    {\n        id1 = id_obj.getArrayItem(0).getStringValue();\n    }\n    else\n    {\n        // Treating a missing ID as the empty string enables qpdf to\n        // decrypt some invalid encrypted files with no /ID that\n        // poppler can read but Adobe Reader can't.\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                     \"trailer\", this->m->file->getLastOffset(),\n                     \"invalid /ID in trailer dictionary\"));\n    }\n\n    QPDFObjectHandle encryption_dict = this->m->trailer.getKey(\"/Encrypt\");\n    if (! encryption_dict.isDictionary())\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      this->m->last_object_description,\n\t\t      this->m->file->getLastOffset(),\n\t\t      \"/Encrypt in trailer dictionary is not a dictionary\");\n    }\n\n    if (! (encryption_dict.getKey(\"/Filter\").isName() &&\n\t   (encryption_dict.getKey(\"/Filter\").getName() == \"/Standard\")))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"unsupported encryption filter\");\n    }\n    if (! encryption_dict.getKey(\"/SubFilter\").isNull())\n    {\n\twarn(QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t     \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t     \"file uses encryption SubFilters,\"\n\t\t     \" which qpdf does not support\"));\n    }\n\n    if (! (encryption_dict.getKey(\"/V\").isInteger() &&\n\t   encryption_dict.getKey(\"/R\").isInteger() &&\n\t   encryption_dict.getKey(\"/O\").isString() &&\n\t   encryption_dict.getKey(\"/U\").isString() &&\n\t   encryption_dict.getKey(\"/P\").isInteger()))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"some encryption dictionary parameters are missing \"\n\t\t      \"or the wrong type\");\n    }\n\n    int V = encryption_dict.getKey(\"/V\").getIntValue();\n    int R = encryption_dict.getKey(\"/R\").getIntValue();\n    std::string O = encryption_dict.getKey(\"/O\").getStringValue();\n    std::string U = encryption_dict.getKey(\"/U\").getStringValue();\n    unsigned int P = encryption_dict.getKey(\"/P\").getIntValue();\n\n    // If supporting new encryption R/V values, remember to update\n    // error message inside this if statement.\n    if (! (((R >= 2) && (R <= 6)) &&\n\t   ((V == 1) || (V == 2) || (V == 4) || (V == 5))))\n    {\n\tthrow QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"Unsupported /R or /V in encryption dictionary; R = \" +\n                      QUtil::int_to_string(R) + \" (max 6), V = \" +\n                      QUtil::int_to_string(V) + \" (max 5)\");\n    }\n\n    this->m->encryption_V = V;\n    this->m->encryption_R = R;\n\n    // OE, UE, and Perms are only present if V >= 5.\n    std::string OE;\n    std::string UE;\n    std::string Perms;\n\n    if (V < 5)\n    {\n        pad_short_parameter(O, key_bytes);\n        pad_short_parameter(U, key_bytes);\n        if (! ((O.length() == key_bytes) && (U.length() == key_bytes)))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for /O and/or /U in \"\n                          \"encryption dictionary\");\n        }\n    }\n    else\n    {\n        if (! (encryption_dict.getKey(\"/OE\").isString() &&\n               encryption_dict.getKey(\"/UE\").isString() &&\n               encryption_dict.getKey(\"/Perms\").isString()))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"some V=5 encryption dictionary parameters are \"\n                          \"missing or the wrong type\");\n        }\n        OE = encryption_dict.getKey(\"/OE\").getStringValue();\n        UE = encryption_dict.getKey(\"/UE\").getStringValue();\n        Perms = encryption_dict.getKey(\"/Perms\").getStringValue();\n\n        pad_short_parameter(O, OU_key_bytes_V5);\n        pad_short_parameter(U, OU_key_bytes_V5);\n        pad_short_parameter(OE, OUE_key_bytes_V5);\n        pad_short_parameter(UE, OUE_key_bytes_V5);\n        pad_short_parameter(Perms, Perms_key_bytes_V5);\n        if ((O.length() < OU_key_bytes_V5) ||\n            (U.length() < OU_key_bytes_V5) ||\n            (OE.length() < OUE_key_bytes_V5) ||\n            (UE.length() < OUE_key_bytes_V5) ||\n            (Perms.length() < Perms_key_bytes_V5))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for some of\"\n                          \" /O, /U, /OE, /UE, or /Perms in\"\n                          \" encryption dictionary\");\n        }\n    }\n\n    int Length = 40;\n    if (encryption_dict.getKey(\"/Length\").isInteger())\n    {\n\tLength = encryption_dict.getKey(\"/Length\").getIntValue();\n\tif ((Length % 8) || (Length < 40) || (Length > 256))\n\t{\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t  \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n\t\t\t  \"invalid /Length value in encryption dictionary\");\n\t}\n    }\n\n    this->m->encrypt_metadata = true;\n    if ((V >= 4) && (encryption_dict.getKey(\"/EncryptMetadata\").isBool()))\n    {\n\tthis->m->encrypt_metadata =\n\t    encryption_dict.getKey(\"/EncryptMetadata\").getBoolValue();\n    }\n\n    if ((V == 4) || (V == 5))\n    {\n\tQPDFObjectHandle CF = encryption_dict.getKey(\"/CF\");\n\tstd::set<std::string> keys = CF.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    std::string const& filter = *iter;\n\t    QPDFObjectHandle cdict = CF.getKey(filter);\n\t    if (cdict.isDictionary())\n\t    {\n\t\tencryption_method_e method = e_none;\n\t\tif (cdict.getKey(\"/CFM\").isName())\n\t\t{\n\t\t    std::string method_name = cdict.getKey(\"/CFM\").getName();\n\t\t    if (method_name == \"/V2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM V2\");\n\t\t\tmethod = e_rc4;\n\t\t    }\n\t\t    else if (method_name == \"/AESV2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV2\");\n\t\t\tmethod = e_aes;\n\t\t    }\n\t\t    else if (method_name == \"/AESV3\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV3\");\n\t\t\tmethod = e_aesv3;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Don't complain now -- maybe we won't need\n\t\t\t// to reference this type.\n\t\t\tmethod = e_unknown;\n\t\t    }\n\t\t}\n\t\tthis->m->crypt_filters[filter] = method;\n\t    }\n\t}\n\n\tQPDFObjectHandle StmF = encryption_dict.getKey(\"/StmF\");\n\tQPDFObjectHandle StrF = encryption_dict.getKey(\"/StrF\");\n\tQPDFObjectHandle EFF = encryption_dict.getKey(\"/EFF\");\n\tthis->m->cf_stream = interpretCF(StmF);\n\tthis->m->cf_string = interpretCF(StrF);\n\tif (EFF.isName())\n\t{\n\t    this->m->cf_file = interpretCF(EFF);\n\t}\n\telse\n\t{\n\t    this->m->cf_file = this->m->cf_stream;\n\t}\n    }\n\n    EncryptionData data(V, R, Length / 8, P, O, U, OE, UE, Perms,\n                        id1, this->m->encrypt_metadata);\n    if (check_owner_password(\n\t    this->m->user_password, this->m->provided_password, data))\n    {\n\t// password supplied was owner password; user_password has\n\t// been initialized for V < 5\n    }\n    else if (check_user_password(this->m->provided_password, data))\n    {\n\tthis->m->user_password = this->m->provided_password;\n    }\n    else\n    {\n\tthrow QPDFExc(qpdf_e_password, this->m->file->getName(),\n\t\t      \"\", 0, \"invalid password\");\n    }\n\n    if (V < 5)\n    {\n        // For V < 5, the user password is encrypted with the owner\n        // password, and the user password is always used for\n        // computing the encryption key.\n        this->m->encryption_key = compute_encryption_key(\n            this->m->user_password, data);\n    }\n    else\n    {\n        // For V >= 5, either password can be used independently to\n        // compute the encryption key, and neither password can be\n        // used to recover the other.\n        bool perms_valid;\n        this->m->encryption_key = recover_encryption_key_with_password(\n            this->m->provided_password, data, perms_valid);\n        if (! perms_valid)\n        {\n            warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                         \"encryption dictionary\",\n                         this->m->file->getLastOffset(),\n                         \"/Perms field in encryption dictionary\"\n                         \" doesn't match expected value\"));\n        }\n    }\n}\n\nstd::string\nQPDF::getKeyForObject(int objid, int generation, bool use_aes)\n{\n    if (! this->m->encrypted)\n    {\n\tthrow std::logic_error(\n\t    \"request for encryption key in non-encrypted PDF\");\n    }\n\n    if (! ((objid == this->m->cached_key_objid) &&\n\t   (generation == this->m->cached_key_generation)))\n    {\n\tthis->m->cached_object_encryption_key =\n\t    compute_data_key(this->m->encryption_key, objid, generation,\n                             use_aes, this->m->encryption_V,\n                             this->m->encryption_R);\n\tthis->m->cached_key_objid = objid;\n\tthis->m->cached_key_generation = generation;\n    }\n\n    return this->m->cached_object_encryption_key;\n}\n\nvoid\nQPDF::decryptString(std::string& str, int objid, int generation)\n{\n    if (objid == 0)\n    {\n\treturn;\n    }\n    bool use_aes = false;\n    if (this->m->encryption_V >= 4)\n    {\n\tswitch (this->m->cf_string)\n\t{\n\t  case e_none:\n\t    return;\n\n\t  case e_aes:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_aesv3:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_rc4:\n\t    break;\n\n\t  default:\n\t    warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t this->m->last_object_description,\n\t\t\t this->m->file->getLastOffset(),\n\t\t\t \"unknown encryption filter for strings\"\n\t\t\t \" (check /StrF in /Encrypt dictionary);\"\n\t\t\t \" strings may be decrypted improperly\"));\n\t    // To avoid repeated warnings, reset cf_string.  Assume\n\t    // we'd want to use AES if V == 4.\n\t    this->m->cf_string = e_aes;\n\t    break;\n\t}\n    }\n\n    std::string key = getKeyForObject(objid, generation, use_aes);\n    try\n    {\n\tif (use_aes)\n\t{\n\t    QTC::TC(\"qpdf\", \"QPDF_encryption aes decode string\");\n\t    Pl_Buffer bufpl(\"decrypted string\");\n\t    Pl_AES_PDF pl(\"aes decrypt string\", &bufpl, false,\n\t\t\t  QUtil::unsigned_char_pointer(key),\n                          key.length());\n\t    pl.write(QUtil::unsigned_char_pointer(str), str.length());\n\t    pl.finish();\n\t    PointerHolder<Buffer> buf = bufpl.getBuffer();\n\t    str = std::string(reinterpret_cast<char*>(buf->getBuffer()),\n                              buf->getSize());\n\t}\n\telse\n\t{\n\t    QTC::TC(\"qpdf\", \"QPDF_encryption rc4 decode string\");\n\t    unsigned int vlen = str.length();\n\t    // Using PointerHolder guarantees that tmp will\n\t    // be freed even if rc4.process throws an exception.\n\t    PointerHolder<char> tmp(true, QUtil::copy_string(str));\n\t    RC4 rc4(QUtil::unsigned_char_pointer(key), key.length());\n\t    rc4.process(QUtil::unsigned_char_pointer(tmp.getPointer()), vlen);\n\t    str = std::string(tmp.getPointer(), vlen);\n\t}\n    }\n    catch (QPDFExc&)\n    {\n\tthrow;\n    }\n    catch (std::runtime_error& e)\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      this->m->last_object_description,\n\t\t      this->m->file->getLastOffset(),\n\t\t      \"error decrypting string for object \" +\n\t\t      QUtil::int_to_string(objid) + \" \" +\n\t\t      QUtil::int_to_string(generation) + \": \" + e.what());\n    }\n}\n\nvoid\nQPDF::decryptStream(Pipeline*& pipeline, int objid, int generation,\n\t\t    QPDFObjectHandle& stream_dict,\n\t\t    std::vector<PointerHolder<Pipeline> >& heap)\n{\n    std::string type;\n    if (stream_dict.getKey(\"/Type\").isName())\n    {\n\ttype = stream_dict.getKey(\"/Type\").getName();\n    }\n    if (type == \"/XRef\")\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption xref stream from encrypted file\");\n\treturn;\n    }\n    bool use_aes = false;\n    if (this->m->encryption_V >= 4)\n    {\n\tencryption_method_e method = e_unknown;\n\tstd::string method_source = \"/StmF from /Encrypt dictionary\";\n\n\tif (stream_dict.getKey(\"/Filter\").isOrHasName(\"/Crypt\"))\n        {\n            if (stream_dict.getKey(\"/DecodeParms\").isDictionary())\n            {\n                QPDFObjectHandle decode_parms =\n                    stream_dict.getKey(\"/DecodeParms\");\n                if (decode_parms.getKey(\"/Type\").isName() &&\n                    (decode_parms.getKey(\"/Type\").getName() ==\n                     \"/CryptFilterDecodeParms\"))\n                {\n                    QTC::TC(\"qpdf\", \"QPDF_encryption stream crypt filter\");\n                    method = interpretCF(decode_parms.getKey(\"/Name\"));\n                    method_source = \"stream's Crypt decode parameters\";\n                }\n            }\n            else if (stream_dict.getKey(\"/DecodeParms\").isArray() &&\n                     stream_dict.getKey(\"/Filter\").isArray())\n            {\n                QPDFObjectHandle filter = stream_dict.getKey(\"/Filter\");\n                QPDFObjectHandle decode = stream_dict.getKey(\"/DecodeParms\");\n                if (filter.getArrayNItems() == decode.getArrayNItems())\n                {\n                    for (int i = 0; i < filter.getArrayNItems(); ++i)\n                    {\n                        if (filter.getArrayItem(i).isName() &&\n                            (filter.getArrayItem(i).getName() == \"/Crypt\"))\n                        {\n                            QPDFObjectHandle crypt_params =\n                                decode.getArrayItem(i);\n                            if (crypt_params.isDictionary() &&\n                                crypt_params.getKey(\"/Name\").isName())\n                            {\n                                QTC::TC(\"qpdf\", \"QPDF_encrypt crypt array\");\n                                method = interpretCF(\n                                    crypt_params.getKey(\"/Name\"));\n                                method_source = \"stream's Crypt \"\n                                    \"decode parameters (array)\";\n                            }\n                        }\n                    }\n                }\n            }\n\t}\n\n\tif (method == e_unknown)\n\t{\n\t    if ((! this->m->encrypt_metadata) && (type == \"/Metadata\"))\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDF_encryption cleartext metadata\");\n\t\tmethod = e_none;\n\t    }\n\t    else\n\t    {\n                if (this->m->attachment_streams.count(\n                        QPDFObjGen(objid, generation)) > 0)\n                {\n                    method = this->m->cf_file;\n                }\n                else\n                {\n                    method = this->m->cf_stream;\n                }\n\t    }\n\t}\n\tuse_aes = false;\n\tswitch (method)\n\t{\n\t  case e_none:\n\t    return;\n\t    break;\n\n\t  case e_aes:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_aesv3:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_rc4:\n\t    break;\n\n\t  default:\n\t    // filter local to this stream.\n\t    warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t this->m->last_object_description,\n\t\t\t this->m->file->getLastOffset(),\n\t\t\t \"unknown encryption filter for streams\"\n\t\t\t \" (check \" + method_source + \");\"\n\t\t\t \" streams may be decrypted improperly\"));\n\t    // To avoid repeated warnings, reset cf_stream.  Assume\n\t    // we'd want to use AES if V == 4.\n\t    this->m->cf_stream = e_aes;\n\t    break;\n\t}\n    }\n    std::string key = getKeyForObject(objid, generation, use_aes);\n    if (use_aes)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption aes decode stream\");\n\tpipeline = new Pl_AES_PDF(\"AES stream decryption\", pipeline,\n\t\t\t\t  false, QUtil::unsigned_char_pointer(key),\n                                  key.length());\n    }\n    else\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption rc4 decode stream\");\n\tpipeline = new Pl_RC4(\"RC4 stream decryption\", pipeline,\n\t\t\t      QUtil::unsigned_char_pointer(key),\n                              key.length());\n    }\n    heap.push_back(pipeline);\n}\n\nvoid\nQPDF::compute_encryption_O_U(\n    char const* user_password, char const* owner_password,\n    int V, int R, int key_len, int P, bool encrypt_metadata,\n    std::string const& id1, std::string& O, std::string& U)\n{\n    if (V >= 5)\n    {\n\tthrow std::logic_error(\n\t    \"compute_encryption_O_U called for file with V >= 5\");\n    }\n    EncryptionData data(V, R, key_len, P, \"\", \"\", \"\", \"\", \"\",\n                        id1, encrypt_metadata);\n    data.setO(compute_O_value(user_password, owner_password, data));\n    O = data.getO();\n    data.setU(compute_U_value(user_password, data));\n    U = data.getU();\n}\n\nvoid\nQPDF::compute_encryption_parameters_V5(\n    char const* user_password, char const* owner_password,\n    int V, int R, int key_len, int P, bool encrypt_metadata,\n    std::string const& id1,\n    std::string& encryption_key,\n    std::string& O, std::string& U,\n    std::string& OE, std::string& UE, std::string& Perms)\n{\n    EncryptionData data(V, R, key_len, P, \"\", \"\", \"\", \"\", \"\",\n                        id1, encrypt_metadata);\n    unsigned char k[key_bytes];\n    QUtil::initializeWithRandomBytes(k, key_bytes);\n    encryption_key = std::string(reinterpret_cast<char*>(k), key_bytes);\n    compute_U_UE_value_V5(user_password, encryption_key, data, U, UE);\n    compute_O_OE_value_V5(owner_password, encryption_key, data, U, O, OE);\n    Perms = compute_Perms_value_V5(encryption_key, data);\n    data.setV5EncryptionParameters(O, OE, U, UE, Perms);\n}\n\nstd::string const&\nQPDF::getPaddedUserPassword() const\n{\n    return this->m->user_password;\n}\n\nstd::string\nQPDF::getTrimmedUserPassword() const\n{\n    std::string result = this->m->user_password;\n    trim_user_password(result);\n    return result;\n}\n\nstd::string\nQPDF::getEncryptionKey() const\n{\n    return this->m->encryption_key;\n}\n\nbool\nQPDF::isEncrypted() const\n{\n    return this->m->encrypted;\n}\n\nbool\nQPDF::isEncrypted(int& R, int& P)\n{\n    int V;\n    encryption_method_e stream, string, file;\n    return isEncrypted(R, P, V, stream, string, file);\n}\n\nbool\nQPDF::isEncrypted(int& R, int& P, int& V,\n                  encryption_method_e& stream_method,\n                  encryption_method_e& string_method,\n                  encryption_method_e& file_method)\n{\n    if (this->m->encrypted)\n    {\n\tQPDFObjectHandle trailer = getTrailer();\n\tQPDFObjectHandle encrypt = trailer.getKey(\"/Encrypt\");\n\tQPDFObjectHandle Pkey = encrypt.getKey(\"/P\");\n\tQPDFObjectHandle Rkey = encrypt.getKey(\"/R\");\n        QPDFObjectHandle Vkey = encrypt.getKey(\"/V\");\n\tP = Pkey.getIntValue();\n\tR = Rkey.getIntValue();\n        V = Vkey.getIntValue();\n        stream_method = this->m->cf_stream;\n        string_method = this->m->cf_stream;\n        file_method = this->m->cf_file;\n\treturn true;\n    }\n    else\n    {\n\treturn false;\n    }\n}\n\nstatic bool\nis_bit_set(int P, int bit)\n{\n    // Bits in P are numbered from 1 in the spec\n    return (P & (1 << (bit - 1)));\n}\n\nbool\nQPDF::allowAccessibility()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 5);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 10);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowExtractAll()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 5);\n    }\n    return status;\n}\n\nbool\nQPDF::allowPrintLowRes()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 3);\n    }\n    return status;\n}\n\nbool\nQPDF::allowPrintHighRes()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 3);\n\tif ((R >= 3) && (! is_bit_set(P, 12)))\n\t{\n\t    status = false;\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAssembly()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 4);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 11);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyForm()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 6);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 9);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAnnotation()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 6);\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyOther()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 4);\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAll()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = (is_bit_set(P, 4) && is_bit_set(P, 6));\n\tif (R >= 3)\n\t{\n\t    status = status && (is_bit_set(P, 9) && is_bit_set(P, 11));\n\t}\n    }\n    return status;\n}\n"], "fixing_code": ["// This file implements methods from the QPDF class that involve\n// encryption.\n\n#include <qpdf/QPDF.hh>\n\n#include <qpdf/QPDFExc.hh>\n\n#include <qpdf/QTC.hh>\n#include <qpdf/QUtil.hh>\n#include <qpdf/Pl_RC4.hh>\n#include <qpdf/Pl_AES_PDF.hh>\n#include <qpdf/Pl_Buffer.hh>\n#include <qpdf/Pl_SHA2.hh>\n#include <qpdf/RC4.hh>\n#include <qpdf/MD5.hh>\n\n#include <algorithm>\n#include <assert.h>\n#include <string.h>\n\nstatic unsigned char const padding_string[] = {\n    0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,\n    0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,\n    0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,\n    0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a\n};\n\nstatic unsigned int const key_bytes = 32;\n\n// V4 key lengths apply to V <= 4\nstatic unsigned int const OU_key_bytes_V4 = sizeof(MD5::Digest);\n\nstatic unsigned int const OU_key_bytes_V5 = 48;\nstatic unsigned int const OUE_key_bytes_V5 = 32;\nstatic unsigned int const Perms_key_bytes_V5 = 16;\n\nint\nQPDF::EncryptionData::getV() const\n{\n    return this->V;\n}\n\nint\nQPDF::EncryptionData::getR() const\n{\n    return this->R;\n}\n\nint\nQPDF::EncryptionData::getLengthBytes() const\n{\n    return this->Length_bytes;\n}\n\nint\nQPDF::EncryptionData::getP() const\n{\n    return this->P;\n}\n\nstd::string const&\nQPDF::EncryptionData::getO() const\n{\n    return this->O;\n}\n\nstd::string const&\nQPDF::EncryptionData::getU() const\n{\n    return this->U;\n}\n\nstd::string const&\nQPDF::EncryptionData::getOE() const\n{\n    return this->OE;\n}\n\nstd::string const&\nQPDF::EncryptionData::getUE() const\n{\n    return this->UE;\n}\n\nstd::string const&\nQPDF::EncryptionData::getPerms() const\n{\n    return this->Perms;\n}\n\nstd::string const&\nQPDF::EncryptionData::getId1() const\n{\n    return this->id1;\n}\n\nbool\nQPDF::EncryptionData::getEncryptMetadata() const\n{\n    return this->encrypt_metadata;\n}\n\nvoid\nQPDF::EncryptionData::setO(std::string const& O)\n{\n    this->O = O;\n}\n\nvoid\nQPDF::EncryptionData::setU(std::string const& U)\n{\n    this->U = U;\n}\n\nvoid\nQPDF::EncryptionData::setV5EncryptionParameters(\n    std::string const& O,\n    std::string const& OE,\n    std::string const& U,\n    std::string const& UE,\n    std::string const& Perms)\n{\n    this->O = O;\n    this->OE = OE;\n    this->U = U;\n    this->UE = UE;\n    this->Perms = Perms;\n}\n\nstatic void\npad_or_truncate_password_V4(std::string const& password, char k1[key_bytes])\n{\n    int password_bytes = std::min(static_cast<size_t>(key_bytes),\n                                  password.length());\n    int pad_bytes = key_bytes - password_bytes;\n    memcpy(k1, password.c_str(), password_bytes);\n    memcpy(k1 + password_bytes, padding_string, pad_bytes);\n}\n\nvoid\nQPDF::trim_user_password(std::string& user_password)\n{\n    // Although unnecessary, this routine trims the padding string\n    // from the end of a user password.  Its only purpose is for\n    // recovery of user passwords which is done in the test suite.\n    char const* cstr = user_password.c_str();\n    size_t len = user_password.length();\n    if (len < key_bytes)\n    {\n\treturn;\n    }\n\n    char const* p1 = cstr;\n    char const* p2 = 0;\n    while ((p2 = strchr(p1, '\\x28')) != 0)\n    {\n\tif (memcmp(p2, padding_string, len - (p2 - cstr)) == 0)\n\t{\n\t    user_password = user_password.substr(0, p2 - cstr);\n\t    return;\n\t}\n        else\n        {\n            QTC::TC(\"qpdf\", \"QPDF_encryption skip 0x28\");\n            p1 = p2 + 1;\n        }\n    }\n}\n\nstatic std::string\npad_or_truncate_password_V4(std::string const& password)\n{\n    char k1[key_bytes];\n    pad_or_truncate_password_V4(password, k1);\n    return std::string(k1, key_bytes);\n}\n\nstatic std::string\ntruncate_password_V5(std::string const& password)\n{\n    return password.substr(\n        0, std::min(static_cast<size_t>(127), password.length()));\n}\n\nstatic void\niterate_md5_digest(MD5& md5, MD5::Digest& digest, int iterations)\n{\n    md5.digest(digest);\n\n    for (int i = 0; i < iterations; ++i)\n    {\n\tMD5 m;\n\tm.encodeDataIncrementally(reinterpret_cast<char*>(digest),\n                                  sizeof(digest));\n\tm.digest(digest);\n    }\n}\n\n\nstatic void\niterate_rc4(unsigned char* data, int data_len,\n\t    unsigned char* okey, int key_len,\n\t    int iterations, bool reverse)\n{\n    unsigned char* key = new unsigned char[key_len];\n    for (int i = 0; i < iterations; ++i)\n    {\n\tint const xor_value = (reverse ? iterations - 1 - i : i);\n\tfor (int j = 0; j < key_len; ++j)\n\t{\n\t    key[j] = okey[j] ^ xor_value;\n\t}\n\tRC4 rc4(key, key_len);\n\trc4.process(data, data_len);\n    }\n    delete [] key;\n}\n\nstatic std::string\nprocess_with_aes(std::string const& key,\n                 bool encrypt,\n                 std::string const& data,\n                 size_t outlength = 0,\n                 unsigned int repetitions = 1,\n                 unsigned char const* iv = 0,\n                 size_t iv_length = 0)\n{\n    Pl_Buffer buffer(\"buffer\");\n    Pl_AES_PDF aes(\"aes\", &buffer, encrypt,\n                   QUtil::unsigned_char_pointer(key),\n                   key.length());\n    if (iv)\n    {\n        aes.setIV(iv, iv_length);\n    }\n    else\n    {\n        aes.useZeroIV();\n    }\n    aes.disablePadding();\n    for (unsigned int i = 0; i < repetitions; ++i)\n    {\n        aes.write(QUtil::unsigned_char_pointer(data), data.length());\n    }\n    aes.finish();\n    PointerHolder<Buffer> bufp = buffer.getBuffer();\n    if (outlength == 0)\n    {\n        outlength = bufp->getSize();\n    }\n    else\n    {\n        outlength = std::min(outlength, bufp->getSize());\n    }\n    return std::string(reinterpret_cast<char*>(bufp->getBuffer()), outlength);\n}\n\nstatic std::string\nhash_V5(std::string const& password,\n        std::string const& salt,\n        std::string const& udata,\n        QPDF::EncryptionData const& data)\n{\n    Pl_SHA2 hash(256);\n    hash.write(QUtil::unsigned_char_pointer(password), password.length());\n    hash.write(QUtil::unsigned_char_pointer(salt), salt.length());\n    hash.write(QUtil::unsigned_char_pointer(udata), udata.length());\n    hash.finish();\n    std::string K = hash.getRawDigest();\n\n    std::string result;\n    if (data.getR() < 6)\n    {\n        result = K;\n    }\n    else\n    {\n        // Algorithm 2.B from ISO 32000-1 chapter 7: Computing a hash\n\n        int round_number = 0;\n        bool done = false;\n        while (! done)\n        {\n            // The hash algorithm has us setting K initially to the R5\n            // value and then repeating a series of steps 64 times\n            // before starting with the termination case testing.  The\n            // wording of the specification is very unclear as to the\n            // exact number of times it should be run since the\n            // wording about whether the initial setup counts as round\n            // 0 or not is ambiguous.  This code counts the initial\n            // setup (R5) value as round 0, which appears to be\n            // correct.  This was determined to be correct by\n            // increasing or decreasing the number of rounds by 1 or 2\n            // from this value and generating 20 test files.  In this\n            // interpretation, all the test files worked with Adobe\n            // Reader X.  In the other configurations, many of the\n            // files did not work, and we were accurately able to\n            // predict which files didn't work by looking at the\n            // conditions under which we terminated repetition.\n\n            ++round_number;\n            std::string K1 = password + K + udata;\n            assert(K.length() >= 32);\n            std::string E = process_with_aes(\n                K.substr(0, 16), true, K1, 0, 64,\n                QUtil::unsigned_char_pointer(K.substr(16, 16)), 16);\n\n            // E_mod_3 is supposed to be mod 3 of the first 16 bytes\n            // of E taken as as a (128-bit) big-endian number.  Since\n            // (xy mod n) is equal to ((x mod n) + (y mod n)) mod n\n            // and since 256 mod n is 1, we can just take the sums of\n            // the the mod 3s of each byte to get the same result.\n            int E_mod_3 = 0;\n            for (unsigned int i = 0; i < 16; ++i)\n            {\n                E_mod_3 += static_cast<unsigned char>(E.at(i));\n            }\n            E_mod_3 %= 3;\n            int next_hash = ((E_mod_3 == 0) ? 256 :\n                             (E_mod_3 == 1) ? 384 :\n                             512);\n            Pl_SHA2 hash(next_hash);\n            hash.write(QUtil::unsigned_char_pointer(E), E.length());\n            hash.finish();\n            K = hash.getRawDigest();\n\n            if (round_number >= 64)\n            {\n                unsigned int ch = static_cast<unsigned char>(*(E.rbegin()));\n\n                if (ch <= static_cast<unsigned int>(round_number - 32))\n                {\n                    done = true;\n                }\n            }\n        }\n        result = K.substr(0, 32);\n    }\n\n    return result;\n}\n\nstatic\nvoid pad_short_parameter(std::string& param, unsigned int max_len)\n{\n    if (param.length() < max_len)\n    {\n        QTC::TC(\"qpdf\", \"QPDF_encryption pad short parameter\");\n        param.append(max_len - param.length(), '\\0');\n    }\n}\n\nstd::string\nQPDF::compute_data_key(std::string const& encryption_key,\n\t\t       int objid, int generation, bool use_aes,\n                       int encryption_V, int encryption_R)\n{\n    // Algorithm 3.1 from the PDF 1.7 Reference Manual\n\n    std::string result = encryption_key;\n\n    if (encryption_V >= 5)\n    {\n        // Algorithm 3.1a (PDF 1.7 extension level 3): just use\n        // encryption key straight.\n        return result;\n    }\n\n    // Append low three bytes of object ID and low two bytes of generation\n    result += static_cast<char>(objid & 0xff);\n    result += static_cast<char>((objid >> 8) & 0xff);\n    result += static_cast<char>((objid >> 16) & 0xff);\n    result += static_cast<char>(generation & 0xff);\n    result += static_cast<char>((generation >> 8) & 0xff);\n    if (use_aes)\n    {\n\tresult += \"sAlT\";\n    }\n\n    MD5 md5;\n    md5.encodeDataIncrementally(result.c_str(), result.length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    return std::string(reinterpret_cast<char*>(digest),\n\t\t       std::min(result.length(), static_cast<size_t>(16)));\n}\n\nstd::string\nQPDF::compute_encryption_key(\n    std::string const& password, EncryptionData const& data)\n{\n    if (data.getV() >= 5)\n    {\n        // For V >= 5, the encryption key is generated and stored in\n        // the file, encrypted separately with both user and owner\n        // passwords.\n        return recover_encryption_key_with_password(password, data);\n    }\n    else\n    {\n        // For V < 5, the encryption key is derived from the user\n        // password.\n        return compute_encryption_key_from_password(password, data);\n    }\n}\n\nstd::string\nQPDF::compute_encryption_key_from_password(\n    std::string const& password, EncryptionData const& data)\n{\n    // Algorithm 3.2 from the PDF 1.7 Reference Manual\n\n    // This code does not properly handle Unicode passwords.\n    // Passwords are supposed to be converted from OS codepage\n    // characters to PDFDocEncoding.  Unicode passwords are supposed\n    // to be converted to OS codepage before converting to\n    // PDFDocEncoding.  We instead require the password to be\n    // presented in its final form.\n\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(password).c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getO().c_str(), key_bytes);\n    char pbytes[4];\n    int P = data.getP();\n    pbytes[0] = static_cast<char>(P & 0xff);\n    pbytes[1] = static_cast<char>((P >> 8) & 0xff);\n    pbytes[2] = static_cast<char>((P >> 16) & 0xff);\n    pbytes[3] = static_cast<char>((P >> 24) & 0xff);\n    md5.encodeDataIncrementally(pbytes, 4);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    if ((data.getR() >= 4) && (! data.getEncryptMetadata()))\n    {\n\tchar bytes[4];\n\tmemset(bytes, 0xff, 4);\n\tmd5.encodeDataIncrementally(bytes, 4);\n    }\n    MD5::Digest digest;\n    iterate_md5_digest(md5, digest, ((data.getR() >= 3) ? 50 : 0));\n    return std::string(reinterpret_cast<char*>(digest),\n                       std::min(static_cast<int>(sizeof(digest)),\n                                data.getLengthBytes()));\n}\n\nstatic void\ncompute_O_rc4_key(std::string const& user_password,\n\t\t  std::string const& owner_password,\n\t\t  QPDF::EncryptionData const& data,\n\t\t  unsigned char key[OU_key_bytes_V4])\n{\n    if (data.getV() >= 5)\n    {\n\tthrow std::logic_error(\n\t    \"compute_O_rc4_key called for file with V >= 5\");\n    }\n    std::string password = owner_password;\n    if (password.empty())\n    {\n\tpassword = user_password;\n    }\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(password).c_str(), key_bytes);\n    MD5::Digest digest;\n    iterate_md5_digest(md5, digest, ((data.getR() >= 3) ? 50 : 0));\n    memcpy(key, digest, OU_key_bytes_V4);\n}\n\nstatic std::string\ncompute_O_value(std::string const& user_password,\n\t\tstd::string const& owner_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    // Algorithm 3.3 from the PDF 1.7 Reference Manual\n\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    std::string k1(reinterpret_cast<char*>(O_key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}\n\nstatic\nstd::string\ncompute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}\n\nstatic\nstd::string\ncompute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.5 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    // pad with arbitrary data -- make it consistent for the sake of\n    // testing\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}\n\nstatic std::string\ncompute_U_value(std::string const& user_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    if (data.getR() >= 3)\n    {\n\treturn compute_U_value_R3(user_password, data);\n    }\n\n    return compute_U_value_R2(user_password, data);\n}\n\nstatic bool\ncheck_user_password_V4(std::string const& user_password,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.6 from the PDF 1.7 Reference Manual\n\n    std::string u_value = compute_U_value(user_password, data);\n    int to_compare = ((data.getR() >= 3) ? sizeof(MD5::Digest)\n                      : key_bytes);\n    return (memcmp(data.getU().c_str(), u_value.c_str(), to_compare) == 0);\n}\n\nstatic bool\ncheck_user_password_V5(std::string const& user_password,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.11 from the PDF 1.7 extension level 3\n\n    std::string user_data = data.getU().substr(0, 32);\n    std::string validation_salt = data.getU().substr(32, 8);\n    std::string password = truncate_password_V5(user_password);\n    return (hash_V5(password, validation_salt, \"\", data) == user_data);\n}\n\nstatic bool\ncheck_user_password(std::string const& user_password,\n\t\t    QPDF::EncryptionData const& data)\n{\n    if (data.getV() < 5)\n    {\n        return check_user_password_V4(user_password, data);\n    }\n    else\n    {\n        return check_user_password_V5(user_password, data);\n    }\n}\n\nstatic bool\ncheck_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}\n\nstatic bool\ncheck_owner_password_V5(std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.12 from the PDF 1.7 extension level 3\n\n    std::string user_data = data.getU().substr(0, 48);\n    std::string owner_data = data.getO().substr(0, 32);\n    std::string validation_salt = data.getO().substr(32, 8);\n    std::string password = truncate_password_V5(owner_password);\n    return (hash_V5(password, validation_salt, user_data,\n                    data) == owner_data);\n}\n\nstatic bool\ncheck_owner_password(std::string& user_password,\n\t\t     std::string const& owner_password,\n\t\t     QPDF::EncryptionData const& data)\n{\n    if (data.getV() < 5)\n    {\n        return check_owner_password_V4(user_password, owner_password, data);\n    }\n    else\n    {\n        return check_owner_password_V5(owner_password, data);\n    }\n}\n\nstd::string\nQPDF::recover_encryption_key_with_password(\n    std::string const& password, EncryptionData const& data)\n{\n    // Disregard whether Perms is valid.\n    bool disregard;\n    return recover_encryption_key_with_password(password, data, disregard);\n}\n\nstatic void\ncompute_U_UE_value_V5(std::string const& user_password,\n                      std::string const& encryption_key,\n                      QPDF::EncryptionData const& data,\n                      std::string& U, std::string& UE)\n{\n    // Algorithm 3.8 from the PDF 1.7 extension level 3\n    char k[16];\n    QUtil::initializeWithRandomBytes(\n        QUtil::unsigned_char_pointer(k), sizeof(k));\n    std::string validation_salt(k, 8);\n    std::string key_salt(k + 8, 8);\n    U = hash_V5(user_password, validation_salt, \"\", data) +\n        validation_salt + key_salt;\n    std::string intermediate_key = hash_V5(user_password, key_salt, \"\", data);\n    UE = process_with_aes(intermediate_key, true, encryption_key);\n}\n\nstatic void\ncompute_O_OE_value_V5(std::string const& owner_password,\n                      std::string const& encryption_key,\n                      QPDF::EncryptionData const& data,\n                      std::string const& U,\n                      std::string& O, std::string& OE)\n{\n    // Algorithm 3.9 from the PDF 1.7 extension level 3\n    char k[16];\n    QUtil::initializeWithRandomBytes(\n        QUtil::unsigned_char_pointer(k), sizeof(k));\n    std::string validation_salt(k, 8);\n    std::string key_salt(k + 8, 8);\n    O = hash_V5(owner_password, validation_salt, U, data) +\n        validation_salt + key_salt;\n    std::string intermediate_key = hash_V5(owner_password, key_salt, U, data);\n    OE = process_with_aes(intermediate_key, true, encryption_key);\n}\n\nvoid\ncompute_Perms_value_V5_clear(std::string const& encryption_key,\n                             QPDF::EncryptionData const& data,\n                             unsigned char k[16])\n{\n    // From algorithm 3.10 from the PDF 1.7 extension level 3\n    unsigned long long extended_perms = 0xffffffff00000000LL | data.getP();\n    for (int i = 0; i < 8; ++i)\n    {\n        k[i] = static_cast<unsigned char>(extended_perms & 0xff);\n        extended_perms >>= 8;\n    }\n    k[8] = data.getEncryptMetadata() ? 'T' : 'F';\n    k[9] = 'a';\n    k[10] = 'd';\n    k[11] = 'b';\n    QUtil::initializeWithRandomBytes(k + 12, 4);\n}\n\nstatic std::string\ncompute_Perms_value_V5(std::string const& encryption_key,\n                       QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.10 from the PDF 1.7 extension level 3\n    unsigned char k[16];\n    compute_Perms_value_V5_clear(encryption_key, data, k);\n    return process_with_aes(\n        encryption_key, true,\n        std::string(reinterpret_cast<char*>(k), sizeof(k)));\n}\n\nstd::string\nQPDF::recover_encryption_key_with_password(\n    std::string const& password, EncryptionData const& data,\n    bool& perms_valid)\n{\n    // Algorithm 3.2a from the PDF 1.7 extension level 3\n\n    // This code does not handle Unicode passwords correctly.\n    // Empirical evidence suggests that most viewers don't.  We are\n    // supposed to process the input string with the SASLprep (RFC\n    // 4013) profile of stringprep (RFC 3454) and then convert the\n    // result to UTF-8.\n\n    perms_valid = false;\n    std::string key_password = truncate_password_V5(password);\n    std::string key_salt;\n    std::string user_data;\n    std::string encrypted_file_key;\n    if (check_owner_password_V5(key_password, data))\n    {\n        key_salt = data.getO().substr(40, 8);\n        user_data = data.getU().substr(0, 48);\n        encrypted_file_key = data.getOE().substr(0, 32);\n    }\n    else if (check_user_password_V5(key_password, data))\n    {\n        key_salt = data.getU().substr(40, 8);\n        encrypted_file_key = data.getUE().substr(0, 32);\n    }\n    std::string intermediate_key =\n        hash_V5(key_password, key_salt, user_data, data);\n    std::string file_key =\n        process_with_aes(intermediate_key, false, encrypted_file_key);\n\n    // Decrypt Perms and check against expected value\n    std::string perms_check =\n        process_with_aes(file_key, false, data.getPerms(), 12);\n    unsigned char k[16];\n    compute_Perms_value_V5_clear(file_key, data, k);\n    perms_valid = (memcmp(perms_check.c_str(), k, 12) == 0);\n\n    return file_key;\n}\n\nQPDF::encryption_method_e\nQPDF::interpretCF(QPDFObjectHandle cf)\n{\n    if (cf.isName())\n    {\n\tstd::string filter = cf.getName();\n\tif (this->m->crypt_filters.count(filter) != 0)\n\t{\n\t    return this->m->crypt_filters[filter];\n\t}\n\telse if (filter == \"/Identity\")\n\t{\n\t    return e_none;\n\t}\n\telse\n\t{\n\t    return e_unknown;\n\t}\n    }\n    else\n    {\n\t// Default: /Identity\n\treturn e_none;\n    }\n}\n\nvoid\nQPDF::initializeEncryption()\n{\n    if (this->m->encryption_initialized)\n    {\n\treturn;\n    }\n    this->m->encryption_initialized = true;\n\n    // After we initialize encryption parameters, we must used stored\n    // key information and never look at /Encrypt again.  Otherwise,\n    // things could go wrong if someone mutates the encryption\n    // dictionary.\n\n    if (! this->m->trailer.hasKey(\"/Encrypt\"))\n    {\n\treturn;\n    }\n\n    // Go ahead and set this->m->encrypted here.  That way, isEncrypted\n    // will return true even if there were errors reading the\n    // encryption dictionary.\n    this->m->encrypted = true;\n\n    std::string id1;\n    QPDFObjectHandle id_obj = this->m->trailer.getKey(\"/ID\");\n    if ((id_obj.isArray() &&\n         (id_obj.getArrayNItems() == 2) &&\n         id_obj.getArrayItem(0).isString()))\n    {\n        id1 = id_obj.getArrayItem(0).getStringValue();\n    }\n    else\n    {\n        // Treating a missing ID as the empty string enables qpdf to\n        // decrypt some invalid encrypted files with no /ID that\n        // poppler can read but Adobe Reader can't.\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                     \"trailer\", this->m->file->getLastOffset(),\n                     \"invalid /ID in trailer dictionary\"));\n    }\n\n    QPDFObjectHandle encryption_dict = this->m->trailer.getKey(\"/Encrypt\");\n    if (! encryption_dict.isDictionary())\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      this->m->last_object_description,\n\t\t      this->m->file->getLastOffset(),\n\t\t      \"/Encrypt in trailer dictionary is not a dictionary\");\n    }\n\n    if (! (encryption_dict.getKey(\"/Filter\").isName() &&\n\t   (encryption_dict.getKey(\"/Filter\").getName() == \"/Standard\")))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"unsupported encryption filter\");\n    }\n    if (! encryption_dict.getKey(\"/SubFilter\").isNull())\n    {\n\twarn(QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t     \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t     \"file uses encryption SubFilters,\"\n\t\t     \" which qpdf does not support\"));\n    }\n\n    if (! (encryption_dict.getKey(\"/V\").isInteger() &&\n\t   encryption_dict.getKey(\"/R\").isInteger() &&\n\t   encryption_dict.getKey(\"/O\").isString() &&\n\t   encryption_dict.getKey(\"/U\").isString() &&\n\t   encryption_dict.getKey(\"/P\").isInteger()))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"some encryption dictionary parameters are missing \"\n\t\t      \"or the wrong type\");\n    }\n\n    int V = encryption_dict.getKey(\"/V\").getIntValue();\n    int R = encryption_dict.getKey(\"/R\").getIntValue();\n    std::string O = encryption_dict.getKey(\"/O\").getStringValue();\n    std::string U = encryption_dict.getKey(\"/U\").getStringValue();\n    unsigned int P = encryption_dict.getKey(\"/P\").getIntValue();\n\n    // If supporting new encryption R/V values, remember to update\n    // error message inside this if statement.\n    if (! (((R >= 2) && (R <= 6)) &&\n\t   ((V == 1) || (V == 2) || (V == 4) || (V == 5))))\n    {\n\tthrow QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"Unsupported /R or /V in encryption dictionary; R = \" +\n                      QUtil::int_to_string(R) + \" (max 6), V = \" +\n                      QUtil::int_to_string(V) + \" (max 5)\");\n    }\n\n    this->m->encryption_V = V;\n    this->m->encryption_R = R;\n\n    // OE, UE, and Perms are only present if V >= 5.\n    std::string OE;\n    std::string UE;\n    std::string Perms;\n\n    if (V < 5)\n    {\n        // These must be exactly the right number of bytes.\n        pad_short_parameter(O, key_bytes);\n        pad_short_parameter(U, key_bytes);\n        if (! ((O.length() == key_bytes) && (U.length() == key_bytes)))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for /O and/or /U in \"\n                          \"encryption dictionary\");\n        }\n    }\n    else\n    {\n        if (! (encryption_dict.getKey(\"/OE\").isString() &&\n               encryption_dict.getKey(\"/UE\").isString() &&\n               encryption_dict.getKey(\"/Perms\").isString()))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"some V=5 encryption dictionary parameters are \"\n                          \"missing or the wrong type\");\n        }\n        OE = encryption_dict.getKey(\"/OE\").getStringValue();\n        UE = encryption_dict.getKey(\"/UE\").getStringValue();\n        Perms = encryption_dict.getKey(\"/Perms\").getStringValue();\n\n        // These may be longer than the minimum number of bytes.\n        pad_short_parameter(O, OU_key_bytes_V5);\n        pad_short_parameter(U, OU_key_bytes_V5);\n        pad_short_parameter(OE, OUE_key_bytes_V5);\n        pad_short_parameter(UE, OUE_key_bytes_V5);\n        pad_short_parameter(Perms, Perms_key_bytes_V5);\n    }\n\n    int Length = 40;\n    if (encryption_dict.getKey(\"/Length\").isInteger())\n    {\n\tLength = encryption_dict.getKey(\"/Length\").getIntValue();\n\tif ((Length % 8) || (Length < 40) || (Length > 256))\n\t{\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t  \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n\t\t\t  \"invalid /Length value in encryption dictionary\");\n\t}\n    }\n\n    this->m->encrypt_metadata = true;\n    if ((V >= 4) && (encryption_dict.getKey(\"/EncryptMetadata\").isBool()))\n    {\n\tthis->m->encrypt_metadata =\n\t    encryption_dict.getKey(\"/EncryptMetadata\").getBoolValue();\n    }\n\n    if ((V == 4) || (V == 5))\n    {\n\tQPDFObjectHandle CF = encryption_dict.getKey(\"/CF\");\n\tstd::set<std::string> keys = CF.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    std::string const& filter = *iter;\n\t    QPDFObjectHandle cdict = CF.getKey(filter);\n\t    if (cdict.isDictionary())\n\t    {\n\t\tencryption_method_e method = e_none;\n\t\tif (cdict.getKey(\"/CFM\").isName())\n\t\t{\n\t\t    std::string method_name = cdict.getKey(\"/CFM\").getName();\n\t\t    if (method_name == \"/V2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM V2\");\n\t\t\tmethod = e_rc4;\n\t\t    }\n\t\t    else if (method_name == \"/AESV2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV2\");\n\t\t\tmethod = e_aes;\n\t\t    }\n\t\t    else if (method_name == \"/AESV3\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV3\");\n\t\t\tmethod = e_aesv3;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Don't complain now -- maybe we won't need\n\t\t\t// to reference this type.\n\t\t\tmethod = e_unknown;\n\t\t    }\n\t\t}\n\t\tthis->m->crypt_filters[filter] = method;\n\t    }\n\t}\n\n\tQPDFObjectHandle StmF = encryption_dict.getKey(\"/StmF\");\n\tQPDFObjectHandle StrF = encryption_dict.getKey(\"/StrF\");\n\tQPDFObjectHandle EFF = encryption_dict.getKey(\"/EFF\");\n\tthis->m->cf_stream = interpretCF(StmF);\n\tthis->m->cf_string = interpretCF(StrF);\n\tif (EFF.isName())\n\t{\n\t    this->m->cf_file = interpretCF(EFF);\n\t}\n\telse\n\t{\n\t    this->m->cf_file = this->m->cf_stream;\n\t}\n    }\n\n    EncryptionData data(V, R, Length / 8, P, O, U, OE, UE, Perms,\n                        id1, this->m->encrypt_metadata);\n    if (check_owner_password(\n\t    this->m->user_password, this->m->provided_password, data))\n    {\n\t// password supplied was owner password; user_password has\n\t// been initialized for V < 5\n    }\n    else if (check_user_password(this->m->provided_password, data))\n    {\n\tthis->m->user_password = this->m->provided_password;\n    }\n    else\n    {\n\tthrow QPDFExc(qpdf_e_password, this->m->file->getName(),\n\t\t      \"\", 0, \"invalid password\");\n    }\n\n    if (V < 5)\n    {\n        // For V < 5, the user password is encrypted with the owner\n        // password, and the user password is always used for\n        // computing the encryption key.\n        this->m->encryption_key = compute_encryption_key(\n            this->m->user_password, data);\n    }\n    else\n    {\n        // For V >= 5, either password can be used independently to\n        // compute the encryption key, and neither password can be\n        // used to recover the other.\n        bool perms_valid;\n        this->m->encryption_key = recover_encryption_key_with_password(\n            this->m->provided_password, data, perms_valid);\n        if (! perms_valid)\n        {\n            warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                         \"encryption dictionary\",\n                         this->m->file->getLastOffset(),\n                         \"/Perms field in encryption dictionary\"\n                         \" doesn't match expected value\"));\n        }\n    }\n}\n\nstd::string\nQPDF::getKeyForObject(int objid, int generation, bool use_aes)\n{\n    if (! this->m->encrypted)\n    {\n\tthrow std::logic_error(\n\t    \"request for encryption key in non-encrypted PDF\");\n    }\n\n    if (! ((objid == this->m->cached_key_objid) &&\n\t   (generation == this->m->cached_key_generation)))\n    {\n\tthis->m->cached_object_encryption_key =\n\t    compute_data_key(this->m->encryption_key, objid, generation,\n                             use_aes, this->m->encryption_V,\n                             this->m->encryption_R);\n\tthis->m->cached_key_objid = objid;\n\tthis->m->cached_key_generation = generation;\n    }\n\n    return this->m->cached_object_encryption_key;\n}\n\nvoid\nQPDF::decryptString(std::string& str, int objid, int generation)\n{\n    if (objid == 0)\n    {\n\treturn;\n    }\n    bool use_aes = false;\n    if (this->m->encryption_V >= 4)\n    {\n\tswitch (this->m->cf_string)\n\t{\n\t  case e_none:\n\t    return;\n\n\t  case e_aes:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_aesv3:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_rc4:\n\t    break;\n\n\t  default:\n\t    warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t this->m->last_object_description,\n\t\t\t this->m->file->getLastOffset(),\n\t\t\t \"unknown encryption filter for strings\"\n\t\t\t \" (check /StrF in /Encrypt dictionary);\"\n\t\t\t \" strings may be decrypted improperly\"));\n\t    // To avoid repeated warnings, reset cf_string.  Assume\n\t    // we'd want to use AES if V == 4.\n\t    this->m->cf_string = e_aes;\n\t    break;\n\t}\n    }\n\n    std::string key = getKeyForObject(objid, generation, use_aes);\n    try\n    {\n\tif (use_aes)\n\t{\n\t    QTC::TC(\"qpdf\", \"QPDF_encryption aes decode string\");\n\t    Pl_Buffer bufpl(\"decrypted string\");\n\t    Pl_AES_PDF pl(\"aes decrypt string\", &bufpl, false,\n\t\t\t  QUtil::unsigned_char_pointer(key),\n                          key.length());\n\t    pl.write(QUtil::unsigned_char_pointer(str), str.length());\n\t    pl.finish();\n\t    PointerHolder<Buffer> buf = bufpl.getBuffer();\n\t    str = std::string(reinterpret_cast<char*>(buf->getBuffer()),\n                              buf->getSize());\n\t}\n\telse\n\t{\n\t    QTC::TC(\"qpdf\", \"QPDF_encryption rc4 decode string\");\n\t    unsigned int vlen = str.length();\n\t    // Using PointerHolder guarantees that tmp will\n\t    // be freed even if rc4.process throws an exception.\n\t    PointerHolder<char> tmp(true, QUtil::copy_string(str));\n\t    RC4 rc4(QUtil::unsigned_char_pointer(key), key.length());\n\t    rc4.process(QUtil::unsigned_char_pointer(tmp.getPointer()), vlen);\n\t    str = std::string(tmp.getPointer(), vlen);\n\t}\n    }\n    catch (QPDFExc&)\n    {\n\tthrow;\n    }\n    catch (std::runtime_error& e)\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      this->m->last_object_description,\n\t\t      this->m->file->getLastOffset(),\n\t\t      \"error decrypting string for object \" +\n\t\t      QUtil::int_to_string(objid) + \" \" +\n\t\t      QUtil::int_to_string(generation) + \": \" + e.what());\n    }\n}\n\nvoid\nQPDF::decryptStream(Pipeline*& pipeline, int objid, int generation,\n\t\t    QPDFObjectHandle& stream_dict,\n\t\t    std::vector<PointerHolder<Pipeline> >& heap)\n{\n    std::string type;\n    if (stream_dict.getKey(\"/Type\").isName())\n    {\n\ttype = stream_dict.getKey(\"/Type\").getName();\n    }\n    if (type == \"/XRef\")\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption xref stream from encrypted file\");\n\treturn;\n    }\n    bool use_aes = false;\n    if (this->m->encryption_V >= 4)\n    {\n\tencryption_method_e method = e_unknown;\n\tstd::string method_source = \"/StmF from /Encrypt dictionary\";\n\n\tif (stream_dict.getKey(\"/Filter\").isOrHasName(\"/Crypt\"))\n        {\n            if (stream_dict.getKey(\"/DecodeParms\").isDictionary())\n            {\n                QPDFObjectHandle decode_parms =\n                    stream_dict.getKey(\"/DecodeParms\");\n                if (decode_parms.getKey(\"/Type\").isName() &&\n                    (decode_parms.getKey(\"/Type\").getName() ==\n                     \"/CryptFilterDecodeParms\"))\n                {\n                    QTC::TC(\"qpdf\", \"QPDF_encryption stream crypt filter\");\n                    method = interpretCF(decode_parms.getKey(\"/Name\"));\n                    method_source = \"stream's Crypt decode parameters\";\n                }\n            }\n            else if (stream_dict.getKey(\"/DecodeParms\").isArray() &&\n                     stream_dict.getKey(\"/Filter\").isArray())\n            {\n                QPDFObjectHandle filter = stream_dict.getKey(\"/Filter\");\n                QPDFObjectHandle decode = stream_dict.getKey(\"/DecodeParms\");\n                if (filter.getArrayNItems() == decode.getArrayNItems())\n                {\n                    for (int i = 0; i < filter.getArrayNItems(); ++i)\n                    {\n                        if (filter.getArrayItem(i).isName() &&\n                            (filter.getArrayItem(i).getName() == \"/Crypt\"))\n                        {\n                            QPDFObjectHandle crypt_params =\n                                decode.getArrayItem(i);\n                            if (crypt_params.isDictionary() &&\n                                crypt_params.getKey(\"/Name\").isName())\n                            {\n                                QTC::TC(\"qpdf\", \"QPDF_encrypt crypt array\");\n                                method = interpretCF(\n                                    crypt_params.getKey(\"/Name\"));\n                                method_source = \"stream's Crypt \"\n                                    \"decode parameters (array)\";\n                            }\n                        }\n                    }\n                }\n            }\n\t}\n\n\tif (method == e_unknown)\n\t{\n\t    if ((! this->m->encrypt_metadata) && (type == \"/Metadata\"))\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDF_encryption cleartext metadata\");\n\t\tmethod = e_none;\n\t    }\n\t    else\n\t    {\n                if (this->m->attachment_streams.count(\n                        QPDFObjGen(objid, generation)) > 0)\n                {\n                    method = this->m->cf_file;\n                }\n                else\n                {\n                    method = this->m->cf_stream;\n                }\n\t    }\n\t}\n\tuse_aes = false;\n\tswitch (method)\n\t{\n\t  case e_none:\n\t    return;\n\t    break;\n\n\t  case e_aes:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_aesv3:\n\t    use_aes = true;\n\t    break;\n\n\t  case e_rc4:\n\t    break;\n\n\t  default:\n\t    // filter local to this stream.\n\t    warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t this->m->last_object_description,\n\t\t\t this->m->file->getLastOffset(),\n\t\t\t \"unknown encryption filter for streams\"\n\t\t\t \" (check \" + method_source + \");\"\n\t\t\t \" streams may be decrypted improperly\"));\n\t    // To avoid repeated warnings, reset cf_stream.  Assume\n\t    // we'd want to use AES if V == 4.\n\t    this->m->cf_stream = e_aes;\n\t    break;\n\t}\n    }\n    std::string key = getKeyForObject(objid, generation, use_aes);\n    if (use_aes)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption aes decode stream\");\n\tpipeline = new Pl_AES_PDF(\"AES stream decryption\", pipeline,\n\t\t\t\t  false, QUtil::unsigned_char_pointer(key),\n                                  key.length());\n    }\n    else\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_encryption rc4 decode stream\");\n\tpipeline = new Pl_RC4(\"RC4 stream decryption\", pipeline,\n\t\t\t      QUtil::unsigned_char_pointer(key),\n                              key.length());\n    }\n    heap.push_back(pipeline);\n}\n\nvoid\nQPDF::compute_encryption_O_U(\n    char const* user_password, char const* owner_password,\n    int V, int R, int key_len, int P, bool encrypt_metadata,\n    std::string const& id1, std::string& O, std::string& U)\n{\n    if (V >= 5)\n    {\n\tthrow std::logic_error(\n\t    \"compute_encryption_O_U called for file with V >= 5\");\n    }\n    EncryptionData data(V, R, key_len, P, \"\", \"\", \"\", \"\", \"\",\n                        id1, encrypt_metadata);\n    data.setO(compute_O_value(user_password, owner_password, data));\n    O = data.getO();\n    data.setU(compute_U_value(user_password, data));\n    U = data.getU();\n}\n\nvoid\nQPDF::compute_encryption_parameters_V5(\n    char const* user_password, char const* owner_password,\n    int V, int R, int key_len, int P, bool encrypt_metadata,\n    std::string const& id1,\n    std::string& encryption_key,\n    std::string& O, std::string& U,\n    std::string& OE, std::string& UE, std::string& Perms)\n{\n    EncryptionData data(V, R, key_len, P, \"\", \"\", \"\", \"\", \"\",\n                        id1, encrypt_metadata);\n    unsigned char k[key_bytes];\n    QUtil::initializeWithRandomBytes(k, key_bytes);\n    encryption_key = std::string(reinterpret_cast<char*>(k), key_bytes);\n    compute_U_UE_value_V5(user_password, encryption_key, data, U, UE);\n    compute_O_OE_value_V5(owner_password, encryption_key, data, U, O, OE);\n    Perms = compute_Perms_value_V5(encryption_key, data);\n    data.setV5EncryptionParameters(O, OE, U, UE, Perms);\n}\n\nstd::string const&\nQPDF::getPaddedUserPassword() const\n{\n    return this->m->user_password;\n}\n\nstd::string\nQPDF::getTrimmedUserPassword() const\n{\n    std::string result = this->m->user_password;\n    trim_user_password(result);\n    return result;\n}\n\nstd::string\nQPDF::getEncryptionKey() const\n{\n    return this->m->encryption_key;\n}\n\nbool\nQPDF::isEncrypted() const\n{\n    return this->m->encrypted;\n}\n\nbool\nQPDF::isEncrypted(int& R, int& P)\n{\n    int V;\n    encryption_method_e stream, string, file;\n    return isEncrypted(R, P, V, stream, string, file);\n}\n\nbool\nQPDF::isEncrypted(int& R, int& P, int& V,\n                  encryption_method_e& stream_method,\n                  encryption_method_e& string_method,\n                  encryption_method_e& file_method)\n{\n    if (this->m->encrypted)\n    {\n\tQPDFObjectHandle trailer = getTrailer();\n\tQPDFObjectHandle encrypt = trailer.getKey(\"/Encrypt\");\n\tQPDFObjectHandle Pkey = encrypt.getKey(\"/P\");\n\tQPDFObjectHandle Rkey = encrypt.getKey(\"/R\");\n        QPDFObjectHandle Vkey = encrypt.getKey(\"/V\");\n\tP = Pkey.getIntValue();\n\tR = Rkey.getIntValue();\n        V = Vkey.getIntValue();\n        stream_method = this->m->cf_stream;\n        string_method = this->m->cf_stream;\n        file_method = this->m->cf_file;\n\treturn true;\n    }\n    else\n    {\n\treturn false;\n    }\n}\n\nstatic bool\nis_bit_set(int P, int bit)\n{\n    // Bits in P are numbered from 1 in the spec\n    return (P & (1 << (bit - 1)));\n}\n\nbool\nQPDF::allowAccessibility()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 5);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 10);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowExtractAll()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 5);\n    }\n    return status;\n}\n\nbool\nQPDF::allowPrintLowRes()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 3);\n    }\n    return status;\n}\n\nbool\nQPDF::allowPrintHighRes()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 3);\n\tif ((R >= 3) && (! is_bit_set(P, 12)))\n\t{\n\t    status = false;\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAssembly()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 4);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 11);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyForm()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tif (R < 3)\n\t{\n\t    status = is_bit_set(P, 6);\n\t}\n\telse\n\t{\n\t    status = is_bit_set(P, 9);\n\t}\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAnnotation()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 6);\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyOther()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = is_bit_set(P, 4);\n    }\n    return status;\n}\n\nbool\nQPDF::allowModifyAll()\n{\n    int R = 0;\n    int P = 0;\n    bool status = true;\n    if (isEncrypted(R, P))\n    {\n\tstatus = (is_bit_set(P, 4) && is_bit_set(P, 6));\n\tif (R >= 3)\n\t{\n\t    status = status && (is_bit_set(P, 9) && is_bit_set(P, 11));\n\t}\n    }\n    return status;\n}\n"], "filenames": ["libqpdf/QPDF_encryption.cc"], "buggy_code_start_loc": [481], "buggy_code_end_loc": [934], "fixing_code_start_loc": [482], "fixing_code_end_loc": [929], "type": "CWE-125", "message": "An issue was discovered in QPDF before 7.0.0. There is a stack-based out-of-bounds read in the function iterate_rc4 in QPDF_encryption.cc.", "other": {"cve": {"id": "CVE-2017-18184", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-13T19:29:00.370", "lastModified": "2018-05-08T13:29:00.740", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in QPDF before 7.0.0. There is a stack-based out-of-bounds read in the function iterate_rc4 in QPDF_encryption.cc."}, {"lang": "es", "value": "Se ha descubierto un problema en versiones anteriores a la 7.0.0 de QPDF. Hay una lectura fuera de l\u00edmites basada en pila en la funci\u00f3n iterate_rc4 en QPDF_encryption.cc."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qpdf_project:qpdf:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "73F0E411-FD17-40ED-87AB-D320CB6A39FE"}]}]}], "references": [{"url": "https://github.com/qpdf/qpdf/commit/dea704f0ab7f625e1e7b3f9a1110b45b63157317", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qpdf/qpdf/issues/147", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3638-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/qpdf/qpdf/commit/dea704f0ab7f625e1e7b3f9a1110b45b63157317"}}