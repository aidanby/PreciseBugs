{"buggy_code": ["horizon.instances = {\n  user_decided_length: false,\n  networks_selected: [],\n  networks_available: [],\n\n  getConsoleLog: function(via_user_submit) {\n    var form_element = $(\"#tail_length\"),\n      data;\n\n    if (!via_user_submit) {\n      via_user_submit = false;\n    }\n\n    if(this.user_decided_length) {\n      data = $(form_element).serialize();\n    } else {\n      data = \"length=35\";\n    }\n\n    $.ajax({\n      url: $(form_element).attr('action'),\n      data: data,\n      method: 'get',\n      success: function(response_body) {\n        $('pre.logs').text(response_body);\n      },\n      error: function(response) {\n        if(via_user_submit) {\n          horizon.clearErrorMessages();\n          horizon.alert('error', gettext('There was a problem communicating with the server, please try again.'));\n        }\n      }\n    });\n  },\n\n  /*\n   * Gets the html select element associated with a given\n   * network id for network_id.\n   **/\n  get_network_element: function(network_id) {\n    return $('li > label[for^=\"id_network_' + network_id + '\"]');\n  },\n\n  /*\n   * Initializes an associative array of lists of the current\n   * networks.\n   **/\n  init_network_list: function() {\n    horizon.instances.networks_selected = [];\n    horizon.instances.networks_available = [];\n    $(this.get_network_element(\"\")).each(function(){\n      var $this = $(this);\n      var $input = $this.children(\"input\");\n      var network_property = {\n        name:$this.text().replace(/^\\s+/,\"\"),\n        id:$input.attr(\"id\"),\n        value:$input.attr(\"value\")\n      };\n      if($input.is(':checked')) {\n        horizon.instances.networks_selected.push(network_property);\n      } else {\n        horizon.instances.networks_available.push(network_property);\n      }\n    });\n  },\n\n  /*\n   * Generates the HTML structure for a network that will be displayed\n   * as a list item in the network list.\n   **/\n  generate_network_element: function(name, id, value) {\n    var $li = $('<li>');\n    $li.attr('name', value).html(name + '<em class=\"network_id\">(' + value + ')</em><a href=\"#\" class=\"btn btn-primary\"></a>');\n    return $li;\n  },\n\n  /*\n   * Generates the HTML structure for the Network List.\n   **/\n  generate_networklist_html: function() {\n    var self = this;\n    var updateForm = function() {\n      var lists = $(\"#networkListId div.input li\").attr('data-index',100);\n      var active_networks = $(\"#selected_network > li\").map(function(){\n        return $(this).attr(\"name\");\n      });\n      $(\"#networkListId div.input input:checkbox\").removeAttr('checked');\n      active_networks.each(function(index, value){\n        $(\"#networkListId div.input input:checkbox[value=\" + value + \"]\")\n          .attr('checked','checked')\n          .parents(\"li\").attr('data-index',index);\n      });\n      $(\"#networkListId div.input ul\").html(\n        lists.sort(function(a,b){\n          if( $(a).data(\"index\") < $(b).data(\"index\")) { return -1; }\n          if( $(a).data(\"index\") > $(b).data(\"index\")) { return 1; }\n          return 0;\n        })\n      );\n    };\n    $(\"#networkListSortContainer\").show();\n    $(\"#networkListIdContainer\").hide();\n    self.init_network_list();\n    // Make sure we don't duplicate the networks in the list\n    $(\"#available_network\").empty();\n    $.each(self.networks_available, function(index, value){\n      $(\"#available_network\").append(self.generate_network_element(value.name, value.id, value.value));\n    });\n    // Make sure we don't duplicate the networks in the list\n    $(\"#selected_network\").empty();\n    $.each(self.networks_selected, function(index, value){\n      $(\"#selected_network\").append(self.generate_network_element(value.name, value.id, value.value));\n    });\n    // $(\".networklist > li\").click(function(){\n    //   $(this).toggleClass(\"ui-selected\");\n    // });\n    $(\".networklist > li > a.btn\").click(function(e){\n      var $this = $(this);\n      e.preventDefault();\n      e.stopPropagation();\n      if($this.parents(\"ul#available_network\").length > 0) {\n        $this.parent().appendTo($(\"#selected_network\"));\n      } else if ($this.parents(\"ul#selected_network\").length > 0) {\n        $this.parent().appendTo($(\"#available_network\"));\n      }\n      updateForm();\n    });\n    if ($(\"#networkListId > div.control-group.error\").length > 0) {\n      var errortext = $(\"#networkListId > div.control-group.error\").find(\"span.help-inline\").text();\n      $(\"#selected_network_label\").before($('<div class=\"dynamic-error\">').html(errortext));\n    }\n    $(\".networklist\").sortable({\n      connectWith: \"ul.networklist\",\n      placeholder: \"ui-state-highlight\",\n      distance: 5,\n      start:function(e,info){\n        $(\"#selected_network\").addClass(\"dragging\");\n      },\n      stop:function(e,info){\n        $(\"#selected_network\").removeClass(\"dragging\");\n        updateForm();\n      }\n    }).disableSelection();\n  },\n\n  workflow_init: function(modal) {\n    // Initialise the drag and drop network list\n    horizon.instances.generate_networklist_html();\n  }\n};\n\nhorizon.addInitFunction(function () {\n  $(document).on('submit', '#tail_length', function (evt) {\n    horizon.instances.user_decided_length = true;\n    horizon.instances.getConsoleLog(true);\n    evt.preventDefault();\n  });\n\n  /* Launch instance workflow */\n\n  // Handle field toggles for the Launch Instance source type field\n  function update_launch_source_displayed_fields (field) {\n    var $this = $(field),\n      base_type = $this.val();\n\n    $this.closest(\".control-group\").nextAll().hide();\n\n    switch(base_type) {\n      case \"image_id\":\n        $(\"#id_image_id\").closest(\".control-group\").show();\n        break;\n\n      case \"instance_snapshot_id\":\n        $(\"#id_instance_snapshot_id\").closest(\".control-group\").show();\n        break;\n\n      case \"volume_id\":\n        $(\"#id_volume_id\").closest(\".control-group\").show();\n        break;\n\n      case \"volume_image_id\":\n        $(\"#id_image_id, #id_volume_size, #id_device_name, , #id_delete_on_terminate\")\n          .closest(\".control-group\").show();\n        break;\n\n      case \"volume_snapshot_id\":\n        $(\"#id_volume_snapshot_id, #id_device_name, #id_delete_on_terminate\")\n          .closest(\".control-group\").show();\n        break;\n    }\n  }\n\n  $(document).on('change', '.workflow #id_source_type', function (evt) {\n    update_launch_source_displayed_fields(this);\n  });\n\n  $('.workflow #id_source_type').change();\n  horizon.modals.addModalInitFunction(function (modal) {\n    $(modal).find(\"#id_source_type\").change();\n  });\n\n\n  // Handle field toggles for the Launch Instance volume type field\n  function update_image_id_fields (field) {\n    var $this = $(field),\n      volume_opt = $this.val();\n    var $option = $this.find(\"option:selected\");\n    var $form = $this.closest('form');\n    var $volSize = $form.find('input#id_volume_size');\n    $volSize.val($option.data(\"volume_size\"));\n  }\n\n  $(document).on('change', '.workflow #id_image_id', function (evt) {\n    update_image_id_fields(this);\n  });\n\n  horizon.instances.decrypt_password = function(encrypted_password, private_key) {\n    var crypt = new JSEncrypt();\n    crypt.setKey(private_key);\n    return crypt.decrypt(encrypted_password);\n  };\n\n  $(document).on('change', '#id_private_key_file', function (evt) {\n    var file = evt.target.files[0];\n    var reader = new FileReader();\n    if (file) {\n      reader.onloadend = function(event) {\n        $(\"#id_private_key\").val(event.target.result);\n      };\n      reader.onerror = function(event) {\n        horizon.clearErrorMessages();\n        horizon.alert('error', gettext('Could not read the file'));\n      };\n      reader.readAsText(file);\n    }\n    else {\n      horizon.clearErrorMessages();\n      horizon.alert('error', gettext('Could not decrypt the password'));\n    }\n  });\n  /*\n    The font-family is changed because with the default policy the major I\n    and minor the l cannot be distinguished.\n  */\n  $(document).on('show', '#password_instance_modal', function (evt) {\n    $(\"#id_decrypted_password\").css(\"font-family\",\"monospace\");\n    $(\"#id_decrypted_password\").css(\"cursor\",\"text\");\n    $(\"#id_encrypted_password\").css(\"cursor\",\"text\");\n    $(\"#id_keypair_name\").css(\"cursor\",\"text\");\n  });\n\n  $(document).on('click', '#decryptpassword_button', function (evt) {\n    encrypted_password = $(\"#id_encrypted_password\").val();\n    private_key = $('#id_private_key').val();\n    if (!private_key) {\n      evt.preventDefault();\n      $(this).closest('.modal').modal('hide');\n    }\n    else {\n      if (private_key.length > 0) {\n        evt.preventDefault();\n        decrypted_password = horizon.instances.decrypt_password(encrypted_password, private_key);\n        if (decrypted_password === false || decrypted_password === null) {\n          horizon.clearErrorMessages();\n          horizon.alert('error', gettext('Could not decrypt the password'));\n        }\n        else {\n          $(\"#id_decrypted_password\").val(decrypted_password);\n          $(\"#decryptpassword_button\").hide();\n        }\n      }\n    }\n  });\n});\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport collections\nimport copy\nimport json\nimport logging\nfrom operator import attrgetter\nimport sys\n\nfrom django.core import exceptions as core_exceptions\nfrom django.core import urlresolvers\nfrom django import forms\nfrom django.http import HttpResponse  # noqa\nfrom django import template\nfrom django.template.defaultfilters import truncatechars  # noqa\nfrom django.template.loader import render_to_string\nfrom django.utils.datastructures import SortedDict\nfrom django.utils.html import escape\nfrom django.utils import http\nfrom django.utils.http import urlencode\nfrom django.utils.safestring import mark_safe\nfrom django.utils import termcolors\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import conf\nfrom horizon import exceptions\nfrom horizon import messages\nfrom horizon.tables.actions import FilterAction  # noqa\nfrom horizon.tables.actions import LinkAction  # noqa\nfrom horizon.utils import html\n\n\nLOG = logging.getLogger(__name__)\nPALETTE = termcolors.PALETTES[termcolors.DEFAULT_PALETTE]\nSTRING_SEPARATOR = \"__\"\n\n\nclass Column(html.HTMLElement):\n    \"\"\"A class which represents a single column in a :class:`.DataTable`.\n\n    .. attribute:: transform\n\n        A string or callable. If ``transform`` is a string, it should be the\n        name of the attribute on the underlying data class which\n        should be displayed in this column. If it is a callable, it\n        will be passed the current row's data at render-time and should\n        return the contents of the cell. Required.\n\n    .. attribute:: verbose_name\n\n        The name for this column which should be used for display purposes.\n        Defaults to the value of ``transform`` with the first letter\n        of each word capitalized if the ``transform`` is not callable,\n        otherwise it defaults to an empty string (``\"\"``).\n\n    .. attribute:: sortable\n\n        Boolean to determine whether this column should be sortable or not.\n        Defaults to ``True``.\n\n    .. attribute:: hidden\n\n        Boolean to determine whether or not this column should be displayed\n        when rendering the table. Default: ``False``.\n\n    .. attribute:: link\n\n        A string or callable which returns a URL which will be wrapped around\n        this column's text as a link.\n\n    .. attribute:: allowed_data_types\n\n        A list of data types for which the link should be created.\n        Default is an empty list (``[]``).\n\n        When the list is empty and the ``link`` attribute is not None, all the\n        rows under this column will be links.\n\n    .. attribute::  status\n\n        Boolean designating whether or not this column represents a status\n        (i.e. \"enabled/disabled\", \"up/down\", \"active/inactive\").\n        Default: ``False``.\n\n    .. attribute::  status_choices\n\n        A tuple of tuples representing the possible data values for the\n        status column and their associated boolean equivalent. Positive\n        states should equate to ``True``, negative states should equate\n        to ``False``, and indeterminate states should be ``None``.\n\n        Values are compared in a case-insensitive manner.\n\n        Example (these are also the default values)::\n\n            status_choices = (\n                    ('enabled', True),\n                    ('true', True)\n                    ('up', True),\n                    ('active', True),\n                    ('yes', True),\n                    ('on', True),\n                    ('none', None),\n                    ('unknown', None),\n                    ('', None),\n                    ('disabled', False),\n                    ('down', False),\n                    ('false', False),\n                    ('inactive', False),\n                    ('no', False),\n                    ('off', False),\n                )\n\n    .. attribute::  display_choices\n\n        A tuple of tuples representing the possible values to substitute\n        the data when displayed in the column cell.\n\n    .. attribute:: empty_value\n\n        A string or callable to be used for cells which have no data.\n        Defaults to the string ``\"-\"``.\n\n    .. attribute:: summation\n\n        A string containing the name of a summation method to be used in\n        the generation of a summary row for this column. By default the\n        options are ``\"sum\"`` or ``\"average\"``, which behave as expected.\n        Optional.\n\n    .. attribute:: filters\n\n        A list of functions (often template filters) to be applied to the\n        value of the data for this column prior to output. This is effectively\n        a shortcut for writing a custom ``transform`` function in simple cases.\n\n    .. attribute:: classes\n\n        An iterable of CSS classes which should be added to this column.\n        Example: ``classes=('foo', 'bar')``.\n\n    .. attribute:: attrs\n\n        A dict of HTML attribute strings which should be added to this column.\n        Example: ``attrs={\"data-foo\": \"bar\"}``.\n\n    .. attribute:: truncate\n\n        An integer for the maximum length of the string in this column. If the\n        data in this column is larger than the supplied number, the data for\n        this column will be truncated and an ellipsis will be appended to the\n        truncated data.\n        Defaults to ``None``.\n\n    .. attribute:: link_classes\n\n        An iterable of CSS classes which will be added when the column's text\n        is displayed as a link.\n        Example: ``classes=('link-foo', 'link-bar')``.\n        Defaults to ``None``.\n\n    .. attribute:: wrap_list\n\n        Boolean value indicating whether the contents of this cell should be\n        wrapped in a ``<ul></ul>`` tag. Useful in conjunction with Django's\n        ``unordered_list`` template filter. Defaults to ``False``.\n\n    .. attribute:: form_field\n\n        A form field used for inline editing of the column. A django\n        forms.Field can be used or django form.Widget can be used.\n\n        Example: ``form_field=forms.CharField(required=True)``.\n        Defaults to ``None``.\n\n    .. attribute:: form_field_attributes\n\n        The additional html attributes that will be rendered to form_field.\n        Example: ``form_field_attributes={'class': 'bold_input_field'}``.\n        Defaults to ``None``.\n\n    .. attribute:: update_action\n\n        The class that inherits from tables.actions.UpdateAction, update_cell\n        method takes care of saving inline edited data. The tables.base.Row\n        get_data method needs to be connected to table for obtaining the data.\n        Example: ``update_action=UpdateCell``.\n        Defaults to ``None``.\n    \"\"\"\n    summation_methods = {\n        \"sum\": sum,\n        \"average\": lambda data: sum(data, 0.0) / len(data)\n    }\n    # Used to retain order when instantiating columns on a table\n    creation_counter = 0\n\n    transform = None\n    name = None\n    verbose_name = None\n    status_choices = (\n        ('enabled', True),\n        ('true', True),\n        ('up', True),\n        ('yes', True),\n        ('active', True),\n        ('on', True),\n        ('none', None),\n        ('unknown', None),\n        ('', None),\n        ('disabled', False),\n        ('down', False),\n        ('false', False),\n        ('inactive', False),\n        ('no', False),\n        ('off', False),\n    )\n\n    def __init__(self, transform, verbose_name=None, sortable=True,\n                 link=None, allowed_data_types=[], hidden=False, attrs=None,\n                 status=False, status_choices=None, display_choices=None,\n                 empty_value=None, filters=None, classes=None, summation=None,\n                 auto=None, truncate=None, link_classes=None, wrap_list=False,\n                 form_field=None, form_field_attributes=None,\n                 update_action=None):\n\n        self.classes = list(classes or getattr(self, \"classes\", []))\n        super(Column, self).__init__()\n        self.attrs.update(attrs or {})\n\n        if callable(transform):\n            self.transform = transform\n            self.name = \"<%s callable>\" % transform.__name__\n        else:\n            self.transform = unicode(transform)\n            self.name = self.transform\n\n        # Empty string is a valid value for verbose_name\n        if verbose_name is None:\n            if callable(transform):\n                self.verbose_name = ''\n            else:\n                self.verbose_name = self.transform.title()\n        else:\n            self.verbose_name = verbose_name\n\n        self.auto = auto\n        self.sortable = sortable\n        self.link = link\n        self.allowed_data_types = allowed_data_types\n        self.hidden = hidden\n        self.status = status\n        self.empty_value = empty_value or '-'\n        self.filters = filters or []\n        self.truncate = truncate\n        self.link_classes = link_classes or []\n        self.wrap_list = wrap_list\n        self.form_field = form_field\n        self.form_field_attributes = form_field_attributes or {}\n        self.update_action = update_action\n\n        if status_choices:\n            self.status_choices = status_choices\n        self.display_choices = display_choices\n\n        if summation is not None and summation not in self.summation_methods:\n            raise ValueError(\"Summation method %s must be one of %s.\"\n                             % (summation,\n                                \", \".join(self.summation_methods.keys())))\n        self.summation = summation\n\n        self.creation_counter = Column.creation_counter\n        Column.creation_counter += 1\n\n        if self.sortable and not self.auto:\n            self.classes.append(\"sortable\")\n        if self.hidden:\n            self.classes.append(\"hide\")\n        if self.link is not None:\n            self.classes.append('anchor')\n\n    def __unicode__(self):\n        return unicode(self.verbose_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.name)\n\n    def get_raw_data(self, datum):\n        \"\"\"Returns the raw data for this column, before any filters or\n        formatting are applied to it. This is useful when doing calculations\n        on data in the table.\n        \"\"\"\n        # Callable transformations\n        if callable(self.transform):\n            data = self.transform(datum)\n        # Dict lookups\n        elif isinstance(datum, collections.Mapping) and \\\n                self.transform in datum:\n            data = datum.get(self.transform)\n        else:\n        # Basic object lookups\n            try:\n                data = getattr(datum, self.transform)\n            except AttributeError:\n                msg = _(\"The attribute %(attr)s doesn't exist on \"\n                        \"%(obj)s.\") % {'attr': self.transform, 'obj': datum}\n                msg = termcolors.colorize(msg, **PALETTE['ERROR'])\n                LOG.warning(msg)\n                data = None\n        return data\n\n    def get_data(self, datum):\n        \"\"\"Returns the final display data for this column from the given\n        inputs.\n\n        The return value will be either the attribute specified for this column\n        or the return value of the attr:`~horizon.tables.Column.transform`\n        method for this column.\n        \"\"\"\n        datum_id = self.table.get_object_id(datum)\n\n        if datum_id in self.table._data_cache[self]:\n            return self.table._data_cache[self][datum_id]\n\n        data = self.get_raw_data(datum)\n        display_value = None\n\n        if self.display_choices:\n            display_value = [display for (value, display) in\n                             self.display_choices\n                             if value.lower() == (data or '').lower()]\n\n        if display_value:\n            data = display_value[0]\n        else:\n            for filter_func in self.filters:\n                try:\n                    data = filter_func(data)\n                except Exception:\n                    msg = (\"Filter '%(filter)s' failed with data \"\n                           \"'%(data)s' on column '%(col_name)s'\")\n                    LOG.warning(msg, {'filter': filter_func.func_name,\n                                      'data': data,\n                                      'col_name': unicode(self.verbose_name)})\n\n        if data and self.truncate:\n            data = truncatechars(data, self.truncate)\n\n        self.table._data_cache[self][datum_id] = data\n\n        return self.table._data_cache[self][datum_id]\n\n    def get_link_url(self, datum):\n        \"\"\"Returns the final value for the column's ``link`` property.\n\n        If ``allowed_data_types`` of this column  is not empty and the datum\n        has an assigned type, check if the datum's type is in the\n        ``allowed_data_types`` list. If not, the datum won't be displayed\n        as a link.\n\n        If ``link`` is a callable, it will be passed the current data object\n        and should return a URL. Otherwise ``get_link_url`` will attempt to\n        call ``reverse`` on ``link`` with the object's id as a parameter.\n        Failing that, it will simply return the value of ``link``.\n        \"\"\"\n        if self.allowed_data_types:\n            data_type_name = self.table._meta.data_type_name\n            data_type = getattr(datum, data_type_name, None)\n            if data_type and (data_type not in self.allowed_data_types):\n                return None\n        obj_id = self.table.get_object_id(datum)\n        if callable(self.link):\n            return self.link(datum)\n        try:\n            return urlresolvers.reverse(self.link, args=(obj_id,))\n        except urlresolvers.NoReverseMatch:\n            return self.link\n\n    def get_summation(self):\n        \"\"\"Returns the summary value for the data in this column if a\n        valid summation method is specified for it. Otherwise returns ``None``.\n        \"\"\"\n        if self.summation not in self.summation_methods:\n            return None\n\n        summation_function = self.summation_methods[self.summation]\n        data = [self.get_raw_data(datum) for datum in self.table.data]\n        data = filter(lambda datum: datum is not None, data)\n\n        if len(data):\n            summation = summation_function(data)\n            for filter_func in self.filters:\n                summation = filter_func(summation)\n            return summation\n        else:\n            return None\n\n\nclass Row(html.HTMLElement):\n    \"\"\"Represents a row in the table.\n\n    When iterated, the ``Row`` instance will yield each of its cells.\n\n    Rows are capable of AJAX updating, with a little added work:\n\n    The ``ajax`` property needs to be set to ``True``, and\n    subclasses need to define a ``get_data`` method which returns a data\n    object appropriate for consumption by the table (effectively the \"get\"\n    lookup versus the table's \"list\" lookup).\n\n    The automatic update interval is configurable by setting the key\n    ``ajax_poll_interval`` in the ``HORIZON_CONFIG`` dictionary.\n    Default: ``2500`` (measured in milliseconds).\n\n    .. attribute:: table\n\n        The table which this row belongs to.\n\n    .. attribute:: datum\n\n        The data object which this row represents.\n\n    .. attribute:: id\n\n        A string uniquely representing this row composed of the table name\n        and the row data object's identifier.\n\n    .. attribute:: cells\n\n        The cells belonging to this row stored in a ``SortedDict`` object.\n        This attribute is populated during instantiation.\n\n    .. attribute:: status\n\n        Boolean value representing the status of this row calculated from\n        the values of the table's ``status_columns`` if they are set.\n\n    .. attribute:: status_class\n\n        Returns a css class for the status of the row based on ``status``.\n\n    .. attribute:: ajax\n\n        Boolean value to determine whether ajax updating for this row is\n        enabled.\n\n    .. attribute:: ajax_action_name\n\n        String that is used for the query parameter key to request AJAX\n        updates. Generally you won't need to change this value.\n        Default: ``\"row_update\"``.\n\n    .. attribute:: ajax_cell_action_name\n\n        String that is used for the query parameter key to request AJAX\n        updates of cell. Generally you won't need to change this value.\n        It is also used for inline edit of the cell.\n        Default: ``\"cell_update\"``.\n    \"\"\"\n    ajax = False\n    ajax_action_name = \"row_update\"\n    ajax_cell_action_name = \"cell_update\"\n\n    def __init__(self, table, datum=None):\n        super(Row, self).__init__()\n        self.table = table\n        self.datum = datum\n        self.selected = False\n        if self.datum:\n            self.load_cells()\n        else:\n            self.id = None\n            self.cells = []\n\n    def load_cells(self, datum=None):\n        \"\"\"Load the row's data (either provided at initialization or as an\n        argument to this function), initiailize all the cells contained\n        by this row, and set the appropriate row properties which require\n        the row's data to be determined.\n\n        This function is called automatically by\n        :meth:`~horizon.tables.Row.__init__` if the ``datum`` argument is\n        provided. However, by not providing the data during initialization\n        this function allows for the possibility of a two-step loading\n        pattern when you need a row instance but don't yet have the data\n        available.\n        \"\"\"\n        # Compile all the cells on instantiation.\n        table = self.table\n        if datum:\n            self.datum = datum\n        else:\n            datum = self.datum\n        cells = []\n        for column in table.columns.values():\n            cell = table._meta.cell_class(datum, column, self)\n            cells.append((column.name or column.auto, cell))\n        self.cells = SortedDict(cells)\n\n        if self.ajax:\n            interval = conf.HORIZON_CONFIG['ajax_poll_interval']\n            self.attrs['data-update-interval'] = interval\n            self.attrs['data-update-url'] = self.get_ajax_update_url()\n            self.classes.append(\"ajax-update\")\n\n        self.attrs['data-object-id'] = table.get_object_id(datum)\n\n        # Add the row's status class and id to the attributes to be rendered.\n        self.classes.append(self.status_class)\n        id_vals = {\"table\": self.table.name,\n                   \"sep\": STRING_SEPARATOR,\n                   \"id\": table.get_object_id(datum)}\n        self.id = \"%(table)s%(sep)srow%(sep)s%(id)s\" % id_vals\n        self.attrs['id'] = self.id\n\n        # Add the row's display name if available\n        display_name = table.get_object_display(datum)\n        if display_name:\n            self.attrs['data-display'] = escape(display_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.id)\n\n    def __iter__(self):\n        return iter(self.cells.values())\n\n    @property\n    def status(self):\n        column_names = self.table._meta.status_columns\n        if column_names:\n            statuses = dict([(column_name, self.cells[column_name].status) for\n                             column_name in column_names])\n            return self.table.calculate_row_status(statuses)\n\n    @property\n    def status_class(self):\n        column_names = self.table._meta.status_columns\n        if column_names:\n            return self.table.get_row_status_class(self.status)\n        else:\n            return ''\n\n    def render(self):\n        return render_to_string(\"horizon/common/_data_table_row.html\",\n                                {\"row\": self})\n\n    def get_cells(self):\n        \"\"\"Returns the bound cells for this row in order.\"\"\"\n        return self.cells.values()\n\n    def get_ajax_update_url(self):\n        table_url = self.table.get_absolute_url()\n        params = urlencode({\"table\": self.table.name,\n                            \"action\": self.ajax_action_name,\n                            \"obj_id\": self.table.get_object_id(self.datum)})\n        return \"%s?%s\" % (table_url, params)\n\n    def can_be_selected(self, datum):\n        \"\"\"By default if multiselect enabled return True. You can remove the\n        checkbox after an ajax update here if required.\n        \"\"\"\n        return True\n\n    def get_data(self, request, obj_id):\n        \"\"\"Fetches the updated data for the row based on the object id\n        passed in. Must be implemented by a subclass to allow AJAX updating.\n        \"\"\"\n        raise NotImplementedError(\"You must define a get_data method on %s\"\n                                  % self.__class__.__name__)\n\n\nclass Cell(html.HTMLElement):\n    \"\"\"Represents a single cell in the table.\"\"\"\n\n    def __init__(self, datum, column, row, attrs=None, classes=None):\n        self.classes = classes or getattr(self, \"classes\", [])\n        super(Cell, self).__init__()\n        self.attrs.update(attrs or {})\n\n        self.datum = datum\n        self.column = column\n        self.row = row\n        self.wrap_list = column.wrap_list\n        self.inline_edit_available = self.column.update_action is not None\n        # initialize the update action if available\n        if self.inline_edit_available:\n            self.update_action = self.column.update_action()\n            self.attrs['data-cell-name'] = column.name\n            self.attrs['data-update-url'] = self.get_ajax_update_url()\n        self.inline_edit_mod = False\n        self.data = self.get_data(datum, column, row)\n\n    def get_data(self, datum, column, row):\n        \"\"\"Fetches the data to be displayed in this cell.\"\"\"\n        table = row.table\n        if column.auto == \"multi_select\":\n            data = \"\"\n            if row.can_be_selected(datum):\n                widget = forms.CheckboxInput(check_test=lambda value: False)\n                # Convert value to string to avoid accidental type conversion\n                data = widget.render('object_ids',\n                                     unicode(table.get_object_id(datum)),\n                                     {'class': 'table-row-multi-select'})\n            table._data_cache[column][table.get_object_id(datum)] = data\n        elif column.auto == \"form_field\":\n            widget = column.form_field\n            if issubclass(widget.__class__, forms.Field):\n                widget = widget.widget\n\n            widget_name = \"%s__%s\" % \\\n                (column.name,\n                 unicode(table.get_object_id(datum)))\n\n            # Create local copy of attributes, so it don't change column\n            # class form_field_attributes\n            form_field_attributes = {}\n            form_field_attributes.update(column.form_field_attributes)\n            # Adding id of the input so it pairs with label correctly\n            form_field_attributes['id'] = widget_name\n\n            data = widget.render(widget_name,\n                                 column.get_data(datum),\n                                 form_field_attributes)\n            table._data_cache[column][table.get_object_id(datum)] = data\n        elif column.auto == \"actions\":\n            data = table.render_row_actions(datum)\n            table._data_cache[column][table.get_object_id(datum)] = data\n        else:\n            data = column.get_data(datum)\n        return data\n\n    def __repr__(self):\n        return '<%s: %s, %s>' % (self.__class__.__name__,\n                                 self.column.name,\n                                 self.row.id)\n\n    @property\n    def id(self):\n        return (\"%s__%s\" % (self.column.name,\n                unicode(self.row.table.get_object_id(self.datum))))\n\n    @property\n    def value(self):\n        \"\"\"Returns a formatted version of the data for final output.\n\n        This takes into consideration the\n        :attr:`~horizon.tables.Column.link`` and\n        :attr:`~horizon.tables.Column.empty_value`\n        attributes.\n        \"\"\"\n        try:\n            data = self.column.get_data(self.datum)\n            if data is None:\n                if callable(self.column.empty_value):\n                    data = self.column.empty_value(self.datum)\n                else:\n                    data = self.column.empty_value\n        except Exception:\n            data = None\n            exc_info = sys.exc_info()\n            raise template.TemplateSyntaxError, exc_info[1], exc_info[2]\n        if self.url:\n            link_classes = ' '.join(self.column.link_classes)\n            # Escape the data inside while allowing our HTML to render\n            data = mark_safe('<a href=\"%s\" class=\"%s\">%s</a>' %\n                             (self.url, link_classes, escape(unicode(data))))\n        return data\n\n    @property\n    def url(self):\n        if self.column.link:\n            url = self.column.get_link_url(self.datum)\n            if url:\n                return url\n        else:\n            return None\n\n    @property\n    def status(self):\n        \"\"\"Gets the status for the column based on the cell's data.\"\"\"\n        # Deal with status column mechanics based in this cell's data\n        if hasattr(self, '_status'):\n            return self._status\n\n        if self.column.status or \\\n                self.column.name in self.column.table._meta.status_columns:\n            #returns the first matching status found\n            data_value_lower = unicode(self.data).lower()\n            for status_name, status_value in self.column.status_choices:\n                if unicode(status_name).lower() == data_value_lower:\n                    self._status = status_value\n                    return self._status\n        self._status = None\n        return self._status\n\n    def get_status_class(self, status):\n        \"\"\"Returns a css class name determined by the status value.\"\"\"\n        if status is True:\n            return \"status_up\"\n        elif status is False:\n            return \"status_down\"\n        else:\n            return \"status_unknown\"\n\n    def get_default_classes(self):\n        \"\"\"Returns a flattened string of the cell's CSS classes.\"\"\"\n        if not self.url:\n            self.column.classes = [cls for cls in self.column.classes\n                                    if cls != \"anchor\"]\n        column_class_string = self.column.get_final_attrs().get('class', \"\")\n        classes = set(column_class_string.split(\" \"))\n        if self.column.status:\n            classes.add(self.get_status_class(self.status))\n\n        if self.inline_edit_available:\n            classes.add(\"inline_edit_available\")\n\n        return list(classes)\n\n    def get_ajax_update_url(self):\n        column = self.column\n        table_url = column.table.get_absolute_url()\n        params = urlencode({\"table\": column.table.name,\n                            \"action\": self.row.ajax_cell_action_name,\n                            \"obj_id\": column.table.get_object_id(self.datum),\n                            \"cell_name\": column.name})\n        return \"%s?%s\" % (table_url, params)\n\n    @property\n    def update_allowed(self):\n        \"\"\"Determines whether update of given cell is allowed.\n\n        Calls allowed action of defined UpdateAction of the Column.\n        \"\"\"\n        return self.update_action.allowed(self.column.table.request,\n                                          self.datum,\n                                          self)\n\n    def render(self):\n        return render_to_string(\"horizon/common/_data_table_cell.html\",\n                                {\"cell\": self})\n\n\nclass DataTableOptions(object):\n    \"\"\"Contains options for :class:`.DataTable` objects.\n\n    .. attribute:: name\n\n        A short name or slug for the table.\n\n    .. attribute:: verbose_name\n\n        A more verbose name for the table meant for display purposes.\n\n    .. attribute:: columns\n\n        A list of column objects or column names. Controls ordering/display\n        of the columns in the table.\n\n    .. attribute:: table_actions\n\n        A list of action classes derived from the\n        :class:`~horizon.tables.Action` class. These actions will handle tasks\n        such as bulk deletion, etc. for multiple objects at once.\n\n    .. attribute:: row_actions\n\n        A list similar to ``table_actions`` except tailored to appear for\n        each row. These actions act on a single object at a time.\n\n    .. attribute:: actions_column\n\n        Boolean value to control rendering of an additional column containing\n        the various actions for each row. Defaults to ``True`` if any actions\n        are specified in the ``row_actions`` option.\n\n    .. attribute:: multi_select\n\n        Boolean value to control rendering of an extra column with checkboxes\n        for selecting multiple objects in the table. Defaults to ``True`` if\n        any actions are specified in the ``table_actions`` option.\n\n    .. attribute:: filter\n\n        Boolean value to control the display of the \"filter\" search box\n        in the table actions. By default it checks whether or not an instance\n        of :class:`.FilterAction` is in :attr:`.table_actions`.\n\n    .. attribute:: template\n\n        String containing the template which should be used to render the\n        table. Defaults to ``\"horizon/common/_data_table.html\"``.\n\n    .. attribute:: context_var_name\n\n        The name of the context variable which will contain the table when\n        it is rendered. Defaults to ``\"table\"``.\n\n    .. attribute:: pagination_param\n\n        The name of the query string parameter which will be used when\n        paginating this table. When using multiple tables in a single\n        view this will need to be changed to differentiate between the\n        tables. Default: ``\"marker\"``.\n\n    .. attribute:: status_columns\n\n        A list or tuple of column names which represents the \"state\"\n        of the data object being represented.\n\n        If ``status_columns`` is set, when the rows are rendered the value\n        of this column will be used to add an extra class to the row in\n        the form of ``\"status_up\"`` or ``\"status_down\"`` for that row's\n        data.\n\n        The row status is used by other Horizon components to trigger tasks\n        such as dynamic AJAX updating.\n\n    .. attribute:: cell_class\n\n        The class which should be used for rendering the cells of this table.\n        Optional. Default: :class:`~horizon.tables.Cell`.\n\n    .. attribute:: row_class\n\n        The class which should be used for rendering the rows of this table.\n        Optional. Default: :class:`~horizon.tables.Row`.\n\n    .. attribute:: column_class\n\n        The class which should be used for handling the columns of this table.\n        Optional. Default: :class:`~horizon.tables.Column`.\n\n    .. attribute:: mixed_data_type\n\n        A toggle to indicate if the table accepts two or more types of data.\n        Optional. Default: :``False``\n\n    .. attribute:: data_types\n\n        A list of data types that this table would accept. Default to be an\n        empty list, but if the attribute ``mixed_data_type`` is set to\n        ``True``, then this list must have at least one element.\n\n    .. attribute:: data_type_name\n\n        The name of an attribute to assign to data passed to the table when it\n        accepts mix data. Default: ``\"_table_data_type\"``\n\n    .. attribute:: footer\n\n        Boolean to control whether or not to show the table's footer.\n        Default: ``True``.\n\n    .. attribute:: permissions\n\n        A list of permission names which this table requires in order to be\n        displayed. Defaults to an empty list (``[]``).\n    \"\"\"\n    def __init__(self, options):\n        self.name = getattr(options, 'name', self.__class__.__name__)\n        verbose_name = getattr(options, 'verbose_name', None) \\\n                                    or self.name.title()\n        self.verbose_name = verbose_name\n        self.columns = getattr(options, 'columns', None)\n        self.status_columns = getattr(options, 'status_columns', [])\n        self.table_actions = getattr(options, 'table_actions', [])\n        self.row_actions = getattr(options, 'row_actions', [])\n        self.cell_class = getattr(options, 'cell_class', Cell)\n        self.row_class = getattr(options, 'row_class', Row)\n        self.column_class = getattr(options, 'column_class', Column)\n        self.pagination_param = getattr(options, 'pagination_param', 'marker')\n        self.browser_table = getattr(options, 'browser_table', None)\n        self.footer = getattr(options, 'footer', True)\n        self.no_data_message = getattr(options,\n                                       \"no_data_message\",\n                                       _(\"No items to display.\"))\n        self.permissions = getattr(options, 'permissions', [])\n\n        # Set self.filter if we have any FilterActions\n        filter_actions = [action for action in self.table_actions if\n                          issubclass(action, FilterAction)]\n        if len(filter_actions) > 1:\n            raise NotImplementedError(\"Multiple filter actions is not \"\n                                      \"currently supported.\")\n        self.filter = getattr(options, 'filter', len(filter_actions) > 0)\n        if len(filter_actions) == 1:\n            self._filter_action = filter_actions.pop()\n        else:\n            self._filter_action = None\n\n        self.template = getattr(options,\n                                'template',\n                                'horizon/common/_data_table.html')\n        self.row_actions_template = \\\n                        'horizon/common/_data_table_row_actions.html'\n        self.table_actions_template = \\\n                        'horizon/common/_data_table_table_actions.html'\n        self.context_var_name = unicode(getattr(options,\n                                                'context_var_name',\n                                                'table'))\n        self.actions_column = getattr(options,\n                                     'actions_column',\n                                     len(self.row_actions) > 0)\n        self.multi_select = getattr(options,\n                                    'multi_select',\n                                    len(self.table_actions) > 0)\n\n        # Set runtime table defaults; not configurable.\n        self.has_more_data = False\n\n        # Set mixed data type table attr\n        self.mixed_data_type = getattr(options, 'mixed_data_type', False)\n        self.data_types = getattr(options, 'data_types', [])\n\n        # If the data_types has more than 2 elements, set mixed_data_type\n        # to True automatically.\n        if len(self.data_types) > 1:\n            self.mixed_data_type = True\n\n        # However, if the mixed_data_type is set to True manually and the\n        # the data_types is empty, raise an error.\n        if self.mixed_data_type and len(self.data_types) <= 1:\n            raise ValueError(\"If mixed_data_type is set to True in class %s, \"\n                             \"data_types should has more than one types\" %\n                             self.name)\n\n        self.data_type_name = getattr(options,\n                                      'data_type_name',\n                                      \"_table_data_type\")\n\n\nclass DataTableMetaclass(type):\n    \"\"\"Metaclass to add options to DataTable class and collect columns.\"\"\"\n    def __new__(mcs, name, bases, attrs):\n        # Process options from Meta\n        class_name = name\n        attrs[\"_meta\"] = opts = DataTableOptions(attrs.get(\"Meta\", None))\n\n        # Gather columns; this prevents the column from being an attribute\n        # on the DataTable class and avoids naming conflicts.\n        columns = []\n        for attr_name, obj in attrs.items():\n            if issubclass(type(obj), (opts.column_class, Column)):\n                column_instance = attrs.pop(attr_name)\n                column_instance.name = attr_name\n                column_instance.classes.append('normal_column')\n                columns.append((attr_name, column_instance))\n        columns.sort(key=lambda x: x[1].creation_counter)\n\n        # Iterate in reverse to preserve final order\n        for base in bases[::-1]:\n            if hasattr(base, 'base_columns'):\n                columns = base.base_columns.items() + columns\n        attrs['base_columns'] = SortedDict(columns)\n\n        # If the table is in a ResourceBrowser, the column number must meet\n        # these limits because of the width of the browser.\n        if opts.browser_table == \"navigation\" and len(columns) > 3:\n            raise ValueError(\"You can only assign three column to %s.\"\n                             % class_name)\n        if opts.browser_table == \"content\" and len(columns) > 2:\n            raise ValueError(\"You can only assign two columns to %s.\"\n                             % class_name)\n\n        if opts.columns:\n            # Remove any columns that weren't declared if we're being explicit\n            # NOTE: we're iterating a COPY of the list here!\n            for column_data in columns[:]:\n                if column_data[0] not in opts.columns:\n                    columns.pop(columns.index(column_data))\n            # Re-order based on declared columns\n            columns.sort(key=lambda x: attrs['_meta'].columns.index(x[0]))\n        # Add in our auto-generated columns\n        if opts.multi_select and opts.browser_table != \"navigation\":\n            multi_select = opts.column_class(\"multi_select\",\n                                             verbose_name=\"\",\n                                             auto=\"multi_select\")\n            multi_select.classes.append('multi_select_column')\n            columns.insert(0, (\"multi_select\", multi_select))\n        if opts.actions_column:\n            actions_column = opts.column_class(\"actions\",\n                                               verbose_name=_(\"Actions\"),\n                                               auto=\"actions\")\n            actions_column.classes.append('actions_column')\n            columns.append((\"actions\", actions_column))\n        # Store this set of columns internally so we can copy them per-instance\n        attrs['_columns'] = SortedDict(columns)\n\n        # Gather and register actions for later access since we only want\n        # to instantiate them once.\n        # (list() call gives deterministic sort order, which sets don't have.)\n        actions = list(set(opts.row_actions) | set(opts.table_actions))\n        actions.sort(key=attrgetter('name'))\n        actions_dict = SortedDict([(action.name, action())\n                                   for action in actions])\n        attrs['base_actions'] = actions_dict\n        if opts._filter_action:\n            # Replace our filter action with the instantiated version\n            opts._filter_action = actions_dict[opts._filter_action.name]\n\n        # Create our new class!\n        return type.__new__(mcs, name, bases, attrs)\n\n\nclass DataTable(object):\n    \"\"\"A class which defines a table with all data and associated actions.\n\n    .. attribute:: name\n\n        String. Read-only access to the name specified in the\n        table's Meta options.\n\n    .. attribute:: multi_select\n\n        Boolean. Read-only access to whether or not this table\n        should display a column for multi-select checkboxes.\n\n    .. attribute:: data\n\n        Read-only access to the data this table represents.\n\n    .. attribute:: filtered_data\n\n        Read-only access to the data this table represents, filtered by\n        the :meth:`~horizon.tables.FilterAction.filter` method of the table's\n        :class:`~horizon.tables.FilterAction` class (if one is provided)\n        using the current request's query parameters.\n    \"\"\"\n    __metaclass__ = DataTableMetaclass\n\n    def __init__(self, request, data=None, needs_form_wrapper=None, **kwargs):\n        self.request = request\n        self.data = data\n        self.kwargs = kwargs\n        self._needs_form_wrapper = needs_form_wrapper\n        self._no_data_message = self._meta.no_data_message\n        self.breadcrumb = None\n        self.current_item_id = None\n        self.permissions = self._meta.permissions\n\n        # Create a new set\n        columns = []\n        for key, _column in self._columns.items():\n            column = copy.copy(_column)\n            column.table = self\n            columns.append((key, column))\n        self.columns = SortedDict(columns)\n        self._populate_data_cache()\n\n        # Associate these actions with this table\n        for action in self.base_actions.values():\n            action.table = self\n\n        self.needs_summary_row = any([col.summation\n                                      for col in self.columns.values()])\n\n    def __unicode__(self):\n        return unicode(self._meta.verbose_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self._meta.name)\n\n    @property\n    def name(self):\n        return self._meta.name\n\n    @property\n    def footer(self):\n        return self._meta.footer\n\n    @property\n    def multi_select(self):\n        return self._meta.multi_select\n\n    @property\n    def filtered_data(self):\n        # This function should be using django.utils.functional.cached_property\n        # decorator, but unfortunately due to bug in Django\n        # https://code.djangoproject.com/ticket/19872 it would make it fail\n        # when being mocked by mox in tests.\n        if not hasattr(self, '_filtered_data'):\n            self._filtered_data = self.data\n            if self._meta.filter and self._meta._filter_action:\n                action = self._meta._filter_action\n                filter_string = self.get_filter_string()\n                request_method = self.request.method\n                needs_preloading = (not filter_string\n                                    and request_method == 'GET'\n                                    and action.needs_preloading)\n                valid_method = (request_method == action.method)\n                if valid_method or needs_preloading:\n                    if self._meta.mixed_data_type:\n                        self._filtered_data = action.data_type_filter(self,\n                                                                self.data,\n                                                                filter_string)\n                    else:\n                        self._filtered_data = action.filter(self,\n                                                            self.data,\n                                                            filter_string)\n        return self._filtered_data\n\n    def get_filter_string(self):\n        filter_action = self._meta._filter_action\n        param_name = filter_action.get_param_name()\n        filter_string = self.request.POST.get(param_name, '')\n        return filter_string\n\n    def _populate_data_cache(self):\n        self._data_cache = {}\n        # Set up hash tables to store data points for each column\n        for column in self.get_columns():\n            self._data_cache[column] = {}\n\n    def _filter_action(self, action, request, datum=None):\n        try:\n            # Catch user errors in permission functions here\n            row_matched = True\n            if self._meta.mixed_data_type:\n                row_matched = action.data_type_matched(datum)\n            return action._allowed(request, datum) and row_matched\n        except Exception:\n            LOG.exception(\"Error while checking action permissions.\")\n            return None\n\n    def is_browser_table(self):\n        if self._meta.browser_table:\n            return True\n        return False\n\n    def render(self):\n        \"\"\"Renders the table using the template from the table options.\"\"\"\n        table_template = template.loader.get_template(self._meta.template)\n        extra_context = {self._meta.context_var_name: self}\n        context = template.RequestContext(self.request, extra_context)\n        return table_template.render(context)\n\n    def get_absolute_url(self):\n        \"\"\"Returns the canonical URL for this table.\n\n        This is used for the POST action attribute on the form element\n        wrapping the table. In many cases it is also useful for redirecting\n        after a successful action on the table.\n\n        For convenience it defaults to the value of\n        ``request.get_full_path()`` with any query string stripped off,\n        e.g. the path at which the table was requested.\n        \"\"\"\n        return self.request.get_full_path().partition('?')[0]\n\n    def get_full_url(self):\n        \"\"\"Returns the full URL path for this table.\n\n        This is used for the POST action attribute on the form element\n        wrapping the table. We use this method to persist the\n        pagination marker.\n\n        \"\"\"\n        return self.request.get_full_path()\n\n    def get_empty_message(self):\n        \"\"\"Returns the message to be displayed when there is no data.\"\"\"\n        return self._no_data_message\n\n    def get_object_by_id(self, lookup):\n        \"\"\"Returns the data object from the table's dataset which matches\n        the ``lookup`` parameter specified. An error will be raised if\n        the match is not a single data object.\n\n        We will convert the object id and ``lookup`` to unicode before\n        comparison.\n\n        Uses :meth:`~horizon.tables.DataTable.get_object_id` internally.\n        \"\"\"\n        if not isinstance(lookup, unicode):\n            lookup = unicode(str(lookup), 'utf-8')\n        matches = []\n        for datum in self.data:\n            obj_id = self.get_object_id(datum)\n            if not isinstance(obj_id, unicode):\n                obj_id = unicode(str(obj_id), 'utf-8')\n            if obj_id == lookup:\n                matches.append(datum)\n        if len(matches) > 1:\n            raise ValueError(\"Multiple matches were returned for that id: %s.\"\n                           % matches)\n        if not matches:\n            raise exceptions.Http302(self.get_absolute_url(),\n                                     _('No match returned for the id \"%s\".')\n                                       % lookup)\n        return matches[0]\n\n    @property\n    def has_actions(self):\n        \"\"\"Boolean. Indicates whether there are any available actions on this\n        table.\n        \"\"\"\n        if not self.base_actions:\n            return False\n        return any(self.get_table_actions()) or any(self._meta.row_actions)\n\n    @property\n    def needs_form_wrapper(self):\n        \"\"\"Boolean. Indicates whether this table should be rendered wrapped in\n        a ``<form>`` tag or not.\n        \"\"\"\n        # If needs_form_wrapper is explicitly set, defer to that.\n        if self._needs_form_wrapper is not None:\n            return self._needs_form_wrapper\n        # Otherwise calculate whether or not we need a form element.\n        return self.has_actions\n\n    def get_table_actions(self):\n        \"\"\"Returns a list of the action instances for this table.\"\"\"\n        bound_actions = [self.base_actions[action.name] for\n                         action in self._meta.table_actions]\n        return [action for action in bound_actions if\n                self._filter_action(action, self.request)]\n\n    def get_row_actions(self, datum):\n        \"\"\"Returns a list of the action instances for a specific row.\"\"\"\n        bound_actions = []\n        for action in self._meta.row_actions:\n            # Copy to allow modifying properties per row\n            bound_action = copy.copy(self.base_actions[action.name])\n            bound_action.attrs = copy.copy(bound_action.attrs)\n            bound_action.datum = datum\n            # Remove disallowed actions.\n            if not self._filter_action(bound_action,\n                                       self.request,\n                                       datum):\n                continue\n            # Hook for modifying actions based on data. No-op by default.\n            bound_action.update(self.request, datum)\n            # Pre-create the URL for this link with appropriate parameters\n            if issubclass(bound_action.__class__, LinkAction):\n                bound_action.bound_url = bound_action.get_link_url(datum)\n            bound_actions.append(bound_action)\n        return bound_actions\n\n    def render_table_actions(self):\n        \"\"\"Renders the actions specified in ``Meta.table_actions``.\"\"\"\n        template_path = self._meta.table_actions_template\n        table_actions_template = template.loader.get_template(template_path)\n        bound_actions = self.get_table_actions()\n        extra_context = {\"table_actions\": bound_actions}\n        if self._meta.filter and \\\n           self._filter_action(self._meta._filter_action, self.request):\n            extra_context[\"filter\"] = self._meta._filter_action\n        context = template.RequestContext(self.request, extra_context)\n        return table_actions_template.render(context)\n\n    def render_row_actions(self, datum):\n        \"\"\"Renders the actions specified in ``Meta.row_actions`` using the\n        current row data.\n        \"\"\"\n        template_path = self._meta.row_actions_template\n        row_actions_template = template.loader.get_template(template_path)\n        bound_actions = self.get_row_actions(datum)\n        extra_context = {\"row_actions\": bound_actions,\n                         \"row_id\": self.get_object_id(datum)}\n        context = template.RequestContext(self.request, extra_context)\n        return row_actions_template.render(context)\n\n    @staticmethod\n    def parse_action(action_string):\n        \"\"\"Parses the ``action`` parameter (a string) sent back with the\n        POST data. By default this parses a string formatted as\n        ``{{ table_name }}__{{ action_name }}__{{ row_id }}`` and returns\n        each of the pieces. The ``row_id`` is optional.\n        \"\"\"\n        if action_string:\n            bits = action_string.split(STRING_SEPARATOR)\n            bits.reverse()\n            table = bits.pop()\n            action = bits.pop()\n            try:\n                object_id = bits.pop()\n            except IndexError:\n                object_id = None\n            return table, action, object_id\n\n    def take_action(self, action_name, obj_id=None, obj_ids=None):\n        \"\"\"Locates the appropriate action and routes the object\n        data to it. The action should return an HTTP redirect\n        if successful, or a value which evaluates to ``False``\n        if unsuccessful.\n        \"\"\"\n        # See if we have a list of ids\n        obj_ids = obj_ids or self.request.POST.getlist('object_ids')\n        action = self.base_actions.get(action_name, None)\n        if not action or action.method != self.request.method:\n            # We either didn't get an action or we're being hacked. Goodbye.\n            return None\n\n        # Meanwhile, back in Gotham...\n        if not action.requires_input or obj_id or obj_ids:\n            if obj_id:\n                obj_id = self.sanitize_id(obj_id)\n            if obj_ids:\n                obj_ids = [self.sanitize_id(i) for i in obj_ids]\n            # Single handling is easy\n            if not action.handles_multiple:\n                response = action.single(self, self.request, obj_id)\n            # Otherwise figure out what to pass along\n            else:\n                # Preference given to a specific id, since that implies\n                # the user selected an action for just one row.\n                if obj_id:\n                    obj_ids = [obj_id]\n                response = action.multiple(self, self.request, obj_ids)\n            return response\n        elif action and action.requires_input and not (obj_id or obj_ids):\n            messages.info(self.request,\n                          _(\"Please select a row before taking that action.\"))\n        return None\n\n    @classmethod\n    def check_handler(cls, request):\n        \"\"\"Determine whether the request should be handled by this table.\"\"\"\n        if request.method == \"POST\" and \"action\" in request.POST:\n            table, action, obj_id = cls.parse_action(request.POST[\"action\"])\n        elif \"table\" in request.GET and \"action\" in request.GET:\n            table = request.GET[\"table\"]\n            action = request.GET[\"action\"]\n            obj_id = request.GET.get(\"obj_id\", None)\n        else:\n            table = action = obj_id = None\n        return table, action, obj_id\n\n    def maybe_preempt(self):\n        \"\"\"Determine whether the request should be handled by a preemptive\n        action on this table or by an AJAX row update before loading any data.\n        \"\"\"\n        request = self.request\n        table_name, action_name, obj_id = self.check_handler(request)\n\n        if table_name == self.name:\n            # Handle AJAX row updating.\n            new_row = self._meta.row_class(self)\n            if new_row.ajax and new_row.ajax_action_name == action_name:\n                try:\n                    datum = new_row.get_data(request, obj_id)\n                    new_row.load_cells(datum)\n                    error = False\n                except Exception:\n                    datum = None\n                    error = exceptions.handle(request, ignore=True)\n                if request.is_ajax():\n                    if not error:\n                        return HttpResponse(new_row.render())\n                    else:\n                        return HttpResponse(status=error.status_code)\n            elif new_row.ajax_cell_action_name == action_name:\n                # inline edit of the cell actions\n                return self.inline_edit_handle(request, table_name,\n                                               action_name, obj_id,\n                                               new_row)\n\n            preemptive_actions = [action for action in\n                                  self.base_actions.values() if action.preempt]\n            if action_name:\n                for action in preemptive_actions:\n                    if action.name == action_name:\n                        handled = self.take_action(action_name, obj_id)\n                        if handled:\n                            return handled\n        return None\n\n    def inline_edit_handle(self, request, table_name, action_name, obj_id,\n                           new_row):\n        \"\"\"Inline edit handler.\n\n        Showing form or handling update by POST of the cell.\n        \"\"\"\n        try:\n            cell_name = request.GET['cell_name']\n            datum = new_row.get_data(request, obj_id)\n            # TODO(lsmola) extract load cell logic to Cell and load\n            # only 1 cell. This is kind of ugly.\n            if request.GET.get('inline_edit_mod') == \"true\":\n                new_row.table.columns[cell_name].auto = \"form_field\"\n                inline_edit_mod = True\n            else:\n                inline_edit_mod = False\n\n            # Load the cell and set the inline_edit_mod.\n            new_row.load_cells(datum)\n            cell = new_row.cells[cell_name]\n            cell.inline_edit_mod = inline_edit_mod\n\n            # If not allowed, neither edit mod or updating is allowed.\n            if not cell.update_allowed:\n                datum_display = (self.get_object_display(datum) or\n                                 _(\"N/A\"))\n                LOG.info('Permission denied to %s: \"%s\"' %\n                         (\"Update Action\", datum_display))\n                return HttpResponse(status=401)\n            # If it is post request, we are updating the cell.\n            if request.method == \"POST\":\n                return self.inline_update_action(request,\n                                                 datum,\n                                                 cell,\n                                                 obj_id,\n                                                 cell_name)\n\n            error = False\n        except Exception:\n            datum = None\n            error = exceptions.handle(request, ignore=True)\n        if request.is_ajax():\n            if not error:\n                return HttpResponse(cell.render())\n            else:\n                return HttpResponse(status=error.status_code)\n\n    def inline_update_action(self, request, datum, cell, obj_id, cell_name):\n        \"\"\"Handling update by POST of the cell.\n        \"\"\"\n        new_cell_value = request.POST.get(\n            cell_name + '__' + obj_id, None)\n        if issubclass(cell.column.form_field.__class__,\n                      forms.Field):\n            try:\n                # using Django Form Field to parse the\n                # right value from POST and to validate it\n                new_cell_value = (\n                    cell.column.form_field.clean(\n                        new_cell_value))\n                cell.update_action.action(\n                    self.request, datum, obj_id, cell_name, new_cell_value)\n                response = {\n                    'status': 'updated',\n                    'message': ''\n                }\n                return HttpResponse(\n                    json.dumps(response),\n                    status=200,\n                    content_type=\"application/json\")\n\n            except core_exceptions.ValidationError:\n                # if there is a validation error, I will\n                # return the message to the client\n                exc_type, exc_value, exc_traceback = (\n                    sys.exc_info())\n                response = {\n                    'status': 'validation_error',\n                    'message': ' '.join(exc_value.messages)}\n                return HttpResponse(\n                    json.dumps(response),\n                    status=400,\n                    content_type=\"application/json\")\n\n    def maybe_handle(self):\n        \"\"\"Determine whether the request should be handled by any action on\n        this table after data has been loaded.\n        \"\"\"\n        request = self.request\n        table_name, action_name, obj_id = self.check_handler(request)\n        if table_name == self.name and action_name:\n            action_names = [action.name for action in\n                self.base_actions.values() if not action.preempt]\n            # do not run preemptive actions here\n            if action_name in action_names:\n                return self.take_action(action_name, obj_id)\n        return None\n\n    def sanitize_id(self, obj_id):\n        \"\"\"Override to modify an incoming obj_id to match existing\n        API data types or modify the format.\n        \"\"\"\n        return obj_id\n\n    def get_object_id(self, datum):\n        \"\"\"Returns the identifier for the object this row will represent.\n\n        By default this returns an ``id`` attribute on the given object,\n        but this can be overridden to return other values.\n\n        .. warning::\n\n            Make sure that the value returned is a unique value for the id\n            otherwise rendering issues can occur.\n        \"\"\"\n        return datum.id\n\n    def get_object_display(self, datum):\n        \"\"\"Returns a display name that identifies this object.\n\n        By default, this returns a ``name`` attribute from the given object,\n        but this can be overridden to return other values.\n        \"\"\"\n        if hasattr(datum, 'name'):\n            return datum.name\n        return None\n\n    def has_more_data(self):\n        \"\"\"Returns a boolean value indicating whether there is more data\n        available to this table from the source (generally an API).\n\n        The method is largely meant for internal use, but if you want to\n        override it to provide custom behavior you can do so at your own risk.\n        \"\"\"\n        return self._meta.has_more_data\n\n    def get_marker(self):\n        \"\"\"Returns the identifier for the last object in the current data set\n        for APIs that use marker/limit-based paging.\n        \"\"\"\n        return http.urlquote_plus(self.get_object_id(self.data[-1]))\n\n    def get_pagination_string(self):\n        \"\"\"Returns the query parameter string to paginate this table.\"\"\"\n        return \"=\".join([self._meta.pagination_param, self.get_marker()])\n\n    def calculate_row_status(self, statuses):\n        \"\"\"Returns a boolean value determining the overall row status\n        based on the dictionary of column name to status mappings passed in.\n\n        By default, it uses the following logic:\n\n        #. If any statuses are ``False``, return ``False``.\n        #. If no statuses are ``False`` but any or ``None``, return ``None``.\n        #. If all statuses are ``True``, return ``True``.\n\n        This provides the greatest protection against false positives without\n        weighting any particular columns.\n\n        The ``statuses`` parameter is passed in as a dictionary mapping\n        column names to their statuses in order to allow this function to\n        be overridden in such a way as to weight one column's status over\n        another should that behavior be desired.\n        \"\"\"\n        values = statuses.values()\n        if any([status is False for status in values]):\n            return False\n        elif any([status is None for status in values]):\n            return None\n        else:\n            return True\n\n    def get_row_status_class(self, status):\n        \"\"\"Returns a css class name determined by the status value. This class\n        name is used to indicate the status of the rows in the table if\n        any ``status_columns`` have been specified.\n        \"\"\"\n        if status is True:\n            return \"status_up\"\n        elif status is False:\n            return \"status_down\"\n        else:\n            return \"status_unknown\"\n\n    def get_columns(self):\n        \"\"\"Returns this table's columns including auto-generated ones.\"\"\"\n        return self.columns.values()\n\n    def get_rows(self):\n        \"\"\"Return the row data for this table broken out by columns.\"\"\"\n        rows = []\n        try:\n            for datum in self.filtered_data:\n                row = self._meta.row_class(self, datum)\n                if self.get_object_id(datum) == self.current_item_id:\n                    self.selected = True\n                    row.classes.append('current_selected')\n                rows.append(row)\n        except Exception:\n            # Exceptions can be swallowed at the template level here,\n            # re-raising as a TemplateSyntaxError makes them visible.\n            LOG.exception(\"Error while rendering table rows.\")\n            exc_info = sys.exc_info()\n            raise template.TemplateSyntaxError, exc_info[1], exc_info[2]\n        return rows\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2013 Hewlett-Packard Development Company, L.P.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django.core.urlresolvers import reverse\nfrom django.template import defaultfilters\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import tables\n\nfrom openstack_dashboard import api\n\nfrom openstack_dashboard.dashboards.admin.groups import constants\n\n\nLOG = logging.getLogger(__name__)\nLOGOUT_URL = 'logout'\nSTATUS_CHOICES = (\n    (\"true\", True),\n    (\"false\", False)\n)\n\n\nclass CreateGroupLink(tables.LinkAction):\n    name = \"create\"\n    verbose_name = _(\"Create Group\")\n    url = constants.GROUPS_CREATE_URL\n    classes = (\"ajax-modal\", \"btn-create\")\n    policy_rules = ((\"identity\", \"identity:create_group\"),)\n\n    def allowed(self, request, group):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass EditGroupLink(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Edit Group\")\n    url = constants.GROUPS_UPDATE_URL\n    classes = (\"ajax-modal\", \"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:update_group\"),)\n\n    def allowed(self, request, group):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass DeleteGroupsAction(tables.DeleteAction):\n    name = \"delete\"\n    data_type_singular = _(\"Group\")\n    data_type_plural = _(\"Groups\")\n    policy_rules = ((\"identity\", \"identity:delete_group\"),)\n\n    def allowed(self, request, datum):\n        return api.keystone.keystone_can_edit_group()\n\n    def delete(self, request, obj_id):\n        LOG.info('Deleting group \"%s\".' % obj_id)\n        api.keystone.group_delete(request, obj_id)\n\n\nclass ManageUsersLink(tables.LinkAction):\n    name = \"users\"\n    verbose_name = _(\"Modify Users\")\n    url = constants.GROUPS_MANAGE_URL\n    classes = (\"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:get_group\"),\n                    (\"identity\", \"identity:list_users\"),)\n\n    def allowed(self, request, datum):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass GroupFilterAction(tables.FilterAction):\n    def filter(self, table, groups, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n\n        def comp(group):\n            if q in group.name.lower():\n                return True\n            return False\n\n        return filter(comp, groups)\n\n\nclass GroupsTable(tables.DataTable):\n    name = tables.Column('name', verbose_name=_('Name'))\n    description = tables.Column(lambda obj: getattr(obj, 'description', None),\n                                verbose_name=_('Description'))\n    id = tables.Column('id', verbose_name=_('Group ID'))\n\n    class Meta:\n        name = \"groups\"\n        verbose_name = _(\"Groups\")\n        row_actions = (ManageUsersLink, EditGroupLink, DeleteGroupsAction)\n        table_actions = (GroupFilterAction, CreateGroupLink,\n                         DeleteGroupsAction)\n\n\nclass UserFilterAction(tables.FilterAction):\n    def filter(self, table, users, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n        return [user for user in users\n                if q in user.name.lower()\n                or q in getattr(user, 'email', '').lower()]\n\n\nclass RemoveMembers(tables.DeleteAction):\n    name = \"removeGroupMember\"\n    action_present = _(\"Remove\")\n    action_past = _(\"Removed\")\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    policy_rules = ((\"identity\", \"identity:remove_user_from_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def action(self, request, obj_id):\n        user_obj = self.table.get_object_by_id(obj_id)\n        group_id = self.table.kwargs['group_id']\n        LOG.info('Removing user %s from group %s.' % (user_obj.id,\n                                                      group_id))\n        api.keystone.remove_group_user(request,\n                                       group_id=group_id,\n                                       user_id=user_obj.id)\n        # TODO(lin-hua-cheng): Fix the bug when removing current user\n        # Keystone revokes the token of the user removed from the group.\n        # If the logon user was removed, redirect the user to logout.\n\n\nclass AddMembersLink(tables.LinkAction):\n    name = \"add_user_link\"\n    verbose_name = _(\"Add...\")\n    classes = (\"ajax-modal\", \"btn-create\")\n    url = constants.GROUPS_ADD_MEMBER_URL\n    policy_rules = ((\"identity\", \"identity:list_users\"),\n                    (\"identity\", \"identity:add_user_to_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def get_link_url(self, datum=None):\n        return reverse(self.url, kwargs=self.table.kwargs)\n\n\nclass UsersTable(tables.DataTable):\n    name = tables.Column('name', verbose_name=_('User Name'))\n    email = tables.Column('email', verbose_name=_('Email'),\n                          filters=[defaultfilters.urlize])\n    id = tables.Column('id', verbose_name=_('User ID'))\n    enabled = tables.Column('enabled', verbose_name=_('Enabled'),\n                            status=True,\n                            status_choices=STATUS_CHOICES,\n                            empty_value=\"False\")\n\n\nclass GroupMembersTable(UsersTable):\n    class Meta:\n        name = \"group_members\"\n        verbose_name = _(\"Group Members\")\n        table_actions = (UserFilterAction, AddMembersLink, RemoveMembers)\n\n\nclass AddMembers(tables.BatchAction):\n    name = \"addMember\"\n    action_present = _(\"Add\")\n    action_past = _(\"Added\")\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    classes = (\"btn-create\", )\n    requires_input = True\n    success_url = constants.GROUPS_MANAGE_URL\n    policy_rules = ((\"identity\", \"identity:add_user_to_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def action(self, request, obj_id):\n        user_obj = self.table.get_object_by_id(obj_id)\n        group_id = self.table.kwargs['group_id']\n        LOG.info('Adding user %s to group %s.' % (user_obj.id,\n                                                  group_id))\n        api.keystone.add_group_user(request,\n                                    group_id=group_id,\n                                    user_id=user_obj.id)\n        # TODO(lin-hua-cheng): Fix the bug when adding current user\n        # Keystone revokes the token of the user added to the group.\n        # If the logon user was added, redirect the user to logout.\n\n    def get_success_url(self, request=None):\n        group_id = self.table.kwargs.get('group_id', None)\n        return reverse(self.success_url, args=[group_id])\n\n\nclass GroupNonMembersTable(UsersTable):\n    class Meta:\n        name = \"group_non_members\"\n        verbose_name = _(\"Non-Members\")\n        table_actions = (UserFilterAction, AddMembers)\n", "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom django.template import defaultfilters\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tables\n\nfrom openstack_dashboard import api\n\n\nENABLE = 0\nDISABLE = 1\n\n\nclass CreateUserLink(tables.LinkAction):\n    name = \"create\"\n    verbose_name = _(\"Create User\")\n    url = \"horizon:admin:users:create\"\n    classes = (\"ajax-modal\", \"btn-create\")\n    policy_rules = (('identity', 'identity:create_grant'),\n                    (\"identity\", \"identity:create_user\"),\n                    (\"identity\", \"identity:list_roles\"),\n                    (\"identity\", \"identity:list_projects\"),)\n\n    def allowed(self, request, user):\n        return api.keystone.keystone_can_edit_user()\n\n\nclass EditUserLink(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Edit\")\n    url = \"horizon:admin:users:update\"\n    classes = (\"ajax-modal\", \"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:update_user\"),\n                    (\"identity\", \"identity:list_projects\"),)\n\n    def get_policy_target(self, request, user):\n        return {\"user_id\": user.id}\n\n    def allowed(self, request, user):\n        return api.keystone.keystone_can_edit_user()\n\n\nclass ToggleEnabled(tables.BatchAction):\n    name = \"toggle\"\n    action_present = (_(\"Enable\"), _(\"Disable\"))\n    action_past = (_(\"Enabled\"), _(\"Disabled\"))\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    classes = (\"btn-toggle\",)\n    policy_rules = ((\"identity\", \"identity:update_user\"),)\n\n    def get_policy_target(self, request, user=None):\n        if user:\n            return {\"user_id\": user.id}\n        return {}\n\n    def allowed(self, request, user=None):\n        if not api.keystone.keystone_can_edit_user():\n            return False\n\n        self.enabled = True\n        if not user:\n            return self.enabled\n        self.enabled = user.enabled\n        if self.enabled:\n            self.current_present_action = DISABLE\n        else:\n            self.current_present_action = ENABLE\n        return True\n\n    def update(self, request, user=None):\n        super(ToggleEnabled, self).update(request, user)\n        if user and user.id == request.user.id:\n            self.attrs[\"disabled\"] = \"disabled\"\n\n    def action(self, request, obj_id):\n        if obj_id == request.user.id:\n            messages.info(request, _('You cannot disable the user you are '\n                                     'currently logged in as.'))\n            return\n        if self.enabled:\n            api.keystone.user_update_enabled(request, obj_id, False)\n            self.current_past_action = DISABLE\n        else:\n            api.keystone.user_update_enabled(request, obj_id, True)\n            self.current_past_action = ENABLE\n\n\nclass DeleteUsersAction(tables.DeleteAction):\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    policy_rules = ((\"identity\", \"identity:delete_user\"),)\n\n    def allowed(self, request, datum):\n        if not api.keystone.keystone_can_edit_user() or \\\n                (datum and datum.id == request.user.id):\n            return False\n        return True\n\n    def delete(self, request, obj_id):\n        api.keystone.user_delete(request, obj_id)\n\n\nclass UserFilterAction(tables.FilterAction):\n    def filter(self, table, users, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n        return [user for user in users\n                if q in user.name.lower()\n                or q in getattr(user, 'email', '').lower()]\n\n\nclass UsersTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"true\", True),\n        (\"false\", False)\n    )\n    name = tables.Column('name', verbose_name=_('User Name'))\n    email = tables.Column('email', verbose_name=_('Email'),\n                          filters=(lambda v: defaultfilters\n                                   .default_if_none(v, \"\"),\n                                   defaultfilters.urlize))\n    # Default tenant is not returned from Keystone currently.\n    #default_tenant = tables.Column('default_tenant',\n    #                               verbose_name=_('Default Project'))\n    id = tables.Column('id', verbose_name=_('User ID'))\n    enabled = tables.Column('enabled', verbose_name=_('Enabled'),\n                            status=True,\n                            status_choices=STATUS_CHOICES,\n                            empty_value=\"False\")\n\n    class Meta:\n        name = \"users\"\n        verbose_name = _(\"Users\")\n        row_actions = (EditUserLink, ToggleEnabled, DeleteUsersAction)\n        table_actions = (UserFilterAction, CreateUserLink, DeleteUsersAction)\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom django.core import urlresolvers\nfrom django.http import Http404  # noqa\nfrom django.template.defaultfilters import title  # noqa\nfrom django.utils.http import urlencode  # noqa\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tables\nfrom horizon.utils import filters\n\nfrom heatclient import exc\n\nfrom openstack_dashboard import api\nfrom openstack_dashboard.dashboards.project.stacks import mappings\n\n\nclass LaunchStack(tables.LinkAction):\n    name = \"launch\"\n    verbose_name = _(\"Launch Stack\")\n    url = \"horizon:project:stacks:select_template\"\n    classes = (\"btn-create\", \"ajax-modal\")\n\n\nclass ChangeStackTemplate(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Change Stack Template\")\n    url = \"horizon:project:stacks:change_template\"\n    classes = (\"ajax-modal\", \"btn-edit\")\n\n    def get_link_url(self, stack):\n        return urlresolvers.reverse(self.url, args=[stack.id])\n\n\nclass DeleteStack(tables.BatchAction):\n    name = \"delete\"\n    action_present = _(\"Delete\")\n    action_past = _(\"Scheduled deletion of %(data_type)s\")\n    data_type_singular = _(\"Stack\")\n    data_type_plural = _(\"Stacks\")\n    classes = ('btn-danger', 'btn-terminate')\n\n    def action(self, request, stack_id):\n        api.heat.stack_delete(request, stack_id)\n\n    def allowed(self, request, stack):\n        if stack is not None:\n            return stack.stack_status != 'DELETE_COMPLETE'\n        return True\n\n\nclass StacksUpdateRow(tables.Row):\n    ajax = True\n\n    def can_be_selected(self, datum):\n        return datum.stack_status != 'DELETE_COMPLETE'\n\n    def get_data(self, request, stack_id):\n        try:\n            return api.heat.stack_get(request, stack_id)\n        except exc.HTTPNotFound:\n            # returning 404 to the ajax call removes the\n            # row from the table on the ui\n            raise Http404\n        except Exception as e:\n            messages.error(request, e)\n\n\nclass StacksTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"Complete\", True),\n        (\"Failed\", False),\n    )\n    name = tables.Column(\"stack_name\",\n                         verbose_name=_(\"Stack Name\"),\n                         link=\"horizon:project:stacks:detail\",)\n    created = tables.Column(\"creation_time\",\n                            verbose_name=_(\"Created\"),\n                            filters=(filters.parse_isotime,\n                                     filters.timesince_or_never))\n    updated = tables.Column(\"updated_time\",\n                            verbose_name=_(\"Updated\"),\n                            filters=(filters.parse_isotime,\n                                     filters.timesince_or_never))\n    status = tables.Column(\"status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),\n                           status=True,\n                           status_choices=STATUS_CHOICES)\n\n    def get_object_display(self, stack):\n        return stack.stack_name\n\n    class Meta:\n        name = \"stacks\"\n        verbose_name = _(\"Stacks\")\n        status_columns = [\"status\", ]\n        row_class = StacksUpdateRow\n        table_actions = (LaunchStack, DeleteStack,)\n        row_actions = (DeleteStack,\n                       ChangeStackTemplate)\n\n\nclass EventsTable(tables.DataTable):\n\n    logical_resource = tables.Column('resource_name',\n                                     verbose_name=_(\"Stack Resource\"),\n                                     link=lambda d: d.resource_name,)\n    physical_resource = tables.Column('physical_resource_id',\n                                      verbose_name=_(\"Resource\"),\n                                      link=mappings.resource_to_url)\n    timestamp = tables.Column('event_time',\n                              verbose_name=_(\"Time Since Event\"),\n                              filters=(filters.parse_isotime,\n                                       filters.timesince_or_never))\n    status = tables.Column(\"resource_status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),)\n\n    statusreason = tables.Column(\"resource_status_reason\",\n                                 verbose_name=_(\"Status Reason\"),)\n\n    class Meta:\n        name = \"events\"\n        verbose_name = _(\"Stack Events\")\n\n\nclass ResourcesUpdateRow(tables.Row):\n    ajax = True\n\n    def get_data(self, request, resource_name):\n        try:\n            stack = self.table.stack\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            return api.heat.resource_get(\n                request, stack_identifier, resource_name)\n        except exc.HTTPNotFound:\n            # returning 404 to the ajax call removes the\n            # row from the table on the ui\n            raise Http404\n        except Exception as e:\n            messages.error(request, e)\n\n\nclass ResourcesTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"Create Complete\", True),\n        (\"Create Failed\", False),\n    )\n\n    logical_resource = tables.Column('resource_name',\n                                     verbose_name=_(\"Stack Resource\"),\n                                     link=lambda d: d.resource_name)\n    physical_resource = tables.Column('physical_resource_id',\n                                     verbose_name=_(\"Resource\"),\n                                     link=mappings.resource_to_url)\n    resource_type = tables.Column(\"resource_type\",\n                           verbose_name=_(\"Stack Resource Type\"),)\n    updated_time = tables.Column('updated_time',\n                              verbose_name=_(\"Date Updated\"),\n                              filters=(filters.parse_isotime,\n                                       filters.timesince_or_never))\n    status = tables.Column(\"resource_status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),\n                           status=True,\n                           status_choices=STATUS_CHOICES)\n\n    statusreason = tables.Column(\"resource_status_reason\",\n                                 verbose_name=_(\"Status Reason\"),)\n\n    def __init__(self, request, data=None,\n                 needs_form_wrapper=None, **kwargs):\n        super(ResourcesTable, self).__init__(\n            request, data, needs_form_wrapper, **kwargs)\n        self.stack = kwargs['stack']\n\n    def get_object_id(self, datum):\n        return datum.resource_name\n\n    class Meta:\n        name = \"resources\"\n        verbose_name = _(\"Stack Resources\")\n        status_columns = [\"status\", ]\n        row_class = ResourcesUpdateRow\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport logging\n\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tabs\nfrom openstack_dashboard import api\n\nfrom openstack_dashboard.dashboards.project.stacks \\\n    import api as project_api\nfrom openstack_dashboard.dashboards.project.stacks import mappings\nfrom openstack_dashboard.dashboards.project.stacks \\\n    import tables as project_tables\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass StackTopologyTab(tabs.Tab):\n    name = _(\"Topology\")\n    slug = \"topology\"\n    template_name = \"project/stacks/_detail_topology.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        context = {}\n        stack = self.tab_group.kwargs['stack']\n        context['stack_id'] = stack.id\n        context['d3_data'] = project_api.d3_data(request, stack_id=stack.id)\n        return context\n\n\nclass StackOverviewTab(tabs.Tab):\n    name = _(\"Overview\")\n    slug = \"overview\"\n    template_name = \"project/stacks/_detail_overview.html\"\n\n    def get_context_data(self, request):\n        return {\"stack\": self.tab_group.kwargs['stack']}\n\n\nclass ResourceOverviewTab(tabs.Tab):\n    name = _(\"Overview\")\n    slug = \"resource_overview\"\n    template_name = \"project/stacks/_resource_overview.html\"\n\n    def get_context_data(self, request):\n        resource = self.tab_group.kwargs['resource']\n        resource_url = mappings.resource_to_url(resource)\n        return {\n            \"resource\": resource,\n            \"resource_url\": resource_url,\n            \"metadata\": self.tab_group.kwargs['metadata']}\n\n\nclass StackEventsTab(tabs.Tab):\n    name = _(\"Events\")\n    slug = \"events\"\n    template_name = \"project/stacks/_detail_events.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        stack = self.tab_group.kwargs['stack']\n        try:\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            events = api.heat.events_list(self.request, stack_identifier)\n            LOG.debug('got events %s' % events)\n        except Exception:\n            events = []\n            messages.error(request, _(\n                'Unable to get events for stack \"%s\".') % stack.stack_name)\n        return {\"stack\": stack,\n                \"table\": project_tables.EventsTable(request, data=events), }\n\n\nclass StackResourcesTab(tabs.Tab):\n    name = _(\"Resources\")\n    slug = \"resources\"\n    template_name = \"project/stacks/_detail_resources.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        stack = self.tab_group.kwargs['stack']\n        try:\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            resources = api.heat.resources_list(self.request, stack_identifier)\n            LOG.debug('got resources %s' % resources)\n        except Exception:\n            resources = []\n            messages.error(request, _(\n                'Unable to get resources for stack \"%s\".') % stack.stack_name)\n        return {\"stack\": stack,\n                \"table\": project_tables.ResourcesTable(\n                    request, data=resources, stack=stack), }\n\n\nclass StackDetailTabs(tabs.TabGroup):\n    slug = \"stack_details\"\n    tabs = (StackTopologyTab, StackOverviewTab, StackResourcesTab,\n            StackEventsTab)\n    sticky = True\n\n\nclass ResourceDetailTabs(tabs.TabGroup):\n    slug = \"resource_details\"\n    tabs = (ResourceOverviewTab,)\n    sticky = True\n"], "fixing_code": ["horizon.instances = {\n  user_decided_length: false,\n  networks_selected: [],\n  networks_available: [],\n\n  getConsoleLog: function(via_user_submit) {\n    var form_element = $(\"#tail_length\"),\n      data;\n\n    if (!via_user_submit) {\n      via_user_submit = false;\n    }\n\n    if(this.user_decided_length) {\n      data = $(form_element).serialize();\n    } else {\n      data = \"length=35\";\n    }\n\n    $.ajax({\n      url: $(form_element).attr('action'),\n      data: data,\n      method: 'get',\n      success: function(response_body) {\n        $('pre.logs').text(response_body);\n      },\n      error: function(response) {\n        if(via_user_submit) {\n          horizon.clearErrorMessages();\n          horizon.alert('error', gettext('There was a problem communicating with the server, please try again.'));\n        }\n      }\n    });\n  },\n\n  /*\n   * Gets the html select element associated with a given\n   * network id for network_id.\n   **/\n  get_network_element: function(network_id) {\n    return $('li > label[for^=\"id_network_' + network_id + '\"]');\n  },\n\n  /*\n   * Initializes an associative array of lists of the current\n   * networks.\n   **/\n  init_network_list: function() {\n    horizon.instances.networks_selected = [];\n    horizon.instances.networks_available = [];\n    $(this.get_network_element(\"\")).each(function(){\n      var $this = $(this);\n      var $input = $this.children(\"input\");\n      var name = $this.text().replace(/^\\s+/,\"\")\n                             .replace(/&/g, '&amp;')\n                             .replace(/</g, '&lt;')\n                             .replace(/>/g, '&gt;')\n                             .replace(/\"/g, '&quot;')\n                             .replace(/'/g, '&#x27;')\n                             .replace(/\\//g, '&#x2F;');\n      var network_property = {\n        name:name,\n        id:$input.attr(\"id\"),\n        value:$input.attr(\"value\")\n      };\n      if($input.is(':checked')) {\n        horizon.instances.networks_selected.push(network_property);\n      } else {\n        horizon.instances.networks_available.push(network_property);\n      }\n    });\n  },\n\n  /*\n   * Generates the HTML structure for a network that will be displayed\n   * as a list item in the network list.\n   **/\n  generate_network_element: function(name, id, value) {\n    var $li = $('<li>');\n    $li.attr('name', value).html(name + '<em class=\"network_id\">(' + value + ')</em><a href=\"#\" class=\"btn btn-primary\"></a>');\n    return $li;\n  },\n\n  /*\n   * Generates the HTML structure for the Network List.\n   **/\n  generate_networklist_html: function() {\n    var self = this;\n    var updateForm = function() {\n      var lists = $(\"#networkListId div.input li\").attr('data-index',100);\n      var active_networks = $(\"#selected_network > li\").map(function(){\n        return $(this).attr(\"name\");\n      });\n      $(\"#networkListId div.input input:checkbox\").removeAttr('checked');\n      active_networks.each(function(index, value){\n        $(\"#networkListId div.input input:checkbox[value=\" + value + \"]\")\n          .attr('checked','checked')\n          .parents(\"li\").attr('data-index',index);\n      });\n      $(\"#networkListId div.input ul\").html(\n        lists.sort(function(a,b){\n          if( $(a).data(\"index\") < $(b).data(\"index\")) { return -1; }\n          if( $(a).data(\"index\") > $(b).data(\"index\")) { return 1; }\n          return 0;\n        })\n      );\n    };\n    $(\"#networkListSortContainer\").show();\n    $(\"#networkListIdContainer\").hide();\n    self.init_network_list();\n    // Make sure we don't duplicate the networks in the list\n    $(\"#available_network\").empty();\n    $.each(self.networks_available, function(index, value){\n      $(\"#available_network\").append(self.generate_network_element(value.name, value.id, value.value));\n    });\n    // Make sure we don't duplicate the networks in the list\n    $(\"#selected_network\").empty();\n    $.each(self.networks_selected, function(index, value){\n      $(\"#selected_network\").append(self.generate_network_element(value.name, value.id, value.value));\n    });\n    // $(\".networklist > li\").click(function(){\n    //   $(this).toggleClass(\"ui-selected\");\n    // });\n    $(\".networklist > li > a.btn\").click(function(e){\n      var $this = $(this);\n      e.preventDefault();\n      e.stopPropagation();\n      if($this.parents(\"ul#available_network\").length > 0) {\n        $this.parent().appendTo($(\"#selected_network\"));\n      } else if ($this.parents(\"ul#selected_network\").length > 0) {\n        $this.parent().appendTo($(\"#available_network\"));\n      }\n      updateForm();\n    });\n    if ($(\"#networkListId > div.control-group.error\").length > 0) {\n      var errortext = $(\"#networkListId > div.control-group.error\").find(\"span.help-inline\").text();\n      $(\"#selected_network_label\").before($('<div class=\"dynamic-error\">').html(errortext));\n    }\n    $(\".networklist\").sortable({\n      connectWith: \"ul.networklist\",\n      placeholder: \"ui-state-highlight\",\n      distance: 5,\n      start:function(e,info){\n        $(\"#selected_network\").addClass(\"dragging\");\n      },\n      stop:function(e,info){\n        $(\"#selected_network\").removeClass(\"dragging\");\n        updateForm();\n      }\n    }).disableSelection();\n  },\n\n  workflow_init: function(modal) {\n    // Initialise the drag and drop network list\n    horizon.instances.generate_networklist_html();\n  }\n};\n\nhorizon.addInitFunction(function () {\n  $(document).on('submit', '#tail_length', function (evt) {\n    horizon.instances.user_decided_length = true;\n    horizon.instances.getConsoleLog(true);\n    evt.preventDefault();\n  });\n\n  /* Launch instance workflow */\n\n  // Handle field toggles for the Launch Instance source type field\n  function update_launch_source_displayed_fields (field) {\n    var $this = $(field),\n      base_type = $this.val();\n\n    $this.closest(\".control-group\").nextAll().hide();\n\n    switch(base_type) {\n      case \"image_id\":\n        $(\"#id_image_id\").closest(\".control-group\").show();\n        break;\n\n      case \"instance_snapshot_id\":\n        $(\"#id_instance_snapshot_id\").closest(\".control-group\").show();\n        break;\n\n      case \"volume_id\":\n        $(\"#id_volume_id\").closest(\".control-group\").show();\n        break;\n\n      case \"volume_image_id\":\n        $(\"#id_image_id, #id_volume_size, #id_device_name, , #id_delete_on_terminate\")\n          .closest(\".control-group\").show();\n        break;\n\n      case \"volume_snapshot_id\":\n        $(\"#id_volume_snapshot_id, #id_device_name, #id_delete_on_terminate\")\n          .closest(\".control-group\").show();\n        break;\n    }\n  }\n\n  $(document).on('change', '.workflow #id_source_type', function (evt) {\n    update_launch_source_displayed_fields(this);\n  });\n\n  $('.workflow #id_source_type').change();\n  horizon.modals.addModalInitFunction(function (modal) {\n    $(modal).find(\"#id_source_type\").change();\n  });\n\n\n  // Handle field toggles for the Launch Instance volume type field\n  function update_image_id_fields (field) {\n    var $this = $(field),\n      volume_opt = $this.val();\n    var $option = $this.find(\"option:selected\");\n    var $form = $this.closest('form');\n    var $volSize = $form.find('input#id_volume_size');\n    $volSize.val($option.data(\"volume_size\"));\n  }\n\n  $(document).on('change', '.workflow #id_image_id', function (evt) {\n    update_image_id_fields(this);\n  });\n\n  horizon.instances.decrypt_password = function(encrypted_password, private_key) {\n    var crypt = new JSEncrypt();\n    crypt.setKey(private_key);\n    return crypt.decrypt(encrypted_password);\n  };\n\n  $(document).on('change', '#id_private_key_file', function (evt) {\n    var file = evt.target.files[0];\n    var reader = new FileReader();\n    if (file) {\n      reader.onloadend = function(event) {\n        $(\"#id_private_key\").val(event.target.result);\n      };\n      reader.onerror = function(event) {\n        horizon.clearErrorMessages();\n        horizon.alert('error', gettext('Could not read the file'));\n      };\n      reader.readAsText(file);\n    }\n    else {\n      horizon.clearErrorMessages();\n      horizon.alert('error', gettext('Could not decrypt the password'));\n    }\n  });\n  /*\n    The font-family is changed because with the default policy the major I\n    and minor the l cannot be distinguished.\n  */\n  $(document).on('show', '#password_instance_modal', function (evt) {\n    $(\"#id_decrypted_password\").css(\"font-family\",\"monospace\");\n    $(\"#id_decrypted_password\").css(\"cursor\",\"text\");\n    $(\"#id_encrypted_password\").css(\"cursor\",\"text\");\n    $(\"#id_keypair_name\").css(\"cursor\",\"text\");\n  });\n\n  $(document).on('click', '#decryptpassword_button', function (evt) {\n    encrypted_password = $(\"#id_encrypted_password\").val();\n    private_key = $('#id_private_key').val();\n    if (!private_key) {\n      evt.preventDefault();\n      $(this).closest('.modal').modal('hide');\n    }\n    else {\n      if (private_key.length > 0) {\n        evt.preventDefault();\n        decrypted_password = horizon.instances.decrypt_password(encrypted_password, private_key);\n        if (decrypted_password === false || decrypted_password === null) {\n          horizon.clearErrorMessages();\n          horizon.alert('error', gettext('Could not decrypt the password'));\n        }\n        else {\n          $(\"#id_decrypted_password\").val(decrypted_password);\n          $(\"#decryptpassword_button\").hide();\n        }\n      }\n    }\n  });\n});\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport collections\nimport copy\nimport json\nimport logging\nfrom operator import attrgetter\nimport sys\n\nfrom django.core import exceptions as core_exceptions\nfrom django.core import urlresolvers\nfrom django import forms\nfrom django.http import HttpResponse  # noqa\nfrom django import template\nfrom django.template.defaultfilters import truncatechars  # noqa\nfrom django.template.loader import render_to_string\nfrom django.utils.datastructures import SortedDict\nfrom django.utils.html import escape\nfrom django.utils import http\nfrom django.utils.http import urlencode\nfrom django.utils.safestring import mark_safe\nfrom django.utils import termcolors\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import conf\nfrom horizon import exceptions\nfrom horizon import messages\nfrom horizon.tables.actions import FilterAction  # noqa\nfrom horizon.tables.actions import LinkAction  # noqa\nfrom horizon.utils import html\n\n\nLOG = logging.getLogger(__name__)\nPALETTE = termcolors.PALETTES[termcolors.DEFAULT_PALETTE]\nSTRING_SEPARATOR = \"__\"\n\n\nclass Column(html.HTMLElement):\n    \"\"\"A class which represents a single column in a :class:`.DataTable`.\n\n    .. attribute:: transform\n\n        A string or callable. If ``transform`` is a string, it should be the\n        name of the attribute on the underlying data class which\n        should be displayed in this column. If it is a callable, it\n        will be passed the current row's data at render-time and should\n        return the contents of the cell. Required.\n\n    .. attribute:: verbose_name\n\n        The name for this column which should be used for display purposes.\n        Defaults to the value of ``transform`` with the first letter\n        of each word capitalized if the ``transform`` is not callable,\n        otherwise it defaults to an empty string (``\"\"``).\n\n    .. attribute:: sortable\n\n        Boolean to determine whether this column should be sortable or not.\n        Defaults to ``True``.\n\n    .. attribute:: hidden\n\n        Boolean to determine whether or not this column should be displayed\n        when rendering the table. Default: ``False``.\n\n    .. attribute:: link\n\n        A string or callable which returns a URL which will be wrapped around\n        this column's text as a link.\n\n    .. attribute:: allowed_data_types\n\n        A list of data types for which the link should be created.\n        Default is an empty list (``[]``).\n\n        When the list is empty and the ``link`` attribute is not None, all the\n        rows under this column will be links.\n\n    .. attribute::  status\n\n        Boolean designating whether or not this column represents a status\n        (i.e. \"enabled/disabled\", \"up/down\", \"active/inactive\").\n        Default: ``False``.\n\n    .. attribute::  status_choices\n\n        A tuple of tuples representing the possible data values for the\n        status column and their associated boolean equivalent. Positive\n        states should equate to ``True``, negative states should equate\n        to ``False``, and indeterminate states should be ``None``.\n\n        Values are compared in a case-insensitive manner.\n\n        Example (these are also the default values)::\n\n            status_choices = (\n                    ('enabled', True),\n                    ('true', True)\n                    ('up', True),\n                    ('active', True),\n                    ('yes', True),\n                    ('on', True),\n                    ('none', None),\n                    ('unknown', None),\n                    ('', None),\n                    ('disabled', False),\n                    ('down', False),\n                    ('false', False),\n                    ('inactive', False),\n                    ('no', False),\n                    ('off', False),\n                )\n\n    .. attribute::  display_choices\n\n        A tuple of tuples representing the possible values to substitute\n        the data when displayed in the column cell.\n\n    .. attribute:: empty_value\n\n        A string or callable to be used for cells which have no data.\n        Defaults to the string ``\"-\"``.\n\n    .. attribute:: summation\n\n        A string containing the name of a summation method to be used in\n        the generation of a summary row for this column. By default the\n        options are ``\"sum\"`` or ``\"average\"``, which behave as expected.\n        Optional.\n\n    .. attribute:: filters\n\n        A list of functions (often template filters) to be applied to the\n        value of the data for this column prior to output. This is effectively\n        a shortcut for writing a custom ``transform`` function in simple cases.\n\n    .. attribute:: classes\n\n        An iterable of CSS classes which should be added to this column.\n        Example: ``classes=('foo', 'bar')``.\n\n    .. attribute:: attrs\n\n        A dict of HTML attribute strings which should be added to this column.\n        Example: ``attrs={\"data-foo\": \"bar\"}``.\n\n    .. attribute:: truncate\n\n        An integer for the maximum length of the string in this column. If the\n        data in this column is larger than the supplied number, the data for\n        this column will be truncated and an ellipsis will be appended to the\n        truncated data.\n        Defaults to ``None``.\n\n    .. attribute:: link_classes\n\n        An iterable of CSS classes which will be added when the column's text\n        is displayed as a link.\n        Example: ``classes=('link-foo', 'link-bar')``.\n        Defaults to ``None``.\n\n    .. attribute:: wrap_list\n\n        Boolean value indicating whether the contents of this cell should be\n        wrapped in a ``<ul></ul>`` tag. Useful in conjunction with Django's\n        ``unordered_list`` template filter. Defaults to ``False``.\n\n    .. attribute:: form_field\n\n        A form field used for inline editing of the column. A django\n        forms.Field can be used or django form.Widget can be used.\n\n        Example: ``form_field=forms.CharField(required=True)``.\n        Defaults to ``None``.\n\n    .. attribute:: form_field_attributes\n\n        The additional html attributes that will be rendered to form_field.\n        Example: ``form_field_attributes={'class': 'bold_input_field'}``.\n        Defaults to ``None``.\n\n    .. attribute:: update_action\n\n        The class that inherits from tables.actions.UpdateAction, update_cell\n        method takes care of saving inline edited data. The tables.base.Row\n        get_data method needs to be connected to table for obtaining the data.\n        Example: ``update_action=UpdateCell``.\n        Defaults to ``None``.\n    \"\"\"\n    summation_methods = {\n        \"sum\": sum,\n        \"average\": lambda data: sum(data, 0.0) / len(data)\n    }\n    # Used to retain order when instantiating columns on a table\n    creation_counter = 0\n\n    transform = None\n    name = None\n    verbose_name = None\n    status_choices = (\n        ('enabled', True),\n        ('true', True),\n        ('up', True),\n        ('yes', True),\n        ('active', True),\n        ('on', True),\n        ('none', None),\n        ('unknown', None),\n        ('', None),\n        ('disabled', False),\n        ('down', False),\n        ('false', False),\n        ('inactive', False),\n        ('no', False),\n        ('off', False),\n    )\n\n    def __init__(self, transform, verbose_name=None, sortable=True,\n                 link=None, allowed_data_types=[], hidden=False, attrs=None,\n                 status=False, status_choices=None, display_choices=None,\n                 empty_value=None, filters=None, classes=None, summation=None,\n                 auto=None, truncate=None, link_classes=None, wrap_list=False,\n                 form_field=None, form_field_attributes=None,\n                 update_action=None):\n\n        self.classes = list(classes or getattr(self, \"classes\", []))\n        super(Column, self).__init__()\n        self.attrs.update(attrs or {})\n\n        if callable(transform):\n            self.transform = transform\n            self.name = \"<%s callable>\" % transform.__name__\n        else:\n            self.transform = unicode(transform)\n            self.name = self.transform\n\n        # Empty string is a valid value for verbose_name\n        if verbose_name is None:\n            if callable(transform):\n                self.verbose_name = ''\n            else:\n                self.verbose_name = self.transform.title()\n        else:\n            self.verbose_name = verbose_name\n\n        self.auto = auto\n        self.sortable = sortable\n        self.link = link\n        self.allowed_data_types = allowed_data_types\n        self.hidden = hidden\n        self.status = status\n        self.empty_value = empty_value or '-'\n        self.filters = filters or []\n        self.truncate = truncate\n        self.link_classes = link_classes or []\n        self.wrap_list = wrap_list\n        self.form_field = form_field\n        self.form_field_attributes = form_field_attributes or {}\n        self.update_action = update_action\n\n        if status_choices:\n            self.status_choices = status_choices\n        self.display_choices = display_choices\n\n        if summation is not None and summation not in self.summation_methods:\n            raise ValueError(\"Summation method %s must be one of %s.\"\n                             % (summation,\n                                \", \".join(self.summation_methods.keys())))\n        self.summation = summation\n\n        self.creation_counter = Column.creation_counter\n        Column.creation_counter += 1\n\n        if self.sortable and not self.auto:\n            self.classes.append(\"sortable\")\n        if self.hidden:\n            self.classes.append(\"hide\")\n        if self.link is not None:\n            self.classes.append('anchor')\n\n    def __unicode__(self):\n        return unicode(self.verbose_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.name)\n\n    def get_raw_data(self, datum):\n        \"\"\"Returns the raw data for this column, before any filters or\n        formatting are applied to it. This is useful when doing calculations\n        on data in the table.\n        \"\"\"\n        # Callable transformations\n        if callable(self.transform):\n            data = self.transform(datum)\n        # Dict lookups\n        elif isinstance(datum, collections.Mapping) and \\\n                self.transform in datum:\n            data = datum.get(self.transform)\n        else:\n        # Basic object lookups\n            try:\n                data = getattr(datum, self.transform)\n            except AttributeError:\n                msg = _(\"The attribute %(attr)s doesn't exist on \"\n                        \"%(obj)s.\") % {'attr': self.transform, 'obj': datum}\n                msg = termcolors.colorize(msg, **PALETTE['ERROR'])\n                LOG.warning(msg)\n                data = None\n        return data\n\n    def get_data(self, datum):\n        \"\"\"Returns the final display data for this column from the given\n        inputs.\n\n        The return value will be either the attribute specified for this column\n        or the return value of the attr:`~horizon.tables.Column.transform`\n        method for this column.\n        \"\"\"\n        datum_id = self.table.get_object_id(datum)\n\n        if datum_id in self.table._data_cache[self]:\n            return self.table._data_cache[self][datum_id]\n\n        data = self.get_raw_data(datum)\n        display_value = None\n\n        if self.display_choices:\n            display_value = [display for (value, display) in\n                             self.display_choices\n                             if value.lower() == (data or '').lower()]\n\n        if display_value:\n            data = display_value[0]\n        else:\n            for filter_func in self.filters:\n                try:\n                    data = filter_func(data)\n                except Exception:\n                    msg = (\"Filter '%(filter)s' failed with data \"\n                           \"'%(data)s' on column '%(col_name)s'\")\n                    LOG.warning(msg, {'filter': filter_func.func_name,\n                                      'data': data,\n                                      'col_name': unicode(self.verbose_name)})\n\n        if data and self.truncate:\n            data = truncatechars(data, self.truncate)\n\n        self.table._data_cache[self][datum_id] = data\n\n        return self.table._data_cache[self][datum_id]\n\n    def get_link_url(self, datum):\n        \"\"\"Returns the final value for the column's ``link`` property.\n\n        If ``allowed_data_types`` of this column  is not empty and the datum\n        has an assigned type, check if the datum's type is in the\n        ``allowed_data_types`` list. If not, the datum won't be displayed\n        as a link.\n\n        If ``link`` is a callable, it will be passed the current data object\n        and should return a URL. Otherwise ``get_link_url`` will attempt to\n        call ``reverse`` on ``link`` with the object's id as a parameter.\n        Failing that, it will simply return the value of ``link``.\n        \"\"\"\n        if self.allowed_data_types:\n            data_type_name = self.table._meta.data_type_name\n            data_type = getattr(datum, data_type_name, None)\n            if data_type and (data_type not in self.allowed_data_types):\n                return None\n        obj_id = self.table.get_object_id(datum)\n        if callable(self.link):\n            return self.link(datum)\n        try:\n            return urlresolvers.reverse(self.link, args=(obj_id,))\n        except urlresolvers.NoReverseMatch:\n            return self.link\n\n    def get_summation(self):\n        \"\"\"Returns the summary value for the data in this column if a\n        valid summation method is specified for it. Otherwise returns ``None``.\n        \"\"\"\n        if self.summation not in self.summation_methods:\n            return None\n\n        summation_function = self.summation_methods[self.summation]\n        data = [self.get_raw_data(datum) for datum in self.table.data]\n        data = filter(lambda datum: datum is not None, data)\n\n        if len(data):\n            summation = summation_function(data)\n            for filter_func in self.filters:\n                summation = filter_func(summation)\n            return summation\n        else:\n            return None\n\n\nclass Row(html.HTMLElement):\n    \"\"\"Represents a row in the table.\n\n    When iterated, the ``Row`` instance will yield each of its cells.\n\n    Rows are capable of AJAX updating, with a little added work:\n\n    The ``ajax`` property needs to be set to ``True``, and\n    subclasses need to define a ``get_data`` method which returns a data\n    object appropriate for consumption by the table (effectively the \"get\"\n    lookup versus the table's \"list\" lookup).\n\n    The automatic update interval is configurable by setting the key\n    ``ajax_poll_interval`` in the ``HORIZON_CONFIG`` dictionary.\n    Default: ``2500`` (measured in milliseconds).\n\n    .. attribute:: table\n\n        The table which this row belongs to.\n\n    .. attribute:: datum\n\n        The data object which this row represents.\n\n    .. attribute:: id\n\n        A string uniquely representing this row composed of the table name\n        and the row data object's identifier.\n\n    .. attribute:: cells\n\n        The cells belonging to this row stored in a ``SortedDict`` object.\n        This attribute is populated during instantiation.\n\n    .. attribute:: status\n\n        Boolean value representing the status of this row calculated from\n        the values of the table's ``status_columns`` if they are set.\n\n    .. attribute:: status_class\n\n        Returns a css class for the status of the row based on ``status``.\n\n    .. attribute:: ajax\n\n        Boolean value to determine whether ajax updating for this row is\n        enabled.\n\n    .. attribute:: ajax_action_name\n\n        String that is used for the query parameter key to request AJAX\n        updates. Generally you won't need to change this value.\n        Default: ``\"row_update\"``.\n\n    .. attribute:: ajax_cell_action_name\n\n        String that is used for the query parameter key to request AJAX\n        updates of cell. Generally you won't need to change this value.\n        It is also used for inline edit of the cell.\n        Default: ``\"cell_update\"``.\n    \"\"\"\n    ajax = False\n    ajax_action_name = \"row_update\"\n    ajax_cell_action_name = \"cell_update\"\n\n    def __init__(self, table, datum=None):\n        super(Row, self).__init__()\n        self.table = table\n        self.datum = datum\n        self.selected = False\n        if self.datum:\n            self.load_cells()\n        else:\n            self.id = None\n            self.cells = []\n\n    def load_cells(self, datum=None):\n        \"\"\"Load the row's data (either provided at initialization or as an\n        argument to this function), initiailize all the cells contained\n        by this row, and set the appropriate row properties which require\n        the row's data to be determined.\n\n        This function is called automatically by\n        :meth:`~horizon.tables.Row.__init__` if the ``datum`` argument is\n        provided. However, by not providing the data during initialization\n        this function allows for the possibility of a two-step loading\n        pattern when you need a row instance but don't yet have the data\n        available.\n        \"\"\"\n        # Compile all the cells on instantiation.\n        table = self.table\n        if datum:\n            self.datum = datum\n        else:\n            datum = self.datum\n        cells = []\n        for column in table.columns.values():\n            cell = table._meta.cell_class(datum, column, self)\n            cells.append((column.name or column.auto, cell))\n        self.cells = SortedDict(cells)\n\n        if self.ajax:\n            interval = conf.HORIZON_CONFIG['ajax_poll_interval']\n            self.attrs['data-update-interval'] = interval\n            self.attrs['data-update-url'] = self.get_ajax_update_url()\n            self.classes.append(\"ajax-update\")\n\n        self.attrs['data-object-id'] = table.get_object_id(datum)\n\n        # Add the row's status class and id to the attributes to be rendered.\n        self.classes.append(self.status_class)\n        id_vals = {\"table\": self.table.name,\n                   \"sep\": STRING_SEPARATOR,\n                   \"id\": table.get_object_id(datum)}\n        self.id = \"%(table)s%(sep)srow%(sep)s%(id)s\" % id_vals\n        self.attrs['id'] = self.id\n\n        # Add the row's display name if available\n        display_name = table.get_object_display(datum)\n        if display_name:\n            self.attrs['data-display'] = escape(display_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.id)\n\n    def __iter__(self):\n        return iter(self.cells.values())\n\n    @property\n    def status(self):\n        column_names = self.table._meta.status_columns\n        if column_names:\n            statuses = dict([(column_name, self.cells[column_name].status) for\n                             column_name in column_names])\n            return self.table.calculate_row_status(statuses)\n\n    @property\n    def status_class(self):\n        column_names = self.table._meta.status_columns\n        if column_names:\n            return self.table.get_row_status_class(self.status)\n        else:\n            return ''\n\n    def render(self):\n        return render_to_string(\"horizon/common/_data_table_row.html\",\n                                {\"row\": self})\n\n    def get_cells(self):\n        \"\"\"Returns the bound cells for this row in order.\"\"\"\n        return self.cells.values()\n\n    def get_ajax_update_url(self):\n        table_url = self.table.get_absolute_url()\n        params = urlencode({\"table\": self.table.name,\n                            \"action\": self.ajax_action_name,\n                            \"obj_id\": self.table.get_object_id(self.datum)})\n        return \"%s?%s\" % (table_url, params)\n\n    def can_be_selected(self, datum):\n        \"\"\"By default if multiselect enabled return True. You can remove the\n        checkbox after an ajax update here if required.\n        \"\"\"\n        return True\n\n    def get_data(self, request, obj_id):\n        \"\"\"Fetches the updated data for the row based on the object id\n        passed in. Must be implemented by a subclass to allow AJAX updating.\n        \"\"\"\n        raise NotImplementedError(\"You must define a get_data method on %s\"\n                                  % self.__class__.__name__)\n\n\nclass Cell(html.HTMLElement):\n    \"\"\"Represents a single cell in the table.\"\"\"\n\n    def __init__(self, datum, column, row, attrs=None, classes=None):\n        self.classes = classes or getattr(self, \"classes\", [])\n        super(Cell, self).__init__()\n        self.attrs.update(attrs or {})\n\n        self.datum = datum\n        self.column = column\n        self.row = row\n        self.wrap_list = column.wrap_list\n        self.inline_edit_available = self.column.update_action is not None\n        # initialize the update action if available\n        if self.inline_edit_available:\n            self.update_action = self.column.update_action()\n            self.attrs['data-cell-name'] = column.name\n            self.attrs['data-update-url'] = self.get_ajax_update_url()\n        self.inline_edit_mod = False\n        self.data = self.get_data(datum, column, row)\n\n    def get_data(self, datum, column, row):\n        \"\"\"Fetches the data to be displayed in this cell.\"\"\"\n        table = row.table\n        if column.auto == \"multi_select\":\n            data = \"\"\n            if row.can_be_selected(datum):\n                widget = forms.CheckboxInput(check_test=lambda value: False)\n                # Convert value to string to avoid accidental type conversion\n                data = widget.render('object_ids',\n                                     unicode(table.get_object_id(datum)),\n                                     {'class': 'table-row-multi-select'})\n            table._data_cache[column][table.get_object_id(datum)] = data\n        elif column.auto == \"form_field\":\n            widget = column.form_field\n            if issubclass(widget.__class__, forms.Field):\n                widget = widget.widget\n\n            widget_name = \"%s__%s\" % \\\n                (column.name,\n                 unicode(table.get_object_id(datum)))\n\n            # Create local copy of attributes, so it don't change column\n            # class form_field_attributes\n            form_field_attributes = {}\n            form_field_attributes.update(column.form_field_attributes)\n            # Adding id of the input so it pairs with label correctly\n            form_field_attributes['id'] = widget_name\n\n            data = widget.render(widget_name,\n                                 column.get_data(datum),\n                                 form_field_attributes)\n            table._data_cache[column][table.get_object_id(datum)] = data\n        elif column.auto == \"actions\":\n            data = table.render_row_actions(datum)\n            table._data_cache[column][table.get_object_id(datum)] = data\n        else:\n            data = column.get_data(datum)\n        return data\n\n    def __repr__(self):\n        return '<%s: %s, %s>' % (self.__class__.__name__,\n                                 self.column.name,\n                                 self.row.id)\n\n    @property\n    def id(self):\n        return (\"%s__%s\" % (self.column.name,\n                unicode(self.row.table.get_object_id(self.datum))))\n\n    @property\n    def value(self):\n        \"\"\"Returns a formatted version of the data for final output.\n\n        This takes into consideration the\n        :attr:`~horizon.tables.Column.link`` and\n        :attr:`~horizon.tables.Column.empty_value`\n        attributes.\n        \"\"\"\n        try:\n            data = self.column.get_data(self.datum)\n            if data is None:\n                if callable(self.column.empty_value):\n                    data = self.column.empty_value(self.datum)\n                else:\n                    data = self.column.empty_value\n        except Exception:\n            data = None\n            exc_info = sys.exc_info()\n            raise template.TemplateSyntaxError, exc_info[1], exc_info[2]\n        if self.url:\n            link_classes = ' '.join(self.column.link_classes)\n            # Escape the data inside while allowing our HTML to render\n            data = mark_safe('<a href=\"%s\" class=\"%s\">%s</a>' %\n                             (escape(self.url),\n                              escape(link_classes),\n                              escape(unicode(data))))\n        return data\n\n    @property\n    def url(self):\n        if self.column.link:\n            url = self.column.get_link_url(self.datum)\n            if url:\n                return url\n        else:\n            return None\n\n    @property\n    def status(self):\n        \"\"\"Gets the status for the column based on the cell's data.\"\"\"\n        # Deal with status column mechanics based in this cell's data\n        if hasattr(self, '_status'):\n            return self._status\n\n        if self.column.status or \\\n                self.column.name in self.column.table._meta.status_columns:\n            #returns the first matching status found\n            data_value_lower = unicode(self.data).lower()\n            for status_name, status_value in self.column.status_choices:\n                if unicode(status_name).lower() == data_value_lower:\n                    self._status = status_value\n                    return self._status\n        self._status = None\n        return self._status\n\n    def get_status_class(self, status):\n        \"\"\"Returns a css class name determined by the status value.\"\"\"\n        if status is True:\n            return \"status_up\"\n        elif status is False:\n            return \"status_down\"\n        else:\n            return \"status_unknown\"\n\n    def get_default_classes(self):\n        \"\"\"Returns a flattened string of the cell's CSS classes.\"\"\"\n        if not self.url:\n            self.column.classes = [cls for cls in self.column.classes\n                                    if cls != \"anchor\"]\n        column_class_string = self.column.get_final_attrs().get('class', \"\")\n        classes = set(column_class_string.split(\" \"))\n        if self.column.status:\n            classes.add(self.get_status_class(self.status))\n\n        if self.inline_edit_available:\n            classes.add(\"inline_edit_available\")\n\n        return list(classes)\n\n    def get_ajax_update_url(self):\n        column = self.column\n        table_url = column.table.get_absolute_url()\n        params = urlencode({\"table\": column.table.name,\n                            \"action\": self.row.ajax_cell_action_name,\n                            \"obj_id\": column.table.get_object_id(self.datum),\n                            \"cell_name\": column.name})\n        return \"%s?%s\" % (table_url, params)\n\n    @property\n    def update_allowed(self):\n        \"\"\"Determines whether update of given cell is allowed.\n\n        Calls allowed action of defined UpdateAction of the Column.\n        \"\"\"\n        return self.update_action.allowed(self.column.table.request,\n                                          self.datum,\n                                          self)\n\n    def render(self):\n        return render_to_string(\"horizon/common/_data_table_cell.html\",\n                                {\"cell\": self})\n\n\nclass DataTableOptions(object):\n    \"\"\"Contains options for :class:`.DataTable` objects.\n\n    .. attribute:: name\n\n        A short name or slug for the table.\n\n    .. attribute:: verbose_name\n\n        A more verbose name for the table meant for display purposes.\n\n    .. attribute:: columns\n\n        A list of column objects or column names. Controls ordering/display\n        of the columns in the table.\n\n    .. attribute:: table_actions\n\n        A list of action classes derived from the\n        :class:`~horizon.tables.Action` class. These actions will handle tasks\n        such as bulk deletion, etc. for multiple objects at once.\n\n    .. attribute:: row_actions\n\n        A list similar to ``table_actions`` except tailored to appear for\n        each row. These actions act on a single object at a time.\n\n    .. attribute:: actions_column\n\n        Boolean value to control rendering of an additional column containing\n        the various actions for each row. Defaults to ``True`` if any actions\n        are specified in the ``row_actions`` option.\n\n    .. attribute:: multi_select\n\n        Boolean value to control rendering of an extra column with checkboxes\n        for selecting multiple objects in the table. Defaults to ``True`` if\n        any actions are specified in the ``table_actions`` option.\n\n    .. attribute:: filter\n\n        Boolean value to control the display of the \"filter\" search box\n        in the table actions. By default it checks whether or not an instance\n        of :class:`.FilterAction` is in :attr:`.table_actions`.\n\n    .. attribute:: template\n\n        String containing the template which should be used to render the\n        table. Defaults to ``\"horizon/common/_data_table.html\"``.\n\n    .. attribute:: context_var_name\n\n        The name of the context variable which will contain the table when\n        it is rendered. Defaults to ``\"table\"``.\n\n    .. attribute:: pagination_param\n\n        The name of the query string parameter which will be used when\n        paginating this table. When using multiple tables in a single\n        view this will need to be changed to differentiate between the\n        tables. Default: ``\"marker\"``.\n\n    .. attribute:: status_columns\n\n        A list or tuple of column names which represents the \"state\"\n        of the data object being represented.\n\n        If ``status_columns`` is set, when the rows are rendered the value\n        of this column will be used to add an extra class to the row in\n        the form of ``\"status_up\"`` or ``\"status_down\"`` for that row's\n        data.\n\n        The row status is used by other Horizon components to trigger tasks\n        such as dynamic AJAX updating.\n\n    .. attribute:: cell_class\n\n        The class which should be used for rendering the cells of this table.\n        Optional. Default: :class:`~horizon.tables.Cell`.\n\n    .. attribute:: row_class\n\n        The class which should be used for rendering the rows of this table.\n        Optional. Default: :class:`~horizon.tables.Row`.\n\n    .. attribute:: column_class\n\n        The class which should be used for handling the columns of this table.\n        Optional. Default: :class:`~horizon.tables.Column`.\n\n    .. attribute:: mixed_data_type\n\n        A toggle to indicate if the table accepts two or more types of data.\n        Optional. Default: :``False``\n\n    .. attribute:: data_types\n\n        A list of data types that this table would accept. Default to be an\n        empty list, but if the attribute ``mixed_data_type`` is set to\n        ``True``, then this list must have at least one element.\n\n    .. attribute:: data_type_name\n\n        The name of an attribute to assign to data passed to the table when it\n        accepts mix data. Default: ``\"_table_data_type\"``\n\n    .. attribute:: footer\n\n        Boolean to control whether or not to show the table's footer.\n        Default: ``True``.\n\n    .. attribute:: permissions\n\n        A list of permission names which this table requires in order to be\n        displayed. Defaults to an empty list (``[]``).\n    \"\"\"\n    def __init__(self, options):\n        self.name = getattr(options, 'name', self.__class__.__name__)\n        verbose_name = getattr(options, 'verbose_name', None) \\\n                                    or self.name.title()\n        self.verbose_name = verbose_name\n        self.columns = getattr(options, 'columns', None)\n        self.status_columns = getattr(options, 'status_columns', [])\n        self.table_actions = getattr(options, 'table_actions', [])\n        self.row_actions = getattr(options, 'row_actions', [])\n        self.cell_class = getattr(options, 'cell_class', Cell)\n        self.row_class = getattr(options, 'row_class', Row)\n        self.column_class = getattr(options, 'column_class', Column)\n        self.pagination_param = getattr(options, 'pagination_param', 'marker')\n        self.browser_table = getattr(options, 'browser_table', None)\n        self.footer = getattr(options, 'footer', True)\n        self.no_data_message = getattr(options,\n                                       \"no_data_message\",\n                                       _(\"No items to display.\"))\n        self.permissions = getattr(options, 'permissions', [])\n\n        # Set self.filter if we have any FilterActions\n        filter_actions = [action for action in self.table_actions if\n                          issubclass(action, FilterAction)]\n        if len(filter_actions) > 1:\n            raise NotImplementedError(\"Multiple filter actions is not \"\n                                      \"currently supported.\")\n        self.filter = getattr(options, 'filter', len(filter_actions) > 0)\n        if len(filter_actions) == 1:\n            self._filter_action = filter_actions.pop()\n        else:\n            self._filter_action = None\n\n        self.template = getattr(options,\n                                'template',\n                                'horizon/common/_data_table.html')\n        self.row_actions_template = \\\n                        'horizon/common/_data_table_row_actions.html'\n        self.table_actions_template = \\\n                        'horizon/common/_data_table_table_actions.html'\n        self.context_var_name = unicode(getattr(options,\n                                                'context_var_name',\n                                                'table'))\n        self.actions_column = getattr(options,\n                                     'actions_column',\n                                     len(self.row_actions) > 0)\n        self.multi_select = getattr(options,\n                                    'multi_select',\n                                    len(self.table_actions) > 0)\n\n        # Set runtime table defaults; not configurable.\n        self.has_more_data = False\n\n        # Set mixed data type table attr\n        self.mixed_data_type = getattr(options, 'mixed_data_type', False)\n        self.data_types = getattr(options, 'data_types', [])\n\n        # If the data_types has more than 2 elements, set mixed_data_type\n        # to True automatically.\n        if len(self.data_types) > 1:\n            self.mixed_data_type = True\n\n        # However, if the mixed_data_type is set to True manually and the\n        # the data_types is empty, raise an error.\n        if self.mixed_data_type and len(self.data_types) <= 1:\n            raise ValueError(\"If mixed_data_type is set to True in class %s, \"\n                             \"data_types should has more than one types\" %\n                             self.name)\n\n        self.data_type_name = getattr(options,\n                                      'data_type_name',\n                                      \"_table_data_type\")\n\n\nclass DataTableMetaclass(type):\n    \"\"\"Metaclass to add options to DataTable class and collect columns.\"\"\"\n    def __new__(mcs, name, bases, attrs):\n        # Process options from Meta\n        class_name = name\n        attrs[\"_meta\"] = opts = DataTableOptions(attrs.get(\"Meta\", None))\n\n        # Gather columns; this prevents the column from being an attribute\n        # on the DataTable class and avoids naming conflicts.\n        columns = []\n        for attr_name, obj in attrs.items():\n            if issubclass(type(obj), (opts.column_class, Column)):\n                column_instance = attrs.pop(attr_name)\n                column_instance.name = attr_name\n                column_instance.classes.append('normal_column')\n                columns.append((attr_name, column_instance))\n        columns.sort(key=lambda x: x[1].creation_counter)\n\n        # Iterate in reverse to preserve final order\n        for base in bases[::-1]:\n            if hasattr(base, 'base_columns'):\n                columns = base.base_columns.items() + columns\n        attrs['base_columns'] = SortedDict(columns)\n\n        # If the table is in a ResourceBrowser, the column number must meet\n        # these limits because of the width of the browser.\n        if opts.browser_table == \"navigation\" and len(columns) > 3:\n            raise ValueError(\"You can only assign three column to %s.\"\n                             % class_name)\n        if opts.browser_table == \"content\" and len(columns) > 2:\n            raise ValueError(\"You can only assign two columns to %s.\"\n                             % class_name)\n\n        if opts.columns:\n            # Remove any columns that weren't declared if we're being explicit\n            # NOTE: we're iterating a COPY of the list here!\n            for column_data in columns[:]:\n                if column_data[0] not in opts.columns:\n                    columns.pop(columns.index(column_data))\n            # Re-order based on declared columns\n            columns.sort(key=lambda x: attrs['_meta'].columns.index(x[0]))\n        # Add in our auto-generated columns\n        if opts.multi_select and opts.browser_table != \"navigation\":\n            multi_select = opts.column_class(\"multi_select\",\n                                             verbose_name=\"\",\n                                             auto=\"multi_select\")\n            multi_select.classes.append('multi_select_column')\n            columns.insert(0, (\"multi_select\", multi_select))\n        if opts.actions_column:\n            actions_column = opts.column_class(\"actions\",\n                                               verbose_name=_(\"Actions\"),\n                                               auto=\"actions\")\n            actions_column.classes.append('actions_column')\n            columns.append((\"actions\", actions_column))\n        # Store this set of columns internally so we can copy them per-instance\n        attrs['_columns'] = SortedDict(columns)\n\n        # Gather and register actions for later access since we only want\n        # to instantiate them once.\n        # (list() call gives deterministic sort order, which sets don't have.)\n        actions = list(set(opts.row_actions) | set(opts.table_actions))\n        actions.sort(key=attrgetter('name'))\n        actions_dict = SortedDict([(action.name, action())\n                                   for action in actions])\n        attrs['base_actions'] = actions_dict\n        if opts._filter_action:\n            # Replace our filter action with the instantiated version\n            opts._filter_action = actions_dict[opts._filter_action.name]\n\n        # Create our new class!\n        return type.__new__(mcs, name, bases, attrs)\n\n\nclass DataTable(object):\n    \"\"\"A class which defines a table with all data and associated actions.\n\n    .. attribute:: name\n\n        String. Read-only access to the name specified in the\n        table's Meta options.\n\n    .. attribute:: multi_select\n\n        Boolean. Read-only access to whether or not this table\n        should display a column for multi-select checkboxes.\n\n    .. attribute:: data\n\n        Read-only access to the data this table represents.\n\n    .. attribute:: filtered_data\n\n        Read-only access to the data this table represents, filtered by\n        the :meth:`~horizon.tables.FilterAction.filter` method of the table's\n        :class:`~horizon.tables.FilterAction` class (if one is provided)\n        using the current request's query parameters.\n    \"\"\"\n    __metaclass__ = DataTableMetaclass\n\n    def __init__(self, request, data=None, needs_form_wrapper=None, **kwargs):\n        self.request = request\n        self.data = data\n        self.kwargs = kwargs\n        self._needs_form_wrapper = needs_form_wrapper\n        self._no_data_message = self._meta.no_data_message\n        self.breadcrumb = None\n        self.current_item_id = None\n        self.permissions = self._meta.permissions\n\n        # Create a new set\n        columns = []\n        for key, _column in self._columns.items():\n            column = copy.copy(_column)\n            column.table = self\n            columns.append((key, column))\n        self.columns = SortedDict(columns)\n        self._populate_data_cache()\n\n        # Associate these actions with this table\n        for action in self.base_actions.values():\n            action.table = self\n\n        self.needs_summary_row = any([col.summation\n                                      for col in self.columns.values()])\n\n    def __unicode__(self):\n        return unicode(self._meta.verbose_name)\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self._meta.name)\n\n    @property\n    def name(self):\n        return self._meta.name\n\n    @property\n    def footer(self):\n        return self._meta.footer\n\n    @property\n    def multi_select(self):\n        return self._meta.multi_select\n\n    @property\n    def filtered_data(self):\n        # This function should be using django.utils.functional.cached_property\n        # decorator, but unfortunately due to bug in Django\n        # https://code.djangoproject.com/ticket/19872 it would make it fail\n        # when being mocked by mox in tests.\n        if not hasattr(self, '_filtered_data'):\n            self._filtered_data = self.data\n            if self._meta.filter and self._meta._filter_action:\n                action = self._meta._filter_action\n                filter_string = self.get_filter_string()\n                request_method = self.request.method\n                needs_preloading = (not filter_string\n                                    and request_method == 'GET'\n                                    and action.needs_preloading)\n                valid_method = (request_method == action.method)\n                if valid_method or needs_preloading:\n                    if self._meta.mixed_data_type:\n                        self._filtered_data = action.data_type_filter(self,\n                                                                self.data,\n                                                                filter_string)\n                    else:\n                        self._filtered_data = action.filter(self,\n                                                            self.data,\n                                                            filter_string)\n        return self._filtered_data\n\n    def get_filter_string(self):\n        filter_action = self._meta._filter_action\n        param_name = filter_action.get_param_name()\n        filter_string = self.request.POST.get(param_name, '')\n        return filter_string\n\n    def _populate_data_cache(self):\n        self._data_cache = {}\n        # Set up hash tables to store data points for each column\n        for column in self.get_columns():\n            self._data_cache[column] = {}\n\n    def _filter_action(self, action, request, datum=None):\n        try:\n            # Catch user errors in permission functions here\n            row_matched = True\n            if self._meta.mixed_data_type:\n                row_matched = action.data_type_matched(datum)\n            return action._allowed(request, datum) and row_matched\n        except Exception:\n            LOG.exception(\"Error while checking action permissions.\")\n            return None\n\n    def is_browser_table(self):\n        if self._meta.browser_table:\n            return True\n        return False\n\n    def render(self):\n        \"\"\"Renders the table using the template from the table options.\"\"\"\n        table_template = template.loader.get_template(self._meta.template)\n        extra_context = {self._meta.context_var_name: self}\n        context = template.RequestContext(self.request, extra_context)\n        return table_template.render(context)\n\n    def get_absolute_url(self):\n        \"\"\"Returns the canonical URL for this table.\n\n        This is used for the POST action attribute on the form element\n        wrapping the table. In many cases it is also useful for redirecting\n        after a successful action on the table.\n\n        For convenience it defaults to the value of\n        ``request.get_full_path()`` with any query string stripped off,\n        e.g. the path at which the table was requested.\n        \"\"\"\n        return self.request.get_full_path().partition('?')[0]\n\n    def get_full_url(self):\n        \"\"\"Returns the full URL path for this table.\n\n        This is used for the POST action attribute on the form element\n        wrapping the table. We use this method to persist the\n        pagination marker.\n\n        \"\"\"\n        return self.request.get_full_path()\n\n    def get_empty_message(self):\n        \"\"\"Returns the message to be displayed when there is no data.\"\"\"\n        return self._no_data_message\n\n    def get_object_by_id(self, lookup):\n        \"\"\"Returns the data object from the table's dataset which matches\n        the ``lookup`` parameter specified. An error will be raised if\n        the match is not a single data object.\n\n        We will convert the object id and ``lookup`` to unicode before\n        comparison.\n\n        Uses :meth:`~horizon.tables.DataTable.get_object_id` internally.\n        \"\"\"\n        if not isinstance(lookup, unicode):\n            lookup = unicode(str(lookup), 'utf-8')\n        matches = []\n        for datum in self.data:\n            obj_id = self.get_object_id(datum)\n            if not isinstance(obj_id, unicode):\n                obj_id = unicode(str(obj_id), 'utf-8')\n            if obj_id == lookup:\n                matches.append(datum)\n        if len(matches) > 1:\n            raise ValueError(\"Multiple matches were returned for that id: %s.\"\n                           % matches)\n        if not matches:\n            raise exceptions.Http302(self.get_absolute_url(),\n                                     _('No match returned for the id \"%s\".')\n                                       % lookup)\n        return matches[0]\n\n    @property\n    def has_actions(self):\n        \"\"\"Boolean. Indicates whether there are any available actions on this\n        table.\n        \"\"\"\n        if not self.base_actions:\n            return False\n        return any(self.get_table_actions()) or any(self._meta.row_actions)\n\n    @property\n    def needs_form_wrapper(self):\n        \"\"\"Boolean. Indicates whether this table should be rendered wrapped in\n        a ``<form>`` tag or not.\n        \"\"\"\n        # If needs_form_wrapper is explicitly set, defer to that.\n        if self._needs_form_wrapper is not None:\n            return self._needs_form_wrapper\n        # Otherwise calculate whether or not we need a form element.\n        return self.has_actions\n\n    def get_table_actions(self):\n        \"\"\"Returns a list of the action instances for this table.\"\"\"\n        bound_actions = [self.base_actions[action.name] for\n                         action in self._meta.table_actions]\n        return [action for action in bound_actions if\n                self._filter_action(action, self.request)]\n\n    def get_row_actions(self, datum):\n        \"\"\"Returns a list of the action instances for a specific row.\"\"\"\n        bound_actions = []\n        for action in self._meta.row_actions:\n            # Copy to allow modifying properties per row\n            bound_action = copy.copy(self.base_actions[action.name])\n            bound_action.attrs = copy.copy(bound_action.attrs)\n            bound_action.datum = datum\n            # Remove disallowed actions.\n            if not self._filter_action(bound_action,\n                                       self.request,\n                                       datum):\n                continue\n            # Hook for modifying actions based on data. No-op by default.\n            bound_action.update(self.request, datum)\n            # Pre-create the URL for this link with appropriate parameters\n            if issubclass(bound_action.__class__, LinkAction):\n                bound_action.bound_url = bound_action.get_link_url(datum)\n            bound_actions.append(bound_action)\n        return bound_actions\n\n    def render_table_actions(self):\n        \"\"\"Renders the actions specified in ``Meta.table_actions``.\"\"\"\n        template_path = self._meta.table_actions_template\n        table_actions_template = template.loader.get_template(template_path)\n        bound_actions = self.get_table_actions()\n        extra_context = {\"table_actions\": bound_actions}\n        if self._meta.filter and \\\n           self._filter_action(self._meta._filter_action, self.request):\n            extra_context[\"filter\"] = self._meta._filter_action\n        context = template.RequestContext(self.request, extra_context)\n        return table_actions_template.render(context)\n\n    def render_row_actions(self, datum):\n        \"\"\"Renders the actions specified in ``Meta.row_actions`` using the\n        current row data.\n        \"\"\"\n        template_path = self._meta.row_actions_template\n        row_actions_template = template.loader.get_template(template_path)\n        bound_actions = self.get_row_actions(datum)\n        extra_context = {\"row_actions\": bound_actions,\n                         \"row_id\": self.get_object_id(datum)}\n        context = template.RequestContext(self.request, extra_context)\n        return row_actions_template.render(context)\n\n    @staticmethod\n    def parse_action(action_string):\n        \"\"\"Parses the ``action`` parameter (a string) sent back with the\n        POST data. By default this parses a string formatted as\n        ``{{ table_name }}__{{ action_name }}__{{ row_id }}`` and returns\n        each of the pieces. The ``row_id`` is optional.\n        \"\"\"\n        if action_string:\n            bits = action_string.split(STRING_SEPARATOR)\n            bits.reverse()\n            table = bits.pop()\n            action = bits.pop()\n            try:\n                object_id = bits.pop()\n            except IndexError:\n                object_id = None\n            return table, action, object_id\n\n    def take_action(self, action_name, obj_id=None, obj_ids=None):\n        \"\"\"Locates the appropriate action and routes the object\n        data to it. The action should return an HTTP redirect\n        if successful, or a value which evaluates to ``False``\n        if unsuccessful.\n        \"\"\"\n        # See if we have a list of ids\n        obj_ids = obj_ids or self.request.POST.getlist('object_ids')\n        action = self.base_actions.get(action_name, None)\n        if not action or action.method != self.request.method:\n            # We either didn't get an action or we're being hacked. Goodbye.\n            return None\n\n        # Meanwhile, back in Gotham...\n        if not action.requires_input or obj_id or obj_ids:\n            if obj_id:\n                obj_id = self.sanitize_id(obj_id)\n            if obj_ids:\n                obj_ids = [self.sanitize_id(i) for i in obj_ids]\n            # Single handling is easy\n            if not action.handles_multiple:\n                response = action.single(self, self.request, obj_id)\n            # Otherwise figure out what to pass along\n            else:\n                # Preference given to a specific id, since that implies\n                # the user selected an action for just one row.\n                if obj_id:\n                    obj_ids = [obj_id]\n                response = action.multiple(self, self.request, obj_ids)\n            return response\n        elif action and action.requires_input and not (obj_id or obj_ids):\n            messages.info(self.request,\n                          _(\"Please select a row before taking that action.\"))\n        return None\n\n    @classmethod\n    def check_handler(cls, request):\n        \"\"\"Determine whether the request should be handled by this table.\"\"\"\n        if request.method == \"POST\" and \"action\" in request.POST:\n            table, action, obj_id = cls.parse_action(request.POST[\"action\"])\n        elif \"table\" in request.GET and \"action\" in request.GET:\n            table = request.GET[\"table\"]\n            action = request.GET[\"action\"]\n            obj_id = request.GET.get(\"obj_id\", None)\n        else:\n            table = action = obj_id = None\n        return table, action, obj_id\n\n    def maybe_preempt(self):\n        \"\"\"Determine whether the request should be handled by a preemptive\n        action on this table or by an AJAX row update before loading any data.\n        \"\"\"\n        request = self.request\n        table_name, action_name, obj_id = self.check_handler(request)\n\n        if table_name == self.name:\n            # Handle AJAX row updating.\n            new_row = self._meta.row_class(self)\n            if new_row.ajax and new_row.ajax_action_name == action_name:\n                try:\n                    datum = new_row.get_data(request, obj_id)\n                    new_row.load_cells(datum)\n                    error = False\n                except Exception:\n                    datum = None\n                    error = exceptions.handle(request, ignore=True)\n                if request.is_ajax():\n                    if not error:\n                        return HttpResponse(new_row.render())\n                    else:\n                        return HttpResponse(status=error.status_code)\n            elif new_row.ajax_cell_action_name == action_name:\n                # inline edit of the cell actions\n                return self.inline_edit_handle(request, table_name,\n                                               action_name, obj_id,\n                                               new_row)\n\n            preemptive_actions = [action for action in\n                                  self.base_actions.values() if action.preempt]\n            if action_name:\n                for action in preemptive_actions:\n                    if action.name == action_name:\n                        handled = self.take_action(action_name, obj_id)\n                        if handled:\n                            return handled\n        return None\n\n    def inline_edit_handle(self, request, table_name, action_name, obj_id,\n                           new_row):\n        \"\"\"Inline edit handler.\n\n        Showing form or handling update by POST of the cell.\n        \"\"\"\n        try:\n            cell_name = request.GET['cell_name']\n            datum = new_row.get_data(request, obj_id)\n            # TODO(lsmola) extract load cell logic to Cell and load\n            # only 1 cell. This is kind of ugly.\n            if request.GET.get('inline_edit_mod') == \"true\":\n                new_row.table.columns[cell_name].auto = \"form_field\"\n                inline_edit_mod = True\n            else:\n                inline_edit_mod = False\n\n            # Load the cell and set the inline_edit_mod.\n            new_row.load_cells(datum)\n            cell = new_row.cells[cell_name]\n            cell.inline_edit_mod = inline_edit_mod\n\n            # If not allowed, neither edit mod or updating is allowed.\n            if not cell.update_allowed:\n                datum_display = (self.get_object_display(datum) or\n                                 _(\"N/A\"))\n                LOG.info('Permission denied to %s: \"%s\"' %\n                         (\"Update Action\", datum_display))\n                return HttpResponse(status=401)\n            # If it is post request, we are updating the cell.\n            if request.method == \"POST\":\n                return self.inline_update_action(request,\n                                                 datum,\n                                                 cell,\n                                                 obj_id,\n                                                 cell_name)\n\n            error = False\n        except Exception:\n            datum = None\n            error = exceptions.handle(request, ignore=True)\n        if request.is_ajax():\n            if not error:\n                return HttpResponse(cell.render())\n            else:\n                return HttpResponse(status=error.status_code)\n\n    def inline_update_action(self, request, datum, cell, obj_id, cell_name):\n        \"\"\"Handling update by POST of the cell.\n        \"\"\"\n        new_cell_value = request.POST.get(\n            cell_name + '__' + obj_id, None)\n        if issubclass(cell.column.form_field.__class__,\n                      forms.Field):\n            try:\n                # using Django Form Field to parse the\n                # right value from POST and to validate it\n                new_cell_value = (\n                    cell.column.form_field.clean(\n                        new_cell_value))\n                cell.update_action.action(\n                    self.request, datum, obj_id, cell_name, new_cell_value)\n                response = {\n                    'status': 'updated',\n                    'message': ''\n                }\n                return HttpResponse(\n                    json.dumps(response),\n                    status=200,\n                    content_type=\"application/json\")\n\n            except core_exceptions.ValidationError:\n                # if there is a validation error, I will\n                # return the message to the client\n                exc_type, exc_value, exc_traceback = (\n                    sys.exc_info())\n                response = {\n                    'status': 'validation_error',\n                    'message': ' '.join(exc_value.messages)}\n                return HttpResponse(\n                    json.dumps(response),\n                    status=400,\n                    content_type=\"application/json\")\n\n    def maybe_handle(self):\n        \"\"\"Determine whether the request should be handled by any action on\n        this table after data has been loaded.\n        \"\"\"\n        request = self.request\n        table_name, action_name, obj_id = self.check_handler(request)\n        if table_name == self.name and action_name:\n            action_names = [action.name for action in\n                self.base_actions.values() if not action.preempt]\n            # do not run preemptive actions here\n            if action_name in action_names:\n                return self.take_action(action_name, obj_id)\n        return None\n\n    def sanitize_id(self, obj_id):\n        \"\"\"Override to modify an incoming obj_id to match existing\n        API data types or modify the format.\n        \"\"\"\n        return obj_id\n\n    def get_object_id(self, datum):\n        \"\"\"Returns the identifier for the object this row will represent.\n\n        By default this returns an ``id`` attribute on the given object,\n        but this can be overridden to return other values.\n\n        .. warning::\n\n            Make sure that the value returned is a unique value for the id\n            otherwise rendering issues can occur.\n        \"\"\"\n        return datum.id\n\n    def get_object_display(self, datum):\n        \"\"\"Returns a display name that identifies this object.\n\n        By default, this returns a ``name`` attribute from the given object,\n        but this can be overridden to return other values.\n        \"\"\"\n        if hasattr(datum, 'name'):\n            return datum.name\n        return None\n\n    def has_more_data(self):\n        \"\"\"Returns a boolean value indicating whether there is more data\n        available to this table from the source (generally an API).\n\n        The method is largely meant for internal use, but if you want to\n        override it to provide custom behavior you can do so at your own risk.\n        \"\"\"\n        return self._meta.has_more_data\n\n    def get_marker(self):\n        \"\"\"Returns the identifier for the last object in the current data set\n        for APIs that use marker/limit-based paging.\n        \"\"\"\n        return http.urlquote_plus(self.get_object_id(self.data[-1]))\n\n    def get_pagination_string(self):\n        \"\"\"Returns the query parameter string to paginate this table.\"\"\"\n        return \"=\".join([self._meta.pagination_param, self.get_marker()])\n\n    def calculate_row_status(self, statuses):\n        \"\"\"Returns a boolean value determining the overall row status\n        based on the dictionary of column name to status mappings passed in.\n\n        By default, it uses the following logic:\n\n        #. If any statuses are ``False``, return ``False``.\n        #. If no statuses are ``False`` but any or ``None``, return ``None``.\n        #. If all statuses are ``True``, return ``True``.\n\n        This provides the greatest protection against false positives without\n        weighting any particular columns.\n\n        The ``statuses`` parameter is passed in as a dictionary mapping\n        column names to their statuses in order to allow this function to\n        be overridden in such a way as to weight one column's status over\n        another should that behavior be desired.\n        \"\"\"\n        values = statuses.values()\n        if any([status is False for status in values]):\n            return False\n        elif any([status is None for status in values]):\n            return None\n        else:\n            return True\n\n    def get_row_status_class(self, status):\n        \"\"\"Returns a css class name determined by the status value. This class\n        name is used to indicate the status of the rows in the table if\n        any ``status_columns`` have been specified.\n        \"\"\"\n        if status is True:\n            return \"status_up\"\n        elif status is False:\n            return \"status_down\"\n        else:\n            return \"status_unknown\"\n\n    def get_columns(self):\n        \"\"\"Returns this table's columns including auto-generated ones.\"\"\"\n        return self.columns.values()\n\n    def get_rows(self):\n        \"\"\"Return the row data for this table broken out by columns.\"\"\"\n        rows = []\n        try:\n            for datum in self.filtered_data:\n                row = self._meta.row_class(self, datum)\n                if self.get_object_id(datum) == self.current_item_id:\n                    self.selected = True\n                    row.classes.append('current_selected')\n                rows.append(row)\n        except Exception:\n            # Exceptions can be swallowed at the template level here,\n            # re-raising as a TemplateSyntaxError makes them visible.\n            LOG.exception(\"Error while rendering table rows.\")\n            exc_info = sys.exc_info()\n            raise template.TemplateSyntaxError, exc_info[1], exc_info[2]\n        return rows\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2013 Hewlett-Packard Development Company, L.P.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django.core.urlresolvers import reverse\nfrom django.template import defaultfilters\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import tables\n\nfrom openstack_dashboard import api\n\nfrom openstack_dashboard.dashboards.admin.groups import constants\n\n\nLOG = logging.getLogger(__name__)\nLOGOUT_URL = 'logout'\nSTATUS_CHOICES = (\n    (\"true\", True),\n    (\"false\", False)\n)\n\n\nclass CreateGroupLink(tables.LinkAction):\n    name = \"create\"\n    verbose_name = _(\"Create Group\")\n    url = constants.GROUPS_CREATE_URL\n    classes = (\"ajax-modal\", \"btn-create\")\n    policy_rules = ((\"identity\", \"identity:create_group\"),)\n\n    def allowed(self, request, group):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass EditGroupLink(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Edit Group\")\n    url = constants.GROUPS_UPDATE_URL\n    classes = (\"ajax-modal\", \"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:update_group\"),)\n\n    def allowed(self, request, group):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass DeleteGroupsAction(tables.DeleteAction):\n    name = \"delete\"\n    data_type_singular = _(\"Group\")\n    data_type_plural = _(\"Groups\")\n    policy_rules = ((\"identity\", \"identity:delete_group\"),)\n\n    def allowed(self, request, datum):\n        return api.keystone.keystone_can_edit_group()\n\n    def delete(self, request, obj_id):\n        LOG.info('Deleting group \"%s\".' % obj_id)\n        api.keystone.group_delete(request, obj_id)\n\n\nclass ManageUsersLink(tables.LinkAction):\n    name = \"users\"\n    verbose_name = _(\"Modify Users\")\n    url = constants.GROUPS_MANAGE_URL\n    classes = (\"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:get_group\"),\n                    (\"identity\", \"identity:list_users\"),)\n\n    def allowed(self, request, datum):\n        return api.keystone.keystone_can_edit_group()\n\n\nclass GroupFilterAction(tables.FilterAction):\n    def filter(self, table, groups, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n\n        def comp(group):\n            if q in group.name.lower():\n                return True\n            return False\n\n        return filter(comp, groups)\n\n\nclass GroupsTable(tables.DataTable):\n    name = tables.Column('name', verbose_name=_('Name'))\n    description = tables.Column(lambda obj: getattr(obj, 'description', None),\n                                verbose_name=_('Description'))\n    id = tables.Column('id', verbose_name=_('Group ID'))\n\n    class Meta:\n        name = \"groups\"\n        verbose_name = _(\"Groups\")\n        row_actions = (ManageUsersLink, EditGroupLink, DeleteGroupsAction)\n        table_actions = (GroupFilterAction, CreateGroupLink,\n                         DeleteGroupsAction)\n\n\nclass UserFilterAction(tables.FilterAction):\n    def filter(self, table, users, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n        return [user for user in users\n                if q in user.name.lower()\n                or q in getattr(user, 'email', '').lower()]\n\n\nclass RemoveMembers(tables.DeleteAction):\n    name = \"removeGroupMember\"\n    action_present = _(\"Remove\")\n    action_past = _(\"Removed\")\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    policy_rules = ((\"identity\", \"identity:remove_user_from_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def action(self, request, obj_id):\n        user_obj = self.table.get_object_by_id(obj_id)\n        group_id = self.table.kwargs['group_id']\n        LOG.info('Removing user %s from group %s.' % (user_obj.id,\n                                                      group_id))\n        api.keystone.remove_group_user(request,\n                                       group_id=group_id,\n                                       user_id=user_obj.id)\n        # TODO(lin-hua-cheng): Fix the bug when removing current user\n        # Keystone revokes the token of the user removed from the group.\n        # If the logon user was removed, redirect the user to logout.\n\n\nclass AddMembersLink(tables.LinkAction):\n    name = \"add_user_link\"\n    verbose_name = _(\"Add...\")\n    classes = (\"ajax-modal\", \"btn-create\")\n    url = constants.GROUPS_ADD_MEMBER_URL\n    policy_rules = ((\"identity\", \"identity:list_users\"),\n                    (\"identity\", \"identity:add_user_to_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def get_link_url(self, datum=None):\n        return reverse(self.url, kwargs=self.table.kwargs)\n\n\nclass UsersTable(tables.DataTable):\n    name = tables.Column('name', verbose_name=_('User Name'))\n    email = tables.Column('email', verbose_name=_('Email'),\n                          filters=[defaultfilters.escape,\n                                   defaultfilters.urlize])\n    id = tables.Column('id', verbose_name=_('User ID'))\n    enabled = tables.Column('enabled', verbose_name=_('Enabled'),\n                            status=True,\n                            status_choices=STATUS_CHOICES,\n                            empty_value=\"False\")\n\n\nclass GroupMembersTable(UsersTable):\n    class Meta:\n        name = \"group_members\"\n        verbose_name = _(\"Group Members\")\n        table_actions = (UserFilterAction, AddMembersLink, RemoveMembers)\n\n\nclass AddMembers(tables.BatchAction):\n    name = \"addMember\"\n    action_present = _(\"Add\")\n    action_past = _(\"Added\")\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    classes = (\"btn-create\", )\n    requires_input = True\n    success_url = constants.GROUPS_MANAGE_URL\n    policy_rules = ((\"identity\", \"identity:add_user_to_group\"),)\n\n    def allowed(self, request, user=None):\n        return api.keystone.keystone_can_edit_group()\n\n    def action(self, request, obj_id):\n        user_obj = self.table.get_object_by_id(obj_id)\n        group_id = self.table.kwargs['group_id']\n        LOG.info('Adding user %s to group %s.' % (user_obj.id,\n                                                  group_id))\n        api.keystone.add_group_user(request,\n                                    group_id=group_id,\n                                    user_id=user_obj.id)\n        # TODO(lin-hua-cheng): Fix the bug when adding current user\n        # Keystone revokes the token of the user added to the group.\n        # If the logon user was added, redirect the user to logout.\n\n    def get_success_url(self, request=None):\n        group_id = self.table.kwargs.get('group_id', None)\n        return reverse(self.success_url, args=[group_id])\n\n\nclass GroupNonMembersTable(UsersTable):\n    class Meta:\n        name = \"group_non_members\"\n        verbose_name = _(\"Non-Members\")\n        table_actions = (UserFilterAction, AddMembers)\n", "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom django.template import defaultfilters\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tables\n\nfrom openstack_dashboard import api\n\n\nENABLE = 0\nDISABLE = 1\n\n\nclass CreateUserLink(tables.LinkAction):\n    name = \"create\"\n    verbose_name = _(\"Create User\")\n    url = \"horizon:admin:users:create\"\n    classes = (\"ajax-modal\", \"btn-create\")\n    policy_rules = (('identity', 'identity:create_grant'),\n                    (\"identity\", \"identity:create_user\"),\n                    (\"identity\", \"identity:list_roles\"),\n                    (\"identity\", \"identity:list_projects\"),)\n\n    def allowed(self, request, user):\n        return api.keystone.keystone_can_edit_user()\n\n\nclass EditUserLink(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Edit\")\n    url = \"horizon:admin:users:update\"\n    classes = (\"ajax-modal\", \"btn-edit\")\n    policy_rules = ((\"identity\", \"identity:update_user\"),\n                    (\"identity\", \"identity:list_projects\"),)\n\n    def get_policy_target(self, request, user):\n        return {\"user_id\": user.id}\n\n    def allowed(self, request, user):\n        return api.keystone.keystone_can_edit_user()\n\n\nclass ToggleEnabled(tables.BatchAction):\n    name = \"toggle\"\n    action_present = (_(\"Enable\"), _(\"Disable\"))\n    action_past = (_(\"Enabled\"), _(\"Disabled\"))\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    classes = (\"btn-toggle\",)\n    policy_rules = ((\"identity\", \"identity:update_user\"),)\n\n    def get_policy_target(self, request, user=None):\n        if user:\n            return {\"user_id\": user.id}\n        return {}\n\n    def allowed(self, request, user=None):\n        if not api.keystone.keystone_can_edit_user():\n            return False\n\n        self.enabled = True\n        if not user:\n            return self.enabled\n        self.enabled = user.enabled\n        if self.enabled:\n            self.current_present_action = DISABLE\n        else:\n            self.current_present_action = ENABLE\n        return True\n\n    def update(self, request, user=None):\n        super(ToggleEnabled, self).update(request, user)\n        if user and user.id == request.user.id:\n            self.attrs[\"disabled\"] = \"disabled\"\n\n    def action(self, request, obj_id):\n        if obj_id == request.user.id:\n            messages.info(request, _('You cannot disable the user you are '\n                                     'currently logged in as.'))\n            return\n        if self.enabled:\n            api.keystone.user_update_enabled(request, obj_id, False)\n            self.current_past_action = DISABLE\n        else:\n            api.keystone.user_update_enabled(request, obj_id, True)\n            self.current_past_action = ENABLE\n\n\nclass DeleteUsersAction(tables.DeleteAction):\n    data_type_singular = _(\"User\")\n    data_type_plural = _(\"Users\")\n    policy_rules = ((\"identity\", \"identity:delete_user\"),)\n\n    def allowed(self, request, datum):\n        if not api.keystone.keystone_can_edit_user() or \\\n                (datum and datum.id == request.user.id):\n            return False\n        return True\n\n    def delete(self, request, obj_id):\n        api.keystone.user_delete(request, obj_id)\n\n\nclass UserFilterAction(tables.FilterAction):\n    def filter(self, table, users, filter_string):\n        \"\"\"Naive case-insensitive search.\"\"\"\n        q = filter_string.lower()\n        return [user for user in users\n                if q in user.name.lower()\n                or q in getattr(user, 'email', '').lower()]\n\n\nclass UsersTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"true\", True),\n        (\"false\", False)\n    )\n    name = tables.Column('name', verbose_name=_('User Name'))\n    email = tables.Column('email', verbose_name=_('Email'),\n                          filters=(lambda v: defaultfilters\n                                   .default_if_none(v, \"\"),\n                                   defaultfilters.escape,\n                                   defaultfilters.urlize)\n                          )\n    # Default tenant is not returned from Keystone currently.\n    #default_tenant = tables.Column('default_tenant',\n    #                               verbose_name=_('Default Project'))\n    id = tables.Column('id', verbose_name=_('User ID'))\n    enabled = tables.Column('enabled', verbose_name=_('Enabled'),\n                            status=True,\n                            status_choices=STATUS_CHOICES,\n                            empty_value=\"False\")\n\n    class Meta:\n        name = \"users\"\n        verbose_name = _(\"Users\")\n        row_actions = (EditUserLink, ToggleEnabled, DeleteUsersAction)\n        table_actions = (UserFilterAction, CreateUserLink, DeleteUsersAction)\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom django.core import urlresolvers\nfrom django.http import Http404  # noqa\nfrom django.template.defaultfilters import title  # noqa\nfrom django.utils.http import urlencode  # noqa\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tables\nfrom horizon.utils import filters\n\nfrom heatclient import exc\n\nfrom openstack_dashboard import api\nfrom openstack_dashboard.dashboards.project.stacks import mappings\n\n\nclass LaunchStack(tables.LinkAction):\n    name = \"launch\"\n    verbose_name = _(\"Launch Stack\")\n    url = \"horizon:project:stacks:select_template\"\n    classes = (\"btn-create\", \"ajax-modal\")\n\n\nclass ChangeStackTemplate(tables.LinkAction):\n    name = \"edit\"\n    verbose_name = _(\"Change Stack Template\")\n    url = \"horizon:project:stacks:change_template\"\n    classes = (\"ajax-modal\", \"btn-edit\")\n\n    def get_link_url(self, stack):\n        return urlresolvers.reverse(self.url, args=[stack.id])\n\n\nclass DeleteStack(tables.BatchAction):\n    name = \"delete\"\n    action_present = _(\"Delete\")\n    action_past = _(\"Scheduled deletion of %(data_type)s\")\n    data_type_singular = _(\"Stack\")\n    data_type_plural = _(\"Stacks\")\n    classes = ('btn-danger', 'btn-terminate')\n\n    def action(self, request, stack_id):\n        api.heat.stack_delete(request, stack_id)\n\n    def allowed(self, request, stack):\n        if stack is not None:\n            return stack.stack_status != 'DELETE_COMPLETE'\n        return True\n\n\nclass StacksUpdateRow(tables.Row):\n    ajax = True\n\n    def can_be_selected(self, datum):\n        return datum.stack_status != 'DELETE_COMPLETE'\n\n    def get_data(self, request, stack_id):\n        try:\n            return api.heat.stack_get(request, stack_id)\n        except exc.HTTPNotFound:\n            # returning 404 to the ajax call removes the\n            # row from the table on the ui\n            raise Http404\n        except Exception as e:\n            messages.error(request, e)\n\n\nclass StacksTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"Complete\", True),\n        (\"Failed\", False),\n    )\n    name = tables.Column(\"stack_name\",\n                         verbose_name=_(\"Stack Name\"),\n                         link=\"horizon:project:stacks:detail\",)\n    created = tables.Column(\"creation_time\",\n                            verbose_name=_(\"Created\"),\n                            filters=(filters.parse_isotime,\n                                     filters.timesince_or_never))\n    updated = tables.Column(\"updated_time\",\n                            verbose_name=_(\"Updated\"),\n                            filters=(filters.parse_isotime,\n                                     filters.timesince_or_never))\n    status = tables.Column(\"status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),\n                           status=True,\n                           status_choices=STATUS_CHOICES)\n\n    def get_object_display(self, stack):\n        return stack.stack_name\n\n    class Meta:\n        name = \"stacks\"\n        verbose_name = _(\"Stacks\")\n        status_columns = [\"status\", ]\n        row_class = StacksUpdateRow\n        table_actions = (LaunchStack, DeleteStack,)\n        row_actions = (DeleteStack,\n                       ChangeStackTemplate)\n\n\ndef get_resource_url(obj):\n    return urlresolvers.reverse('horizon:project:stacks:resource',\n                                args=(obj.stack_id, obj.resource_name))\n\n\nclass EventsTable(tables.DataTable):\n\n    logical_resource = tables.Column('resource_name',\n                                     verbose_name=_(\"Stack Resource\"),\n                                     link=get_resource_url)\n    physical_resource = tables.Column('physical_resource_id',\n                                      verbose_name=_(\"Resource\"),\n                                      link=mappings.resource_to_url)\n    timestamp = tables.Column('event_time',\n                              verbose_name=_(\"Time Since Event\"),\n                              filters=(filters.parse_isotime,\n                                       filters.timesince_or_never))\n    status = tables.Column(\"resource_status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),)\n\n    statusreason = tables.Column(\"resource_status_reason\",\n                                 verbose_name=_(\"Status Reason\"),)\n\n    class Meta:\n        name = \"events\"\n        verbose_name = _(\"Stack Events\")\n\n\nclass ResourcesUpdateRow(tables.Row):\n    ajax = True\n\n    def get_data(self, request, resource_name):\n        try:\n            stack = self.table.stack\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            return api.heat.resource_get(\n                request, stack_identifier, resource_name)\n        except exc.HTTPNotFound:\n            # returning 404 to the ajax call removes the\n            # row from the table on the ui\n            raise Http404\n        except Exception as e:\n            messages.error(request, e)\n\n\nclass ResourcesTable(tables.DataTable):\n    STATUS_CHOICES = (\n        (\"Create Complete\", True),\n        (\"Create Failed\", False),\n    )\n\n    logical_resource = tables.Column('resource_name',\n                                     verbose_name=_(\"Stack Resource\"),\n                                     link=get_resource_url)\n    physical_resource = tables.Column('physical_resource_id',\n                                     verbose_name=_(\"Resource\"),\n                                     link=mappings.resource_to_url)\n    resource_type = tables.Column(\"resource_type\",\n                           verbose_name=_(\"Stack Resource Type\"),)\n    updated_time = tables.Column('updated_time',\n                              verbose_name=_(\"Date Updated\"),\n                              filters=(filters.parse_isotime,\n                                       filters.timesince_or_never))\n    status = tables.Column(\"resource_status\",\n                           filters=(title, filters.replace_underscores),\n                           verbose_name=_(\"Status\"),\n                           status=True,\n                           status_choices=STATUS_CHOICES)\n\n    statusreason = tables.Column(\"resource_status_reason\",\n                                 verbose_name=_(\"Status Reason\"),)\n\n    def __init__(self, request, data=None,\n                 needs_form_wrapper=None, **kwargs):\n        super(ResourcesTable, self).__init__(\n            request, data, needs_form_wrapper, **kwargs)\n        self.stack = kwargs['stack']\n\n    def get_object_id(self, datum):\n        return datum.resource_name\n\n    class Meta:\n        name = \"resources\"\n        verbose_name = _(\"Stack Resources\")\n        status_columns = [\"status\", ]\n        row_class = ResourcesUpdateRow\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport logging\n\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom horizon import messages\nfrom horizon import tabs\nfrom openstack_dashboard import api\n\nfrom openstack_dashboard.dashboards.project.stacks \\\n    import api as project_api\nfrom openstack_dashboard.dashboards.project.stacks import mappings\nfrom openstack_dashboard.dashboards.project.stacks \\\n    import tables as project_tables\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass StackTopologyTab(tabs.Tab):\n    name = _(\"Topology\")\n    slug = \"topology\"\n    template_name = \"project/stacks/_detail_topology.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        context = {}\n        stack = self.tab_group.kwargs['stack']\n        context['stack_id'] = stack.id\n        context['d3_data'] = project_api.d3_data(request, stack_id=stack.id)\n        return context\n\n\nclass StackOverviewTab(tabs.Tab):\n    name = _(\"Overview\")\n    slug = \"overview\"\n    template_name = \"project/stacks/_detail_overview.html\"\n\n    def get_context_data(self, request):\n        return {\"stack\": self.tab_group.kwargs['stack']}\n\n\nclass ResourceOverviewTab(tabs.Tab):\n    name = _(\"Overview\")\n    slug = \"resource_overview\"\n    template_name = \"project/stacks/_resource_overview.html\"\n\n    def get_context_data(self, request):\n        resource = self.tab_group.kwargs['resource']\n        resource_url = mappings.resource_to_url(resource)\n        return {\n            \"resource\": resource,\n            \"resource_url\": resource_url,\n            \"metadata\": self.tab_group.kwargs['metadata']}\n\n\nclass StackEventsTab(tabs.Tab):\n    name = _(\"Events\")\n    slug = \"events\"\n    template_name = \"project/stacks/_detail_events.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        stack = self.tab_group.kwargs['stack']\n        try:\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            events = api.heat.events_list(self.request, stack_identifier)\n            LOG.debug('got events %s' % events)\n            # The stack id is needed to generate the resource URL.\n            for event in events:\n                event.stack_id = stack.id\n        except Exception:\n            events = []\n            messages.error(request, _(\n                'Unable to get events for stack \"%s\".') % stack.stack_name)\n        return {\"stack\": stack,\n                \"table\": project_tables.EventsTable(request, data=events), }\n\n\nclass StackResourcesTab(tabs.Tab):\n    name = _(\"Resources\")\n    slug = \"resources\"\n    template_name = \"project/stacks/_detail_resources.html\"\n    preload = False\n\n    def get_context_data(self, request):\n        stack = self.tab_group.kwargs['stack']\n        try:\n            stack_identifier = '%s/%s' % (stack.stack_name, stack.id)\n            resources = api.heat.resources_list(self.request, stack_identifier)\n            LOG.debug('got resources %s' % resources)\n            # The stack id is needed to generate the resource URL.\n            for r in resources:\n                r.stack_id = stack.id\n        except Exception:\n            resources = []\n            messages.error(request, _(\n                'Unable to get resources for stack \"%s\".') % stack.stack_name)\n        return {\"stack\": stack,\n                \"table\": project_tables.ResourcesTable(\n                    request, data=resources, stack=stack), }\n\n\nclass StackDetailTabs(tabs.TabGroup):\n    slug = \"stack_details\"\n    tabs = (StackTopologyTab, StackOverviewTab, StackResourcesTab,\n            StackEventsTab)\n    sticky = True\n\n\nclass ResourceDetailTabs(tabs.TabGroup):\n    slug = \"resource_details\"\n    tabs = (ResourceOverviewTab,)\n    sticky = True\n"], "filenames": ["horizon/static/horizon/js/horizon.instances.js", "horizon/tables/base.py", "openstack_dashboard/dashboards/admin/groups/tables.py", "openstack_dashboard/dashboards/admin/users/tables.py", "openstack_dashboard/dashboards/project/stacks/tables.py", "openstack_dashboard/dashboards/project/stacks/tabs.py"], "buggy_code_start_loc": [53, 679, 164, 134, 116, 81], "buggy_code_end_loc": [56, 680, 165, 135, 167, 101], "fixing_code_start_loc": [54, 679, 164, 134, 117, 82], "fixing_code_end_loc": [63, 682, 166, 137, 172, 108], "type": "CWE-79", "message": "A vulnerability was found in yanheven console and classified as problematic. Affected by this issue is some unknown functionality of the file horizon/static/horizon/js/horizon.instances.js. The manipulation leads to cross site scripting. The attack may be launched remotely. The name of the patch is 32a7b713468161282f2ea01d5e2faff980d924cd. It is recommended to apply a patch to fix this issue. VDB-218354 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2014-125078", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-15T09:15:13.693", "lastModified": "2023-01-24T15:19:37.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in yanheven console and classified as problematic. Affected by this issue is some unknown functionality of the file horizon/static/horizon/js/horizon.instances.js. The manipulation leads to cross site scripting. The attack may be launched remotely. The name of the patch is 32a7b713468161282f2ea01d5e2faff980d924cd. It is recommended to apply a patch to fix this issue. VDB-218354 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:horizon_project:horizon:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-07-08", "matchCriteriaId": "F2B8D7F2-5FD3-490A-B411-675703B45C16"}]}]}], "references": [{"url": "https://github.com/yanheven/console/commit/32a7b713468161282f2ea01d5e2faff980d924cd", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218354", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218354", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yanheven/console/commit/32a7b713468161282f2ea01d5e2faff980d924cd"}}