{"buggy_code": ["'use strict';\nconst UserController = require('../lib/Controllers/UserController')\n  .UserController;\nconst Config = require('../lib/Config');\ndescribe('ParseLiveQuery', function () {\n  it('can subscribe to query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can return different object in afterEvent', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const object = new Parse.Object('Yolo');\n      req.object = object;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.className).toBe('Yolo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('can handle afterEvent throw', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      throw 'Throw error from LQ afterEvent.';\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', e => {\n      expect(e).toBe('Throw error from LQ afterEvent.');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent sendEvent to false', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      const original = req.original;\n\n      setTimeout(() => {\n        done();\n      }, 2000);\n\n      if (current.get('foo') != original.get('foo')) {\n        req.sendEvent = false;\n      }\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle async afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const parent = new TestObject();\n    const child = new TestObject();\n    child.set('bar', 'foo');\n    await Parse.Object.saveAll([parent, child]);\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async req => {\n      const current = req.object;\n      const pointer = current.get('child');\n      await pointer.fetch();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', parent.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('child')).toBeDefined();\n      expect(object.get('child').get('bar')).toBe('foo');\n      done();\n    });\n    parent.set('child', child);\n    await parent.save();\n  });\n\n  it('can handle beforeConnect / beforeSubscribe hooks', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe('TestObject', req => {\n      expect(req.op).toBe('subscribe');\n      expect(req.requestId).toBe(1);\n      expect(req.query).toBeDefined();\n      expect(req.user).toBeUndefined();\n    });\n\n    Parse.Cloud.beforeConnect(req => {\n      expect(req.event).toBe('connect');\n      expect(req.clients).toBe(0);\n      expect(req.subscriptions).toBe(0);\n      expect(req.useMasterKey).toBe(false);\n      expect(req.installationId).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.sessionToken).toBeUndefined();\n      expect(req.client).toBeDefined();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle beforeConnect error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {\n      throw new Error('You shall not pass!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not pass!');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can handle beforeSubscribe error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      throw new Error('You shall not subscribe!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n      done();\n    });\n  });\n\n  it('can handle mutate beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.equalTo('yolo', 'abc');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', () => {\n      fail();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n    setTimeout(async () => {\n      done();\n    }, 1000);\n  });\n\n  it('can return a new beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'yolo');\n      request.query = query;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('yolo');\n      done();\n    });\n    const object = new TestObject();\n    object.set({ foo: 'yolo' });\n    await object.save();\n  });\n\n  it('can handle select beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.select('yolo');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBeUndefined();\n      expect(object.get('yolo')).toBe('abc');\n      done();\n    });\n    object.set({ foo: 'bar', yolo: 'abc' });\n    await object.save();\n  });\n\n  it('handle invalid websocket payload length', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    // All control frames must have a payload length of 125 bytes or less.\n    // https://tools.ietf.org/html/rfc6455#section-5.5\n    //\n    // 0x89 = 10001001 = ping\n    // 0xfe = 11111110 = first bit is masking the remaining 7 are 1111110 or 126 the payload length\n    // https://tools.ietf.org/html/rfc6455#section-5.2\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.socket._socket.write(Buffer.from([0x89, 0xfe]));\n\n    subscription.on('update', async object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    // Wait for Websocket timeout to reconnect\n    setTimeout(async () => {\n      object.set({ foo: 'bar' });\n      await object.save();\n    }, 1000);\n  });\n\n  it('should execute live query update on email validation', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {},\n    };\n\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['_User'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n      appName: 'liveQueryEmailValidation',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 20, // 0.5 second\n      publicServerURL: 'http://localhost:8378/1',\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('password', 'asdf');\n      user.set('email', 'asdf@example.com');\n      user.set('username', 'zxcv');\n      user\n        .signUp()\n        .then(() => {\n          const config = Config.get('test');\n          return config.database.find('_User', {\n            username: 'zxcv',\n          });\n        })\n        .then(async results => {\n          const foundUser = results[0];\n          const query = new Parse.Query('_User');\n          query.equalTo('objectId', foundUser.objectId);\n          const subscription = await query.subscribe();\n\n          subscription.on('update', async object => {\n            expect(object).toBeDefined();\n            expect(object.get('emailVerified')).toBe(true);\n            done();\n          });\n\n          const userController = new UserController(emailAdapter, 'test', {\n            verifyUserEmails: true,\n          });\n          userController.verifyEmail(\n            foundUser.username,\n            foundUser._email_verify_token\n          );\n        });\n    });\n  });\n\n  afterEach(async function (done) {\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n    // Wait for live query client to disconnect\n    setTimeout(() => {\n      done();\n    }, 1000);\n  });\n});\n", "import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  runLiveQueryEventHandlers,\n  maybeRunConnectTrigger,\n  maybeRunSubscribeTrigger,\n  maybeRunAfterEventTrigger,\n} from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(config);\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: 60 * 60 * 1000, // 1h\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe messsage %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error(\n          'Get message %s from unknown channel %j',\n          message,\n          channel\n        );\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose(\n      'ClassName: %j | ObjectId: %s',\n      className,\n      deletedParseObject.id\n    );\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(\n        deletedParseObject,\n        subscription\n      );\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(\n        subscription.clientRequestIds\n      )) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          this._matchesCLP(\n            classLevelPermissions,\n            message.currentParseObject,\n            client,\n            requestId,\n            op\n          )\n            .then(() => {\n              // Check ACL\n              return this._matchesACL(acl, client, requestId);\n            })\n            .then(isMatched => {\n              if (!isMatched) {\n                return null;\n              }\n              res = {\n                event: 'Delete',\n                sessionToken: client.sessionToken,\n                object: deletedParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(() => {\n              if (!res.sendEvent) {\n                return;\n              }\n              if (res.object && typeof res.object.toJSON === 'function') {\n                deletedParseObject = res.object.toJSON();\n                deletedParseObject.className = className;\n              }\n              client.pushDelete(requestId, deletedParseObject);\n            })\n            .catch(error => {\n              Client.pushError(\n                client.parseWebSocket,\n                error.code || 141,\n                error.message || error,\n                false,\n                requestId\n              );\n              logger.error(\n                `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                  JSON.stringify(error)\n              );\n            });\n        }\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose(\n      'ClassName: %s | ObjectId: %s',\n      className,\n      currentParseObject.id\n    );\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(\n        subscription.clientRequestIds\n      )) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(\n              originalACL,\n              client,\n              requestId\n            );\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(\n              currentACL,\n              client,\n              requestId\n            );\n          }\n          const op = this._getCLPOperation(subscription.query);\n          this._matchesCLP(\n            classLevelPermissions,\n            message.currentParseObject,\n            client,\n            requestId,\n            op\n          )\n            .then(() => {\n              return Promise.all([\n                originalACLCheckingPromise,\n                currentACLCheckingPromise,\n              ]);\n            })\n            .then(([isOriginalMatched, isCurrentMatched]) => {\n              logger.verbose(\n                'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n                originalParseObject,\n                currentParseObject,\n                isOriginalSubscriptionMatched,\n                isCurrentSubscriptionMatched,\n                isOriginalMatched,\n                isCurrentMatched,\n                subscription.hash\n              );\n              // Decide event type\n              let type;\n              if (isOriginalMatched && isCurrentMatched) {\n                type = 'Update';\n              } else if (isOriginalMatched && !isCurrentMatched) {\n                type = 'Leave';\n              } else if (!isOriginalMatched && isCurrentMatched) {\n                if (originalParseObject) {\n                  type = 'Enter';\n                } else {\n                  type = 'Create';\n                }\n              } else {\n                return null;\n              }\n              message.event = type;\n              res = {\n                event: type,\n                sessionToken: client.sessionToken,\n                object: currentParseObject,\n                original: originalParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(\n              () => {\n                if (!res.sendEvent) {\n                  return;\n                }\n                if (res.object && typeof res.object.toJSON === 'function') {\n                  currentParseObject = res.object.toJSON();\n                  currentParseObject.className =\n                    res.object.className || className;\n                }\n\n                if (res.original && typeof res.original.toJSON === 'function') {\n                  originalParseObject = res.original.toJSON();\n                  originalParseObject.className =\n                    res.original.className || className;\n                }\n                const functionName = 'push' + message.event;\n                if (client[functionName]) {\n                  client[functionName](\n                    requestId,\n                    currentParseObject,\n                    originalParseObject\n                  );\n                }\n              },\n              error => {\n                Client.pushError(\n                  client.parseWebSocket,\n                  error.code || 141,\n                  error.message || error,\n                  false,\n                  requestId\n                );\n                logger.error(\n                  `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                    JSON.stringify(error)\n                );\n              }\n            );\n        }\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(\n        client.subscriptionInfos\n      )) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(\n          subscription.className\n        );\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(\n    sessionToken: ?string\n  ): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          // Store a resolved promise with the error for 10 minutes\n          result.error = error;\n          this.authCache.set(\n            sessionToken,\n            Promise.resolve(result),\n            60 * 10 * 1000\n          );\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(\n        subscriptionInfo.sessionToken\n      );\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key =>\n          key.startsWith('role:')\n        );\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async _matchesACL(\n    acl: any,\n    client: any,\n    requestId: number\n  ): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      await maybeRunConnectTrigger('beforeConnect', req);\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (error) {\n      Client.pushError(\n        parseWebsocket,\n        error.code || 141,\n        error.message || error,\n        false\n      );\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (\n      !validKeyPairs ||\n      validKeyPairs.size == 0 ||\n      !validKeyPairs.has('masterKey')\n    ) {\n      return false;\n    }\n    if (\n      !request ||\n      !Object.prototype.hasOwnProperty.call(request, 'masterKey')\n    ) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    try {\n      await maybeRunSubscribeTrigger('beforeSubscribe', className, request);\n\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(\n          className,\n          request.query.where,\n          subscriptionHash\n        );\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(\n        parseWebsocket.clientId,\n        request.requestId\n      );\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      Client.pushError(\n        parseWebsocket,\n        e.code || 141,\n        e.message || e,\n        false,\n        request.requestId\n      );\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(e)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(\n    parseWebsocket: any,\n    request: any,\n    notifyClient: boolean = true\n  ): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n", "/*\n**** GENERATED CODE ****\nThis code has been generated by resources/buildConfigDefinitions.js\nDo not edit manually, but update Options/index.js\n*/\nvar parsers = require('./parsers');\n\nmodule.exports.ParseServerOptions = {\n  accountLockout: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT',\n    help: 'account lockout policy for failed login attempts',\n    action: parsers.objectParser,\n  },\n  allowClientClassCreation: {\n    env: 'PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION',\n    help: 'Enable (or disable) client class creation, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  allowCustomObjectId: {\n    env: 'PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID',\n    help: 'Enable (or disable) custom objectId',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  allowHeaders: {\n    env: 'PARSE_SERVER_ALLOW_HEADERS',\n    help: 'Add headers to Access-Control-Allow-Headers',\n    action: parsers.arrayParser,\n  },\n  allowOrigin: {\n    env: 'PARSE_SERVER_ALLOW_ORIGIN',\n    help: 'Sets the origin to Access-Control-Allow-Origin',\n  },\n  analyticsAdapter: {\n    env: 'PARSE_SERVER_ANALYTICS_ADAPTER',\n    help: 'Adapter module for the analytics',\n    action: parsers.moduleOrObjectParser,\n  },\n  appId: {\n    env: 'PARSE_SERVER_APPLICATION_ID',\n    help: 'Your Parse Application ID',\n    required: true,\n  },\n  appName: {\n    env: 'PARSE_SERVER_APP_NAME',\n    help: 'Sets the app name',\n  },\n  auth: {\n    env: 'PARSE_SERVER_AUTH_PROVIDERS',\n    help:\n      'Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication',\n    action: parsers.objectParser,\n  },\n  cacheAdapter: {\n    env: 'PARSE_SERVER_CACHE_ADAPTER',\n    help: 'Adapter module for the cache',\n    action: parsers.moduleOrObjectParser,\n  },\n  cacheMaxSize: {\n    env: 'PARSE_SERVER_CACHE_MAX_SIZE',\n    help: 'Sets the maximum size for the in memory cache, defaults to 10000',\n    action: parsers.numberParser('cacheMaxSize'),\n    default: 10000,\n  },\n  cacheTTL: {\n    env: 'PARSE_SERVER_CACHE_TTL',\n    help:\n      'Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)',\n    action: parsers.numberParser('cacheTTL'),\n    default: 5000,\n  },\n  clientKey: {\n    env: 'PARSE_SERVER_CLIENT_KEY',\n    help: 'Key for iOS, MacOS, tvOS clients',\n  },\n  cloud: {\n    env: 'PARSE_SERVER_CLOUD',\n    help: 'Full path to your cloud code main.js',\n  },\n  cluster: {\n    env: 'PARSE_SERVER_CLUSTER',\n    help:\n      'Run with cluster, optionally set the number of processes default to os.cpus().length',\n    action: parsers.numberOrBooleanParser,\n  },\n  collectionPrefix: {\n    env: 'PARSE_SERVER_COLLECTION_PREFIX',\n    help: 'A collection prefix for the classes',\n    default: '',\n  },\n  customPages: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES',\n    help: 'custom pages for password validation and reset',\n    action: parsers.objectParser,\n    default: {},\n  },\n  databaseAdapter: {\n    env: 'PARSE_SERVER_DATABASE_ADAPTER',\n    help: 'Adapter module for the database',\n    action: parsers.moduleOrObjectParser,\n  },\n  databaseOptions: {\n    env: 'PARSE_SERVER_DATABASE_OPTIONS',\n    help: 'Options to pass to the mongodb client',\n    action: parsers.objectParser,\n  },\n  databaseURI: {\n    env: 'PARSE_SERVER_DATABASE_URI',\n    help:\n      'The full URI to your database. Supported databases are mongodb or postgres.',\n    required: true,\n    default: 'mongodb://localhost:27017/parse',\n  },\n  directAccess: {\n    env: 'PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS',\n    help:\n      'Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  dotNetKey: {\n    env: 'PARSE_SERVER_DOT_NET_KEY',\n    help: 'Key for Unity and .Net SDK',\n  },\n  emailAdapter: {\n    env: 'PARSE_SERVER_EMAIL_ADAPTER',\n    help: 'Adapter module for email sending',\n    action: parsers.moduleOrObjectParser,\n  },\n  emailVerifyTokenValidityDuration: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_VALIDITY_DURATION',\n    help: 'Email verification token validity duration, in seconds',\n    action: parsers.numberParser('emailVerifyTokenValidityDuration'),\n  },\n  enableAnonymousUsers: {\n    env: 'PARSE_SERVER_ENABLE_ANON_USERS',\n    help: 'Enable (or disable) anonymous users, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableExpressErrorHandler: {\n    env: 'PARSE_SERVER_ENABLE_EXPRESS_ERROR_HANDLER',\n    help: 'Enables the default express error handler for all errors',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableSingleSchemaCache: {\n    env: 'PARSE_SERVER_ENABLE_SINGLE_SCHEMA_CACHE',\n    help:\n      'Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  expireInactiveSessions: {\n    env: 'PARSE_SERVER_EXPIRE_INACTIVE_SESSIONS',\n    help:\n      'Sets wether we should expire the inactive sessions, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  fileKey: {\n    env: 'PARSE_SERVER_FILE_KEY',\n    help: 'Key for your files',\n  },\n  filesAdapter: {\n    env: 'PARSE_SERVER_FILES_ADAPTER',\n    help: 'Adapter module for the files sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  graphQLPath: {\n    env: 'PARSE_SERVER_GRAPHQL_PATH',\n    help: 'Mount path for the GraphQL endpoint, defaults to /graphql',\n    default: '/graphql',\n  },\n  graphQLSchema: {\n    env: 'PARSE_SERVER_GRAPH_QLSCHEMA',\n    help: 'Full path to your GraphQL custom schema.graphql file',\n  },\n  host: {\n    env: 'PARSE_SERVER_HOST',\n    help: 'The host to serve ParseServer on, defaults to 0.0.0.0',\n    default: '0.0.0.0',\n  },\n  idempotencyOptions: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS',\n    help:\n      'Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  javascriptKey: {\n    env: 'PARSE_SERVER_JAVASCRIPT_KEY',\n    help: 'Key for the Javascript SDK',\n  },\n  jsonLogs: {\n    env: 'JSON_LOGS',\n    help: 'Log as structured JSON objects',\n    action: parsers.booleanParser,\n  },\n  liveQuery: {\n    env: 'PARSE_SERVER_LIVE_QUERY',\n    help: \"parse-server's LiveQuery configuration object\",\n    action: parsers.objectParser,\n  },\n  liveQueryServerOptions: {\n    env: 'PARSE_SERVER_LIVE_QUERY_SERVER_OPTIONS',\n    help:\n      'Live query server configuration options (will start the liveQuery server)',\n    action: parsers.objectParser,\n  },\n  loggerAdapter: {\n    env: 'PARSE_SERVER_LOGGER_ADAPTER',\n    help: 'Adapter module for the logging sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  logLevel: {\n    env: 'PARSE_SERVER_LOG_LEVEL',\n    help: 'Sets the level for logs',\n  },\n  logsFolder: {\n    env: 'PARSE_SERVER_LOGS_FOLDER',\n    help:\n      \"Folder for the logs (defaults to './logs'); set to null to disable file based logging\",\n    default: './logs',\n  },\n  masterKey: {\n    env: 'PARSE_SERVER_MASTER_KEY',\n    help: 'Your Parse Master Key',\n    required: true,\n  },\n  masterKeyIps: {\n    env: 'PARSE_SERVER_MASTER_KEY_IPS',\n    help:\n      'Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  maxLimit: {\n    env: 'PARSE_SERVER_MAX_LIMIT',\n    help: 'Max value for limit option on queries, defaults to unlimited',\n    action: parsers.numberParser('maxLimit'),\n  },\n  maxLogFiles: {\n    env: 'PARSE_SERVER_MAX_LOG_FILES',\n    help:\n      \"Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\",\n    action: parsers.objectParser,\n  },\n  maxUploadSize: {\n    env: 'PARSE_SERVER_MAX_UPLOAD_SIZE',\n    help: 'Max file size for uploads, defaults to 20mb',\n    default: '20mb',\n  },\n  middleware: {\n    env: 'PARSE_SERVER_MIDDLEWARE',\n    help: 'middleware for express server, can be string or function',\n  },\n  mountGraphQL: {\n    env: 'PARSE_SERVER_MOUNT_GRAPHQL',\n    help: 'Mounts the GraphQL endpoint',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  mountPath: {\n    env: 'PARSE_SERVER_MOUNT_PATH',\n    help: 'Mount path for the server, defaults to /parse',\n    default: '/parse',\n  },\n  mountPlayground: {\n    env: 'PARSE_SERVER_MOUNT_PLAYGROUND',\n    help: 'Mounts the GraphQL Playground - never use this option in production',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  objectIdSize: {\n    env: 'PARSE_SERVER_OBJECT_ID_SIZE',\n    help: \"Sets the number of characters in generated object id's, default 10\",\n    action: parsers.numberParser('objectIdSize'),\n    default: 10,\n  },\n  passwordPolicy: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY',\n    help: 'Password policy for enforcing password related rules',\n    action: parsers.objectParser,\n  },\n  playgroundPath: {\n    env: 'PARSE_SERVER_PLAYGROUND_PATH',\n    help: 'Mount path for the GraphQL Playground, defaults to /playground',\n    default: '/playground',\n  },\n  port: {\n    env: 'PORT',\n    help: 'The port to run the ParseServer, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  preserveFileName: {\n    env: 'PARSE_SERVER_PRESERVE_FILE_NAME',\n    help: 'Enable (or disable) the addition of a unique hash to the file names',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  preventLoginWithUnverifiedEmail: {\n    env: 'PARSE_SERVER_PREVENT_LOGIN_WITH_UNVERIFIED_EMAIL',\n    help:\n      'Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  protectedFields: {\n    env: 'PARSE_SERVER_PROTECTED_FIELDS',\n    help:\n      'Protected fields that should be treated with extra security when fetching details.',\n    action: parsers.objectParser,\n    default: {\n      _User: {\n        '*': ['email'],\n      },\n    },\n  },\n  publicServerURL: {\n    env: 'PARSE_PUBLIC_SERVER_URL',\n    help: 'Public URL to your parse server with http:// or https://.',\n  },\n  push: {\n    env: 'PARSE_SERVER_PUSH',\n    help:\n      'Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications',\n    action: parsers.objectParser,\n  },\n  readOnlyMasterKey: {\n    env: 'PARSE_SERVER_READ_ONLY_MASTER_KEY',\n    help:\n      'Read-only key, which has the same capabilities as MasterKey without writes',\n  },\n  restAPIKey: {\n    env: 'PARSE_SERVER_REST_API_KEY',\n    help: 'Key for REST calls',\n  },\n  revokeSessionOnPasswordReset: {\n    env: 'PARSE_SERVER_REVOKE_SESSION_ON_PASSWORD_RESET',\n    help:\n      \"When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\",\n    action: parsers.booleanParser,\n    default: true,\n  },\n  scheduledPush: {\n    env: 'PARSE_SERVER_SCHEDULED_PUSH',\n    help: 'Configuration for push scheduling, defaults to false.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  schemaCacheTTL: {\n    env: 'PARSE_SERVER_SCHEMA_CACHE_TTL',\n    help:\n      'The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.',\n    action: parsers.numberParser('schemaCacheTTL'),\n    default: 5000,\n  },\n  serverCloseComplete: {\n    env: 'PARSE_SERVER_SERVER_CLOSE_COMPLETE',\n    help: 'Callback when server has closed',\n  },\n  serverStartComplete: {\n    env: 'PARSE_SERVER_SERVER_START_COMPLETE',\n    help: 'Callback when server has started',\n  },\n  serverURL: {\n    env: 'PARSE_SERVER_URL',\n    help: 'URL to your parse server with http:// or https://.',\n    required: true,\n  },\n  sessionLength: {\n    env: 'PARSE_SERVER_SESSION_LENGTH',\n    help: 'Session duration, in seconds, defaults to 1 year',\n    action: parsers.numberParser('sessionLength'),\n    default: 31536000,\n  },\n  silent: {\n    env: 'SILENT',\n    help: 'Disables console output',\n    action: parsers.booleanParser,\n  },\n  startLiveQueryServer: {\n    env: 'PARSE_SERVER_START_LIVE_QUERY_SERVER',\n    help: 'Starts the liveQuery server',\n    action: parsers.booleanParser,\n  },\n  userSensitiveFields: {\n    env: 'PARSE_SERVER_USER_SENSITIVE_FIELDS',\n    help:\n      'Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields',\n    action: parsers.arrayParser,\n  },\n  verbose: {\n    env: 'VERBOSE',\n    help: 'Set the logging to verbose',\n    action: parsers.booleanParser,\n  },\n  verifyUserEmails: {\n    env: 'PARSE_SERVER_VERIFY_USER_EMAILS',\n    help: 'Enable (or disable) user email validation, defaults to false',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  webhookKey: {\n    env: 'PARSE_SERVER_WEBHOOK_KEY',\n    help: 'Key sent with outgoing webhook calls',\n  },\n};\nmodule.exports.CustomPagesOptions = {\n  choosePassword: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_CHOOSE_PASSWORD',\n    help: 'choose password page path',\n  },\n  invalidLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_LINK',\n    help: 'invalid link page path',\n  },\n  invalidVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_VERIFICATION_LINK',\n    help: 'invalid verification link page path',\n  },\n  linkSendFail: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_FAIL',\n    help: 'verification link send fail page path',\n  },\n  linkSendSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_SUCCESS',\n    help: 'verification link send success page path',\n  },\n  parseFrameURL: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PARSE_FRAME_URL',\n    help: 'for masking user-facing pages',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PASSWORD_RESET_SUCCESS',\n    help: 'password reset success page path',\n  },\n  verifyEmailSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_VERIFY_EMAIL_SUCCESS',\n    help: 'verify email success page path',\n  },\n};\nmodule.exports.LiveQueryOptions = {\n  classNames: {\n    env: 'PARSE_SERVER_LIVEQUERY_CLASSNAMES',\n    help: \"parse-server's LiveQuery classNames\",\n    action: parsers.arrayParser,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  wssAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.LiveQueryServerOptions = {\n  appId: {\n    env: 'PARSE_LIVE_QUERY_SERVER_APP_ID',\n    help:\n      'This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.',\n  },\n  cacheTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_CACHE_TIMEOUT',\n    help:\n      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).\",\n    action: parsers.numberParser('cacheTimeout'),\n  },\n  keyPairs: {\n    env: 'PARSE_LIVE_QUERY_SERVER_KEY_PAIRS',\n    help:\n      'A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.',\n    action: parsers.objectParser,\n  },\n  logLevel: {\n    env: 'PARSE_LIVE_QUERY_SERVER_LOG_LEVEL',\n    help:\n      'This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.',\n  },\n  masterKey: {\n    env: 'PARSE_LIVE_QUERY_SERVER_MASTER_KEY',\n    help:\n      'This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.',\n  },\n  port: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PORT',\n    help: 'The port to run the LiveQuery server, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  serverURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_SERVER_URL',\n    help:\n      'This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.',\n  },\n  websocketTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WEBSOCKET_TIMEOUT',\n    help:\n      'Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).',\n    action: parsers.numberParser('websocketTimeout'),\n  },\n  wssAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.IdempotencyOptions = {\n  paths: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_PATHS',\n    help:\n      'An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  ttl: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_TTL',\n    help:\n      'The duration in seconds after which a request record is discarded from the database, defaults to 300s.',\n    action: parsers.numberParser('ttl'),\n    default: 300,\n  },\n};\n", "/**\n * @interface ParseServerOptions\n * @property {Any} accountLockout account lockout policy for failed login attempts\n * @property {Boolean} allowClientClassCreation Enable (or disable) client class creation, defaults to true\n * @property {Boolean} allowCustomObjectId Enable (or disable) custom objectId\n * @property {String[]} allowHeaders Add headers to Access-Control-Allow-Headers\n * @property {String} allowOrigin Sets the origin to Access-Control-Allow-Origin\n * @property {Adapter<AnalyticsAdapter>} analyticsAdapter Adapter module for the analytics\n * @property {String} appId Your Parse Application ID\n * @property {String} appName Sets the app name\n * @property {Any} auth Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n * @property {Adapter<CacheAdapter>} cacheAdapter Adapter module for the cache\n * @property {Number} cacheMaxSize Sets the maximum size for the in memory cache, defaults to 10000\n * @property {Number} cacheTTL Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n * @property {String} clientKey Key for iOS, MacOS, tvOS clients\n * @property {String} cloud Full path to your cloud code main.js\n * @property {Number|Boolean} cluster Run with cluster, optionally set the number of processes default to os.cpus().length\n * @property {String} collectionPrefix A collection prefix for the classes\n * @property {CustomPagesOptions} customPages custom pages for password validation and reset\n * @property {Adapter<StorageAdapter>} databaseAdapter Adapter module for the database\n * @property {Any} databaseOptions Options to pass to the mongodb client\n * @property {String} databaseURI The full URI to your database. Supported databases are mongodb or postgres.\n * @property {Boolean} directAccess Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} dotNetKey Key for Unity and .Net SDK\n * @property {Adapter<MailAdapter>} emailAdapter Adapter module for email sending\n * @property {Number} emailVerifyTokenValidityDuration Email verification token validity duration, in seconds\n * @property {Boolean} enableAnonymousUsers Enable (or disable) anonymous users, defaults to true\n * @property {Boolean} enableExpressErrorHandler Enables the default express error handler for all errors\n * @property {Boolean} enableSingleSchemaCache Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.\n * @property {Boolean} expireInactiveSessions Sets wether we should expire the inactive sessions, defaults to true\n * @property {String} fileKey Key for your files\n * @property {Adapter<FilesAdapter>} filesAdapter Adapter module for the files sub-system\n * @property {String} graphQLPath Mount path for the GraphQL endpoint, defaults to /graphql\n * @property {String} graphQLSchema Full path to your GraphQL custom schema.graphql file\n * @property {String} host The host to serve ParseServer on, defaults to 0.0.0.0\n * @property {IdempotencyOptions} idempotencyOptions Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} javascriptKey Key for the Javascript SDK\n * @property {Boolean} jsonLogs Log as structured JSON objects\n * @property {LiveQueryOptions} liveQuery parse-server's LiveQuery configuration object\n * @property {LiveQueryServerOptions} liveQueryServerOptions Live query server configuration options (will start the liveQuery server)\n * @property {Adapter<LoggerAdapter>} loggerAdapter Adapter module for the logging sub-system\n * @property {String} logLevel Sets the level for logs\n * @property {String} logsFolder Folder for the logs (defaults to './logs'); set to null to disable file based logging\n * @property {String} masterKey Your Parse Master Key\n * @property {String[]} masterKeyIps Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n * @property {Number} maxLimit Max value for limit option on queries, defaults to unlimited\n * @property {Number|String} maxLogFiles Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\n * @property {String} maxUploadSize Max file size for uploads, defaults to 20mb\n * @property {Union} middleware middleware for express server, can be string or function\n * @property {Boolean} mountGraphQL Mounts the GraphQL endpoint\n * @property {String} mountPath Mount path for the server, defaults to /parse\n * @property {Boolean} mountPlayground Mounts the GraphQL Playground - never use this option in production\n * @property {Number} objectIdSize Sets the number of characters in generated object id's, default 10\n * @property {Any} passwordPolicy Password policy for enforcing password related rules\n * @property {String} playgroundPath Mount path for the GraphQL Playground, defaults to /playground\n * @property {Number} port The port to run the ParseServer, defaults to 1337.\n * @property {Boolean} preserveFileName Enable (or disable) the addition of a unique hash to the file names\n * @property {Boolean} preventLoginWithUnverifiedEmail Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false\n * @property {ProtectedFields} protectedFields Protected fields that should be treated with extra security when fetching details.\n * @property {String} publicServerURL Public URL to your parse server with http:// or https://.\n * @property {Any} push Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications\n * @property {String} readOnlyMasterKey Read-only key, which has the same capabilities as MasterKey without writes\n * @property {String} restAPIKey Key for REST calls\n * @property {Boolean} revokeSessionOnPasswordReset When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n * @property {Boolean} scheduledPush Configuration for push scheduling, defaults to false.\n * @property {Number} schemaCacheTTL The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.\n * @property {Function} serverCloseComplete Callback when server has closed\n * @property {Function} serverStartComplete Callback when server has started\n * @property {String} serverURL URL to your parse server with http:// or https://.\n * @property {Number} sessionLength Session duration, in seconds, defaults to 1 year\n * @property {Boolean} silent Disables console output\n * @property {Boolean} startLiveQueryServer Starts the liveQuery server\n * @property {String[]} userSensitiveFields Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields\n * @property {Boolean} verbose Set the logging to verbose\n * @property {Boolean} verifyUserEmails Enable (or disable) user email validation, defaults to false\n * @property {String} webhookKey Key sent with outgoing webhook calls\n */\n\n/**\n * @interface CustomPagesOptions\n * @property {String} choosePassword choose password page path\n * @property {String} invalidLink invalid link page path\n * @property {String} invalidVerificationLink invalid verification link page path\n * @property {String} linkSendFail verification link send fail page path\n * @property {String} linkSendSuccess verification link send success page path\n * @property {String} parseFrameURL for masking user-facing pages\n * @property {String} passwordResetSuccess password reset success page path\n * @property {String} verifyEmailSuccess verify email success page path\n */\n\n/**\n * @interface LiveQueryOptions\n * @property {String[]} classNames parse-server's LiveQuery classNames\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface LiveQueryServerOptions\n * @property {String} appId This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\n * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).\n * @property {Any} keyPairs A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\n * @property {String} logLevel This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.\n * @property {String} masterKey This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\n * @property {Number} port The port to run the LiveQuery server, defaults to 1337.\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {String} serverURL This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.\n * @property {Number} websocketTimeout Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface IdempotencyOptions\n * @property {String[]} paths An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n * @property {Number} ttl The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n */\n", "import { AnalyticsAdapter } from '../Adapters/Analytics/AnalyticsAdapter';\nimport { FilesAdapter } from '../Adapters/Files/FilesAdapter';\nimport { LoggerAdapter } from '../Adapters/Logger/LoggerAdapter';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport { CacheAdapter } from '../Adapters/Cache/CacheAdapter';\nimport { MailAdapter } from '../Adapters/Email/MailAdapter';\nimport { PubSubAdapter } from '../Adapters/PubSub/PubSubAdapter';\nimport { WSSAdapter } from '../Adapters/WebSocketServer/WSSAdapter';\n\n// @flow\ntype Adapter<T> = string | any | T;\ntype NumberOrBoolean = number | boolean;\ntype NumberOrString = number | string;\ntype ProtectedFields = any;\n\nexport interface ParseServerOptions {\n  /* Your Parse Application ID\n  :ENV: PARSE_SERVER_APPLICATION_ID */\n  appId: string;\n  /* Your Parse Master Key */\n  masterKey: string;\n  /* URL to your parse server with http:// or https://.\n  :ENV: PARSE_SERVER_URL */\n  serverURL: string;\n  /* Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n  :DEFAULT: [] */\n  masterKeyIps: ?(string[]);\n  /* Sets the app name */\n  appName: ?string;\n  /* Add headers to Access-Control-Allow-Headers */\n  allowHeaders: ?(string[]);\n  /* Sets the origin to Access-Control-Allow-Origin */\n  allowOrigin: ?string;\n  /* Adapter module for the analytics */\n  analyticsAdapter: ?Adapter<AnalyticsAdapter>;\n  /* Adapter module for the files sub-system */\n  filesAdapter: ?Adapter<FilesAdapter>;\n  /* Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications */\n  push: ?any;\n  /* Configuration for push scheduling, defaults to false.\n  :DEFAULT: false */\n  scheduledPush: ?boolean;\n  /* Adapter module for the logging sub-system */\n  loggerAdapter: ?Adapter<LoggerAdapter>;\n  /* Log as structured JSON objects\n  :ENV: JSON_LOGS */\n  jsonLogs: ?boolean;\n  /* Folder for the logs (defaults to './logs'); set to null to disable file based logging\n  :ENV: PARSE_SERVER_LOGS_FOLDER\n  :DEFAULT: ./logs */\n  logsFolder: ?string;\n  /* Set the logging to verbose\n  :ENV: VERBOSE */\n  verbose: ?boolean;\n  /* Sets the level for logs */\n  logLevel: ?string;\n  /* Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null) */\n  maxLogFiles: ?NumberOrString;\n  /* Disables console output\n  :ENV: SILENT */\n  silent: ?boolean;\n  /* The full URI to your database. Supported databases are mongodb or postgres.\n  :DEFAULT: mongodb://localhost:27017/parse */\n  databaseURI: string;\n  /* Options to pass to the mongodb client */\n  databaseOptions: ?any;\n  /* Adapter module for the database */\n  databaseAdapter: ?Adapter<StorageAdapter>;\n  /* Full path to your cloud code main.js */\n  cloud: ?string;\n  /* A collection prefix for the classes\n  :DEFAULT: '' */\n  collectionPrefix: ?string;\n  /* Key for iOS, MacOS, tvOS clients */\n  clientKey: ?string;\n  /* Key for the Javascript SDK */\n  javascriptKey: ?string;\n  /* Key for Unity and .Net SDK */\n  dotNetKey: ?string;\n  /* Key for REST calls\n  :ENV: PARSE_SERVER_REST_API_KEY */\n  restAPIKey: ?string;\n  /* Read-only key, which has the same capabilities as MasterKey without writes */\n  readOnlyMasterKey: ?string;\n  /* Key sent with outgoing webhook calls */\n  webhookKey: ?string;\n  /* Key for your files */\n  fileKey: ?string;\n  /* Enable (or disable) the addition of a unique hash to the file names\n  :ENV: PARSE_SERVER_PRESERVE_FILE_NAME\n  :DEFAULT: false */\n  preserveFileName: ?boolean;\n  /* Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields */\n  userSensitiveFields: ?(string[]);\n  /* Protected fields that should be treated with extra security when fetching details.\n  :DEFAULT: {\"_User\": {\"*\": [\"email\"]}} */\n  protectedFields: ?ProtectedFields;\n  /* Enable (or disable) anonymous users, defaults to true\n  :ENV: PARSE_SERVER_ENABLE_ANON_USERS\n  :DEFAULT: true */\n  enableAnonymousUsers: ?boolean;\n  /* Enable (or disable) client class creation, defaults to true\n  :ENV: PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION\n  :DEFAULT: true */\n  allowClientClassCreation: ?boolean;\n  /* Enable (or disable) custom objectId\n  :ENV: PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID\n  :DEFAULT: false */\n  allowCustomObjectId: ?boolean;\n  /* Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n  :ENV: PARSE_SERVER_AUTH_PROVIDERS */\n  auth: ?any;\n  /* Max file size for uploads, defaults to 20mb\n  :DEFAULT: 20mb */\n  maxUploadSize: ?string;\n  /* Enable (or disable) user email validation, defaults to false\n  :DEFAULT: false */\n  verifyUserEmails: ?boolean;\n  /* Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false\n  :DEFAULT: false */\n  preventLoginWithUnverifiedEmail: ?boolean;\n  /* Email verification token validity duration, in seconds */\n  emailVerifyTokenValidityDuration: ?number;\n  /* account lockout policy for failed login attempts */\n  accountLockout: ?any;\n  /* Password policy for enforcing password related rules */\n  passwordPolicy: ?any;\n  /* Adapter module for the cache */\n  cacheAdapter: ?Adapter<CacheAdapter>;\n  /* Adapter module for email sending */\n  emailAdapter: ?Adapter<MailAdapter>;\n  /* Public URL to your parse server with http:// or https://.\n  :ENV: PARSE_PUBLIC_SERVER_URL */\n  publicServerURL: ?string;\n  /* custom pages for password validation and reset\n  :DEFAULT: {} */\n  customPages: ?CustomPagesOptions;\n  /* parse-server's LiveQuery configuration object */\n  liveQuery: ?LiveQueryOptions;\n  /* Session duration, in seconds, defaults to 1 year\n  :DEFAULT: 31536000 */\n  sessionLength: ?number;\n  /* Max value for limit option on queries, defaults to unlimited */\n  maxLimit: ?number;\n  /* Sets wether we should expire the inactive sessions, defaults to true\n  :DEFAULT: true */\n  expireInactiveSessions: ?boolean;\n  /* When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n  :DEFAULT: true */\n  revokeSessionOnPasswordReset: ?boolean;\n  /* The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.\n  :DEFAULT: 5000 */\n  schemaCacheTTL: ?number;\n  /* Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n  :DEFAULT: 5000 */\n  cacheTTL: ?number;\n  /* Sets the maximum size for the in memory cache, defaults to 10000\n  :DEFAULT: 10000 */\n  cacheMaxSize: ?number;\n  /* Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS\n  :DEFAULT: false */\n  directAccess: ?boolean;\n  /* Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.\n  :DEFAULT: false */\n  enableSingleSchemaCache: ?boolean;\n  /* Enables the default express error handler for all errors\n  :DEFAULT: false */\n  enableExpressErrorHandler: ?boolean;\n  /* Sets the number of characters in generated object id's, default 10\n  :DEFAULT: 10 */\n  objectIdSize: ?number;\n  /* The port to run the ParseServer, defaults to 1337.\n  :ENV: PORT\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* The host to serve ParseServer on, defaults to 0.0.0.0\n  :DEFAULT: 0.0.0.0 */\n  host: ?string;\n  /* Mount path for the server, defaults to /parse\n  :DEFAULT: /parse */\n  mountPath: ?string;\n  /* Run with cluster, optionally set the number of processes default to os.cpus().length */\n  cluster: ?NumberOrBoolean;\n  /* middleware for express server, can be string or function */\n  middleware: ?((() => void) | string);\n  /* Starts the liveQuery server */\n  startLiveQueryServer: ?boolean;\n  /* Live query server configuration options (will start the liveQuery server) */\n  liveQueryServerOptions: ?LiveQueryServerOptions;\n  /* Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS\n  :DEFAULT: false */\n  idempotencyOptions: ?IdempotencyOptions;\n  /* Full path to your GraphQL custom schema.graphql file */\n  graphQLSchema: ?string;\n  /* Mounts the GraphQL endpoint\n  :ENV: PARSE_SERVER_MOUNT_GRAPHQL\n  :DEFAULT: false */\n  mountGraphQL: ?boolean;\n  /* Mount path for the GraphQL endpoint, defaults to /graphql\n  :ENV: PARSE_SERVER_GRAPHQL_PATH\n  :DEFAULT: /graphql */\n  graphQLPath: ?string;\n  /* Mounts the GraphQL Playground - never use this option in production\n  :ENV: PARSE_SERVER_MOUNT_PLAYGROUND\n  :DEFAULT: false */\n  mountPlayground: ?boolean;\n  /* Mount path for the GraphQL Playground, defaults to /playground\n  :ENV: PARSE_SERVER_PLAYGROUND_PATH\n  :DEFAULT: /playground */\n  playgroundPath: ?string;\n  /* Callback when server has started */\n  serverStartComplete: ?(error: ?Error) => void;\n  /* Callback when server has closed */\n  serverCloseComplete: ?() => void;\n}\n\nexport interface CustomPagesOptions {\n  /* invalid link page path */\n  invalidLink: ?string;\n  /* verify email success page path */\n  verifyEmailSuccess: ?string;\n  /* invalid verification link page path */\n  invalidVerificationLink: ?string;\n  /* verification link send success page path */\n  linkSendSuccess: ?string;\n  /* verification link send fail page path */\n  linkSendFail: ?string;\n  /* choose password page path */\n  choosePassword: ?string;\n  /* password reset success page path */\n  passwordResetSuccess: ?string;\n  /* for masking user-facing pages */\n  parseFrameURL: ?string;\n}\n\nexport interface LiveQueryOptions {\n  /* parse-server's LiveQuery classNames\n  :ENV: PARSE_SERVER_LIVEQUERY_CLASSNAMES */\n  classNames: ?(string[]);\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface LiveQueryServerOptions {\n  /* This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.*/\n  appId: ?string;\n  /* This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.*/\n  masterKey: ?string;\n  /* This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.*/\n  serverURL: ?string;\n  /* A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.*/\n  keyPairs: ?any;\n  /* Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).*/\n  websocketTimeout: ?number;\n  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).*/\n  cacheTimeout: ?number;\n  /* This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.*/\n  logLevel: ?string;\n  /* The port to run the LiveQuery server, defaults to 1337.\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface IdempotencyOptions {\n  /* An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n  :DEFAULT: [] */\n  paths: ?(string[]);\n  /* The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n  :DEFAULT: 300 */\n  ttl: ?number;\n}\n", "// ParseServer - open-source compatible API Server for Parse apps\n\nvar batch = require('./batch'),\n  bodyParser = require('body-parser'),\n  express = require('express'),\n  middlewares = require('./middlewares'),\n  Parse = require('parse/node').Parse,\n  { parse } = require('graphql'),\n  path = require('path'),\n  fs = require('fs');\n\nimport { ParseServerOptions, LiveQueryServerOptions } from './Options';\nimport defaults from './defaults';\nimport * as logging from './logger';\nimport Config from './Config';\nimport PromiseRouter from './PromiseRouter';\nimport requiredParameter from './requiredParameter';\nimport { AnalyticsRouter } from './Routers/AnalyticsRouter';\nimport { ClassesRouter } from './Routers/ClassesRouter';\nimport { FeaturesRouter } from './Routers/FeaturesRouter';\nimport { FilesRouter } from './Routers/FilesRouter';\nimport { FunctionsRouter } from './Routers/FunctionsRouter';\nimport { GlobalConfigRouter } from './Routers/GlobalConfigRouter';\nimport { GraphQLRouter } from './Routers/GraphQLRouter';\nimport { HooksRouter } from './Routers/HooksRouter';\nimport { IAPValidationRouter } from './Routers/IAPValidationRouter';\nimport { InstallationsRouter } from './Routers/InstallationsRouter';\nimport { LogsRouter } from './Routers/LogsRouter';\nimport { ParseLiveQueryServer } from './LiveQuery/ParseLiveQueryServer';\nimport { PublicAPIRouter } from './Routers/PublicAPIRouter';\nimport { PushRouter } from './Routers/PushRouter';\nimport { CloudCodeRouter } from './Routers/CloudCodeRouter';\nimport { RolesRouter } from './Routers/RolesRouter';\nimport { SchemasRouter } from './Routers/SchemasRouter';\nimport { SessionsRouter } from './Routers/SessionsRouter';\nimport { UsersRouter } from './Routers/UsersRouter';\nimport { PurgeRouter } from './Routers/PurgeRouter';\nimport { AudiencesRouter } from './Routers/AudiencesRouter';\nimport { AggregateRouter } from './Routers/AggregateRouter';\nimport { ParseServerRESTController } from './ParseServerRESTController';\nimport * as controllers from './Controllers';\nimport { ParseGraphQLServer } from './GraphQL/ParseGraphQLServer';\n\n// Mutate the Parse object to add the Cloud Code handlers\naddParseCloud();\n\n// ParseServer works like a constructor of an express app.\n// https://parseplatform.org/parse-server/api/master/ParseServerOptions.html\nclass ParseServer {\n  /**\n   * @constructor\n   * @param {ParseServerOptions} options the parse server initialization options\n   */\n  constructor(options: ParseServerOptions) {\n    injectDefaults(options);\n    const {\n      appId = requiredParameter('You must provide an appId!'),\n      masterKey = requiredParameter('You must provide a masterKey!'),\n      cloud,\n      javascriptKey,\n      serverURL = requiredParameter('You must provide a serverURL!'),\n      serverStartComplete,\n    } = options;\n    // Initialize the node client SDK automatically\n    Parse.initialize(appId, javascriptKey || 'unused', masterKey);\n    Parse.serverURL = serverURL;\n\n    const allControllers = controllers.getControllers(options);\n\n    const {\n      loggerController,\n      databaseController,\n      hooksController,\n    } = allControllers;\n    this.config = Config.put(Object.assign({}, options, allControllers));\n\n    logging.setLogger(loggerController);\n    const dbInitPromise = databaseController.performInitialization();\n    const hooksLoadPromise = hooksController.load();\n\n    // Note: Tests will start to fail if any validation happens after this is called.\n    Promise.all([dbInitPromise, hooksLoadPromise])\n      .then(() => {\n        if (serverStartComplete) {\n          serverStartComplete();\n        }\n      })\n      .catch(error => {\n        if (serverStartComplete) {\n          serverStartComplete(error);\n        } else {\n          console.error(error);\n          process.exit(1);\n        }\n      });\n\n    if (cloud) {\n      addParseCloud();\n      if (typeof cloud === 'function') {\n        cloud(Parse);\n      } else if (typeof cloud === 'string') {\n        require(path.resolve(process.cwd(), cloud));\n      } else {\n        throw \"argument 'cloud' must either be a string or a function\";\n      }\n    }\n  }\n\n  get app() {\n    if (!this._app) {\n      this._app = ParseServer.app(this.config);\n    }\n    return this._app;\n  }\n\n  handleShutdown() {\n    const promises = [];\n    const { adapter: databaseAdapter } = this.config.databaseController;\n    if (\n      databaseAdapter &&\n      typeof databaseAdapter.handleShutdown === 'function'\n    ) {\n      promises.push(databaseAdapter.handleShutdown());\n    }\n    const { adapter: fileAdapter } = this.config.filesController;\n    if (fileAdapter && typeof fileAdapter.handleShutdown === 'function') {\n      promises.push(fileAdapter.handleShutdown());\n    }\n    const { adapter: cacheAdapter } = this.config.cacheController;\n    if (cacheAdapter && typeof cacheAdapter.handleShutdown === 'function') {\n      promises.push(cacheAdapter.handleShutdown());\n    }\n    return (promises.length > 0\n      ? Promise.all(promises)\n      : Promise.resolve()\n    ).then(() => {\n      if (this.config.serverCloseComplete) {\n        this.config.serverCloseComplete();\n      }\n    });\n  }\n\n  /**\n   * @static\n   * Create an express app for the parse server\n   * @param {Object} options let you specify the maxUploadSize when creating the express app  */\n  static app({ maxUploadSize = '20mb', appId, directAccess }) {\n    // This app serves the Parse API directly.\n    // It's the equivalent of https://api.parse.com/1 in the hosted Parse API.\n    var api = express();\n    //api.use(\"/apps\", express.static(__dirname + \"/public\"));\n    api.use(middlewares.allowCrossDomain(appId));\n    // File handling needs to be before default middlewares are applied\n    api.use(\n      '/',\n      new FilesRouter().expressRouter({\n        maxUploadSize: maxUploadSize,\n      })\n    );\n\n    api.use('/health', function (req, res) {\n      res.json({\n        status: 'ok',\n      });\n    });\n\n    api.use(\n      '/',\n      bodyParser.urlencoded({ extended: false }),\n      new PublicAPIRouter().expressRouter()\n    );\n\n    api.use(bodyParser.json({ type: '*/*', limit: maxUploadSize }));\n    api.use(middlewares.allowMethodOverride);\n    api.use(middlewares.handleParseHeaders);\n\n    const appRouter = ParseServer.promiseRouter({ appId });\n    api.use(appRouter.expressRouter());\n\n    api.use(middlewares.handleParseErrors);\n\n    // run the following when not testing\n    if (!process.env.TESTING) {\n      //This causes tests to spew some useless warnings, so disable in test\n      /* istanbul ignore next */\n      process.on('uncaughtException', err => {\n        if (err.code === 'EADDRINUSE') {\n          // user-friendly message for this common error\n          process.stderr.write(\n            `Unable to listen on port ${err.port}. The port is already in use.`\n          );\n          process.exit(0);\n        } else {\n          throw err;\n        }\n      });\n      // verify the server url after a 'mount' event is received\n      /* istanbul ignore next */\n      api.on('mount', function () {\n        ParseServer.verifyServerUrl();\n      });\n    }\n    if (\n      process.env.PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS === '1' ||\n      directAccess\n    ) {\n      Parse.CoreManager.setRESTController(\n        ParseServerRESTController(appId, appRouter)\n      );\n    }\n    return api;\n  }\n\n  static promiseRouter({ appId }) {\n    const routers = [\n      new ClassesRouter(),\n      new UsersRouter(),\n      new SessionsRouter(),\n      new RolesRouter(),\n      new AnalyticsRouter(),\n      new InstallationsRouter(),\n      new FunctionsRouter(),\n      new SchemasRouter(),\n      new PushRouter(),\n      new LogsRouter(),\n      new IAPValidationRouter(),\n      new FeaturesRouter(),\n      new GlobalConfigRouter(),\n      new GraphQLRouter(),\n      new PurgeRouter(),\n      new HooksRouter(),\n      new CloudCodeRouter(),\n      new AudiencesRouter(),\n      new AggregateRouter(),\n    ];\n\n    const routes = routers.reduce((memo, router) => {\n      return memo.concat(router.routes);\n    }, []);\n\n    const appRouter = new PromiseRouter(routes, appId);\n\n    batch.mountOnto(appRouter);\n    return appRouter;\n  }\n\n  /**\n   * starts the parse server's express app\n   * @param {ParseServerOptions} options to use to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  start(options: ParseServerOptions, callback: ?() => void) {\n    const app = express();\n    if (options.middleware) {\n      let middleware;\n      if (typeof options.middleware == 'string') {\n        middleware = require(path.resolve(process.cwd(), options.middleware));\n      } else {\n        middleware = options.middleware; // use as-is let express fail\n      }\n      app.use(middleware);\n    }\n\n    app.use(options.mountPath, this.app);\n\n    if (options.mountGraphQL === true || options.mountPlayground === true) {\n      let graphQLCustomTypeDefs = undefined;\n      if (typeof options.graphQLSchema === 'string') {\n        graphQLCustomTypeDefs = parse(\n          fs.readFileSync(options.graphQLSchema, 'utf8')\n        );\n      } else if (\n        typeof options.graphQLSchema === 'object' ||\n        typeof options.graphQLSchema === 'function'\n      ) {\n        graphQLCustomTypeDefs = options.graphQLSchema;\n      }\n\n      const parseGraphQLServer = new ParseGraphQLServer(this, {\n        graphQLPath: options.graphQLPath,\n        playgroundPath: options.playgroundPath,\n        graphQLCustomTypeDefs,\n      });\n\n      if (options.mountGraphQL) {\n        parseGraphQLServer.applyGraphQL(app);\n      }\n\n      if (options.mountPlayground) {\n        parseGraphQLServer.applyPlayground(app);\n      }\n    }\n\n    const server = app.listen(options.port, options.host, callback);\n    this.server = server;\n\n    if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n      this.liveQueryServer = ParseServer.createLiveQueryServer(\n        server,\n        options.liveQueryServerOptions\n      );\n    }\n    /* istanbul ignore next */\n    if (!process.env.TESTING) {\n      configureListeners(this);\n    }\n    this.expressApp = app;\n    return this;\n  }\n\n  /**\n   * Creates a new ParseServer and starts it.\n   * @param {ParseServerOptions} options used to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  static start(options: ParseServerOptions, callback: ?() => void) {\n    const parseServer = new ParseServer(options);\n    return parseServer.start(options, callback);\n  }\n\n  /**\n   * Helper method to create a liveQuery server\n   * @static\n   * @param {Server} httpServer an optional http server to pass\n   * @param {LiveQueryServerOptions} config options fot he liveQueryServer\n   * @returns {ParseLiveQueryServer} the live query server instance\n   */\n  static createLiveQueryServer(httpServer, config: LiveQueryServerOptions) {\n    if (!httpServer || (config && config.port)) {\n      var app = express();\n      httpServer = require('http').createServer(app);\n      httpServer.listen(config.port);\n    }\n    return new ParseLiveQueryServer(httpServer, config);\n  }\n\n  static verifyServerUrl(callback) {\n    // perform a health check on the serverURL value\n    if (Parse.serverURL) {\n      const request = require('./request');\n      request({ url: Parse.serverURL.replace(/\\/$/, '') + '/health' })\n        .catch(response => response)\n        .then(response => {\n          const json = response.data || null;\n          if (\n            response.status !== 200 ||\n            !json ||\n            (json && json.status !== 'ok')\n          ) {\n            /* eslint-disable no-console */\n            console.warn(\n              `\\nWARNING, Unable to connect to '${Parse.serverURL}'.` +\n                ` Cloud code and push notifications may be unavailable!\\n`\n            );\n            /* eslint-enable no-console */\n            if (callback) {\n              callback(false);\n            }\n          } else {\n            if (callback) {\n              callback(true);\n            }\n          }\n        });\n    }\n  }\n}\n\nfunction addParseCloud() {\n  const ParseCloud = require('./cloud-code/Parse.Cloud');\n  Object.assign(Parse.Cloud, ParseCloud);\n  global.Parse = Parse;\n}\n\nfunction injectDefaults(options: ParseServerOptions) {\n  Object.keys(defaults).forEach(key => {\n    if (!Object.prototype.hasOwnProperty.call(options, key)) {\n      options[key] = defaults[key];\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(options, 'serverURL')) {\n    options.serverURL = `http://localhost:${options.port}${options.mountPath}`;\n  }\n\n  // Reserved Characters\n  if (options.appId) {\n    const regex = /[!#$%'()*+&/:;=?@[\\]{}^,|<>]/g;\n    if (options.appId.match(regex)) {\n      console.warn(\n        `\\nWARNING, appId that contains special characters can cause issues while using with urls.\\n`\n      );\n    }\n  }\n\n  // Backwards compatibility\n  if (options.userSensitiveFields) {\n    /* eslint-disable no-console */\n    !process.env.TESTING &&\n      console.warn(\n        `\\nDEPRECATED: userSensitiveFields has been replaced by protectedFields allowing the ability to protect fields in all classes with CLP. \\n`\n      );\n    /* eslint-enable no-console */\n\n    const userSensitiveFields = Array.from(\n      new Set([\n        ...(defaults.userSensitiveFields || []),\n        ...(options.userSensitiveFields || []),\n      ])\n    );\n\n    // If the options.protectedFields is unset,\n    // it'll be assigned the default above.\n    // Here, protect against the case where protectedFields\n    // is set, but doesn't have _User.\n    if (!('_User' in options.protectedFields)) {\n      options.protectedFields = Object.assign(\n        { _User: [] },\n        options.protectedFields\n      );\n    }\n\n    options.protectedFields['_User']['*'] = Array.from(\n      new Set([\n        ...(options.protectedFields['_User']['*'] || []),\n        ...userSensitiveFields,\n      ])\n    );\n  }\n\n  // Merge protectedFields options with defaults.\n  Object.keys(defaults.protectedFields).forEach(c => {\n    const cur = options.protectedFields[c];\n    if (!cur) {\n      options.protectedFields[c] = defaults.protectedFields[c];\n    } else {\n      Object.keys(defaults.protectedFields[c]).forEach(r => {\n        const unq = new Set([\n          ...(options.protectedFields[c][r] || []),\n          ...defaults.protectedFields[c][r],\n        ]);\n        options.protectedFields[c][r] = Array.from(unq);\n      });\n    }\n  });\n\n  options.masterKeyIps = Array.from(\n    new Set(\n      options.masterKeyIps.concat(defaults.masterKeyIps, options.masterKeyIps)\n    )\n  );\n}\n\n// Those can't be tested as it requires a subprocess\n/* istanbul ignore next */\nfunction configureListeners(parseServer) {\n  const server = parseServer.server;\n  const sockets = {};\n  /* Currently, express doesn't shut down immediately after receiving SIGINT/SIGTERM if it has client connections that haven't timed out. (This is a known issue with node - https://github.com/nodejs/node/issues/2642)\n    This function, along with `destroyAliveConnections()`, intend to fix this behavior such that parse server will close all open connections and initiate the shutdown process as soon as it receives a SIGINT/SIGTERM signal. */\n  server.on('connection', socket => {\n    const socketId = socket.remoteAddress + ':' + socket.remotePort;\n    sockets[socketId] = socket;\n    socket.on('close', () => {\n      delete sockets[socketId];\n    });\n  });\n\n  const destroyAliveConnections = function () {\n    for (const socketId in sockets) {\n      try {\n        sockets[socketId].destroy();\n      } catch (e) {\n        /* */\n      }\n    }\n  };\n\n  const handleShutdown = function () {\n    process.stdout.write('Termination signal received. Shutting down.');\n    destroyAliveConnections();\n    server.close();\n    parseServer.handleShutdown();\n  };\n  process.on('SIGTERM', handleShutdown);\n  process.on('SIGINT', handleShutdown);\n}\n\nexport default ParseServer;\n"], "fixing_code": ["'use strict';\nconst UserController = require('../lib/Controllers/UserController')\n  .UserController;\nconst Config = require('../lib/Config');\ndescribe('ParseLiveQuery', function () {\n  it('can subscribe to query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can return different object in afterEvent', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const object = new Parse.Object('Yolo');\n      req.object = object;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.className).toBe('Yolo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('can handle afterEvent throw', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      throw 'Throw error from LQ afterEvent.';\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', e => {\n      expect(e).toBe('Throw error from LQ afterEvent.');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent sendEvent to false', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      const original = req.original;\n\n      setTimeout(() => {\n        done();\n      }, 2000);\n\n      if (current.get('foo') != original.get('foo')) {\n        req.sendEvent = false;\n      }\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('Delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle async afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const parent = new TestObject();\n    const child = new TestObject();\n    child.set('bar', 'foo');\n    await Parse.Object.saveAll([parent, child]);\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async req => {\n      const current = req.object;\n      const pointer = current.get('child');\n      await pointer.fetch();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', parent.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('child')).toBeDefined();\n      expect(object.get('child').get('bar')).toBe('foo');\n      done();\n    });\n    parent.set('child', child);\n    await parent.save();\n  });\n\n  it('can handle beforeConnect / beforeSubscribe hooks', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe('TestObject', req => {\n      expect(req.op).toBe('subscribe');\n      expect(req.requestId).toBe(1);\n      expect(req.query).toBeDefined();\n      expect(req.user).toBeUndefined();\n    });\n\n    Parse.Cloud.beforeConnect(req => {\n      expect(req.event).toBe('connect');\n      expect(req.clients).toBe(0);\n      expect(req.subscriptions).toBe(0);\n      expect(req.useMasterKey).toBe(false);\n      expect(req.installationId).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.sessionToken).toBeUndefined();\n      expect(req.client).toBeDefined();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle beforeConnect error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {\n      throw new Error('You shall not pass!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not pass!');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can handle beforeSubscribe error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      throw new Error('You shall not subscribe!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n      done();\n    });\n  });\n\n  it('can handle mutate beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.equalTo('yolo', 'abc');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', () => {\n      fail();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n    setTimeout(async () => {\n      done();\n    }, 1000);\n  });\n\n  it('can return a new beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'yolo');\n      request.query = query;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('yolo');\n      done();\n    });\n    const object = new TestObject();\n    object.set({ foo: 'yolo' });\n    await object.save();\n  });\n\n  it('can handle select beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.select('yolo');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBeUndefined();\n      expect(object.get('yolo')).toBe('abc');\n      done();\n    });\n    object.set({ foo: 'bar', yolo: 'abc' });\n    await object.save();\n  });\n\n  it('handle invalid websocket payload length', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    // All control frames must have a payload length of 125 bytes or less.\n    // https://tools.ietf.org/html/rfc6455#section-5.5\n    //\n    // 0x89 = 10001001 = ping\n    // 0xfe = 11111110 = first bit is masking the remaining 7 are 1111110 or 126 the payload length\n    // https://tools.ietf.org/html/rfc6455#section-5.2\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.socket._socket.write(Buffer.from([0x89, 0xfe]));\n\n    subscription.on('update', async object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    // Wait for Websocket timeout to reconnect\n    setTimeout(async () => {\n      object.set({ foo: 'bar' });\n      await object.save();\n    }, 1000);\n  });\n\n  it('should execute live query update on email validation', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {},\n    };\n\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['_User'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n      appName: 'liveQueryEmailValidation',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 20, // 0.5 second\n      publicServerURL: 'http://localhost:8378/1',\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('password', 'asdf');\n      user.set('email', 'asdf@example.com');\n      user.set('username', 'zxcv');\n      user\n        .signUp()\n        .then(() => {\n          const config = Config.get('test');\n          return config.database.find('_User', {\n            username: 'zxcv',\n          });\n        })\n        .then(async results => {\n          const foundUser = results[0];\n          const query = new Parse.Query('_User');\n          query.equalTo('objectId', foundUser.objectId);\n          const subscription = await query.subscribe();\n\n          subscription.on('update', async object => {\n            expect(object).toBeDefined();\n            expect(object.get('emailVerified')).toBe(true);\n            done();\n          });\n\n          const userController = new UserController(emailAdapter, 'test', {\n            verifyUserEmails: true,\n          });\n          userController.verifyEmail(\n            foundUser.username,\n            foundUser._email_verify_token\n          );\n        });\n    });\n  });\n\n  it('should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      liveQueryServerOptions: {\n        cacheTimeout: 100,\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      cacheTTL: 100,\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const obj1 = new Parse.Object('TestObject');\n    const obj1ACL = new Parse.ACL();\n    obj1ACL.setPublicReadAccess(false);\n    obj1ACL.setReadAccess(user, true);\n    obj1.setACL(obj1ACL);\n    const obj2 = new Parse.Object('TestObject');\n    const obj2ACL = new Parse.ACL();\n    obj2ACL.setPublicReadAccess(false);\n    obj2ACL.setReadAccess(user, true);\n    obj2.setACL(obj2ACL);\n    const query = new Parse.Query('TestObject');\n    const subscription = await query.subscribe();\n    subscription.on('create', obj => {\n      if (obj.id !== obj1.id) {\n        done.fail('should not fire');\n      }\n    });\n    await obj1.save();\n    await Parse.User.logOut();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    await obj2.save();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    done();\n  });\n\n  afterEach(async function (done) {\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n    // Wait for live query client to disconnect\n    setTimeout(() => {\n      done();\n    }, 1000);\n  });\n});\n", "import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  runLiveQueryEventHandlers,\n  maybeRunConnectTrigger,\n  maybeRunSubscribeTrigger,\n  maybeRunAfterEventTrigger,\n} from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n    this.config = config;\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(parseServerConfig);\n\n    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: config.cacheTimeout,\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe messsage %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error(\n          'Get message %s from unknown channel %j',\n          message,\n          channel\n        );\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose(\n      'ClassName: %j | ObjectId: %s',\n      className,\n      deletedParseObject.id\n    );\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(\n        deletedParseObject,\n        subscription\n      );\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(\n        subscription.clientRequestIds\n      )) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          this._matchesCLP(\n            classLevelPermissions,\n            message.currentParseObject,\n            client,\n            requestId,\n            op\n          )\n            .then(() => {\n              // Check ACL\n              return this._matchesACL(acl, client, requestId);\n            })\n            .then(isMatched => {\n              if (!isMatched) {\n                return null;\n              }\n              res = {\n                event: 'Delete',\n                sessionToken: client.sessionToken,\n                object: deletedParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(() => {\n              if (!res.sendEvent) {\n                return;\n              }\n              if (res.object && typeof res.object.toJSON === 'function') {\n                deletedParseObject = res.object.toJSON();\n                deletedParseObject.className = className;\n              }\n              client.pushDelete(requestId, deletedParseObject);\n            })\n            .catch(error => {\n              Client.pushError(\n                client.parseWebSocket,\n                error.code || 141,\n                error.message || error,\n                false,\n                requestId\n              );\n              logger.error(\n                `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                  JSON.stringify(error)\n              );\n            });\n        }\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose(\n      'ClassName: %s | ObjectId: %s',\n      className,\n      currentParseObject.id\n    );\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(\n        subscription.clientRequestIds\n      )) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(\n              originalACL,\n              client,\n              requestId\n            );\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(\n              currentACL,\n              client,\n              requestId\n            );\n          }\n          const op = this._getCLPOperation(subscription.query);\n          this._matchesCLP(\n            classLevelPermissions,\n            message.currentParseObject,\n            client,\n            requestId,\n            op\n          )\n            .then(() => {\n              return Promise.all([\n                originalACLCheckingPromise,\n                currentACLCheckingPromise,\n              ]);\n            })\n            .then(([isOriginalMatched, isCurrentMatched]) => {\n              logger.verbose(\n                'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n                originalParseObject,\n                currentParseObject,\n                isOriginalSubscriptionMatched,\n                isCurrentSubscriptionMatched,\n                isOriginalMatched,\n                isCurrentMatched,\n                subscription.hash\n              );\n              // Decide event type\n              let type;\n              if (isOriginalMatched && isCurrentMatched) {\n                type = 'Update';\n              } else if (isOriginalMatched && !isCurrentMatched) {\n                type = 'Leave';\n              } else if (!isOriginalMatched && isCurrentMatched) {\n                if (originalParseObject) {\n                  type = 'Enter';\n                } else {\n                  type = 'Create';\n                }\n              } else {\n                return null;\n              }\n              message.event = type;\n              res = {\n                event: type,\n                sessionToken: client.sessionToken,\n                object: currentParseObject,\n                original: originalParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(\n              () => {\n                if (!res.sendEvent) {\n                  return;\n                }\n                if (res.object && typeof res.object.toJSON === 'function') {\n                  currentParseObject = res.object.toJSON();\n                  currentParseObject.className =\n                    res.object.className || className;\n                }\n\n                if (res.original && typeof res.original.toJSON === 'function') {\n                  originalParseObject = res.original.toJSON();\n                  originalParseObject.className =\n                    res.original.className || className;\n                }\n                const functionName = 'push' + message.event;\n                if (client[functionName]) {\n                  client[functionName](\n                    requestId,\n                    currentParseObject,\n                    originalParseObject\n                  );\n                }\n              },\n              error => {\n                Client.pushError(\n                  client.parseWebSocket,\n                  error.code || 141,\n                  error.message || error,\n                  false,\n                  requestId\n                );\n                logger.error(\n                  `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                    JSON.stringify(error)\n                );\n              }\n            );\n        }\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(\n        client.subscriptionInfos\n      )) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(\n          subscription.className\n        );\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(\n    sessionToken: ?string\n  ): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          result.error = error;\n          this.authCache.set(\n            sessionToken,\n            Promise.resolve(result),\n            this.config.cacheTimeout\n          );\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(\n        subscriptionInfo.sessionToken\n      );\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key =>\n          key.startsWith('role:')\n        );\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async _matchesACL(\n    acl: any,\n    client: any,\n    requestId: number\n  ): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      await maybeRunConnectTrigger('beforeConnect', req);\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (error) {\n      Client.pushError(\n        parseWebsocket,\n        error.code || 141,\n        error.message || error,\n        false\n      );\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (\n      !validKeyPairs ||\n      validKeyPairs.size == 0 ||\n      !validKeyPairs.has('masterKey')\n    ) {\n      return false;\n    }\n    if (\n      !request ||\n      !Object.prototype.hasOwnProperty.call(request, 'masterKey')\n    ) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    try {\n      await maybeRunSubscribeTrigger('beforeSubscribe', className, request);\n\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(\n          className,\n          request.query.where,\n          subscriptionHash\n        );\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(\n        parseWebsocket.clientId,\n        request.requestId\n      );\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      Client.pushError(\n        parseWebsocket,\n        e.code || 141,\n        e.message || e,\n        false,\n        request.requestId\n      );\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(e)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(\n    parseWebsocket: any,\n    request: any,\n    notifyClient: boolean = true\n  ): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n", "/*\n**** GENERATED CODE ****\nThis code has been generated by resources/buildConfigDefinitions.js\nDo not edit manually, but update Options/index.js\n*/\nvar parsers = require('./parsers');\n\nmodule.exports.ParseServerOptions = {\n  accountLockout: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT',\n    help: 'account lockout policy for failed login attempts',\n    action: parsers.objectParser,\n  },\n  allowClientClassCreation: {\n    env: 'PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION',\n    help: 'Enable (or disable) client class creation, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  allowCustomObjectId: {\n    env: 'PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID',\n    help: 'Enable (or disable) custom objectId',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  allowHeaders: {\n    env: 'PARSE_SERVER_ALLOW_HEADERS',\n    help: 'Add headers to Access-Control-Allow-Headers',\n    action: parsers.arrayParser,\n  },\n  allowOrigin: {\n    env: 'PARSE_SERVER_ALLOW_ORIGIN',\n    help: 'Sets the origin to Access-Control-Allow-Origin',\n  },\n  analyticsAdapter: {\n    env: 'PARSE_SERVER_ANALYTICS_ADAPTER',\n    help: 'Adapter module for the analytics',\n    action: parsers.moduleOrObjectParser,\n  },\n  appId: {\n    env: 'PARSE_SERVER_APPLICATION_ID',\n    help: 'Your Parse Application ID',\n    required: true,\n  },\n  appName: {\n    env: 'PARSE_SERVER_APP_NAME',\n    help: 'Sets the app name',\n  },\n  auth: {\n    env: 'PARSE_SERVER_AUTH_PROVIDERS',\n    help:\n      'Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication',\n    action: parsers.objectParser,\n  },\n  cacheAdapter: {\n    env: 'PARSE_SERVER_CACHE_ADAPTER',\n    help: 'Adapter module for the cache',\n    action: parsers.moduleOrObjectParser,\n  },\n  cacheMaxSize: {\n    env: 'PARSE_SERVER_CACHE_MAX_SIZE',\n    help: 'Sets the maximum size for the in memory cache, defaults to 10000',\n    action: parsers.numberParser('cacheMaxSize'),\n    default: 10000,\n  },\n  cacheTTL: {\n    env: 'PARSE_SERVER_CACHE_TTL',\n    help:\n      'Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)',\n    action: parsers.numberParser('cacheTTL'),\n    default: 5000,\n  },\n  clientKey: {\n    env: 'PARSE_SERVER_CLIENT_KEY',\n    help: 'Key for iOS, MacOS, tvOS clients',\n  },\n  cloud: {\n    env: 'PARSE_SERVER_CLOUD',\n    help: 'Full path to your cloud code main.js',\n  },\n  cluster: {\n    env: 'PARSE_SERVER_CLUSTER',\n    help:\n      'Run with cluster, optionally set the number of processes default to os.cpus().length',\n    action: parsers.numberOrBooleanParser,\n  },\n  collectionPrefix: {\n    env: 'PARSE_SERVER_COLLECTION_PREFIX',\n    help: 'A collection prefix for the classes',\n    default: '',\n  },\n  customPages: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES',\n    help: 'custom pages for password validation and reset',\n    action: parsers.objectParser,\n    default: {},\n  },\n  databaseAdapter: {\n    env: 'PARSE_SERVER_DATABASE_ADAPTER',\n    help: 'Adapter module for the database',\n    action: parsers.moduleOrObjectParser,\n  },\n  databaseOptions: {\n    env: 'PARSE_SERVER_DATABASE_OPTIONS',\n    help: 'Options to pass to the mongodb client',\n    action: parsers.objectParser,\n  },\n  databaseURI: {\n    env: 'PARSE_SERVER_DATABASE_URI',\n    help:\n      'The full URI to your database. Supported databases are mongodb or postgres.',\n    required: true,\n    default: 'mongodb://localhost:27017/parse',\n  },\n  directAccess: {\n    env: 'PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS',\n    help:\n      'Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  dotNetKey: {\n    env: 'PARSE_SERVER_DOT_NET_KEY',\n    help: 'Key for Unity and .Net SDK',\n  },\n  emailAdapter: {\n    env: 'PARSE_SERVER_EMAIL_ADAPTER',\n    help: 'Adapter module for email sending',\n    action: parsers.moduleOrObjectParser,\n  },\n  emailVerifyTokenValidityDuration: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_VALIDITY_DURATION',\n    help: 'Email verification token validity duration, in seconds',\n    action: parsers.numberParser('emailVerifyTokenValidityDuration'),\n  },\n  enableAnonymousUsers: {\n    env: 'PARSE_SERVER_ENABLE_ANON_USERS',\n    help: 'Enable (or disable) anonymous users, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableExpressErrorHandler: {\n    env: 'PARSE_SERVER_ENABLE_EXPRESS_ERROR_HANDLER',\n    help: 'Enables the default express error handler for all errors',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableSingleSchemaCache: {\n    env: 'PARSE_SERVER_ENABLE_SINGLE_SCHEMA_CACHE',\n    help:\n      'Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  expireInactiveSessions: {\n    env: 'PARSE_SERVER_EXPIRE_INACTIVE_SESSIONS',\n    help:\n      'Sets wether we should expire the inactive sessions, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  fileKey: {\n    env: 'PARSE_SERVER_FILE_KEY',\n    help: 'Key for your files',\n  },\n  filesAdapter: {\n    env: 'PARSE_SERVER_FILES_ADAPTER',\n    help: 'Adapter module for the files sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  graphQLPath: {\n    env: 'PARSE_SERVER_GRAPHQL_PATH',\n    help: 'Mount path for the GraphQL endpoint, defaults to /graphql',\n    default: '/graphql',\n  },\n  graphQLSchema: {\n    env: 'PARSE_SERVER_GRAPH_QLSCHEMA',\n    help: 'Full path to your GraphQL custom schema.graphql file',\n  },\n  host: {\n    env: 'PARSE_SERVER_HOST',\n    help: 'The host to serve ParseServer on, defaults to 0.0.0.0',\n    default: '0.0.0.0',\n  },\n  idempotencyOptions: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS',\n    help:\n      'Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  javascriptKey: {\n    env: 'PARSE_SERVER_JAVASCRIPT_KEY',\n    help: 'Key for the Javascript SDK',\n  },\n  jsonLogs: {\n    env: 'JSON_LOGS',\n    help: 'Log as structured JSON objects',\n    action: parsers.booleanParser,\n  },\n  liveQuery: {\n    env: 'PARSE_SERVER_LIVE_QUERY',\n    help: \"parse-server's LiveQuery configuration object\",\n    action: parsers.objectParser,\n  },\n  liveQueryServerOptions: {\n    env: 'PARSE_SERVER_LIVE_QUERY_SERVER_OPTIONS',\n    help:\n      'Live query server configuration options (will start the liveQuery server)',\n    action: parsers.objectParser,\n  },\n  loggerAdapter: {\n    env: 'PARSE_SERVER_LOGGER_ADAPTER',\n    help: 'Adapter module for the logging sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  logLevel: {\n    env: 'PARSE_SERVER_LOG_LEVEL',\n    help: 'Sets the level for logs',\n  },\n  logsFolder: {\n    env: 'PARSE_SERVER_LOGS_FOLDER',\n    help:\n      \"Folder for the logs (defaults to './logs'); set to null to disable file based logging\",\n    default: './logs',\n  },\n  masterKey: {\n    env: 'PARSE_SERVER_MASTER_KEY',\n    help: 'Your Parse Master Key',\n    required: true,\n  },\n  masterKeyIps: {\n    env: 'PARSE_SERVER_MASTER_KEY_IPS',\n    help:\n      'Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  maxLimit: {\n    env: 'PARSE_SERVER_MAX_LIMIT',\n    help: 'Max value for limit option on queries, defaults to unlimited',\n    action: parsers.numberParser('maxLimit'),\n  },\n  maxLogFiles: {\n    env: 'PARSE_SERVER_MAX_LOG_FILES',\n    help:\n      \"Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\",\n    action: parsers.objectParser,\n  },\n  maxUploadSize: {\n    env: 'PARSE_SERVER_MAX_UPLOAD_SIZE',\n    help: 'Max file size for uploads, defaults to 20mb',\n    default: '20mb',\n  },\n  middleware: {\n    env: 'PARSE_SERVER_MIDDLEWARE',\n    help: 'middleware for express server, can be string or function',\n  },\n  mountGraphQL: {\n    env: 'PARSE_SERVER_MOUNT_GRAPHQL',\n    help: 'Mounts the GraphQL endpoint',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  mountPath: {\n    env: 'PARSE_SERVER_MOUNT_PATH',\n    help: 'Mount path for the server, defaults to /parse',\n    default: '/parse',\n  },\n  mountPlayground: {\n    env: 'PARSE_SERVER_MOUNT_PLAYGROUND',\n    help: 'Mounts the GraphQL Playground - never use this option in production',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  objectIdSize: {\n    env: 'PARSE_SERVER_OBJECT_ID_SIZE',\n    help: \"Sets the number of characters in generated object id's, default 10\",\n    action: parsers.numberParser('objectIdSize'),\n    default: 10,\n  },\n  passwordPolicy: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY',\n    help: 'Password policy for enforcing password related rules',\n    action: parsers.objectParser,\n  },\n  playgroundPath: {\n    env: 'PARSE_SERVER_PLAYGROUND_PATH',\n    help: 'Mount path for the GraphQL Playground, defaults to /playground',\n    default: '/playground',\n  },\n  port: {\n    env: 'PORT',\n    help: 'The port to run the ParseServer, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  preserveFileName: {\n    env: 'PARSE_SERVER_PRESERVE_FILE_NAME',\n    help: 'Enable (or disable) the addition of a unique hash to the file names',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  preventLoginWithUnverifiedEmail: {\n    env: 'PARSE_SERVER_PREVENT_LOGIN_WITH_UNVERIFIED_EMAIL',\n    help:\n      'Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  protectedFields: {\n    env: 'PARSE_SERVER_PROTECTED_FIELDS',\n    help:\n      'Protected fields that should be treated with extra security when fetching details.',\n    action: parsers.objectParser,\n    default: {\n      _User: {\n        '*': ['email'],\n      },\n    },\n  },\n  publicServerURL: {\n    env: 'PARSE_PUBLIC_SERVER_URL',\n    help: 'Public URL to your parse server with http:// or https://.',\n  },\n  push: {\n    env: 'PARSE_SERVER_PUSH',\n    help:\n      'Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications',\n    action: parsers.objectParser,\n  },\n  readOnlyMasterKey: {\n    env: 'PARSE_SERVER_READ_ONLY_MASTER_KEY',\n    help:\n      'Read-only key, which has the same capabilities as MasterKey without writes',\n  },\n  restAPIKey: {\n    env: 'PARSE_SERVER_REST_API_KEY',\n    help: 'Key for REST calls',\n  },\n  revokeSessionOnPasswordReset: {\n    env: 'PARSE_SERVER_REVOKE_SESSION_ON_PASSWORD_RESET',\n    help:\n      \"When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\",\n    action: parsers.booleanParser,\n    default: true,\n  },\n  scheduledPush: {\n    env: 'PARSE_SERVER_SCHEDULED_PUSH',\n    help: 'Configuration for push scheduling, defaults to false.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  schemaCacheTTL: {\n    env: 'PARSE_SERVER_SCHEMA_CACHE_TTL',\n    help:\n      'The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.',\n    action: parsers.numberParser('schemaCacheTTL'),\n    default: 5000,\n  },\n  serverCloseComplete: {\n    env: 'PARSE_SERVER_SERVER_CLOSE_COMPLETE',\n    help: 'Callback when server has closed',\n  },\n  serverStartComplete: {\n    env: 'PARSE_SERVER_SERVER_START_COMPLETE',\n    help: 'Callback when server has started',\n  },\n  serverURL: {\n    env: 'PARSE_SERVER_URL',\n    help: 'URL to your parse server with http:// or https://.',\n    required: true,\n  },\n  sessionLength: {\n    env: 'PARSE_SERVER_SESSION_LENGTH',\n    help: 'Session duration, in seconds, defaults to 1 year',\n    action: parsers.numberParser('sessionLength'),\n    default: 31536000,\n  },\n  silent: {\n    env: 'SILENT',\n    help: 'Disables console output',\n    action: parsers.booleanParser,\n  },\n  startLiveQueryServer: {\n    env: 'PARSE_SERVER_START_LIVE_QUERY_SERVER',\n    help: 'Starts the liveQuery server',\n    action: parsers.booleanParser,\n  },\n  userSensitiveFields: {\n    env: 'PARSE_SERVER_USER_SENSITIVE_FIELDS',\n    help:\n      'Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields',\n    action: parsers.arrayParser,\n  },\n  verbose: {\n    env: 'VERBOSE',\n    help: 'Set the logging to verbose',\n    action: parsers.booleanParser,\n  },\n  verifyUserEmails: {\n    env: 'PARSE_SERVER_VERIFY_USER_EMAILS',\n    help: 'Enable (or disable) user email validation, defaults to false',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  webhookKey: {\n    env: 'PARSE_SERVER_WEBHOOK_KEY',\n    help: 'Key sent with outgoing webhook calls',\n  },\n};\nmodule.exports.CustomPagesOptions = {\n  choosePassword: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_CHOOSE_PASSWORD',\n    help: 'choose password page path',\n  },\n  invalidLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_LINK',\n    help: 'invalid link page path',\n  },\n  invalidVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_VERIFICATION_LINK',\n    help: 'invalid verification link page path',\n  },\n  linkSendFail: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_FAIL',\n    help: 'verification link send fail page path',\n  },\n  linkSendSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_SUCCESS',\n    help: 'verification link send success page path',\n  },\n  parseFrameURL: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PARSE_FRAME_URL',\n    help: 'for masking user-facing pages',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PASSWORD_RESET_SUCCESS',\n    help: 'password reset success page path',\n  },\n  verifyEmailSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_VERIFY_EMAIL_SUCCESS',\n    help: 'verify email success page path',\n  },\n};\nmodule.exports.LiveQueryOptions = {\n  classNames: {\n    env: 'PARSE_SERVER_LIVEQUERY_CLASSNAMES',\n    help: \"parse-server's LiveQuery classNames\",\n    action: parsers.arrayParser,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  wssAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.LiveQueryServerOptions = {\n  appId: {\n    env: 'PARSE_LIVE_QUERY_SERVER_APP_ID',\n    help:\n      'This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.',\n  },\n  cacheTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_CACHE_TIMEOUT',\n    help:\n      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\",\n    action: parsers.numberParser('cacheTimeout'),\n  },\n  keyPairs: {\n    env: 'PARSE_LIVE_QUERY_SERVER_KEY_PAIRS',\n    help:\n      'A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.',\n    action: parsers.objectParser,\n  },\n  logLevel: {\n    env: 'PARSE_LIVE_QUERY_SERVER_LOG_LEVEL',\n    help:\n      'This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.',\n  },\n  masterKey: {\n    env: 'PARSE_LIVE_QUERY_SERVER_MASTER_KEY',\n    help:\n      'This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.',\n  },\n  port: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PORT',\n    help: 'The port to run the LiveQuery server, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  serverURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_SERVER_URL',\n    help:\n      'This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.',\n  },\n  websocketTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WEBSOCKET_TIMEOUT',\n    help:\n      'Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).',\n    action: parsers.numberParser('websocketTimeout'),\n  },\n  wssAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.IdempotencyOptions = {\n  paths: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_PATHS',\n    help:\n      'An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  ttl: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_TTL',\n    help:\n      'The duration in seconds after which a request record is discarded from the database, defaults to 300s.',\n    action: parsers.numberParser('ttl'),\n    default: 300,\n  },\n};\n", "/**\n * @interface ParseServerOptions\n * @property {Any} accountLockout account lockout policy for failed login attempts\n * @property {Boolean} allowClientClassCreation Enable (or disable) client class creation, defaults to true\n * @property {Boolean} allowCustomObjectId Enable (or disable) custom objectId\n * @property {String[]} allowHeaders Add headers to Access-Control-Allow-Headers\n * @property {String} allowOrigin Sets the origin to Access-Control-Allow-Origin\n * @property {Adapter<AnalyticsAdapter>} analyticsAdapter Adapter module for the analytics\n * @property {String} appId Your Parse Application ID\n * @property {String} appName Sets the app name\n * @property {Any} auth Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n * @property {Adapter<CacheAdapter>} cacheAdapter Adapter module for the cache\n * @property {Number} cacheMaxSize Sets the maximum size for the in memory cache, defaults to 10000\n * @property {Number} cacheTTL Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n * @property {String} clientKey Key for iOS, MacOS, tvOS clients\n * @property {String} cloud Full path to your cloud code main.js\n * @property {Number|Boolean} cluster Run with cluster, optionally set the number of processes default to os.cpus().length\n * @property {String} collectionPrefix A collection prefix for the classes\n * @property {CustomPagesOptions} customPages custom pages for password validation and reset\n * @property {Adapter<StorageAdapter>} databaseAdapter Adapter module for the database\n * @property {Any} databaseOptions Options to pass to the mongodb client\n * @property {String} databaseURI The full URI to your database. Supported databases are mongodb or postgres.\n * @property {Boolean} directAccess Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} dotNetKey Key for Unity and .Net SDK\n * @property {Adapter<MailAdapter>} emailAdapter Adapter module for email sending\n * @property {Number} emailVerifyTokenValidityDuration Email verification token validity duration, in seconds\n * @property {Boolean} enableAnonymousUsers Enable (or disable) anonymous users, defaults to true\n * @property {Boolean} enableExpressErrorHandler Enables the default express error handler for all errors\n * @property {Boolean} enableSingleSchemaCache Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.\n * @property {Boolean} expireInactiveSessions Sets wether we should expire the inactive sessions, defaults to true\n * @property {String} fileKey Key for your files\n * @property {Adapter<FilesAdapter>} filesAdapter Adapter module for the files sub-system\n * @property {String} graphQLPath Mount path for the GraphQL endpoint, defaults to /graphql\n * @property {String} graphQLSchema Full path to your GraphQL custom schema.graphql file\n * @property {String} host The host to serve ParseServer on, defaults to 0.0.0.0\n * @property {IdempotencyOptions} idempotencyOptions Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} javascriptKey Key for the Javascript SDK\n * @property {Boolean} jsonLogs Log as structured JSON objects\n * @property {LiveQueryOptions} liveQuery parse-server's LiveQuery configuration object\n * @property {LiveQueryServerOptions} liveQueryServerOptions Live query server configuration options (will start the liveQuery server)\n * @property {Adapter<LoggerAdapter>} loggerAdapter Adapter module for the logging sub-system\n * @property {String} logLevel Sets the level for logs\n * @property {String} logsFolder Folder for the logs (defaults to './logs'); set to null to disable file based logging\n * @property {String} masterKey Your Parse Master Key\n * @property {String[]} masterKeyIps Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n * @property {Number} maxLimit Max value for limit option on queries, defaults to unlimited\n * @property {Number|String} maxLogFiles Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\n * @property {String} maxUploadSize Max file size for uploads, defaults to 20mb\n * @property {Union} middleware middleware for express server, can be string or function\n * @property {Boolean} mountGraphQL Mounts the GraphQL endpoint\n * @property {String} mountPath Mount path for the server, defaults to /parse\n * @property {Boolean} mountPlayground Mounts the GraphQL Playground - never use this option in production\n * @property {Number} objectIdSize Sets the number of characters in generated object id's, default 10\n * @property {Any} passwordPolicy Password policy for enforcing password related rules\n * @property {String} playgroundPath Mount path for the GraphQL Playground, defaults to /playground\n * @property {Number} port The port to run the ParseServer, defaults to 1337.\n * @property {Boolean} preserveFileName Enable (or disable) the addition of a unique hash to the file names\n * @property {Boolean} preventLoginWithUnverifiedEmail Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false\n * @property {ProtectedFields} protectedFields Protected fields that should be treated with extra security when fetching details.\n * @property {String} publicServerURL Public URL to your parse server with http:// or https://.\n * @property {Any} push Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications\n * @property {String} readOnlyMasterKey Read-only key, which has the same capabilities as MasterKey without writes\n * @property {String} restAPIKey Key for REST calls\n * @property {Boolean} revokeSessionOnPasswordReset When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n * @property {Boolean} scheduledPush Configuration for push scheduling, defaults to false.\n * @property {Number} schemaCacheTTL The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.\n * @property {Function} serverCloseComplete Callback when server has closed\n * @property {Function} serverStartComplete Callback when server has started\n * @property {String} serverURL URL to your parse server with http:// or https://.\n * @property {Number} sessionLength Session duration, in seconds, defaults to 1 year\n * @property {Boolean} silent Disables console output\n * @property {Boolean} startLiveQueryServer Starts the liveQuery server\n * @property {String[]} userSensitiveFields Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields\n * @property {Boolean} verbose Set the logging to verbose\n * @property {Boolean} verifyUserEmails Enable (or disable) user email validation, defaults to false\n * @property {String} webhookKey Key sent with outgoing webhook calls\n */\n\n/**\n * @interface CustomPagesOptions\n * @property {String} choosePassword choose password page path\n * @property {String} invalidLink invalid link page path\n * @property {String} invalidVerificationLink invalid verification link page path\n * @property {String} linkSendFail verification link send fail page path\n * @property {String} linkSendSuccess verification link send success page path\n * @property {String} parseFrameURL for masking user-facing pages\n * @property {String} passwordResetSuccess password reset success page path\n * @property {String} verifyEmailSuccess verify email success page path\n */\n\n/**\n * @interface LiveQueryOptions\n * @property {String[]} classNames parse-server's LiveQuery classNames\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface LiveQueryServerOptions\n * @property {String} appId This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\n * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\n * @property {Any} keyPairs A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\n * @property {String} logLevel This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.\n * @property {String} masterKey This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\n * @property {Number} port The port to run the LiveQuery server, defaults to 1337.\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {String} serverURL This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.\n * @property {Number} websocketTimeout Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface IdempotencyOptions\n * @property {String[]} paths An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n * @property {Number} ttl The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n */\n", "import { AnalyticsAdapter } from '../Adapters/Analytics/AnalyticsAdapter';\nimport { FilesAdapter } from '../Adapters/Files/FilesAdapter';\nimport { LoggerAdapter } from '../Adapters/Logger/LoggerAdapter';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport { CacheAdapter } from '../Adapters/Cache/CacheAdapter';\nimport { MailAdapter } from '../Adapters/Email/MailAdapter';\nimport { PubSubAdapter } from '../Adapters/PubSub/PubSubAdapter';\nimport { WSSAdapter } from '../Adapters/WebSocketServer/WSSAdapter';\n\n// @flow\ntype Adapter<T> = string | any | T;\ntype NumberOrBoolean = number | boolean;\ntype NumberOrString = number | string;\ntype ProtectedFields = any;\n\nexport interface ParseServerOptions {\n  /* Your Parse Application ID\n  :ENV: PARSE_SERVER_APPLICATION_ID */\n  appId: string;\n  /* Your Parse Master Key */\n  masterKey: string;\n  /* URL to your parse server with http:// or https://.\n  :ENV: PARSE_SERVER_URL */\n  serverURL: string;\n  /* Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n  :DEFAULT: [] */\n  masterKeyIps: ?(string[]);\n  /* Sets the app name */\n  appName: ?string;\n  /* Add headers to Access-Control-Allow-Headers */\n  allowHeaders: ?(string[]);\n  /* Sets the origin to Access-Control-Allow-Origin */\n  allowOrigin: ?string;\n  /* Adapter module for the analytics */\n  analyticsAdapter: ?Adapter<AnalyticsAdapter>;\n  /* Adapter module for the files sub-system */\n  filesAdapter: ?Adapter<FilesAdapter>;\n  /* Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications */\n  push: ?any;\n  /* Configuration for push scheduling, defaults to false.\n  :DEFAULT: false */\n  scheduledPush: ?boolean;\n  /* Adapter module for the logging sub-system */\n  loggerAdapter: ?Adapter<LoggerAdapter>;\n  /* Log as structured JSON objects\n  :ENV: JSON_LOGS */\n  jsonLogs: ?boolean;\n  /* Folder for the logs (defaults to './logs'); set to null to disable file based logging\n  :ENV: PARSE_SERVER_LOGS_FOLDER\n  :DEFAULT: ./logs */\n  logsFolder: ?string;\n  /* Set the logging to verbose\n  :ENV: VERBOSE */\n  verbose: ?boolean;\n  /* Sets the level for logs */\n  logLevel: ?string;\n  /* Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null) */\n  maxLogFiles: ?NumberOrString;\n  /* Disables console output\n  :ENV: SILENT */\n  silent: ?boolean;\n  /* The full URI to your database. Supported databases are mongodb or postgres.\n  :DEFAULT: mongodb://localhost:27017/parse */\n  databaseURI: string;\n  /* Options to pass to the mongodb client */\n  databaseOptions: ?any;\n  /* Adapter module for the database */\n  databaseAdapter: ?Adapter<StorageAdapter>;\n  /* Full path to your cloud code main.js */\n  cloud: ?string;\n  /* A collection prefix for the classes\n  :DEFAULT: '' */\n  collectionPrefix: ?string;\n  /* Key for iOS, MacOS, tvOS clients */\n  clientKey: ?string;\n  /* Key for the Javascript SDK */\n  javascriptKey: ?string;\n  /* Key for Unity and .Net SDK */\n  dotNetKey: ?string;\n  /* Key for REST calls\n  :ENV: PARSE_SERVER_REST_API_KEY */\n  restAPIKey: ?string;\n  /* Read-only key, which has the same capabilities as MasterKey without writes */\n  readOnlyMasterKey: ?string;\n  /* Key sent with outgoing webhook calls */\n  webhookKey: ?string;\n  /* Key for your files */\n  fileKey: ?string;\n  /* Enable (or disable) the addition of a unique hash to the file names\n  :ENV: PARSE_SERVER_PRESERVE_FILE_NAME\n  :DEFAULT: false */\n  preserveFileName: ?boolean;\n  /* Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields */\n  userSensitiveFields: ?(string[]);\n  /* Protected fields that should be treated with extra security when fetching details.\n  :DEFAULT: {\"_User\": {\"*\": [\"email\"]}} */\n  protectedFields: ?ProtectedFields;\n  /* Enable (or disable) anonymous users, defaults to true\n  :ENV: PARSE_SERVER_ENABLE_ANON_USERS\n  :DEFAULT: true */\n  enableAnonymousUsers: ?boolean;\n  /* Enable (or disable) client class creation, defaults to true\n  :ENV: PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION\n  :DEFAULT: true */\n  allowClientClassCreation: ?boolean;\n  /* Enable (or disable) custom objectId\n  :ENV: PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID\n  :DEFAULT: false */\n  allowCustomObjectId: ?boolean;\n  /* Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n  :ENV: PARSE_SERVER_AUTH_PROVIDERS */\n  auth: ?any;\n  /* Max file size for uploads, defaults to 20mb\n  :DEFAULT: 20mb */\n  maxUploadSize: ?string;\n  /* Enable (or disable) user email validation, defaults to false\n  :DEFAULT: false */\n  verifyUserEmails: ?boolean;\n  /* Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false\n  :DEFAULT: false */\n  preventLoginWithUnverifiedEmail: ?boolean;\n  /* Email verification token validity duration, in seconds */\n  emailVerifyTokenValidityDuration: ?number;\n  /* account lockout policy for failed login attempts */\n  accountLockout: ?any;\n  /* Password policy for enforcing password related rules */\n  passwordPolicy: ?any;\n  /* Adapter module for the cache */\n  cacheAdapter: ?Adapter<CacheAdapter>;\n  /* Adapter module for email sending */\n  emailAdapter: ?Adapter<MailAdapter>;\n  /* Public URL to your parse server with http:// or https://.\n  :ENV: PARSE_PUBLIC_SERVER_URL */\n  publicServerURL: ?string;\n  /* custom pages for password validation and reset\n  :DEFAULT: {} */\n  customPages: ?CustomPagesOptions;\n  /* parse-server's LiveQuery configuration object */\n  liveQuery: ?LiveQueryOptions;\n  /* Session duration, in seconds, defaults to 1 year\n  :DEFAULT: 31536000 */\n  sessionLength: ?number;\n  /* Max value for limit option on queries, defaults to unlimited */\n  maxLimit: ?number;\n  /* Sets wether we should expire the inactive sessions, defaults to true\n  :DEFAULT: true */\n  expireInactiveSessions: ?boolean;\n  /* When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n  :DEFAULT: true */\n  revokeSessionOnPasswordReset: ?boolean;\n  /* The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 5000; set 0 to disable.\n  :DEFAULT: 5000 */\n  schemaCacheTTL: ?number;\n  /* Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n  :DEFAULT: 5000 */\n  cacheTTL: ?number;\n  /* Sets the maximum size for the in memory cache, defaults to 10000\n  :DEFAULT: 10000 */\n  cacheMaxSize: ?number;\n  /* Replace HTTP Interface when using JS SDK in current node runtime, defaults to false. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS\n  :DEFAULT: false */\n  directAccess: ?boolean;\n  /* Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA, defaults to false, i.e. unique schema cache per request.\n  :DEFAULT: false */\n  enableSingleSchemaCache: ?boolean;\n  /* Enables the default express error handler for all errors\n  :DEFAULT: false */\n  enableExpressErrorHandler: ?boolean;\n  /* Sets the number of characters in generated object id's, default 10\n  :DEFAULT: 10 */\n  objectIdSize: ?number;\n  /* The port to run the ParseServer, defaults to 1337.\n  :ENV: PORT\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* The host to serve ParseServer on, defaults to 0.0.0.0\n  :DEFAULT: 0.0.0.0 */\n  host: ?string;\n  /* Mount path for the server, defaults to /parse\n  :DEFAULT: /parse */\n  mountPath: ?string;\n  /* Run with cluster, optionally set the number of processes default to os.cpus().length */\n  cluster: ?NumberOrBoolean;\n  /* middleware for express server, can be string or function */\n  middleware: ?((() => void) | string);\n  /* Starts the liveQuery server */\n  startLiveQueryServer: ?boolean;\n  /* Live query server configuration options (will start the liveQuery server) */\n  liveQueryServerOptions: ?LiveQueryServerOptions;\n  /* Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS\n  :DEFAULT: false */\n  idempotencyOptions: ?IdempotencyOptions;\n  /* Full path to your GraphQL custom schema.graphql file */\n  graphQLSchema: ?string;\n  /* Mounts the GraphQL endpoint\n  :ENV: PARSE_SERVER_MOUNT_GRAPHQL\n  :DEFAULT: false */\n  mountGraphQL: ?boolean;\n  /* Mount path for the GraphQL endpoint, defaults to /graphql\n  :ENV: PARSE_SERVER_GRAPHQL_PATH\n  :DEFAULT: /graphql */\n  graphQLPath: ?string;\n  /* Mounts the GraphQL Playground - never use this option in production\n  :ENV: PARSE_SERVER_MOUNT_PLAYGROUND\n  :DEFAULT: false */\n  mountPlayground: ?boolean;\n  /* Mount path for the GraphQL Playground, defaults to /playground\n  :ENV: PARSE_SERVER_PLAYGROUND_PATH\n  :DEFAULT: /playground */\n  playgroundPath: ?string;\n  /* Callback when server has started */\n  serverStartComplete: ?(error: ?Error) => void;\n  /* Callback when server has closed */\n  serverCloseComplete: ?() => void;\n}\n\nexport interface CustomPagesOptions {\n  /* invalid link page path */\n  invalidLink: ?string;\n  /* verify email success page path */\n  verifyEmailSuccess: ?string;\n  /* invalid verification link page path */\n  invalidVerificationLink: ?string;\n  /* verification link send success page path */\n  linkSendSuccess: ?string;\n  /* verification link send fail page path */\n  linkSendFail: ?string;\n  /* choose password page path */\n  choosePassword: ?string;\n  /* password reset success page path */\n  passwordResetSuccess: ?string;\n  /* for masking user-facing pages */\n  parseFrameURL: ?string;\n}\n\nexport interface LiveQueryOptions {\n  /* parse-server's LiveQuery classNames\n  :ENV: PARSE_SERVER_LIVEQUERY_CLASSNAMES */\n  classNames: ?(string[]);\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface LiveQueryServerOptions {\n  /* This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.*/\n  appId: ?string;\n  /* This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.*/\n  masterKey: ?string;\n  /* This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.*/\n  serverURL: ?string;\n  /* A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.*/\n  keyPairs: ?any;\n  /* Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).*/\n  websocketTimeout: ?number;\n  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).*/\n  cacheTimeout: ?number;\n  /* This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.*/\n  logLevel: ?string;\n  /* The port to run the LiveQuery server, defaults to 1337.\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface IdempotencyOptions {\n  /* An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n  :DEFAULT: [] */\n  paths: ?(string[]);\n  /* The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n  :DEFAULT: 300 */\n  ttl: ?number;\n}\n", "// ParseServer - open-source compatible API Server for Parse apps\n\nvar batch = require('./batch'),\n  bodyParser = require('body-parser'),\n  express = require('express'),\n  middlewares = require('./middlewares'),\n  Parse = require('parse/node').Parse,\n  { parse } = require('graphql'),\n  path = require('path'),\n  fs = require('fs');\n\nimport { ParseServerOptions, LiveQueryServerOptions } from './Options';\nimport defaults from './defaults';\nimport * as logging from './logger';\nimport Config from './Config';\nimport PromiseRouter from './PromiseRouter';\nimport requiredParameter from './requiredParameter';\nimport { AnalyticsRouter } from './Routers/AnalyticsRouter';\nimport { ClassesRouter } from './Routers/ClassesRouter';\nimport { FeaturesRouter } from './Routers/FeaturesRouter';\nimport { FilesRouter } from './Routers/FilesRouter';\nimport { FunctionsRouter } from './Routers/FunctionsRouter';\nimport { GlobalConfigRouter } from './Routers/GlobalConfigRouter';\nimport { GraphQLRouter } from './Routers/GraphQLRouter';\nimport { HooksRouter } from './Routers/HooksRouter';\nimport { IAPValidationRouter } from './Routers/IAPValidationRouter';\nimport { InstallationsRouter } from './Routers/InstallationsRouter';\nimport { LogsRouter } from './Routers/LogsRouter';\nimport { ParseLiveQueryServer } from './LiveQuery/ParseLiveQueryServer';\nimport { PublicAPIRouter } from './Routers/PublicAPIRouter';\nimport { PushRouter } from './Routers/PushRouter';\nimport { CloudCodeRouter } from './Routers/CloudCodeRouter';\nimport { RolesRouter } from './Routers/RolesRouter';\nimport { SchemasRouter } from './Routers/SchemasRouter';\nimport { SessionsRouter } from './Routers/SessionsRouter';\nimport { UsersRouter } from './Routers/UsersRouter';\nimport { PurgeRouter } from './Routers/PurgeRouter';\nimport { AudiencesRouter } from './Routers/AudiencesRouter';\nimport { AggregateRouter } from './Routers/AggregateRouter';\nimport { ParseServerRESTController } from './ParseServerRESTController';\nimport * as controllers from './Controllers';\nimport { ParseGraphQLServer } from './GraphQL/ParseGraphQLServer';\n\n// Mutate the Parse object to add the Cloud Code handlers\naddParseCloud();\n\n// ParseServer works like a constructor of an express app.\n// https://parseplatform.org/parse-server/api/master/ParseServerOptions.html\nclass ParseServer {\n  /**\n   * @constructor\n   * @param {ParseServerOptions} options the parse server initialization options\n   */\n  constructor(options: ParseServerOptions) {\n    injectDefaults(options);\n    const {\n      appId = requiredParameter('You must provide an appId!'),\n      masterKey = requiredParameter('You must provide a masterKey!'),\n      cloud,\n      javascriptKey,\n      serverURL = requiredParameter('You must provide a serverURL!'),\n      serverStartComplete,\n    } = options;\n    // Initialize the node client SDK automatically\n    Parse.initialize(appId, javascriptKey || 'unused', masterKey);\n    Parse.serverURL = serverURL;\n\n    const allControllers = controllers.getControllers(options);\n\n    const {\n      loggerController,\n      databaseController,\n      hooksController,\n    } = allControllers;\n    this.config = Config.put(Object.assign({}, options, allControllers));\n\n    logging.setLogger(loggerController);\n    const dbInitPromise = databaseController.performInitialization();\n    const hooksLoadPromise = hooksController.load();\n\n    // Note: Tests will start to fail if any validation happens after this is called.\n    Promise.all([dbInitPromise, hooksLoadPromise])\n      .then(() => {\n        if (serverStartComplete) {\n          serverStartComplete();\n        }\n      })\n      .catch(error => {\n        if (serverStartComplete) {\n          serverStartComplete(error);\n        } else {\n          console.error(error);\n          process.exit(1);\n        }\n      });\n\n    if (cloud) {\n      addParseCloud();\n      if (typeof cloud === 'function') {\n        cloud(Parse);\n      } else if (typeof cloud === 'string') {\n        require(path.resolve(process.cwd(), cloud));\n      } else {\n        throw \"argument 'cloud' must either be a string or a function\";\n      }\n    }\n  }\n\n  get app() {\n    if (!this._app) {\n      this._app = ParseServer.app(this.config);\n    }\n    return this._app;\n  }\n\n  handleShutdown() {\n    const promises = [];\n    const { adapter: databaseAdapter } = this.config.databaseController;\n    if (\n      databaseAdapter &&\n      typeof databaseAdapter.handleShutdown === 'function'\n    ) {\n      promises.push(databaseAdapter.handleShutdown());\n    }\n    const { adapter: fileAdapter } = this.config.filesController;\n    if (fileAdapter && typeof fileAdapter.handleShutdown === 'function') {\n      promises.push(fileAdapter.handleShutdown());\n    }\n    const { adapter: cacheAdapter } = this.config.cacheController;\n    if (cacheAdapter && typeof cacheAdapter.handleShutdown === 'function') {\n      promises.push(cacheAdapter.handleShutdown());\n    }\n    return (promises.length > 0\n      ? Promise.all(promises)\n      : Promise.resolve()\n    ).then(() => {\n      if (this.config.serverCloseComplete) {\n        this.config.serverCloseComplete();\n      }\n    });\n  }\n\n  /**\n   * @static\n   * Create an express app for the parse server\n   * @param {Object} options let you specify the maxUploadSize when creating the express app  */\n  static app({ maxUploadSize = '20mb', appId, directAccess }) {\n    // This app serves the Parse API directly.\n    // It's the equivalent of https://api.parse.com/1 in the hosted Parse API.\n    var api = express();\n    //api.use(\"/apps\", express.static(__dirname + \"/public\"));\n    api.use(middlewares.allowCrossDomain(appId));\n    // File handling needs to be before default middlewares are applied\n    api.use(\n      '/',\n      new FilesRouter().expressRouter({\n        maxUploadSize: maxUploadSize,\n      })\n    );\n\n    api.use('/health', function (req, res) {\n      res.json({\n        status: 'ok',\n      });\n    });\n\n    api.use(\n      '/',\n      bodyParser.urlencoded({ extended: false }),\n      new PublicAPIRouter().expressRouter()\n    );\n\n    api.use(bodyParser.json({ type: '*/*', limit: maxUploadSize }));\n    api.use(middlewares.allowMethodOverride);\n    api.use(middlewares.handleParseHeaders);\n\n    const appRouter = ParseServer.promiseRouter({ appId });\n    api.use(appRouter.expressRouter());\n\n    api.use(middlewares.handleParseErrors);\n\n    // run the following when not testing\n    if (!process.env.TESTING) {\n      //This causes tests to spew some useless warnings, so disable in test\n      /* istanbul ignore next */\n      process.on('uncaughtException', err => {\n        if (err.code === 'EADDRINUSE') {\n          // user-friendly message for this common error\n          process.stderr.write(\n            `Unable to listen on port ${err.port}. The port is already in use.`\n          );\n          process.exit(0);\n        } else {\n          throw err;\n        }\n      });\n      // verify the server url after a 'mount' event is received\n      /* istanbul ignore next */\n      api.on('mount', function () {\n        ParseServer.verifyServerUrl();\n      });\n    }\n    if (\n      process.env.PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS === '1' ||\n      directAccess\n    ) {\n      Parse.CoreManager.setRESTController(\n        ParseServerRESTController(appId, appRouter)\n      );\n    }\n    return api;\n  }\n\n  static promiseRouter({ appId }) {\n    const routers = [\n      new ClassesRouter(),\n      new UsersRouter(),\n      new SessionsRouter(),\n      new RolesRouter(),\n      new AnalyticsRouter(),\n      new InstallationsRouter(),\n      new FunctionsRouter(),\n      new SchemasRouter(),\n      new PushRouter(),\n      new LogsRouter(),\n      new IAPValidationRouter(),\n      new FeaturesRouter(),\n      new GlobalConfigRouter(),\n      new GraphQLRouter(),\n      new PurgeRouter(),\n      new HooksRouter(),\n      new CloudCodeRouter(),\n      new AudiencesRouter(),\n      new AggregateRouter(),\n    ];\n\n    const routes = routers.reduce((memo, router) => {\n      return memo.concat(router.routes);\n    }, []);\n\n    const appRouter = new PromiseRouter(routes, appId);\n\n    batch.mountOnto(appRouter);\n    return appRouter;\n  }\n\n  /**\n   * starts the parse server's express app\n   * @param {ParseServerOptions} options to use to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  start(options: ParseServerOptions, callback: ?() => void) {\n    const app = express();\n    if (options.middleware) {\n      let middleware;\n      if (typeof options.middleware == 'string') {\n        middleware = require(path.resolve(process.cwd(), options.middleware));\n      } else {\n        middleware = options.middleware; // use as-is let express fail\n      }\n      app.use(middleware);\n    }\n\n    app.use(options.mountPath, this.app);\n\n    if (options.mountGraphQL === true || options.mountPlayground === true) {\n      let graphQLCustomTypeDefs = undefined;\n      if (typeof options.graphQLSchema === 'string') {\n        graphQLCustomTypeDefs = parse(\n          fs.readFileSync(options.graphQLSchema, 'utf8')\n        );\n      } else if (\n        typeof options.graphQLSchema === 'object' ||\n        typeof options.graphQLSchema === 'function'\n      ) {\n        graphQLCustomTypeDefs = options.graphQLSchema;\n      }\n\n      const parseGraphQLServer = new ParseGraphQLServer(this, {\n        graphQLPath: options.graphQLPath,\n        playgroundPath: options.playgroundPath,\n        graphQLCustomTypeDefs,\n      });\n\n      if (options.mountGraphQL) {\n        parseGraphQLServer.applyGraphQL(app);\n      }\n\n      if (options.mountPlayground) {\n        parseGraphQLServer.applyPlayground(app);\n      }\n    }\n\n    const server = app.listen(options.port, options.host, callback);\n    this.server = server;\n\n    if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n      this.liveQueryServer = ParseServer.createLiveQueryServer(\n        server,\n        options.liveQueryServerOptions,\n        options\n      );\n    }\n    /* istanbul ignore next */\n    if (!process.env.TESTING) {\n      configureListeners(this);\n    }\n    this.expressApp = app;\n    return this;\n  }\n\n  /**\n   * Creates a new ParseServer and starts it.\n   * @param {ParseServerOptions} options used to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  static start(options: ParseServerOptions, callback: ?() => void) {\n    const parseServer = new ParseServer(options);\n    return parseServer.start(options, callback);\n  }\n\n  /**\n   * Helper method to create a liveQuery server\n   * @static\n   * @param {Server} httpServer an optional http server to pass\n   * @param {LiveQueryServerOptions} config options for the liveQueryServer\n   * @param {ParseServerOptions} options options for the ParseServer\n   * @returns {ParseLiveQueryServer} the live query server instance\n   */\n  static createLiveQueryServer(\n    httpServer,\n    config: LiveQueryServerOptions,\n    options: ParseServerOptions\n  ) {\n    if (!httpServer || (config && config.port)) {\n      var app = express();\n      httpServer = require('http').createServer(app);\n      httpServer.listen(config.port);\n    }\n    return new ParseLiveQueryServer(httpServer, config, options);\n  }\n\n  static verifyServerUrl(callback) {\n    // perform a health check on the serverURL value\n    if (Parse.serverURL) {\n      const request = require('./request');\n      request({ url: Parse.serverURL.replace(/\\/$/, '') + '/health' })\n        .catch(response => response)\n        .then(response => {\n          const json = response.data || null;\n          if (\n            response.status !== 200 ||\n            !json ||\n            (json && json.status !== 'ok')\n          ) {\n            /* eslint-disable no-console */\n            console.warn(\n              `\\nWARNING, Unable to connect to '${Parse.serverURL}'.` +\n                ` Cloud code and push notifications may be unavailable!\\n`\n            );\n            /* eslint-enable no-console */\n            if (callback) {\n              callback(false);\n            }\n          } else {\n            if (callback) {\n              callback(true);\n            }\n          }\n        });\n    }\n  }\n}\n\nfunction addParseCloud() {\n  const ParseCloud = require('./cloud-code/Parse.Cloud');\n  Object.assign(Parse.Cloud, ParseCloud);\n  global.Parse = Parse;\n}\n\nfunction injectDefaults(options: ParseServerOptions) {\n  Object.keys(defaults).forEach(key => {\n    if (!Object.prototype.hasOwnProperty.call(options, key)) {\n      options[key] = defaults[key];\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(options, 'serverURL')) {\n    options.serverURL = `http://localhost:${options.port}${options.mountPath}`;\n  }\n\n  // Reserved Characters\n  if (options.appId) {\n    const regex = /[!#$%'()*+&/:;=?@[\\]{}^,|<>]/g;\n    if (options.appId.match(regex)) {\n      console.warn(\n        `\\nWARNING, appId that contains special characters can cause issues while using with urls.\\n`\n      );\n    }\n  }\n\n  // Backwards compatibility\n  if (options.userSensitiveFields) {\n    /* eslint-disable no-console */\n    !process.env.TESTING &&\n      console.warn(\n        `\\nDEPRECATED: userSensitiveFields has been replaced by protectedFields allowing the ability to protect fields in all classes with CLP. \\n`\n      );\n    /* eslint-enable no-console */\n\n    const userSensitiveFields = Array.from(\n      new Set([\n        ...(defaults.userSensitiveFields || []),\n        ...(options.userSensitiveFields || []),\n      ])\n    );\n\n    // If the options.protectedFields is unset,\n    // it'll be assigned the default above.\n    // Here, protect against the case where protectedFields\n    // is set, but doesn't have _User.\n    if (!('_User' in options.protectedFields)) {\n      options.protectedFields = Object.assign(\n        { _User: [] },\n        options.protectedFields\n      );\n    }\n\n    options.protectedFields['_User']['*'] = Array.from(\n      new Set([\n        ...(options.protectedFields['_User']['*'] || []),\n        ...userSensitiveFields,\n      ])\n    );\n  }\n\n  // Merge protectedFields options with defaults.\n  Object.keys(defaults.protectedFields).forEach(c => {\n    const cur = options.protectedFields[c];\n    if (!cur) {\n      options.protectedFields[c] = defaults.protectedFields[c];\n    } else {\n      Object.keys(defaults.protectedFields[c]).forEach(r => {\n        const unq = new Set([\n          ...(options.protectedFields[c][r] || []),\n          ...defaults.protectedFields[c][r],\n        ]);\n        options.protectedFields[c][r] = Array.from(unq);\n      });\n    }\n  });\n\n  options.masterKeyIps = Array.from(\n    new Set(\n      options.masterKeyIps.concat(defaults.masterKeyIps, options.masterKeyIps)\n    )\n  );\n}\n\n// Those can't be tested as it requires a subprocess\n/* istanbul ignore next */\nfunction configureListeners(parseServer) {\n  const server = parseServer.server;\n  const sockets = {};\n  /* Currently, express doesn't shut down immediately after receiving SIGINT/SIGTERM if it has client connections that haven't timed out. (This is a known issue with node - https://github.com/nodejs/node/issues/2642)\n    This function, along with `destroyAliveConnections()`, intend to fix this behavior such that parse server will close all open connections and initiate the shutdown process as soon as it receives a SIGINT/SIGTERM signal. */\n  server.on('connection', socket => {\n    const socketId = socket.remoteAddress + ':' + socket.remotePort;\n    sockets[socketId] = socket;\n    socket.on('close', () => {\n      delete sockets[socketId];\n    });\n  });\n\n  const destroyAliveConnections = function () {\n    for (const socketId in sockets) {\n      try {\n        sockets[socketId].destroy();\n      } catch (e) {\n        /* */\n      }\n    }\n  };\n\n  const handleShutdown = function () {\n    process.stdout.write('Termination signal received. Shutting down.');\n    destroyAliveConnections();\n    server.close();\n    parseServer.handleShutdown();\n  };\n  process.on('SIGTERM', handleShutdown);\n  process.on('SIGINT', handleShutdown);\n}\n\nexport default ParseServer;\n"], "filenames": ["spec/ParseLiveQuery.spec.js", "src/LiveQuery/ParseLiveQueryServer.js", "src/Options/Definitions.js", "src/Options/docs.js", "src/Options/index.js", "src/ParseServer.js"], "buggy_code_start_loc": [786, 33, 481, 103, 263, 301], "buggy_code_end_loc": [786, 519, 482, 104, 264, 337], "fixing_code_start_loc": [787, 33, 481, 103, 263, 301], "fixing_code_end_loc": [829, 521, 482, 104, 264, 343], "type": "CWE-672", "message": "Parse Server (npm package parse-server) broadcasts events to all clients without checking if the session token is valid. This allows clients with expired sessions to still receive subscription objects. It is not possible to create subscription objects with invalid session tokens. The issue is not patched.", "other": {"cve": {"id": "CVE-2020-15270", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-22T22:15:12.063", "lastModified": "2020-10-30T15:02:46.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server (npm package parse-server) broadcasts events to all clients without checking if the session token is valid. This allows clients with expired sessions to still receive subscription objects. It is not possible to create subscription objects with invalid session tokens. The issue is not patched."}, {"lang": "es", "value": "El servidor de an\u00e1lisis (npm package parse-server) transmite eventos a todos los clientes sin comprobar si el testigo de sesi\u00f3n es v\u00e1lido. Esto permite a los clientes con sesiones caducadas seguir recibiendo objetos de suscripci\u00f3n. No es posible crear objetos de suscripci\u00f3n con testigos de sesi\u00f3n inv\u00e1lidos. El problema no est\u00e1 parcheado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-672"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "4.3.0", "matchCriteriaId": "A72BDBDC-5721-470F-8C38-51FEB236B3D4"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://npmjs.com/parse-server", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58"}}