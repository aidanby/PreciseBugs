{"buggy_code": ["@chapter Demuxers\n@c man begin DEMUXERS\n\nDemuxers are configured elements in FFmpeg that can read the\nmultimedia streams from a particular type of file.\n\nWhen you configure your FFmpeg build, all the supported demuxers\nare enabled by default. You can list all available ones using the\nconfigure option @code{--list-demuxers}.\n\nYou can disable all the demuxers using the configure option\n@code{--disable-demuxers}, and selectively enable a single demuxer with\nthe option @code{--enable-demuxer=@var{DEMUXER}}, or disable it\nwith the option @code{--disable-demuxer=@var{DEMUXER}}.\n\nThe option @code{-demuxers} of the ff* tools will display the list of\nenabled demuxers. Use @code{-formats} to view a combined list of\nenabled demuxers and muxers.\n\nThe description of some of the currently available demuxers follows.\n\n@section aa\n\nAudible Format 2, 3, and 4 demuxer.\n\nThis demuxer is used to demux Audible Format 2, 3, and 4 (.aa) files.\n\n@section applehttp\n\nApple HTTP Live Streaming demuxer.\n\nThis demuxer presents all AVStreams from all variant streams.\nThe id field is set to the bitrate variant index number. By setting\nthe discard flags on AVStreams (by pressing 'a' or 'v' in ffplay),\nthe caller can decide which variant streams to actually receive.\nThe total bitrate of the variant that the stream belongs to is\navailable in a metadata key named \"variant_bitrate\".\n\n@section apng\n\nAnimated Portable Network Graphics demuxer.\n\nThis demuxer is used to demux APNG files.\nAll headers, but the PNG signature, up to (but not including) the first\nfcTL chunk are transmitted as extradata.\nFrames are then split as being all the chunks between two fcTL ones, or\nbetween the last fcTL and IEND chunks.\n\n@table @option\n@item -ignore_loop @var{bool}\nIgnore the loop variable in the file if set.\n@item -max_fps @var{int}\nMaximum framerate in frames per second (0 for no limit).\n@item -default_fps @var{int}\nDefault framerate in frames per second when none is specified in the file\n(0 meaning as fast as possible).\n@end table\n\n@section asf\n\nAdvanced Systems Format demuxer.\n\nThis demuxer is used to demux ASF files and MMS network streams.\n\n@table @option\n@item -no_resync_search @var{bool}\nDo not try to resynchronize by looking for a certain optional start code.\n@end table\n\n@anchor{concat}\n@section concat\n\nVirtual concatenation script demuxer.\n\nThis demuxer reads a list of files and other directives from a text file and\ndemuxes them one after the other, as if all their packets had been muxed\ntogether.\n\nThe timestamps in the files are adjusted so that the first file starts at 0\nand each next file starts where the previous one finishes. Note that it is\ndone globally and may cause gaps if all streams do not have exactly the same\nlength.\n\nAll files must have the same streams (same codecs, same time base, etc.).\n\nThe duration of each file is used to adjust the timestamps of the next file:\nif the duration is incorrect (because it was computed using the bit-rate or\nbecause the file is truncated, for example), it can cause artifacts. The\n@code{duration} directive can be used to override the duration stored in\neach file.\n\n@subsection Syntax\n\nThe script is a text file in extended-ASCII, with one directive per line.\nEmpty lines, leading spaces and lines starting with '#' are ignored. The\nfollowing directive is recognized:\n\n@table @option\n\n@item @code{file @var{path}}\nPath to a file to read; special characters and spaces must be escaped with\nbackslash or single quotes.\n\nAll subsequent file-related directives apply to that file.\n\n@item @code{ffconcat version 1.0}\nIdentify the script type and version. It also sets the @option{safe} option\nto 1 if it was -1.\n\nTo make FFmpeg recognize the format automatically, this directive must\nappear exactly as is (no extra space or byte-order-mark) on the very first\nline of the script.\n\n@item @code{duration @var{dur}}\nDuration of the file. This information can be specified from the file;\nspecifying it here may be more efficient or help if the information from the\nfile is not available or accurate.\n\nIf the duration is set for all files, then it is possible to seek in the\nwhole concatenated video.\n\n@item @code{inpoint @var{timestamp}}\nIn point of the file. When the demuxer opens the file it instantly seeks to the\nspecified timestamp. Seeking is done so that all streams can be presented\nsuccessfully at In point.\n\nThis directive works best with intra frame codecs, because for non-intra frame\nones you will usually get extra packets before the actual In point and the\ndecoded content will most likely contain frames before In point too.\n\nFor each file, packets before the file In point will have timestamps less than\nthe calculated start timestamp of the file (negative in case of the first\nfile), and the duration of the files (if not specified by the @code{duration}\ndirective) will be reduced based on their specified In point.\n\nBecause of potential packets before the specified In point, packet timestamps\nmay overlap between two concatenated files.\n\n@item @code{outpoint @var{timestamp}}\nOut point of the file. When the demuxer reaches the specified decoding\ntimestamp in any of the streams, it handles it as an end of file condition and\nskips the current and all the remaining packets from all streams.\n\nOut point is exclusive, which means that the demuxer will not output packets\nwith a decoding timestamp greater or equal to Out point.\n\nThis directive works best with intra frame codecs and formats where all streams\nare tightly interleaved. For non-intra frame codecs you will usually get\nadditional packets with presentation timestamp after Out point therefore the\ndecoded content will most likely contain frames after Out point too. If your\nstreams are not tightly interleaved you may not get all the packets from all\nstreams before Out point and you may only will be able to decode the earliest\nstream until Out point.\n\nThe duration of the files (if not specified by the @code{duration}\ndirective) will be reduced based on their specified Out point.\n\n@item @code{file_packet_metadata @var{key=value}}\nMetadata of the packets of the file. The specified metadata will be set for\neach file packet. You can specify this directive multiple times to add multiple\nmetadata entries.\n\n@item @code{stream}\nIntroduce a stream in the virtual file.\nAll subsequent stream-related directives apply to the last introduced\nstream.\nSome streams properties must be set in order to allow identifying the\nmatching streams in the subfiles.\nIf no streams are defined in the script, the streams from the first file are\ncopied.\n\n@item @code{exact_stream_id @var{id}}\nSet the id of the stream.\nIf this directive is given, the string with the corresponding id in the\nsubfiles will be used.\nThis is especially useful for MPEG-PS (VOB) files, where the order of the\nstreams is not reliable.\n\n@end table\n\n@subsection Options\n\nThis demuxer accepts the following option:\n\n@table @option\n\n@item safe\nIf set to 1, reject unsafe file paths. A file path is considered safe if it\ndoes not contain a protocol specification and is relative and all components\nonly contain characters from the portable character set (letters, digits,\nperiod, underscore and hyphen) and have no period at the beginning of a\ncomponent.\n\nIf set to 0, any file name is accepted.\n\nThe default is 1.\n\n-1 is equivalent to 1 if the format was automatically\nprobed and 0 otherwise.\n\n@item auto_convert\nIf set to 1, try to perform automatic conversions on packet data to make the\nstreams concatenable.\nThe default is 1.\n\nCurrently, the only conversion is adding the h264_mp4toannexb bitstream\nfilter to H.264 streams in MP4 format. This is necessary in particular if\nthere are resolution changes.\n\n@item segment_time_metadata\nIf set to 1, every packet will contain the @var{lavf.concat.start_time} and the\n@var{lavf.concat.duration} packet metadata values which are the start_time and\nthe duration of the respective file segments in the concatenated output\nexpressed in microseconds. The duration metadata is only set if it is known\nbased on the concat file.\nThe default is 0.\n\n@end table\n\n@subsection Examples\n\n@itemize\n@item\nUse absolute filenames and include some comments:\n@example\n# my first filename\nfile /mnt/share/file-1.wav\n# my second filename including whitespace\nfile '/mnt/share/file 2.wav'\n# my third filename including whitespace plus single quote\nfile '/mnt/share/file 3'\\''.wav'\n@end example\n\n@item\nAllow for input format auto-probing, use safe filenames and set the duration of\nthe first file:\n@example\nffconcat version 1.0\n\nfile file-1.wav\nduration 20.0\n\nfile subdir/file-2.wav\n@end example\n@end itemize\n\n@section flv, live_flv\n\nAdobe Flash Video Format demuxer.\n\nThis demuxer is used to demux FLV files and RTMP network streams. In case of live network streams, if you force format, you may use live_flv option instead of flv to survive timestamp discontinuities.\n\n@example\nffmpeg -f flv -i myfile.flv ...\nffmpeg -f live_flv -i rtmp://<any.server>/anything/key ....\n@end example\n\n\n@table @option\n@item -flv_metadata @var{bool}\nAllocate the streams according to the onMetaData array content.\n@end table\n\n@section gif\n\nAnimated GIF demuxer.\n\nIt accepts the following options:\n\n@table @option\n@item min_delay\nSet the minimum valid delay between frames in hundredths of seconds.\nRange is 0 to 6000. Default value is 2.\n\n@item max_gif_delay\nSet the maximum valid delay between frames in hundredth of seconds.\nRange is 0 to 65535. Default value is 65535 (nearly eleven minutes),\nthe maximum value allowed by the specification.\n\n@item default_delay\nSet the default delay between frames in hundredths of seconds.\nRange is 0 to 6000. Default value is 10.\n\n@item ignore_loop\nGIF files can contain information to loop a certain number of times (or\ninfinitely). If @option{ignore_loop} is set to 1, then the loop setting\nfrom the input will be ignored and looping will not occur. If set to 0,\nthen looping will occur and will cycle the number of times according to\nthe GIF. Default value is 1.\n@end table\n\nFor example, with the overlay filter, place an infinitely looping GIF\nover another video:\n@example\nffmpeg -i input.mp4 -ignore_loop 0 -i input.gif -filter_complex overlay=shortest=1 out.mkv\n@end example\n\nNote that in the above example the shortest option for overlay filter is\nused to end the output video at the length of the shortest input file,\nwhich in this case is @file{input.mp4} as the GIF in this example loops\ninfinitely.\n\n@section image2\n\nImage file demuxer.\n\nThis demuxer reads from a list of image files specified by a pattern.\nThe syntax and meaning of the pattern is specified by the\noption @var{pattern_type}.\n\nThe pattern may contain a suffix which is used to automatically\ndetermine the format of the images contained in the files.\n\nThe size, the pixel format, and the format of each image must be the\nsame for all the files in the sequence.\n\nThis demuxer accepts the following options:\n@table @option\n@item framerate\nSet the frame rate for the video stream. It defaults to 25.\n@item loop\nIf set to 1, loop over the input. Default value is 0.\n@item pattern_type\nSelect the pattern type used to interpret the provided filename.\n\n@var{pattern_type} accepts one of the following values.\n@table @option\n@item none\nDisable pattern matching, therefore the video will only contain the specified\nimage. You should use this option if you do not want to create sequences from\nmultiple images and your filenames may contain special pattern characters.\n@item sequence\nSelect a sequence pattern type, used to specify a sequence of files\nindexed by sequential numbers.\n\nA sequence pattern may contain the string \"%d\" or \"%0@var{N}d\", which\nspecifies the position of the characters representing a sequential\nnumber in each filename matched by the pattern. If the form\n\"%d0@var{N}d\" is used, the string representing the number in each\nfilename is 0-padded and @var{N} is the total number of 0-padded\ndigits representing the number. The literal character '%' can be\nspecified in the pattern with the string \"%%\".\n\nIf the sequence pattern contains \"%d\" or \"%0@var{N}d\", the first filename of\nthe file list specified by the pattern must contain a number\ninclusively contained between @var{start_number} and\n@var{start_number}+@var{start_number_range}-1, and all the following\nnumbers must be sequential.\n\nFor example the pattern \"img-%03d.bmp\" will match a sequence of\nfilenames of the form @file{img-001.bmp}, @file{img-002.bmp}, ...,\n@file{img-010.bmp}, etc.; the pattern \"i%%m%%g-%d.jpg\" will match a\nsequence of filenames of the form @file{i%m%g-1.jpg},\n@file{i%m%g-2.jpg}, ..., @file{i%m%g-10.jpg}, etc.\n\nNote that the pattern must not necessarily contain \"%d\" or\n\"%0@var{N}d\", for example to convert a single image file\n@file{img.jpeg} you can employ the command:\n@example\nffmpeg -i img.jpeg img.png\n@end example\n\n@item glob\nSelect a glob wildcard pattern type.\n\nThe pattern is interpreted like a @code{glob()} pattern. This is only\nselectable if libavformat was compiled with globbing support.\n\n@item glob_sequence @emph{(deprecated, will be removed)}\nSelect a mixed glob wildcard/sequence pattern.\n\nIf your version of libavformat was compiled with globbing support, and\nthe provided pattern contains at least one glob meta character among\n@code{%*?[]@{@}} that is preceded by an unescaped \"%\", the pattern is\ninterpreted like a @code{glob()} pattern, otherwise it is interpreted\nlike a sequence pattern.\n\nAll glob special characters @code{%*?[]@{@}} must be prefixed\nwith \"%\". To escape a literal \"%\" you shall use \"%%\".\n\nFor example the pattern @code{foo-%*.jpeg} will match all the\nfilenames prefixed by \"foo-\" and terminating with \".jpeg\", and\n@code{foo-%?%?%?.jpeg} will match all the filenames prefixed with\n\"foo-\", followed by a sequence of three characters, and terminating\nwith \".jpeg\".\n\nThis pattern type is deprecated in favor of @var{glob} and\n@var{sequence}.\n@end table\n\nDefault value is @var{glob_sequence}.\n@item pixel_format\nSet the pixel format of the images to read. If not specified the pixel\nformat is guessed from the first image file in the sequence.\n@item start_number\nSet the index of the file matched by the image file pattern to start\nto read from. Default value is 0.\n@item start_number_range\nSet the index interval range to check when looking for the first image\nfile in the sequence, starting from @var{start_number}. Default value\nis 5.\n@item ts_from_file\nIf set to 1, will set frame timestamp to modification time of image file. Note\nthat monotonity of timestamps is not provided: images go in the same order as\nwithout this option. Default value is 0.\nIf set to 2, will set frame timestamp to the modification time of the image file in\nnanosecond precision.\n@item video_size\nSet the video size of the images to read. If not specified the video\nsize is guessed from the first image file in the sequence.\n@end table\n\n@subsection Examples\n\n@itemize\n@item\nUse @command{ffmpeg} for creating a video from the images in the file\nsequence @file{img-001.jpeg}, @file{img-002.jpeg}, ..., assuming an\ninput frame rate of 10 frames per second:\n@example\nffmpeg -framerate 10 -i 'img-%03d.jpeg' out.mkv\n@end example\n\n@item\nAs above, but start by reading from a file with index 100 in the sequence:\n@example\nffmpeg -framerate 10 -start_number 100 -i 'img-%03d.jpeg' out.mkv\n@end example\n\n@item\nRead images matching the \"*.png\" glob pattern , that is all the files\nterminating with the \".png\" suffix:\n@example\nffmpeg -framerate 10 -pattern_type glob -i \"*.png\" out.mkv\n@end example\n@end itemize\n\n@section libgme\n\nThe Game Music Emu library is a collection of video game music file emulators.\n\nSee @url{http://code.google.com/p/game-music-emu/} for more information.\n\nSome files have multiple tracks. The demuxer will pick the first track by\ndefault. The @option{track_index} option can be used to select a different\ntrack. Track indexes start at 0. The demuxer exports the number of tracks as\n@var{tracks} meta data entry.\n\nFor very large files, the @option{max_size} option may have to be adjusted.\n\n@section libopenmpt\n\nlibopenmpt based module demuxer\n\nSee @url{https://lib.openmpt.org/libopenmpt/} for more information.\n\nSome files have multiple subsongs (tracks) this can be set with the @option{subsong}\noption.\n\nIt accepts the following options:\n\n@table @option\n@item subsong\nSet the subsong index. This can be either  'all', 'auto', or the index of the\nsubsong. Subsong indexes start at 0. The default is 'auto'.\n\nThe default value is to let libopenmpt choose.\n\n@item layout\nSet the channel layout. Valid values are 1, 2, and 4 channel layouts.\nThe default value is STEREO.\n\n@item sample_rate\nSet the sample rate for libopenmpt to output.\nRange is from 1000 to INT_MAX. The value default is 48000.\n@end table\n\n@section mov/mp4/3gp/QuickTime\n\nQuickTime / MP4 demuxer.\n\nThis demuxer accepts the following options:\n@table @option\n@item enable_drefs\nEnable loading of external tracks, disabled by default.\nEnabling this can theoretically leak information in some use cases.\n\n@item use_absolute_path\nAllows loading of external tracks via absolute paths, disabled by default.\nEnabling this poses a security risk. It should only be enabled if the source\nis known to be non malicious.\n\n@end table\n\n@section mpegts\n\nMPEG-2 transport stream demuxer.\n\nThis demuxer accepts the following options:\n@table @option\n@item resync_size\nSet size limit for looking up a new synchronization. Default value is\n65536.\n\n@item fix_teletext_pts\nOverride teletext packet PTS and DTS values with the timestamps calculated\nfrom the PCR of the first program which the teletext stream is part of and is\nnot discarded. Default value is 1, set this option to 0 if you want your\nteletext packet PTS and DTS values untouched.\n\n@item ts_packetsize\nOutput option carrying the raw packet size in bytes.\nShow the detected raw packet size, cannot be set by the user.\n\n@item scan_all_pmts\nScan and combine all PMTs. The value is an integer with value from -1\nto 1 (-1 means automatic setting, 1 means enabled, 0 means\ndisabled). Default value is -1.\n@end table\n\n@section mpjpeg\n\nMJPEG encapsulated in multi-part MIME demuxer.\n\nThis demuxer allows reading of MJPEG, where each frame is represented as a part of\nmultipart/x-mixed-replace stream.\n@table @option\n\n@item strict_mime_boundary\nDefault implementation applies a relaxed standard to multi-part MIME boundary detection,\nto prevent regression with numerous existing endpoints not generating a proper MIME\nMJPEG stream. Turning this option on by setting it to 1 will result in a stricter check\nof the boundary value.\n@end table\n\n@section rawvideo\n\nRaw video demuxer.\n\nThis demuxer allows one to read raw video data. Since there is no header\nspecifying the assumed video parameters, the user must specify them\nin order to be able to decode the data correctly.\n\nThis demuxer accepts the following options:\n@table @option\n\n@item framerate\nSet input video frame rate. Default value is 25.\n\n@item pixel_format\nSet the input video pixel format. Default value is @code{yuv420p}.\n\n@item video_size\nSet the input video size. This value must be specified explicitly.\n@end table\n\nFor example to read a rawvideo file @file{input.raw} with\n@command{ffplay}, assuming a pixel format of @code{rgb24}, a video\nsize of @code{320x240}, and a frame rate of 10 images per second, use\nthe command:\n@example\nffplay -f rawvideo -pixel_format rgb24 -video_size 320x240 -framerate 10 input.raw\n@end example\n\n@section sbg\n\nSBaGen script demuxer.\n\nThis demuxer reads the script language used by SBaGen\n@url{http://uazu.net/sbagen/} to generate binaural beats sessions. A SBG\nscript looks like that:\n@example\n-SE\na: 300-2.5/3 440+4.5/0\nb: 300-2.5/0 440+4.5/3\noff: -\nNOW      == a\n+0:07:00 == b\n+0:14:00 == a\n+0:21:00 == b\n+0:30:00    off\n@end example\n\nA SBG script can mix absolute and relative timestamps. If the script uses\neither only absolute timestamps (including the script start time) or only\nrelative ones, then its layout is fixed, and the conversion is\nstraightforward. On the other hand, if the script mixes both kind of\ntimestamps, then the @var{NOW} reference for relative timestamps will be\ntaken from the current time of day at the time the script is read, and the\nscript layout will be frozen according to that reference. That means that if\nthe script is directly played, the actual times will match the absolute\ntimestamps up to the sound controller's clock accuracy, but if the user\nsomehow pauses the playback or seeks, all times will be shifted accordingly.\n\n@section tedcaptions\n\nJSON captions used for @url{http://www.ted.com/, TED Talks}.\n\nTED does not provide links to the captions, but they can be guessed from the\npage. The file @file{tools/bookmarklets.html} from the FFmpeg source tree\ncontains a bookmarklet to expose them.\n\nThis demuxer accepts the following option:\n@table @option\n@item start_time\nSet the start time of the TED talk, in milliseconds. The default is 15000\n(15s). It is used to sync the captions with the downloadable videos, because\nthey include a 15s intro.\n@end table\n\nExample: convert the captions to a format most players understand:\n@example\nffmpeg -i http://www.ted.com/talks/subtitles/id/1/lang/en talk1-en.srt\n@end example\n\n@c man end DEMUXERS\n", "/*\n * Apple HTTP Live Streaming demuxer\n * Copyright (c) 2010 Martin Storsjo\n * Copyright (c) 2013 Anssi Hannula\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Apple HTTP Live Streaming demuxer\n * http://tools.ietf.org/html/draft-pantos-http-live-streaming\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/time.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"id3v2.h\"\n\n#define INITIAL_BUFFER_SIZE 32768\n\n#define MAX_FIELD_LEN 64\n#define MAX_CHARACTERISTICS_LEN 512\n\n#define MPEG_TIME_BASE 90000\n#define MPEG_TIME_BASE_Q (AVRational){1, MPEG_TIME_BASE}\n\n/*\n * An apple http stream consists of a playlist with media segment files,\n * played sequentially. There may be several playlists with the same\n * video content, in different bandwidth variants, that are played in\n * parallel (preferably only one bandwidth variant at a time). In this case,\n * the user supplied the url to a main playlist that only lists the variant\n * playlists.\n *\n * If the main playlist doesn't point at any variants, we still create\n * one anonymous toplevel variant for this, to maintain the structure.\n */\n\nenum KeyType {\n    KEY_NONE,\n    KEY_AES_128,\n    KEY_SAMPLE_AES\n};\n\nstruct segment {\n    int64_t duration;\n    int64_t url_offset;\n    int64_t size;\n    char *url;\n    char *key;\n    enum KeyType key_type;\n    uint8_t iv[16];\n    /* associated Media Initialization Section, treated as a segment */\n    struct segment *init_section;\n};\n\nstruct rendition;\n\nenum PlaylistType {\n    PLS_TYPE_UNSPECIFIED,\n    PLS_TYPE_EVENT,\n    PLS_TYPE_VOD\n};\n\n/*\n * Each playlist has its own demuxer. If it currently is active,\n * it has an open AVIOContext too, and potentially an AVPacket\n * containing the next packet from this stream.\n */\nstruct playlist {\n    char url[MAX_URL_SIZE];\n    AVIOContext pb;\n    uint8_t* read_buffer;\n    AVIOContext *input;\n    AVFormatContext *parent;\n    int index;\n    AVFormatContext *ctx;\n    AVPacket pkt;\n    int has_noheader_flag;\n\n    /* main demuxer streams associated with this playlist\n     * indexed by the subdemuxer stream indexes */\n    AVStream **main_streams;\n    int n_main_streams;\n\n    int finished;\n    enum PlaylistType type;\n    int64_t target_duration;\n    int start_seq_no;\n    int n_segments;\n    struct segment **segments;\n    int needed, cur_needed;\n    int cur_seq_no;\n    int64_t cur_seg_offset;\n    int64_t last_load_time;\n\n    /* Currently active Media Initialization Section */\n    struct segment *cur_init_section;\n    uint8_t *init_sec_buf;\n    unsigned int init_sec_buf_size;\n    unsigned int init_sec_data_len;\n    unsigned int init_sec_buf_read_offset;\n\n    char key_url[MAX_URL_SIZE];\n    uint8_t key[16];\n\n    /* ID3 timestamp handling (elementary audio streams have ID3 timestamps\n     * (and possibly other ID3 tags) in the beginning of each segment) */\n    int is_id3_timestamped; /* -1: not yet known */\n    int64_t id3_mpegts_timestamp; /* in mpegts tb */\n    int64_t id3_offset; /* in stream original tb */\n    uint8_t* id3_buf; /* temp buffer for id3 parsing */\n    unsigned int id3_buf_size;\n    AVDictionary *id3_initial; /* data from first id3 tag */\n    int id3_found; /* ID3 tag found at some point */\n    int id3_changed; /* ID3 tag data has changed at some point */\n    ID3v2ExtraMeta *id3_deferred_extra; /* stored here until subdemuxer is opened */\n\n    int64_t seek_timestamp;\n    int seek_flags;\n    int seek_stream_index; /* into subdemuxer stream array */\n\n    /* Renditions associated with this playlist, if any.\n     * Alternative rendition playlists have a single rendition associated\n     * with them, and variant main Media Playlists may have\n     * multiple (playlist-less) renditions associated with them. */\n    int n_renditions;\n    struct rendition **renditions;\n\n    /* Media Initialization Sections (EXT-X-MAP) associated with this\n     * playlist, if any. */\n    int n_init_sections;\n    struct segment **init_sections;\n};\n\n/*\n * Renditions are e.g. alternative subtitle or audio streams.\n * The rendition may either be an external playlist or it may be\n * contained in the main Media Playlist of the variant (in which case\n * playlist is NULL).\n */\nstruct rendition {\n    enum AVMediaType type;\n    struct playlist *playlist;\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    int disposition;\n};\n\nstruct variant {\n    int bandwidth;\n\n    /* every variant contains at least the main Media Playlist in index 0 */\n    int n_playlists;\n    struct playlist **playlists;\n\n    char audio_group[MAX_FIELD_LEN];\n    char video_group[MAX_FIELD_LEN];\n    char subtitles_group[MAX_FIELD_LEN];\n};\n\ntypedef struct HLSContext {\n    AVClass *class;\n    AVFormatContext *ctx;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    char *http_proxy;                    ///< holds the address of the HTTP proxy server\n    AVDictionary *avio_opts;\n    int strict_std_compliance;\n    char *allowed_extensions;\n} HLSContext;\n\nstatic int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n\nstatic void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_freep(&pls->segments[i]->key);\n        av_freep(&pls->segments[i]->url);\n        av_freep(&pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}\n\nstatic void free_init_section_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_init_sections; i++) {\n        av_freep(&pls->init_sections[i]->url);\n        av_freep(&pls->init_sections[i]);\n    }\n    av_freep(&pls->init_sections);\n    pls->n_init_sections = 0;\n}\n\nstatic void free_playlist_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        free_segment_list(pls);\n        free_init_section_list(pls);\n        av_freep(&pls->main_streams);\n        av_freep(&pls->renditions);\n        av_freep(&pls->id3_buf);\n        av_dict_free(&pls->id3_initial);\n        ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n        av_freep(&pls->init_sec_buf);\n        av_packet_unref(&pls->pkt);\n        av_freep(&pls->pb.buffer);\n        if (pls->input)\n            ff_format_io_close(c->ctx, &pls->input);\n        if (pls->ctx) {\n            pls->ctx->pb = NULL;\n            avformat_close_input(&pls->ctx);\n        }\n        av_free(pls);\n    }\n    av_freep(&c->playlists);\n    av_freep(&c->cookies);\n    av_freep(&c->user_agent);\n    av_freep(&c->headers);\n    av_freep(&c->http_proxy);\n    c->n_playlists = 0;\n}\n\nstatic void free_variant_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        av_freep(&var->playlists);\n        av_free(var);\n    }\n    av_freep(&c->variants);\n    c->n_variants = 0;\n}\n\nstatic void free_rendition_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_renditions; i++)\n        av_freep(&c->renditions[i]);\n    av_freep(&c->renditions);\n    c->n_renditions = 0;\n}\n\n/*\n * Used to reset a statically allocated AVPacket to a clean slate,\n * containing no data.\n */\nstatic void reset_packet(AVPacket *pkt)\n{\n    av_init_packet(pkt);\n    pkt->data = NULL;\n}\n\nstatic struct playlist *new_playlist(HLSContext *c, const char *url,\n                                     const char *base)\n{\n    struct playlist *pls = av_mallocz(sizeof(struct playlist));\n    if (!pls)\n        return NULL;\n    reset_packet(&pls->pkt);\n    ff_make_absolute_url(pls->url, sizeof(pls->url), base, url);\n    pls->seek_timestamp = AV_NOPTS_VALUE;\n\n    pls->is_id3_timestamped = -1;\n    pls->id3_mpegts_timestamp = AV_NOPTS_VALUE;\n\n    dynarray_add(&c->playlists, &c->n_playlists, pls);\n    return pls;\n}\n\nstruct variant_info {\n    char bandwidth[20];\n    /* variant group ids: */\n    char audio[MAX_FIELD_LEN];\n    char video[MAX_FIELD_LEN];\n    char subtitles[MAX_FIELD_LEN];\n};\n\nstatic struct variant *new_variant(HLSContext *c, struct variant_info *info,\n                                   const char *url, const char *base)\n{\n    struct variant *var;\n    struct playlist *pls;\n\n    pls = new_playlist(c, url, base);\n    if (!pls)\n        return NULL;\n\n    var = av_mallocz(sizeof(struct variant));\n    if (!var)\n        return NULL;\n\n    if (info) {\n        var->bandwidth = atoi(info->bandwidth);\n        strcpy(var->audio_group, info->audio);\n        strcpy(var->video_group, info->video);\n        strcpy(var->subtitles_group, info->subtitles);\n    }\n\n    dynarray_add(&c->variants, &c->n_variants, var);\n    dynarray_add(&var->playlists, &var->n_playlists, pls);\n    return var;\n}\n\nstatic void handle_variant_args(struct variant_info *info, const char *key,\n                                int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"BANDWIDTH=\", key_len)) {\n        *dest     =        info->bandwidth;\n        *dest_len = sizeof(info->bandwidth);\n    } else if (!strncmp(key, \"AUDIO=\", key_len)) {\n        *dest     =        info->audio;\n        *dest_len = sizeof(info->audio);\n    } else if (!strncmp(key, \"VIDEO=\", key_len)) {\n        *dest     =        info->video;\n        *dest_len = sizeof(info->video);\n    } else if (!strncmp(key, \"SUBTITLES=\", key_len)) {\n        *dest     =        info->subtitles;\n        *dest_len = sizeof(info->subtitles);\n    }\n}\n\nstruct key_info {\n     char uri[MAX_URL_SIZE];\n     char method[11];\n     char iv[35];\n};\n\nstatic void handle_key_args(struct key_info *info, const char *key,\n                            int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"METHOD=\", key_len)) {\n        *dest     =        info->method;\n        *dest_len = sizeof(info->method);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"IV=\", key_len)) {\n        *dest     =        info->iv;\n        *dest_len = sizeof(info->iv);\n    }\n}\n\nstruct init_section_info {\n    char uri[MAX_URL_SIZE];\n    char byterange[32];\n};\n\nstatic struct segment *new_init_section(struct playlist *pls,\n                                        struct init_section_info *info,\n                                        const char *url_base)\n{\n    struct segment *sec;\n    char *ptr;\n    char tmp_str[MAX_URL_SIZE];\n\n    if (!info->uri[0])\n        return NULL;\n\n    sec = av_mallocz(sizeof(*sec));\n    if (!sec)\n        return NULL;\n\n    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url_base, info->uri);\n    sec->url = av_strdup(tmp_str);\n    if (!sec->url) {\n        av_free(sec);\n        return NULL;\n    }\n\n    if (info->byterange[0]) {\n        sec->size = strtoll(info->byterange, NULL, 10);\n        ptr = strchr(info->byterange, '@');\n        if (ptr)\n            sec->url_offset = strtoll(ptr+1, NULL, 10);\n    } else {\n        /* the entire file is the init section */\n        sec->size = -1;\n    }\n\n    dynarray_add(&pls->init_sections, &pls->n_init_sections, sec);\n\n    return sec;\n}\n\nstatic void handle_init_section_args(struct init_section_info *info, const char *key,\n                                           int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"BYTERANGE=\", key_len)) {\n        *dest     =        info->byterange;\n        *dest_len = sizeof(info->byterange);\n    }\n}\n\nstruct rendition_info {\n    char type[16];\n    char uri[MAX_URL_SIZE];\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char assoc_language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    char defaultr[4];\n    char forced[4];\n    char characteristics[MAX_CHARACTERISTICS_LEN];\n};\n\nstatic struct rendition *new_rendition(HLSContext *c, struct rendition_info *info,\n                                      const char *url_base)\n{\n    struct rendition *rend;\n    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;\n    char *characteristic;\n    char *chr_ptr;\n    char *saveptr;\n\n    if (!strcmp(info->type, \"AUDIO\"))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!strcmp(info->type, \"VIDEO\"))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!strcmp(info->type, \"SUBTITLES\"))\n        type = AVMEDIA_TYPE_SUBTITLE;\n    else if (!strcmp(info->type, \"CLOSED-CAPTIONS\"))\n        /* CLOSED-CAPTIONS is ignored since we do not support CEA-608 CC in\n         * AVC SEI RBSP anyway */\n        return NULL;\n\n    if (type == AVMEDIA_TYPE_UNKNOWN)\n        return NULL;\n\n    /* URI is mandatory for subtitles as per spec */\n    if (type == AVMEDIA_TYPE_SUBTITLE && !info->uri[0])\n        return NULL;\n\n    /* TODO: handle subtitles (each segment has to parsed separately) */\n    if (c->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)\n        if (type == AVMEDIA_TYPE_SUBTITLE)\n            return NULL;\n\n    rend = av_mallocz(sizeof(struct rendition));\n    if (!rend)\n        return NULL;\n\n    dynarray_add(&c->renditions, &c->n_renditions, rend);\n\n    rend->type = type;\n    strcpy(rend->group_id, info->group_id);\n    strcpy(rend->language, info->language);\n    strcpy(rend->name, info->name);\n\n    /* add the playlist if this is an external rendition */\n    if (info->uri[0]) {\n        rend->playlist = new_playlist(c, info->uri, url_base);\n        if (rend->playlist)\n            dynarray_add(&rend->playlist->renditions,\n                         &rend->playlist->n_renditions, rend);\n    }\n\n    if (info->assoc_language[0]) {\n        int langlen = strlen(rend->language);\n        if (langlen < sizeof(rend->language) - 3) {\n            rend->language[langlen] = ',';\n            strncpy(rend->language + langlen + 1, info->assoc_language,\n                    sizeof(rend->language) - langlen - 2);\n        }\n    }\n\n    if (!strcmp(info->defaultr, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_DEFAULT;\n    if (!strcmp(info->forced, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_FORCED;\n\n    chr_ptr = info->characteristics;\n    while ((characteristic = av_strtok(chr_ptr, \",\", &saveptr))) {\n        if (!strcmp(characteristic, \"public.accessibility.describes-music-and-sound\"))\n            rend->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n        else if (!strcmp(characteristic, \"public.accessibility.describes-video\"))\n            rend->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n        chr_ptr = NULL;\n    }\n\n    return rend;\n}\n\nstatic void handle_rendition_args(struct rendition_info *info, const char *key,\n                                  int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"TYPE=\", key_len)) {\n        *dest     =        info->type;\n        *dest_len = sizeof(info->type);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"GROUP-ID=\", key_len)) {\n        *dest     =        info->group_id;\n        *dest_len = sizeof(info->group_id);\n    } else if (!strncmp(key, \"LANGUAGE=\", key_len)) {\n        *dest     =        info->language;\n        *dest_len = sizeof(info->language);\n    } else if (!strncmp(key, \"ASSOC-LANGUAGE=\", key_len)) {\n        *dest     =        info->assoc_language;\n        *dest_len = sizeof(info->assoc_language);\n    } else if (!strncmp(key, \"NAME=\", key_len)) {\n        *dest     =        info->name;\n        *dest_len = sizeof(info->name);\n    } else if (!strncmp(key, \"DEFAULT=\", key_len)) {\n        *dest     =        info->defaultr;\n        *dest_len = sizeof(info->defaultr);\n    } else if (!strncmp(key, \"FORCED=\", key_len)) {\n        *dest     =        info->forced;\n        *dest_len = sizeof(info->forced);\n    } else if (!strncmp(key, \"CHARACTERISTICS=\", key_len)) {\n        *dest     =        info->characteristics;\n        *dest_len = sizeof(info->characteristics);\n    }\n    /*\n     * ignored:\n     * - AUTOSELECT: client may autoselect based on e.g. system language\n     * - INSTREAM-ID: EIA-608 closed caption number (\"CC1\"..\"CC4\")\n     */\n}\n\n/* used by parse_playlist to allocate a new variant+playlist when the\n * playlist is detected to be a Media Playlist (not Master Playlist)\n * and we have no parent Master Playlist (parsing of which would have\n * allocated the variant and playlist already)\n * *pls == NULL  => Master Playlist or parentless Media Playlist\n * *pls != NULL => parented Media Playlist, playlist+variant allocated */\nstatic int ensure_playlist(HLSContext *c, struct playlist **pls, const char *url)\n{\n    if (*pls)\n        return 0;\n    if (!new_variant(c, NULL, url, NULL))\n        return AVERROR(ENOMEM);\n    *pls = c->playlists[c->n_playlists - 1];\n    return 0;\n}\n\nstatic void update_options(char **dest, const char *name, void *src)\n{\n    av_freep(dest);\n    av_opt_get(src, name, AV_OPT_SEARCH_CHILDREN, (uint8_t**)dest);\n    if (*dest && !strlen(*dest))\n        av_freep(dest);\n}\n\nstatic int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n\n    // only http(s) & file are allowed\n    if (av_strstart(proto_name, \"file\", NULL)) {\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n            av_log(s, AV_LOG_ERROR,\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n                url);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n        ;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        // update cookies on http response with setcookies.\n        char *new_cookies = NULL;\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n\n    av_dict_free(&tmp);\n\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n    return ret;\n}\n\nstatic int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n        av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n\n        ret = c->ctx->io_open(c->ctx, &in, url, AVIO_FLAG_READ, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = strtoll(ptr, NULL, 10);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = strtoll(ptr+1, NULL, 10);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        ff_format_io_close(c->ctx, &in);\n    return ret;\n}\n\nstatic struct segment *current_segment(struct playlist *pls)\n{\n    return pls->segments[pls->cur_seq_no - pls->start_seq_no];\n}\n\nenum ReadFromURLMode {\n    READ_NORMAL,\n    READ_COMPLETE,\n};\n\nstatic int read_from_url(struct playlist *pls, struct segment *seg,\n                         uint8_t *buf, int buf_size,\n                         enum ReadFromURLMode mode)\n{\n    int ret;\n\n     /* limit read if the segment was only a part of a file */\n    if (seg->size >= 0)\n        buf_size = FFMIN(buf_size, seg->size - pls->cur_seg_offset);\n\n    if (mode == READ_COMPLETE) {\n        ret = avio_read(pls->input, buf, buf_size);\n        if (ret != buf_size)\n            av_log(NULL, AV_LOG_ERROR, \"Could not read complete segment.\\n\");\n    } else\n        ret = avio_read(pls->input, buf, buf_size);\n\n    if (ret > 0)\n        pls->cur_seg_offset += ret;\n\n    return ret;\n}\n\n/* Parse the raw ID3 data and pass contents to caller */\nstatic void parse_id3(AVFormatContext *s, AVIOContext *pb,\n                      AVDictionary **metadata, int64_t *dts,\n                      ID3v2ExtraMetaAPIC **apic, ID3v2ExtraMeta **extra_meta)\n{\n    static const char id3_priv_owner_ts[] = \"com.apple.streaming.transportStreamTimestamp\";\n    ID3v2ExtraMeta *meta;\n\n    ff_id3v2_read_dict(pb, metadata, ID3v2_DEFAULT_MAGIC, extra_meta);\n    for (meta = *extra_meta; meta; meta = meta->next) {\n        if (!strcmp(meta->tag, \"PRIV\")) {\n            ID3v2ExtraMetaPRIV *priv = meta->data;\n            if (priv->datasize == 8 && !strcmp(priv->owner, id3_priv_owner_ts)) {\n                /* 33-bit MPEG timestamp */\n                int64_t ts = AV_RB64(priv->data);\n                av_log(s, AV_LOG_DEBUG, \"HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n                if ((ts & ~((1ULL << 33) - 1)) == 0)\n                    *dts = ts;\n                else\n                    av_log(s, AV_LOG_ERROR, \"Invalid HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n            }\n        } else if (!strcmp(meta->tag, \"APIC\") && apic)\n            *apic = meta->data;\n    }\n}\n\n/* Check if the ID3 metadata contents have changed */\nstatic int id3_has_changed_values(struct playlist *pls, AVDictionary *metadata,\n                                  ID3v2ExtraMetaAPIC *apic)\n{\n    AVDictionaryEntry *entry = NULL;\n    AVDictionaryEntry *oldentry;\n    /* check that no keys have changed values */\n    while ((entry = av_dict_get(metadata, \"\", entry, AV_DICT_IGNORE_SUFFIX))) {\n        oldentry = av_dict_get(pls->id3_initial, entry->key, NULL, AV_DICT_MATCH_CASE);\n        if (!oldentry || strcmp(oldentry->value, entry->value) != 0)\n            return 1;\n    }\n\n    /* check if apic appeared */\n    if (apic && (pls->ctx->nb_streams != 2 || !pls->ctx->streams[1]->attached_pic.data))\n        return 1;\n\n    if (apic) {\n        int size = pls->ctx->streams[1]->attached_pic.size;\n        if (size != apic->buf->size - AV_INPUT_BUFFER_PADDING_SIZE)\n            return 1;\n\n        if (memcmp(apic->buf->data, pls->ctx->streams[1]->attached_pic.data, size) != 0)\n            return 1;\n    }\n\n    return 0;\n}\n\n/* Parse ID3 data and handle the found data */\nstatic void handle_id3(AVIOContext *pb, struct playlist *pls)\n{\n    AVDictionary *metadata = NULL;\n    ID3v2ExtraMetaAPIC *apic = NULL;\n    ID3v2ExtraMeta *extra_meta = NULL;\n    int64_t timestamp = AV_NOPTS_VALUE;\n\n    parse_id3(pls->ctx, pb, &metadata, &timestamp, &apic, &extra_meta);\n\n    if (timestamp != AV_NOPTS_VALUE) {\n        pls->id3_mpegts_timestamp = timestamp;\n        pls->id3_offset = 0;\n    }\n\n    if (!pls->id3_found) {\n        /* initial ID3 tags */\n        av_assert0(!pls->id3_deferred_extra);\n        pls->id3_found = 1;\n\n        /* get picture attachment and set text metadata */\n        if (pls->ctx->nb_streams)\n            ff_id3v2_parse_apic(pls->ctx, &extra_meta);\n        else\n            /* demuxer not yet opened, defer picture attachment */\n            pls->id3_deferred_extra = extra_meta;\n\n        av_dict_copy(&pls->ctx->metadata, metadata, 0);\n        pls->id3_initial = metadata;\n\n    } else {\n        if (!pls->id3_changed && id3_has_changed_values(pls, metadata, apic)) {\n            avpriv_report_missing_feature(pls->ctx, \"Changing ID3 metadata in HLS audio elementary stream\");\n            pls->id3_changed = 1;\n        }\n        av_dict_free(&metadata);\n    }\n\n    if (!pls->id3_deferred_extra)\n        ff_id3v2_free_extra_meta(&extra_meta);\n}\n\nstatic void intercept_id3(struct playlist *pls, uint8_t *buf,\n                         int buf_size, int *len)\n{\n    /* intercept id3 tags, we do not want to pass them to the raw\n     * demuxer on all segment switches */\n    int bytes;\n    int id3_buf_pos = 0;\n    int fill_buf = 0;\n    struct segment *seg = current_segment(pls);\n\n    /* gather all the id3 tags */\n    while (1) {\n        /* see if we can retrieve enough data for ID3 header */\n        if (*len < ID3v2_HEADER_SIZE && buf_size >= ID3v2_HEADER_SIZE) {\n            bytes = read_from_url(pls, seg, buf + *len, ID3v2_HEADER_SIZE - *len, READ_COMPLETE);\n            if (bytes > 0) {\n\n                if (bytes == ID3v2_HEADER_SIZE - *len)\n                    /* no EOF yet, so fill the caller buffer again after\n                     * we have stripped the ID3 tags */\n                    fill_buf = 1;\n\n                *len += bytes;\n\n            } else if (*len <= 0) {\n                /* error/EOF */\n                *len = bytes;\n                fill_buf = 0;\n            }\n        }\n\n        if (*len < ID3v2_HEADER_SIZE)\n            break;\n\n        if (ff_id3v2_match(buf, ID3v2_DEFAULT_MAGIC)) {\n            int64_t maxsize = seg->size >= 0 ? seg->size : 1024*1024;\n            int taglen = ff_id3v2_tag_len(buf);\n            int tag_got_bytes = FFMIN(taglen, *len);\n            int remaining = taglen - tag_got_bytes;\n\n            if (taglen > maxsize) {\n                av_log(pls->ctx, AV_LOG_ERROR, \"Too large HLS ID3 tag (%d > %\"PRId64\" bytes)\\n\",\n                       taglen, maxsize);\n                break;\n            }\n\n            /*\n             * Copy the id3 tag to our temporary id3 buffer.\n             * We could read a small id3 tag directly without memcpy, but\n             * we would still need to copy the large tags, and handling\n             * both of those cases together with the possibility for multiple\n             * tags would make the handling a bit complex.\n             */\n            pls->id3_buf = av_fast_realloc(pls->id3_buf, &pls->id3_buf_size, id3_buf_pos + taglen);\n            if (!pls->id3_buf)\n                break;\n            memcpy(pls->id3_buf + id3_buf_pos, buf, tag_got_bytes);\n            id3_buf_pos += tag_got_bytes;\n\n            /* strip the intercepted bytes */\n            *len -= tag_got_bytes;\n            memmove(buf, buf + tag_got_bytes, *len);\n            av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped %d HLS ID3 bytes\\n\", tag_got_bytes);\n\n            if (remaining > 0) {\n                /* read the rest of the tag in */\n                if (read_from_url(pls, seg, pls->id3_buf + id3_buf_pos, remaining, READ_COMPLETE) != remaining)\n                    break;\n                id3_buf_pos += remaining;\n                av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped additional %d HLS ID3 bytes\\n\", remaining);\n            }\n\n        } else {\n            /* no more ID3 tags */\n            break;\n        }\n    }\n\n    /* re-fill buffer for the caller unless EOF */\n    if (*len >= 0 && (fill_buf || *len == 0)) {\n        bytes = read_from_url(pls, seg, buf + *len, buf_size - *len, READ_NORMAL);\n\n        /* ignore error if we already had some data */\n        if (bytes >= 0)\n            *len += bytes;\n        else if (*len == 0)\n            *len = bytes;\n    }\n\n    if (pls->id3_buf) {\n        /* Now parse all the ID3 tags */\n        AVIOContext id3ioctx;\n        ffio_init_context(&id3ioctx, pls->id3_buf, id3_buf_pos, 0, NULL, NULL, NULL, NULL);\n        handle_id3(&id3ioctx, pls);\n    }\n\n    if (pls->is_id3_timestamped == -1)\n        pls->is_id3_timestamped = (pls->id3_mpegts_timestamp != AV_NOPTS_VALUE);\n}\n\nstatic int open_input(HLSContext *c, struct playlist *pls, struct segment *seg)\n{\n    AVDictionary *opts = NULL;\n    int ret;\n    int is_http = 0;\n\n    // broker prior HTTP options that should be consistent across requests\n    av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n    av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    av_dict_set(&opts, \"headers\", c->headers, 0);\n    av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n    av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n    if (seg->size >= 0) {\n        /* try to restrict the HTTP request to the part we want\n         * (if this is in fact a HTTP request) */\n        av_dict_set_int(&opts, \"offset\", seg->url_offset, 0);\n        av_dict_set_int(&opts, \"end_offset\", seg->url_offset + seg->size, 0);\n    }\n\n    av_log(pls->parent, AV_LOG_VERBOSE, \"HLS request for url '%s', offset %\"PRId64\", playlist %d\\n\",\n           seg->url, seg->url_offset, pls->index);\n\n    if (seg->key_type == KEY_NONE) {\n        ret = open_url(pls->parent, &pls->input, seg->url, c->avio_opts, opts, &is_http);\n    } else if (seg->key_type == KEY_AES_128) {\n        AVDictionary *opts2 = NULL;\n        char iv[33], key[33], url[MAX_URL_SIZE];\n        if (strcmp(seg->key, pls->key_url)) {\n            AVIOContext *pb;\n            if (open_url(pls->parent, &pb, seg->key, c->avio_opts, opts, NULL) == 0) {\n                ret = avio_read(pb, pls->key, sizeof(pls->key));\n                if (ret != sizeof(pls->key)) {\n                    av_log(NULL, AV_LOG_ERROR, \"Unable to read key file %s\\n\",\n                           seg->key);\n                }\n                ff_format_io_close(pls->parent, &pb);\n            } else {\n                av_log(NULL, AV_LOG_ERROR, \"Unable to open key file %s\\n\",\n                       seg->key);\n            }\n            av_strlcpy(pls->key_url, seg->key, sizeof(pls->key_url));\n        }\n        ff_data_to_hex(iv, seg->iv, sizeof(seg->iv), 0);\n        ff_data_to_hex(key, pls->key, sizeof(pls->key), 0);\n        iv[32] = key[32] = '\\0';\n        if (strstr(seg->url, \"://\"))\n            snprintf(url, sizeof(url), \"crypto+%s\", seg->url);\n        else\n            snprintf(url, sizeof(url), \"crypto:%s\", seg->url);\n\n        av_dict_copy(&opts2, c->avio_opts, 0);\n        av_dict_set(&opts2, \"key\", key, 0);\n        av_dict_set(&opts2, \"iv\", iv, 0);\n\n        ret = open_url(pls->parent, &pls->input, url, opts2, opts, &is_http);\n\n        av_dict_free(&opts2);\n\n        if (ret < 0) {\n            goto cleanup;\n        }\n        ret = 0;\n    } else if (seg->key_type == KEY_SAMPLE_AES) {\n        av_log(pls->parent, AV_LOG_ERROR,\n               \"SAMPLE-AES encryption is not supported yet\\n\");\n        ret = AVERROR_PATCHWELCOME;\n    }\n    else\n      ret = AVERROR(ENOSYS);\n\n    /* Seek to the requested position. If this was a HTTP request, the offset\n     * should already be where want it to, but this allows e.g. local testing\n     * without a HTTP server.\n     *\n     * This is not done for HTTP at all as avio_seek() does internal bookkeeping\n     * of file offset which is out-of-sync with the actual offset when \"offset\"\n     * AVOption is used with http protocol, causing the seek to not be a no-op\n     * as would be expected. Wrong offset received from the server will not be\n     * noticed without the call, though.\n     */\n    if (ret == 0 && !is_http && seg->key_type == KEY_NONE && seg->url_offset) {\n        int64_t seekret = avio_seek(pls->input, seg->url_offset, SEEK_SET);\n        if (seekret < 0) {\n            av_log(pls->parent, AV_LOG_ERROR, \"Unable to seek to offset %\"PRId64\" of HLS segment '%s'\\n\", seg->url_offset, seg->url);\n            ret = seekret;\n            ff_format_io_close(pls->parent, &pls->input);\n        }\n    }\n\ncleanup:\n    av_dict_free(&opts);\n    pls->cur_seg_offset = 0;\n    return ret;\n}\n\nstatic int update_init_section(struct playlist *pls, struct segment *seg)\n{\n    static const int max_init_section_size = 1024*1024;\n    HLSContext *c = pls->parent->priv_data;\n    int64_t sec_size;\n    int64_t urlsize;\n    int ret;\n\n    if (seg->init_section == pls->cur_init_section)\n        return 0;\n\n    pls->cur_init_section = NULL;\n\n    if (!seg->init_section)\n        return 0;\n\n    ret = open_input(c, pls, seg->init_section);\n    if (ret < 0) {\n        av_log(pls->parent, AV_LOG_WARNING,\n               \"Failed to open an initialization section in playlist %d\\n\",\n               pls->index);\n        return ret;\n    }\n\n    if (seg->init_section->size >= 0)\n        sec_size = seg->init_section->size;\n    else if ((urlsize = avio_size(pls->input)) >= 0)\n        sec_size = urlsize;\n    else\n        sec_size = max_init_section_size;\n\n    av_log(pls->parent, AV_LOG_DEBUG,\n           \"Downloading an initialization section of size %\"PRId64\"\\n\",\n           sec_size);\n\n    sec_size = FFMIN(sec_size, max_init_section_size);\n\n    av_fast_malloc(&pls->init_sec_buf, &pls->init_sec_buf_size, sec_size);\n\n    ret = read_from_url(pls, seg->init_section, pls->init_sec_buf,\n                        pls->init_sec_buf_size, READ_COMPLETE);\n    ff_format_io_close(pls->parent, &pls->input);\n\n    if (ret < 0)\n        return ret;\n\n    pls->cur_init_section = seg->init_section;\n    pls->init_sec_data_len = ret;\n    pls->init_sec_buf_read_offset = 0;\n\n    /* spec says audio elementary streams do not have media initialization\n     * sections, so there should be no ID3 timestamps */\n    pls->is_id3_timestamped = 0;\n\n    return 0;\n}\n\nstatic int64_t default_reload_interval(struct playlist *pls)\n{\n    return pls->n_segments > 0 ?\n                          pls->segments[pls->n_segments - 1]->duration :\n                          pls->target_duration;\n}\n\nstatic int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        if (!v->finished &&\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n\nstatic void add_renditions_to_variant(HLSContext *c, struct variant *var,\n                                      enum AVMediaType type, const char *group_id)\n{\n    int i;\n\n    for (i = 0; i < c->n_renditions; i++) {\n        struct rendition *rend = c->renditions[i];\n\n        if (rend->type == type && !strcmp(rend->group_id, group_id)) {\n\n            if (rend->playlist)\n                /* rendition is an external playlist\n                 * => add the playlist to the variant */\n                dynarray_add(&var->playlists, &var->n_playlists, rend->playlist);\n            else\n                /* rendition is part of the variant main Media Playlist\n                 * => add the rendition to the main Media Playlist */\n                dynarray_add(&var->playlists[0]->renditions,\n                             &var->playlists[0]->n_renditions,\n                             rend);\n        }\n    }\n}\n\nstatic void add_metadata_from_renditions(AVFormatContext *s, struct playlist *pls,\n                                         enum AVMediaType type)\n{\n    int rend_idx = 0;\n    int i;\n\n    for (i = 0; i < pls->n_main_streams; i++) {\n        AVStream *st = pls->main_streams[i];\n\n        if (st->codecpar->codec_type != type)\n            continue;\n\n        for (; rend_idx < pls->n_renditions; rend_idx++) {\n            struct rendition *rend = pls->renditions[rend_idx];\n\n            if (rend->type != type)\n                continue;\n\n            if (rend->language[0])\n                av_dict_set(&st->metadata, \"language\", rend->language, 0);\n            if (rend->name[0])\n                av_dict_set(&st->metadata, \"comment\", rend->name, 0);\n\n            st->disposition |= rend->disposition;\n        }\n        if (rend_idx >=pls->n_renditions)\n            break;\n    }\n}\n\n/* if timestamp was in valid range: returns 1 and sets seq_no\n * if not: returns 0 and sets seq_no to closest segment */\nstatic int find_timestamp_in_playlist(HLSContext *c, struct playlist *pls,\n                                      int64_t timestamp, int *seq_no)\n{\n    int i;\n    int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ?\n                  0 : c->first_timestamp;\n\n    if (timestamp < pos) {\n        *seq_no = pls->start_seq_no;\n        return 0;\n    }\n\n    for (i = 0; i < pls->n_segments; i++) {\n        int64_t diff = pos + pls->segments[i]->duration - timestamp;\n        if (diff > 0) {\n            *seq_no = pls->start_seq_no + i;\n            return 1;\n        }\n        pos += pls->segments[i]->duration;\n    }\n\n    *seq_no = pls->start_seq_no + pls->n_segments - 1;\n\n    return 0;\n}\n\nstatic int select_cur_seq_no(HLSContext *c, struct playlist *pls)\n{\n    int seq_no;\n\n    if (!pls->finished && !c->first_packet &&\n        av_gettime_relative() - pls->last_load_time >= default_reload_interval(pls))\n        /* reload the playlist since it was suspended */\n        parse_playlist(c, pls->url, pls, NULL);\n\n    /* If playback is already in progress (we are just selecting a new\n     * playlist) and this is a complete file, find the matching segment\n     * by counting durations. */\n    if (pls->finished && c->cur_timestamp != AV_NOPTS_VALUE) {\n        find_timestamp_in_playlist(c, pls, c->cur_timestamp, &seq_no);\n        return seq_no;\n    }\n\n    if (!pls->finished) {\n        if (!c->first_packet && /* we are doing a segment selection during playback */\n            c->cur_seq_no >= pls->start_seq_no &&\n            c->cur_seq_no < pls->start_seq_no + pls->n_segments)\n            /* While spec 3.4.3 says that we cannot assume anything about the\n             * content at the same sequence number on different playlists,\n             * in practice this seems to work and doing it otherwise would\n             * require us to download a segment to inspect its timestamps. */\n            return c->cur_seq_no;\n\n        /* If this is a live stream, start live_start_index segments from the\n         * start or end */\n        if (c->live_start_index < 0)\n            return pls->start_seq_no + FFMAX(pls->n_segments + c->live_start_index, 0);\n        else\n            return pls->start_seq_no + FFMIN(c->live_start_index, pls->n_segments - 1);\n    }\n\n    /* Otherwise just start on the first segment. */\n    return pls->start_seq_no;\n}\n\nstatic int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n\nstatic int nested_io_open(AVFormatContext *s, AVIOContext **pb, const char *url,\n                          int flags, AVDictionary **opts)\n{\n    av_log(s, AV_LOG_ERROR,\n           \"A HLS playlist item '%s' referred to an external file '%s'. \"\n           \"Opening this file was forbidden for security reasons\\n\",\n           s->filename, url);\n    return AVERROR(EPERM);\n}\n\nstatic void add_stream_to_programs(AVFormatContext *s, struct playlist *pls, AVStream *stream)\n{\n    HLSContext *c = s->priv_data;\n    int i, j;\n    int bandwidth = -1;\n\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n\n        for (j = 0; j < v->n_playlists; j++) {\n            if (v->playlists[j] != pls)\n                continue;\n\n            av_program_add_stream_index(s, i, stream->index);\n\n            if (bandwidth < 0)\n                bandwidth = v->bandwidth;\n            else if (bandwidth != v->bandwidth)\n                bandwidth = -1; /* stream in multiple variants with different bandwidths */\n        }\n    }\n\n    if (bandwidth >= 0)\n        av_dict_set_int(&stream->metadata, \"variant_bitrate\", bandwidth, 0);\n}\n\nstatic int set_stream_info_from_input_stream(AVStream *st, struct playlist *pls, AVStream *ist)\n{\n    int err;\n\n    err = avcodec_parameters_copy(st->codecpar, ist->codecpar);\n    if (err < 0)\n        return err;\n\n    if (pls->is_id3_timestamped) /* custom timestamps via id3 */\n        avpriv_set_pts_info(st, 33, 1, MPEG_TIME_BASE);\n    else\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n    st->internal->need_context_update = 1;\n\n    return 0;\n}\n\n/* add new subdemuxer streams to our context, if any */\nstatic int update_streams_from_subdemuxer(AVFormatContext *s, struct playlist *pls)\n{\n    int err;\n\n    while (pls->n_main_streams < pls->ctx->nb_streams) {\n        int ist_idx = pls->n_main_streams;\n        AVStream *st = avformat_new_stream(s, NULL);\n        AVStream *ist = pls->ctx->streams[ist_idx];\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = pls->index;\n        dynarray_add(&pls->main_streams, &pls->n_main_streams, st);\n\n        add_stream_to_programs(s, pls, st);\n\n        err = set_stream_info_from_input_stream(st, pls, ist);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic void update_noheader_flag(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    int flag_needed = 0;\n    int i;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->has_noheader_flag) {\n            flag_needed = 1;\n            break;\n        }\n    }\n\n    if (flag_needed)\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n    else\n        s->ctx_flags &= ~AVFMTCTX_NOHEADER;\n}\n\nstatic int hls_close(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n\n    av_dict_free(&c->avio_opts);\n\n    return 0;\n}\n\nstatic int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user_agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n        pls->ctx->flags   |= s->flags & ~AVFMT_FLAG_CUSTOM_IO;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    hls_close(s);\n    return ret;\n}\n\nstatic int recheck_discard_flags(AVFormatContext *s, int first)\n{\n    HLSContext *c = s->priv_data;\n    int i, changed = 0;\n\n    /* Check if any new streams are needed */\n    for (i = 0; i < c->n_playlists; i++)\n        c->playlists[i]->cur_needed = 0;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n        if (st->discard < AVDISCARD_ALL)\n            pls->cur_needed = 1;\n    }\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (pls->cur_needed && !pls->needed) {\n            pls->needed = 1;\n            changed = 1;\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n            pls->pb.eof_reached = 0;\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n                /* catch up */\n                pls->seek_timestamp = c->cur_timestamp;\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n                pls->seek_stream_index = -1;\n            }\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n        } else if (first && !pls->cur_needed && pls->needed) {\n            if (pls->input)\n                ff_format_io_close(pls->parent, &pls->input);\n            pls->needed = 0;\n            changed = 1;\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n        }\n    }\n    return changed;\n}\n\nstatic void fill_timing_for_id3_timestamped_stream(struct playlist *pls)\n{\n    if (pls->id3_offset >= 0) {\n        pls->pkt.dts = pls->id3_mpegts_timestamp +\n                                 av_rescale_q(pls->id3_offset,\n                                              pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                              MPEG_TIME_BASE_Q);\n        if (pls->pkt.duration)\n            pls->id3_offset += pls->pkt.duration;\n        else\n            pls->id3_offset = -1;\n    } else {\n        /* there have been packets with unknown duration\n         * since the last id3 tag, should not normally happen */\n        pls->pkt.dts = AV_NOPTS_VALUE;\n    }\n\n    if (pls->pkt.duration)\n        pls->pkt.duration = av_rescale_q(pls->pkt.duration,\n                                         pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                         MPEG_TIME_BASE_Q);\n\n    pls->pkt.pts = AV_NOPTS_VALUE;\n}\n\nstatic AVRational get_timebase(struct playlist *pls)\n{\n    if (pls->is_id3_timestamped)\n        return MPEG_TIME_BASE_Q;\n\n    return pls->ctx->streams[pls->pkt.stream_index]->time_base;\n}\n\nstatic int compare_ts_with_wrapdetect(int64_t ts_a, struct playlist *pls_a,\n                                      int64_t ts_b, struct playlist *pls_b)\n{\n    int64_t scaled_ts_a = av_rescale_q(ts_a, get_timebase(pls_a), MPEG_TIME_BASE_Q);\n    int64_t scaled_ts_b = av_rescale_q(ts_b, get_timebase(pls_b), MPEG_TIME_BASE_Q);\n\n    return av_compare_mod(scaled_ts_a, scaled_ts_b, 1LL << 33);\n}\n\nstatic int hls_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    HLSContext *c = s->priv_data;\n    int ret, i, minplaylist = -1;\n\n    recheck_discard_flags(s, c->first_packet);\n    c->first_packet = 0;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        /* Make sure we've got one buffered packet from each open playlist\n         * stream */\n        if (pls->needed && !pls->pkt.data) {\n            while (1) {\n                int64_t ts_diff;\n                AVRational tb;\n                ret = av_read_frame(pls->ctx, &pls->pkt);\n                if (ret < 0) {\n                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF)\n                        return ret;\n                    reset_packet(&pls->pkt);\n                    break;\n                } else {\n                    /* stream_index check prevents matching picture attachments etc. */\n                    if (pls->is_id3_timestamped && pls->pkt.stream_index == 0) {\n                        /* audio elementary streams are id3 timestamped */\n                        fill_timing_for_id3_timestamped_stream(pls);\n                    }\n\n                    if (c->first_timestamp == AV_NOPTS_VALUE &&\n                        pls->pkt.dts       != AV_NOPTS_VALUE)\n                        c->first_timestamp = av_rescale_q(pls->pkt.dts,\n                            get_timebase(pls), AV_TIME_BASE_Q);\n                }\n\n                if (pls->seek_timestamp == AV_NOPTS_VALUE)\n                    break;\n\n                if (pls->seek_stream_index < 0 ||\n                    pls->seek_stream_index == pls->pkt.stream_index) {\n\n                    if (pls->pkt.dts == AV_NOPTS_VALUE) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n\n                    tb = get_timebase(pls);\n                    ts_diff = av_rescale_rnd(pls->pkt.dts, AV_TIME_BASE,\n                                            tb.den, AV_ROUND_DOWN) -\n                            pls->seek_timestamp;\n                    if (ts_diff >= 0 && (pls->seek_flags  & AVSEEK_FLAG_ANY ||\n                                        pls->pkt.flags & AV_PKT_FLAG_KEY)) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n                }\n                av_packet_unref(&pls->pkt);\n                reset_packet(&pls->pkt);\n            }\n        }\n        /* Check if this stream has the packet with the lowest dts */\n        if (pls->pkt.data) {\n            struct playlist *minpls = minplaylist < 0 ?\n                                     NULL : c->playlists[minplaylist];\n            if (minplaylist < 0) {\n                minplaylist = i;\n            } else {\n                int64_t dts     =    pls->pkt.dts;\n                int64_t mindts  = minpls->pkt.dts;\n\n                if (dts == AV_NOPTS_VALUE ||\n                    (mindts != AV_NOPTS_VALUE && compare_ts_with_wrapdetect(dts, pls, mindts, minpls) < 0))\n                    minplaylist = i;\n            }\n        }\n    }\n\n    /* If we got a packet, return it */\n    if (minplaylist >= 0) {\n        struct playlist *pls = c->playlists[minplaylist];\n        AVStream *ist;\n        AVStream *st;\n\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0) {\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return ret;\n        }\n\n        /* check if noheader flag has been cleared by the subdemuxer */\n        if (pls->has_noheader_flag && !(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER)) {\n            pls->has_noheader_flag = 0;\n            update_noheader_flag(s);\n        }\n\n        if (pls->pkt.stream_index >= pls->n_main_streams) {\n            av_log(s, AV_LOG_ERROR, \"stream index inconsistency: index %d, %d main streams, %d subdemuxer streams\\n\",\n                   pls->pkt.stream_index, pls->n_main_streams, pls->ctx->nb_streams);\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return AVERROR_BUG;\n        }\n\n        ist = pls->ctx->streams[pls->pkt.stream_index];\n        st = pls->main_streams[pls->pkt.stream_index];\n\n        *pkt = pls->pkt;\n        pkt->stream_index = st->index;\n        reset_packet(&c->playlists[minplaylist]->pkt);\n\n        if (pkt->dts != AV_NOPTS_VALUE)\n            c->cur_timestamp = av_rescale_q(pkt->dts,\n                                            ist->time_base,\n                                            AV_TIME_BASE_Q);\n\n        /* There may be more situations where this would be useful, but this at least\n         * handles newly probed codecs properly (i.e. request_probe by mpegts). */\n        if (ist->codecpar->codec_id != st->codecpar->codec_id) {\n            ret = set_stream_info_from_input_stream(st, pls, ist);\n            if (ret < 0) {\n                av_packet_unref(pkt);\n                return ret;\n            }\n        }\n\n        return 0;\n    }\n    return AVERROR_EOF;\n}\n\nstatic int hls_read_seek(AVFormatContext *s, int stream_index,\n                               int64_t timestamp, int flags)\n{\n    HLSContext *c = s->priv_data;\n    struct playlist *seek_pls = NULL;\n    int i, seq_no;\n    int j;\n    int stream_subdemuxer_index;\n    int64_t first_timestamp, seek_timestamp, duration;\n\n    if ((flags & AVSEEK_FLAG_BYTE) ||\n        !(c->variants[0]->playlists[0]->finished || c->variants[0]->playlists[0]->type == PLS_TYPE_EVENT))\n        return AVERROR(ENOSYS);\n\n    first_timestamp = c->first_timestamp == AV_NOPTS_VALUE ?\n                      0 : c->first_timestamp;\n\n    seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE,\n                                    s->streams[stream_index]->time_base.den,\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n    duration = s->duration == AV_NOPTS_VALUE ?\n               0 : s->duration;\n\n    if (0 < duration && duration < seek_timestamp - first_timestamp)\n        return AVERROR(EIO);\n\n    /* find the playlist with the specified stream */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        for (j = 0; j < pls->n_main_streams; j++) {\n            if (pls->main_streams[j] == s->streams[stream_index]) {\n                seek_pls = pls;\n                stream_subdemuxer_index = j;\n                break;\n            }\n        }\n    }\n    /* check if the timestamp is valid for the playlist with the\n     * specified stream index */\n    if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no))\n        return AVERROR(EIO);\n\n    /* set segment now so we do not need to search again below */\n    seek_pls->cur_seq_no = seq_no;\n    seek_pls->seek_stream_index = stream_subdemuxer_index;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        /* Reset reading */\n        struct playlist *pls = c->playlists[i];\n        if (pls->input)\n            ff_format_io_close(pls->parent, &pls->input);\n        av_packet_unref(&pls->pkt);\n        reset_packet(&pls->pkt);\n        pls->pb.eof_reached = 0;\n        /* Clear any buffered data */\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n        pls->pb.pos = 0;\n        /* Flush the packet queue of the subdemuxer. */\n        ff_read_frame_flush(pls->ctx);\n\n        pls->seek_timestamp = seek_timestamp;\n        pls->seek_flags = flags;\n\n        if (pls != seek_pls) {\n            /* set closest segment seq_no for playlists not handled above */\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n            /* seek the playlist to the given position without taking\n             * keyframes into account since this playlist does not have the\n             * specified stream where we should look for the keyframes */\n            pls->seek_stream_index = -1;\n            pls->seek_flags |= AVSEEK_FLAG_ANY;\n        }\n    }\n\n    c->cur_timestamp = seek_timestamp;\n\n    return 0;\n}\n\nstatic int hls_probe(AVProbeData *p)\n{\n    /* Require #EXTM3U at the start, and either one of the ones below\n     * somewhere for a proper match. */\n    if (strncmp(p->buf, \"#EXTM3U\", 7))\n        return 0;\n\n    if (strstr(p->buf, \"#EXT-X-STREAM-INF:\")     ||\n        strstr(p->buf, \"#EXT-X-TARGETDURATION:\") ||\n        strstr(p->buf, \"#EXT-X-MEDIA-SEQUENCE:\"))\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(HLSContext, x)\n#define FLAGS AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption hls_options[] = {\n    {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",\n        OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},\n    {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",\n        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,\n        {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},\n        INT_MIN, INT_MAX, FLAGS},\n    {NULL}\n};\n\nstatic const AVClass hls_class = {\n    .class_name = \"hls,applehttp\",\n    .item_name  = av_default_item_name,\n    .option     = hls_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_hls_demuxer = {\n    .name           = \"hls,applehttp\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Apple HTTP Live Streaming\"),\n    .priv_class     = &hls_class,\n    .priv_data_size = sizeof(HLSContext),\n    .read_probe     = hls_probe,\n    .read_header    = hls_read_header,\n    .read_packet    = hls_read_packet,\n    .read_close     = hls_close,\n    .read_seek      = hls_read_seek,\n};\n"], "fixing_code": ["@chapter Demuxers\n@c man begin DEMUXERS\n\nDemuxers are configured elements in FFmpeg that can read the\nmultimedia streams from a particular type of file.\n\nWhen you configure your FFmpeg build, all the supported demuxers\nare enabled by default. You can list all available ones using the\nconfigure option @code{--list-demuxers}.\n\nYou can disable all the demuxers using the configure option\n@code{--disable-demuxers}, and selectively enable a single demuxer with\nthe option @code{--enable-demuxer=@var{DEMUXER}}, or disable it\nwith the option @code{--disable-demuxer=@var{DEMUXER}}.\n\nThe option @code{-demuxers} of the ff* tools will display the list of\nenabled demuxers. Use @code{-formats} to view a combined list of\nenabled demuxers and muxers.\n\nThe description of some of the currently available demuxers follows.\n\n@section aa\n\nAudible Format 2, 3, and 4 demuxer.\n\nThis demuxer is used to demux Audible Format 2, 3, and 4 (.aa) files.\n\n@section applehttp\n\nApple HTTP Live Streaming demuxer.\n\nThis demuxer presents all AVStreams from all variant streams.\nThe id field is set to the bitrate variant index number. By setting\nthe discard flags on AVStreams (by pressing 'a' or 'v' in ffplay),\nthe caller can decide which variant streams to actually receive.\nThe total bitrate of the variant that the stream belongs to is\navailable in a metadata key named \"variant_bitrate\".\n\n@section apng\n\nAnimated Portable Network Graphics demuxer.\n\nThis demuxer is used to demux APNG files.\nAll headers, but the PNG signature, up to (but not including) the first\nfcTL chunk are transmitted as extradata.\nFrames are then split as being all the chunks between two fcTL ones, or\nbetween the last fcTL and IEND chunks.\n\n@table @option\n@item -ignore_loop @var{bool}\nIgnore the loop variable in the file if set.\n@item -max_fps @var{int}\nMaximum framerate in frames per second (0 for no limit).\n@item -default_fps @var{int}\nDefault framerate in frames per second when none is specified in the file\n(0 meaning as fast as possible).\n@end table\n\n@section asf\n\nAdvanced Systems Format demuxer.\n\nThis demuxer is used to demux ASF files and MMS network streams.\n\n@table @option\n@item -no_resync_search @var{bool}\nDo not try to resynchronize by looking for a certain optional start code.\n@end table\n\n@anchor{concat}\n@section concat\n\nVirtual concatenation script demuxer.\n\nThis demuxer reads a list of files and other directives from a text file and\ndemuxes them one after the other, as if all their packets had been muxed\ntogether.\n\nThe timestamps in the files are adjusted so that the first file starts at 0\nand each next file starts where the previous one finishes. Note that it is\ndone globally and may cause gaps if all streams do not have exactly the same\nlength.\n\nAll files must have the same streams (same codecs, same time base, etc.).\n\nThe duration of each file is used to adjust the timestamps of the next file:\nif the duration is incorrect (because it was computed using the bit-rate or\nbecause the file is truncated, for example), it can cause artifacts. The\n@code{duration} directive can be used to override the duration stored in\neach file.\n\n@subsection Syntax\n\nThe script is a text file in extended-ASCII, with one directive per line.\nEmpty lines, leading spaces and lines starting with '#' are ignored. The\nfollowing directive is recognized:\n\n@table @option\n\n@item @code{file @var{path}}\nPath to a file to read; special characters and spaces must be escaped with\nbackslash or single quotes.\n\nAll subsequent file-related directives apply to that file.\n\n@item @code{ffconcat version 1.0}\nIdentify the script type and version. It also sets the @option{safe} option\nto 1 if it was -1.\n\nTo make FFmpeg recognize the format automatically, this directive must\nappear exactly as is (no extra space or byte-order-mark) on the very first\nline of the script.\n\n@item @code{duration @var{dur}}\nDuration of the file. This information can be specified from the file;\nspecifying it here may be more efficient or help if the information from the\nfile is not available or accurate.\n\nIf the duration is set for all files, then it is possible to seek in the\nwhole concatenated video.\n\n@item @code{inpoint @var{timestamp}}\nIn point of the file. When the demuxer opens the file it instantly seeks to the\nspecified timestamp. Seeking is done so that all streams can be presented\nsuccessfully at In point.\n\nThis directive works best with intra frame codecs, because for non-intra frame\nones you will usually get extra packets before the actual In point and the\ndecoded content will most likely contain frames before In point too.\n\nFor each file, packets before the file In point will have timestamps less than\nthe calculated start timestamp of the file (negative in case of the first\nfile), and the duration of the files (if not specified by the @code{duration}\ndirective) will be reduced based on their specified In point.\n\nBecause of potential packets before the specified In point, packet timestamps\nmay overlap between two concatenated files.\n\n@item @code{outpoint @var{timestamp}}\nOut point of the file. When the demuxer reaches the specified decoding\ntimestamp in any of the streams, it handles it as an end of file condition and\nskips the current and all the remaining packets from all streams.\n\nOut point is exclusive, which means that the demuxer will not output packets\nwith a decoding timestamp greater or equal to Out point.\n\nThis directive works best with intra frame codecs and formats where all streams\nare tightly interleaved. For non-intra frame codecs you will usually get\nadditional packets with presentation timestamp after Out point therefore the\ndecoded content will most likely contain frames after Out point too. If your\nstreams are not tightly interleaved you may not get all the packets from all\nstreams before Out point and you may only will be able to decode the earliest\nstream until Out point.\n\nThe duration of the files (if not specified by the @code{duration}\ndirective) will be reduced based on their specified Out point.\n\n@item @code{file_packet_metadata @var{key=value}}\nMetadata of the packets of the file. The specified metadata will be set for\neach file packet. You can specify this directive multiple times to add multiple\nmetadata entries.\n\n@item @code{stream}\nIntroduce a stream in the virtual file.\nAll subsequent stream-related directives apply to the last introduced\nstream.\nSome streams properties must be set in order to allow identifying the\nmatching streams in the subfiles.\nIf no streams are defined in the script, the streams from the first file are\ncopied.\n\n@item @code{exact_stream_id @var{id}}\nSet the id of the stream.\nIf this directive is given, the string with the corresponding id in the\nsubfiles will be used.\nThis is especially useful for MPEG-PS (VOB) files, where the order of the\nstreams is not reliable.\n\n@end table\n\n@subsection Options\n\nThis demuxer accepts the following option:\n\n@table @option\n\n@item safe\nIf set to 1, reject unsafe file paths. A file path is considered safe if it\ndoes not contain a protocol specification and is relative and all components\nonly contain characters from the portable character set (letters, digits,\nperiod, underscore and hyphen) and have no period at the beginning of a\ncomponent.\n\nIf set to 0, any file name is accepted.\n\nThe default is 1.\n\n-1 is equivalent to 1 if the format was automatically\nprobed and 0 otherwise.\n\n@item auto_convert\nIf set to 1, try to perform automatic conversions on packet data to make the\nstreams concatenable.\nThe default is 1.\n\nCurrently, the only conversion is adding the h264_mp4toannexb bitstream\nfilter to H.264 streams in MP4 format. This is necessary in particular if\nthere are resolution changes.\n\n@item segment_time_metadata\nIf set to 1, every packet will contain the @var{lavf.concat.start_time} and the\n@var{lavf.concat.duration} packet metadata values which are the start_time and\nthe duration of the respective file segments in the concatenated output\nexpressed in microseconds. The duration metadata is only set if it is known\nbased on the concat file.\nThe default is 0.\n\n@end table\n\n@subsection Examples\n\n@itemize\n@item\nUse absolute filenames and include some comments:\n@example\n# my first filename\nfile /mnt/share/file-1.wav\n# my second filename including whitespace\nfile '/mnt/share/file 2.wav'\n# my third filename including whitespace plus single quote\nfile '/mnt/share/file 3'\\''.wav'\n@end example\n\n@item\nAllow for input format auto-probing, use safe filenames and set the duration of\nthe first file:\n@example\nffconcat version 1.0\n\nfile file-1.wav\nduration 20.0\n\nfile subdir/file-2.wav\n@end example\n@end itemize\n\n@section flv, live_flv\n\nAdobe Flash Video Format demuxer.\n\nThis demuxer is used to demux FLV files and RTMP network streams. In case of live network streams, if you force format, you may use live_flv option instead of flv to survive timestamp discontinuities.\n\n@example\nffmpeg -f flv -i myfile.flv ...\nffmpeg -f live_flv -i rtmp://<any.server>/anything/key ....\n@end example\n\n\n@table @option\n@item -flv_metadata @var{bool}\nAllocate the streams according to the onMetaData array content.\n@end table\n\n@section gif\n\nAnimated GIF demuxer.\n\nIt accepts the following options:\n\n@table @option\n@item min_delay\nSet the minimum valid delay between frames in hundredths of seconds.\nRange is 0 to 6000. Default value is 2.\n\n@item max_gif_delay\nSet the maximum valid delay between frames in hundredth of seconds.\nRange is 0 to 65535. Default value is 65535 (nearly eleven minutes),\nthe maximum value allowed by the specification.\n\n@item default_delay\nSet the default delay between frames in hundredths of seconds.\nRange is 0 to 6000. Default value is 10.\n\n@item ignore_loop\nGIF files can contain information to loop a certain number of times (or\ninfinitely). If @option{ignore_loop} is set to 1, then the loop setting\nfrom the input will be ignored and looping will not occur. If set to 0,\nthen looping will occur and will cycle the number of times according to\nthe GIF. Default value is 1.\n@end table\n\nFor example, with the overlay filter, place an infinitely looping GIF\nover another video:\n@example\nffmpeg -i input.mp4 -ignore_loop 0 -i input.gif -filter_complex overlay=shortest=1 out.mkv\n@end example\n\nNote that in the above example the shortest option for overlay filter is\nused to end the output video at the length of the shortest input file,\nwhich in this case is @file{input.mp4} as the GIF in this example loops\ninfinitely.\n\n@section hls\n\nHLS demuxer\n\nIt accepts the following options:\n\n@table @option\n@item live_start_index\nsegment index to start live streams at (negative values are from the end).\n\n@item allowed_extensions\n',' separated list of file extensions that hls is allowed to access.\n\n@item max_reload\nMaximum number of times a insufficient list is attempted to be reloaded.\nDefault value is 1000.\n@end table\n\n@section image2\n\nImage file demuxer.\n\nThis demuxer reads from a list of image files specified by a pattern.\nThe syntax and meaning of the pattern is specified by the\noption @var{pattern_type}.\n\nThe pattern may contain a suffix which is used to automatically\ndetermine the format of the images contained in the files.\n\nThe size, the pixel format, and the format of each image must be the\nsame for all the files in the sequence.\n\nThis demuxer accepts the following options:\n@table @option\n@item framerate\nSet the frame rate for the video stream. It defaults to 25.\n@item loop\nIf set to 1, loop over the input. Default value is 0.\n@item pattern_type\nSelect the pattern type used to interpret the provided filename.\n\n@var{pattern_type} accepts one of the following values.\n@table @option\n@item none\nDisable pattern matching, therefore the video will only contain the specified\nimage. You should use this option if you do not want to create sequences from\nmultiple images and your filenames may contain special pattern characters.\n@item sequence\nSelect a sequence pattern type, used to specify a sequence of files\nindexed by sequential numbers.\n\nA sequence pattern may contain the string \"%d\" or \"%0@var{N}d\", which\nspecifies the position of the characters representing a sequential\nnumber in each filename matched by the pattern. If the form\n\"%d0@var{N}d\" is used, the string representing the number in each\nfilename is 0-padded and @var{N} is the total number of 0-padded\ndigits representing the number. The literal character '%' can be\nspecified in the pattern with the string \"%%\".\n\nIf the sequence pattern contains \"%d\" or \"%0@var{N}d\", the first filename of\nthe file list specified by the pattern must contain a number\ninclusively contained between @var{start_number} and\n@var{start_number}+@var{start_number_range}-1, and all the following\nnumbers must be sequential.\n\nFor example the pattern \"img-%03d.bmp\" will match a sequence of\nfilenames of the form @file{img-001.bmp}, @file{img-002.bmp}, ...,\n@file{img-010.bmp}, etc.; the pattern \"i%%m%%g-%d.jpg\" will match a\nsequence of filenames of the form @file{i%m%g-1.jpg},\n@file{i%m%g-2.jpg}, ..., @file{i%m%g-10.jpg}, etc.\n\nNote that the pattern must not necessarily contain \"%d\" or\n\"%0@var{N}d\", for example to convert a single image file\n@file{img.jpeg} you can employ the command:\n@example\nffmpeg -i img.jpeg img.png\n@end example\n\n@item glob\nSelect a glob wildcard pattern type.\n\nThe pattern is interpreted like a @code{glob()} pattern. This is only\nselectable if libavformat was compiled with globbing support.\n\n@item glob_sequence @emph{(deprecated, will be removed)}\nSelect a mixed glob wildcard/sequence pattern.\n\nIf your version of libavformat was compiled with globbing support, and\nthe provided pattern contains at least one glob meta character among\n@code{%*?[]@{@}} that is preceded by an unescaped \"%\", the pattern is\ninterpreted like a @code{glob()} pattern, otherwise it is interpreted\nlike a sequence pattern.\n\nAll glob special characters @code{%*?[]@{@}} must be prefixed\nwith \"%\". To escape a literal \"%\" you shall use \"%%\".\n\nFor example the pattern @code{foo-%*.jpeg} will match all the\nfilenames prefixed by \"foo-\" and terminating with \".jpeg\", and\n@code{foo-%?%?%?.jpeg} will match all the filenames prefixed with\n\"foo-\", followed by a sequence of three characters, and terminating\nwith \".jpeg\".\n\nThis pattern type is deprecated in favor of @var{glob} and\n@var{sequence}.\n@end table\n\nDefault value is @var{glob_sequence}.\n@item pixel_format\nSet the pixel format of the images to read. If not specified the pixel\nformat is guessed from the first image file in the sequence.\n@item start_number\nSet the index of the file matched by the image file pattern to start\nto read from. Default value is 0.\n@item start_number_range\nSet the index interval range to check when looking for the first image\nfile in the sequence, starting from @var{start_number}. Default value\nis 5.\n@item ts_from_file\nIf set to 1, will set frame timestamp to modification time of image file. Note\nthat monotonity of timestamps is not provided: images go in the same order as\nwithout this option. Default value is 0.\nIf set to 2, will set frame timestamp to the modification time of the image file in\nnanosecond precision.\n@item video_size\nSet the video size of the images to read. If not specified the video\nsize is guessed from the first image file in the sequence.\n@end table\n\n@subsection Examples\n\n@itemize\n@item\nUse @command{ffmpeg} for creating a video from the images in the file\nsequence @file{img-001.jpeg}, @file{img-002.jpeg}, ..., assuming an\ninput frame rate of 10 frames per second:\n@example\nffmpeg -framerate 10 -i 'img-%03d.jpeg' out.mkv\n@end example\n\n@item\nAs above, but start by reading from a file with index 100 in the sequence:\n@example\nffmpeg -framerate 10 -start_number 100 -i 'img-%03d.jpeg' out.mkv\n@end example\n\n@item\nRead images matching the \"*.png\" glob pattern , that is all the files\nterminating with the \".png\" suffix:\n@example\nffmpeg -framerate 10 -pattern_type glob -i \"*.png\" out.mkv\n@end example\n@end itemize\n\n@section libgme\n\nThe Game Music Emu library is a collection of video game music file emulators.\n\nSee @url{http://code.google.com/p/game-music-emu/} for more information.\n\nSome files have multiple tracks. The demuxer will pick the first track by\ndefault. The @option{track_index} option can be used to select a different\ntrack. Track indexes start at 0. The demuxer exports the number of tracks as\n@var{tracks} meta data entry.\n\nFor very large files, the @option{max_size} option may have to be adjusted.\n\n@section libopenmpt\n\nlibopenmpt based module demuxer\n\nSee @url{https://lib.openmpt.org/libopenmpt/} for more information.\n\nSome files have multiple subsongs (tracks) this can be set with the @option{subsong}\noption.\n\nIt accepts the following options:\n\n@table @option\n@item subsong\nSet the subsong index. This can be either  'all', 'auto', or the index of the\nsubsong. Subsong indexes start at 0. The default is 'auto'.\n\nThe default value is to let libopenmpt choose.\n\n@item layout\nSet the channel layout. Valid values are 1, 2, and 4 channel layouts.\nThe default value is STEREO.\n\n@item sample_rate\nSet the sample rate for libopenmpt to output.\nRange is from 1000 to INT_MAX. The value default is 48000.\n@end table\n\n@section mov/mp4/3gp/QuickTime\n\nQuickTime / MP4 demuxer.\n\nThis demuxer accepts the following options:\n@table @option\n@item enable_drefs\nEnable loading of external tracks, disabled by default.\nEnabling this can theoretically leak information in some use cases.\n\n@item use_absolute_path\nAllows loading of external tracks via absolute paths, disabled by default.\nEnabling this poses a security risk. It should only be enabled if the source\nis known to be non malicious.\n\n@end table\n\n@section mpegts\n\nMPEG-2 transport stream demuxer.\n\nThis demuxer accepts the following options:\n@table @option\n@item resync_size\nSet size limit for looking up a new synchronization. Default value is\n65536.\n\n@item fix_teletext_pts\nOverride teletext packet PTS and DTS values with the timestamps calculated\nfrom the PCR of the first program which the teletext stream is part of and is\nnot discarded. Default value is 1, set this option to 0 if you want your\nteletext packet PTS and DTS values untouched.\n\n@item ts_packetsize\nOutput option carrying the raw packet size in bytes.\nShow the detected raw packet size, cannot be set by the user.\n\n@item scan_all_pmts\nScan and combine all PMTs. The value is an integer with value from -1\nto 1 (-1 means automatic setting, 1 means enabled, 0 means\ndisabled). Default value is -1.\n@end table\n\n@section mpjpeg\n\nMJPEG encapsulated in multi-part MIME demuxer.\n\nThis demuxer allows reading of MJPEG, where each frame is represented as a part of\nmultipart/x-mixed-replace stream.\n@table @option\n\n@item strict_mime_boundary\nDefault implementation applies a relaxed standard to multi-part MIME boundary detection,\nto prevent regression with numerous existing endpoints not generating a proper MIME\nMJPEG stream. Turning this option on by setting it to 1 will result in a stricter check\nof the boundary value.\n@end table\n\n@section rawvideo\n\nRaw video demuxer.\n\nThis demuxer allows one to read raw video data. Since there is no header\nspecifying the assumed video parameters, the user must specify them\nin order to be able to decode the data correctly.\n\nThis demuxer accepts the following options:\n@table @option\n\n@item framerate\nSet input video frame rate. Default value is 25.\n\n@item pixel_format\nSet the input video pixel format. Default value is @code{yuv420p}.\n\n@item video_size\nSet the input video size. This value must be specified explicitly.\n@end table\n\nFor example to read a rawvideo file @file{input.raw} with\n@command{ffplay}, assuming a pixel format of @code{rgb24}, a video\nsize of @code{320x240}, and a frame rate of 10 images per second, use\nthe command:\n@example\nffplay -f rawvideo -pixel_format rgb24 -video_size 320x240 -framerate 10 input.raw\n@end example\n\n@section sbg\n\nSBaGen script demuxer.\n\nThis demuxer reads the script language used by SBaGen\n@url{http://uazu.net/sbagen/} to generate binaural beats sessions. A SBG\nscript looks like that:\n@example\n-SE\na: 300-2.5/3 440+4.5/0\nb: 300-2.5/0 440+4.5/3\noff: -\nNOW      == a\n+0:07:00 == b\n+0:14:00 == a\n+0:21:00 == b\n+0:30:00    off\n@end example\n\nA SBG script can mix absolute and relative timestamps. If the script uses\neither only absolute timestamps (including the script start time) or only\nrelative ones, then its layout is fixed, and the conversion is\nstraightforward. On the other hand, if the script mixes both kind of\ntimestamps, then the @var{NOW} reference for relative timestamps will be\ntaken from the current time of day at the time the script is read, and the\nscript layout will be frozen according to that reference. That means that if\nthe script is directly played, the actual times will match the absolute\ntimestamps up to the sound controller's clock accuracy, but if the user\nsomehow pauses the playback or seeks, all times will be shifted accordingly.\n\n@section tedcaptions\n\nJSON captions used for @url{http://www.ted.com/, TED Talks}.\n\nTED does not provide links to the captions, but they can be guessed from the\npage. The file @file{tools/bookmarklets.html} from the FFmpeg source tree\ncontains a bookmarklet to expose them.\n\nThis demuxer accepts the following option:\n@table @option\n@item start_time\nSet the start time of the TED talk, in milliseconds. The default is 15000\n(15s). It is used to sync the captions with the downloadable videos, because\nthey include a 15s intro.\n@end table\n\nExample: convert the captions to a format most players understand:\n@example\nffmpeg -i http://www.ted.com/talks/subtitles/id/1/lang/en talk1-en.srt\n@end example\n\n@c man end DEMUXERS\n", "/*\n * Apple HTTP Live Streaming demuxer\n * Copyright (c) 2010 Martin Storsjo\n * Copyright (c) 2013 Anssi Hannula\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Apple HTTP Live Streaming demuxer\n * http://tools.ietf.org/html/draft-pantos-http-live-streaming\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/time.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"id3v2.h\"\n\n#define INITIAL_BUFFER_SIZE 32768\n\n#define MAX_FIELD_LEN 64\n#define MAX_CHARACTERISTICS_LEN 512\n\n#define MPEG_TIME_BASE 90000\n#define MPEG_TIME_BASE_Q (AVRational){1, MPEG_TIME_BASE}\n\n/*\n * An apple http stream consists of a playlist with media segment files,\n * played sequentially. There may be several playlists with the same\n * video content, in different bandwidth variants, that are played in\n * parallel (preferably only one bandwidth variant at a time). In this case,\n * the user supplied the url to a main playlist that only lists the variant\n * playlists.\n *\n * If the main playlist doesn't point at any variants, we still create\n * one anonymous toplevel variant for this, to maintain the structure.\n */\n\nenum KeyType {\n    KEY_NONE,\n    KEY_AES_128,\n    KEY_SAMPLE_AES\n};\n\nstruct segment {\n    int64_t duration;\n    int64_t url_offset;\n    int64_t size;\n    char *url;\n    char *key;\n    enum KeyType key_type;\n    uint8_t iv[16];\n    /* associated Media Initialization Section, treated as a segment */\n    struct segment *init_section;\n};\n\nstruct rendition;\n\nenum PlaylistType {\n    PLS_TYPE_UNSPECIFIED,\n    PLS_TYPE_EVENT,\n    PLS_TYPE_VOD\n};\n\n/*\n * Each playlist has its own demuxer. If it currently is active,\n * it has an open AVIOContext too, and potentially an AVPacket\n * containing the next packet from this stream.\n */\nstruct playlist {\n    char url[MAX_URL_SIZE];\n    AVIOContext pb;\n    uint8_t* read_buffer;\n    AVIOContext *input;\n    AVFormatContext *parent;\n    int index;\n    AVFormatContext *ctx;\n    AVPacket pkt;\n    int has_noheader_flag;\n\n    /* main demuxer streams associated with this playlist\n     * indexed by the subdemuxer stream indexes */\n    AVStream **main_streams;\n    int n_main_streams;\n\n    int finished;\n    enum PlaylistType type;\n    int64_t target_duration;\n    int start_seq_no;\n    int n_segments;\n    struct segment **segments;\n    int needed, cur_needed;\n    int cur_seq_no;\n    int64_t cur_seg_offset;\n    int64_t last_load_time;\n\n    /* Currently active Media Initialization Section */\n    struct segment *cur_init_section;\n    uint8_t *init_sec_buf;\n    unsigned int init_sec_buf_size;\n    unsigned int init_sec_data_len;\n    unsigned int init_sec_buf_read_offset;\n\n    char key_url[MAX_URL_SIZE];\n    uint8_t key[16];\n\n    /* ID3 timestamp handling (elementary audio streams have ID3 timestamps\n     * (and possibly other ID3 tags) in the beginning of each segment) */\n    int is_id3_timestamped; /* -1: not yet known */\n    int64_t id3_mpegts_timestamp; /* in mpegts tb */\n    int64_t id3_offset; /* in stream original tb */\n    uint8_t* id3_buf; /* temp buffer for id3 parsing */\n    unsigned int id3_buf_size;\n    AVDictionary *id3_initial; /* data from first id3 tag */\n    int id3_found; /* ID3 tag found at some point */\n    int id3_changed; /* ID3 tag data has changed at some point */\n    ID3v2ExtraMeta *id3_deferred_extra; /* stored here until subdemuxer is opened */\n\n    int64_t seek_timestamp;\n    int seek_flags;\n    int seek_stream_index; /* into subdemuxer stream array */\n\n    /* Renditions associated with this playlist, if any.\n     * Alternative rendition playlists have a single rendition associated\n     * with them, and variant main Media Playlists may have\n     * multiple (playlist-less) renditions associated with them. */\n    int n_renditions;\n    struct rendition **renditions;\n\n    /* Media Initialization Sections (EXT-X-MAP) associated with this\n     * playlist, if any. */\n    int n_init_sections;\n    struct segment **init_sections;\n};\n\n/*\n * Renditions are e.g. alternative subtitle or audio streams.\n * The rendition may either be an external playlist or it may be\n * contained in the main Media Playlist of the variant (in which case\n * playlist is NULL).\n */\nstruct rendition {\n    enum AVMediaType type;\n    struct playlist *playlist;\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    int disposition;\n};\n\nstruct variant {\n    int bandwidth;\n\n    /* every variant contains at least the main Media Playlist in index 0 */\n    int n_playlists;\n    struct playlist **playlists;\n\n    char audio_group[MAX_FIELD_LEN];\n    char video_group[MAX_FIELD_LEN];\n    char subtitles_group[MAX_FIELD_LEN];\n};\n\ntypedef struct HLSContext {\n    AVClass *class;\n    AVFormatContext *ctx;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    char *http_proxy;                    ///< holds the address of the HTTP proxy server\n    AVDictionary *avio_opts;\n    int strict_std_compliance;\n    char *allowed_extensions;\n    int max_reload;\n} HLSContext;\n\nstatic int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n\nstatic void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_freep(&pls->segments[i]->key);\n        av_freep(&pls->segments[i]->url);\n        av_freep(&pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}\n\nstatic void free_init_section_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_init_sections; i++) {\n        av_freep(&pls->init_sections[i]->url);\n        av_freep(&pls->init_sections[i]);\n    }\n    av_freep(&pls->init_sections);\n    pls->n_init_sections = 0;\n}\n\nstatic void free_playlist_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        free_segment_list(pls);\n        free_init_section_list(pls);\n        av_freep(&pls->main_streams);\n        av_freep(&pls->renditions);\n        av_freep(&pls->id3_buf);\n        av_dict_free(&pls->id3_initial);\n        ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n        av_freep(&pls->init_sec_buf);\n        av_packet_unref(&pls->pkt);\n        av_freep(&pls->pb.buffer);\n        if (pls->input)\n            ff_format_io_close(c->ctx, &pls->input);\n        if (pls->ctx) {\n            pls->ctx->pb = NULL;\n            avformat_close_input(&pls->ctx);\n        }\n        av_free(pls);\n    }\n    av_freep(&c->playlists);\n    av_freep(&c->cookies);\n    av_freep(&c->user_agent);\n    av_freep(&c->headers);\n    av_freep(&c->http_proxy);\n    c->n_playlists = 0;\n}\n\nstatic void free_variant_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        av_freep(&var->playlists);\n        av_free(var);\n    }\n    av_freep(&c->variants);\n    c->n_variants = 0;\n}\n\nstatic void free_rendition_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_renditions; i++)\n        av_freep(&c->renditions[i]);\n    av_freep(&c->renditions);\n    c->n_renditions = 0;\n}\n\n/*\n * Used to reset a statically allocated AVPacket to a clean slate,\n * containing no data.\n */\nstatic void reset_packet(AVPacket *pkt)\n{\n    av_init_packet(pkt);\n    pkt->data = NULL;\n}\n\nstatic struct playlist *new_playlist(HLSContext *c, const char *url,\n                                     const char *base)\n{\n    struct playlist *pls = av_mallocz(sizeof(struct playlist));\n    if (!pls)\n        return NULL;\n    reset_packet(&pls->pkt);\n    ff_make_absolute_url(pls->url, sizeof(pls->url), base, url);\n    pls->seek_timestamp = AV_NOPTS_VALUE;\n\n    pls->is_id3_timestamped = -1;\n    pls->id3_mpegts_timestamp = AV_NOPTS_VALUE;\n\n    dynarray_add(&c->playlists, &c->n_playlists, pls);\n    return pls;\n}\n\nstruct variant_info {\n    char bandwidth[20];\n    /* variant group ids: */\n    char audio[MAX_FIELD_LEN];\n    char video[MAX_FIELD_LEN];\n    char subtitles[MAX_FIELD_LEN];\n};\n\nstatic struct variant *new_variant(HLSContext *c, struct variant_info *info,\n                                   const char *url, const char *base)\n{\n    struct variant *var;\n    struct playlist *pls;\n\n    pls = new_playlist(c, url, base);\n    if (!pls)\n        return NULL;\n\n    var = av_mallocz(sizeof(struct variant));\n    if (!var)\n        return NULL;\n\n    if (info) {\n        var->bandwidth = atoi(info->bandwidth);\n        strcpy(var->audio_group, info->audio);\n        strcpy(var->video_group, info->video);\n        strcpy(var->subtitles_group, info->subtitles);\n    }\n\n    dynarray_add(&c->variants, &c->n_variants, var);\n    dynarray_add(&var->playlists, &var->n_playlists, pls);\n    return var;\n}\n\nstatic void handle_variant_args(struct variant_info *info, const char *key,\n                                int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"BANDWIDTH=\", key_len)) {\n        *dest     =        info->bandwidth;\n        *dest_len = sizeof(info->bandwidth);\n    } else if (!strncmp(key, \"AUDIO=\", key_len)) {\n        *dest     =        info->audio;\n        *dest_len = sizeof(info->audio);\n    } else if (!strncmp(key, \"VIDEO=\", key_len)) {\n        *dest     =        info->video;\n        *dest_len = sizeof(info->video);\n    } else if (!strncmp(key, \"SUBTITLES=\", key_len)) {\n        *dest     =        info->subtitles;\n        *dest_len = sizeof(info->subtitles);\n    }\n}\n\nstruct key_info {\n     char uri[MAX_URL_SIZE];\n     char method[11];\n     char iv[35];\n};\n\nstatic void handle_key_args(struct key_info *info, const char *key,\n                            int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"METHOD=\", key_len)) {\n        *dest     =        info->method;\n        *dest_len = sizeof(info->method);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"IV=\", key_len)) {\n        *dest     =        info->iv;\n        *dest_len = sizeof(info->iv);\n    }\n}\n\nstruct init_section_info {\n    char uri[MAX_URL_SIZE];\n    char byterange[32];\n};\n\nstatic struct segment *new_init_section(struct playlist *pls,\n                                        struct init_section_info *info,\n                                        const char *url_base)\n{\n    struct segment *sec;\n    char *ptr;\n    char tmp_str[MAX_URL_SIZE];\n\n    if (!info->uri[0])\n        return NULL;\n\n    sec = av_mallocz(sizeof(*sec));\n    if (!sec)\n        return NULL;\n\n    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url_base, info->uri);\n    sec->url = av_strdup(tmp_str);\n    if (!sec->url) {\n        av_free(sec);\n        return NULL;\n    }\n\n    if (info->byterange[0]) {\n        sec->size = strtoll(info->byterange, NULL, 10);\n        ptr = strchr(info->byterange, '@');\n        if (ptr)\n            sec->url_offset = strtoll(ptr+1, NULL, 10);\n    } else {\n        /* the entire file is the init section */\n        sec->size = -1;\n    }\n\n    dynarray_add(&pls->init_sections, &pls->n_init_sections, sec);\n\n    return sec;\n}\n\nstatic void handle_init_section_args(struct init_section_info *info, const char *key,\n                                           int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"BYTERANGE=\", key_len)) {\n        *dest     =        info->byterange;\n        *dest_len = sizeof(info->byterange);\n    }\n}\n\nstruct rendition_info {\n    char type[16];\n    char uri[MAX_URL_SIZE];\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char assoc_language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    char defaultr[4];\n    char forced[4];\n    char characteristics[MAX_CHARACTERISTICS_LEN];\n};\n\nstatic struct rendition *new_rendition(HLSContext *c, struct rendition_info *info,\n                                      const char *url_base)\n{\n    struct rendition *rend;\n    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;\n    char *characteristic;\n    char *chr_ptr;\n    char *saveptr;\n\n    if (!strcmp(info->type, \"AUDIO\"))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!strcmp(info->type, \"VIDEO\"))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!strcmp(info->type, \"SUBTITLES\"))\n        type = AVMEDIA_TYPE_SUBTITLE;\n    else if (!strcmp(info->type, \"CLOSED-CAPTIONS\"))\n        /* CLOSED-CAPTIONS is ignored since we do not support CEA-608 CC in\n         * AVC SEI RBSP anyway */\n        return NULL;\n\n    if (type == AVMEDIA_TYPE_UNKNOWN)\n        return NULL;\n\n    /* URI is mandatory for subtitles as per spec */\n    if (type == AVMEDIA_TYPE_SUBTITLE && !info->uri[0])\n        return NULL;\n\n    /* TODO: handle subtitles (each segment has to parsed separately) */\n    if (c->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)\n        if (type == AVMEDIA_TYPE_SUBTITLE)\n            return NULL;\n\n    rend = av_mallocz(sizeof(struct rendition));\n    if (!rend)\n        return NULL;\n\n    dynarray_add(&c->renditions, &c->n_renditions, rend);\n\n    rend->type = type;\n    strcpy(rend->group_id, info->group_id);\n    strcpy(rend->language, info->language);\n    strcpy(rend->name, info->name);\n\n    /* add the playlist if this is an external rendition */\n    if (info->uri[0]) {\n        rend->playlist = new_playlist(c, info->uri, url_base);\n        if (rend->playlist)\n            dynarray_add(&rend->playlist->renditions,\n                         &rend->playlist->n_renditions, rend);\n    }\n\n    if (info->assoc_language[0]) {\n        int langlen = strlen(rend->language);\n        if (langlen < sizeof(rend->language) - 3) {\n            rend->language[langlen] = ',';\n            strncpy(rend->language + langlen + 1, info->assoc_language,\n                    sizeof(rend->language) - langlen - 2);\n        }\n    }\n\n    if (!strcmp(info->defaultr, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_DEFAULT;\n    if (!strcmp(info->forced, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_FORCED;\n\n    chr_ptr = info->characteristics;\n    while ((characteristic = av_strtok(chr_ptr, \",\", &saveptr))) {\n        if (!strcmp(characteristic, \"public.accessibility.describes-music-and-sound\"))\n            rend->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n        else if (!strcmp(characteristic, \"public.accessibility.describes-video\"))\n            rend->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n        chr_ptr = NULL;\n    }\n\n    return rend;\n}\n\nstatic void handle_rendition_args(struct rendition_info *info, const char *key,\n                                  int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"TYPE=\", key_len)) {\n        *dest     =        info->type;\n        *dest_len = sizeof(info->type);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"GROUP-ID=\", key_len)) {\n        *dest     =        info->group_id;\n        *dest_len = sizeof(info->group_id);\n    } else if (!strncmp(key, \"LANGUAGE=\", key_len)) {\n        *dest     =        info->language;\n        *dest_len = sizeof(info->language);\n    } else if (!strncmp(key, \"ASSOC-LANGUAGE=\", key_len)) {\n        *dest     =        info->assoc_language;\n        *dest_len = sizeof(info->assoc_language);\n    } else if (!strncmp(key, \"NAME=\", key_len)) {\n        *dest     =        info->name;\n        *dest_len = sizeof(info->name);\n    } else if (!strncmp(key, \"DEFAULT=\", key_len)) {\n        *dest     =        info->defaultr;\n        *dest_len = sizeof(info->defaultr);\n    } else if (!strncmp(key, \"FORCED=\", key_len)) {\n        *dest     =        info->forced;\n        *dest_len = sizeof(info->forced);\n    } else if (!strncmp(key, \"CHARACTERISTICS=\", key_len)) {\n        *dest     =        info->characteristics;\n        *dest_len = sizeof(info->characteristics);\n    }\n    /*\n     * ignored:\n     * - AUTOSELECT: client may autoselect based on e.g. system language\n     * - INSTREAM-ID: EIA-608 closed caption number (\"CC1\"..\"CC4\")\n     */\n}\n\n/* used by parse_playlist to allocate a new variant+playlist when the\n * playlist is detected to be a Media Playlist (not Master Playlist)\n * and we have no parent Master Playlist (parsing of which would have\n * allocated the variant and playlist already)\n * *pls == NULL  => Master Playlist or parentless Media Playlist\n * *pls != NULL => parented Media Playlist, playlist+variant allocated */\nstatic int ensure_playlist(HLSContext *c, struct playlist **pls, const char *url)\n{\n    if (*pls)\n        return 0;\n    if (!new_variant(c, NULL, url, NULL))\n        return AVERROR(ENOMEM);\n    *pls = c->playlists[c->n_playlists - 1];\n    return 0;\n}\n\nstatic void update_options(char **dest, const char *name, void *src)\n{\n    av_freep(dest);\n    av_opt_get(src, name, AV_OPT_SEARCH_CHILDREN, (uint8_t**)dest);\n    if (*dest && !strlen(*dest))\n        av_freep(dest);\n}\n\nstatic int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n\n    // only http(s) & file are allowed\n    if (av_strstart(proto_name, \"file\", NULL)) {\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n            av_log(s, AV_LOG_ERROR,\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n                url);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n        ;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        // update cookies on http response with setcookies.\n        char *new_cookies = NULL;\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n\n    av_dict_free(&tmp);\n\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n    return ret;\n}\n\nstatic int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n        av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n\n        ret = c->ctx->io_open(c->ctx, &in, url, AVIO_FLAG_READ, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = strtoll(ptr, NULL, 10);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = strtoll(ptr+1, NULL, 10);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        ff_format_io_close(c->ctx, &in);\n    return ret;\n}\n\nstatic struct segment *current_segment(struct playlist *pls)\n{\n    return pls->segments[pls->cur_seq_no - pls->start_seq_no];\n}\n\nenum ReadFromURLMode {\n    READ_NORMAL,\n    READ_COMPLETE,\n};\n\nstatic int read_from_url(struct playlist *pls, struct segment *seg,\n                         uint8_t *buf, int buf_size,\n                         enum ReadFromURLMode mode)\n{\n    int ret;\n\n     /* limit read if the segment was only a part of a file */\n    if (seg->size >= 0)\n        buf_size = FFMIN(buf_size, seg->size - pls->cur_seg_offset);\n\n    if (mode == READ_COMPLETE) {\n        ret = avio_read(pls->input, buf, buf_size);\n        if (ret != buf_size)\n            av_log(NULL, AV_LOG_ERROR, \"Could not read complete segment.\\n\");\n    } else\n        ret = avio_read(pls->input, buf, buf_size);\n\n    if (ret > 0)\n        pls->cur_seg_offset += ret;\n\n    return ret;\n}\n\n/* Parse the raw ID3 data and pass contents to caller */\nstatic void parse_id3(AVFormatContext *s, AVIOContext *pb,\n                      AVDictionary **metadata, int64_t *dts,\n                      ID3v2ExtraMetaAPIC **apic, ID3v2ExtraMeta **extra_meta)\n{\n    static const char id3_priv_owner_ts[] = \"com.apple.streaming.transportStreamTimestamp\";\n    ID3v2ExtraMeta *meta;\n\n    ff_id3v2_read_dict(pb, metadata, ID3v2_DEFAULT_MAGIC, extra_meta);\n    for (meta = *extra_meta; meta; meta = meta->next) {\n        if (!strcmp(meta->tag, \"PRIV\")) {\n            ID3v2ExtraMetaPRIV *priv = meta->data;\n            if (priv->datasize == 8 && !strcmp(priv->owner, id3_priv_owner_ts)) {\n                /* 33-bit MPEG timestamp */\n                int64_t ts = AV_RB64(priv->data);\n                av_log(s, AV_LOG_DEBUG, \"HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n                if ((ts & ~((1ULL << 33) - 1)) == 0)\n                    *dts = ts;\n                else\n                    av_log(s, AV_LOG_ERROR, \"Invalid HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n            }\n        } else if (!strcmp(meta->tag, \"APIC\") && apic)\n            *apic = meta->data;\n    }\n}\n\n/* Check if the ID3 metadata contents have changed */\nstatic int id3_has_changed_values(struct playlist *pls, AVDictionary *metadata,\n                                  ID3v2ExtraMetaAPIC *apic)\n{\n    AVDictionaryEntry *entry = NULL;\n    AVDictionaryEntry *oldentry;\n    /* check that no keys have changed values */\n    while ((entry = av_dict_get(metadata, \"\", entry, AV_DICT_IGNORE_SUFFIX))) {\n        oldentry = av_dict_get(pls->id3_initial, entry->key, NULL, AV_DICT_MATCH_CASE);\n        if (!oldentry || strcmp(oldentry->value, entry->value) != 0)\n            return 1;\n    }\n\n    /* check if apic appeared */\n    if (apic && (pls->ctx->nb_streams != 2 || !pls->ctx->streams[1]->attached_pic.data))\n        return 1;\n\n    if (apic) {\n        int size = pls->ctx->streams[1]->attached_pic.size;\n        if (size != apic->buf->size - AV_INPUT_BUFFER_PADDING_SIZE)\n            return 1;\n\n        if (memcmp(apic->buf->data, pls->ctx->streams[1]->attached_pic.data, size) != 0)\n            return 1;\n    }\n\n    return 0;\n}\n\n/* Parse ID3 data and handle the found data */\nstatic void handle_id3(AVIOContext *pb, struct playlist *pls)\n{\n    AVDictionary *metadata = NULL;\n    ID3v2ExtraMetaAPIC *apic = NULL;\n    ID3v2ExtraMeta *extra_meta = NULL;\n    int64_t timestamp = AV_NOPTS_VALUE;\n\n    parse_id3(pls->ctx, pb, &metadata, &timestamp, &apic, &extra_meta);\n\n    if (timestamp != AV_NOPTS_VALUE) {\n        pls->id3_mpegts_timestamp = timestamp;\n        pls->id3_offset = 0;\n    }\n\n    if (!pls->id3_found) {\n        /* initial ID3 tags */\n        av_assert0(!pls->id3_deferred_extra);\n        pls->id3_found = 1;\n\n        /* get picture attachment and set text metadata */\n        if (pls->ctx->nb_streams)\n            ff_id3v2_parse_apic(pls->ctx, &extra_meta);\n        else\n            /* demuxer not yet opened, defer picture attachment */\n            pls->id3_deferred_extra = extra_meta;\n\n        av_dict_copy(&pls->ctx->metadata, metadata, 0);\n        pls->id3_initial = metadata;\n\n    } else {\n        if (!pls->id3_changed && id3_has_changed_values(pls, metadata, apic)) {\n            avpriv_report_missing_feature(pls->ctx, \"Changing ID3 metadata in HLS audio elementary stream\");\n            pls->id3_changed = 1;\n        }\n        av_dict_free(&metadata);\n    }\n\n    if (!pls->id3_deferred_extra)\n        ff_id3v2_free_extra_meta(&extra_meta);\n}\n\nstatic void intercept_id3(struct playlist *pls, uint8_t *buf,\n                         int buf_size, int *len)\n{\n    /* intercept id3 tags, we do not want to pass them to the raw\n     * demuxer on all segment switches */\n    int bytes;\n    int id3_buf_pos = 0;\n    int fill_buf = 0;\n    struct segment *seg = current_segment(pls);\n\n    /* gather all the id3 tags */\n    while (1) {\n        /* see if we can retrieve enough data for ID3 header */\n        if (*len < ID3v2_HEADER_SIZE && buf_size >= ID3v2_HEADER_SIZE) {\n            bytes = read_from_url(pls, seg, buf + *len, ID3v2_HEADER_SIZE - *len, READ_COMPLETE);\n            if (bytes > 0) {\n\n                if (bytes == ID3v2_HEADER_SIZE - *len)\n                    /* no EOF yet, so fill the caller buffer again after\n                     * we have stripped the ID3 tags */\n                    fill_buf = 1;\n\n                *len += bytes;\n\n            } else if (*len <= 0) {\n                /* error/EOF */\n                *len = bytes;\n                fill_buf = 0;\n            }\n        }\n\n        if (*len < ID3v2_HEADER_SIZE)\n            break;\n\n        if (ff_id3v2_match(buf, ID3v2_DEFAULT_MAGIC)) {\n            int64_t maxsize = seg->size >= 0 ? seg->size : 1024*1024;\n            int taglen = ff_id3v2_tag_len(buf);\n            int tag_got_bytes = FFMIN(taglen, *len);\n            int remaining = taglen - tag_got_bytes;\n\n            if (taglen > maxsize) {\n                av_log(pls->ctx, AV_LOG_ERROR, \"Too large HLS ID3 tag (%d > %\"PRId64\" bytes)\\n\",\n                       taglen, maxsize);\n                break;\n            }\n\n            /*\n             * Copy the id3 tag to our temporary id3 buffer.\n             * We could read a small id3 tag directly without memcpy, but\n             * we would still need to copy the large tags, and handling\n             * both of those cases together with the possibility for multiple\n             * tags would make the handling a bit complex.\n             */\n            pls->id3_buf = av_fast_realloc(pls->id3_buf, &pls->id3_buf_size, id3_buf_pos + taglen);\n            if (!pls->id3_buf)\n                break;\n            memcpy(pls->id3_buf + id3_buf_pos, buf, tag_got_bytes);\n            id3_buf_pos += tag_got_bytes;\n\n            /* strip the intercepted bytes */\n            *len -= tag_got_bytes;\n            memmove(buf, buf + tag_got_bytes, *len);\n            av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped %d HLS ID3 bytes\\n\", tag_got_bytes);\n\n            if (remaining > 0) {\n                /* read the rest of the tag in */\n                if (read_from_url(pls, seg, pls->id3_buf + id3_buf_pos, remaining, READ_COMPLETE) != remaining)\n                    break;\n                id3_buf_pos += remaining;\n                av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped additional %d HLS ID3 bytes\\n\", remaining);\n            }\n\n        } else {\n            /* no more ID3 tags */\n            break;\n        }\n    }\n\n    /* re-fill buffer for the caller unless EOF */\n    if (*len >= 0 && (fill_buf || *len == 0)) {\n        bytes = read_from_url(pls, seg, buf + *len, buf_size - *len, READ_NORMAL);\n\n        /* ignore error if we already had some data */\n        if (bytes >= 0)\n            *len += bytes;\n        else if (*len == 0)\n            *len = bytes;\n    }\n\n    if (pls->id3_buf) {\n        /* Now parse all the ID3 tags */\n        AVIOContext id3ioctx;\n        ffio_init_context(&id3ioctx, pls->id3_buf, id3_buf_pos, 0, NULL, NULL, NULL, NULL);\n        handle_id3(&id3ioctx, pls);\n    }\n\n    if (pls->is_id3_timestamped == -1)\n        pls->is_id3_timestamped = (pls->id3_mpegts_timestamp != AV_NOPTS_VALUE);\n}\n\nstatic int open_input(HLSContext *c, struct playlist *pls, struct segment *seg)\n{\n    AVDictionary *opts = NULL;\n    int ret;\n    int is_http = 0;\n\n    // broker prior HTTP options that should be consistent across requests\n    av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n    av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    av_dict_set(&opts, \"headers\", c->headers, 0);\n    av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n    av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n    if (seg->size >= 0) {\n        /* try to restrict the HTTP request to the part we want\n         * (if this is in fact a HTTP request) */\n        av_dict_set_int(&opts, \"offset\", seg->url_offset, 0);\n        av_dict_set_int(&opts, \"end_offset\", seg->url_offset + seg->size, 0);\n    }\n\n    av_log(pls->parent, AV_LOG_VERBOSE, \"HLS request for url '%s', offset %\"PRId64\", playlist %d\\n\",\n           seg->url, seg->url_offset, pls->index);\n\n    if (seg->key_type == KEY_NONE) {\n        ret = open_url(pls->parent, &pls->input, seg->url, c->avio_opts, opts, &is_http);\n    } else if (seg->key_type == KEY_AES_128) {\n        AVDictionary *opts2 = NULL;\n        char iv[33], key[33], url[MAX_URL_SIZE];\n        if (strcmp(seg->key, pls->key_url)) {\n            AVIOContext *pb;\n            if (open_url(pls->parent, &pb, seg->key, c->avio_opts, opts, NULL) == 0) {\n                ret = avio_read(pb, pls->key, sizeof(pls->key));\n                if (ret != sizeof(pls->key)) {\n                    av_log(NULL, AV_LOG_ERROR, \"Unable to read key file %s\\n\",\n                           seg->key);\n                }\n                ff_format_io_close(pls->parent, &pb);\n            } else {\n                av_log(NULL, AV_LOG_ERROR, \"Unable to open key file %s\\n\",\n                       seg->key);\n            }\n            av_strlcpy(pls->key_url, seg->key, sizeof(pls->key_url));\n        }\n        ff_data_to_hex(iv, seg->iv, sizeof(seg->iv), 0);\n        ff_data_to_hex(key, pls->key, sizeof(pls->key), 0);\n        iv[32] = key[32] = '\\0';\n        if (strstr(seg->url, \"://\"))\n            snprintf(url, sizeof(url), \"crypto+%s\", seg->url);\n        else\n            snprintf(url, sizeof(url), \"crypto:%s\", seg->url);\n\n        av_dict_copy(&opts2, c->avio_opts, 0);\n        av_dict_set(&opts2, \"key\", key, 0);\n        av_dict_set(&opts2, \"iv\", iv, 0);\n\n        ret = open_url(pls->parent, &pls->input, url, opts2, opts, &is_http);\n\n        av_dict_free(&opts2);\n\n        if (ret < 0) {\n            goto cleanup;\n        }\n        ret = 0;\n    } else if (seg->key_type == KEY_SAMPLE_AES) {\n        av_log(pls->parent, AV_LOG_ERROR,\n               \"SAMPLE-AES encryption is not supported yet\\n\");\n        ret = AVERROR_PATCHWELCOME;\n    }\n    else\n      ret = AVERROR(ENOSYS);\n\n    /* Seek to the requested position. If this was a HTTP request, the offset\n     * should already be where want it to, but this allows e.g. local testing\n     * without a HTTP server.\n     *\n     * This is not done for HTTP at all as avio_seek() does internal bookkeeping\n     * of file offset which is out-of-sync with the actual offset when \"offset\"\n     * AVOption is used with http protocol, causing the seek to not be a no-op\n     * as would be expected. Wrong offset received from the server will not be\n     * noticed without the call, though.\n     */\n    if (ret == 0 && !is_http && seg->key_type == KEY_NONE && seg->url_offset) {\n        int64_t seekret = avio_seek(pls->input, seg->url_offset, SEEK_SET);\n        if (seekret < 0) {\n            av_log(pls->parent, AV_LOG_ERROR, \"Unable to seek to offset %\"PRId64\" of HLS segment '%s'\\n\", seg->url_offset, seg->url);\n            ret = seekret;\n            ff_format_io_close(pls->parent, &pls->input);\n        }\n    }\n\ncleanup:\n    av_dict_free(&opts);\n    pls->cur_seg_offset = 0;\n    return ret;\n}\n\nstatic int update_init_section(struct playlist *pls, struct segment *seg)\n{\n    static const int max_init_section_size = 1024*1024;\n    HLSContext *c = pls->parent->priv_data;\n    int64_t sec_size;\n    int64_t urlsize;\n    int ret;\n\n    if (seg->init_section == pls->cur_init_section)\n        return 0;\n\n    pls->cur_init_section = NULL;\n\n    if (!seg->init_section)\n        return 0;\n\n    ret = open_input(c, pls, seg->init_section);\n    if (ret < 0) {\n        av_log(pls->parent, AV_LOG_WARNING,\n               \"Failed to open an initialization section in playlist %d\\n\",\n               pls->index);\n        return ret;\n    }\n\n    if (seg->init_section->size >= 0)\n        sec_size = seg->init_section->size;\n    else if ((urlsize = avio_size(pls->input)) >= 0)\n        sec_size = urlsize;\n    else\n        sec_size = max_init_section_size;\n\n    av_log(pls->parent, AV_LOG_DEBUG,\n           \"Downloading an initialization section of size %\"PRId64\"\\n\",\n           sec_size);\n\n    sec_size = FFMIN(sec_size, max_init_section_size);\n\n    av_fast_malloc(&pls->init_sec_buf, &pls->init_sec_buf_size, sec_size);\n\n    ret = read_from_url(pls, seg->init_section, pls->init_sec_buf,\n                        pls->init_sec_buf_size, READ_COMPLETE);\n    ff_format_io_close(pls->parent, &pls->input);\n\n    if (ret < 0)\n        return ret;\n\n    pls->cur_init_section = seg->init_section;\n    pls->init_sec_data_len = ret;\n    pls->init_sec_buf_read_offset = 0;\n\n    /* spec says audio elementary streams do not have media initialization\n     * sections, so there should be no ID3 timestamps */\n    pls->is_id3_timestamped = 0;\n\n    return 0;\n}\n\nstatic int64_t default_reload_interval(struct playlist *pls)\n{\n    return pls->n_segments > 0 ?\n                          pls->segments[pls->n_segments - 1]->duration :\n                          pls->target_duration;\n}\n\nstatic int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n    int reload_count = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        reload_count++;\n        if (reload_count > c->max_reload)\n            return AVERROR_EOF;\n        if (!v->finished &&\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n\nstatic void add_renditions_to_variant(HLSContext *c, struct variant *var,\n                                      enum AVMediaType type, const char *group_id)\n{\n    int i;\n\n    for (i = 0; i < c->n_renditions; i++) {\n        struct rendition *rend = c->renditions[i];\n\n        if (rend->type == type && !strcmp(rend->group_id, group_id)) {\n\n            if (rend->playlist)\n                /* rendition is an external playlist\n                 * => add the playlist to the variant */\n                dynarray_add(&var->playlists, &var->n_playlists, rend->playlist);\n            else\n                /* rendition is part of the variant main Media Playlist\n                 * => add the rendition to the main Media Playlist */\n                dynarray_add(&var->playlists[0]->renditions,\n                             &var->playlists[0]->n_renditions,\n                             rend);\n        }\n    }\n}\n\nstatic void add_metadata_from_renditions(AVFormatContext *s, struct playlist *pls,\n                                         enum AVMediaType type)\n{\n    int rend_idx = 0;\n    int i;\n\n    for (i = 0; i < pls->n_main_streams; i++) {\n        AVStream *st = pls->main_streams[i];\n\n        if (st->codecpar->codec_type != type)\n            continue;\n\n        for (; rend_idx < pls->n_renditions; rend_idx++) {\n            struct rendition *rend = pls->renditions[rend_idx];\n\n            if (rend->type != type)\n                continue;\n\n            if (rend->language[0])\n                av_dict_set(&st->metadata, \"language\", rend->language, 0);\n            if (rend->name[0])\n                av_dict_set(&st->metadata, \"comment\", rend->name, 0);\n\n            st->disposition |= rend->disposition;\n        }\n        if (rend_idx >=pls->n_renditions)\n            break;\n    }\n}\n\n/* if timestamp was in valid range: returns 1 and sets seq_no\n * if not: returns 0 and sets seq_no to closest segment */\nstatic int find_timestamp_in_playlist(HLSContext *c, struct playlist *pls,\n                                      int64_t timestamp, int *seq_no)\n{\n    int i;\n    int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ?\n                  0 : c->first_timestamp;\n\n    if (timestamp < pos) {\n        *seq_no = pls->start_seq_no;\n        return 0;\n    }\n\n    for (i = 0; i < pls->n_segments; i++) {\n        int64_t diff = pos + pls->segments[i]->duration - timestamp;\n        if (diff > 0) {\n            *seq_no = pls->start_seq_no + i;\n            return 1;\n        }\n        pos += pls->segments[i]->duration;\n    }\n\n    *seq_no = pls->start_seq_no + pls->n_segments - 1;\n\n    return 0;\n}\n\nstatic int select_cur_seq_no(HLSContext *c, struct playlist *pls)\n{\n    int seq_no;\n\n    if (!pls->finished && !c->first_packet &&\n        av_gettime_relative() - pls->last_load_time >= default_reload_interval(pls))\n        /* reload the playlist since it was suspended */\n        parse_playlist(c, pls->url, pls, NULL);\n\n    /* If playback is already in progress (we are just selecting a new\n     * playlist) and this is a complete file, find the matching segment\n     * by counting durations. */\n    if (pls->finished && c->cur_timestamp != AV_NOPTS_VALUE) {\n        find_timestamp_in_playlist(c, pls, c->cur_timestamp, &seq_no);\n        return seq_no;\n    }\n\n    if (!pls->finished) {\n        if (!c->first_packet && /* we are doing a segment selection during playback */\n            c->cur_seq_no >= pls->start_seq_no &&\n            c->cur_seq_no < pls->start_seq_no + pls->n_segments)\n            /* While spec 3.4.3 says that we cannot assume anything about the\n             * content at the same sequence number on different playlists,\n             * in practice this seems to work and doing it otherwise would\n             * require us to download a segment to inspect its timestamps. */\n            return c->cur_seq_no;\n\n        /* If this is a live stream, start live_start_index segments from the\n         * start or end */\n        if (c->live_start_index < 0)\n            return pls->start_seq_no + FFMAX(pls->n_segments + c->live_start_index, 0);\n        else\n            return pls->start_seq_no + FFMIN(c->live_start_index, pls->n_segments - 1);\n    }\n\n    /* Otherwise just start on the first segment. */\n    return pls->start_seq_no;\n}\n\nstatic int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n\nstatic int nested_io_open(AVFormatContext *s, AVIOContext **pb, const char *url,\n                          int flags, AVDictionary **opts)\n{\n    av_log(s, AV_LOG_ERROR,\n           \"A HLS playlist item '%s' referred to an external file '%s'. \"\n           \"Opening this file was forbidden for security reasons\\n\",\n           s->filename, url);\n    return AVERROR(EPERM);\n}\n\nstatic void add_stream_to_programs(AVFormatContext *s, struct playlist *pls, AVStream *stream)\n{\n    HLSContext *c = s->priv_data;\n    int i, j;\n    int bandwidth = -1;\n\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n\n        for (j = 0; j < v->n_playlists; j++) {\n            if (v->playlists[j] != pls)\n                continue;\n\n            av_program_add_stream_index(s, i, stream->index);\n\n            if (bandwidth < 0)\n                bandwidth = v->bandwidth;\n            else if (bandwidth != v->bandwidth)\n                bandwidth = -1; /* stream in multiple variants with different bandwidths */\n        }\n    }\n\n    if (bandwidth >= 0)\n        av_dict_set_int(&stream->metadata, \"variant_bitrate\", bandwidth, 0);\n}\n\nstatic int set_stream_info_from_input_stream(AVStream *st, struct playlist *pls, AVStream *ist)\n{\n    int err;\n\n    err = avcodec_parameters_copy(st->codecpar, ist->codecpar);\n    if (err < 0)\n        return err;\n\n    if (pls->is_id3_timestamped) /* custom timestamps via id3 */\n        avpriv_set_pts_info(st, 33, 1, MPEG_TIME_BASE);\n    else\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n    st->internal->need_context_update = 1;\n\n    return 0;\n}\n\n/* add new subdemuxer streams to our context, if any */\nstatic int update_streams_from_subdemuxer(AVFormatContext *s, struct playlist *pls)\n{\n    int err;\n\n    while (pls->n_main_streams < pls->ctx->nb_streams) {\n        int ist_idx = pls->n_main_streams;\n        AVStream *st = avformat_new_stream(s, NULL);\n        AVStream *ist = pls->ctx->streams[ist_idx];\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = pls->index;\n        dynarray_add(&pls->main_streams, &pls->n_main_streams, st);\n\n        add_stream_to_programs(s, pls, st);\n\n        err = set_stream_info_from_input_stream(st, pls, ist);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic void update_noheader_flag(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    int flag_needed = 0;\n    int i;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->has_noheader_flag) {\n            flag_needed = 1;\n            break;\n        }\n    }\n\n    if (flag_needed)\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n    else\n        s->ctx_flags &= ~AVFMTCTX_NOHEADER;\n}\n\nstatic int hls_close(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n\n    av_dict_free(&c->avio_opts);\n\n    return 0;\n}\n\nstatic int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user_agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n        pls->ctx->flags   |= s->flags & ~AVFMT_FLAG_CUSTOM_IO;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    hls_close(s);\n    return ret;\n}\n\nstatic int recheck_discard_flags(AVFormatContext *s, int first)\n{\n    HLSContext *c = s->priv_data;\n    int i, changed = 0;\n\n    /* Check if any new streams are needed */\n    for (i = 0; i < c->n_playlists; i++)\n        c->playlists[i]->cur_needed = 0;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n        if (st->discard < AVDISCARD_ALL)\n            pls->cur_needed = 1;\n    }\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (pls->cur_needed && !pls->needed) {\n            pls->needed = 1;\n            changed = 1;\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n            pls->pb.eof_reached = 0;\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n                /* catch up */\n                pls->seek_timestamp = c->cur_timestamp;\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n                pls->seek_stream_index = -1;\n            }\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n        } else if (first && !pls->cur_needed && pls->needed) {\n            if (pls->input)\n                ff_format_io_close(pls->parent, &pls->input);\n            pls->needed = 0;\n            changed = 1;\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n        }\n    }\n    return changed;\n}\n\nstatic void fill_timing_for_id3_timestamped_stream(struct playlist *pls)\n{\n    if (pls->id3_offset >= 0) {\n        pls->pkt.dts = pls->id3_mpegts_timestamp +\n                                 av_rescale_q(pls->id3_offset,\n                                              pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                              MPEG_TIME_BASE_Q);\n        if (pls->pkt.duration)\n            pls->id3_offset += pls->pkt.duration;\n        else\n            pls->id3_offset = -1;\n    } else {\n        /* there have been packets with unknown duration\n         * since the last id3 tag, should not normally happen */\n        pls->pkt.dts = AV_NOPTS_VALUE;\n    }\n\n    if (pls->pkt.duration)\n        pls->pkt.duration = av_rescale_q(pls->pkt.duration,\n                                         pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                         MPEG_TIME_BASE_Q);\n\n    pls->pkt.pts = AV_NOPTS_VALUE;\n}\n\nstatic AVRational get_timebase(struct playlist *pls)\n{\n    if (pls->is_id3_timestamped)\n        return MPEG_TIME_BASE_Q;\n\n    return pls->ctx->streams[pls->pkt.stream_index]->time_base;\n}\n\nstatic int compare_ts_with_wrapdetect(int64_t ts_a, struct playlist *pls_a,\n                                      int64_t ts_b, struct playlist *pls_b)\n{\n    int64_t scaled_ts_a = av_rescale_q(ts_a, get_timebase(pls_a), MPEG_TIME_BASE_Q);\n    int64_t scaled_ts_b = av_rescale_q(ts_b, get_timebase(pls_b), MPEG_TIME_BASE_Q);\n\n    return av_compare_mod(scaled_ts_a, scaled_ts_b, 1LL << 33);\n}\n\nstatic int hls_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    HLSContext *c = s->priv_data;\n    int ret, i, minplaylist = -1;\n\n    recheck_discard_flags(s, c->first_packet);\n    c->first_packet = 0;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        /* Make sure we've got one buffered packet from each open playlist\n         * stream */\n        if (pls->needed && !pls->pkt.data) {\n            while (1) {\n                int64_t ts_diff;\n                AVRational tb;\n                ret = av_read_frame(pls->ctx, &pls->pkt);\n                if (ret < 0) {\n                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF)\n                        return ret;\n                    reset_packet(&pls->pkt);\n                    break;\n                } else {\n                    /* stream_index check prevents matching picture attachments etc. */\n                    if (pls->is_id3_timestamped && pls->pkt.stream_index == 0) {\n                        /* audio elementary streams are id3 timestamped */\n                        fill_timing_for_id3_timestamped_stream(pls);\n                    }\n\n                    if (c->first_timestamp == AV_NOPTS_VALUE &&\n                        pls->pkt.dts       != AV_NOPTS_VALUE)\n                        c->first_timestamp = av_rescale_q(pls->pkt.dts,\n                            get_timebase(pls), AV_TIME_BASE_Q);\n                }\n\n                if (pls->seek_timestamp == AV_NOPTS_VALUE)\n                    break;\n\n                if (pls->seek_stream_index < 0 ||\n                    pls->seek_stream_index == pls->pkt.stream_index) {\n\n                    if (pls->pkt.dts == AV_NOPTS_VALUE) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n\n                    tb = get_timebase(pls);\n                    ts_diff = av_rescale_rnd(pls->pkt.dts, AV_TIME_BASE,\n                                            tb.den, AV_ROUND_DOWN) -\n                            pls->seek_timestamp;\n                    if (ts_diff >= 0 && (pls->seek_flags  & AVSEEK_FLAG_ANY ||\n                                        pls->pkt.flags & AV_PKT_FLAG_KEY)) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n                }\n                av_packet_unref(&pls->pkt);\n                reset_packet(&pls->pkt);\n            }\n        }\n        /* Check if this stream has the packet with the lowest dts */\n        if (pls->pkt.data) {\n            struct playlist *minpls = minplaylist < 0 ?\n                                     NULL : c->playlists[minplaylist];\n            if (minplaylist < 0) {\n                minplaylist = i;\n            } else {\n                int64_t dts     =    pls->pkt.dts;\n                int64_t mindts  = minpls->pkt.dts;\n\n                if (dts == AV_NOPTS_VALUE ||\n                    (mindts != AV_NOPTS_VALUE && compare_ts_with_wrapdetect(dts, pls, mindts, minpls) < 0))\n                    minplaylist = i;\n            }\n        }\n    }\n\n    /* If we got a packet, return it */\n    if (minplaylist >= 0) {\n        struct playlist *pls = c->playlists[minplaylist];\n        AVStream *ist;\n        AVStream *st;\n\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0) {\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return ret;\n        }\n\n        /* check if noheader flag has been cleared by the subdemuxer */\n        if (pls->has_noheader_flag && !(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER)) {\n            pls->has_noheader_flag = 0;\n            update_noheader_flag(s);\n        }\n\n        if (pls->pkt.stream_index >= pls->n_main_streams) {\n            av_log(s, AV_LOG_ERROR, \"stream index inconsistency: index %d, %d main streams, %d subdemuxer streams\\n\",\n                   pls->pkt.stream_index, pls->n_main_streams, pls->ctx->nb_streams);\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return AVERROR_BUG;\n        }\n\n        ist = pls->ctx->streams[pls->pkt.stream_index];\n        st = pls->main_streams[pls->pkt.stream_index];\n\n        *pkt = pls->pkt;\n        pkt->stream_index = st->index;\n        reset_packet(&c->playlists[minplaylist]->pkt);\n\n        if (pkt->dts != AV_NOPTS_VALUE)\n            c->cur_timestamp = av_rescale_q(pkt->dts,\n                                            ist->time_base,\n                                            AV_TIME_BASE_Q);\n\n        /* There may be more situations where this would be useful, but this at least\n         * handles newly probed codecs properly (i.e. request_probe by mpegts). */\n        if (ist->codecpar->codec_id != st->codecpar->codec_id) {\n            ret = set_stream_info_from_input_stream(st, pls, ist);\n            if (ret < 0) {\n                av_packet_unref(pkt);\n                return ret;\n            }\n        }\n\n        return 0;\n    }\n    return AVERROR_EOF;\n}\n\nstatic int hls_read_seek(AVFormatContext *s, int stream_index,\n                               int64_t timestamp, int flags)\n{\n    HLSContext *c = s->priv_data;\n    struct playlist *seek_pls = NULL;\n    int i, seq_no;\n    int j;\n    int stream_subdemuxer_index;\n    int64_t first_timestamp, seek_timestamp, duration;\n\n    if ((flags & AVSEEK_FLAG_BYTE) ||\n        !(c->variants[0]->playlists[0]->finished || c->variants[0]->playlists[0]->type == PLS_TYPE_EVENT))\n        return AVERROR(ENOSYS);\n\n    first_timestamp = c->first_timestamp == AV_NOPTS_VALUE ?\n                      0 : c->first_timestamp;\n\n    seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE,\n                                    s->streams[stream_index]->time_base.den,\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n    duration = s->duration == AV_NOPTS_VALUE ?\n               0 : s->duration;\n\n    if (0 < duration && duration < seek_timestamp - first_timestamp)\n        return AVERROR(EIO);\n\n    /* find the playlist with the specified stream */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        for (j = 0; j < pls->n_main_streams; j++) {\n            if (pls->main_streams[j] == s->streams[stream_index]) {\n                seek_pls = pls;\n                stream_subdemuxer_index = j;\n                break;\n            }\n        }\n    }\n    /* check if the timestamp is valid for the playlist with the\n     * specified stream index */\n    if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no))\n        return AVERROR(EIO);\n\n    /* set segment now so we do not need to search again below */\n    seek_pls->cur_seq_no = seq_no;\n    seek_pls->seek_stream_index = stream_subdemuxer_index;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        /* Reset reading */\n        struct playlist *pls = c->playlists[i];\n        if (pls->input)\n            ff_format_io_close(pls->parent, &pls->input);\n        av_packet_unref(&pls->pkt);\n        reset_packet(&pls->pkt);\n        pls->pb.eof_reached = 0;\n        /* Clear any buffered data */\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n        pls->pb.pos = 0;\n        /* Flush the packet queue of the subdemuxer. */\n        ff_read_frame_flush(pls->ctx);\n\n        pls->seek_timestamp = seek_timestamp;\n        pls->seek_flags = flags;\n\n        if (pls != seek_pls) {\n            /* set closest segment seq_no for playlists not handled above */\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n            /* seek the playlist to the given position without taking\n             * keyframes into account since this playlist does not have the\n             * specified stream where we should look for the keyframes */\n            pls->seek_stream_index = -1;\n            pls->seek_flags |= AVSEEK_FLAG_ANY;\n        }\n    }\n\n    c->cur_timestamp = seek_timestamp;\n\n    return 0;\n}\n\nstatic int hls_probe(AVProbeData *p)\n{\n    /* Require #EXTM3U at the start, and either one of the ones below\n     * somewhere for a proper match. */\n    if (strncmp(p->buf, \"#EXTM3U\", 7))\n        return 0;\n\n    if (strstr(p->buf, \"#EXT-X-STREAM-INF:\")     ||\n        strstr(p->buf, \"#EXT-X-TARGETDURATION:\") ||\n        strstr(p->buf, \"#EXT-X-MEDIA-SEQUENCE:\"))\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(HLSContext, x)\n#define FLAGS AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption hls_options[] = {\n    {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",\n        OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},\n    {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",\n        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,\n        {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},\n        INT_MIN, INT_MAX, FLAGS},\n    {\"max_reload\", \"Maximum number of times a insufficient list is attempted to be reloaded\",\n        OFFSET(max_reload), AV_OPT_TYPE_INT, {.i64 = 1000}, 0, INT_MAX, FLAGS},\n    {NULL}\n};\n\nstatic const AVClass hls_class = {\n    .class_name = \"hls,applehttp\",\n    .item_name  = av_default_item_name,\n    .option     = hls_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_hls_demuxer = {\n    .name           = \"hls,applehttp\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Apple HTTP Live Streaming\"),\n    .priv_class     = &hls_class,\n    .priv_data_size = sizeof(HLSContext),\n    .read_probe     = hls_probe,\n    .read_header    = hls_read_header,\n    .read_packet    = hls_read_packet,\n    .read_close     = hls_close,\n    .read_seek      = hls_read_seek,\n};\n"], "filenames": ["doc/demuxers.texi", "libavformat/hls.c"], "buggy_code_start_loc": [301, 207], "buggy_code_end_loc": [301, 2152], "fixing_code_start_loc": [302, 208], "fixing_code_end_loc": [320, 2160], "type": "CWE-835", "message": "In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).", "other": {"cve": {"id": "CVE-2017-14058", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T15:29:00.450", "lastModified": "2020-12-29T21:15:12.743", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop)."}, {"lang": "es", "value": "En FFmpeg versiones 2.4 y 3.3.3, la funci\u00f3n read_data en libavformat/hls.c no restringe los intentos de recarga de una lista insuficiente, lo que permite a los atacantes remotos causar una denegaci\u00f3n de servicio (bucle infinito)"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100629", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7ba100d3e6e8b1e5d5342feb960a7f081d6e15af", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7ec414892ddcad88313848494b6fc5f437c9ca4a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00041.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7ec414892ddcad88313848494b6fc5f437c9ca4a"}}