{"buggy_code": ["[package]\nname = \"evm\"\nversion = \"0.41.0\"\nlicense = \"Apache-2.0\"\nauthors = [\"Wei Tang <hi@that.world>\", \"Parity Technologies <admin@parity.io>\"]\ndescription = \"SputnikVM - a Portable Blockchain Virtual Machine\"\nrepository = \"https://github.com/sorpaas/rust-evm\"\nkeywords = [\"no_std\", \"ethereum\"]\nedition = \"2018\"\n\n[dependencies]\nauto_impl = \"1.0\"\nethereum = { version = \"0.15\", default-features = false }\nlog = { version = \"0.4\", default-features = false }\nprimitive-types = { version = \"0.12\", default-features = false, features = [\"rlp\"] }\nrlp = { version = \"0.5\", default-features = false }\nsha3 = { version = \"0.10\", default-features = false }\n\n# Optional dependencies\nenvironmental = { version = \"1.1.2\", default-features = false, optional = true }\nscale-codec = { package = \"parity-scale-codec\", version = \"3.2\", default-features = false, features = [\"derive\"], optional = true }\nscale-info = { version = \"2.3\", default-features = false, features = [\"derive\"], optional = true }\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"], optional = true }\n\nevm-core = { version = \"0.41\", path = \"core\", default-features = false }\nevm-gasometer = { version = \"0.41\", path = \"gasometer\", default-features = false }\nevm-runtime = { version = \"0.41\", path = \"runtime\", default-features = false }\n\n[dev-dependencies]\ncriterion = \"0.4\"\nhex = \"0.4\"\n\n[[bench]]\nname = \"loop\"\nharness = false\n\n[features]\ndefault = [\"std\"]\nstd = [\n\t\"ethereum/std\",\n\t\"log/std\",\n\t\"primitive-types/std\",\n\t\"rlp/std\",\n\t\"sha3/std\",\n\t\"environmental/std\",\n\t\"scale-codec/std\",\n\t\"scale-info/std\",\n\t\"serde/std\",\n\t\"evm-core/std\",\n\t\"evm-gasometer/std\",\n\t\"evm-runtime/std\",\n]\nwith-codec = [\n\t\"scale-codec\",\n\t\"scale-info\",\n\t\"primitive-types/codec\",\n\t\"primitive-types/scale-info\",\n\t\"ethereum/with-codec\",\n\t\"evm-core/with-codec\",\n]\nwith-serde = [\n\t\"serde\",\n\t\"primitive-types/impl-serde\",\n\t\"evm-core/with-serde\",\n\t\"ethereum/with-serde\",\n]\ntracing = [\n\t\"environmental\",\n\t\"evm-gasometer/tracing\",\n\t\"evm-runtime/tracing\",\n]\nforce-debug = [\n\t\"evm-core/force-debug\",\n\t\"evm-gasometer/force-debug\",\n]\n\n[workspace]\nmembers = [\n\t\"core\",\n\t\"gasometer\",\n\t\"runtime\",\n\t\"fuzzer\",\n]\n", "use crate::backend::Backend;\nuse crate::executor::stack::precompile::{\n\tIsPrecompileResult, PrecompileFailure, PrecompileHandle, PrecompileOutput, PrecompileSet,\n};\nuse crate::executor::stack::tagged_runtime::{RuntimeKind, TaggedRuntime};\nuse crate::gasometer::{self, Gasometer, StorageTarget};\nuse crate::maybe_borrowed::MaybeBorrowed;\nuse crate::{\n\tCapture, Config, Context, CreateScheme, ExitError, ExitReason, Handler, Opcode, Runtime, Stack,\n\tTransfer,\n};\nuse alloc::{collections::BTreeSet, rc::Rc, vec::Vec};\nuse core::{cmp::min, convert::Infallible};\nuse evm_core::ExitFatal;\nuse evm_runtime::Resolve;\nuse primitive_types::{H160, H256, U256};\nuse sha3::{Digest, Keccak256};\n\nmacro_rules! emit_exit {\n\t($reason:expr) => {{\n\t\tlet reason = $reason;\n\t\tevent!(Exit {\n\t\t\treason: &reason,\n\t\t\treturn_value: &Vec::new(),\n\t\t});\n\t\treason\n\t}};\n\t($reason:expr, $return_value:expr) => {{\n\t\tlet reason = $reason;\n\t\tlet return_value = $return_value;\n\t\tevent!(Exit {\n\t\t\treason: &reason,\n\t\t\treturn_value: &return_value,\n\t\t});\n\t\t(reason, return_value)\n\t}};\n}\n\nconst DEFAULT_CALL_STACK_CAPACITY: usize = 4;\n\npub enum StackExitKind {\n\tSucceeded,\n\tReverted,\n\tFailed,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct Accessed {\n\tpub accessed_addresses: BTreeSet<H160>,\n\tpub accessed_storage: BTreeSet<(H160, H256)>,\n}\n\nimpl Accessed {\n\tpub fn access_address(&mut self, address: H160) {\n\t\tself.accessed_addresses.insert(address);\n\t}\n\n\tpub fn access_addresses<I>(&mut self, addresses: I)\n\twhere\n\t\tI: Iterator<Item = H160>,\n\t{\n\t\tfor address in addresses {\n\t\t\tself.accessed_addresses.insert(address);\n\t\t}\n\t}\n\n\tpub fn access_storages<I>(&mut self, storages: I)\n\twhere\n\t\tI: Iterator<Item = (H160, H256)>,\n\t{\n\t\tfor storage in storages {\n\t\t\tself.accessed_storage.insert((storage.0, storage.1));\n\t\t}\n\t}\n}\n\n#[derive(Clone, Debug)]\npub struct StackSubstateMetadata<'config> {\n\tgasometer: Gasometer<'config>,\n\tis_static: bool,\n\tdepth: Option<usize>,\n\taccessed: Option<Accessed>,\n}\n\nimpl<'config> StackSubstateMetadata<'config> {\n\tpub fn new(gas_limit: u64, config: &'config Config) -> Self {\n\t\tlet accessed = if config.increase_state_access_gas {\n\t\t\tSome(Accessed::default())\n\t\t} else {\n\t\t\tNone\n\t\t};\n\t\tSelf {\n\t\t\tgasometer: Gasometer::new(gas_limit, config),\n\t\t\tis_static: false,\n\t\t\tdepth: None,\n\t\t\taccessed,\n\t\t}\n\t}\n\n\tpub fn swallow_commit(&mut self, other: Self) -> Result<(), ExitError> {\n\t\tself.gasometer.record_stipend(other.gasometer.gas())?;\n\t\tself.gasometer\n\t\t\t.record_refund(other.gasometer.refunded_gas())?;\n\n\t\tif let (Some(mut other_accessed), Some(self_accessed)) =\n\t\t\t(other.accessed, self.accessed.as_mut())\n\t\t{\n\t\t\tself_accessed\n\t\t\t\t.accessed_addresses\n\t\t\t\t.append(&mut other_accessed.accessed_addresses);\n\t\t\tself_accessed\n\t\t\t\t.accessed_storage\n\t\t\t\t.append(&mut other_accessed.accessed_storage);\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tpub fn swallow_revert(&mut self, other: Self) -> Result<(), ExitError> {\n\t\tself.gasometer.record_stipend(other.gasometer.gas())?;\n\n\t\tOk(())\n\t}\n\n\tpub fn swallow_discard(&mut self, _other: Self) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tpub fn spit_child(&self, gas_limit: u64, is_static: bool) -> Self {\n\t\tSelf {\n\t\t\tgasometer: Gasometer::new(gas_limit, self.gasometer.config()),\n\t\t\tis_static: is_static || self.is_static,\n\t\t\tdepth: match self.depth {\n\t\t\t\tNone => Some(0),\n\t\t\t\tSome(n) => Some(n + 1),\n\t\t\t},\n\t\t\taccessed: self.accessed.as_ref().map(|_| Accessed::default()),\n\t\t}\n\t}\n\n\tpub fn gasometer(&self) -> &Gasometer<'config> {\n\t\t&self.gasometer\n\t}\n\n\tpub fn gasometer_mut(&mut self) -> &mut Gasometer<'config> {\n\t\t&mut self.gasometer\n\t}\n\n\tpub fn is_static(&self) -> bool {\n\t\tself.is_static\n\t}\n\n\tpub fn depth(&self) -> Option<usize> {\n\t\tself.depth\n\t}\n\n\tpub fn access_address(&mut self, address: H160) {\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_address(address)\n\t\t}\n\t}\n\n\tpub fn access_addresses<I>(&mut self, addresses: I)\n\twhere\n\t\tI: Iterator<Item = H160>,\n\t{\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_addresses(addresses);\n\t\t}\n\t}\n\n\tpub fn access_storage(&mut self, address: H160, key: H256) {\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.accessed_storage.insert((address, key));\n\t\t}\n\t}\n\n\tpub fn access_storages<I>(&mut self, storages: I)\n\twhere\n\t\tI: Iterator<Item = (H160, H256)>,\n\t{\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_storages(storages);\n\t\t}\n\t}\n\n\tpub fn accessed(&self) -> &Option<Accessed> {\n\t\t&self.accessed\n\t}\n}\n\n#[auto_impl::auto_impl(&mut, Box)]\npub trait StackState<'config>: Backend {\n\tfn metadata(&self) -> &StackSubstateMetadata<'config>;\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config>;\n\n\tfn enter(&mut self, gas_limit: u64, is_static: bool);\n\tfn exit_commit(&mut self) -> Result<(), ExitError>;\n\tfn exit_revert(&mut self) -> Result<(), ExitError>;\n\tfn exit_discard(&mut self) -> Result<(), ExitError>;\n\n\tfn is_empty(&self, address: H160) -> bool;\n\tfn deleted(&self, address: H160) -> bool;\n\tfn is_cold(&self, address: H160) -> bool;\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool;\n\n\tfn inc_nonce(&mut self, address: H160) -> Result<(), ExitError>;\n\tfn set_storage(&mut self, address: H160, key: H256, value: H256);\n\tfn reset_storage(&mut self, address: H160);\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>);\n\tfn set_deleted(&mut self, address: H160);\n\tfn set_code(&mut self, address: H160, code: Vec<u8>);\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError>;\n\tfn reset_balance(&mut self, address: H160);\n\tfn touch(&mut self, address: H160);\n\n\t/// Fetch the code size of an address.\n\t/// Provide a default implementation by fetching the code, but\n\t/// can be customized to use a more performant approach that don't need to\n\t/// fetch the code.\n\tfn code_size(&self, address: H160) -> U256 {\n\t\tU256::from(self.code(address).len())\n\t}\n\n\t/// Fetch the code hash of an address.\n\t/// Provide a default implementation by fetching the code, but\n\t/// can be customized to use a more performant approach that don't need to\n\t/// fetch the code.\n\tfn code_hash(&self, address: H160) -> H256 {\n\t\tH256::from_slice(Keccak256::digest(self.code(address)).as_slice())\n\t}\n\n\tfn record_external_operation(\n\t\t&mut self,\n\t\t_op: crate::ExternalOperation,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn record_external_dynamic_opcode_cost(\n\t\t&mut self,\n\t\t_opcode: Opcode,\n\t\t_gas_cost: crate::gasometer::GasCost,\n\t\t_target: StorageTarget,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn record_external_cost(\n\t\t&mut self,\n\t\t_ref_time: Option<u64>,\n\t\t_proof_size: Option<u64>,\n\t\t_storage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn refund_external_cost(&mut self, _ref_time: Option<u64>, _proof_size: Option<u64>) {}\n}\n\n/// Stack-based executor.\npub struct StackExecutor<'config, 'precompiles, S, P> {\n\tconfig: &'config Config,\n\tstate: S,\n\tprecompile_set: &'precompiles P,\n}\n\nimpl<'config, 'precompiles, S: StackState<'config>, P: PrecompileSet>\n\tStackExecutor<'config, 'precompiles, S, P>\n{\n\t/// Return a reference of the Config.\n\tpub fn config(&self) -> &'config Config {\n\t\tself.config\n\t}\n\n\t/// Return a reference to the precompile set.\n\tpub fn precompiles(&self) -> &'precompiles P {\n\t\tself.precompile_set\n\t}\n\n\t/// Create a new stack-based executor with given precompiles.\n\tpub fn new_with_precompiles(\n\t\tstate: S,\n\t\tconfig: &'config Config,\n\t\tprecompile_set: &'precompiles P,\n\t) -> Self {\n\t\tSelf {\n\t\t\tconfig,\n\t\t\tstate,\n\t\t\tprecompile_set,\n\t\t}\n\t}\n\n\tpub fn state(&self) -> &S {\n\t\t&self.state\n\t}\n\n\tpub fn state_mut(&mut self) -> &mut S {\n\t\t&mut self.state\n\t}\n\n\tpub fn into_state(self) -> S {\n\t\tself.state\n\t}\n\n\t/// Create a substate executor from the current executor.\n\tpub fn enter_substate(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.state.enter(gas_limit, is_static);\n\t}\n\n\t/// Exit a substate. Panic if it results an empty substate stack.\n\tpub fn exit_substate(&mut self, kind: StackExitKind) -> Result<(), ExitError> {\n\t\tmatch kind {\n\t\t\tStackExitKind::Succeeded => self.state.exit_commit(),\n\t\t\tStackExitKind::Reverted => self.state.exit_revert(),\n\t\t\tStackExitKind::Failed => self.state.exit_discard(),\n\t\t}\n\t}\n\n\t/// Execute the runtime until it returns.\n\tpub fn execute(&mut self, runtime: &mut Runtime) -> ExitReason {\n\t\tlet mut call_stack = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\tcall_stack.push(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Execute,\n\t\t\tinner: MaybeBorrowed::Borrowed(runtime),\n\t\t});\n\t\tlet (reason, _, _) = self.execute_with_call_stack(&mut call_stack);\n\t\treason\n\t}\n\n\t/// Execute using Runtimes on the call_stack until it returns.\n\tfn execute_with_call_stack(\n\t\t&mut self,\n\t\tcall_stack: &mut Vec<TaggedRuntime<'_>>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\t// This `interrupt_runtime` is used to pass the runtime obtained from the\n\t\t// `Capture::Trap` branch in the match below back to the top of the call stack.\n\t\t// The reason we can't simply `push` the runtime directly onto the stack in the\n\t\t// `Capture::Trap` branch is because the borrow-checker complains that the stack\n\t\t// is already borrowed as long as we hold a pointer on the last element\n\t\t// (i.e. the currently executing runtime).\n\t\tlet mut interrupt_runtime = None;\n\t\tloop {\n\t\t\tif let Some(rt) = interrupt_runtime.take() {\n\t\t\t\tcall_stack.push(rt);\n\t\t\t}\n\t\t\tlet runtime = match call_stack.last_mut() {\n\t\t\t\tSome(runtime) => runtime,\n\t\t\t\tNone => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tExitReason::Fatal(ExitFatal::UnhandledInterrupt),\n\t\t\t\t\t\tNone,\n\t\t\t\t\t\tVec::new(),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet reason = {\n\t\t\t\tlet inner_runtime = &mut runtime.inner;\n\t\t\t\tmatch inner_runtime.run(self) {\n\t\t\t\t\tCapture::Exit(reason) => reason,\n\t\t\t\t\tCapture::Trap(Resolve::Call(rt, _)) => {\n\t\t\t\t\t\tinterrupt_runtime = Some(rt.0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCapture::Trap(Resolve::Create(rt, _)) => {\n\t\t\t\t\t\tinterrupt_runtime = Some(rt.0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet runtime_kind = runtime.kind;\n\t\t\tlet (reason, maybe_address, return_data) = match runtime_kind {\n\t\t\t\tRuntimeKind::Create(created_address) => {\n\t\t\t\t\tlet (reason, maybe_address, return_data) = self.cleanup_for_create(\n\t\t\t\t\t\tcreated_address,\n\t\t\t\t\t\treason,\n\t\t\t\t\t\truntime.inner.machine().return_value(),\n\t\t\t\t\t);\n\t\t\t\t\t(reason, maybe_address, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Call(code_address) => {\n\t\t\t\t\tlet return_data = self.cleanup_for_call(\n\t\t\t\t\t\tcode_address,\n\t\t\t\t\t\t&reason,\n\t\t\t\t\t\truntime.inner.machine().return_value(),\n\t\t\t\t\t);\n\t\t\t\t\t(reason, None, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Execute => (reason, None, runtime.inner.machine().return_value()),\n\t\t\t};\n\t\t\t// We're done with that runtime now, so can pop it off the call stack\n\t\t\tcall_stack.pop();\n\t\t\t// Now pass the results from that runtime on to the next one in the stack\n\t\t\tlet runtime = match call_stack.last_mut() {\n\t\t\t\tSome(r) => r,\n\t\t\t\tNone => return (reason, None, return_data),\n\t\t\t};\n\t\t\temit_exit!(&reason, &return_data);\n\t\t\tlet inner_runtime = &mut runtime.inner;\n\t\t\tlet maybe_error = match runtime_kind {\n\t\t\t\tRuntimeKind::Create(_) => {\n\t\t\t\t\tinner_runtime.finish_create(reason, maybe_address, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Call(_) => inner_runtime.finish_call(reason, return_data),\n\t\t\t\tRuntimeKind::Execute => inner_runtime.finish_call(reason, return_data),\n\t\t\t};\n\t\t\t// Early exit if passing on the result caused an error\n\t\t\tif let Err(e) = maybe_error {\n\t\t\t\treturn (e, None, Vec::new());\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Get remaining gas.\n\tpub fn gas(&self) -> u64 {\n\t\tself.state.metadata().gasometer.gas()\n\t}\n\n\tfn record_create_transaction_cost(\n\t\t&mut self,\n\t\tinit_code: &[u8],\n\t\taccess_list: &[(H160, Vec<H256>)],\n\t) -> Result<(), ExitError> {\n\t\tlet transaction_cost = gasometer::create_transaction_cost(init_code, access_list);\n\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\tgasometer.record_transaction(transaction_cost)\n\t}\n\n\tfn maybe_record_init_code_cost(&mut self, init_code: &[u8]) -> Result<(), ExitError> {\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\t// EIP-3860\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn Err(ExitError::CreateContractLimit);\n\t\t\t}\n\t\t\treturn self\n\t\t\t\t.state\n\t\t\t\t.metadata_mut()\n\t\t\t\t.gasometer\n\t\t\t\t.record_cost(gasometer::init_code_cost(init_code));\n\t\t}\n\t\tOk(())\n\t}\n\n\t/// Execute a `CREATE` transaction.\n\tpub fn transact_create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n\t) -> (ExitReason, Vec<u8>) {\n\t\tevent!(TransactCreate {\n\t\t\tcaller,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\tgas_limit,\n\t\t\taddress: self.create_address(CreateScheme::Legacy { caller }),\n\t\t});\n\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn emit_exit!(ExitError::CreateContractLimit.into(), Vec::new());\n\t\t\t}\n\t\t}\n\n\t\tif let Err(e) = self.record_create_transaction_cost(&init_code, &access_list) {\n\t\t\treturn emit_exit!(e.into(), Vec::new());\n\t\t}\n\t\tself.initialize_with_access_list(access_list);\n\n\t\tmatch self.create_inner(\n\t\t\tcaller,\n\t\t\tCreateScheme::Legacy { caller },\n\t\t\tvalue,\n\t\t\tinit_code,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t) {\n\t\t\tCapture::Exit((s, _, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Execute a `CREATE2` transaction.\n\tpub fn transact_create2(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\tsalt: H256,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n\t) -> (ExitReason, Vec<u8>) {\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn emit_exit!(ExitError::CreateContractLimit.into(), Vec::new());\n\t\t\t}\n\t\t}\n\n\t\tlet code_hash = H256::from_slice(Keccak256::digest(&init_code).as_slice());\n\t\tevent!(TransactCreate2 {\n\t\t\tcaller,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\tsalt,\n\t\t\tgas_limit,\n\t\t\taddress: self.create_address(CreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t}),\n\t\t});\n\n\t\tif let Err(e) = self.record_create_transaction_cost(&init_code, &access_list) {\n\t\t\treturn emit_exit!(e.into(), Vec::new());\n\t\t}\n\t\tself.initialize_with_access_list(access_list);\n\n\t\tmatch self.create_inner(\n\t\t\tcaller,\n\t\t\tCreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t},\n\t\t\tvalue,\n\t\t\tinit_code,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t) {\n\t\t\tCapture::Exit((s, _, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Execute a `CALL` transaction with a given caller, address, value and\n\t/// gas limit and data.\n\t///\n\t/// Takes in an additional `access_list` parameter for EIP-2930 which was\n\t/// introduced in the Ethereum Berlin hard fork. If you do not wish to use\n\t/// this functionality, just pass in an empty vector.\n\tpub fn transact_call(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\taddress: H160,\n\t\tvalue: U256,\n\t\tdata: Vec<u8>,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t) -> (ExitReason, Vec<u8>) {\n\t\tevent!(TransactCall {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tvalue,\n\t\t\tdata: &data,\n\t\t\tgas_limit,\n\t\t});\n\n\t\tlet transaction_cost = gasometer::call_transaction_cost(&data, &access_list);\n\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\tmatch gasometer.record_transaction(transaction_cost) {\n\t\t\tOk(()) => (),\n\t\t\tErr(e) => return emit_exit!(e.into(), Vec::new()),\n\t\t}\n\n\t\t// Initialize initial addresses for EIP-2929\n\t\tif self.config.increase_state_access_gas {\n\t\t\tif self.config.warm_coinbase_address {\n\t\t\t\t// Warm coinbase address for EIP-3651\n\t\t\t\tlet addresses = core::iter::once(caller)\n\t\t\t\t\t.chain(core::iter::once(address))\n\t\t\t\t\t.chain(core::iter::once(self.block_coinbase()));\n\t\t\t\tself.state.metadata_mut().access_addresses(addresses);\n\t\t\t} else {\n\t\t\t\tlet addresses = core::iter::once(caller).chain(core::iter::once(address));\n\t\t\t\tself.state.metadata_mut().access_addresses(addresses);\n\t\t\t}\n\n\t\t\tself.initialize_with_access_list(access_list);\n\t\t}\n\t\tif let Err(e) = self.record_external_operation(crate::ExternalOperation::AccountBasicRead) {\n\t\t\treturn (e.into(), Vec::new());\n\t\t}\n\t\tif let Err(e) = self.state.inc_nonce(caller) {\n\t\t\treturn (e.into(), Vec::new());\n\t\t}\n\n\t\tlet context = Context {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tapparent_value: value,\n\t\t};\n\n\t\tmatch self.call_inner(\n\t\t\taddress,\n\t\t\tSome(Transfer {\n\t\t\t\tsource: caller,\n\t\t\t\ttarget: address,\n\t\t\t\tvalue,\n\t\t\t}),\n\t\t\tdata,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tcontext,\n\t\t) {\n\t\t\tCapture::Exit((s, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Get used gas for the current executor, given the price.\n\tpub fn used_gas(&self) -> u64 {\n\t\tself.state.metadata().gasometer.total_used_gas()\n\t\t\t- min(\n\t\t\t\tself.state.metadata().gasometer.total_used_gas() / self.config.max_refund_quotient,\n\t\t\t\tself.state.metadata().gasometer.refunded_gas() as u64,\n\t\t\t)\n\t}\n\n\t/// Get fee needed for the current executor, given the price.\n\tpub fn fee(&self, price: U256) -> U256 {\n\t\tlet used_gas = self.used_gas();\n\t\tU256::from(used_gas).saturating_mul(price)\n\t}\n\n\t/// Get account nonce.\n\tpub fn nonce(&self, address: H160) -> U256 {\n\t\tself.state.basic(address).nonce\n\t}\n\n\t/// Get the create address from given scheme.\n\tpub fn create_address(&self, scheme: CreateScheme) -> H160 {\n\t\tmatch scheme {\n\t\t\tCreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t} => {\n\t\t\t\tlet mut hasher = Keccak256::new();\n\t\t\t\thasher.update([0xff]);\n\t\t\t\thasher.update(&caller[..]);\n\t\t\t\thasher.update(&salt[..]);\n\t\t\t\thasher.update(&code_hash[..]);\n\t\t\t\tH256::from_slice(hasher.finalize().as_slice()).into()\n\t\t\t}\n\t\t\tCreateScheme::Legacy { caller } => {\n\t\t\t\tlet nonce = self.nonce(caller);\n\t\t\t\tlet mut stream = rlp::RlpStream::new_list(2);\n\t\t\t\tstream.append(&caller);\n\t\t\t\tstream.append(&nonce);\n\t\t\t\tH256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()\n\t\t\t}\n\t\t\tCreateScheme::Fixed(naddress) => naddress,\n\t\t}\n\t}\n\n\tpub fn initialize_with_access_list(&mut self, access_list: Vec<(H160, Vec<H256>)>) {\n\t\tlet addresses = access_list.iter().map(|a| a.0);\n\t\tself.state.metadata_mut().access_addresses(addresses);\n\n\t\tlet storage_keys = access_list\n\t\t\t.into_iter()\n\t\t\t.flat_map(|(address, keys)| keys.into_iter().map(move |key| (address, key)));\n\t\tself.state.metadata_mut().access_storages(storage_keys);\n\t}\n\n\tfn create_inner(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\ttake_l64: bool,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), StackExecutorCreateInterrupt<'static>> {\n\t\tmacro_rules! try_or_fail {\n\t\t\t( $e:expr ) => {\n\t\t\t\tmatch $e {\n\t\t\t\t\tOk(v) => v,\n\t\t\t\t\tErr(e) => return Capture::Exit((e.into(), None, Vec::new())),\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfn l64(gas: u64) -> u64 {\n\t\t\tgas - gas / 64\n\t\t}\n\n\t\tlet address = self.create_address(scheme);\n\n\t\tself.state.metadata_mut().access_address(caller);\n\t\tself.state.metadata_mut().access_address(address);\n\n\t\tevent!(Create {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tscheme,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\ttarget_gas\n\t\t});\n\n\t\tif let Some(depth) = self.state.metadata().depth {\n\t\t\tif depth > self.config.call_stack_limit {\n\t\t\t\treturn Capture::Exit((ExitError::CallTooDeep.into(), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif self.balance(caller) < value {\n\t\t\treturn Capture::Exit((ExitError::OutOfFund.into(), None, Vec::new()));\n\t\t}\n\n\t\tif let Err(e) = self.record_external_operation(crate::ExternalOperation::AccountBasicRead) {\n\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t}\n\t\tif let Err(e) = self.state.inc_nonce(caller) {\n\t\t\treturn Capture::Exit((e.into(), None, Vec::new()));\n\t\t}\n\n\t\tlet after_gas = if take_l64 && self.config.call_l64_after_gas {\n\t\t\tif self.config.estimate {\n\t\t\t\tlet initial_after_gas = self.state.metadata().gasometer.gas();\n\t\t\t\tlet diff = initial_after_gas - l64(initial_after_gas);\n\t\t\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(diff));\n\t\t\t\tself.state.metadata().gasometer.gas()\n\t\t\t} else {\n\t\t\t\tl64(self.state.metadata().gasometer.gas())\n\t\t\t}\n\t\t} else {\n\t\t\tself.state.metadata().gasometer.gas()\n\t\t};\n\n\t\tlet target_gas = target_gas.unwrap_or(after_gas);\n\n\t\tlet gas_limit = min(after_gas, target_gas);\n\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(gas_limit));\n\n\t\tself.enter_substate(gas_limit, false);\n\n\t\t{\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AddressCodeRead(address))\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t\tlet code_size = self.code_size(address);\n\t\t\tif code_size != U256::zero() {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitError::CreateCollision.into(), None, Vec::new()));\n\t\t\t}\n\n\t\t\tif self.nonce(address) > U256::zero() {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitError::CreateCollision.into(), None, Vec::new()));\n\t\t\t}\n\n\t\t\tself.state.reset_storage(address);\n\t\t}\n\n\t\tlet context = Context {\n\t\t\taddress,\n\t\t\tcaller,\n\t\t\tapparent_value: value,\n\t\t};\n\t\tlet transfer = Transfer {\n\t\t\tsource: caller,\n\t\t\ttarget: address,\n\t\t\tvalue,\n\t\t};\n\t\tmatch self.state.transfer(transfer) {\n\t\t\tOk(()) => (),\n\t\t\tErr(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif self.config.create_increase_nonce {\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AccountBasicRead)\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t\tif let Err(e) = self.state.inc_nonce(address) {\n\t\t\t\treturn Capture::Exit((e.into(), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tlet runtime = Runtime::new(\n\t\t\tRc::new(init_code),\n\t\t\tRc::new(Vec::new()),\n\t\t\tcontext,\n\t\t\tself.config.stack_limit,\n\t\t\tself.config.memory_limit,\n\t\t);\n\n\t\tCapture::Trap(StackExecutorCreateInterrupt(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Create(address),\n\t\t\tinner: MaybeBorrowed::Owned(runtime),\n\t\t}))\n\t}\n\n\t#[allow(clippy::too_many_arguments)]\n\tfn call_inner(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\ttake_l64: bool,\n\t\ttake_stipend: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), StackExecutorCallInterrupt<'static>> {\n\t\tmacro_rules! try_or_fail {\n\t\t\t( $e:expr ) => {\n\t\t\t\tmatch $e {\n\t\t\t\t\tOk(v) => v,\n\t\t\t\t\tErr(e) => return Capture::Exit((e.into(), Vec::new())),\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfn l64(gas: u64) -> u64 {\n\t\t\tgas - gas / 64\n\t\t}\n\n\t\tevent!(Call {\n\t\t\tcode_address,\n\t\t\ttransfer: &transfer,\n\t\t\tinput: &input,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\tcontext: &context,\n\t\t});\n\n\t\tlet after_gas = if take_l64 && self.config.call_l64_after_gas {\n\t\t\tif self.config.estimate {\n\t\t\t\tlet initial_after_gas = self.state.metadata().gasometer.gas();\n\t\t\t\tlet diff = initial_after_gas - l64(initial_after_gas);\n\t\t\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(diff));\n\t\t\t\tself.state.metadata().gasometer.gas()\n\t\t\t} else {\n\t\t\t\tl64(self.state.metadata().gasometer.gas())\n\t\t\t}\n\t\t} else {\n\t\t\tself.state.metadata().gasometer.gas()\n\t\t};\n\n\t\tlet target_gas = target_gas.unwrap_or(after_gas);\n\t\tlet mut gas_limit = min(target_gas, after_gas);\n\n\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(gas_limit));\n\n\t\tif let Some(transfer) = transfer.as_ref() {\n\t\t\tif take_stipend && transfer.value != U256::zero() {\n\t\t\t\tgas_limit = gas_limit.saturating_add(self.config.call_stipend);\n\t\t\t}\n\t\t}\n\n\t\tself.enter_substate(gas_limit, is_static);\n\t\tself.state.touch(context.address);\n\n\t\tif let Err(e) =\n\t\t\tself.record_external_operation(crate::ExternalOperation::AddressCodeRead(code_address))\n\t\t{\n\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t}\n\t\tlet code = self.code(code_address);\n\t\tif let Some(depth) = self.state.metadata().depth {\n\t\t\tif depth > self.config.call_stack_limit {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn Capture::Exit((ExitError::CallTooDeep.into(), Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif let Some(transfer) = transfer {\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AccountBasicRead)\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t\t}\n\t\t\tmatch self.state.transfer(transfer) {\n\t\t\t\tOk(()) => (),\n\t\t\t\tErr(e) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, the state has been modified in enter_substate to\n\t\t// reflect both the is_static parameter of this call and the is_static\n\t\t// of the caller context.\n\t\tlet precompile_is_static = self.state.metadata().is_static();\n\t\tif let Some(result) = self.precompile_set.execute(&mut StackExecutorHandle {\n\t\t\texecutor: self,\n\t\t\tcode_address,\n\t\t\tinput: &input,\n\t\t\tgas_limit: Some(gas_limit),\n\t\t\tcontext: &context,\n\t\t\tis_static: precompile_is_static,\n\t\t}) {\n\t\t\treturn match result {\n\t\t\t\tOk(PrecompileOutput {\n\t\t\t\t\texit_status,\n\t\t\t\t\toutput,\n\t\t\t\t}) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\tCapture::Exit((ExitReason::Succeed(exit_status), output))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Error { exit_status }) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\tCapture::Exit((ExitReason::Error(exit_status), Vec::new()))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Revert {\n\t\t\t\t\texit_status,\n\t\t\t\t\toutput,\n\t\t\t\t}) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t\tCapture::Exit((ExitReason::Revert(exit_status), output))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Fatal { exit_status }) => {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\tCapture::Exit((ExitReason::Fatal(exit_status), Vec::new()))\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tlet runtime = Runtime::new(\n\t\t\tRc::new(code),\n\t\t\tRc::new(input),\n\t\t\tcontext,\n\t\t\tself.config.stack_limit,\n\t\t\tself.config.memory_limit,\n\t\t);\n\n\t\tCapture::Trap(StackExecutorCallInterrupt(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Call(code_address),\n\t\t\tinner: MaybeBorrowed::Owned(runtime),\n\t\t}))\n\t}\n\n\tfn cleanup_for_create(\n\t\t&mut self,\n\t\tcreated_address: H160,\n\t\treason: ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\tfn check_first_byte(config: &Config, code: &[u8]) -> Result<(), ExitError> {\n\t\t\tif config.disallow_executable_format && Some(&Opcode::EOFMAGIC.as_u8()) == code.first()\n\t\t\t{\n\t\t\t\treturn Err(ExitError::InvalidCode(Opcode::EOFMAGIC));\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\tlog::debug!(target: \"evm\", \"Create execution using address {}: {:?}\", created_address, reason);\n\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(s) => {\n\t\t\t\tlet out = return_data;\n\t\t\t\tlet address = created_address;\n\t\t\t\t// As of EIP-3541 code starting with 0xef cannot be deployed\n\t\t\t\tif let Err(e) = check_first_byte(self.config, &out) {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t}\n\n\t\t\t\tif let Some(limit) = self.config.create_contract_limit {\n\t\t\t\t\tif out.len() > limit {\n\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\treturn (ExitError::CreateContractLimit.into(), None, Vec::new());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmatch self\n\t\t\t\t\t.state\n\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t.gasometer\n\t\t\t\t\t.record_deposit(out.len())\n\t\t\t\t{\n\t\t\t\t\tOk(()) => {\n\t\t\t\t\t\tlet exit_result = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\t\tif let Err(e) = self.record_external_operation(\n\t\t\t\t\t\t\tcrate::ExternalOperation::Write(U256::from(out.len())),\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.state.set_code(address, out);\n\t\t\t\t\t\tif let Err(e) = exit_result {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(ExitReason::Succeed(s), Some(address), Vec::new())\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tExitReason::Error(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t}\n\t\t\tExitReason::Revert(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t(ExitReason::Revert(e), None, return_data)\n\t\t\t}\n\t\t\tExitReason::Fatal(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Fatal(e), None, Vec::new())\n\t\t\t}\n\t\t}\n\t}\n\n\tfn cleanup_for_call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\treason: &ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> Vec<u8> {\n\t\tlog::debug!(target: \"evm\", \"Call execution using address {}: {:?}\", code_address, reason);\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\treturn_data\n\t\t\t}\n\t\t\tExitReason::Error(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\tVec::new()\n\t\t\t}\n\t\t\tExitReason::Revert(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn_data\n\t\t\t}\n\t\t\tExitReason::Fatal(_) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\tVec::new()\n\t\t\t}\n\t\t}\n\t}\n}\n\npub struct StackExecutorCallInterrupt<'borrow>(TaggedRuntime<'borrow>);\npub struct StackExecutorCreateInterrupt<'borrow>(TaggedRuntime<'borrow>);\n\nimpl<'config, 'precompiles, S: StackState<'config>, P: PrecompileSet> Handler\n\tfor StackExecutor<'config, 'precompiles, S, P>\n{\n\ttype CreateInterrupt = StackExecutorCreateInterrupt<'static>;\n\ttype CreateFeedback = Infallible;\n\ttype CallInterrupt = StackExecutorCallInterrupt<'static>;\n\ttype CallFeedback = Infallible;\n\n\tfn balance(&self, address: H160) -> U256 {\n\t\tself.state.basic(address).balance\n\t}\n\n\tfn code_size(&self, address: H160) -> U256 {\n\t\tself.state.code_size(address)\n\t}\n\n\tfn code_hash(&self, address: H160) -> H256 {\n\t\tif !self.exists(address) {\n\t\t\treturn H256::default();\n\t\t}\n\n\t\tself.state.code_hash(address)\n\t}\n\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\tself.state.code(address)\n\t}\n\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\tself.state.storage(address, index)\n\t}\n\n\tfn original_storage(&self, address: H160, index: H256) -> H256 {\n\t\tself.state\n\t\t\t.original_storage(address, index)\n\t\t\t.unwrap_or_default()\n\t}\n\n\tfn exists(&self, address: H160) -> bool {\n\t\tif self.config.empty_considered_exists {\n\t\t\tself.state.exists(address)\n\t\t} else {\n\t\t\tself.state.exists(address) && !self.state.is_empty(address)\n\t\t}\n\t}\n\n\tfn is_cold(&mut self, address: H160, maybe_index: Option<H256>) -> Result<bool, ExitError> {\n\t\tOk(match maybe_index {\n\t\t\tNone => {\n\t\t\t\tlet is_precompile = match self\n\t\t\t\t\t.precompile_set\n\t\t\t\t\t.is_precompile(address, self.state.metadata().gasometer.gas())\n\t\t\t\t{\n\t\t\t\t\tIsPrecompileResult::Answer {\n\t\t\t\t\t\tis_precompile,\n\t\t\t\t\t\textra_cost,\n\t\t\t\t\t} => {\n\t\t\t\t\t\tself.state\n\t\t\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t\t\t.gasometer\n\t\t\t\t\t\t\t.record_cost(extra_cost)?;\n\t\t\t\t\t\tis_precompile\n\t\t\t\t\t}\n\t\t\t\t\tIsPrecompileResult::OutOfGas => return Err(ExitError::OutOfGas),\n\t\t\t\t};\n\n\t\t\t\t!is_precompile && self.state.is_cold(address)\n\t\t\t}\n\t\t\tSome(index) => self.state.is_storage_cold(address, index),\n\t\t})\n\t}\n\n\tfn gas_left(&self) -> U256 {\n\t\tU256::from(self.state.metadata().gasometer.gas())\n\t}\n\n\tfn gas_price(&self) -> U256 {\n\t\tself.state.gas_price()\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.state.origin()\n\t}\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tself.state.block_hash(number)\n\t}\n\tfn block_number(&self) -> U256 {\n\t\tself.state.block_number()\n\t}\n\tfn block_coinbase(&self) -> H160 {\n\t\tself.state.block_coinbase()\n\t}\n\tfn block_timestamp(&self) -> U256 {\n\t\tself.state.block_timestamp()\n\t}\n\tfn block_difficulty(&self) -> U256 {\n\t\tself.state.block_difficulty()\n\t}\n\tfn block_randomness(&self) -> Option<H256> {\n\t\tself.state.block_randomness()\n\t}\n\tfn block_gas_limit(&self) -> U256 {\n\t\tself.state.block_gas_limit()\n\t}\n\tfn block_base_fee_per_gas(&self) -> U256 {\n\t\tself.state.block_base_fee_per_gas()\n\t}\n\tfn chain_id(&self) -> U256 {\n\t\tself.state.chain_id()\n\t}\n\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.state.deleted(address)\n\t}\n\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) -> Result<(), ExitError> {\n\t\tself.state.set_storage(address, index, value);\n\t\tOk(())\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), ExitError> {\n\t\tself.state.log(address, topics, data);\n\t\tOk(())\n\t}\n\n\tfn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {\n\t\tlet balance = self.balance(address);\n\n\t\tevent!(Suicide {\n\t\t\ttarget,\n\t\t\taddress,\n\t\t\tbalance,\n\t\t});\n\n\t\tself.state.transfer(Transfer {\n\t\t\tsource: address,\n\t\t\ttarget,\n\t\t\tvalue: balance,\n\t\t})?;\n\t\tself.state.reset_balance(address);\n\t\tself.state.set_deleted(address);\n\n\t\tOk(())\n\t}\n\n\t#[cfg(not(feature = \"tracing\"))]\n\tfn create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), Self::CreateInterrupt> {\n\t\tif let Err(e) = self.maybe_record_init_code_cost(&init_code) {\n\t\t\tlet reason: ExitReason = e.into();\n\t\t\temit_exit!(reason.clone());\n\t\t\treturn Capture::Exit((reason, None, Vec::new()));\n\t\t}\n\n\t\tself.create_inner(caller, scheme, value, init_code, target_gas, true)\n\t}\n\n\t#[cfg(feature = \"tracing\")]\n\tfn create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), Self::CreateInterrupt> {\n\t\tif let Err(e) = self.maybe_record_init_code_cost(&init_code) {\n\t\t\tlet reason: ExitReason = e.into();\n\t\t\temit_exit!(reason.clone());\n\t\t\treturn Capture::Exit((reason, None, Vec::new()));\n\t\t}\n\n\t\tlet capture = self.create_inner(caller, scheme, value, init_code, target_gas, true);\n\n\t\tif let Capture::Exit((ref reason, _, ref return_value)) = capture {\n\t\t\temit_exit!(reason, return_value);\n\t\t}\n\n\t\tcapture\n\t}\n\n\t#[cfg(not(feature = \"tracing\"))]\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), Self::CallInterrupt> {\n\t\tself.call_inner(\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tcontext,\n\t\t)\n\t}\n\n\t#[cfg(feature = \"tracing\")]\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), Self::CallInterrupt> {\n\t\tlet capture = self.call_inner(\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tcontext,\n\t\t);\n\n\t\tif let Capture::Exit((ref reason, ref return_value)) = capture {\n\t\t\temit_exit!(reason, return_value);\n\t\t}\n\n\t\tcapture\n\t}\n\n\t#[inline]\n\tfn pre_validate(\n\t\t&mut self,\n\t\tcontext: &Context,\n\t\topcode: Opcode,\n\t\tstack: &Stack,\n\t) -> Result<(), ExitError> {\n\t\t// log::trace!(target: \"evm\", \"Running opcode: {:?}, Pre gas-left: {:?}\", opcode, gasometer.gas());\n\n\t\tif let Some(cost) = gasometer::static_opcode_cost(opcode) {\n\t\t\tself.state.metadata_mut().gasometer.record_cost(cost)?;\n\t\t} else {\n\t\t\tlet is_static = self.state.metadata().is_static;\n\t\t\tlet (gas_cost, target, memory_cost) = gasometer::dynamic_opcode_cost(\n\t\t\t\tcontext.address,\n\t\t\t\topcode,\n\t\t\t\tstack,\n\t\t\t\tis_static,\n\t\t\t\tself.config,\n\t\t\t\tself,\n\t\t\t)?;\n\n\t\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\t\tgasometer.record_dynamic_cost(gas_cost, memory_cost)?;\n\n\t\t\tself.state\n\t\t\t\t.record_external_dynamic_opcode_cost(opcode, gas_cost, target)?;\n\n\t\t\tmatch target {\n\t\t\t\tStorageTarget::Address(address) => {\n\t\t\t\t\tself.state.metadata_mut().access_address(address)\n\t\t\t\t}\n\t\t\t\tStorageTarget::Slot(address, key) => {\n\t\t\t\t\tself.state.metadata_mut().access_storage(address, key)\n\t\t\t\t}\n\t\t\t\tStorageTarget::None => (),\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tfn record_external_operation(&mut self, op: crate::ExternalOperation) -> Result<(), ExitError> {\n\t\tself.state.record_external_operation(op)\n\t}\n}\n\nstruct StackExecutorHandle<'inner, 'config, 'precompiles, S, P> {\n\texecutor: &'inner mut StackExecutor<'config, 'precompiles, S, P>,\n\tcode_address: H160,\n\tinput: &'inner [u8],\n\tgas_limit: Option<u64>,\n\tcontext: &'inner Context,\n\tis_static: bool,\n}\n\nimpl<'inner, 'config, 'precompiles, S: StackState<'config>, P: PrecompileSet> PrecompileHandle\n\tfor StackExecutorHandle<'inner, 'config, 'precompiles, S, P>\n{\n\t// Perform subcall in provided context.\n\t/// Precompile specifies in which context the subcall is executed.\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\tgas_limit: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: &Context,\n\t) -> (ExitReason, Vec<u8>) {\n\t\t// For normal calls the cost is recorded at opcode level.\n\t\t// Since we don't go through opcodes we need manually record the call\n\t\t// cost. Not doing so will make the code panic as recording the call stipend\n\t\t// will do an underflow.\n\t\tlet target_is_cold = match self.executor.is_cold(code_address, None) {\n\t\t\tOk(x) => x,\n\t\t\tErr(err) => return (ExitReason::Error(err), Vec::new()),\n\t\t};\n\n\t\tlet target_exists = self.executor.exists(code_address);\n\n\t\tlet gas_cost = crate::gasometer::GasCost::Call {\n\t\t\tvalue: transfer.clone().map(|x| x.value).unwrap_or_else(U256::zero),\n\t\t\tgas: U256::from(gas_limit.unwrap_or(u64::MAX)),\n\t\t\ttarget_is_cold,\n\t\t\ttarget_exists,\n\t\t};\n\n\t\t// We record the length of the input.\n\t\tlet memory_cost = Some(crate::gasometer::MemoryCost {\n\t\t\toffset: U256::zero(),\n\t\t\tlen: input.len().into(),\n\t\t});\n\n\t\tif let Err(error) = self\n\t\t\t.executor\n\t\t\t.state\n\t\t\t.metadata_mut()\n\t\t\t.gasometer\n\t\t\t.record_dynamic_cost(gas_cost, memory_cost)\n\t\t{\n\t\t\treturn (ExitReason::Error(error), Vec::new());\n\t\t}\n\n\t\tevent!(PrecompileSubcall {\n\t\t\tcode_address,\n\t\t\ttransfer: &transfer,\n\t\t\tinput: &input,\n\t\t\ttarget_gas: gas_limit,\n\t\t\tis_static,\n\t\t\tcontext\n\t\t});\n\n\t\t// Perform the subcall\n\t\tmatch Handler::call(\n\t\t\tself.executor,\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\tgas_limit,\n\t\t\tis_static,\n\t\t\tcontext.clone(),\n\t\t) {\n\t\t\tCapture::Exit((s, v)) => (s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\t// Ideally this would pass the interrupt back to the executor so it could be\n\t\t\t\t// handled like any other call, however the type signature of this function does\n\t\t\t\t// not allow it. For now we'll make a recursive call instead of making a breaking\n\t\t\t\t// change to the precompile API. But this means a custom precompile could still\n\t\t\t\t// potentially cause a stack overflow if you're not careful.\n\t\t\t\tlet mut call_stack = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcall_stack.push(rt.0);\n\t\t\t\tlet (reason, _, return_data) =\n\t\t\t\t\tself.executor.execute_with_call_stack(&mut call_stack);\n\t\t\t\temit_exit!(reason, return_data)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Record cost to the Runtime gasometer.\n\tfn record_cost(&mut self, cost: u64) -> Result<(), ExitError> {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.metadata_mut()\n\t\t\t.gasometer\n\t\t\t.record_cost(cost)\n\t}\n\n\t/// Record Substrate specific cost.\n\tfn record_external_cost(\n\t\t&mut self,\n\t\tref_time: Option<u64>,\n\t\tproof_size: Option<u64>,\n\t\tstorage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.record_external_cost(ref_time, proof_size, storage_growth)\n\t}\n\n\t/// Refund Substrate specific cost.\n\tfn refund_external_cost(&mut self, ref_time: Option<u64>, proof_size: Option<u64>) {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.refund_external_cost(ref_time, proof_size);\n\t}\n\n\t/// Retreive the remaining gas.\n\tfn remaining_gas(&self) -> u64 {\n\t\tself.executor.state.metadata().gasometer.gas()\n\t}\n\n\t/// Record a log.\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), ExitError> {\n\t\tHandler::log(self.executor, address, topics, data)\n\t}\n\n\t/// Retreive the code address (what is the address of the precompile being called).\n\tfn code_address(&self) -> H160 {\n\t\tself.code_address\n\t}\n\n\t/// Retreive the input data the precompile is called with.\n\tfn input(&self) -> &[u8] {\n\t\tself.input\n\t}\n\n\t/// Retreive the context in which the precompile is executed.\n\tfn context(&self) -> &Context {\n\t\tself.context\n\t}\n\n\t/// Is the precompile call is done statically.\n\tfn is_static(&self) -> bool {\n\t\tself.is_static\n\t}\n\n\t/// Retreive the gas limit of this call.\n\tfn gas_limit(&self) -> Option<u64> {\n\t\tself.gas_limit\n\t}\n}\n"], "fixing_code": ["[package]\nname = \"evm\"\nversion = \"0.41.1\"\nlicense = \"Apache-2.0\"\nauthors = [\"Wei Tang <hi@that.world>\", \"Parity Technologies <admin@parity.io>\"]\ndescription = \"SputnikVM - a Portable Blockchain Virtual Machine\"\nrepository = \"https://github.com/sorpaas/rust-evm\"\nkeywords = [\"no_std\", \"ethereum\"]\nedition = \"2018\"\n\n[dependencies]\nauto_impl = \"1.0\"\nethereum = { version = \"0.15\", default-features = false }\nlog = { version = \"0.4\", default-features = false }\nprimitive-types = { version = \"0.12\", default-features = false, features = [\"rlp\"] }\nrlp = { version = \"0.5\", default-features = false }\nsha3 = { version = \"0.10\", default-features = false }\n\n# Optional dependencies\nenvironmental = { version = \"1.1.2\", default-features = false, optional = true }\nscale-codec = { package = \"parity-scale-codec\", version = \"3.2\", default-features = false, features = [\"derive\"], optional = true }\nscale-info = { version = \"2.3\", default-features = false, features = [\"derive\"], optional = true }\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"], optional = true }\n\nevm-core = { version = \"0.41\", path = \"core\", default-features = false }\nevm-gasometer = { version = \"0.41\", path = \"gasometer\", default-features = false }\nevm-runtime = { version = \"0.41\", path = \"runtime\", default-features = false }\n\n[dev-dependencies]\ncriterion = \"0.4\"\nhex = \"0.4\"\n\n[[bench]]\nname = \"loop\"\nharness = false\n\n[features]\ndefault = [\"std\"]\nstd = [\n\t\"ethereum/std\",\n\t\"log/std\",\n\t\"primitive-types/std\",\n\t\"rlp/std\",\n\t\"sha3/std\",\n\t\"environmental/std\",\n\t\"scale-codec/std\",\n\t\"scale-info/std\",\n\t\"serde/std\",\n\t\"evm-core/std\",\n\t\"evm-gasometer/std\",\n\t\"evm-runtime/std\",\n]\nwith-codec = [\n\t\"scale-codec\",\n\t\"scale-info\",\n\t\"primitive-types/codec\",\n\t\"primitive-types/scale-info\",\n\t\"ethereum/with-codec\",\n\t\"evm-core/with-codec\",\n]\nwith-serde = [\n\t\"serde\",\n\t\"primitive-types/impl-serde\",\n\t\"evm-core/with-serde\",\n\t\"ethereum/with-serde\",\n]\ntracing = [\n\t\"environmental\",\n\t\"evm-gasometer/tracing\",\n\t\"evm-runtime/tracing\",\n]\nforce-debug = [\n\t\"evm-core/force-debug\",\n\t\"evm-gasometer/force-debug\",\n]\n\n[workspace]\nmembers = [\n\t\"core\",\n\t\"gasometer\",\n\t\"runtime\",\n\t\"fuzzer\",\n]\n", "use crate::backend::Backend;\nuse crate::executor::stack::precompile::{\n\tIsPrecompileResult, PrecompileFailure, PrecompileHandle, PrecompileOutput, PrecompileSet,\n};\nuse crate::executor::stack::tagged_runtime::{RuntimeKind, TaggedRuntime};\nuse crate::gasometer::{self, Gasometer, StorageTarget};\nuse crate::maybe_borrowed::MaybeBorrowed;\nuse crate::{\n\tCapture, Config, Context, CreateScheme, ExitError, ExitReason, Handler, Opcode, Runtime, Stack,\n\tTransfer,\n};\nuse alloc::{collections::BTreeSet, rc::Rc, vec::Vec};\nuse core::{cmp::min, convert::Infallible};\nuse evm_core::ExitFatal;\nuse evm_runtime::Resolve;\nuse primitive_types::{H160, H256, U256};\nuse sha3::{Digest, Keccak256};\n\nmacro_rules! emit_exit {\n\t($reason:expr) => {{\n\t\tlet reason = $reason;\n\t\tevent!(Exit {\n\t\t\treason: &reason,\n\t\t\treturn_value: &Vec::new(),\n\t\t});\n\t\treason\n\t}};\n\t($reason:expr, $return_value:expr) => {{\n\t\tlet reason = $reason;\n\t\tlet return_value = $return_value;\n\t\tevent!(Exit {\n\t\t\treason: &reason,\n\t\t\treturn_value: &return_value,\n\t\t});\n\t\t(reason, return_value)\n\t}};\n}\n\nconst DEFAULT_CALL_STACK_CAPACITY: usize = 4;\n\npub enum StackExitKind {\n\tSucceeded,\n\tReverted,\n\tFailed,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct Accessed {\n\tpub accessed_addresses: BTreeSet<H160>,\n\tpub accessed_storage: BTreeSet<(H160, H256)>,\n}\n\nimpl Accessed {\n\tpub fn access_address(&mut self, address: H160) {\n\t\tself.accessed_addresses.insert(address);\n\t}\n\n\tpub fn access_addresses<I>(&mut self, addresses: I)\n\twhere\n\t\tI: Iterator<Item = H160>,\n\t{\n\t\tfor address in addresses {\n\t\t\tself.accessed_addresses.insert(address);\n\t\t}\n\t}\n\n\tpub fn access_storages<I>(&mut self, storages: I)\n\twhere\n\t\tI: Iterator<Item = (H160, H256)>,\n\t{\n\t\tfor storage in storages {\n\t\t\tself.accessed_storage.insert((storage.0, storage.1));\n\t\t}\n\t}\n}\n\n#[derive(Clone, Debug)]\npub struct StackSubstateMetadata<'config> {\n\tgasometer: Gasometer<'config>,\n\tis_static: bool,\n\tdepth: Option<usize>,\n\taccessed: Option<Accessed>,\n}\n\nimpl<'config> StackSubstateMetadata<'config> {\n\tpub fn new(gas_limit: u64, config: &'config Config) -> Self {\n\t\tlet accessed = if config.increase_state_access_gas {\n\t\t\tSome(Accessed::default())\n\t\t} else {\n\t\t\tNone\n\t\t};\n\t\tSelf {\n\t\t\tgasometer: Gasometer::new(gas_limit, config),\n\t\t\tis_static: false,\n\t\t\tdepth: None,\n\t\t\taccessed,\n\t\t}\n\t}\n\n\tpub fn swallow_commit(&mut self, other: Self) -> Result<(), ExitError> {\n\t\tself.gasometer.record_stipend(other.gasometer.gas())?;\n\t\tself.gasometer\n\t\t\t.record_refund(other.gasometer.refunded_gas())?;\n\n\t\tif let (Some(mut other_accessed), Some(self_accessed)) =\n\t\t\t(other.accessed, self.accessed.as_mut())\n\t\t{\n\t\t\tself_accessed\n\t\t\t\t.accessed_addresses\n\t\t\t\t.append(&mut other_accessed.accessed_addresses);\n\t\t\tself_accessed\n\t\t\t\t.accessed_storage\n\t\t\t\t.append(&mut other_accessed.accessed_storage);\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tpub fn swallow_revert(&mut self, other: Self) -> Result<(), ExitError> {\n\t\tself.gasometer.record_stipend(other.gasometer.gas())?;\n\n\t\tOk(())\n\t}\n\n\tpub fn swallow_discard(&mut self, _other: Self) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tpub fn spit_child(&self, gas_limit: u64, is_static: bool) -> Self {\n\t\tSelf {\n\t\t\tgasometer: Gasometer::new(gas_limit, self.gasometer.config()),\n\t\t\tis_static: is_static || self.is_static,\n\t\t\tdepth: match self.depth {\n\t\t\t\tNone => Some(0),\n\t\t\t\tSome(n) => Some(n + 1),\n\t\t\t},\n\t\t\taccessed: self.accessed.as_ref().map(|_| Accessed::default()),\n\t\t}\n\t}\n\n\tpub fn gasometer(&self) -> &Gasometer<'config> {\n\t\t&self.gasometer\n\t}\n\n\tpub fn gasometer_mut(&mut self) -> &mut Gasometer<'config> {\n\t\t&mut self.gasometer\n\t}\n\n\tpub fn is_static(&self) -> bool {\n\t\tself.is_static\n\t}\n\n\tpub fn depth(&self) -> Option<usize> {\n\t\tself.depth\n\t}\n\n\tpub fn access_address(&mut self, address: H160) {\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_address(address)\n\t\t}\n\t}\n\n\tpub fn access_addresses<I>(&mut self, addresses: I)\n\twhere\n\t\tI: Iterator<Item = H160>,\n\t{\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_addresses(addresses);\n\t\t}\n\t}\n\n\tpub fn access_storage(&mut self, address: H160, key: H256) {\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.accessed_storage.insert((address, key));\n\t\t}\n\t}\n\n\tpub fn access_storages<I>(&mut self, storages: I)\n\twhere\n\t\tI: Iterator<Item = (H160, H256)>,\n\t{\n\t\tif let Some(accessed) = &mut self.accessed {\n\t\t\taccessed.access_storages(storages);\n\t\t}\n\t}\n\n\tpub fn accessed(&self) -> &Option<Accessed> {\n\t\t&self.accessed\n\t}\n}\n\n#[auto_impl::auto_impl(&mut, Box)]\npub trait StackState<'config>: Backend {\n\tfn metadata(&self) -> &StackSubstateMetadata<'config>;\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config>;\n\n\tfn enter(&mut self, gas_limit: u64, is_static: bool);\n\tfn exit_commit(&mut self) -> Result<(), ExitError>;\n\tfn exit_revert(&mut self) -> Result<(), ExitError>;\n\tfn exit_discard(&mut self) -> Result<(), ExitError>;\n\n\tfn is_empty(&self, address: H160) -> bool;\n\tfn deleted(&self, address: H160) -> bool;\n\tfn is_cold(&self, address: H160) -> bool;\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool;\n\n\tfn inc_nonce(&mut self, address: H160) -> Result<(), ExitError>;\n\tfn set_storage(&mut self, address: H160, key: H256, value: H256);\n\tfn reset_storage(&mut self, address: H160);\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>);\n\tfn set_deleted(&mut self, address: H160);\n\tfn set_code(&mut self, address: H160, code: Vec<u8>);\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError>;\n\tfn reset_balance(&mut self, address: H160);\n\tfn touch(&mut self, address: H160);\n\n\t/// Fetch the code size of an address.\n\t/// Provide a default implementation by fetching the code, but\n\t/// can be customized to use a more performant approach that don't need to\n\t/// fetch the code.\n\tfn code_size(&self, address: H160) -> U256 {\n\t\tU256::from(self.code(address).len())\n\t}\n\n\t/// Fetch the code hash of an address.\n\t/// Provide a default implementation by fetching the code, but\n\t/// can be customized to use a more performant approach that don't need to\n\t/// fetch the code.\n\tfn code_hash(&self, address: H160) -> H256 {\n\t\tH256::from_slice(Keccak256::digest(self.code(address)).as_slice())\n\t}\n\n\tfn record_external_operation(\n\t\t&mut self,\n\t\t_op: crate::ExternalOperation,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn record_external_dynamic_opcode_cost(\n\t\t&mut self,\n\t\t_opcode: Opcode,\n\t\t_gas_cost: crate::gasometer::GasCost,\n\t\t_target: StorageTarget,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn record_external_cost(\n\t\t&mut self,\n\t\t_ref_time: Option<u64>,\n\t\t_proof_size: Option<u64>,\n\t\t_storage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tOk(())\n\t}\n\n\tfn refund_external_cost(&mut self, _ref_time: Option<u64>, _proof_size: Option<u64>) {}\n}\n\n/// Stack-based executor.\npub struct StackExecutor<'config, 'precompiles, S, P> {\n\tconfig: &'config Config,\n\tstate: S,\n\tprecompile_set: &'precompiles P,\n}\n\nimpl<'config, 'precompiles, S: StackState<'config>, P: PrecompileSet>\n\tStackExecutor<'config, 'precompiles, S, P>\n{\n\t/// Return a reference of the Config.\n\tpub fn config(&self) -> &'config Config {\n\t\tself.config\n\t}\n\n\t/// Return a reference to the precompile set.\n\tpub fn precompiles(&self) -> &'precompiles P {\n\t\tself.precompile_set\n\t}\n\n\t/// Create a new stack-based executor with given precompiles.\n\tpub fn new_with_precompiles(\n\t\tstate: S,\n\t\tconfig: &'config Config,\n\t\tprecompile_set: &'precompiles P,\n\t) -> Self {\n\t\tSelf {\n\t\t\tconfig,\n\t\t\tstate,\n\t\t\tprecompile_set,\n\t\t}\n\t}\n\n\tpub fn state(&self) -> &S {\n\t\t&self.state\n\t}\n\n\tpub fn state_mut(&mut self) -> &mut S {\n\t\t&mut self.state\n\t}\n\n\tpub fn into_state(self) -> S {\n\t\tself.state\n\t}\n\n\t/// Create a substate executor from the current executor.\n\tpub fn enter_substate(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.state.enter(gas_limit, is_static);\n\t}\n\n\t/// Exit a substate. Panic if it results an empty substate stack.\n\tpub fn exit_substate(&mut self, kind: StackExitKind) -> Result<(), ExitError> {\n\t\tmatch kind {\n\t\t\tStackExitKind::Succeeded => self.state.exit_commit(),\n\t\t\tStackExitKind::Reverted => self.state.exit_revert(),\n\t\t\tStackExitKind::Failed => self.state.exit_discard(),\n\t\t}\n\t}\n\n\t/// Execute the runtime until it returns.\n\tpub fn execute(&mut self, runtime: &mut Runtime) -> ExitReason {\n\t\tlet mut call_stack = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\tcall_stack.push(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Execute,\n\t\t\tinner: MaybeBorrowed::Borrowed(runtime),\n\t\t});\n\t\tlet (reason, _, _) = self.execute_with_call_stack(&mut call_stack);\n\t\treason\n\t}\n\n\t/// Execute using Runtimes on the call_stack until it returns.\n\tfn execute_with_call_stack(\n\t\t&mut self,\n\t\tcall_stack: &mut Vec<TaggedRuntime<'_>>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\t// This `interrupt_runtime` is used to pass the runtime obtained from the\n\t\t// `Capture::Trap` branch in the match below back to the top of the call stack.\n\t\t// The reason we can't simply `push` the runtime directly onto the stack in the\n\t\t// `Capture::Trap` branch is because the borrow-checker complains that the stack\n\t\t// is already borrowed as long as we hold a pointer on the last element\n\t\t// (i.e. the currently executing runtime).\n\t\tlet mut interrupt_runtime = None;\n\t\tloop {\n\t\t\tif let Some(rt) = interrupt_runtime.take() {\n\t\t\t\tcall_stack.push(rt);\n\t\t\t}\n\t\t\tlet runtime = match call_stack.last_mut() {\n\t\t\t\tSome(runtime) => runtime,\n\t\t\t\tNone => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tExitReason::Fatal(ExitFatal::UnhandledInterrupt),\n\t\t\t\t\t\tNone,\n\t\t\t\t\t\tVec::new(),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet reason = {\n\t\t\t\tlet inner_runtime = &mut runtime.inner;\n\t\t\t\tmatch inner_runtime.run(self) {\n\t\t\t\t\tCapture::Exit(reason) => reason,\n\t\t\t\t\tCapture::Trap(Resolve::Call(rt, _)) => {\n\t\t\t\t\t\tinterrupt_runtime = Some(rt.0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCapture::Trap(Resolve::Create(rt, _)) => {\n\t\t\t\t\t\tinterrupt_runtime = Some(rt.0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet runtime_kind = runtime.kind;\n\t\t\tlet (reason, maybe_address, return_data) = match runtime_kind {\n\t\t\t\tRuntimeKind::Create(created_address) => {\n\t\t\t\t\tlet (reason, maybe_address, return_data) = self.cleanup_for_create(\n\t\t\t\t\t\tcreated_address,\n\t\t\t\t\t\treason,\n\t\t\t\t\t\truntime.inner.machine().return_value(),\n\t\t\t\t\t);\n\t\t\t\t\t(reason, maybe_address, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Call(code_address) => {\n\t\t\t\t\tlet return_data = self.cleanup_for_call(\n\t\t\t\t\t\tcode_address,\n\t\t\t\t\t\t&reason,\n\t\t\t\t\t\truntime.inner.machine().return_value(),\n\t\t\t\t\t);\n\t\t\t\t\t(reason, None, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Execute => (reason, None, runtime.inner.machine().return_value()),\n\t\t\t};\n\t\t\t// We're done with that runtime now, so can pop it off the call stack\n\t\t\tcall_stack.pop();\n\t\t\t// Now pass the results from that runtime on to the next one in the stack\n\t\t\tlet runtime = match call_stack.last_mut() {\n\t\t\t\tSome(r) => r,\n\t\t\t\tNone => return (reason, None, return_data),\n\t\t\t};\n\t\t\temit_exit!(&reason, &return_data);\n\t\t\tlet inner_runtime = &mut runtime.inner;\n\t\t\tlet maybe_error = match runtime_kind {\n\t\t\t\tRuntimeKind::Create(_) => {\n\t\t\t\t\tinner_runtime.finish_create(reason, maybe_address, return_data)\n\t\t\t\t}\n\t\t\t\tRuntimeKind::Call(_) => inner_runtime.finish_call(reason, return_data),\n\t\t\t\tRuntimeKind::Execute => inner_runtime.finish_call(reason, return_data),\n\t\t\t};\n\t\t\t// Early exit if passing on the result caused an error\n\t\t\tif let Err(e) = maybe_error {\n\t\t\t\treturn (e, None, Vec::new());\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Get remaining gas.\n\tpub fn gas(&self) -> u64 {\n\t\tself.state.metadata().gasometer.gas()\n\t}\n\n\tfn record_create_transaction_cost(\n\t\t&mut self,\n\t\tinit_code: &[u8],\n\t\taccess_list: &[(H160, Vec<H256>)],\n\t) -> Result<(), ExitError> {\n\t\tlet transaction_cost = gasometer::create_transaction_cost(init_code, access_list);\n\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\tgasometer.record_transaction(transaction_cost)\n\t}\n\n\tfn maybe_record_init_code_cost(&mut self, init_code: &[u8]) -> Result<(), ExitError> {\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\t// EIP-3860\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn Err(ExitError::CreateContractLimit);\n\t\t\t}\n\t\t\treturn self\n\t\t\t\t.state\n\t\t\t\t.metadata_mut()\n\t\t\t\t.gasometer\n\t\t\t\t.record_cost(gasometer::init_code_cost(init_code));\n\t\t}\n\t\tOk(())\n\t}\n\n\t/// Execute a `CREATE` transaction.\n\tpub fn transact_create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n\t) -> (ExitReason, Vec<u8>) {\n\t\tevent!(TransactCreate {\n\t\t\tcaller,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\tgas_limit,\n\t\t\taddress: self.create_address(CreateScheme::Legacy { caller }),\n\t\t});\n\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn emit_exit!(ExitError::CreateContractLimit.into(), Vec::new());\n\t\t\t}\n\t\t}\n\n\t\tif let Err(e) = self.record_create_transaction_cost(&init_code, &access_list) {\n\t\t\treturn emit_exit!(e.into(), Vec::new());\n\t\t}\n\t\tself.initialize_with_access_list(access_list);\n\n\t\tmatch self.create_inner(\n\t\t\tcaller,\n\t\t\tCreateScheme::Legacy { caller },\n\t\t\tvalue,\n\t\t\tinit_code,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t) {\n\t\t\tCapture::Exit((s, _, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Execute a `CREATE2` transaction.\n\tpub fn transact_create2(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\tsalt: H256,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n\t) -> (ExitReason, Vec<u8>) {\n\t\tif let Some(limit) = self.config.max_initcode_size {\n\t\t\tif init_code.len() > limit {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\treturn emit_exit!(ExitError::CreateContractLimit.into(), Vec::new());\n\t\t\t}\n\t\t}\n\n\t\tlet code_hash = H256::from_slice(Keccak256::digest(&init_code).as_slice());\n\t\tevent!(TransactCreate2 {\n\t\t\tcaller,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\tsalt,\n\t\t\tgas_limit,\n\t\t\taddress: self.create_address(CreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t}),\n\t\t});\n\n\t\tif let Err(e) = self.record_create_transaction_cost(&init_code, &access_list) {\n\t\t\treturn emit_exit!(e.into(), Vec::new());\n\t\t}\n\t\tself.initialize_with_access_list(access_list);\n\n\t\tmatch self.create_inner(\n\t\t\tcaller,\n\t\t\tCreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t},\n\t\t\tvalue,\n\t\t\tinit_code,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t) {\n\t\t\tCapture::Exit((s, _, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Execute a `CALL` transaction with a given caller, address, value and\n\t/// gas limit and data.\n\t///\n\t/// Takes in an additional `access_list` parameter for EIP-2930 which was\n\t/// introduced in the Ethereum Berlin hard fork. If you do not wish to use\n\t/// this functionality, just pass in an empty vector.\n\tpub fn transact_call(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\taddress: H160,\n\t\tvalue: U256,\n\t\tdata: Vec<u8>,\n\t\tgas_limit: u64,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t) -> (ExitReason, Vec<u8>) {\n\t\tevent!(TransactCall {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tvalue,\n\t\t\tdata: &data,\n\t\t\tgas_limit,\n\t\t});\n\n\t\tlet transaction_cost = gasometer::call_transaction_cost(&data, &access_list);\n\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\tmatch gasometer.record_transaction(transaction_cost) {\n\t\t\tOk(()) => (),\n\t\t\tErr(e) => return emit_exit!(e.into(), Vec::new()),\n\t\t}\n\n\t\t// Initialize initial addresses for EIP-2929\n\t\tif self.config.increase_state_access_gas {\n\t\t\tif self.config.warm_coinbase_address {\n\t\t\t\t// Warm coinbase address for EIP-3651\n\t\t\t\tlet addresses = core::iter::once(caller)\n\t\t\t\t\t.chain(core::iter::once(address))\n\t\t\t\t\t.chain(core::iter::once(self.block_coinbase()));\n\t\t\t\tself.state.metadata_mut().access_addresses(addresses);\n\t\t\t} else {\n\t\t\t\tlet addresses = core::iter::once(caller).chain(core::iter::once(address));\n\t\t\t\tself.state.metadata_mut().access_addresses(addresses);\n\t\t\t}\n\n\t\t\tself.initialize_with_access_list(access_list);\n\t\t}\n\t\tif let Err(e) = self.record_external_operation(crate::ExternalOperation::AccountBasicRead) {\n\t\t\treturn (e.into(), Vec::new());\n\t\t}\n\t\tif let Err(e) = self.state.inc_nonce(caller) {\n\t\t\treturn (e.into(), Vec::new());\n\t\t}\n\n\t\tlet context = Context {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tapparent_value: value,\n\t\t};\n\n\t\tmatch self.call_inner(\n\t\t\taddress,\n\t\t\tSome(Transfer {\n\t\t\t\tsource: caller,\n\t\t\t\ttarget: address,\n\t\t\t\tvalue,\n\t\t\t}),\n\t\t\tdata,\n\t\t\tSome(gas_limit),\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tcontext,\n\t\t) {\n\t\t\tCapture::Exit((s, v)) => emit_exit!(s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\tlet mut cs = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcs.push(rt.0);\n\t\t\t\tlet (s, _, v) = self.execute_with_call_stack(&mut cs);\n\t\t\t\temit_exit!(s, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Get used gas for the current executor, given the price.\n\tpub fn used_gas(&self) -> u64 {\n\t\tself.state.metadata().gasometer.total_used_gas()\n\t\t\t- min(\n\t\t\t\tself.state.metadata().gasometer.total_used_gas() / self.config.max_refund_quotient,\n\t\t\t\tself.state.metadata().gasometer.refunded_gas() as u64,\n\t\t\t)\n\t}\n\n\t/// Get fee needed for the current executor, given the price.\n\tpub fn fee(&self, price: U256) -> U256 {\n\t\tlet used_gas = self.used_gas();\n\t\tU256::from(used_gas).saturating_mul(price)\n\t}\n\n\t/// Get account nonce.\n\tpub fn nonce(&self, address: H160) -> U256 {\n\t\tself.state.basic(address).nonce\n\t}\n\n\t/// Get the create address from given scheme.\n\tpub fn create_address(&self, scheme: CreateScheme) -> H160 {\n\t\tmatch scheme {\n\t\t\tCreateScheme::Create2 {\n\t\t\t\tcaller,\n\t\t\t\tcode_hash,\n\t\t\t\tsalt,\n\t\t\t} => {\n\t\t\t\tlet mut hasher = Keccak256::new();\n\t\t\t\thasher.update([0xff]);\n\t\t\t\thasher.update(&caller[..]);\n\t\t\t\thasher.update(&salt[..]);\n\t\t\t\thasher.update(&code_hash[..]);\n\t\t\t\tH256::from_slice(hasher.finalize().as_slice()).into()\n\t\t\t}\n\t\t\tCreateScheme::Legacy { caller } => {\n\t\t\t\tlet nonce = self.nonce(caller);\n\t\t\t\tlet mut stream = rlp::RlpStream::new_list(2);\n\t\t\t\tstream.append(&caller);\n\t\t\t\tstream.append(&nonce);\n\t\t\t\tH256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()\n\t\t\t}\n\t\t\tCreateScheme::Fixed(naddress) => naddress,\n\t\t}\n\t}\n\n\tpub fn initialize_with_access_list(&mut self, access_list: Vec<(H160, Vec<H256>)>) {\n\t\tlet addresses = access_list.iter().map(|a| a.0);\n\t\tself.state.metadata_mut().access_addresses(addresses);\n\n\t\tlet storage_keys = access_list\n\t\t\t.into_iter()\n\t\t\t.flat_map(|(address, keys)| keys.into_iter().map(move |key| (address, key)));\n\t\tself.state.metadata_mut().access_storages(storage_keys);\n\t}\n\n\tfn create_inner(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\ttake_l64: bool,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), StackExecutorCreateInterrupt<'static>> {\n\t\tmacro_rules! try_or_fail {\n\t\t\t( $e:expr ) => {\n\t\t\t\tmatch $e {\n\t\t\t\t\tOk(v) => v,\n\t\t\t\t\tErr(e) => return Capture::Exit((e.into(), None, Vec::new())),\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfn l64(gas: u64) -> u64 {\n\t\t\tgas - gas / 64\n\t\t}\n\n\t\tlet address = self.create_address(scheme);\n\n\t\tself.state.metadata_mut().access_address(caller);\n\t\tself.state.metadata_mut().access_address(address);\n\n\t\tevent!(Create {\n\t\t\tcaller,\n\t\t\taddress,\n\t\t\tscheme,\n\t\t\tvalue,\n\t\t\tinit_code: &init_code,\n\t\t\ttarget_gas\n\t\t});\n\n\t\tif let Some(depth) = self.state.metadata().depth {\n\t\t\tif depth > self.config.call_stack_limit {\n\t\t\t\treturn Capture::Exit((ExitError::CallTooDeep.into(), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif self.balance(caller) < value {\n\t\t\treturn Capture::Exit((ExitError::OutOfFund.into(), None, Vec::new()));\n\t\t}\n\n\t\tif let Err(e) = self.record_external_operation(crate::ExternalOperation::AccountBasicRead) {\n\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t}\n\t\tif let Err(e) = self.state.inc_nonce(caller) {\n\t\t\treturn Capture::Exit((e.into(), None, Vec::new()));\n\t\t}\n\n\t\tlet after_gas = if take_l64 && self.config.call_l64_after_gas {\n\t\t\tif self.config.estimate {\n\t\t\t\tlet initial_after_gas = self.state.metadata().gasometer.gas();\n\t\t\t\tlet diff = initial_after_gas - l64(initial_after_gas);\n\t\t\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(diff));\n\t\t\t\tself.state.metadata().gasometer.gas()\n\t\t\t} else {\n\t\t\t\tl64(self.state.metadata().gasometer.gas())\n\t\t\t}\n\t\t} else {\n\t\t\tself.state.metadata().gasometer.gas()\n\t\t};\n\n\t\tlet target_gas = target_gas.unwrap_or(after_gas);\n\n\t\tlet gas_limit = min(after_gas, target_gas);\n\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(gas_limit));\n\n\t\tself.enter_substate(gas_limit, false);\n\n\t\t{\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AddressCodeRead(address))\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t\tlet code_size = self.code_size(address);\n\t\t\tif code_size != U256::zero() {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitError::CreateCollision.into(), None, Vec::new()));\n\t\t\t}\n\n\t\t\tif self.nonce(address) > U256::zero() {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitError::CreateCollision.into(), None, Vec::new()));\n\t\t\t}\n\n\t\t\tself.state.reset_storage(address);\n\t\t}\n\n\t\tlet context = Context {\n\t\t\taddress,\n\t\t\tcaller,\n\t\t\tapparent_value: value,\n\t\t};\n\t\tlet transfer = Transfer {\n\t\t\tsource: caller,\n\t\t\ttarget: address,\n\t\t\tvalue,\n\t\t};\n\t\tmatch self.state.transfer(transfer) {\n\t\t\tOk(()) => (),\n\t\t\tErr(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif self.config.create_increase_nonce {\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AccountBasicRead)\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), None, Vec::new()));\n\t\t\t}\n\t\t\tif let Err(e) = self.state.inc_nonce(address) {\n\t\t\t\treturn Capture::Exit((e.into(), None, Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tlet runtime = Runtime::new(\n\t\t\tRc::new(init_code),\n\t\t\tRc::new(Vec::new()),\n\t\t\tcontext,\n\t\t\tself.config.stack_limit,\n\t\t\tself.config.memory_limit,\n\t\t);\n\n\t\tCapture::Trap(StackExecutorCreateInterrupt(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Create(address),\n\t\t\tinner: MaybeBorrowed::Owned(runtime),\n\t\t}))\n\t}\n\n\t#[allow(clippy::too_many_arguments)]\n\tfn call_inner(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\ttake_l64: bool,\n\t\ttake_stipend: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), StackExecutorCallInterrupt<'static>> {\n\t\tmacro_rules! try_or_fail {\n\t\t\t( $e:expr ) => {\n\t\t\t\tmatch $e {\n\t\t\t\t\tOk(v) => v,\n\t\t\t\t\tErr(e) => return Capture::Exit((e.into(), Vec::new())),\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfn l64(gas: u64) -> u64 {\n\t\t\tgas - gas / 64\n\t\t}\n\n\t\tevent!(Call {\n\t\t\tcode_address,\n\t\t\ttransfer: &transfer,\n\t\t\tinput: &input,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\tcontext: &context,\n\t\t});\n\n\t\tlet after_gas = if take_l64 && self.config.call_l64_after_gas {\n\t\t\tif self.config.estimate {\n\t\t\t\tlet initial_after_gas = self.state.metadata().gasometer.gas();\n\t\t\t\tlet diff = initial_after_gas - l64(initial_after_gas);\n\t\t\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(diff));\n\t\t\t\tself.state.metadata().gasometer.gas()\n\t\t\t} else {\n\t\t\t\tl64(self.state.metadata().gasometer.gas())\n\t\t\t}\n\t\t} else {\n\t\t\tself.state.metadata().gasometer.gas()\n\t\t};\n\n\t\tlet target_gas = target_gas.unwrap_or(after_gas);\n\t\tlet mut gas_limit = min(target_gas, after_gas);\n\n\t\ttry_or_fail!(self.state.metadata_mut().gasometer.record_cost(gas_limit));\n\n\t\tif let Some(transfer) = transfer.as_ref() {\n\t\t\tif take_stipend && transfer.value != U256::zero() {\n\t\t\t\tgas_limit = gas_limit.saturating_add(self.config.call_stipend);\n\t\t\t}\n\t\t}\n\n\t\tself.enter_substate(gas_limit, is_static);\n\t\tself.state.touch(context.address);\n\n\t\tif let Err(e) =\n\t\t\tself.record_external_operation(crate::ExternalOperation::AddressCodeRead(code_address))\n\t\t{\n\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t}\n\t\tlet code = self.code(code_address);\n\t\tif let Some(depth) = self.state.metadata().depth {\n\t\t\tif depth > self.config.call_stack_limit {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn Capture::Exit((ExitError::CallTooDeep.into(), Vec::new()));\n\t\t\t}\n\t\t}\n\n\t\tif let Some(transfer) = transfer {\n\t\t\tif let Err(e) =\n\t\t\t\tself.record_external_operation(crate::ExternalOperation::AccountBasicRead)\n\t\t\t{\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t\t}\n\t\t\tmatch self.state.transfer(transfer) {\n\t\t\t\tOk(()) => (),\n\t\t\t\tErr(e) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t\treturn Capture::Exit((ExitReason::Error(e), Vec::new()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, the state has been modified in enter_substate to\n\t\t// reflect both the is_static parameter of this call and the is_static\n\t\t// of the caller context.\n\t\tlet precompile_is_static = self.state.metadata().is_static();\n\t\tif let Some(result) = self.precompile_set.execute(&mut StackExecutorHandle {\n\t\t\texecutor: self,\n\t\t\tcode_address,\n\t\t\tinput: &input,\n\t\t\tgas_limit: Some(gas_limit),\n\t\t\tcontext: &context,\n\t\t\tis_static: precompile_is_static,\n\t\t}) {\n\t\t\treturn match result {\n\t\t\t\tOk(PrecompileOutput {\n\t\t\t\t\texit_status,\n\t\t\t\t\toutput,\n\t\t\t\t}) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\tCapture::Exit((ExitReason::Succeed(exit_status), output))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Error { exit_status }) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\tCapture::Exit((ExitReason::Error(exit_status), Vec::new()))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Revert {\n\t\t\t\t\texit_status,\n\t\t\t\t\toutput,\n\t\t\t\t}) => {\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t\tCapture::Exit((ExitReason::Revert(exit_status), output))\n\t\t\t\t}\n\t\t\t\tErr(PrecompileFailure::Fatal { exit_status }) => {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\tCapture::Exit((ExitReason::Fatal(exit_status), Vec::new()))\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tlet runtime = Runtime::new(\n\t\t\tRc::new(code),\n\t\t\tRc::new(input),\n\t\t\tcontext,\n\t\t\tself.config.stack_limit,\n\t\t\tself.config.memory_limit,\n\t\t);\n\n\t\tCapture::Trap(StackExecutorCallInterrupt(TaggedRuntime {\n\t\t\tkind: RuntimeKind::Call(code_address),\n\t\t\tinner: MaybeBorrowed::Owned(runtime),\n\t\t}))\n\t}\n\n\tfn cleanup_for_create(\n\t\t&mut self,\n\t\tcreated_address: H160,\n\t\treason: ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\tfn check_first_byte(config: &Config, code: &[u8]) -> Result<(), ExitError> {\n\t\t\tif config.disallow_executable_format && Some(&Opcode::EOFMAGIC.as_u8()) == code.first()\n\t\t\t{\n\t\t\t\treturn Err(ExitError::InvalidCode(Opcode::EOFMAGIC));\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\tlog::debug!(target: \"evm\", \"Create execution using address {}: {:?}\", created_address, reason);\n\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(s) => {\n\t\t\t\tlet out = return_data;\n\t\t\t\tlet address = created_address;\n\t\t\t\t// As of EIP-3541 code starting with 0xef cannot be deployed\n\t\t\t\tif let Err(e) = check_first_byte(self.config, &out) {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t}\n\n\t\t\t\tif let Some(limit) = self.config.create_contract_limit {\n\t\t\t\t\tif out.len() > limit {\n\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\treturn (ExitError::CreateContractLimit.into(), None, Vec::new());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmatch self\n\t\t\t\t\t.state\n\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t.gasometer\n\t\t\t\t\t.record_deposit(out.len())\n\t\t\t\t{\n\t\t\t\t\tOk(()) => {\n\t\t\t\t\t\tif let Err(e) = self.record_external_operation(\n\t\t\t\t\t\t\tcrate::ExternalOperation::Write(U256::from(out.len())),\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet exit_result = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\t\tself.state.set_code(address, out);\n\t\t\t\t\t\tif let Err(e) = exit_result {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(ExitReason::Succeed(s), Some(address), Vec::new())\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tExitReason::Error(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t}\n\t\t\tExitReason::Revert(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t(ExitReason::Revert(e), None, return_data)\n\t\t\t}\n\t\t\tExitReason::Fatal(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Fatal(e), None, Vec::new())\n\t\t\t}\n\t\t}\n\t}\n\n\tfn cleanup_for_call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\treason: &ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> Vec<u8> {\n\t\tlog::debug!(target: \"evm\", \"Call execution using address {}: {:?}\", code_address, reason);\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\treturn_data\n\t\t\t}\n\t\t\tExitReason::Error(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\tVec::new()\n\t\t\t}\n\t\t\tExitReason::Revert(_) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\treturn_data\n\t\t\t}\n\t\t\tExitReason::Fatal(_) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\tVec::new()\n\t\t\t}\n\t\t}\n\t}\n}\n\npub struct StackExecutorCallInterrupt<'borrow>(TaggedRuntime<'borrow>);\npub struct StackExecutorCreateInterrupt<'borrow>(TaggedRuntime<'borrow>);\n\nimpl<'config, 'precompiles, S: StackState<'config>, P: PrecompileSet> Handler\n\tfor StackExecutor<'config, 'precompiles, S, P>\n{\n\ttype CreateInterrupt = StackExecutorCreateInterrupt<'static>;\n\ttype CreateFeedback = Infallible;\n\ttype CallInterrupt = StackExecutorCallInterrupt<'static>;\n\ttype CallFeedback = Infallible;\n\n\tfn balance(&self, address: H160) -> U256 {\n\t\tself.state.basic(address).balance\n\t}\n\n\tfn code_size(&self, address: H160) -> U256 {\n\t\tself.state.code_size(address)\n\t}\n\n\tfn code_hash(&self, address: H160) -> H256 {\n\t\tif !self.exists(address) {\n\t\t\treturn H256::default();\n\t\t}\n\n\t\tself.state.code_hash(address)\n\t}\n\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\tself.state.code(address)\n\t}\n\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\tself.state.storage(address, index)\n\t}\n\n\tfn original_storage(&self, address: H160, index: H256) -> H256 {\n\t\tself.state\n\t\t\t.original_storage(address, index)\n\t\t\t.unwrap_or_default()\n\t}\n\n\tfn exists(&self, address: H160) -> bool {\n\t\tif self.config.empty_considered_exists {\n\t\t\tself.state.exists(address)\n\t\t} else {\n\t\t\tself.state.exists(address) && !self.state.is_empty(address)\n\t\t}\n\t}\n\n\tfn is_cold(&mut self, address: H160, maybe_index: Option<H256>) -> Result<bool, ExitError> {\n\t\tOk(match maybe_index {\n\t\t\tNone => {\n\t\t\t\tlet is_precompile = match self\n\t\t\t\t\t.precompile_set\n\t\t\t\t\t.is_precompile(address, self.state.metadata().gasometer.gas())\n\t\t\t\t{\n\t\t\t\t\tIsPrecompileResult::Answer {\n\t\t\t\t\t\tis_precompile,\n\t\t\t\t\t\textra_cost,\n\t\t\t\t\t} => {\n\t\t\t\t\t\tself.state\n\t\t\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t\t\t.gasometer\n\t\t\t\t\t\t\t.record_cost(extra_cost)?;\n\t\t\t\t\t\tis_precompile\n\t\t\t\t\t}\n\t\t\t\t\tIsPrecompileResult::OutOfGas => return Err(ExitError::OutOfGas),\n\t\t\t\t};\n\n\t\t\t\t!is_precompile && self.state.is_cold(address)\n\t\t\t}\n\t\t\tSome(index) => self.state.is_storage_cold(address, index),\n\t\t})\n\t}\n\n\tfn gas_left(&self) -> U256 {\n\t\tU256::from(self.state.metadata().gasometer.gas())\n\t}\n\n\tfn gas_price(&self) -> U256 {\n\t\tself.state.gas_price()\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.state.origin()\n\t}\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tself.state.block_hash(number)\n\t}\n\tfn block_number(&self) -> U256 {\n\t\tself.state.block_number()\n\t}\n\tfn block_coinbase(&self) -> H160 {\n\t\tself.state.block_coinbase()\n\t}\n\tfn block_timestamp(&self) -> U256 {\n\t\tself.state.block_timestamp()\n\t}\n\tfn block_difficulty(&self) -> U256 {\n\t\tself.state.block_difficulty()\n\t}\n\tfn block_randomness(&self) -> Option<H256> {\n\t\tself.state.block_randomness()\n\t}\n\tfn block_gas_limit(&self) -> U256 {\n\t\tself.state.block_gas_limit()\n\t}\n\tfn block_base_fee_per_gas(&self) -> U256 {\n\t\tself.state.block_base_fee_per_gas()\n\t}\n\tfn chain_id(&self) -> U256 {\n\t\tself.state.chain_id()\n\t}\n\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.state.deleted(address)\n\t}\n\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) -> Result<(), ExitError> {\n\t\tself.state.set_storage(address, index, value);\n\t\tOk(())\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), ExitError> {\n\t\tself.state.log(address, topics, data);\n\t\tOk(())\n\t}\n\n\tfn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {\n\t\tlet balance = self.balance(address);\n\n\t\tevent!(Suicide {\n\t\t\ttarget,\n\t\t\taddress,\n\t\t\tbalance,\n\t\t});\n\n\t\tself.state.transfer(Transfer {\n\t\t\tsource: address,\n\t\t\ttarget,\n\t\t\tvalue: balance,\n\t\t})?;\n\t\tself.state.reset_balance(address);\n\t\tself.state.set_deleted(address);\n\n\t\tOk(())\n\t}\n\n\t#[cfg(not(feature = \"tracing\"))]\n\tfn create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), Self::CreateInterrupt> {\n\t\tif let Err(e) = self.maybe_record_init_code_cost(&init_code) {\n\t\t\tlet reason: ExitReason = e.into();\n\t\t\temit_exit!(reason.clone());\n\t\t\treturn Capture::Exit((reason, None, Vec::new()));\n\t\t}\n\n\t\tself.create_inner(caller, scheme, value, init_code, target_gas, true)\n\t}\n\n\t#[cfg(feature = \"tracing\")]\n\tfn create(\n\t\t&mut self,\n\t\tcaller: H160,\n\t\tscheme: CreateScheme,\n\t\tvalue: U256,\n\t\tinit_code: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t) -> Capture<(ExitReason, Option<H160>, Vec<u8>), Self::CreateInterrupt> {\n\t\tif let Err(e) = self.maybe_record_init_code_cost(&init_code) {\n\t\t\tlet reason: ExitReason = e.into();\n\t\t\temit_exit!(reason.clone());\n\t\t\treturn Capture::Exit((reason, None, Vec::new()));\n\t\t}\n\n\t\tlet capture = self.create_inner(caller, scheme, value, init_code, target_gas, true);\n\n\t\tif let Capture::Exit((ref reason, _, ref return_value)) = capture {\n\t\t\temit_exit!(reason, return_value);\n\t\t}\n\n\t\tcapture\n\t}\n\n\t#[cfg(not(feature = \"tracing\"))]\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), Self::CallInterrupt> {\n\t\tself.call_inner(\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tcontext,\n\t\t)\n\t}\n\n\t#[cfg(feature = \"tracing\")]\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: Context,\n\t) -> Capture<(ExitReason, Vec<u8>), Self::CallInterrupt> {\n\t\tlet capture = self.call_inner(\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\ttarget_gas,\n\t\t\tis_static,\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tcontext,\n\t\t);\n\n\t\tif let Capture::Exit((ref reason, ref return_value)) = capture {\n\t\t\temit_exit!(reason, return_value);\n\t\t}\n\n\t\tcapture\n\t}\n\n\t#[inline]\n\tfn pre_validate(\n\t\t&mut self,\n\t\tcontext: &Context,\n\t\topcode: Opcode,\n\t\tstack: &Stack,\n\t) -> Result<(), ExitError> {\n\t\t// log::trace!(target: \"evm\", \"Running opcode: {:?}, Pre gas-left: {:?}\", opcode, gasometer.gas());\n\n\t\tif let Some(cost) = gasometer::static_opcode_cost(opcode) {\n\t\t\tself.state.metadata_mut().gasometer.record_cost(cost)?;\n\t\t} else {\n\t\t\tlet is_static = self.state.metadata().is_static;\n\t\t\tlet (gas_cost, target, memory_cost) = gasometer::dynamic_opcode_cost(\n\t\t\t\tcontext.address,\n\t\t\t\topcode,\n\t\t\t\tstack,\n\t\t\t\tis_static,\n\t\t\t\tself.config,\n\t\t\t\tself,\n\t\t\t)?;\n\n\t\t\tlet gasometer = &mut self.state.metadata_mut().gasometer;\n\t\t\tgasometer.record_dynamic_cost(gas_cost, memory_cost)?;\n\n\t\t\tself.state\n\t\t\t\t.record_external_dynamic_opcode_cost(opcode, gas_cost, target)?;\n\n\t\t\tmatch target {\n\t\t\t\tStorageTarget::Address(address) => {\n\t\t\t\t\tself.state.metadata_mut().access_address(address)\n\t\t\t\t}\n\t\t\t\tStorageTarget::Slot(address, key) => {\n\t\t\t\t\tself.state.metadata_mut().access_storage(address, key)\n\t\t\t\t}\n\t\t\t\tStorageTarget::None => (),\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tfn record_external_operation(&mut self, op: crate::ExternalOperation) -> Result<(), ExitError> {\n\t\tself.state.record_external_operation(op)\n\t}\n}\n\nstruct StackExecutorHandle<'inner, 'config, 'precompiles, S, P> {\n\texecutor: &'inner mut StackExecutor<'config, 'precompiles, S, P>,\n\tcode_address: H160,\n\tinput: &'inner [u8],\n\tgas_limit: Option<u64>,\n\tcontext: &'inner Context,\n\tis_static: bool,\n}\n\nimpl<'inner, 'config, 'precompiles, S: StackState<'config>, P: PrecompileSet> PrecompileHandle\n\tfor StackExecutorHandle<'inner, 'config, 'precompiles, S, P>\n{\n\t// Perform subcall in provided context.\n\t/// Precompile specifies in which context the subcall is executed.\n\tfn call(\n\t\t&mut self,\n\t\tcode_address: H160,\n\t\ttransfer: Option<Transfer>,\n\t\tinput: Vec<u8>,\n\t\tgas_limit: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: &Context,\n\t) -> (ExitReason, Vec<u8>) {\n\t\t// For normal calls the cost is recorded at opcode level.\n\t\t// Since we don't go through opcodes we need manually record the call\n\t\t// cost. Not doing so will make the code panic as recording the call stipend\n\t\t// will do an underflow.\n\t\tlet target_is_cold = match self.executor.is_cold(code_address, None) {\n\t\t\tOk(x) => x,\n\t\t\tErr(err) => return (ExitReason::Error(err), Vec::new()),\n\t\t};\n\n\t\tlet target_exists = self.executor.exists(code_address);\n\n\t\tlet gas_cost = crate::gasometer::GasCost::Call {\n\t\t\tvalue: transfer.clone().map(|x| x.value).unwrap_or_else(U256::zero),\n\t\t\tgas: U256::from(gas_limit.unwrap_or(u64::MAX)),\n\t\t\ttarget_is_cold,\n\t\t\ttarget_exists,\n\t\t};\n\n\t\t// We record the length of the input.\n\t\tlet memory_cost = Some(crate::gasometer::MemoryCost {\n\t\t\toffset: U256::zero(),\n\t\t\tlen: input.len().into(),\n\t\t});\n\n\t\tif let Err(error) = self\n\t\t\t.executor\n\t\t\t.state\n\t\t\t.metadata_mut()\n\t\t\t.gasometer\n\t\t\t.record_dynamic_cost(gas_cost, memory_cost)\n\t\t{\n\t\t\treturn (ExitReason::Error(error), Vec::new());\n\t\t}\n\n\t\tevent!(PrecompileSubcall {\n\t\t\tcode_address,\n\t\t\ttransfer: &transfer,\n\t\t\tinput: &input,\n\t\t\ttarget_gas: gas_limit,\n\t\t\tis_static,\n\t\t\tcontext\n\t\t});\n\n\t\t// Perform the subcall\n\t\tmatch Handler::call(\n\t\t\tself.executor,\n\t\t\tcode_address,\n\t\t\ttransfer,\n\t\t\tinput,\n\t\t\tgas_limit,\n\t\t\tis_static,\n\t\t\tcontext.clone(),\n\t\t) {\n\t\t\tCapture::Exit((s, v)) => (s, v),\n\t\t\tCapture::Trap(rt) => {\n\t\t\t\t// Ideally this would pass the interrupt back to the executor so it could be\n\t\t\t\t// handled like any other call, however the type signature of this function does\n\t\t\t\t// not allow it. For now we'll make a recursive call instead of making a breaking\n\t\t\t\t// change to the precompile API. But this means a custom precompile could still\n\t\t\t\t// potentially cause a stack overflow if you're not careful.\n\t\t\t\tlet mut call_stack = Vec::with_capacity(DEFAULT_CALL_STACK_CAPACITY);\n\t\t\t\tcall_stack.push(rt.0);\n\t\t\t\tlet (reason, _, return_data) =\n\t\t\t\t\tself.executor.execute_with_call_stack(&mut call_stack);\n\t\t\t\temit_exit!(reason, return_data)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Record cost to the Runtime gasometer.\n\tfn record_cost(&mut self, cost: u64) -> Result<(), ExitError> {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.metadata_mut()\n\t\t\t.gasometer\n\t\t\t.record_cost(cost)\n\t}\n\n\t/// Record Substrate specific cost.\n\tfn record_external_cost(\n\t\t&mut self,\n\t\tref_time: Option<u64>,\n\t\tproof_size: Option<u64>,\n\t\tstorage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.record_external_cost(ref_time, proof_size, storage_growth)\n\t}\n\n\t/// Refund Substrate specific cost.\n\tfn refund_external_cost(&mut self, ref_time: Option<u64>, proof_size: Option<u64>) {\n\t\tself.executor\n\t\t\t.state\n\t\t\t.refund_external_cost(ref_time, proof_size);\n\t}\n\n\t/// Retreive the remaining gas.\n\tfn remaining_gas(&self) -> u64 {\n\t\tself.executor.state.metadata().gasometer.gas()\n\t}\n\n\t/// Record a log.\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), ExitError> {\n\t\tHandler::log(self.executor, address, topics, data)\n\t}\n\n\t/// Retreive the code address (what is the address of the precompile being called).\n\tfn code_address(&self) -> H160 {\n\t\tself.code_address\n\t}\n\n\t/// Retreive the input data the precompile is called with.\n\tfn input(&self) -> &[u8] {\n\t\tself.input\n\t}\n\n\t/// Retreive the context in which the precompile is executed.\n\tfn context(&self) -> &Context {\n\t\tself.context\n\t}\n\n\t/// Is the precompile call is done statically.\n\tfn is_static(&self) -> bool {\n\t\tself.is_static\n\t}\n\n\t/// Retreive the gas limit of this call.\n\tfn gas_limit(&self) -> Option<u64> {\n\t\tself.gas_limit\n\t}\n}\n"], "filenames": ["Cargo.toml", "src/executor/stack/executor.rs"], "buggy_code_start_loc": [3, 1012], "buggy_code_end_loc": [4, 1017], "fixing_code_start_loc": [3, 1011], "fixing_code_end_loc": [4, 1020], "type": "NVD-CWE-noinfo", "message": "Rust EVM is an Ethereum Virtual Machine interpreter. In `rust-evm`, a feature called `record_external_operation` was introduced, allowing library users to record custom gas changes. This feature can have some bogus interactions with the call stack. In particular, during finalization of a `CREATE` or `CREATE2`, in the case that the substack execution happens successfully, `rust-evm` will first commit the substate, and then call `record_external_operation(Write(out_code.len()))`. If `record_external_operation` later fails, this error is returned to the parent call stack, instead of `Succeeded`. Yet, the substate commitment already happened. This causes smart contracts able to commit state changes, when the parent caller contract receives zero address (which usually indicates that the execution has failed). This issue only impacts library users with custom `record_external_operation` that returns errors. The issue is patched in release 0.41.1. No known workarounds are available.", "other": {"cve": {"id": "CVE-2024-21629", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-02T22:15:09.897", "lastModified": "2024-01-09T16:37:01.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rust EVM is an Ethereum Virtual Machine interpreter. In `rust-evm`, a feature called `record_external_operation` was introduced, allowing library users to record custom gas changes. This feature can have some bogus interactions with the call stack. In particular, during finalization of a `CREATE` or `CREATE2`, in the case that the substack execution happens successfully, `rust-evm` will first commit the substate, and then call `record_external_operation(Write(out_code.len()))`. If `record_external_operation` later fails, this error is returned to the parent call stack, instead of `Succeeded`. Yet, the substate commitment already happened. This causes smart contracts able to commit state changes, when the parent caller contract receives zero address (which usually indicates that the execution has failed). This issue only impacts library users with custom `record_external_operation` that returns errors. The issue is patched in release 0.41.1. No known workarounds are available."}, {"lang": "es", "value": "Rust EVM es un int\u00e9rprete de m\u00e1quina virtual Ethereum. En \"rust-evm\", se introdujo una funci\u00f3n llamada \"record_external_operation\", que permite a los usuarios de la librer\u00eda registrar cambios de gas personalizados. Esta caracter\u00edstica puede tener algunas interacciones falsas con la pila de llamadas. En particular, durante la finalizaci\u00f3n de `CREATE` o `CREATE2`, en el caso de que la ejecuci\u00f3n de la subpila se realice exitosamente, `rust-evm` primero confirmar\u00e1 el subestado y luego llamar\u00e1 a `record_external_operation(Write(out_code.len()) )`. Si `record_external_operation` falla posteriormente, este error se devuelve a la pila de llamadas principal, en lugar de `Succeeded`. Sin embargo, el compromiso subestatal ya se produjo. Esto hace que los contratos inteligentes puedan realizar cambios de estado, cuando el contrato principal de la persona que llama recibe una direcci\u00f3n cero (lo que generalmente indica que la ejecuci\u00f3n ha fallado). Este problema solo afecta a los usuarios de la librer\u00eda con `record_external_operative` personalizado que devuelve errores. El problema se solucion\u00f3 en la versi\u00f3n 0.41.1. No hay workarounds disponibles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-703"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.41.1", "matchCriteriaId": "40939BAA-57AE-4D36-B0EE-C900BA72F55A"}]}]}], "references": [{"url": "https://github.com/rust-ethereum/evm/blob/release-v041/src/executor/stack/executor.rs#L1012C25-L1012C69", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/rust-ethereum/evm/commit/d8991ec727ad0fb64fe9957a3cd307387a6701e4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rust-ethereum/evm/pull/264", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rust-ethereum/evm/security/advisories/GHSA-27wg-99g8-2v4v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/rust-ethereum/evm/commit/d8991ec727ad0fb64fe9957a3cd307387a6701e4"}}