{"buggy_code": ["// Copyright (c) 2017 Sandstorm Development Group, Inc. and contributors\n// Licensed under the MIT License:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include \"http.h\"\n#include \"kj/exception.h\"\n#include \"url.h\"\n#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include <kj/string.h>\n#include <unordered_map>\n#include <stdlib.h>\n#include <kj/encoding.h>\n#include <deque>\n#include <queue>\n#include <map>\n#if KJ_HAS_ZLIB\n#include <zlib.h>\n#endif // KJ_HAS_ZLIB\n\nnamespace kj {\n\n// =======================================================================================\n// SHA-1 implementation from https://github.com/clibs/sha1\n//\n// The WebSocket standard depends on SHA-1. ARRRGGGHHHHH.\n//\n// Any old checksum would have served the purpose, or hell, even just returning the header\n// verbatim. But NO, they decided to throw a whole complicated hash algorithm in there, AND\n// THEY CHOSE A BROKEN ONE THAT WE OTHERWISE WOULDN'T NEED ANYMORE.\n//\n// TODO(cleanup): Move this to a shared hashing library. Maybe. Or maybe don't, because no one\n//   should be using SHA-1 anymore.\n//\n// THIS USAGE IS NOT SECURITY SENSITIVE. IF YOU REPORT A SECURITY ISSUE BECAUSE YOU SAW SHA1 IN THE\n// SOURCE CODE I WILL MAKE FUN OF YOU.\n\n/*\nSHA-1 in C\nBy Steve Reid <steve@edmweb.com>\n100% Public Domain\nTest Vectors (from FIPS PUB 180-1)\n\"abc\"\n  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D\n\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1\nA million repetitions of \"a\"\n  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F\n*/\n\n/* #define LITTLE_ENDIAN * This should be #define'd already, if true. */\n/* #define SHA1HANDSOFF * Copies data before messing with it. */\n\n#define SHA1HANDSOFF\n\ntypedef struct\n{\n    uint32_t state[5];\n    uint32_t count[2];\n    unsigned char buffer[64];\n} SHA1_CTX;\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\n/* blk0() and blk() perform the initial expand. */\n/* I got the idea of expanding during the round function from SSLeay */\n#if BYTE_ORDER == LITTLE_ENDIAN\n#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \\\n    |(rol(block->l[i],8)&0x00FF00FF))\n#elif BYTE_ORDER == BIG_ENDIAN\n#define blk0(i) block->l[i]\n#else\n#error \"Endianness not defined!\"\n#endif\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n\n/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */\n#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n\n\n/* Hash a single 512-bit block. This is the core of the algorithm. */\n\nvoid SHA1Transform(\n    uint32_t state[5],\n    const unsigned char buffer[64]\n)\n{\n    uint32_t a, b, c, d, e;\n\n    typedef union\n    {\n        unsigned char c[64];\n        uint32_t l[16];\n    } CHAR64LONG16;\n\n#ifdef SHA1HANDSOFF\n    CHAR64LONG16 block[1];      /* use array to appear as a pointer */\n\n    memcpy(block, buffer, 64);\n#else\n    /* The following had better never be used because it causes the\n     * pointer-to-const buffer to be cast into a pointer to non-const.\n     * And the result is written through.  I threw a \"const\" in, hoping\n     * this will cause a diagnostic.\n     */\n    CHAR64LONG16 *block = (const CHAR64LONG16 *) buffer;\n#endif\n    /* Copy context->state[] to working vars */\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    /* 4 rounds of 20 operations each. Loop unrolled. */\n    R0(a, b, c, d, e, 0);\n    R0(e, a, b, c, d, 1);\n    R0(d, e, a, b, c, 2);\n    R0(c, d, e, a, b, 3);\n    R0(b, c, d, e, a, 4);\n    R0(a, b, c, d, e, 5);\n    R0(e, a, b, c, d, 6);\n    R0(d, e, a, b, c, 7);\n    R0(c, d, e, a, b, 8);\n    R0(b, c, d, e, a, 9);\n    R0(a, b, c, d, e, 10);\n    R0(e, a, b, c, d, 11);\n    R0(d, e, a, b, c, 12);\n    R0(c, d, e, a, b, 13);\n    R0(b, c, d, e, a, 14);\n    R0(a, b, c, d, e, 15);\n    R1(e, a, b, c, d, 16);\n    R1(d, e, a, b, c, 17);\n    R1(c, d, e, a, b, 18);\n    R1(b, c, d, e, a, 19);\n    R2(a, b, c, d, e, 20);\n    R2(e, a, b, c, d, 21);\n    R2(d, e, a, b, c, 22);\n    R2(c, d, e, a, b, 23);\n    R2(b, c, d, e, a, 24);\n    R2(a, b, c, d, e, 25);\n    R2(e, a, b, c, d, 26);\n    R2(d, e, a, b, c, 27);\n    R2(c, d, e, a, b, 28);\n    R2(b, c, d, e, a, 29);\n    R2(a, b, c, d, e, 30);\n    R2(e, a, b, c, d, 31);\n    R2(d, e, a, b, c, 32);\n    R2(c, d, e, a, b, 33);\n    R2(b, c, d, e, a, 34);\n    R2(a, b, c, d, e, 35);\n    R2(e, a, b, c, d, 36);\n    R2(d, e, a, b, c, 37);\n    R2(c, d, e, a, b, 38);\n    R2(b, c, d, e, a, 39);\n    R3(a, b, c, d, e, 40);\n    R3(e, a, b, c, d, 41);\n    R3(d, e, a, b, c, 42);\n    R3(c, d, e, a, b, 43);\n    R3(b, c, d, e, a, 44);\n    R3(a, b, c, d, e, 45);\n    R3(e, a, b, c, d, 46);\n    R3(d, e, a, b, c, 47);\n    R3(c, d, e, a, b, 48);\n    R3(b, c, d, e, a, 49);\n    R3(a, b, c, d, e, 50);\n    R3(e, a, b, c, d, 51);\n    R3(d, e, a, b, c, 52);\n    R3(c, d, e, a, b, 53);\n    R3(b, c, d, e, a, 54);\n    R3(a, b, c, d, e, 55);\n    R3(e, a, b, c, d, 56);\n    R3(d, e, a, b, c, 57);\n    R3(c, d, e, a, b, 58);\n    R3(b, c, d, e, a, 59);\n    R4(a, b, c, d, e, 60);\n    R4(e, a, b, c, d, 61);\n    R4(d, e, a, b, c, 62);\n    R4(c, d, e, a, b, 63);\n    R4(b, c, d, e, a, 64);\n    R4(a, b, c, d, e, 65);\n    R4(e, a, b, c, d, 66);\n    R4(d, e, a, b, c, 67);\n    R4(c, d, e, a, b, 68);\n    R4(b, c, d, e, a, 69);\n    R4(a, b, c, d, e, 70);\n    R4(e, a, b, c, d, 71);\n    R4(d, e, a, b, c, 72);\n    R4(c, d, e, a, b, 73);\n    R4(b, c, d, e, a, 74);\n    R4(a, b, c, d, e, 75);\n    R4(e, a, b, c, d, 76);\n    R4(d, e, a, b, c, 77);\n    R4(c, d, e, a, b, 78);\n    R4(b, c, d, e, a, 79);\n    /* Add the working vars back into context.state[] */\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    /* Wipe variables */\n    a = b = c = d = e = 0;\n#ifdef SHA1HANDSOFF\n    memset(block, '\\0', sizeof(block));\n#endif\n}\n\n\n/* SHA1Init - Initialize new context */\n\nvoid SHA1Init(\n    SHA1_CTX * context\n)\n{\n    /* SHA1 initialization constants */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xEFCDAB89;\n    context->state[2] = 0x98BADCFE;\n    context->state[3] = 0x10325476;\n    context->state[4] = 0xC3D2E1F0;\n    context->count[0] = context->count[1] = 0;\n}\n\n\n/* Run your data through this. */\n\nvoid SHA1Update(\n    SHA1_CTX * context,\n    const unsigned char *data,\n    uint32_t len\n)\n{\n    uint32_t i;\n\n    uint32_t j;\n\n    j = context->count[0];\n    if ((context->count[0] += len << 3) < j)\n        context->count[1]++;\n    context->count[1] += (len >> 29);\n    j = (j >> 3) & 63;\n    if ((j + len) > 63)\n    {\n        memcpy(&context->buffer[j], data, (i = 64 - j));\n        SHA1Transform(context->state, context->buffer);\n        for (; i + 63 < len; i += 64)\n        {\n            SHA1Transform(context->state, &data[i]);\n        }\n        j = 0;\n    }\n    else\n        i = 0;\n    memcpy(&context->buffer[j], &data[i], len - i);\n}\n\n\n/* Add padding and return the message digest. */\n\nvoid SHA1Final(\n    unsigned char digest[20],\n    SHA1_CTX * context\n)\n{\n    unsigned i;\n\n    unsigned char finalcount[8];\n\n    unsigned char c;\n\n#if 0    /* untested \"improvement\" by DHR */\n    /* Convert context->count to a sequence of bytes\n     * in finalcount.  Second element first, but\n     * big-endian order within element.\n     * But we do it all backwards.\n     */\n    unsigned char *fcp = &finalcount[8];\n    for (i = 0; i < 2; i++)\n    {\n        uint32_t t = context->count[i];\n        int j;\n        for (j = 0; j < 4; t >>= 8, j++)\n            *--fcp = (unsigned char) t}\n#else\n    for (i = 0; i < 8; i++)\n    {\n        finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);      /* Endian independent */\n    }\n#endif\n    c = 0200;\n    SHA1Update(context, &c, 1);\n    while ((context->count[0] & 504) != 448)\n    {\n        c = 0000;\n        SHA1Update(context, &c, 1);\n    }\n    SHA1Update(context, finalcount, 8); /* Should cause a SHA1Transform() */\n    for (i = 0; i < 20; i++)\n    {\n        digest[i] = (unsigned char)\n            ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n    }\n    /* Wipe variables */\n    memset(context, '\\0', sizeof(*context));\n    memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\n// End SHA-1 implementation.\n// =======================================================================================\n\nstatic const char* METHOD_NAMES[] = {\n#define METHOD_NAME(id) #id,\nKJ_HTTP_FOR_EACH_METHOD(METHOD_NAME)\n#undef METHOD_NAME\n};\n\nkj::StringPtr KJ_STRINGIFY(HttpMethod method) {\n  auto index = static_cast<uint>(method);\n  KJ_ASSERT(index < size(METHOD_NAMES), \"invalid HTTP method\");\n\n  return METHOD_NAMES[index];\n}\n\nkj::StringPtr KJ_STRINGIFY(HttpConnectMethod method) {\n  return \"CONNECT\"_kj;\n}\n\nstatic kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> consumeHttpMethod(char*& ptr) {\n  char* p = ptr;\n\n#define EXPECT_REST(prefix, suffix) \\\n  if (strncmp(p, #suffix, sizeof(#suffix)-1) == 0) { \\\n    ptr = p + (sizeof(#suffix)-1); \\\n    return kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>>(HttpMethod::prefix##suffix); \\\n  } else { \\\n    return kj::none; \\\n  }\n\n  switch (*p++) {\n    case 'A': EXPECT_REST(A,CL)\n    case 'C':\n      switch (*p++) {\n        case 'H': EXPECT_REST(CH,ECKOUT)\n        case 'O':\n          switch (*p++) {\n            case 'P': EXPECT_REST(COP,Y)\n            case 'N':\n              if (strncmp(p, \"NECT\", 4) == 0) {\n                ptr = p + 4;\n                return kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>>(HttpConnectMethod());\n              } else {\n                return kj::none;\n              }\n            default: return kj::none;\n          }\n        default: return kj::none;\n      }\n    case 'D': EXPECT_REST(D,ELETE)\n    case 'G': EXPECT_REST(G,ET)\n    case 'H': EXPECT_REST(H,EAD)\n    case 'L': EXPECT_REST(L,OCK)\n    case 'M':\n      switch (*p++) {\n        case 'E': EXPECT_REST(ME,RGE)\n        case 'K':\n          switch (*p++) {\n            case 'A': EXPECT_REST(MKA,CTIVITY)\n            case 'C': EXPECT_REST(MKC,OL)\n            default: return kj::none;\n          }\n        case 'O': EXPECT_REST(MO,VE)\n        case 'S': EXPECT_REST(MS,EARCH)\n        default: return kj::none;\n      }\n    case 'N': EXPECT_REST(N,OTIFY)\n    case 'O': EXPECT_REST(O,PTIONS)\n    case 'P':\n      switch (*p++) {\n        case 'A': EXPECT_REST(PA,TCH)\n        case 'O': EXPECT_REST(PO,ST)\n        case 'R':\n          if (*p++ != 'O' || *p++ != 'P') return kj::none;\n          switch (*p++) {\n            case 'F': EXPECT_REST(PROPF,IND)\n            case 'P': EXPECT_REST(PROPP,ATCH)\n            default: return kj::none;\n          }\n        case 'U':\n          switch (*p++) {\n            case 'R': EXPECT_REST(PUR,GE)\n            case 'T': EXPECT_REST(PUT,)\n            default: return kj::none;\n          }\n        default: return kj::none;\n      }\n    case 'R': EXPECT_REST(R,EPORT)\n    case 'S':\n      switch (*p++) {\n        case 'E': EXPECT_REST(SE,ARCH)\n        case 'U': EXPECT_REST(SU,BSCRIBE)\n        default: return kj::none;\n      }\n    case 'T': EXPECT_REST(T,RACE)\n    case 'U':\n      if (*p++ != 'N') return kj::none;\n      switch (*p++) {\n        case 'L': EXPECT_REST(UNL,OCK)\n        case 'S': EXPECT_REST(UNS,UBSCRIBE)\n        default: return kj::none;\n      }\n    default: return kj::none;\n  }\n#undef EXPECT_REST\n}\n\nkj::Maybe<HttpMethod> tryParseHttpMethod(kj::StringPtr name) {\n  KJ_IF_SOME(method, tryParseHttpMethodAllowingConnect(name)) {\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) { return m; }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) { return kj::none; }\n    }\n    KJ_UNREACHABLE;\n  } else {\n    return kj::none;\n  }\n}\n\nkj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> tryParseHttpMethodAllowingConnect(\n    kj::StringPtr name) {\n  // const_cast OK because we don't actually access it. consumeHttpMethod() is also called by some\n  // code later than explicitly needs to use a non-const pointer.\n  char* ptr = const_cast<char*>(name.begin());\n  auto result = consumeHttpMethod(ptr);\n  if (*ptr == '\\0') {\n    return result;\n  } else {\n    return kj::none;\n  }\n}\n\n// =======================================================================================\n\nnamespace {\n\nconstexpr char WEBSOCKET_GUID[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n// From RFC6455.\n\nstatic kj::String generateWebSocketAccept(kj::StringPtr key) {\n  // WebSocket demands we do a SHA-1 here. ARRGHH WHY SHA-1 WHYYYYYY?\n  SHA1_CTX ctx;\n  byte digest[20];\n  SHA1Init(&ctx);\n  SHA1Update(&ctx, key.asBytes().begin(), key.size());\n  SHA1Update(&ctx, reinterpret_cast<const byte*>(WEBSOCKET_GUID), strlen(WEBSOCKET_GUID));\n  SHA1Final(digest, &ctx);\n  return kj::encodeBase64(digest);\n}\n\nconstexpr auto HTTP_SEPARATOR_CHARS = kj::parse::anyOfChars(\"()<>@,;:\\\\\\\"/[]?={} \\t\");\n// RFC2616 section 2.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\n\nconstexpr auto HTTP_TOKEN_CHARS =\n    kj::parse::controlChar.orChar('\\x7f')\n    .orGroup(kj::parse::whitespaceChar)\n    .orGroup(HTTP_SEPARATOR_CHARS)\n    .invert();\n// RFC2616 section 2.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\n\nconstexpr auto HTTP_HEADER_NAME_CHARS = HTTP_TOKEN_CHARS;\n// RFC2616 section 4.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n\nstatic void requireValidHeaderName(kj::StringPtr name) {\n  for (char c: name) {\n    KJ_REQUIRE(HTTP_HEADER_NAME_CHARS.contains(c), \"invalid header name\", name);\n  }\n}\n\nstatic void requireValidHeaderValue(kj::StringPtr value) {\n  KJ_REQUIRE(HttpHeaders::isValidHeaderValue(value), \"invalid header value\",\n      kj::encodeCEscape(value));\n}\n\nstatic const char* BUILTIN_HEADER_NAMES[] = {\n  // Indexed by header ID, which includes connection headers, so we include those names too.\n#define HEADER_NAME(id, name) name,\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(HEADER_NAME)\n#undef HEADER_NAME\n};\n\n}  // namespace\n\n#define HEADER_ID(id, name) constexpr uint HttpHeaders::BuiltinIndices::id;\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(HEADER_ID)\n#undef HEADER_ID\n\n#define DEFINE_HEADER(id, name) \\\nconst HttpHeaderId HttpHeaderId::id(nullptr, HttpHeaders::BuiltinIndices::id);\nKJ_HTTP_FOR_EACH_BUILTIN_HEADER(DEFINE_HEADER)\n#undef DEFINE_HEADER\n\nkj::StringPtr HttpHeaderId::toString() const {\n  if (table == nullptr) {\n    KJ_ASSERT(id < kj::size(BUILTIN_HEADER_NAMES));\n    return BUILTIN_HEADER_NAMES[id];\n  } else {\n    return table->idToString(*this);\n  }\n}\n\nnamespace {\n\nstruct HeaderNameHash {\n  size_t operator()(kj::StringPtr s) const {\n    size_t result = 5381;\n    for (byte b: s.asBytes()) {\n      // Masking bit 0x20 makes our hash case-insensitive while conveniently avoiding any\n      // collisions that would matter for header names.\n      result = ((result << 5) + result) ^ (b & ~0x20);\n    }\n    return result;\n  }\n\n  bool operator()(kj::StringPtr a, kj::StringPtr b) const {\n    // TODO(perf): I wonder if we can beat strcasecmp() by masking bit 0x20 from each byte. We'd\n    //   need to prohibit one of the technically-legal characters '^' or '~' from header names\n    //   since they'd otherwise be ambiguous, but otherwise there is no ambiguity.\n#if _MSC_VER\n    return _stricmp(a.cStr(), b.cStr()) == 0;\n#else\n    return strcasecmp(a.cStr(), b.cStr()) == 0;\n#endif\n  }\n};\n\n}  // namespace\n\nstruct HttpHeaderTable::IdsByNameMap {\n  // TODO(perf): If we were cool we could maybe use a perfect hash here, since our hashtable is\n  //   static once built.\n\n  std::unordered_map<kj::StringPtr, uint, HeaderNameHash, HeaderNameHash> map;\n};\n\nHttpHeaderTable::Builder::Builder()\n    : table(kj::heap<HttpHeaderTable>()) {\n  table->buildStatus = BuildStatus::BUILDING;\n}\n\nHttpHeaderId HttpHeaderTable::Builder::add(kj::StringPtr name) {\n  requireValidHeaderName(name);\n\n  auto insertResult = table->idsByName->map.insert(std::make_pair(name, table->namesById.size()));\n  if (insertResult.second) {\n    table->namesById.add(name);\n  }\n  return HttpHeaderId(table, insertResult.first->second);\n}\n\nHttpHeaderTable::HttpHeaderTable()\n    : idsByName(kj::heap<IdsByNameMap>()) {\n#define ADD_HEADER(id, name) \\\n  namesById.add(name); \\\n  idsByName->map.insert(std::make_pair(name, HttpHeaders::BuiltinIndices::id));\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(ADD_HEADER);\n#undef ADD_HEADER\n}\nHttpHeaderTable::~HttpHeaderTable() noexcept(false) {}\n\nkj::Maybe<HttpHeaderId> HttpHeaderTable::stringToId(kj::StringPtr name) const {\n  auto iter = idsByName->map.find(name);\n  if (iter == idsByName->map.end()) {\n    return kj::none;\n  } else {\n    return HttpHeaderId(this, iter->second);\n  }\n}\n\n// =======================================================================================\n\nbool HttpHeaders::isValidHeaderValue(kj::StringPtr value) {\n  for (char c: value) {\n    // While the HTTP spec suggests that only printable ASCII characters are allowed in header\n    // values, reality has a different opinion. See: https://github.com/httpwg/http11bis/issues/19\n    // We follow the browsers' lead.\n    if (c == '\\0' || c == '\\r' || c == '\\n') {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nHttpHeaders::HttpHeaders(const HttpHeaderTable& table)\n    : table(&table),\n      indexedHeaders(kj::heapArray<kj::StringPtr>(table.idCount())) {\n  KJ_ASSERT(\n      table.isReady(), \"HttpHeaders object was constructed from \"\n      \"HttpHeaderTable that wasn't fully built yet at the time of construction\");\n}\n\nvoid HttpHeaders::clear() {\n  for (auto& header: indexedHeaders) {\n    header = nullptr;\n  }\n\n  unindexedHeaders.clear();\n}\n\nsize_t HttpHeaders::size() const {\n  size_t result = unindexedHeaders.size();\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      ++result;\n    }\n  }\n  return result;\n}\n\nHttpHeaders HttpHeaders::clone() const {\n  HttpHeaders result(*table);\n\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      result.indexedHeaders[i] = result.cloneToOwn(indexedHeaders[i]);\n    }\n  }\n\n  result.unindexedHeaders.resize(unindexedHeaders.size());\n  for (auto i: kj::indices(unindexedHeaders)) {\n    result.unindexedHeaders[i].name = result.cloneToOwn(unindexedHeaders[i].name);\n    result.unindexedHeaders[i].value = result.cloneToOwn(unindexedHeaders[i].value);\n  }\n\n  return result;\n}\n\nHttpHeaders HttpHeaders::cloneShallow() const {\n  HttpHeaders result(*table);\n\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      result.indexedHeaders[i] = indexedHeaders[i];\n    }\n  }\n\n  result.unindexedHeaders.resize(unindexedHeaders.size());\n  for (auto i: kj::indices(unindexedHeaders)) {\n    result.unindexedHeaders[i] = unindexedHeaders[i];\n  }\n\n  return result;\n}\n\nkj::StringPtr HttpHeaders::cloneToOwn(kj::StringPtr str) {\n  auto copy = kj::heapString(str);\n  kj::StringPtr result = copy;\n  ownedStrings.add(copy.releaseArray());\n  return result;\n}\n\n\nnamespace {\n\ntemplate <char... chars>\nconstexpr bool fastCaseCmp(const char* actual);\n\n}  // namespace\n\nbool HttpHeaders::isWebSocket() const {\n  return fastCaseCmp<'w', 'e', 'b', 's', 'o', 'c', 'k', 'e', 't'>(\n      get(HttpHeaderId::UPGRADE).orDefault(nullptr).cStr());\n}\n\nvoid HttpHeaders::set(HttpHeaderId id, kj::StringPtr value) {\n  id.requireFrom(*table);\n  requireValidHeaderValue(value);\n\n  indexedHeaders[id.id] = value;\n}\n\nvoid HttpHeaders::set(HttpHeaderId id, kj::String&& value) {\n  set(id, kj::StringPtr(value));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::add(kj::StringPtr name, kj::StringPtr value) {\n  requireValidHeaderName(name);\n  requireValidHeaderValue(value);\n\n  addNoCheck(name, value);\n}\n\nvoid HttpHeaders::add(kj::StringPtr name, kj::String&& value) {\n  add(name, kj::StringPtr(value));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::add(kj::String&& name, kj::String&& value) {\n  add(kj::StringPtr(name), kj::StringPtr(value));\n  takeOwnership(kj::mv(name));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::addNoCheck(kj::StringPtr name, kj::StringPtr value) {\n  KJ_IF_SOME(id, table->stringToId(name)) {\n    if (indexedHeaders[id.id] == nullptr) {\n      indexedHeaders[id.id] = value;\n    } else {\n      // Duplicate HTTP headers are equivalent to the values being separated by a comma.\n\n#if _MSC_VER\n      if (_stricmp(name.cStr(), \"set-cookie\") == 0) {\n#else\n      if (strcasecmp(name.cStr(), \"set-cookie\") == 0) {\n#endif\n        // Uh-oh, Set-Cookie will be corrupted if we try to concatenate it. We'll make it an\n        // unindexed header, which is weird, but the alternative is guaranteed corruption, so...\n        // TODO(cleanup): Maybe HttpHeaders should just special-case set-cookie in general?\n        unindexedHeaders.add(Header {name, value});\n      } else {\n        auto concat = kj::str(indexedHeaders[id.id], \", \", value);\n        indexedHeaders[id.id] = concat;\n        ownedStrings.add(concat.releaseArray());\n      }\n    }\n  } else {\n    unindexedHeaders.add(Header {name, value});\n  }\n}\n\nvoid HttpHeaders::takeOwnership(kj::String&& string) {\n  ownedStrings.add(string.releaseArray());\n}\nvoid HttpHeaders::takeOwnership(kj::Array<char>&& chars) {\n  ownedStrings.add(kj::mv(chars));\n}\nvoid HttpHeaders::takeOwnership(HttpHeaders&& otherHeaders) {\n  for (auto& str: otherHeaders.ownedStrings) {\n    ownedStrings.add(kj::mv(str));\n  }\n  otherHeaders.ownedStrings.clear();\n}\n\n// -----------------------------------------------------------------------------\n\nstatic inline const char* skipSpace(const char* p) {\n  for (;;) {\n    switch (*p) {\n      case '\\t':\n      case ' ':\n        ++p;\n        break;\n      default:\n        return p;\n    }\n  }\n}\nstatic inline char* skipSpace(char* p) {\n  return const_cast<char*>(skipSpace(const_cast<const char*>(p)));\n}\n\nstatic kj::Maybe<kj::StringPtr> consumeWord(char*& ptr) {\n  char* start = skipSpace(ptr);\n  char* p = start;\n\n  for (;;) {\n    switch (*p) {\n      case '\\0':\n        ptr = p;\n        return kj::StringPtr(start, p);\n\n      case '\\t':\n      case ' ': {\n        char* end = p++;\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      case '\\n':\n      case '\\r':\n        // Not expecting EOL!\n        return kj::none;\n\n      default:\n        ++p;\n        break;\n    }\n  }\n}\n\nstatic kj::Maybe<uint> consumeNumber(const char*& ptr) {\n  const char* start = skipSpace(ptr);\n  const char* p = start;\n\n  uint result = 0;\n\n  for (;;) {\n    const char c = *p;\n    if ('0' <= c && c <= '9') {\n      result = result * 10 + (c - '0');\n      ++p;\n    } else {\n      if (p == start) return kj::none;\n      ptr = p;\n      return result;\n    }\n  }\n}\nstatic kj::Maybe<uint> consumeNumber(char*& ptr) {\n  const char* constPtr = ptr;\n  auto result = consumeNumber(constPtr);\n  ptr = const_cast<char*>(constPtr);\n  return result;\n}\n\nstatic kj::StringPtr consumeLine(char*& ptr) {\n  char* start = skipSpace(ptr);\n  char* p = start;\n\n  for (;;) {\n    switch (*p) {\n      case '\\0':\n        ptr = p;\n        return kj::StringPtr(start, p);\n\n      case '\\r': {\n        char* end = p++;\n        if (*p == '\\n') ++p;\n\n        if (*p == ' ' || *p == '\\t') {\n          // Whoa, continuation line. These are deprecated, but historically a line starting with\n          // a space was treated as a continuation of the previous line. The behavior should be\n          // the same as if the \\r\\n were replaced with spaces, so let's do that here to prevent\n          // confusion later.\n          *end = ' ';\n          p[-1] = ' ';\n          break;\n        }\n\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      case '\\n': {\n        char* end = p++;\n\n        if (*p == ' ' || *p == '\\t') {\n          // Whoa, continuation line. These are deprecated, but historically a line starting with\n          // a space was treated as a continuation of the previous line. The behavior should be\n          // the same as if the \\n were replaced with spaces, so let's do that here to prevent\n          // confusion later.\n          *end = ' ';\n          break;\n        }\n\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      default:\n        ++p;\n        break;\n    }\n  }\n}\n\nstatic kj::Maybe<kj::StringPtr> consumeHeaderName(char*& ptr) {\n  // Do NOT skip spaces before the header name. Leading spaces indicate a continuation line; they\n  // should have been handled in consumeLine().\n  char* p = ptr;\n\n  char* start = p;\n  while (HTTP_HEADER_NAME_CHARS.contains(*p)) ++p;\n  char* end = p;\n\n  p = skipSpace(p);\n\n  if (end == start || *p != ':') return kj::none;\n  ++p;\n\n  p = skipSpace(p);\n\n  *end = '\\0';\n  ptr = p;\n  return kj::StringPtr(start, end);\n}\n\nstatic char* trimHeaderEnding(kj::ArrayPtr<char> content) {\n  // Trim off the trailing \\r\\n from a header blob.\n\n  if (content.size() < 2) return nullptr;\n\n  // Remove trailing \\r\\n\\r\\n and replace with \\0 sentinel char.\n  char* end = content.end();\n\n  if (end[-1] != '\\n') return nullptr;\n  --end;\n  if (end[-1] == '\\r') --end;\n  *end = '\\0';\n\n  return end;\n}\n\nHttpHeaders::RequestOrProtocolError HttpHeaders::tryParseRequest(kj::ArrayPtr<char> content) {\n  KJ_SWITCH_ONEOF(tryParseRequestOrConnect(content)) {\n    KJ_CASE_ONEOF(request, Request) {\n      return kj::mv(request);\n    }\n    KJ_CASE_ONEOF(error, ProtocolError) {\n      return kj::mv(error);\n    }\n    KJ_CASE_ONEOF(connect, ConnectRequest) {\n      return ProtocolError { 501, \"Not Implemented\",\n          \"Unrecognized request method.\", content };\n    }\n  }\n  KJ_UNREACHABLE;\n}\n\nHttpHeaders::RequestConnectOrProtocolError HttpHeaders::tryParseRequestOrConnect(\n    kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) {\n    return ProtocolError { 400, \"Bad Request\",\n        \"Request headers have no terminal newline.\", content };\n  }\n\n  char* ptr = content.begin();\n\n  HttpHeaders::RequestConnectOrProtocolError result;\n\n  KJ_IF_SOME(method, consumeHttpMethod(ptr)) {\n    if (*ptr != ' ' && *ptr != '\\t') {\n      return ProtocolError { 501, \"Not Implemented\",\n          \"Unrecognized request method.\", content };\n    }\n    ++ptr;\n\n    kj::Maybe<StringPtr> path;\n    KJ_IF_SOME(p, consumeWord(ptr)) {\n      path = p;\n    } else {\n      return ProtocolError { 400, \"Bad Request\",\n          \"Invalid request line.\", content };\n    }\n\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) {\n        result = HttpHeaders::Request { m, KJ_ASSERT_NONNULL(path) };\n      }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) {\n        result = HttpHeaders::ConnectRequest { KJ_ASSERT_NONNULL(path) };\n      }\n    }\n  } else {\n    return ProtocolError { 501, \"Not Implemented\",\n        \"Unrecognized request method.\", content };\n  }\n\n  // Ignore rest of line. Don't care about \"HTTP/1.1\" or whatever.\n  consumeLine(ptr);\n\n  if (!parseHeaders(ptr, end)) {\n    return ProtocolError { 400, \"Bad Request\",\n        \"The headers sent by your client are not valid.\", content };\n  }\n\n  return result;\n}\n\nHttpHeaders::ResponseOrProtocolError HttpHeaders::tryParseResponse(kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Response headers have no terminal newline.\", content };\n  }\n\n  char* ptr = content.begin();\n\n  HttpHeaders::Response response;\n\n  KJ_IF_SOME(version, consumeWord(ptr)) {\n    if (!version.startsWith(\"HTTP/\")) {\n      return ProtocolError { 502, \"Bad Gateway\",\n          \"Invalid response status line (invalid protocol).\", content };\n    }\n  } else {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Invalid response status line (no spaces).\", content };\n  }\n\n  KJ_IF_SOME(code, consumeNumber(ptr)) {\n    response.statusCode = code;\n  } else {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Invalid response status line (invalid status code).\", content };\n  }\n\n  response.statusText = consumeLine(ptr);\n\n  if (!parseHeaders(ptr, end)) {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"The headers sent by the server are not valid.\", content };\n  }\n\n  return response;\n}\n\nbool HttpHeaders::tryParse(kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) return false;\n\n  char* ptr = content.begin();\n  return parseHeaders(ptr, end);\n}\n\nbool HttpHeaders::parseHeaders(char* ptr, char* end) {\n  while (*ptr != '\\0') {\n    KJ_IF_SOME(name, consumeHeaderName(ptr)) {\n      kj::StringPtr line = consumeLine(ptr);\n      addNoCheck(name, line);\n    } else {\n      return false;\n    }\n  }\n\n  return ptr == end;\n}\n\n// -----------------------------------------------------------------------------\n\nkj::String HttpHeaders::serializeRequest(\n    HttpMethod method, kj::StringPtr url,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  return serialize(kj::toCharSequence(method), url, kj::StringPtr(\"HTTP/1.1\"), connectionHeaders);\n}\n\nkj::String HttpHeaders::serializeConnectRequest(\n    kj::StringPtr authority,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  return serialize(\"CONNECT\"_kj, authority, kj::StringPtr(\"HTTP/1.1\"), connectionHeaders);\n}\n\nkj::String HttpHeaders::serializeResponse(\n    uint statusCode, kj::StringPtr statusText,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  auto statusCodeStr = kj::toCharSequence(statusCode);\n\n  return serialize(kj::StringPtr(\"HTTP/1.1\"), statusCodeStr, statusText, connectionHeaders);\n}\n\nkj::String HttpHeaders::serialize(kj::ArrayPtr<const char> word1,\n                                  kj::ArrayPtr<const char> word2,\n                                  kj::ArrayPtr<const char> word3,\n                                  kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  const kj::StringPtr space = \" \";\n  const kj::StringPtr newline = \"\\r\\n\";\n  const kj::StringPtr colon = \": \";\n\n  size_t size = 2;  // final \\r\\n\n  if (word1 != nullptr) {\n    size += word1.size() + word2.size() + word3.size() + 4;\n  }\n  KJ_ASSERT(connectionHeaders.size() <= indexedHeaders.size());\n  for (auto i: kj::indices(indexedHeaders)) {\n    kj::StringPtr value = i < connectionHeaders.size() ? connectionHeaders[i] : indexedHeaders[i];\n    if (value != nullptr) {\n      size += table->idToString(HttpHeaderId(table, i)).size() + value.size() + 4;\n    }\n  }\n  for (auto& header: unindexedHeaders) {\n    size += header.name.size() + header.value.size() + 4;\n  }\n\n  String result = heapString(size);\n  char* ptr = result.begin();\n\n  if (word1 != nullptr) {\n    ptr = kj::_::fill(ptr, word1, space, word2, space, word3, newline);\n  }\n  for (auto i: kj::indices(indexedHeaders)) {\n    kj::StringPtr value = i < connectionHeaders.size() ? connectionHeaders[i] : indexedHeaders[i];\n    if (value != nullptr) {\n      ptr = kj::_::fill(ptr, table->idToString(HttpHeaderId(table, i)), colon, value, newline);\n    }\n  }\n  for (auto& header: unindexedHeaders) {\n    ptr = kj::_::fill(ptr, header.name, colon, header.value, newline);\n  }\n  ptr = kj::_::fill(ptr, newline);\n\n  KJ_ASSERT(ptr == result.end());\n  return result;\n}\n\nkj::String HttpHeaders::toString() const {\n  return serialize(nullptr, nullptr, nullptr, nullptr);\n}\n\n// -----------------------------------------------------------------------------\n\n\nnamespace {\n\n// The functions below parse HTTP \"ranges specifiers\" set in `Range` headers and defined by\n// RFC9110 section 14.1: https://www.rfc-editor.org/rfc/rfc9110#section-14.1.\n//\n// Ranges specifiers consist of a case-insensitive \"range unit\", followed by an '=', followed by a\n// comma separated list of \"range specs\". We currently only support byte ranges, with a range unit\n// of \"bytes\". A byte range spec can either be:\n//\n// - An \"int range\" consisting of an inclusive start index, followed by a '-', and optionally an\n//   inclusive end index (e.g. \"2-5\", \"7-7\", \"9-\"). Satisfiable if the start index is less than\n//   the content length. Note the end index defaults to, and is clamped to the content length.\n// - A \"suffix range\" consisting of a '-', followed by a suffix length (e.g. \"-5\"). Satisfiable\n//   if the suffix length is not 0. Note the suffix length is clamped to the content length.\n//\n// A full ranges specifier might look something like \"bytes=2-4,-1\", which requests bytes 2 through\n// 4, and the last byte.\n//\n// A range spec is invalid if it doesn't match the above structure, or if it is an int range\n// with an end index > start index. A ranges specifier is invalid if any of its range specs are.\n// A byte ranges specifier is satisfiable if at least one of its range specs are.\n//\n// `tryParseHttpRangeHeader()` will return an array of satisfiable ranges, unless the ranges\n// specifier is invalid.\n\nstatic bool consumeByteRangeUnit(const char*& ptr) {\n  const char* p = ptr;\n  p = skipSpace(p);\n\n  // Match case-insensitive \"bytes\"\n  if (*p != 'b' && *p != 'B') return false;\n  if (*(++p) != 'y' && *p != 'Y') return false;\n  if (*(++p) != 't' && *p != 'T') return false;\n  if (*(++p) != 'e' && *p != 'E') return false;\n  if (*(++p) != 's' && *p != 'S') return false;\n  ++p;\n\n  p = skipSpace(p);\n  ptr = p;\n  return true;\n}\n\nstatic kj::Maybe<HttpByteRange> consumeIntRange(const char*& ptr, uint64_t contentLength) {\n  const char* p = ptr;\n  p = skipSpace(p);\n  uint firstPos;\n  KJ_IF_SOME(n, consumeNumber(p)) {\n    firstPos = n;\n  } else {\n    return kj::none;\n  }\n  p = skipSpace(p);\n  if (*(p++) != '-') return kj::none;\n  p = skipSpace(p);\n  auto maybeLastPos = consumeNumber(p);\n  p = skipSpace(p);\n\n  KJ_IF_SOME(lastPos, maybeLastPos) {\n    // \"An int-range is invalid if the last-pos value is present and less than the first-pos\"\n    if (firstPos > lastPos) return kj::none;\n    // \"if the value is greater than or equal to the current length of the representation data\n    // ... interpreted as the remainder of the representation\"\n    if (lastPos >= contentLength) lastPos = contentLength - 1;\n    ptr = p;\n    return HttpByteRange { firstPos, lastPos };\n  } else {\n    // \"if the last-pos value is absent ... interpreted as the remainder of the representation\"\n    ptr = p;\n    return HttpByteRange { firstPos, contentLength - 1 };\n  }\n}\n\nstatic kj::Maybe<HttpByteRange> consumeSuffixRange(const char*& ptr, uint64_t contentLength) {\n  const char* p = ptr;\n  p = skipSpace(p);\n  if (*(p++) != '-') return kj::none;\n  p = skipSpace(p);\n  uint suffixLength;\n  KJ_IF_SOME(n, consumeNumber(p)) {\n    suffixLength = n;\n  } else {\n    return kj::none;\n  }\n  p = skipSpace(p);\n\n  ptr = p;\n  if (suffixLength >= contentLength) {\n    // \"if the selected representation is shorter than the specified suffix-length, the entire\n    // representation is used\"\n    return HttpByteRange { 0, contentLength - 1 };\n  } else {\n    return HttpByteRange { contentLength - suffixLength, contentLength - 1 };\n  }\n}\n\nstatic kj::Maybe<HttpByteRange> consumeRangeSpec(const char*& ptr, uint64_t contentLength) {\n  KJ_IF_SOME(range, consumeIntRange(ptr, contentLength)) {\n    return range;\n  } else {\n    // If we failed to consume an int range, try consume a suffix range instead\n    return consumeSuffixRange(ptr, contentLength);\n  }\n}\n\n}  // namespace\n\nkj::String KJ_STRINGIFY(HttpByteRange range) {\n  return kj::str(range.start, \"-\", range.end);\n}\n\nHttpRanges tryParseHttpRangeHeader(kj::ArrayPtr<const char> value, uint64_t contentLength) {\n  const char* p = value.begin();\n  if (!consumeByteRangeUnit(p)) return HttpUnsatisfiableRange {};\n  if (*(p++) != '=') return HttpUnsatisfiableRange {};\n\n  auto fullRange = false;\n  kj::Vector<HttpByteRange> satisfiableRanges;\n  do {\n    KJ_IF_SOME(range, consumeRangeSpec(p, contentLength)) {\n      // Don't record more ranges if we've already recorded a full range\n      if (!fullRange && range.start <= range.end) {\n        if (range.start == 0 && range.end == contentLength - 1) {\n          // A range evaluated to the full range, but still need to check rest are valid\n          fullRange = true;\n        } else {\n          // \"a valid bytes range-spec is satisfiable if it is either:\n          // - an int-range with a first-pos that is less than the current length of the selected\n          //   representation or\n          // - a suffix-range with a non-zero suffix-length\"\n          satisfiableRanges.add(range);\n        }\n      }\n    } else {\n      // If we failed to parse a range, the whole range specification is invalid\n      return HttpUnsatisfiableRange {};\n    }\n  } while (*(p++) == ',');\n\n  if ((--p) != value.end()) return HttpUnsatisfiableRange {};\n  if (fullRange) return HttpEverythingRange {};\n  // \"A valid ranges-specifier is \"satisfiable\" if it contains at least one range-spec that is\n  // satisfiable\"\n  if (satisfiableRanges.size() == 0) return HttpUnsatisfiableRange {};\n  return satisfiableRanges.releaseAsArray();\n}\n\n// =======================================================================================\n\nnamespace {\n\ntemplate <typename Subclass>\nclass WrappableStreamMixin {\n  // Both HttpInputStreamImpl and HttpOutputStream are commonly wrapped by a class that implements\n  // a particular type of body stream, such as a chunked body or a fixed-length body. That wrapper\n  // stream is passed back to the application to represent the specific request/response body, but\n  // the inner stream is associated with the connection and can be reused several times.\n  //\n  // It's easy for applications to screw up and hold on to a body stream beyond the lifetime of the\n  // underlying connection stream. This used to lead to UAF. This mixin class implements behavior\n  // that detached the wrapper if it outlives the wrapped stream, so that we log errors and\n\npublic:\n  WrappableStreamMixin() = default;\n  WrappableStreamMixin(WrappableStreamMixin&& other) {\n    // This constructor is only needed by HttpServer::Connection::makeHttpInput() which constructs\n    // a new stream and returns it. Technically the constructor will always be elided anyway.\n    KJ_REQUIRE(other.currentWrapper == nullptr, \"can't move a wrappable object that has wrappers!\");\n  }\n  KJ_DISALLOW_COPY(WrappableStreamMixin);\n\n  ~WrappableStreamMixin() noexcept(false) {\n    KJ_IF_SOME(w, currentWrapper) {\n      KJ_LOG(ERROR, \"HTTP connection destroyed while HTTP body streams still exist\",\n          kj::getStackTrace());\n      w = nullptr;\n    }\n  }\n\n  void setCurrentWrapper(kj::Maybe<Subclass&>& weakRef) {\n    // Tracks the current `HttpEntityBodyReader` instance which is wrapping this stream. There can\n    // be only one wrapper at a time, and the wrapper must be destroyed before the underlying HTTP\n    // connection is torn down. The purpose of tracking the wrapper here is to detect when these\n    // rules are violated by apps, and log an error instead of going UB.\n    //\n    // `weakRef` is the wrapper's pointer to this object. If the underlying stream is destroyed\n    // before the wrapper, then `weakRef` will be nulled out.\n\n    // The API should prevent an app from obtaining multiple wrappers with the same backing stream.\n    KJ_ASSERT(currentWrapper == kj::none,\n        \"bug in KJ HTTP: only one HTTP stream wrapper can exist at a time\");\n\n    currentWrapper = weakRef;\n    weakRef = static_cast<Subclass&>(*this);\n  }\n\n  void unsetCurrentWrapper(kj::Maybe<Subclass&>& weakRef) {\n    auto& current = KJ_ASSERT_NONNULL(currentWrapper);\n    KJ_ASSERT(&current == &weakRef,\n        \"bug in KJ HTTP: unsetCurrentWrapper() passed the wrong wrapper\");\n    weakRef = kj::none;\n    currentWrapper = kj::none;\n  }\n\nprivate:\n  kj::Maybe<kj::Maybe<Subclass&>&> currentWrapper;\n};\n\n// =======================================================================================\n\nstatic constexpr size_t MIN_BUFFER = 4096;\nstatic constexpr size_t MAX_BUFFER = 128 * 1024;\nstatic constexpr size_t MAX_CHUNK_HEADER_SIZE = 32;\n\nclass HttpInputStreamImpl final: public HttpInputStream,\n                                 public WrappableStreamMixin<HttpInputStreamImpl> {\nprivate:\n  static kj::OneOf<HttpHeaders::Request, HttpHeaders::ConnectRequest> getResumingRequest(\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      kj::StringPtr url) {\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) {\n        return HttpHeaders::Request { m, url };\n      }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) {\n        return HttpHeaders::ConnectRequest { url };\n      }\n    }\n    KJ_UNREACHABLE;\n  }\npublic:\n  explicit HttpInputStreamImpl(AsyncInputStream& inner, const HttpHeaderTable& table)\n      : inner(inner), headerBuffer(kj::heapArray<char>(MIN_BUFFER)), headers(table) {\n  }\n\n  explicit HttpInputStreamImpl(AsyncInputStream& inner,\n      kj::Array<char> headerBufferParam,\n      kj::ArrayPtr<char> leftoverParam,\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      kj::StringPtr url,\n      HttpHeaders headers)\n      : inner(inner),\n        headerBuffer(kj::mv(headerBufferParam)),\n        // Initialize `messageHeaderEnd` to a safe value, we'll adjust it below.\n        messageHeaderEnd(leftoverParam.begin() - headerBuffer.begin()),\n        leftover(leftoverParam),\n        headers(kj::mv(headers)),\n        resumingRequest(getResumingRequest(method, url)) {\n    // Constructor used for resuming a SuspendedRequest.\n\n    // We expect headerBuffer to look like this:\n    //   <method> <url> <headers> [CR] LF <leftover>\n    // We initialized `messageHeaderEnd` to the beginning of `leftover`, but we want to point it at\n    // the CR (or LF if there's no CR).\n    KJ_REQUIRE(messageHeaderEnd >= 2 && leftover.end() <= headerBuffer.end(),\n        \"invalid SuspendedRequest - leftover buffer not where it should be\");\n    KJ_REQUIRE(leftover.begin()[-1] == '\\n', \"invalid SuspendedRequest - missing LF\");\n    messageHeaderEnd -= 1 + (leftover.begin()[-2] == '\\r');\n\n    // We're in the middle of a message, so set up our state as such. Note that the only way to\n    // resume a SuspendedRequest is via an HttpServer, but HttpServers never call\n    // `awaitNextMessage()` before fully reading request bodies, meaning we expect that\n    // `messageReadQueue` will never be used.\n    ++pendingMessageCount;\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    onMessageDone = kj::mv(paf.fulfiller);\n    messageReadQueue = kj::mv(paf.promise);\n  }\n\n  bool canReuse() {\n    return !broken && pendingMessageCount == 0;\n  }\n\n  bool canSuspend() {\n    // We are at a suspendable point if we've parsed the headers, but haven't consumed anything\n    // beyond that.\n    //\n    // TODO(cleanup): This is a silly check; we need a more defined way to track the state of the\n    //   stream.\n    bool messageHeaderEndLooksRight =\n        (leftover.begin() - (headerBuffer.begin() + messageHeaderEnd) == 2 &&\n            leftover.begin()[-1] == '\\n' && leftover.begin()[-2] == '\\r')\n        || (leftover.begin() - (headerBuffer.begin() + messageHeaderEnd) == 1 &&\n            leftover.begin()[-1] == '\\n');\n\n    return !broken && headerBuffer.size() > 0 && messageHeaderEndLooksRight;\n  }\n\n  // ---------------------------------------------------------------------------\n  // public interface\n\n  kj::Promise<Request> readRequest() override {\n    auto requestOrProtocolError = co_await readRequestHeaders();\n    auto request = KJ_REQUIRE_NONNULL(\n        requestOrProtocolError.tryGet<HttpHeaders::Request>(), \"bad request\");\n    auto body = getEntityBody(HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n\n    co_return { request.method, request.url, headers, kj::mv(body) };\n  }\n\n  kj::Promise<kj::OneOf<Request, Connect>> readRequestAllowingConnect() override {\n    auto requestOrProtocolError = co_await readRequestHeaders();\n    KJ_SWITCH_ONEOF(requestOrProtocolError) {\n      KJ_CASE_ONEOF(request, HttpHeaders::Request) {\n        auto body = getEntityBody(HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n        co_return HttpInputStream::Request { request.method, request.url, headers, kj::mv(body) };\n      }\n      KJ_CASE_ONEOF(request, HttpHeaders::ConnectRequest) {\n        auto body = getEntityBody(HttpInputStreamImpl::REQUEST, HttpConnectMethod(), 0, headers);\n        co_return HttpInputStream::Connect { request.authority, headers, kj::mv(body) };\n      }\n      KJ_CASE_ONEOF(error, HttpHeaders::ProtocolError) {\n        KJ_FAIL_REQUIRE(\"bad request\");\n      }\n    }\n    KJ_UNREACHABLE;\n  }\n\n  kj::Promise<Response> readResponse(HttpMethod requestMethod) override {\n    auto responseOrProtocolError = co_await readResponseHeaders();\n    auto response = KJ_REQUIRE_NONNULL(\n        responseOrProtocolError.tryGet<HttpHeaders::Response>(), \"bad response\");\n    auto body = getEntityBody(HttpInputStreamImpl::RESPONSE, requestMethod,\n                              response.statusCode, headers);\n\n    co_return { response.statusCode, response.statusText, headers, kj::mv(body) };\n  }\n\n  kj::Promise<Message> readMessage() override {\n    auto textOrError = co_await readMessageHeaders();\n    KJ_REQUIRE(textOrError.is<kj::ArrayPtr<char>>(), \"bad message\");\n    auto text = textOrError.get<kj::ArrayPtr<char>>();\n    headers.clear();\n    KJ_REQUIRE(headers.tryParse(text), \"bad message\");\n    auto body = getEntityBody(HttpInputStreamImpl::RESPONSE, HttpMethod::GET, 0, headers);\n\n    co_return { headers, kj::mv(body) };\n  }\n\n  // ---------------------------------------------------------------------------\n  // Stream locking: While an entity-body is being read, the body stream \"locks\" the underlying\n  // HTTP stream. Once the entity-body is complete, we can read the next pipelined message.\n\n  void finishRead() {\n    // Called when entire request has been read.\n\n    KJ_REQUIRE_NONNULL(onMessageDone)->fulfill();\n    onMessageDone = kj::none;\n    --pendingMessageCount;\n  }\n\n  void abortRead() {\n    // Called when a body input stream was destroyed without reading to the end.\n\n    KJ_REQUIRE_NONNULL(onMessageDone)->reject(KJ_EXCEPTION(FAILED,\n        \"application did not finish reading previous HTTP response body\",\n        \"can't read next pipelined request/response\"));\n    onMessageDone = kj::none;\n    broken = true;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  kj::Promise<bool> awaitNextMessage() override {\n    // Waits until more data is available, but doesn't consume it. Returns false on EOF.\n    //\n    // Used on the server after a request is handled, to check for pipelined requests.\n    //\n    // Used on the client to detect when idle connections are closed from the server end. (In this\n    // case, the promise always returns false or is canceled.)\n\n    if (resumingRequest != kj::none) {\n      // We're resuming a request, so report that we have a message.\n      co_return true;\n    }\n\n    if (onMessageDone != kj::none) {\n      // We're still working on reading the previous body.\n      auto fork = messageReadQueue.fork();\n      messageReadQueue = fork.addBranch();\n      co_await fork;\n    }\n\n    for (;;) {\n      snarfBufferedLineBreak();\n\n      if (!lineBreakBeforeNextHeader && leftover != nullptr) {\n        co_return true;\n      }\n\n      auto amount = co_await inner.tryRead(headerBuffer.begin(), 1, headerBuffer.size());\n      if (amount == 0) {\n        co_return false;\n      }\n\n      leftover = headerBuffer.slice(0, amount);\n    }\n  }\n\n  bool isCleanDrain() {\n    // Returns whether we can cleanly drain the stream at this point.\n    if (onMessageDone != kj::none) return false;\n    snarfBufferedLineBreak();\n    return !lineBreakBeforeNextHeader && leftover == nullptr;\n  }\n\n  kj::Promise<kj::OneOf<kj::ArrayPtr<char>, HttpHeaders::ProtocolError>> readMessageHeaders() {\n    ++pendingMessageCount;\n    auto paf = kj::newPromiseAndFulfiller<void>();\n\n    auto nextMessageReady = kj::mv(messageReadQueue);\n    messageReadQueue = kj::mv(paf.promise);\n\n    co_await nextMessageReady;\n    onMessageDone = kj::mv(paf.fulfiller);\n\n    co_return co_await readHeader(HeaderType::MESSAGE, 0, 0);\n  }\n\n  kj::Promise<kj::OneOf<uint64_t, HttpHeaders::ProtocolError>> readChunkHeader() {\n    KJ_REQUIRE(onMessageDone != kj::none);\n\n    // We use the portion of the header after the end of message headers.\n    auto textOrError = co_await readHeader(HeaderType::CHUNK, messageHeaderEnd, messageHeaderEnd);\n\n    KJ_SWITCH_ONEOF(textOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        KJ_REQUIRE(text.size() > 0) { break; }\n\n        uint64_t value = 0;\n        for (char c: text) {\n          if ('0' <= c && c <= '9') {\n            value = value * 16 + (c - '0');\n          } else if ('a' <= c && c <= 'f') {\n            value = value * 16 + (c - 'a' + 10);\n          } else if ('A' <= c && c <= 'F') {\n            value = value * 16 + (c - 'A' + 10);\n          } else {\n            KJ_FAIL_REQUIRE(\"invalid HTTP chunk size\", text, text.asBytes()) { break; }\n            co_return value;\n          }\n        }\n\n        co_return value;\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline kj::Promise<HttpHeaders::RequestConnectOrProtocolError> readRequestHeaders() {\n    KJ_IF_SOME(resuming, resumingRequest) {\n      KJ_DEFER(resumingRequest = kj::none);\n      co_return HttpHeaders::RequestConnectOrProtocolError(resuming);\n    }\n\n    auto textOrError = co_await readMessageHeaders();\n    KJ_SWITCH_ONEOF(textOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        headers.clear();\n        co_return headers.tryParseRequestOrConnect(text);\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline kj::Promise<HttpHeaders::ResponseOrProtocolError> readResponseHeaders() {\n    // Note: readResponseHeaders() could be called multiple times concurrently when pipelining\n    //   requests. readMessageHeaders() will serialize these, but it's important not to mess with\n    //   state (like calling headers.clear()) before said serialization has taken place.\n    auto headersOrError = co_await readMessageHeaders();\n    KJ_SWITCH_ONEOF(headersOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        headers.clear();\n        co_return headers.tryParseResponse(text);\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline const HttpHeaders& getHeaders() const { return headers; }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n    // Read message body data.\n\n    KJ_REQUIRE(onMessageDone != kj::none);\n\n    if (leftover == nullptr) {\n      // No leftovers. Forward directly to inner stream.\n      co_return co_await inner.tryRead(buffer, minBytes, maxBytes);\n    } else if (leftover.size() >= maxBytes) {\n      // Didn't even read the entire leftover buffer.\n      memcpy(buffer, leftover.begin(), maxBytes);\n      leftover = leftover.slice(maxBytes, leftover.size());\n      co_return maxBytes;\n    } else {\n      // Read the entire leftover buffer, plus some.\n      memcpy(buffer, leftover.begin(), leftover.size());\n      size_t copied = leftover.size();\n      leftover = nullptr;\n      if (copied >= minBytes) {\n        // Got enough to stop here.\n        co_return copied;\n      } else {\n        // Read the rest from the underlying stream.\n        auto n = co_await inner.tryRead(reinterpret_cast<byte*>(buffer) + copied,\n                             minBytes - copied, maxBytes - copied);\n        co_return n + copied;\n      }\n    }\n  }\n\n  enum RequestOrResponse {\n    REQUEST,\n    RESPONSE\n  };\n\n  kj::Own<kj::AsyncInputStream> getEntityBody(\n      RequestOrResponse type,\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      uint statusCode,\n      const kj::HttpHeaders& headers);\n\n  struct ReleasedBuffer {\n    kj::Array<byte> buffer;\n    kj::ArrayPtr<byte> leftover;\n  };\n\n  ReleasedBuffer releaseBuffer() {\n    return { headerBuffer.releaseAsBytes(), leftover.asBytes() };\n  }\n\n  kj::Promise<void> discard(AsyncOutputStream &output, size_t maxBytes) {\n    // Used to read and discard the input during error handling.\n    return inner.pumpTo(output, maxBytes).ignoreResult();\n  }\n\nprivate:\n  AsyncInputStream& inner;\n  kj::Array<char> headerBuffer;\n\n  size_t messageHeaderEnd = 0;\n  // Position in headerBuffer where the message headers end -- further buffer space can\n  // be used for chunk headers.\n\n  kj::ArrayPtr<char> leftover;\n  // Data in headerBuffer that comes immediately after the header content, if any.\n\n  HttpHeaders headers;\n  // Parsed headers, after a call to parseAwaited*().\n\n  kj::Maybe<kj::OneOf<HttpHeaders::Request, HttpHeaders::ConnectRequest>> resumingRequest;\n  // Non-null if we're resuming a SuspendedRequest.\n\n  bool lineBreakBeforeNextHeader = false;\n  // If true, the next await should expect to start with a spurious '\\n' or '\\r\\n'. This happens\n  // as a side-effect of HTTP chunked encoding, where such a newline is added to the end of each\n  // chunk, for no good reason.\n\n  bool broken = false;\n  // Becomes true if the caller failed to read the whole entity-body before closing the stream.\n\n  uint pendingMessageCount = 0;\n  // Number of reads we have queued up.\n\n  kj::Promise<void> messageReadQueue = kj::READY_NOW;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> onMessageDone;\n  // Fulfill once the current message has been completely read. Unblocks reading of the next\n  // message headers.\n\n  enum class HeaderType {\n    MESSAGE,\n    CHUNK\n  };\n\n  kj::Promise<kj::OneOf<kj::ArrayPtr<char>, HttpHeaders::ProtocolError>> readHeader(\n      HeaderType type, size_t bufferStart, size_t bufferEnd) {\n    // Reads the HTTP message header or a chunk header (as in transfer-encoding chunked) and\n    // returns the buffer slice containing it.\n    //\n    // The main source of complication here is that we want to end up with one continuous buffer\n    // containing the result, and that the input is delimited by newlines rather than by an upfront\n    // length.\n\n    for (;;) {\n      kj::Promise<size_t> readPromise = nullptr;\n\n      // Figure out where we're reading from.\n      if (leftover != nullptr) {\n        // Some data is still left over from the previous message, so start with that.\n\n        // This can only happen if this is the initial run through the loop.\n        KJ_ASSERT(bufferStart == bufferEnd);\n\n        // OK, set bufferStart and bufferEnd to both point to the start of the leftover, and then\n        // fake a read promise as if we read the bytes from the leftover.\n        bufferStart = leftover.begin() - headerBuffer.begin();\n        bufferEnd = bufferStart;\n        readPromise = leftover.size();\n        leftover = nullptr;\n      } else {\n        // Need to read more data from the underlying stream.\n\n        if (bufferEnd == headerBuffer.size()) {\n          // Out of buffer space.\n\n          // Maybe we can move bufferStart backwards to make more space at the end?\n          size_t minStart = type == HeaderType::MESSAGE ? 0 : messageHeaderEnd;\n\n          if (bufferStart > minStart) {\n            // Move to make space.\n            memmove(headerBuffer.begin() + minStart, headerBuffer.begin() + bufferStart,\n                    bufferEnd - bufferStart);\n            bufferEnd = bufferEnd - bufferStart + minStart;\n            bufferStart = minStart;\n          } else {\n            // Really out of buffer space. Grow the buffer.\n            if (type != HeaderType::MESSAGE) {\n              // Can't grow because we'd invalidate the HTTP headers.\n              kj::throwFatalException(KJ_EXCEPTION(FAILED, \"invalid HTTP chunk size\"));\n            }\n            if (headerBuffer.size() >= MAX_BUFFER) {\n              co_return HttpHeaders::ProtocolError {\n                  .statusCode = 431,\n                  .statusMessage = \"Request Header Fields Too Large\",\n                  .description = \"header too large.\" };\n            }\n            auto newBuffer = kj::heapArray<char>(headerBuffer.size() * 2);\n            memcpy(newBuffer.begin(), headerBuffer.begin(), headerBuffer.size());\n            headerBuffer = kj::mv(newBuffer);\n          }\n        }\n\n        // How many bytes will we read?\n        size_t maxBytes = headerBuffer.size() - bufferEnd;\n\n        if (type == HeaderType::CHUNK) {\n          // Roughly limit the amount of data we read to MAX_CHUNK_HEADER_SIZE.\n          // TODO(perf): This is mainly to avoid copying a lot of body data into our buffer just to\n          //   copy it again when it is read. But maybe the copy would be cheaper than overhead of\n          //   extra event loop turns?\n          KJ_REQUIRE(bufferEnd - bufferStart <= MAX_CHUNK_HEADER_SIZE, \"invalid HTTP chunk size\");\n          maxBytes = kj::min(maxBytes, MAX_CHUNK_HEADER_SIZE);\n        }\n\n        readPromise = inner.read(headerBuffer.begin() + bufferEnd, 1, maxBytes);\n      }\n\n      auto amount = co_await readPromise;\n\n      if (lineBreakBeforeNextHeader) {\n        // Hackily deal with expected leading line break.\n        if (bufferEnd == bufferStart && headerBuffer[bufferEnd] == '\\r') {\n          ++bufferEnd;\n          --amount;\n        }\n\n        if (amount > 0 && headerBuffer[bufferEnd] == '\\n') {\n          lineBreakBeforeNextHeader = false;\n          ++bufferEnd;\n          --amount;\n\n          // Cut the leading line break out of the buffer entirely.\n          bufferStart = bufferEnd;\n        }\n\n        if (amount == 0) {\n          continue;\n        }\n      }\n\n      size_t pos = bufferEnd;\n      size_t newEnd = pos + amount;\n\n      for (;;) {\n        // Search for next newline.\n        char* nl = reinterpret_cast<char*>(\n            memchr(headerBuffer.begin() + pos, '\\n', newEnd - pos));\n        if (nl == nullptr) {\n          // No newline found. Wait for more data.\n          bufferEnd = newEnd;\n          break;\n        }\n\n        // Is this newline which we found the last of the header? For a chunk header, always. For\n        // a message header, we search for two newlines in a row. We accept either \"\\r\\n\" or just\n        // \"\\n\" as a newline sequence (though the standard requires \"\\r\\n\").\n        if (type == HeaderType::CHUNK ||\n            (nl - headerBuffer.begin() >= 4 &&\n             ((nl[-1] == '\\r' && nl[-2] == '\\n') || (nl[-1] == '\\n')))) {\n          // OK, we've got all the data!\n\n          size_t endIndex = nl + 1 - headerBuffer.begin();\n          size_t leftoverStart = endIndex;\n\n          // Strip off the last newline from end.\n          endIndex -= 1 + (nl[-1] == '\\r');\n\n          if (type == HeaderType::MESSAGE) {\n            if (headerBuffer.size() - newEnd < MAX_CHUNK_HEADER_SIZE) {\n              // Ugh, there's not enough space for the secondary await buffer. Grow once more.\n              auto newBuffer = kj::heapArray<char>(headerBuffer.size() * 2);\n              memcpy(newBuffer.begin(), headerBuffer.begin(), headerBuffer.size());\n              headerBuffer = kj::mv(newBuffer);\n            }\n            messageHeaderEnd = endIndex;\n          } else {\n            // For some reason, HTTP specifies that there will be a line break after each chunk.\n            lineBreakBeforeNextHeader = true;\n          }\n\n          auto result = headerBuffer.slice(bufferStart, endIndex);\n          leftover = headerBuffer.slice(leftoverStart, newEnd);\n          co_return result;\n        } else {\n          pos = nl - headerBuffer.begin() + 1;\n        }\n      }\n\n      // If we're here, we broke out of the inner loop because we need to read more data.\n    }\n  }\n\n  void snarfBufferedLineBreak() {\n    // Slightly-crappy code to snarf the expected line break. This will actually eat the leading\n    // regex /\\r*\\n?/.\n    while (lineBreakBeforeNextHeader && leftover.size() > 0) {\n      if (leftover[0] == '\\r') {\n        leftover = leftover.slice(1, leftover.size());\n      } else if (leftover[0] == '\\n') {\n        leftover = leftover.slice(1, leftover.size());\n        lineBreakBeforeNextHeader = false;\n      } else {\n        // Err, missing line break, whatever.\n        lineBreakBeforeNextHeader = false;\n      }\n    }\n  }\n};\n\n// -----------------------------------------------------------------------------\n\nclass HttpEntityBodyReader: public kj::AsyncInputStream {\npublic:\n  HttpEntityBodyReader(HttpInputStreamImpl& inner) {\n    inner.setCurrentWrapper(weakInner);\n  }\n  ~HttpEntityBodyReader() noexcept(false) {\n    if (!finished) {\n      KJ_IF_SOME(inner, weakInner) {\n        inner.unsetCurrentWrapper(weakInner);\n        inner.abortRead();\n      } else {\n        // Since we're in a destructor, log an error instead of throwing.\n        KJ_LOG(ERROR, \"HTTP body input stream outlived underlying connection\", kj::getStackTrace());\n      }\n    }\n  }\n\nprotected:\n  HttpInputStreamImpl& getInner() {\n    KJ_IF_SOME(i, weakInner) {\n      return i;\n    } else if (finished) {\n      // This is a bug in the implementations in this file, not the app.\n      KJ_FAIL_ASSERT(\"bug in KJ HTTP: tried to access inner stream after it had been released\");\n    } else {\n      KJ_FAIL_REQUIRE(\"HTTP body input stream outlived underlying connection\");\n    }\n  }\n\n  void doneReading() {\n    auto& inner = getInner();\n    inner.unsetCurrentWrapper(weakInner);\n    finished = true;\n    inner.finishRead();\n  }\n\n  inline bool alreadyDone() { return weakInner == kj::none; }\n\nprivate:\n  kj::Maybe<HttpInputStreamImpl&> weakInner;\n  bool finished = false;\n};\n\nclass HttpNullEntityReader final: public HttpEntityBodyReader {\n  // Stream for an entity-body which is not present. Always returns EOF on read, but tryGetLength()\n  // may indicate non-zero in the special case of a response to a HEAD request.\n\npublic:\n  HttpNullEntityReader(HttpInputStreamImpl& inner, kj::Maybe<uint64_t> length)\n      : HttpEntityBodyReader(inner), length(length) {\n    // `length` is what to return from tryGetLength(). For a response to a HEAD request, this may\n    // be non-zero.\n    doneReading();\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return length;\n  }\n\nprivate:\n  kj::Maybe<uint64_t> length;\n};\n\nclass HttpConnectionCloseEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads until EOF.\n\npublic:\n  HttpConnectionCloseEntityReader(HttpInputStreamImpl& inner)\n      : HttpEntityBodyReader(inner) {}\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    if (alreadyDone()) co_return 0;\n\n    auto amount = co_await getInner().tryRead(buffer, minBytes, maxBytes);\n    if (amount < minBytes) {\n      doneReading();\n    }\n    co_return amount;\n  }\n};\n\nclass HttpFixedLengthEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads only up to a fixed length from the underlying stream, then emulates EOF.\n\npublic:\n  HttpFixedLengthEntityReader(HttpInputStreamImpl& inner, size_t length)\n      : HttpEntityBodyReader(inner), length(length) {\n    if (length == 0) doneReading();\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return length;\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(clean, \"can't read more data after a previous read didn't complete\");\n    clean = false;\n\n    size_t alreadyRead = 0;\n\n    for (;;) {\n      if (length == 0) {\n        clean = true;\n        co_return 0;\n      }\n\n      // We have to set minBytes to 1 here so that if we read any data at all, we update our\n      // counter immediately, so that we still know where we are in case of cancellation.\n      auto amount = co_await getInner().tryRead(buffer, 1, kj::min(maxBytes, length));\n\n      length -= amount;\n      if (length > 0) {\n        // We haven't reached the end of the entity body yet.\n        if (amount == 0) {\n          size_t expectedLength = length + alreadyRead;\n          kj::throwRecoverableException(KJ_EXCEPTION(\n            DISCONNECTED,\n            \"premature EOF in HTTP entity body; did not reach Content-Length\",\n            expectedLength,\n            alreadyRead\n          ));\n        } else if (amount < minBytes) {\n          // We requested a minimum 1 byte above, but our own caller actually set a larger minimum\n          // which has not yet been reached. Keep trying until we reach it.\n          buffer = reinterpret_cast<byte*>(buffer) + amount;\n          minBytes -= amount;\n          maxBytes -= amount;\n          alreadyRead += amount;\n          continue;\n        }\n      } else if (length == 0) {\n        doneReading();\n      }\n      clean = true;\n      co_return amount + alreadyRead;\n    }\n  }\n\nprivate:\n  size_t length;\n  bool clean = true;\n};\n\nclass HttpChunkedEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads a Transfer-Encoding: Chunked stream.\n\npublic:\n  HttpChunkedEntityReader(HttpInputStreamImpl& inner)\n      : HttpEntityBodyReader(inner) {}\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(clean, \"can't read more data after a previous read didn't complete\");\n    clean = false;\n\n    size_t alreadyRead = 0;\n\n    for (;;) {\n      if (alreadyDone()) {\n        clean = true;\n        co_return alreadyRead;\n      } else if (chunkSize == 0) {\n        // Read next chunk header.\n        auto nextChunkSizeOrError = co_await getInner().readChunkHeader();\n        KJ_REQUIRE(nextChunkSizeOrError.is<uint64_t>(), \"bad header\");\n        auto nextChunkSize = nextChunkSizeOrError.get<uint64_t>();\n        if (nextChunkSize == 0) {\n          doneReading();\n        }\n\n        chunkSize = nextChunkSize;\n        continue;\n      } else {\n        // Read current chunk.\n        // We have to set minBytes to 1 here so that if we read any data at all, we update our\n        // counter immediately, so that we still know where we are in case of cancellation.\n        auto amount = co_await getInner().tryRead(buffer, 1, kj::min(maxBytes, chunkSize));\n\n        chunkSize -= amount;\n        if (amount == 0) {\n          kj::throwRecoverableException(KJ_EXCEPTION(DISCONNECTED, \"premature EOF in HTTP chunk\"));\n        } else if (amount < minBytes) {\n          // We requested a minimum 1 byte above, but our own caller actually set a larger minimum\n          // which has not yet been reached. Keep trying until we reach it.\n          buffer = reinterpret_cast<byte*>(buffer) + amount;\n          minBytes -= amount;\n          maxBytes -= amount;\n          alreadyRead += amount;\n          continue;\n        }\n        clean = true;\n        co_return alreadyRead + amount;\n      }\n    }\n  }\n\nprivate:\n  size_t chunkSize = 0;\n  bool clean = true;\n};\n\ntemplate <char...>\nstruct FastCaseCmp;\n\ntemplate <char first, char... rest>\nstruct FastCaseCmp<first, rest...> {\n  static constexpr bool apply(const char* actual) {\n    return\n      ('a' <= first && first <= 'z') || ('A' <= first && first <= 'Z')\n        ? (*actual | 0x20) == (first | 0x20) && FastCaseCmp<rest...>::apply(actual + 1)\n        : *actual == first && FastCaseCmp<rest...>::apply(actual + 1);\n  }\n};\n\ntemplate <>\nstruct FastCaseCmp<> {\n  static constexpr bool apply(const char* actual) {\n    return *actual == '\\0';\n  }\n};\n\ntemplate <char... chars>\nconstexpr bool fastCaseCmp(const char* actual) {\n  return FastCaseCmp<chars...>::apply(actual);\n}\n\n// Tests\nstatic_assert(fastCaseCmp<'f','O','o','B','1'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B','2'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'n','O','o','B','1'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B','1','a'>(\"FooB1\"), \"\");\n\nkj::Own<kj::AsyncInputStream> HttpInputStreamImpl::getEntityBody(\n    RequestOrResponse type,\n    kj::OneOf<HttpMethod, HttpConnectMethod> method,\n    uint statusCode,\n    const kj::HttpHeaders& headers) {\n  KJ_REQUIRE(headerBuffer.size() > 0, \"Cannot get entity body after header buffer release.\");\n\n  auto isHeadRequest = method.tryGet<HttpMethod>().map([](auto& m) {\n    return m == HttpMethod::HEAD;\n  }).orDefault(false);\n\n  auto isConnectRequest = method.is<HttpConnectMethod>();\n\n  // Rules to determine how HTTP entity-body is delimited:\n  //   https://tools.ietf.org/html/rfc7230#section-3.3.3\n  // #1\n  if (type == RESPONSE) {\n    if (isHeadRequest) {\n      // Body elided.\n      kj::Maybe<uint64_t> length;\n      KJ_IF_SOME(cl, headers.get(HttpHeaderId::CONTENT_LENGTH)) {\n        length = strtoull(cl.cStr(), nullptr, 10);\n      } else if (headers.get(HttpHeaderId::TRANSFER_ENCODING) == kj::none) {\n        // HACK: Neither Content-Length nor Transfer-Encoding header in response to HEAD\n        //   request. Propagate this fact with a 0 expected body length.\n        length = uint64_t(0);\n      }\n      return kj::heap<HttpNullEntityReader>(*this, length);\n    } else if (isConnectRequest && statusCode >= 200 && statusCode < 300) {\n      KJ_FAIL_ASSERT(\"a CONNECT response with a 2xx status does not have an entity body to get\");\n    } else if (statusCode == 204 || statusCode == 304) {\n      // No body.\n      return kj::heap<HttpNullEntityReader>(*this, uint64_t(0));\n    }\n  }\n\n  // For CONNECT requests messages, we let the rest of the logic play out.\n  // We already check before here to ensure that Transfer-Encoding and\n  // Content-Length headers are not present in which case the code below\n  // does the right thing.\n\n  // #3\n  KJ_IF_SOME(te, headers.get(HttpHeaderId::TRANSFER_ENCODING)) {\n    // TODO(someday): Support pluggable transfer encodings? Or at least gzip?\n    // TODO(someday): Support stacked transfer encodings, e.g. \"gzip, chunked\".\n\n    // NOTE: #3\u00b63 is ambiguous about what should happen if Transfer-Encoding and Content-Length are\n    //   both present. It says that Transfer-Encoding takes precedence, but also that the request\n    //   \"ought to be handled as an error\", and that proxies \"MUST\" drop the Content-Length before\n    //   forwarding. We ignore the vague \"ought to\" part and implement the other two. (The\n    //   dropping of Content-Length will happen naturally if/when the message is sent back out to\n    //   the network.)\n    if (fastCaseCmp<'c','h','u','n','k','e','d'>(te.cStr())) {\n      // #3\u00b61\n      return kj::heap<HttpChunkedEntityReader>(*this);\n    } else if (fastCaseCmp<'i','d','e','n','t','i','t','y'>(te.cStr())) {\n      // #3\u00b62\n      KJ_REQUIRE(type != REQUEST, \"request body cannot have Transfer-Encoding other than chunked\");\n      return kj::heap<HttpConnectionCloseEntityReader>(*this);\n    }\n\n    KJ_FAIL_REQUIRE(\"unknown transfer encoding\", te) { break; };\n  }\n\n  // #4 and #5\n  KJ_IF_SOME(cl, headers.get(HttpHeaderId::CONTENT_LENGTH)) {\n    // NOTE: By spec, multiple Content-Length values are allowed as long as they are the same, e.g.\n    //   \"Content-Length: 5, 5, 5\". Hopefully no one actually does that...\n    char* end;\n    uint64_t length = strtoull(cl.cStr(), &end, 10);\n    if (end > cl.begin() && *end == '\\0') {\n      // #5\n      return kj::heap<HttpFixedLengthEntityReader>(*this, length);\n    } else {\n      // #4 (bad content-length)\n      KJ_FAIL_REQUIRE(\"invalid Content-Length header value\", cl);\n    }\n  }\n\n  // #6\n  if (type == REQUEST) {\n    // Lack of a Content-Length or Transfer-Encoding means no body for requests.\n    return kj::heap<HttpNullEntityReader>(*this, uint64_t(0));\n  }\n\n  // RFC 2616 permitted \"multipart/byteranges\" responses to be self-delimiting, but this was\n  // mercifully removed in RFC 7230, and new exceptions of this type are disallowed:\n  //   https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4\n  //   https://tools.ietf.org/html/rfc7230#page-81\n  // To be extra-safe, we'll reject a multipart/byteranges response that lacks transfer-encoding\n  // and content-length.\n  KJ_IF_SOME(type, headers.get(HttpHeaderId::CONTENT_TYPE)) {\n    if (type.startsWith(\"multipart/byteranges\")) {\n      KJ_FAIL_REQUIRE(\n          \"refusing to handle multipart/byteranges response without transfer-encoding nor \"\n          \"content-length due to ambiguity between RFC 2616 vs RFC 7230.\");\n    }\n  }\n\n  // #7\n  return kj::heap<HttpConnectionCloseEntityReader>(*this);\n}\n\n}  // namespace\n\nkj::Own<HttpInputStream> newHttpInputStream(\n    kj::AsyncInputStream& input, const HttpHeaderTable& table) {\n  return kj::heap<HttpInputStreamImpl>(input, table);\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpOutputStream: public WrappableStreamMixin<HttpOutputStream> {\npublic:\n  HttpOutputStream(AsyncOutputStream& inner): inner(inner) {}\n\n  bool isInBody() {\n    return inBody;\n  }\n\n  bool canReuse() {\n    return !inBody && !broken && !writeInProgress;\n  }\n\n  bool canWriteBodyData() {\n    return !writeInProgress && inBody;\n  }\n\n  bool isBroken() {\n    return broken;\n  }\n\n  void writeHeaders(String content) {\n    // Writes some header content and begins a new entity body.\n\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\") { return; }\n    KJ_REQUIRE(!inBody, \"previous HTTP message body incomplete; can't write more messages\");\n    inBody = true;\n\n    queueWrite(kj::mv(content));\n  }\n\n  void writeBodyData(kj::String content) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\") { return; }\n    KJ_REQUIRE(inBody) { return; }\n\n    queueWrite(kj::mv(content));\n  }\n\n  kj::Promise<void> writeBodyData(const void* buffer, size_t size) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    co_await inner.write(buffer, size);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n  }\n\n  kj::Promise<void> writeBodyData(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    co_await inner.write(pieces);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n  }\n\n  Promise<uint64_t> pumpBodyFrom(AsyncInputStream& input, uint64_t amount) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    auto actual = co_await input.pumpTo(inner, amount);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n    co_return actual;\n  }\n\n  void finishBody() {\n    // Called when entire body was written.\n\n    KJ_REQUIRE(inBody) { return; }\n    inBody = false;\n\n    if (writeInProgress) {\n      // It looks like the last write never completed -- possibly because it was canceled or threw\n      // an exception. We must treat this equivalent to abortBody().\n      broken = true;\n\n      // Cancel any writes that are still queued.\n      writeQueue = KJ_EXCEPTION(FAILED,\n          \"previous HTTP message body incomplete; can't write more messages\");\n    }\n  }\n\n  void abortBody() {\n    // Called if the application failed to write all expected body bytes.\n    KJ_REQUIRE(inBody) { return; }\n    inBody = false;\n    broken = true;\n\n    // Cancel any writes that are still queued.\n    writeQueue = KJ_EXCEPTION(FAILED,\n        \"previous HTTP message body incomplete; can't write more messages\");\n  }\n\n  kj::Promise<void> flush() {\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n    return fork.addBranch();\n  }\n\n  Promise<void> whenWriteDisconnected() {\n    return inner.whenWriteDisconnected();\n  }\n\n  bool isWriteInProgress() { return writeInProgress; }\n\nprivate:\n  AsyncOutputStream& inner;\n  kj::Promise<void> writeQueue = kj::READY_NOW;\n  bool inBody = false;\n  bool broken = false;\n\n  bool writeInProgress = false;\n  // True if a write method has been called and has not completed successfully. In the case that\n  // a write throws an exception or is canceled, this remains true forever. In these cases, the\n  // underlying stream is in an inconsistent state and cannot be reused.\n\n  void queueWrite(kj::String content) {\n    // We only use queueWrite() in cases where we can take ownership of the write buffer, and where\n    // it is convenient if we can return `void` rather than a promise.  In particular, this is used\n    // to write headers and chunk boundaries. Writes of application data do not go into\n    // `writeQueue` because this would prevent cancellation. Instead, they wait until `writeQueue`\n    // is empty, then they make the write directly, using `writeInProgress` to detect and block\n    // concurrent writes.\n\n    writeQueue = writeQueue.then([this,content=kj::mv(content)]() mutable {\n      auto promise = inner.write(content.begin(), content.size());\n      return promise.attach(kj::mv(content));\n    });\n  }\n};\n\nclass HttpEntityBodyWriter: public kj::AsyncOutputStream {\npublic:\n  HttpEntityBodyWriter(HttpOutputStream& inner) {\n    inner.setCurrentWrapper(weakInner);\n  }\n  ~HttpEntityBodyWriter() noexcept(false) {\n    if (!finished) {\n      KJ_IF_SOME(inner, weakInner) {\n        inner.unsetCurrentWrapper(weakInner);\n        inner.abortBody();\n      } else {\n        // Since we're in a destructor, log an error instead of throwing.\n        KJ_LOG(ERROR, \"HTTP body output stream outlived underlying connection\",\n            kj::getStackTrace());\n      }\n    }\n  }\n\nprotected:\n  HttpOutputStream& getInner() {\n    KJ_IF_SOME(i, weakInner) {\n      return i;\n    } else if (finished) {\n      // This is a bug in the implementations in this file, not the app.\n      KJ_FAIL_ASSERT(\"bug in KJ HTTP: tried to access inner stream after it had been released\");\n    } else {\n      KJ_FAIL_REQUIRE(\"HTTP body output stream outlived underlying connection\");\n    }\n  }\n\n  void doneWriting() {\n    auto& inner = getInner();\n    inner.unsetCurrentWrapper(weakInner);\n    finished = true;\n    inner.finishBody();\n  }\n\n  inline bool alreadyDone() { return weakInner == kj::none; }\n\nprivate:\n  kj::Maybe<HttpOutputStream&> weakInner;\n  bool finished = false;\n};\n\nclass HttpNullEntityWriter final: public kj::AsyncOutputStream {\n  // Does not inherit HttpEntityBodyWriter because it doesn't actually write anything.\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return KJ_EXCEPTION(FAILED, \"HTTP message has no entity-body; can't write()\");\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return KJ_EXCEPTION(FAILED, \"HTTP message has no entity-body; can't write()\");\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n};\n\nclass HttpDiscardingEntityWriter final: public kj::AsyncOutputStream {\n  // Does not inherit HttpEntityBodyWriter because it doesn't actually write anything.\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n};\n\nclass HttpFixedLengthEntityWriter final: public HttpEntityBodyWriter {\npublic:\n  HttpFixedLengthEntityWriter(HttpOutputStream& inner, uint64_t length)\n      : HttpEntityBodyWriter(inner), length(length) {\n    if (length == 0) doneWriting();\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (size == 0) co_return;\n    KJ_REQUIRE(size <= length, \"overwrote Content-Length\");\n    length -= size;\n\n    co_await getInner().writeBodyData(buffer, size);\n    if (length == 0) doneWriting();\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    uint64_t size = 0;\n    for (auto& piece: pieces) size += piece.size();\n\n    if (size == 0) co_return;\n    KJ_REQUIRE(size <= length, \"overwrote Content-Length\");\n    length -= size;\n\n    co_await getInner().writeBodyData(pieces);\n    if (length == 0) doneWriting();\n  }\n\n  Maybe<Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input, uint64_t amount) override {\n    return pumpFrom(input, amount);\n  }\n\n  Promise<uint64_t> pumpFrom(AsyncInputStream& input, uint64_t amount) {\n    if (amount == 0) co_return 0;\n\n    bool overshot = amount > length;\n    if (overshot) {\n      // Hmm, the requested amount was too large, but it's common to specify kj::max as the amount\n      // to pump, in which case we pump to EOF. Let's try to verify whether EOF is where we\n      // expect it to be.\n      KJ_IF_SOME(available, input.tryGetLength()) {\n        // Great, the stream knows how large it is. If it's indeed larger than the space available\n        // then let's abort.\n        KJ_REQUIRE(available <= length, \"overwrote Content-Length\");\n      } else {\n        // OK, we have no idea how large the input is, so we'll have to check later.\n      }\n    }\n\n    amount = kj::min(amount, length);\n    length -= amount;\n    uint64_t actual = amount;\n\n    if (amount != 0) {\n      actual = co_await getInner().pumpBodyFrom(input, amount);\n      length += amount - actual;\n      if (length == 0) doneWriting();\n    }\n\n    if (overshot) {\n        if (actual == amount) {\n          // We read exactly the amount expected. In order to detect an overshoot, we have to\n          // try reading one more byte. Ugh.\n          static byte junk;\n          auto extra = co_await input.tryRead(&junk, 1, 1);\n          KJ_REQUIRE(extra == 0, \"overwrote Content-Length\");\n        } else {\n          // We actually read less data than requested so we couldn't have overshot. In fact, we\n          // undershot.\n        }\n    }\n\n    co_return actual;\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return getInner().whenWriteDisconnected();\n  }\n\nprivate:\n  uint64_t length;\n};\n\nclass HttpChunkedEntityWriter final: public HttpEntityBodyWriter {\npublic:\n  HttpChunkedEntityWriter(HttpOutputStream& inner)\n      : HttpEntityBodyWriter(inner) {}\n  ~HttpChunkedEntityWriter() noexcept(false) {\n    if (!alreadyDone()) {\n      auto& inner = getInner();\n      if (inner.canWriteBodyData()) {\n        inner.writeBodyData(kj::str(\"0\\r\\n\\r\\n\"));\n        doneWriting();\n      }\n    }\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (size == 0) return kj::READY_NOW;  // can't encode zero-size chunk since it indicates EOF.\n\n    auto header = kj::str(kj::hex(size), \"\\r\\n\");\n    auto parts = kj::heapArray<ArrayPtr<const byte>>(3);\n    parts[0] = header.asBytes();\n    parts[1] = kj::arrayPtr(reinterpret_cast<const byte*>(buffer), size);\n    parts[2] = kj::StringPtr(\"\\r\\n\").asBytes();\n\n    auto promise = getInner().writeBodyData(parts.asPtr());\n    return promise.attach(kj::mv(header), kj::mv(parts));\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    uint64_t size = 0;\n    for (auto& piece: pieces) size += piece.size();\n\n    if (size == 0) return kj::READY_NOW;  // can't encode zero-size chunk since it indicates EOF.\n\n    auto header = kj::str(kj::hex(size), \"\\r\\n\");\n    auto partsBuilder = kj::heapArrayBuilder<ArrayPtr<const byte>>(pieces.size() + 2);\n    partsBuilder.add(header.asBytes());\n    for (auto& piece: pieces) {\n      partsBuilder.add(piece);\n    }\n    partsBuilder.add(kj::StringPtr(\"\\r\\n\").asBytes());\n\n    auto parts = partsBuilder.finish();\n    auto promise = getInner().writeBodyData(parts.asPtr());\n    return promise.attach(kj::mv(header), kj::mv(parts));\n  }\n\n  Maybe<Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input, uint64_t amount) override {\n    KJ_IF_SOME(l, input.tryGetLength()) {\n      return pumpImpl(input, kj::min(amount, l));\n    } else {\n      // Need to use naive read/write loop.\n      return kj::none;\n    }\n  }\n\n  Promise<uint64_t> pumpImpl(AsyncInputStream& input, uint64_t length) {\n    // Hey, we know exactly how large the input is, so we can write just one chunk.\n    getInner().writeBodyData(kj::str(kj::hex(length), \"\\r\\n\"));\n    auto actual = co_await getInner().pumpBodyFrom(input, length);\n\n    if (actual < length) {\n      getInner().abortBody();\n      KJ_FAIL_REQUIRE(\n          \"value returned by input.tryGetLength() was greater than actual bytes transferred\") {\n        break;\n      }\n    }\n\n    getInner().writeBodyData(kj::str(\"\\r\\n\"));\n    co_return actual;\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return getInner().whenWriteDisconnected();\n  }\n};\n\n// =======================================================================================\n\nclass WebSocketImpl final: public WebSocket, private WebSocketErrorHandler {\npublic:\n  WebSocketImpl(kj::Own<kj::AsyncIoStream> stream,\n                kj::Maybe<EntropySource&> maskKeyGenerator,\n                kj::Maybe<CompressionParameters> compressionConfigParam = kj::none,\n                kj::Maybe<WebSocketErrorHandler&> errorHandler = kj::none,\n                kj::Array<byte> buffer = kj::heapArray<byte>(4096),\n                kj::ArrayPtr<byte> leftover = nullptr,\n                kj::Maybe<kj::Promise<void>> waitBeforeSend = kj::none)\n      : stream(kj::mv(stream)), maskKeyGenerator(maskKeyGenerator),\n        compressionConfig(kj::mv(compressionConfigParam)),\n        errorHandler(errorHandler.orDefault(*this)),\n        sendingPong(kj::mv(waitBeforeSend)),\n        recvBuffer(kj::mv(buffer)), recvData(leftover) {\n#if KJ_HAS_ZLIB\n    KJ_IF_SOME(config, compressionConfig) {\n      compressionContext.emplace(ZlibContext::Mode::COMPRESS, config);\n      decompressionContext.emplace(ZlibContext::Mode::DECOMPRESS, config);\n    }\n#else\n    KJ_REQUIRE(compressionConfig == kj::none,\n        \"WebSocket compression is only supported if KJ is compiled with Zlib.\");\n#endif // KJ_HAS_ZLIB\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    return sendImpl(OPCODE_BINARY, message);\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    return sendImpl(OPCODE_TEXT, message.asBytes());\n  }\n\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    kj::Array<byte> payload;\n    if (code == 1005) {\n      KJ_REQUIRE(reason.size() == 0, \"WebSocket close code 1005 cannot have a reason\");\n\n      // code 1005 -- leave payload empty\n    } else {\n      payload = heapArray<byte>(reason.size() + 2);\n      payload[0] = code >> 8;\n      payload[1] = code;\n      memcpy(payload.begin() + 2, reason.begin(), reason.size());\n    }\n\n    auto promise = sendImpl(OPCODE_CLOSE, payload);\n    return promise.attach(kj::mv(payload));\n  }\n\n  kj::Promise<void> disconnect() override {\n    KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n\n    KJ_IF_SOME(p, sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      currentlySending = true;\n      auto promise = p.then([this]() {\n        currentlySending = false;\n        return disconnect();\n      });\n      sendingPong = kj::none;\n      return promise;\n    }\n\n    disconnected = true;\n\n    stream->shutdownWrite();\n    return kj::READY_NOW;\n  }\n\n  void abort() override {\n    queuedPong = kj::none;\n    sendingPong = kj::none;\n    disconnected = true;\n    stream->abortRead();\n    stream->shutdownWrite();\n  }\n\n  kj::Promise<void> whenAborted() override {\n    return stream->whenWriteDisconnected();\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    size_t headerSize = Header::headerSize(recvData.begin(), recvData.size());\n\n    if (headerSize > recvData.size()) {\n      if (recvData.begin() != recvBuffer.begin()) {\n        // Move existing data to front of buffer.\n        if (recvData.size() > 0) {\n          memmove(recvBuffer.begin(), recvData.begin(), recvData.size());\n        }\n        recvData = recvBuffer.slice(0, recvData.size());\n      }\n\n      return stream->tryRead(recvData.end(), 1, recvBuffer.end() - recvData.end())\n          .then([this,maxSize](size_t actual) -> kj::Promise<Message> {\n        receivedBytes += actual;\n        if (actual == 0) {\n          if (recvData.size() > 0) {\n            return KJ_EXCEPTION(DISCONNECTED, \"WebSocket EOF in frame header\");\n          } else {\n            // It's incorrect for the WebSocket to disconnect without sending `Close`.\n            return KJ_EXCEPTION(DISCONNECTED,\n                \"WebSocket disconnected between frames without sending `Close`.\");\n          }\n        }\n\n        recvData = recvBuffer.slice(0, recvData.size() + actual);\n        return receive(maxSize);\n      });\n    }\n\n    auto& recvHeader = *reinterpret_cast<Header*>(recvData.begin());\n    if (recvHeader.hasRsv2or3()) {\n      return errorHandler.handleWebSocketProtocolError({\n        1002, \"Received frame had RSV bits 2 or 3 set\",\n      });\n    }\n\n    recvData = recvData.slice(headerSize, recvData.size());\n\n    size_t payloadLen = recvHeader.getPayloadLen();\n    if (payloadLen > maxSize) {\n      return errorHandler.handleWebSocketProtocolError({\n        1009, kj::str(\"Message is too large: \", payloadLen, \" > \", maxSize)\n      });\n    }\n\n    auto opcode = recvHeader.getOpcode();\n    bool isData = opcode < OPCODE_FIRST_CONTROL;\n    if (opcode == OPCODE_CONTINUATION) {\n      if (fragments.empty()) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Unexpected continuation frame\"\n        });\n      }\n\n      opcode = fragmentOpcode;\n    } else if (isData) {\n      if (!fragments.empty()) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Missing continuation frame\"\n        });\n      }\n    }\n\n    bool isFin = recvHeader.isFin();\n\n    kj::Array<byte> message;           // space to allocate\n    byte* payloadTarget;               // location into which to read payload (size is payloadLen)\n    kj::Maybe<size_t> originalMaxSize; // maxSize from first `receive()` call\n    if (isFin) {\n      size_t amountToAllocate;\n      if (recvHeader.isCompressed() || fragmentCompressed) {\n        // Add 4 since we append 0x00 0x00 0xFF 0xFF to the tail of the payload.\n        // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n        amountToAllocate = payloadLen + 4;\n      } else {\n        // Add space for NUL terminator when allocating text message.\n        amountToAllocate = payloadLen + (opcode == OPCODE_TEXT && isFin);\n      }\n\n      if (isData && !fragments.empty()) {\n        // Final frame of a fragmented message. Gather the fragments.\n        size_t offset = 0;\n        for (auto& fragment: fragments) offset += fragment.size();\n        message = kj::heapArray<byte>(offset + amountToAllocate);\n        originalMaxSize = offset + maxSize; // gives us back the original maximum message size.\n\n        offset = 0;\n        for (auto& fragment: fragments) {\n          memcpy(message.begin() + offset, fragment.begin(), fragment.size());\n          offset += fragment.size();\n        }\n        payloadTarget = message.begin() + offset;\n\n        fragments.clear();\n        fragmentOpcode = 0;\n        fragmentCompressed = false;\n      } else {\n        // Single-frame message.\n        message = kj::heapArray<byte>(amountToAllocate);\n        originalMaxSize = maxSize; // gives us back the original maximum message size.\n        payloadTarget = message.begin();\n      }\n    } else {\n      // Fragmented message, and this isn't the final fragment.\n      if (!isData) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Received fragmented control frame\"\n        });\n      }\n\n      message = kj::heapArray<byte>(payloadLen);\n      payloadTarget = message.begin();\n      if (fragments.empty()) {\n        // This is the first fragment, so set the opcode.\n        fragmentOpcode = opcode;\n        fragmentCompressed = recvHeader.isCompressed();\n      }\n    }\n\n    Mask mask = recvHeader.getMask();\n\n    auto handleMessage =\n        [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,message=kj::mv(message)]() mutable\n        -> kj::Promise<Message> {\n      if (!mask.isZero()) {\n        mask.apply(kj::arrayPtr(payloadTarget, payloadLen));\n      }\n\n      if (!isFin) {\n        // Add fragment to the list and loop.\n        auto newMax = maxSize - message.size();\n        fragments.add(kj::mv(message));\n        return receive(newMax);\n      }\n\n      switch (opcode) {\n        case OPCODE_CONTINUATION:\n          // Shouldn't get here; handled above.\n          KJ_UNREACHABLE;\n        case OPCODE_TEXT:\n#if KJ_HAS_ZLIB\n          KJ_IF_SOME(config, compressionConfig) {\n            auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);\n            auto tail = message.slice(message.size() - 4, message.size());\n            // Note that we added an additional 4 bytes to `message`s capacity to account for these\n            // extra bytes. See `amountToAllocate` in the if(recvHeader.isCompressed()) block above.\n            const byte tailBytes[] = {0x00, 0x00, 0xFF, 0xFF};\n            memcpy(tail.begin(), tailBytes, sizeof(tailBytes));\n            // We have to append 0x00 0x00 0xFF 0xFF to the message before inflating.\n            // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n            if (config.inboundNoContextTakeover) {\n              // We must reset context on each message.\n              decompressor.reset();\n            }\n            bool addNullTerminator = true;\n            // We want to add the null terminator when receiving a TEXT message.\n            auto decompressed = decompressor.processMessage(message, originalMaxSize,\n                addNullTerminator);\n            return Message(kj::String(decompressed.releaseAsChars()));\n          }\n#endif // KJ_HAS_ZLIB\n          message.back() = '\\0';\n          return Message(kj::String(message.releaseAsChars()));\n        case OPCODE_BINARY:\n#if KJ_HAS_ZLIB\n          KJ_IF_SOME(config, compressionConfig) {\n            auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);\n            auto tail = message.slice(message.size() - 4, message.size());\n            // Note that we added an additional 4 bytes to `message`s capacity to account for these\n            // extra bytes. See `amountToAllocate` in the if(recvHeader.isCompressed()) block above.\n            const byte tailBytes[] = {0x00, 0x00, 0xFF, 0xFF};\n            memcpy(tail.begin(), tailBytes, sizeof(tailBytes));\n            // We have to append 0x00 0x00 0xFF 0xFF to the message before inflating.\n            // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n            if (config.inboundNoContextTakeover) {\n              // We must reset context on each message.\n              decompressor.reset();\n            }\n            auto decompressed = decompressor.processMessage(message, originalMaxSize);\n            return Message(decompressed.releaseAsBytes());\n          }\n#endif // KJ_HAS_ZLIB\n          return Message(message.releaseAsBytes());\n        case OPCODE_CLOSE:\n          if (message.size() < 2) {\n            return Message(Close { 1005, nullptr });\n          } else {\n            uint16_t status = (static_cast<uint16_t>(message[0]) << 8)\n                            | (static_cast<uint16_t>(message[1])     );\n            return Message(Close {\n              status, kj::heapString(message.slice(2, message.size()).asChars())\n            });\n          }\n        case OPCODE_PING:\n          // Send back a pong.\n          queuePong(kj::mv(message));\n          return receive(maxSize);\n        case OPCODE_PONG:\n          // Unsolicited pong. Ignore.\n          return receive(maxSize);\n        default:\n          return errorHandler.handleWebSocketProtocolError({\n            1002, kj::str(\"Unknown opcode \", opcode)\n          });\n      }\n    };\n\n    if (payloadLen <= recvData.size()) {\n      // All data already received.\n      memcpy(payloadTarget, recvData.begin(), payloadLen);\n      recvData = recvData.slice(payloadLen, recvData.size());\n      return handleMessage();\n    } else {\n      // Need to read more data.\n      memcpy(payloadTarget, recvData.begin(), recvData.size());\n      size_t remaining = payloadLen - recvData.size();\n      auto promise = stream->tryRead(payloadTarget + recvData.size(), remaining, remaining)\n          .then([this, remaining](size_t amount) {\n        receivedBytes += amount;\n        if (amount < remaining) {\n          kj::throwRecoverableException(KJ_EXCEPTION(DISCONNECTED, \"WebSocket EOF in message\"));\n        }\n      });\n      recvData = nullptr;\n      return promise.then(kj::mv(handleMessage));\n    }\n  }\n\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    KJ_IF_SOME(optOther, kj::dynamicDowncastIfAvailable<WebSocketImpl>(other)) {\n      // Both WebSockets are raw WebSockets, so we can pump the streams directly rather than read\n      // whole messages.\n\n      if ((maskKeyGenerator == kj::none) == (optOther.maskKeyGenerator == kj::none)) {\n        // Oops, it appears that we either believe we are the client side of both sockets, or we\n        // are the server side of both sockets. Since clients must \"mask\" their outgoing frames but\n        // servers must *not* do so, we can't direct-pump. Sad.\n        return kj::none;\n      }\n\n      KJ_IF_SOME(config, compressionConfig) {\n        KJ_IF_SOME(otherConfig, optOther.compressionConfig) {\n          if (config.outboundMaxWindowBits != otherConfig.inboundMaxWindowBits ||\n              config.inboundMaxWindowBits != otherConfig.outboundMaxWindowBits ||\n              config.inboundNoContextTakeover!= otherConfig.outboundNoContextTakeover ||\n              config.outboundNoContextTakeover!= otherConfig.inboundNoContextTakeover) {\n            // Compression configurations differ.\n            return kj::none;\n          }\n        } else {\n          // Only one websocket uses compression.\n          return kj::none;\n        }\n      } else {\n        if (optOther.compressionConfig != kj::none) {\n          // Only one websocket uses compression.\n          return kj::none;\n        }\n      }\n      // Both websockets use compatible compression configurations so we can pump directly.\n\n      // Check same error conditions as with sendImpl().\n      KJ_REQUIRE(!disconnected, \"WebSocket can't send after disconnect()\");\n      KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n      currentlySending = true;\n\n      // If the application chooses to pump messages out, but receives incoming messages normally\n      // with `receive()`, then we will receive pings and attempt to send pongs. But we can't\n      // safely insert a pong in the middle of a pumped stream. We kind of don't have a choice\n      // except to drop them on the floor, which is what will happen if we set `hasSentClose` true.\n      // Hopefully most apps that set up a pump do so in both directions at once, and so pings will\n      // flow through and pongs will flow back.\n      hasSentClose = true;\n\n      return optOther.optimizedPumpTo(*this);\n    }\n\n    return kj::none;\n  }\n\n  uint64_t sentByteCount() override { return sentBytes; }\n\n  uint64_t receivedByteCount() override { return receivedBytes; }\n\n  kj::Maybe<kj::String> getPreferredExtensions(ExtensionsContext ctx) override {\n    if (maskKeyGenerator == kj::none) {\n      // `this` is the server side of a websocket.\n      if (ctx == ExtensionsContext::REQUEST) {\n        // The other WebSocket is (going to be) the client side of a WebSocket, i.e. this is a\n        // proxying pass-through scenario. Optimization is possible. Confusingly, we have to use\n        // generateExtensionResponse() (even though we're generating headers to be passed in a\n        // request) because this is the function that correctly maps our config's inbound/outbound\n        // to client/server.\n        KJ_IF_SOME(c, compressionConfig) {\n          return _::generateExtensionResponse(c);\n        } else {\n          return kj::String(nullptr);  // recommend no compression\n        }\n      } else {\n        // We're apparently arranging to pump from the server side of one WebSocket to the server\n        // side of another; i.e., we are a server, we have two clients, and we're trying to pump\n        // between them. We cannot optimize this case, because the masking requirements are\n        // different for client->server vs. server->client messages. Since we have to parse out\n        // the messages anyway there's no point in trying to match extensions, so return null.\n        return kj::none;\n      }\n    } else {\n      // `this` is the client side of a websocket.\n      if (ctx == ExtensionsContext::RESPONSE) {\n        // The other WebSocket is (going to be) the server side of a WebSocket, i.e. this is a\n        // proxying pass-through scenario. Optimization is possible. Confusingly, we have to use\n        // generateExtensionRequest() (even though we're generating headers to be passed in a\n        // response) because this is the function that correctly maps our config's inbound/outbound\n        // to server/client.\n        KJ_IF_SOME(c, compressionConfig) {\n          CompressionParameters arr[1]{c};\n          return _::generateExtensionRequest(arr);\n        } else {\n          return kj::String(nullptr);  // recommend no compression\n        }\n      } else {\n        // We're apparently arranging to pump from the client side of one WebSocket to the client\n        // side of another; i.e., we are a client, we are connected to two servers, and we're\n        // trying to pump between them. We cannot optimize this case, because the masking\n        // requirements are different for client->server vs. server->client messages. Since we have\n        // to parse out the messages anyway there's no point in trying to match extensions, so\n        // return null.\n        return kj::none;\n      }\n    }\n  }\n\nprivate:\n  class Mask {\n  public:\n    Mask(): maskBytes { 0, 0, 0, 0 } {}\n    Mask(const byte* ptr) { memcpy(maskBytes, ptr, 4); }\n\n    Mask(kj::Maybe<EntropySource&> generator) {\n      KJ_IF_SOME(g, generator) {\n        g.generate(maskBytes);\n      } else {\n        memset(maskBytes, 0, 4);\n      }\n    }\n\n    void apply(kj::ArrayPtr<byte> bytes) const {\n      apply(bytes.begin(), bytes.size());\n    }\n\n    void copyTo(byte* output) const {\n      memcpy(output, maskBytes, 4);\n    }\n\n    bool isZero() const {\n      return (maskBytes[0] | maskBytes[1] | maskBytes[2] | maskBytes[3]) == 0;\n    }\n\n  private:\n    byte maskBytes[4];\n\n    void apply(byte* __restrict__ bytes, size_t size) const {\n      for (size_t i = 0; i < size; i++) {\n        bytes[i] ^= maskBytes[i % 4];\n      }\n    }\n  };\n\n  class Header {\n  public:\n    kj::ArrayPtr<const byte> compose(bool fin, bool compressed, byte opcode, uint64_t payloadLen,\n        Mask mask) {\n      bytes[0] = (fin ? FIN_MASK : 0) | (compressed ? RSV1_MASK : 0) | opcode;\n      // Note that we can only set the compressed bit on DATA frames.\n      bool hasMask = !mask.isZero();\n\n      size_t fill;\n\n      if (payloadLen < 126) {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | payloadLen;\n        if (hasMask) {\n          mask.copyTo(bytes + 2);\n          fill = 6;\n        } else {\n          fill = 2;\n        }\n      } else if (payloadLen < 65536) {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | 126;\n        bytes[2] = static_cast<byte>(payloadLen >> 8);\n        bytes[3] = static_cast<byte>(payloadLen     );\n        if (hasMask) {\n          mask.copyTo(bytes + 4);\n          fill = 8;\n        } else {\n          fill = 4;\n        }\n      } else {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | 127;\n        bytes[2] = static_cast<byte>(payloadLen >> 56);\n        bytes[3] = static_cast<byte>(payloadLen >> 48);\n        bytes[4] = static_cast<byte>(payloadLen >> 40);\n        bytes[5] = static_cast<byte>(payloadLen >> 42);\n        bytes[6] = static_cast<byte>(payloadLen >> 24);\n        bytes[7] = static_cast<byte>(payloadLen >> 16);\n        bytes[8] = static_cast<byte>(payloadLen >>  8);\n        bytes[9] = static_cast<byte>(payloadLen      );\n        if (hasMask) {\n          mask.copyTo(bytes + 10);\n          fill = 14;\n        } else {\n          fill = 10;\n        }\n      }\n\n      return arrayPtr(bytes, fill);\n    }\n\n    bool isFin() const {\n      return bytes[0] & FIN_MASK;\n    }\n\n    bool isCompressed() const {\n      return bytes[0] & RSV1_MASK;\n    }\n\n    bool hasRsv2or3() const {\n      return bytes[0] & RSV2_3_MASK;\n    }\n\n    byte getOpcode() const {\n      return bytes[0] & OPCODE_MASK;\n    }\n\n    uint64_t getPayloadLen() const {\n      byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n      if (payloadLen == 127) {\n        return (static_cast<uint64_t>(bytes[2]) << 56)\n             | (static_cast<uint64_t>(bytes[3]) << 48)\n             | (static_cast<uint64_t>(bytes[4]) << 40)\n             | (static_cast<uint64_t>(bytes[5]) << 32)\n             | (static_cast<uint64_t>(bytes[6]) << 24)\n             | (static_cast<uint64_t>(bytes[7]) << 16)\n             | (static_cast<uint64_t>(bytes[8]) <<  8)\n             | (static_cast<uint64_t>(bytes[9])      );\n      } else if (payloadLen == 126) {\n        return (static_cast<uint64_t>(bytes[2]) <<  8)\n             | (static_cast<uint64_t>(bytes[3])      );\n      } else {\n        return payloadLen;\n      }\n    }\n\n    Mask getMask() const {\n      if (bytes[1] & USE_MASK_MASK) {\n        byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n        if (payloadLen == 127) {\n          return Mask(bytes + 10);\n        } else if (payloadLen == 126) {\n          return Mask(bytes + 4);\n        } else {\n          return Mask(bytes + 2);\n        }\n      } else {\n        return Mask();\n      }\n    }\n\n    static size_t headerSize(byte const* bytes, size_t sizeSoFar) {\n      if (sizeSoFar < 2) return 2;\n\n      size_t required = 2;\n\n      if (bytes[1] & USE_MASK_MASK) {\n        required += 4;\n      }\n\n      byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n      if (payloadLen == 127) {\n        required += 8;\n      } else if (payloadLen == 126) {\n        required += 2;\n      }\n\n      return required;\n    }\n\n  private:\n    byte bytes[14];\n\n    static constexpr byte FIN_MASK = 0x80;\n    static constexpr byte RSV2_3_MASK = 0x30;\n    static constexpr byte RSV1_MASK = 0x40;\n    static constexpr byte OPCODE_MASK = 0x0f;\n\n    static constexpr byte USE_MASK_MASK = 0x80;\n    static constexpr byte PAYLOAD_LEN_MASK = 0x7f;\n  };\n\n#if KJ_HAS_ZLIB\n  class ZlibContext {\n    // `ZlibContext` is the WebSocket's interface to Zlib's compression/decompression functions.\n    // Depending on the `mode`, `ZlibContext` will act as a compressor or a decompressor.\n  public:\n    enum class Mode {\n      COMPRESS,\n      DECOMPRESS,\n    };\n\n    struct Result {\n      int processResult = 0;\n      kj::Array<const byte> buffer;\n      size_t size = 0; // Number of bytes used; size <= buffer.size().\n    };\n\n    ZlibContext(Mode mode, const CompressionParameters& config) : mode(mode) {\n      switch (mode) {\n        case Mode::COMPRESS: {\n          int windowBits = -config.outboundMaxWindowBits.orDefault(15);\n          // We use negative values because we want to use raw deflate.\n          if(windowBits == -8) {\n            // Zlib cannot accept `windowBits` of 8 for the deflater. However, due to an\n            // implementation quirk, `windowBits` of 8 and 9 would both use 250 bytes.\n            // Therefore, a decompressor using `windowBits` of 8 could safely inflate a message\n            // that a zlib client compressed using `windowBits` = 9.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=691074\n            windowBits = -9;\n          }\n          int result = deflateInit2(\n              &ctx,\n              Z_DEFAULT_COMPRESSION,\n              Z_DEFLATED,\n              windowBits,\n              8,  // memLevel = 8 is the default\n              Z_DEFAULT_STRATEGY);\n          KJ_REQUIRE(result == Z_OK, \"Failed to initialize compression context (deflate).\");\n          break;\n        }\n        case Mode::DECOMPRESS: {\n          int windowBits = -config.inboundMaxWindowBits.orDefault(15);\n          // We use negative values because we want to use raw inflate.\n          int result = inflateInit2(&ctx, windowBits);\n          KJ_REQUIRE(result == Z_OK, \"Failed to initialize decompression context (inflate).\");\n          break;\n        }\n      }\n    }\n\n    ~ZlibContext() noexcept(false) {\n      switch (mode) {\n        case Mode::COMPRESS:\n          deflateEnd(&ctx);\n          break;\n        case Mode::DECOMPRESS:\n          inflateEnd(&ctx);\n          break;\n      }\n    }\n\n    KJ_DISALLOW_COPY_AND_MOVE(ZlibContext);\n\n    kj::Array<kj::byte> processMessage(kj::ArrayPtr<const byte> message,\n        kj::Maybe<size_t> maxSize = kj::none,\n        bool addNullTerminator = false) {\n      // If `this` is the compressor, calling `processMessage()` will compress the `message`.\n      // Likewise, if `this` is the decompressor, `processMessage()` will decompress the `message`.\n      //\n      // `maxSize` is only passed in when decompressing, since we want to ensure the decompressed\n      // message is smaller than the `maxSize` passed to `receive()`.\n      //\n      // If (de)compression is successful, the result is returned as a Vector, otherwise,\n      // an Exception is thrown.\n\n      ctx.next_in = const_cast<byte*>(reinterpret_cast<const byte*>(message.begin()));\n      ctx.avail_in = message.size();\n\n      kj::Vector<Result> parts(processLoop(maxSize));\n\n      size_t amountToAllocate = 0;\n      for (const auto& part : parts) {\n        amountToAllocate += part.size;\n      }\n\n      if (addNullTerminator) {\n        // Add space for the null-terminator.\n        amountToAllocate += 1;\n      }\n\n      kj::Array<kj::byte> processedMessage = kj::heapArray<kj::byte>(amountToAllocate);\n      size_t currentIndex = 0; // Current index into processedMessage.\n      for (const auto& part : parts) {\n        memcpy(&processedMessage[currentIndex], part.buffer.begin(), part.size);\n        // We need to use `part.size` to determine the number of useful bytes, since data after\n        // `part.size` is unused (and probably junk).\n        currentIndex += part.size;\n      }\n\n      if (addNullTerminator) {\n        processedMessage[currentIndex++] = '\\0';\n      }\n\n      KJ_ASSERT(currentIndex == processedMessage.size());\n\n      return kj::mv(processedMessage);\n    }\n\n    void reset() {\n      // Resets the (de)compression context. This should only be called when the (de)compressor uses\n      // client/server_no_context_takeover.\n      switch (mode) {\n        case Mode::COMPRESS: {\n          KJ_ASSERT(deflateReset(&ctx) == Z_OK, \"deflateReset() failed.\");\n          break;\n        }\n        case Mode::DECOMPRESS: {\n          KJ_ASSERT(inflateReset(&ctx) == Z_OK, \"inflateReset failed.\");\n          break;\n        }\n      }\n\n    }\n\n  private:\n    Result pumpOnce() {\n      // Prepares Zlib's internal state for a call to deflate/inflate, then calls the relevant\n      // function to process the input buffer. It is assumed that the caller has already set up\n      // Zlib's input buffer.\n      //\n      // Since calls to deflate/inflate will process data until the input is empty, or until the\n      // output is full, multiple calls to `pumpOnce()` may be required to process the entire\n      // message. We're done processing once either `result` is `Z_STREAM_END`, or we get\n      // `Z_BUF_ERROR` and did not write any more output.\n      size_t bufSize = 4096;\n      Array<kj::byte> buffer = kj::heapArray<kj::byte>(bufSize);\n      ctx.next_out = buffer.begin();\n      ctx.avail_out = bufSize;\n\n      int result = Z_OK;\n\n      switch (mode) {\n        case Mode::COMPRESS:\n          result = deflate(&ctx, Z_SYNC_FLUSH);\n          KJ_REQUIRE(result == Z_OK || result == Z_BUF_ERROR || result == Z_STREAM_END,\n                      \"Compression failed\", result);\n          break;\n        case Mode::DECOMPRESS:\n          result = inflate(&ctx, Z_SYNC_FLUSH);\n          KJ_REQUIRE(result == Z_OK || result == Z_BUF_ERROR || result == Z_STREAM_END,\n                      \"Decompression failed\", result, \" with reason\", ctx.msg);\n          break;\n      }\n\n      return Result {\n        result,\n        kj::mv(buffer),\n        bufSize - ctx.avail_out,\n      };\n    }\n\n    kj::Vector<Result> processLoop(kj::Maybe<size_t> maxSize) {\n      // Since Zlib buffers the writes, we want to continue processing until there's nothing left.\n      kj::Vector<Result> output;\n      size_t totalBytesProcessed = 0;\n      for (;;) {\n        Result result = pumpOnce();\n\n        auto status = result.processResult;\n        auto bytesProcessed = result.size;\n        if (bytesProcessed > 0) {\n          output.add(kj::mv(result));\n          totalBytesProcessed += bytesProcessed;\n          KJ_IF_SOME(m, maxSize) {\n            // This is only non-null for `receive` calls, so we must be decompressing. We don't want\n            // the decompressed message to OOM us, so let's make sure it's not too big.\n            KJ_REQUIRE(totalBytesProcessed < m,\n                \"Decompressed WebSocket message is too large\");\n          }\n        }\n\n        if ((ctx.avail_in == 0 && ctx.avail_out != 0) || status == Z_STREAM_END) {\n          // If we're out of input to consume, and we have space in the output buffer, then we must\n          // have flushed the remaining message, so we're done pumping. Alternatively, if we found a\n          // BFINAL deflate block, then we know the stream is completely finished.\n          if (status == Z_STREAM_END) {\n            reset();\n          }\n          return kj::mv(output);\n        }\n      }\n    }\n\n    Mode mode;\n    z_stream ctx = {};\n  };\n#endif // KJ_HAS_ZLIB\n\n  static constexpr byte OPCODE_CONTINUATION = 0;\n  static constexpr byte OPCODE_TEXT         = 1;\n  static constexpr byte OPCODE_BINARY       = 2;\n  static constexpr byte OPCODE_CLOSE        = 8;\n  static constexpr byte OPCODE_PING         = 9;\n  static constexpr byte OPCODE_PONG         = 10;\n\n  static constexpr byte OPCODE_FIRST_CONTROL = 8;\n\n  // ---------------------------------------------------------------------------\n\n  kj::Own<kj::AsyncIoStream> stream;\n  kj::Maybe<EntropySource&> maskKeyGenerator;\n  kj::Maybe<CompressionParameters> compressionConfig;\n  WebSocketErrorHandler& errorHandler;\n#if KJ_HAS_ZLIB\n  kj::Maybe<ZlibContext> compressionContext;\n  kj::Maybe<ZlibContext> decompressionContext;\n#endif // KJ_HAS_ZLIB\n\n  bool hasSentClose = false;\n  bool disconnected = false;\n  bool currentlySending = false;\n  Header sendHeader;\n  kj::ArrayPtr<const byte> sendParts[2];\n\n  kj::Maybe<kj::Array<byte>> queuedPong;\n  // queuedPong holds the body of the next pong to write, cleared when the pong is written.  If a\n  // more recent ping arrives before the pong is actually written, we can update this value to\n  // instead respond to the more recent ping.\n\n  kj::Maybe<kj::Promise<void>> sendingPong;\n  // If a Pong is being sent asynchronously in response to a Ping, this is a promise for the\n  // completion of that send.\n  //\n  // Additionally, this member is used if we need to block our first send on WebSocket startup,\n  // e.g. because we need to wait for HTTP handshake writes to flush before we can start sending\n  // WebSocket data. `sendingPong` was overloaded for this use case because the logic is the same.\n  // Perhaps it should be renamed to `blockSend` or `writeQueue`.\n\n  uint fragmentOpcode = 0;\n  bool fragmentCompressed = false;\n  // For fragmented messages, was the first frame compressed?\n  // Note that subsequent frames of a compressed message will not set the RSV1 bit.\n  kj::Vector<kj::Array<byte>> fragments;\n  // If `fragments` is non-empty, we've already received some fragments of a message.\n  // `fragmentOpcode` is the original opcode.\n\n  kj::Array<byte> recvBuffer;\n  kj::ArrayPtr<byte> recvData;\n\n  uint64_t sentBytes = 0;\n  uint64_t receivedBytes = 0;\n\n  kj::Promise<void> sendImpl(byte opcode, kj::ArrayPtr<const byte> message) {\n    KJ_REQUIRE(!disconnected, \"WebSocket can't send after disconnect()\");\n    KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n\n    currentlySending = true;\n\n    KJ_IF_SOME(p, sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      auto promise = p.then([this, opcode, message]() {\n        currentlySending = false;\n        return sendImpl(opcode, message);\n      });\n      sendingPong = kj::none;\n      return promise;\n    }\n\n    // We don't stop the application from sending further messages after close() -- this is the\n    // application's error to make. But, we do want to make sure we don't send any PONGs after a\n    // close, since that would be our error. So we stack whether we closed for that reason.\n    hasSentClose = hasSentClose || opcode == OPCODE_CLOSE;\n\n    Mask mask(maskKeyGenerator);\n\n    bool useCompression = false;\n    kj::Maybe<kj::Array<byte>> compressedMessage;\n    if (opcode == OPCODE_BINARY || opcode == OPCODE_TEXT) {\n      // We can only compress data frames.\n#if KJ_HAS_ZLIB\n      KJ_IF_SOME(config, compressionConfig) {\n        useCompression = true;\n        // Compress `message` according to `compressionConfig`s outbound parameters.\n        auto& compressor = KJ_ASSERT_NONNULL(compressionContext);\n        if (config.outboundNoContextTakeover) {\n          // We must reset context on each message.\n          compressor.reset();\n        }\n        auto& innerMessage = compressedMessage.emplace(compressor.processMessage(message));\n        if (message.size() > 0) {\n          KJ_ASSERT(innerMessage.asPtr().endsWith({0x00, 0x00, 0xFF, 0xFF}));\n          message = innerMessage.slice(0, innerMessage.size() - 4);\n          // Strip 0x00 0x00 0xFF 0xFF off the tail.\n          // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.1\n        } else {\n          // RFC 7692 (7.2.3.6) specifies that an empty uncompressed DEFLATE block (0x00) should be\n          // built if the compression library doesn't generate data when the input is empty.\n          message = compressedMessage.emplace(kj::heapArray<byte>({0x00}));\n        }\n      }\n#endif // KJ_HAS_ZLIB\n    }\n\n    kj::Array<byte> ownMessage;\n    if (!mask.isZero()) {\n      // Sadness, we have to make a copy to apply the mask.\n      ownMessage = kj::heapArray(message);\n      mask.apply(ownMessage);\n      message = ownMessage;\n    }\n\n    sendParts[0] = sendHeader.compose(true, useCompression, opcode, message.size(), mask);\n    sendParts[1] = message;\n    KJ_ASSERT(!sendHeader.hasRsv2or3(), \"RSV bits 2 and 3 must be 0, as we do not currently \"\n        \"support an extension that would set these bits\");\n\n    auto promise = stream->write(sendParts).attach(kj::mv(compressedMessage));\n    if (!mask.isZero()) {\n      promise = promise.attach(kj::mv(ownMessage));\n    }\n    return promise.then([this, size = sendParts[0].size() + sendParts[1].size()]() {\n      currentlySending = false;\n\n      // Send queued pong if needed.\n      if (queuedPong != kj::none) {\n        setUpSendingPong();\n      }\n      sentBytes += size;\n    });\n  }\n\n  void queuePong(kj::Array<byte> payload) {\n    bool alreadyWaitingForPongWrite = (queuedPong != kj::none);\n\n    // Note: According to spec, if the server receives a second ping before responding to the\n    //   previous one, it can opt to respond only to the last ping. So we don't have to check if\n    //   queuedPong is already non-null.\n    queuedPong = kj::mv(payload);\n\n    if (currentlySending) {\n      // There is a message-send in progress, so we cannot write to the stream now.  We will set\n      // up the pong write at the end of the message-send.\n      return;\n    }\n    if (alreadyWaitingForPongWrite) {\n      // We were already waiting for a pong to be written; don't need to queue another write.\n      return;\n    }\n    setUpSendingPong();\n  }\n\n  void setUpSendingPong() {\n    KJ_IF_SOME(promise, sendingPong) {\n      sendingPong = promise.then([this]() mutable {\n        return writeQueuedPong();\n      });\n    } else {\n      sendingPong = writeQueuedPong();\n    }\n  }\n\n  kj::Promise<void> writeQueuedPong() {\n    KJ_IF_SOME(q, queuedPong) {\n      kj::Array<byte> payload = kj::mv(q);\n      queuedPong = kj::none;\n\n      if (hasSentClose || disconnected) {\n        return kj::READY_NOW;\n      }\n\n      sendParts[0] = sendHeader.compose(true, false, OPCODE_PONG,\n                                        payload.size(), Mask(maskKeyGenerator));\n      sendParts[1] = payload;\n      return stream->write(sendParts).attach(kj::mv(payload));\n    } else {\n      return kj::READY_NOW;\n    }\n  }\n\n  kj::Promise<void> optimizedPumpTo(WebSocketImpl& other) {\n    KJ_IF_SOME(p, other.sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      auto promise = p.then([this, &other]() {\n        return optimizedPumpTo(other);\n      });\n      other.sendingPong = kj::none;\n      return promise;\n    }\n\n    if (recvData.size() > 0) {\n      // We have some data buffered. Write it first.\n      return other.stream->write(recvData.begin(), recvData.size())\n          .then([this, &other, size = recvData.size()]() {\n        recvData = nullptr;\n        other.sentBytes += size;\n        return optimizedPumpTo(other);\n      });\n    }\n\n    auto cancelPromise = other.stream->whenWriteDisconnected()\n        .then([this]() -> kj::Promise<void> {\n      this->abort();\n      return KJ_EXCEPTION(DISCONNECTED,\n          \"destination of WebSocket pump disconnected prematurely\");\n    });\n\n    // There's no buffered incoming data, so start pumping stream now.\n    return stream->pumpTo(*other.stream).then([this, &other](size_t s) -> kj::Promise<void> {\n      // WebSocket pumps are expected to include end-of-stream.\n      other.disconnected = true;\n      other.stream->shutdownWrite();\n      receivedBytes += s;\n      other.sentBytes += s;\n      return kj::READY_NOW;\n    }, [&other](kj::Exception&& e) -> kj::Promise<void> {\n      // We don't know if it was a read or a write that threw. If it was a read that threw, we need\n      // to send a disconnect on the destination. If it was the destination that threw, it\n      // shouldn't hurt to disconnect() it again, but we'll catch and squelch any exceptions.\n      other.disconnected = true;\n      kj::runCatchingExceptions([&other]() { other.stream->shutdownWrite(); });\n      return kj::mv(e);\n    }).exclusiveJoin(kj::mv(cancelPromise));\n  }\n};\n\nkj::Own<WebSocket> upgradeToWebSocket(\n    kj::Own<kj::AsyncIoStream> stream, HttpInputStreamImpl& httpInput, HttpOutputStream& httpOutput,\n    kj::Maybe<EntropySource&> maskKeyGenerator,\n    kj::Maybe<CompressionParameters> compressionConfig = kj::none,\n    kj::Maybe<WebSocketErrorHandler&> errorHandler = kj::none) {\n  // Create a WebSocket upgraded from an HTTP stream.\n  auto releasedBuffer = httpInput.releaseBuffer();\n  return kj::heap<WebSocketImpl>(kj::mv(stream), maskKeyGenerator,\n                                 kj::mv(compressionConfig), errorHandler,\n                                 kj::mv(releasedBuffer.buffer),\n                                 releasedBuffer.leftover, httpOutput.flush());\n}\n\n}  // namespace\n\nkj::Own<WebSocket> newWebSocket(kj::Own<kj::AsyncIoStream> stream,\n                                kj::Maybe<EntropySource&> maskKeyGenerator,\n                                kj::Maybe<CompressionParameters> compressionConfig,\n                                kj::Maybe<WebSocketErrorHandler&> errorHandler) {\n  return kj::heap<WebSocketImpl>(kj::mv(stream), maskKeyGenerator, kj::mv(compressionConfig), errorHandler);\n}\n\nstatic kj::Promise<void> pumpWebSocketLoop(WebSocket& from, WebSocket& to) {\n  return from.receive().then([&from,&to](WebSocket::Message&& message) {\n    KJ_SWITCH_ONEOF(message) {\n      KJ_CASE_ONEOF(text, kj::String) {\n        return to.send(text)\n            .attach(kj::mv(text))\n            .then([&from,&to]() { return pumpWebSocketLoop(from, to); });\n      }\n      KJ_CASE_ONEOF(data, kj::Array<byte>) {\n        return to.send(data)\n            .attach(kj::mv(data))\n            .then([&from,&to]() { return pumpWebSocketLoop(from, to); });\n      }\n      KJ_CASE_ONEOF(close, WebSocket::Close) {\n        // Once a close has passed through, the pump is complete.\n        return to.close(close.code, close.reason)\n            .attach(kj::mv(close));\n      }\n    }\n    KJ_UNREACHABLE;\n  }, [&to](kj::Exception&& e) {\n    if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n      return to.disconnect();\n    } else {\n      return to.close(1002, e.getDescription());\n    }\n  });\n}\n\nkj::Promise<void> WebSocket::pumpTo(WebSocket& other) {\n  KJ_IF_SOME(p, other.tryPumpFrom(*this)) {\n    // Yay, optimized pump!\n    return kj::mv(p);\n  } else {\n    // Fall back to default implementation.\n    return kj::evalNow([&]() {\n      auto cancelPromise = other.whenAborted().then([this]() -> kj::Promise<void> {\n        this->abort();\n        return KJ_EXCEPTION(DISCONNECTED,\n            \"destination of WebSocket pump disconnected prematurely\");\n      });\n      return pumpWebSocketLoop(*this, other).exclusiveJoin(kj::mv(cancelPromise));\n    });\n  }\n}\n\nkj::Maybe<kj::Promise<void>> WebSocket::tryPumpFrom(WebSocket& other) {\n  return kj::none;\n}\n\nnamespace {\n\nclass WebSocketPipeImpl final: public WebSocket, public kj::Refcounted {\n  // Represents one direction of a WebSocket pipe.\n  //\n  // This class behaves as a \"loopback\" WebSocket: a message sent using send() is received using\n  // receive(), on the same object. This is *not* how WebSocket implementations usually behave.\n  // But, this object is actually used to implement only one direction of a bidirectional pipe. At\n  // another layer above this, the pipe is actually composed of two WebSocketPipeEnd instances,\n  // which layer on top of two WebSocketPipeImpl instances representing the two directions. So,\n  // send() calls on a WebSocketPipeImpl instance always come from one of the two WebSocketPipeEnds\n  // while receive() calls come from the other end.\n\npublic:\n  ~WebSocketPipeImpl() noexcept(false) {\n    KJ_REQUIRE(state == kj::none || ownState.get() != nullptr,\n        \"destroying WebSocketPipe with operation still in-progress; probably going to segfault\") {\n      // Don't std::terminate().\n      break;\n    }\n  }\n\n  void abort() override {\n    KJ_IF_SOME(s, state) {\n      s.abort();\n    } else {\n      ownState = heap<Aborted>();\n      state = *ownState;\n\n      aborted = true;\n      KJ_IF_SOME(f, abortedFulfiller) {\n        f->fulfill();\n        abortedFulfiller = kj::none;\n      }\n    }\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    KJ_IF_SOME(s, state) {\n      return s.send(message).then([&, size = message.size()]() { transferredBytes += size; });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(message))\n          .then([&, size = message.size()]() { transferredBytes += size; });\n    }\n  }\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    KJ_IF_SOME(s, state) {\n      return s.send(message).then([&, size = message.size()]() { transferredBytes += size; });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(message))\n          .then([&, size = message.size()]() { transferredBytes += size; });\n    }\n  }\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    KJ_IF_SOME(s, state) {\n      return s.close(code, reason)\n          .then([&, size = reason.size()]() { transferredBytes += (2 +size); });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(ClosePtr { code, reason }))\n          .then([&, size = reason.size()]() { transferredBytes += (2 +size); });\n    }\n  }\n  kj::Promise<void> disconnect() override {\n    KJ_IF_SOME(s, state) {\n      return s.disconnect();\n    } else {\n      ownState = heap<Disconnected>();\n      state = *ownState;\n      return kj::READY_NOW;\n    }\n  }\n  kj::Promise<void> whenAborted() override {\n    if (aborted) {\n      return kj::READY_NOW;\n    } else KJ_IF_SOME(p, abortedPromise) {\n      return p.addBranch();\n    } else {\n      auto paf = newPromiseAndFulfiller<void>();\n      abortedFulfiller = kj::mv(paf.fulfiller);\n      auto fork = paf.promise.fork();\n      auto result = fork.addBranch();\n      abortedPromise = kj::mv(fork);\n      return result;\n    }\n  }\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    KJ_IF_SOME(s, state) {\n      return s.tryPumpFrom(other);\n    } else {\n      return newAdaptedPromise<void, BlockedPumpFrom>(*this, other);\n    }\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    KJ_IF_SOME(s, state) {\n      return s.receive(maxSize);\n    } else {\n      return newAdaptedPromise<Message, BlockedReceive>(*this, maxSize);\n    }\n  }\n  kj::Promise<void> pumpTo(WebSocket& other) override {\n    auto onAbort = other.whenAborted()\n        .then([]() -> kj::Promise<void> {\n      return KJ_EXCEPTION(DISCONNECTED, \"WebSocket was aborted\");\n    });\n\n    KJ_IF_SOME(s, state) {\n      auto before = other.receivedByteCount();\n      return s.pumpTo(other).attach(kj::defer([this, &other, before]() {\n        transferredBytes += other.receivedByteCount() - before;\n      })).exclusiveJoin(kj::mv(onAbort));\n    } else {\n      return newAdaptedPromise<void, BlockedPumpTo>(*this, other).exclusiveJoin(kj::mv(onAbort));\n    }\n  }\n\n  uint64_t sentByteCount() override {\n    return transferredBytes;\n  }\n  uint64_t receivedByteCount() override {\n    return transferredBytes;\n  }\n\nprivate:\n  kj::Maybe<WebSocket&> state;\n  // Object-oriented state! If any method call is blocked waiting on activity from the other end,\n  // then `state` is non-null and method calls should be forwarded to it. If no calls are\n  // outstanding, `state` is null.\n\n  kj::Own<WebSocket> ownState;\n\n  uint64_t transferredBytes = 0;\n\n  bool aborted = false;\n  Maybe<Own<PromiseFulfiller<void>>> abortedFulfiller = kj::none;\n  Maybe<ForkedPromise<void>> abortedPromise = kj::none;\n\n  void endState(WebSocket& obj) {\n    KJ_IF_SOME(s, state) {\n      if (&s == &obj) {\n        state = kj::none;\n      }\n    }\n  }\n\n  struct ClosePtr {\n    uint16_t code;\n    kj::StringPtr reason;\n  };\n  typedef kj::OneOf<kj::ArrayPtr<const char>, kj::ArrayPtr<const byte>, ClosePtr> MessagePtr;\n\n  class BlockedSend final: public WebSocket {\n  public:\n    BlockedSend(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe, MessagePtr message)\n        : fulfiller(fulfiller), pipe(pipe), message(kj::mv(message)) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedSend() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill();\n      pipe.endState(*this);\n      KJ_SWITCH_ONEOF(message) {\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const char>) {\n          return Message(kj::str(arr));\n        }\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const byte>) {\n          auto copy = kj::heapArray<byte>(arr.size());\n          memcpy(copy.begin(), arr.begin(), arr.size());\n          return Message(kj::mv(copy));\n        }\n        KJ_CASE_ONEOF(close, ClosePtr) {\n          return Message(Close { close.code, kj::str(close.reason) });\n        }\n      }\n      KJ_UNREACHABLE;\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      kj::Promise<void> promise = nullptr;\n      KJ_SWITCH_ONEOF(message) {\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const char>) {\n          promise = other.send(arr);\n        }\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const byte>) {\n          promise = other.send(arr);\n        }\n        KJ_CASE_ONEOF(close, ClosePtr) {\n          promise = other.close(close.code, close.reason);\n        }\n      }\n      return canceler.wrap(promise.then([this,&other]() {\n        canceler.release();\n        fulfiller.fulfill();\n        pipe.endState(*this);\n        return pipe.pumpTo(other);\n      }, [this](kj::Exception&& e) -> kj::Promise<void> {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        return kj::mv(e);\n      }));\n    }\n\n  uint64_t sentByteCount() override {\n    KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n  }\n  uint64_t receivedByteCount() override {\n    KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n   }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    MessagePtr message;\n    Canceler canceler;\n  };\n\n  class BlockedPumpFrom final: public WebSocket {\n  public:\n    BlockedPumpFrom(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe,\n                    WebSocket& input)\n        : fulfiller(fulfiller), pipe(pipe), input(input) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedPumpFrom() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message receive is already in progress\");\n      return canceler.wrap(input.receive(maxSize)\n          .then([this](Message message) {\n        if (message.is<Close>()) {\n          canceler.release();\n          fulfiller.fulfill();\n          pipe.endState(*this);\n        }\n        return kj::mv(message);\n      }, [this](kj::Exception&& e) -> Message {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        kj::throwRecoverableException(kj::mv(e));\n        return Message(kj::String());\n      }));\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message receive is already in progress\");\n      return canceler.wrap(input.pumpTo(other)\n          .then([this]() {\n        canceler.release();\n        fulfiller.fulfill();\n        pipe.endState(*this);\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    WebSocket& input;\n    Canceler canceler;\n  };\n\n  class BlockedReceive final: public WebSocket {\n  public:\n    BlockedReceive(kj::PromiseFulfiller<Message>& fulfiller, WebSocketPipeImpl& pipe,\n                   size_t maxSize)\n        : fulfiller(fulfiller), pipe(pipe), maxSize(maxSize) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedReceive() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      auto copy = kj::heapArray<byte>(message.size());\n      memcpy(copy.begin(), message.begin(), message.size());\n      fulfiller.fulfill(Message(kj::mv(copy)));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill(Message(kj::str(message)));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill(Message(Close { code, kj::str(reason) }));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"WebSocket disconnected\"));\n      pipe.endState(*this);\n      return pipe.disconnect();\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      return canceler.wrap(other.receive(maxSize).then([this,&other](Message message) {\n        canceler.release();\n        fulfiller.fulfill(kj::mv(message));\n        pipe.endState(*this);\n        return other.pumpTo(pipe);\n      }, [this](kj::Exception&& e) -> kj::Promise<void> {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        return kj::mv(e);\n      }));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<Message>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    size_t maxSize;\n    Canceler canceler;\n  };\n\n  class BlockedPumpTo final: public WebSocket {\n  public:\n    BlockedPumpTo(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe, WebSocket& output)\n        : fulfiller(fulfiller), pipe(pipe), output(output) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedPumpTo() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n\n      // abort() is called when the pipe end is dropped. This should be treated as disconnecting,\n      // so pumpTo() should complete normally.\n      fulfiller.fulfill();\n\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.send(message));\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.send(message));\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.close(code, reason).then([this]() {\n        // A pump is expected to end upon seeing a Close message.\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.disconnect().then([this]() {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n        return pipe.disconnect();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(other.pumpTo(output).then([this]() {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    WebSocket& output;\n    Canceler canceler;\n  };\n\n  class Disconnected final: public WebSocket {\n  public:\n    void abort() override {\n      // can ignore\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_REQUIRE(\"can't send() after disconnect()\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_REQUIRE(\"can't send() after disconnect()\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_REQUIRE(\"can't close() after disconnect()\");\n    }\n    kj::Promise<void> disconnect() override {\n      return kj::READY_NOW;\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_REQUIRE(\"can't tryPumpFrom() after disconnect()\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"WebSocket disconnected\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return kj::READY_NOW;\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  };\n\n  class Aborted final: public WebSocket {\n  public:\n    void abort() override {\n      // can ignore\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> disconnect() override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      return kj::Promise<void>(KJ_EXCEPTION(DISCONNECTED,\n          \"other end of WebSocketPipe was destroyed\"));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n  };\n};\n\nclass WebSocketPipeEnd final: public WebSocket {\npublic:\n  WebSocketPipeEnd(kj::Own<WebSocketPipeImpl> in, kj::Own<WebSocketPipeImpl> out)\n      : in(kj::mv(in)), out(kj::mv(out)) {}\n  ~WebSocketPipeEnd() noexcept(false) {\n    in->abort();\n    out->abort();\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    return out->send(message);\n  }\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    return out->send(message);\n  }\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    return out->close(code, reason);\n  }\n  kj::Promise<void> disconnect() override {\n    return out->disconnect();\n  }\n  void abort() override {\n    in->abort();\n    out->abort();\n  }\n  kj::Promise<void> whenAborted() override {\n    return out->whenAborted();\n  }\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    return out->tryPumpFrom(other);\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    return in->receive(maxSize);\n  }\n  kj::Promise<void> pumpTo(WebSocket& other) override {\n    return in->pumpTo(other);\n  }\n\n  uint64_t sentByteCount() override { return out->sentByteCount(); }\n  uint64_t receivedByteCount() override { return in->sentByteCount(); }\n\nprivate:\n  kj::Own<WebSocketPipeImpl> in;\n  kj::Own<WebSocketPipeImpl> out;\n};\n\n}  // namespace\n\nWebSocketPipe newWebSocketPipe() {\n  auto pipe1 = kj::refcounted<WebSocketPipeImpl>();\n  auto pipe2 = kj::refcounted<WebSocketPipeImpl>();\n\n  auto end1 = kj::heap<WebSocketPipeEnd>(kj::addRef(*pipe1), kj::addRef(*pipe2));\n  auto end2 = kj::heap<WebSocketPipeEnd>(kj::mv(pipe2), kj::mv(pipe1));\n\n  return { { kj::mv(end1), kj::mv(end2) } };\n}\n\n// =======================================================================================\nclass AsyncIoStreamWithInitialBuffer final: public kj::AsyncIoStream {\n  // An AsyncIoStream implementation that accepts an initial buffer of data\n  // to be read out first, and is optionally capable of deferring writes\n  // until a given waitBeforeSend promise is fulfilled.\n  //\n  // Instances are created with a leftoverBackingBuffer (a kj::Array<byte>)\n  // and a leftover kj::ArrayPtr<byte> that provides a view into the backing\n  // buffer representing the queued data that is pending to be read. Calling\n  // tryRead will consume the data from the leftover first. Once leftover has\n  // been fully consumed, reads will defer to the underlying stream.\npublic:\n  AsyncIoStreamWithInitialBuffer(kj::Own<kj::AsyncIoStream> stream,\n                                 kj::Array<byte> leftoverBackingBuffer,\n                                 kj::ArrayPtr<byte> leftover)\n                                 : stream(kj::mv(stream)),\n                                   leftoverBackingBuffer(kj::mv(leftoverBackingBuffer)),\n                                   leftover(leftover) {}\n\n  void shutdownWrite() override {\n    stream->shutdownWrite();\n  }\n\n  // AsyncInputStream\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(maxBytes >= minBytes);\n    auto destination = static_cast<byte*>(buffer);\n\n    // If there are at least minBytes available in the leftover buffer...\n    if (leftover.size() >= minBytes) {\n      // We are going to immediately read up to maxBytes from the leftover buffer...\n      auto bytesToCopy = kj::min(maxBytes, leftover.size());\n      memcpy(destination, leftover.begin(), bytesToCopy);\n      leftover = leftover.slice(bytesToCopy, leftover.size());\n\n      // If we've consumed all of the data in the leftover buffer, go ahead and free it.\n      if (leftover.size() == 0) {\n        leftoverBackingBuffer = nullptr;\n      }\n\n      return bytesToCopy;\n    } else {\n      // We know here that leftover.size() is less than minBytes, but it might not\n      // be zero. Copy everything from leftover into the destination buffer then read\n      // the rest from the underlying stream.\n      auto bytesToCopy = leftover.size();\n      KJ_DASSERT(bytesToCopy < minBytes);\n\n      if (bytesToCopy > 0) {\n        memcpy(destination, leftover.begin(), bytesToCopy);\n        leftoverBackingBuffer = nullptr;\n        minBytes -= bytesToCopy;\n        maxBytes -= bytesToCopy;\n        KJ_DASSERT(minBytes >= 1);\n        KJ_DASSERT(maxBytes >= minBytes);\n      }\n\n      return stream->tryRead(destination + bytesToCopy, minBytes, maxBytes)\n          .then([bytesToCopy](size_t amount) { return amount + bytesToCopy; });\n    }\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    // For a CONNECT pipe, we have no idea how much data there is going to be.\n    return kj::none;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output,\n                               uint64_t amount = kj::maxValue) override {\n    return pumpLoop(output, amount, 0);\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input,\n                                               uint64_t amount = kj::maxValue) override {\n    return input.pumpTo(*stream, amount);\n  }\n\n  // AsyncOutputStream\n  Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return stream->write(pieces);\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return stream->whenWriteDisconnected();\n  }\n\nprivate:\n\n  kj::Promise<uint64_t> pumpLoop(\n      kj::AsyncOutputStream& output,\n      uint64_t remaining,\n      uint64_t total) {\n    // If there is any data remaining in the leftover queue, we'll write it out first to output.\n    if (leftover.size() > 0) {\n      auto bytesToWrite = kj::min(leftover.size(), remaining);\n      return output.write(leftover.begin(), bytesToWrite).then(\n          [this, &output, remaining, total, bytesToWrite]() mutable -> kj::Promise<uint64_t> {\n        leftover = leftover.slice(bytesToWrite, leftover.size());\n        // If the leftover buffer has been fully consumed, go ahead and free it now.\n        if (leftover.size() == 0) {\n          leftoverBackingBuffer = nullptr;\n        }\n        remaining -= bytesToWrite;\n        total += bytesToWrite;\n\n        if (remaining == 0) {\n          return total;\n        }\n        return pumpLoop(output, remaining, total);\n      });\n    } else {\n      // Otherwise, we are just going to defer to stream's pumpTo, making sure to\n      // account for the total amount we've already written from the leftover queue.\n      return stream->pumpTo(output, remaining).then([total](auto read) {\n        return total + read;\n      });\n    }\n  };\n\n  kj::Own<kj::AsyncIoStream> stream;\n  kj::Array<byte> leftoverBackingBuffer;\n  kj::ArrayPtr<byte> leftover;\n};\n\nclass AsyncIoStreamWithGuards final: public kj::AsyncIoStream,\n                                     private kj::TaskSet::ErrorHandler {\n  // This AsyncIoStream adds separate kj::Promise guards to both the input and output,\n  // delaying reads and writes until each relevant guard is resolved.\n  //\n  // When the read guard promise resolves, it may provide a released buffer that will\n  // be read out first.\n  // The primary use case for this impl is to support pipelined CONNECT calls which\n  // optimistically allow outbound writes to happen while establishing the CONNECT\n  // tunnel has not yet been completed. If the guard promise rejects, the stream\n  // is permanently errored and existing pending calls (reads and writes) are canceled.\npublic:\n  AsyncIoStreamWithGuards(\n      kj::Own<kj::AsyncIoStream> inner,\n      kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>> readGuard,\n      kj::Promise<void> writeGuard)\n      : inner(kj::mv(inner)),\n        readGuard(handleReadGuard(kj::mv(readGuard))),\n        writeGuard(handleWriteGuard(kj::mv(writeGuard))),\n        tasks(*this) {}\n\n  // AsyncInputStream\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    if (readGuardReleased) {\n      return inner->tryRead(buffer, minBytes, maxBytes);\n    }\n    return readGuard.addBranch().then([this, buffer, minBytes, maxBytes] {\n      return inner->tryRead(buffer, minBytes, maxBytes);\n    });\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return kj::none;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount = kj::maxValue) override {\n    if (readGuardReleased) {\n      return inner->pumpTo(output, amount);\n    }\n    return readGuard.addBranch().then([this, &output, amount] {\n      return inner->pumpTo(output, amount);\n    });\n  }\n\n  // AsyncOutputStream\n\n  void shutdownWrite() override {\n    if (writeGuardReleased) {\n      inner->shutdownWrite();\n    } else {\n      tasks.add(writeGuard.addBranch().then([this]() { inner->shutdownWrite(); }));\n    }\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input,\n                                               uint64_t amount = kj::maxValue) override {\n    if (writeGuardReleased) {\n      return input.pumpTo(*inner, amount);\n    } else {\n      return writeGuard.addBranch().then([this,&input,amount]() {\n        return input.pumpTo(*inner, amount);\n      });\n    }\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (writeGuardReleased) {\n      return inner->write(buffer, size);\n    } else {\n      return writeGuard.addBranch().then([this,buffer,size]() {\n        return inner->write(buffer, size);\n      });\n    }\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    if (writeGuardReleased) {\n      return inner->write(pieces);\n    } else {\n      return writeGuard.addBranch().then([this, pieces]() {\n        return inner->write(pieces);\n      });\n    }\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    if (writeGuardReleased) {\n      return inner->whenWriteDisconnected();\n    } else {\n      return writeGuard.addBranch().then([this]() {\n        return inner->whenWriteDisconnected();\n      }, [](kj::Exception&& e) mutable -> kj::Promise<void> {\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          return kj::READY_NOW;\n        } else {\n          return kj::mv(e);\n        }\n      });\n    }\n  }\n\nprivate:\n  kj::Own<kj::AsyncIoStream> inner;\n  kj::ForkedPromise<void> readGuard;\n  kj::ForkedPromise<void> writeGuard;\n  bool readGuardReleased = false;\n  bool writeGuardReleased = false;\n  kj::TaskSet tasks;\n  // Set of tasks used to call `shutdownWrite` after write guard is released.\n\n  void taskFailed(kj::Exception&& exception) override {\n    // This `taskFailed` callback is only used when `shutdownWrite` is being called. Because we\n    // don't care about DISCONNECTED exceptions when `shutdownWrite` is called we ignore this\n    // class of exceptions here.\n    if (exception.getType() != kj::Exception::Type::DISCONNECTED) {\n      KJ_LOG(ERROR, exception);\n    }\n  }\n\n  kj::ForkedPromise<void> handleWriteGuard(kj::Promise<void> guard) {\n    return guard.then([this]() {\n      writeGuardReleased = true;\n    }).fork();\n  }\n\n  kj::ForkedPromise<void> handleReadGuard(\n      kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>> guard) {\n    return guard.then([this](kj::Maybe<HttpInputStreamImpl::ReleasedBuffer> buffer) mutable {\n      readGuardReleased = true;\n      KJ_IF_SOME(b, buffer) {\n        if (b.leftover.size() > 0) {\n          // We only need to replace the inner stream if a non-empty buffer is provided.\n          inner = heap<AsyncIoStreamWithInitialBuffer>(\n              kj::mv(inner),\n              kj::mv(b.buffer), b.leftover);\n        }\n      }\n    }).fork();\n  }\n};\n\n// =======================================================================================\n\nnamespace _ { // private implementation details\n\nkj::ArrayPtr<const char> splitNext(kj::ArrayPtr<const char>& cursor, char delimiter) {\n  // Consumes and returns the next item in a delimited list.\n  //\n  // If a delimiter is found:\n  //  - `cursor` is updated to point to the rest of the string after the delimiter.\n  //  - The text before the delimiter is returned.\n  // If no delimiter is found:\n  //  - `cursor` is updated to an empty string.\n  //  - The text that had been in `cursor` is returned.\n  //\n  // (It's up to the caller to stop the loop once `cursor` is empty.)\n  KJ_IF_SOME(index, cursor.findFirst(delimiter)) {\n    auto part = cursor.slice(0, index);\n    cursor = cursor.slice(index + 1, cursor.size());\n    return part;\n  }\n  kj::ArrayPtr<const char> result(kj::mv(cursor));\n  cursor = nullptr;\n\n  return result;\n}\n\nvoid stripLeadingAndTrailingSpace(ArrayPtr<const char>& str) {\n  // Remove any leading/trailing spaces from `str`, modifying it in-place.\n  while (str.size() > 0 && (str[0] == ' ' || str[0] == '\\t')) {\n    str = str.slice(1, str.size());\n  }\n  while (str.size() > 0 && (str.back() == ' ' || str.back() == '\\t')) {\n    str = str.slice(0, str.size() - 1);\n  }\n}\n\nkj::Vector<kj::ArrayPtr<const char>> splitParts(kj::ArrayPtr<const char> input, char delim) {\n  // Given a string `input` and a delimiter `delim`, split the string into a vector of substrings,\n  // separated by the delimiter. Note that leading/trailing whitespace is stripped from each element.\n  kj::Vector<kj::ArrayPtr<const char>> parts;\n\n  while (input.size() != 0) {\n    auto part = splitNext(input, delim);\n    stripLeadingAndTrailingSpace(part);\n    parts.add(kj::mv(part));\n  }\n\n  return parts;\n}\n\nkj::Array<KeyMaybeVal> toKeysAndVals(const kj::ArrayPtr<kj::ArrayPtr<const char>>& params) {\n  // Given a collection of parameters (a single offer), parse the parameters into <key, MaybeValue>\n  // pairs. If the parameter contains an `=`, we set the `key` to everything before, and the `value`\n  // to everything after. Otherwise, we set the `key` to be the entire parameter.\n  // Either way, both the key and value (if it exists) are stripped of leading & trailing whitespace.\n  auto result = kj::heapArray<KeyMaybeVal>(params.size());\n  size_t count = 0;\n  for (const auto& param : params) {\n    kj::ArrayPtr<const char> key;\n    kj::Maybe<kj::ArrayPtr<const char>> value;\n\n    KJ_IF_SOME(index, param.findFirst('=')) {\n      // Found '=' so we have a value.\n      key = param.slice(0, index);\n      stripLeadingAndTrailingSpace(key);\n      value = param.slice(index + 1, param.size());\n      KJ_IF_SOME(v, value) {\n        stripLeadingAndTrailingSpace(v);\n      }\n    } else {\n      key = kj::mv(param);\n    }\n\n    result[count].key = kj::mv(key);\n    result[count].val = kj::mv(value);\n    ++count;\n  }\n  return kj::mv(result);\n}\n\nstruct ParamType {\n  enum { CLIENT, SERVER } side;\n  enum { NO_CONTEXT_TAKEOVER, MAX_WINDOW_BITS } property;\n};\n\ninline kj::Maybe<ParamType> parseKeyName(kj::ArrayPtr<const char>& key) {\n  // Returns a `ParamType` struct if the `key` is valid and kj::none if invalid.\n\n  if (key == \"client_no_context_takeover\"_kj) {\n    return ParamType { ParamType::CLIENT, ParamType::NO_CONTEXT_TAKEOVER };\n  } else if (key == \"server_no_context_takeover\"_kj) {\n    return ParamType { ParamType::SERVER, ParamType::NO_CONTEXT_TAKEOVER };\n  } else if (key == \"client_max_window_bits\"_kj) {\n    return ParamType { ParamType::CLIENT, ParamType::MAX_WINDOW_BITS };\n  } else if (key == \"server_max_window_bits\"_kj) {\n    return ParamType { ParamType::SERVER, ParamType::MAX_WINDOW_BITS };\n  }\n  return kj::none;\n}\n\nkj::Maybe<UnverifiedConfig> populateUnverifiedConfig(kj::Array<KeyMaybeVal>& params) {\n  // Given a collection of <key, MaybeValue> pairs, attempt to populate an `UnverifiedConfig` struct.\n  // If the struct cannot be populated, we return null.\n  //\n  // This function populates the struct with what it finds, it does not perform bounds checking or\n  // concern itself with valid `Value`s (so long as the `Value` is non-empty).\n  //\n  // The following issues would prevent a struct from being populated:\n  //  Key issues:\n  //    - `Key` is invalid (see `parseKeyName()`).\n  //    - `Key` is repeated.\n  //  Value issues:\n  //    - Got a `Value` when none was expected (only the `max_window_bits` parameters expect values).\n  //    - Got an empty `Value` (0 characters, or all whitespace characters).\n\n  if (params.size() > 4) {\n    // We expect 4 `Key`s at most, having more implies repeats/invalid keys are present.\n    return kj::none;\n  }\n\n  UnverifiedConfig config;\n\n  for (auto& param : params) {\n    KJ_IF_SOME(paramType, parseKeyName(param.key)) {\n      // `Key` is valid, but we still want to check for repeats.\n      const auto& side = paramType.side;\n      const auto& property = paramType.property;\n\n      if (property == ParamType::NO_CONTEXT_TAKEOVER) {\n        auto& takeOverSetting = (side == ParamType::CLIENT) ?\n            config.clientNoContextTakeover : config.serverNoContextTakeover;\n\n        if (takeOverSetting == true) {\n          // This `Key` is a repeat; invalid config.\n          return kj::none;\n        }\n\n        if (param.val != kj::none) {\n          // The `x_no_context_takeover` parameter shouldn't have a value; invalid config.\n          return kj::none;\n        }\n\n        takeOverSetting = true;\n      } else if (property == ParamType::MAX_WINDOW_BITS) {\n        auto& maxBitsSetting =\n            (side == ParamType::CLIENT) ? config.clientMaxWindowBits : config.serverMaxWindowBits;\n\n        if (maxBitsSetting != kj::none) {\n          // This `Key` is a repeat; invalid config.\n          return kj::none;\n        }\n\n        KJ_IF_SOME(value, param.val) {\n          if (value.size() == 0) {\n            // This is equivalent to `x_max_window_bits=`, since we got an \"=\" we expected a token\n            // to follow.\n            return kj::none;\n          }\n          maxBitsSetting = param.val;\n        } else {\n          // We know we got this `max_window_bits` parameter in a Request/Response, and we also know\n          // that it didn't include an \"=\" (otherwise the value wouldn't be null).\n          // It's important to retain the information that the parameter was received *without* a\n          // corresponding value, as this may determine whether the offer is valid or not.\n          //\n          // To retain this information, we'll set `maxBitsSetting` to be an empty ArrayPtr so this\n          // can be dealt with properly later.\n          maxBitsSetting = ArrayPtr<const char>();\n        }\n      }\n    } else {\n      // Invalid parameter.\n      return kj::none;\n    }\n  }\n  return kj::mv(config);\n}\n\nkj::Maybe<CompressionParameters> validateCompressionConfig(UnverifiedConfig&& config,\n    bool isAgreement) {\n  // Verifies that the `config` is valid depending on whether we're validating a Request (offer) or\n  // a Response (agreement). This essentially consumes the `UnverifiedConfig` and converts it into a\n  // `CompressionParameters` struct.\n  CompressionParameters result;\n\n  KJ_IF_SOME(serverBits, config.serverMaxWindowBits) {\n    if (serverBits.size() == 0) {\n      // This means `server_max_window_bits` was passed without a value. Since a value is required,\n      // this config is invalid.\n      return kj::none;\n    } else {\n      KJ_IF_SOME(bits, kj::str(serverBits).tryParseAs<size_t>()) {\n        if (bits < 8 || 15 < bits) {\n          // Out of range -- invalid.\n          return kj::none;\n        }\n        if (isAgreement) {\n          result.inboundMaxWindowBits = bits;\n        } else {\n          result.outboundMaxWindowBits = bits;\n        }\n      } else {\n        // Invalid ABNF, expected 1*DIGIT.\n        return kj::none;\n      }\n    }\n  }\n\n  KJ_IF_SOME(clientBits, config.clientMaxWindowBits) {\n    if (clientBits.size() == 0) {\n      if (!isAgreement) {\n        // `client_max_window_bits` does not need to have a value in an offer, let's set it to 15\n        // to get the best level of compression.\n        result.inboundMaxWindowBits = 15;\n      } else {\n        // `client_max_window_bits` must have a value in a Response.\n        return kj::none;\n      }\n    } else {\n      KJ_IF_SOME(bits, kj::str(clientBits).tryParseAs<size_t>()) {\n        if (bits < 8 || 15 < bits) {\n          // Out of range -- invalid.\n          return kj::none;\n        }\n        if (isAgreement) {\n          result.outboundMaxWindowBits = bits;\n        } else {\n          result.inboundMaxWindowBits = bits;\n        }\n      } else {\n        // Invalid ABNF, expected 1*DIGIT.\n        return kj::none;\n      }\n    }\n  }\n\n  if (isAgreement) {\n    result.outboundNoContextTakeover = config.clientNoContextTakeover;\n    result.inboundNoContextTakeover = config.serverNoContextTakeover;\n  } else {\n    result.inboundNoContextTakeover = config.clientNoContextTakeover;\n    result.outboundNoContextTakeover = config.serverNoContextTakeover;\n  }\n  return kj::mv(result);\n}\n\ninline kj::Maybe<CompressionParameters> tryExtractParameters(\n    kj::Vector<kj::ArrayPtr<const char>>& configuration,\n    bool isAgreement) {\n  // If the `configuration` is structured correctly and has no invalid parameters/values, we will\n  // return a populated `CompressionParameters` struct.\n  if (configuration.size() == 1) {\n    // Plain `permessage-deflate`.\n    return CompressionParameters{};\n  }\n  auto params = configuration.slice(1, configuration.size());\n  auto keyMaybeValuePairs = toKeysAndVals(params);\n  // Parse parameter strings into parameter[=value] pairs.\n  auto maybeUnverified = populateUnverifiedConfig(keyMaybeValuePairs);\n  KJ_IF_SOME(unverified, maybeUnverified) {\n    // Parsing succeeded, i.e. the parameter (`key`) names are valid and we don't have\n    // values for `x_no_context_takeover` parameters (the configuration is structured correctly).\n    // All that's left is to check the `x_max_window_bits` values (if any are present).\n    KJ_IF_SOME(validConfig, validateCompressionConfig(kj::mv(unverified), isAgreement)) {\n      return kj::mv(validConfig);\n    }\n  }\n  return kj::none;\n}\n\nkj::Vector<CompressionParameters> findValidExtensionOffers(StringPtr offers) {\n  // A function to be called by the client that wants to offer extensions through\n  // `Sec-WebSocket-Extensions`. This function takes the value of the header (a string) and\n  // populates a Vector of all the valid offers.\n  kj::Vector<CompressionParameters> result;\n\n  auto extensions = splitParts(offers, ',');\n\n  for (const auto& offer : extensions) {\n    auto splitOffer = splitParts(offer, ';');\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      continue;\n    }\n    KJ_IF_SOME(validated, tryExtractParameters(splitOffer, false)) {\n      // We need to swap the inbound/outbound properties since `tryExtractParameters` thinks we're\n      // parsing as the server (`isAgreement` is false).\n      auto tempCtx = validated.inboundNoContextTakeover;\n      validated.inboundNoContextTakeover = validated.outboundNoContextTakeover;\n      validated.outboundNoContextTakeover = tempCtx;\n      auto tempWindow = validated.inboundMaxWindowBits;\n      validated.inboundMaxWindowBits = validated.outboundMaxWindowBits;\n      validated.outboundMaxWindowBits = tempWindow;\n      result.add(kj::mv(validated));\n    }\n  }\n\n  return kj::mv(result);\n}\n\nkj::String generateExtensionRequest(const ArrayPtr<CompressionParameters>& extensions) {\n  // Build the `Sec-WebSocket-Extensions` request from the validated parameters.\n  constexpr auto EXT = \"permessage-deflate\"_kj;\n  auto offers = kj::heapArray<String>(extensions.size());\n  size_t i = 0;\n  for (const auto& offer : extensions) {\n    offers[i] = kj::str(EXT);\n    if (offer.outboundNoContextTakeover) {\n      offers[i] = kj::str(offers[i], \"; client_no_context_takeover\");\n    }\n    if (offer.inboundNoContextTakeover) {\n      offers[i] = kj::str(offers[i], \"; server_no_context_takeover\");\n    }\n    if (offer.outboundMaxWindowBits != kj::none) {\n      auto w = KJ_ASSERT_NONNULL(offer.outboundMaxWindowBits);\n      offers[i] = kj::str(offers[i], \"; client_max_window_bits=\", w);\n    }\n    if (offer.inboundMaxWindowBits != kj::none) {\n      auto w = KJ_ASSERT_NONNULL(offer.inboundMaxWindowBits);\n      offers[i] = kj::str(offers[i], \"; server_max_window_bits=\", w);\n    }\n    ++i;\n  }\n  return kj::strArray(offers, \", \");\n}\n\nkj::Maybe<CompressionParameters> tryParseExtensionOffers(StringPtr offers) {\n  // Given a string of offers, accept the first valid offer by returning a `CompressionParameters`\n  // struct. If there are no valid offers, return `kj::none`.\n  auto splitOffers = splitParts(offers, ',');\n\n  for (const auto& offer : splitOffers) {\n    auto splitOffer = splitParts(offer, ';');\n\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      // Extension token was invalid.\n      continue;\n    }\n    KJ_IF_SOME(config, tryExtractParameters(splitOffer, false)) {\n      return kj::mv(config);\n    }\n  }\n  return kj::none;\n}\n\nkj::Maybe<CompressionParameters> tryParseAllExtensionOffers(StringPtr offers,\n    CompressionParameters manualConfig) {\n  // Similar to `tryParseExtensionOffers()`, however, this function is called when parsing in\n  // `MANUAL_COMPRESSION` mode. In some cases, the server's configuration might not support the\n  // `server_no_context_takeover` or `server_max_window_bits` parameters. Essentially, this function\n  // will look at all the client's offers, and accept the first one that it can support.\n  //\n  // We differentiate these functions because in `AUTOMATIC_COMPRESSION` mode, KJ can support these\n  // server restricting compression parameters.\n  auto splitOffers = splitParts(offers, ',');\n\n  for (const auto& offer : splitOffers) {\n    auto splitOffer = splitParts(offer, ';');\n\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      // Extension token was invalid.\n      continue;\n    }\n    KJ_IF_SOME(config, tryExtractParameters(splitOffer, false)) {\n      KJ_IF_SOME(finalConfig, compareClientAndServerConfigs(config, manualConfig)) {\n        // Found a compatible configuration between the server's config and client's offer.\n        return kj::mv(finalConfig);\n      }\n    }\n  }\n  return kj::none;\n}\n\nkj::Maybe<CompressionParameters> compareClientAndServerConfigs(CompressionParameters requestConfig,\n    CompressionParameters manualConfig) {\n  // We start from the `manualConfig` and go through a series of filters to get a compression\n  // configuration that both the client and the server can agree upon. If no agreement can be made,\n  // we return null.\n\n  CompressionParameters acceptedParameters = manualConfig;\n\n  // We only need to modify `client_no_context_takeover` and `server_no_context_takeover` when\n  // `manualConfig` doesn't include them.\n  if (manualConfig.inboundNoContextTakeover == false) {\n    acceptedParameters.inboundNoContextTakeover = false;\n  }\n\n  if (manualConfig.outboundNoContextTakeover == false) {\n    acceptedParameters.outboundNoContextTakeover = false;\n    if (requestConfig.outboundNoContextTakeover == true) {\n      // The client has told the server to not use context takeover. This is not a \"hint\",\n      // rather it is a restriction on the server's configuration. If the server does not support\n      // the configuration, it must reject the offer.\n      return kj::none;\n    }\n  }\n\n  // client_max_window_bits\n  if (requestConfig.inboundMaxWindowBits != kj::none &&\n      manualConfig.inboundMaxWindowBits != kj::none)  {\n    // We want `min(requestConfig, manualConfig)` in this case.\n    auto reqBits = KJ_ASSERT_NONNULL(requestConfig.inboundMaxWindowBits);\n    auto manualBits = KJ_ASSERT_NONNULL(manualConfig.inboundMaxWindowBits);\n    if (reqBits < manualBits) {\n      acceptedParameters.inboundMaxWindowBits = reqBits;\n    }\n  } else {\n    // We will not reply with `client_max_window_bits`.\n    acceptedParameters.inboundMaxWindowBits = kj::none;\n  }\n\n  // server_max_window_bits\n  if (manualConfig.outboundMaxWindowBits != kj::none) {\n    auto manualBits = KJ_ASSERT_NONNULL(manualConfig.outboundMaxWindowBits);\n    if (requestConfig.outboundMaxWindowBits != kj::none) {\n      // We want `min(requestConfig, manualConfig)` in this case.\n      auto reqBits = KJ_ASSERT_NONNULL(requestConfig.outboundMaxWindowBits);\n      if (reqBits < manualBits) {\n        acceptedParameters.outboundMaxWindowBits = reqBits;\n      }\n    }\n  } else {\n    acceptedParameters.outboundMaxWindowBits = kj::none;\n    if (requestConfig.outboundMaxWindowBits != kj::none) {\n      // The client has told the server to use `server_max_window_bits`. This is not a \"hint\",\n      // rather it is a restriction on the server's configuration. If the server does not support\n      // the configuration, it must reject the offer.\n      return kj::none;\n    }\n  }\n  return acceptedParameters;\n}\n\nkj::String generateExtensionResponse(const CompressionParameters& parameters) {\n  // Build the `Sec-WebSocket-Extensions` response from the agreed parameters.\n  kj::String response = kj::str(\"permessage-deflate\");\n  if (parameters.inboundNoContextTakeover) {\n    response = kj::str(response, \"; client_no_context_takeover\");\n  }\n  if (parameters.outboundNoContextTakeover) {\n    response = kj::str(response, \"; server_no_context_takeover\");\n  }\n  if (parameters.inboundMaxWindowBits != kj::none) {\n    auto w = KJ_REQUIRE_NONNULL(parameters.inboundMaxWindowBits);\n    response = kj::str(response, \"; client_max_window_bits=\", w);\n  }\n  if (parameters.outboundMaxWindowBits != kj::none) {\n    auto w = KJ_REQUIRE_NONNULL(parameters.outboundMaxWindowBits);\n    response = kj::str(response, \"; server_max_window_bits=\", w);\n  }\n  return kj::mv(response);\n}\n\nkj::OneOf<CompressionParameters, kj::Exception> tryParseExtensionAgreement(\n    const Maybe<CompressionParameters>& clientOffer,\n    StringPtr agreedParameters) {\n  // Like `tryParseExtensionOffers`, but called by the client when parsing the server's Response.\n  // If the client must decline the agreement, we want to provide some details about what went wrong\n  // (since the client has to fail the connection).\n  constexpr auto FAILURE = \"Server failed WebSocket handshake: \"_kj;\n  auto e = KJ_EXCEPTION(FAILED);\n\n  if (clientOffer == kj::none) {\n    // We've received extensions when we did not send any in the first place.\n    e.setDescription(\n        kj::str(FAILURE, \"added Sec-WebSocket-Extensions when client did not offer any.\"));\n    return kj::mv(e);\n  }\n\n  auto offers = splitParts(agreedParameters, ',');\n  if (offers.size() != 1) {\n    constexpr auto EXPECT = \"expected exactly one extension (permessage-deflate) but received \"\n                            \"more than one.\"_kj;\n    e.setDescription(kj::str(FAILURE, EXPECT));\n    return kj::mv(e);\n  }\n  auto splitOffer = splitParts(offers.front(), ';');\n\n  if (splitOffer.front() != \"permessage-deflate\"_kj) {\n    e.setDescription(kj::str(FAILURE, \"response included a Sec-WebSocket-Extensions value that was \"\n                                      \"not permessage-deflate.\"));\n    return kj::mv(e);\n  }\n\n  // Verify the parameters of our single extension, and compare it with the clients original offer.\n  KJ_IF_SOME(config, tryExtractParameters(splitOffer, true)) {\n    const auto& client = KJ_ASSERT_NONNULL(clientOffer);\n    // The server might have ignored the client's hints regarding its compressor's configuration.\n    // That's fine, but as the client, we still want to use those outbound compression parameters.\n    if (config.outboundMaxWindowBits == kj::none) {\n      config.outboundMaxWindowBits = client.outboundMaxWindowBits;\n    } else KJ_IF_SOME(value, client.outboundMaxWindowBits) {\n      if (value < KJ_ASSERT_NONNULL(config.outboundMaxWindowBits)) {\n        // If the client asked for a value smaller than what the server responded with, use the\n        // value that the client originally specified.\n        config.outboundMaxWindowBits = value;\n      }\n    }\n    if (config.outboundNoContextTakeover == false) {\n      config.outboundNoContextTakeover = client.outboundNoContextTakeover;\n    }\n    return kj::mv(config);\n  }\n\n  // There was a problem parsing the server's `Sec-WebSocket-Extensions` response.\n  e.setDescription(kj::str(FAILURE, \"the Sec-WebSocket-Extensions header in the Response included \"\n      \"an invalid value.\"));\n  return kj::mv(e);\n}\n} // namespace _ (private)\nnamespace {\nclass NullInputStream final: public kj::AsyncInputStream {\npublic:\n  NullInputStream(kj::Maybe<size_t> expectedLength = size_t(0))\n      : expectedLength(expectedLength) {}\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return expectedLength;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount) override {\n    return constPromise<uint64_t, 0>();\n  }\n\nprivate:\n  kj::Maybe<size_t> expectedLength;\n};\n\nclass NullOutputStream final: public kj::AsyncOutputStream {\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n\n  // We can't really optimize tryPumpFrom() unless AsyncInputStream grows a skip() method.\n};\n\nclass NullIoStream final: public kj::AsyncIoStream {\npublic:\n  void shutdownWrite() override {}\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return kj::Maybe<uint64_t>((uint64_t)0);\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount) override {\n    return constPromise<uint64_t, 0>();\n  }\n};\n\nclass HttpClientImpl final: public HttpClient,\n                            private HttpClientErrorHandler {\npublic:\n  HttpClientImpl(const HttpHeaderTable& responseHeaderTable, kj::Own<kj::AsyncIoStream> rawStream,\n                 HttpClientSettings settings)\n      : httpInput(*rawStream, responseHeaderTable),\n        httpOutput(*rawStream),\n        ownStream(kj::mv(rawStream)),\n        settings(kj::mv(settings)) {}\n\n  bool canReuse() {\n    // Returns true if we can immediately reuse this HttpClient for another message (so all\n    // previous messages have been fully read).\n\n    return !upgraded && !closed && httpInput.canReuse() && httpOutput.canReuse();\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    KJ_REQUIRE(httpOutput.canReuse(),\n        \"can't start new request until previous request body has been fully written\");\n    closeWatcherTask = kj::none;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n    kj::String lengthStr;\n\n    bool isGet = method == HttpMethod::GET || method == HttpMethod::HEAD;\n    bool hasBody;\n\n    KJ_IF_SOME(s, expectedBodySize) {\n      if (isGet && s == 0) {\n        // GET with empty body; don't send any Content-Length.\n        hasBody = false;\n      } else {\n        lengthStr = kj::str(s);\n        connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = lengthStr;\n        hasBody = true;\n      }\n    } else {\n      if (isGet && headers.get(HttpHeaderId::TRANSFER_ENCODING) == kj::none) {\n        // GET with empty body; don't send any Transfer-Encoding.\n        hasBody = false;\n      } else {\n        // HACK: Normally GET requests shouldn't have bodies. But, if the caller set a\n        //   Transfer-Encoding header on a GET, we use this as a special signal that it might\n        //   actually want to send a body. This allows pass-through of a GET request with a chunked\n        //   body to \"just work\". We strongly discourage writing any new code that sends\n        //   full-bodied GETs.\n        connectionHeaders[HttpHeaders::BuiltinIndices::TRANSFER_ENCODING] = \"chunked\";\n        hasBody = true;\n      }\n    }\n\n    httpOutput.writeHeaders(headers.serializeRequest(method, url, connectionHeaders));\n\n    kj::Own<kj::AsyncOutputStream> bodyStream;\n    if (!hasBody) {\n      // No entity-body.\n      httpOutput.finishBody();\n      bodyStream = heap<HttpNullEntityWriter>();\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      bodyStream = heap<HttpFixedLengthEntityWriter>(httpOutput, s);\n    } else {\n      bodyStream = heap<HttpChunkedEntityWriter>(httpOutput);\n    }\n\n    auto id = ++counter;\n\n    auto responsePromise = httpInput.readResponseHeaders().then(\n        [this,method,id](HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError)\n            -> HttpClient::Response {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          HttpClient::Response result {\n            response.statusCode,\n            response.statusText,\n            &responseHeaders,\n            httpInput.getEntityBody(\n                HttpInputStreamImpl::RESPONSE, method, response.statusCode, responseHeaders)\n          };\n\n          if (fastCaseCmp<'c', 'l', 'o', 's', 'e'>(\n              responseHeaders.get(HttpHeaderId::CONNECTION).orDefault(nullptr).cStr())) {\n            closed = true;\n          } else if (counter == id) {\n            watchForClose();\n          } else {\n            // Another request was already queued after this one, so we don't want to watch for\n            // stream closure because we're fully expecting another response.\n          }\n          return result;\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          closed = true;\n          return settings.errorHandler.orDefault(*this).handleProtocolError(\n              kj::mv(protocolError));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n\n    return { kj::mv(bodyStream), kj::mv(responsePromise) };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    closeWatcherTask = kj::none;\n\n    // Mark upgraded for now, even though the upgrade could fail, because we can't allow pipelined\n    // requests in the meantime.\n    upgraded = true;\n\n    byte keyBytes[16];\n    KJ_ASSERT_NONNULL(settings.entropySource,\n        \"can't use openWebSocket() because no EntropySource was provided when creating the \"\n        \"HttpClient\").generate(keyBytes);\n    auto keyBase64 = kj::encodeBase64(keyBytes);\n\n    kj::StringPtr connectionHeaders[HttpHeaders::WEBSOCKET_CONNECTION_HEADERS_COUNT];\n    connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"Upgrade\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::UPGRADE] = \"websocket\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_VERSION] = \"13\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_KEY] = keyBase64;\n\n    kj::Maybe<kj::String> offeredExtensions;\n    kj::Maybe<CompressionParameters> clientOffer;\n    kj::Vector<CompressionParameters> extensions;\n    auto compressionMode = settings.webSocketCompressionMode;\n\n    if (compressionMode == HttpClientSettings::MANUAL_COMPRESSION) {\n      KJ_IF_SOME(value, headers.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // Strip all `Sec-WebSocket-Extensions` except for `permessage-deflate`.\n        extensions = _::findValidExtensionOffers(value);\n      }\n    } else if (compressionMode == HttpClientSettings::AUTOMATIC_COMPRESSION) {\n      // If AUTOMATIC_COMPRESSION is enabled, we send `Sec-WebSocket-Extensions: permessage-deflate`\n      // to the server and ignore the `headers` provided by the caller.\n      extensions.add(CompressionParameters());\n    }\n\n    if (extensions.size() > 0) {\n      clientOffer = extensions.front();\n      // We hold on to a copy of the client's most preferred offer so even if the server\n      // ignores `client_no_context_takeover` or `client_max_window_bits`, we can still refer to\n      // the original offer made by the client (thereby allowing the client to use these parameters).\n      //\n      // It's safe to ignore the remaining offers because:\n      //  1. Offers are ordered by preference.\n      //  2. `client_x` parameters are hints to the server and do not result in rejections, so the\n      //     client is likely to put them in every offer anyways.\n      connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_EXTENSIONS] =\n          offeredExtensions.emplace(_::generateExtensionRequest(extensions.asPtr()));\n    }\n\n    httpOutput.writeHeaders(headers.serializeRequest(HttpMethod::GET, url, connectionHeaders));\n\n    // No entity-body.\n    httpOutput.finishBody();\n\n    auto id = ++counter;\n\n    return httpInput.readResponseHeaders()\n        .then([this,id,keyBase64 = kj::mv(keyBase64),clientOffer = kj::mv(clientOffer)](\n            HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError)\n            -> HttpClient::WebSocketResponse {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          if (response.statusCode == 101) {\n            if (!fastCaseCmp<'w', 'e', 'b', 's', 'o', 'c', 'k', 'e', 't'>(\n                    responseHeaders.get(HttpHeaderId::UPGRADE).orDefault(nullptr).cStr())) {\n              kj::String ownMessage;\n              kj::StringPtr message;\n              KJ_IF_SOME(actual, responseHeaders.get(HttpHeaderId::UPGRADE)) {\n                ownMessage = kj::str(\n                    \"Server failed WebSocket handshake: incorrect Upgrade header: \"\n                    \"expected 'websocket', got '\", actual, \"'.\");\n                message = ownMessage;\n              } else {\n                message = \"Server failed WebSocket handshake: missing Upgrade header.\";\n              }\n              return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                502, \"Bad Gateway\", message, nullptr\n              });\n            }\n\n            auto expectedAccept = generateWebSocketAccept(keyBase64);\n            if (responseHeaders.get(HttpHeaderId::SEC_WEBSOCKET_ACCEPT).orDefault(nullptr)\n                  != expectedAccept) {\n              kj::String ownMessage;\n              kj::StringPtr message;\n              KJ_IF_SOME(actual, responseHeaders.get(HttpHeaderId::SEC_WEBSOCKET_ACCEPT)) {\n                ownMessage = kj::str(\n                    \"Server failed WebSocket handshake: incorrect Sec-WebSocket-Accept header: \"\n                    \"expected '\", expectedAccept, \"', got '\", actual, \"'.\");\n                message = ownMessage;\n              } else {\n                message = \"Server failed WebSocket handshake: missing Upgrade header.\";\n              }\n              return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                502, \"Bad Gateway\", message, nullptr\n              });\n            }\n\n            kj::Maybe<CompressionParameters> compressionParameters;\n            if (settings.webSocketCompressionMode != HttpClientSettings::NO_COMPRESSION) {\n              KJ_IF_SOME(agreedParameters, responseHeaders.get(\n                  HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n\n                auto parseResult = _::tryParseExtensionAgreement(clientOffer,\n                    agreedParameters);\n                if (parseResult.is<kj::Exception>()) {\n                  return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                    502, \"Bad Gateway\", parseResult.get<kj::Exception>().getDescription(), nullptr});\n                }\n                compressionParameters.emplace(kj::mv(parseResult.get<CompressionParameters>()));\n              }\n            }\n\n            return {\n              response.statusCode,\n              response.statusText,\n              &httpInput.getHeaders(),\n              upgradeToWebSocket(kj::mv(ownStream), httpInput, httpOutput, settings.entropySource,\n                  kj::mv(compressionParameters)),\n            };\n          } else {\n            upgraded = false;\n            HttpClient::WebSocketResponse result {\n              response.statusCode,\n              response.statusText,\n              &responseHeaders,\n              httpInput.getEntityBody(HttpInputStreamImpl::RESPONSE, HttpMethod::GET,\n                                      response.statusCode, responseHeaders)\n            };\n            if (fastCaseCmp<'c', 'l', 'o', 's', 'e'>(\n                responseHeaders.get(HttpHeaderId::CONNECTION).orDefault(nullptr).cStr())) {\n              closed = true;\n            } else if (counter == id) {\n              watchForClose();\n            } else {\n              // Another request was already queued after this one, so we don't want to watch for\n              // stream closure because we're fully expecting another response.\n            }\n            return result;\n          }\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError(\n              kj::mv(protocolError));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    KJ_REQUIRE(httpOutput.canReuse(),\n        \"can't start new request until previous request body has been fully written\");\n\n    if (settings.useTls) {\n      KJ_UNIMPLEMENTED(\"This HttpClient does not support TLS.\");\n    }\n\n    closeWatcherTask = kj::none;\n\n    // Mark upgraded for now even though the tunnel could fail, because we can't allow pipelined\n    // requests in the meantime.\n    upgraded = true;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n\n    httpOutput.writeHeaders(headers.serializeConnectRequest(host, connectionHeaders));\n\n    auto id = ++counter;\n\n    auto split = httpInput.readResponseHeaders().then(\n        [this, id](HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError) mutable\n            -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                         kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>>> {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          if (response.statusCode < 200 || response.statusCode >= 300) {\n            // Any statusCode that is not in the 2xx range in interpreted\n            // as an HTTP response. Any status code in the 2xx range is\n            // interpreted as a successful CONNECT response.\n            closed = true;\n            return kj::tuple(ConnectRequest::Status(\n              response.statusCode,\n              kj::str(response.statusText),\n              kj::heap(responseHeaders.clone()),\n              httpInput.getEntityBody(\n                  HttpInputStreamImpl::RESPONSE,\n                  HttpConnectMethod(),\n                  response.statusCode,\n                  responseHeaders)),\n              KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n          }\n          KJ_ASSERT(counter == id);\n          return kj::tuple(ConnectRequest::Status(\n            response.statusCode,\n            kj::str(response.statusText),\n            kj::heap(responseHeaders.clone())\n          ), kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(httpInput.releaseBuffer()));\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          closed = true;\n          auto response = handleProtocolError(protocolError);\n          return kj::tuple(ConnectRequest::Status(\n            response.statusCode,\n            kj::str(response.statusText),\n            kj::heap(response.headers->clone()),\n            kj::mv(response.body)\n          ), KJ_EXCEPTION(DISCONNECTED, \"the connect request errored\"));\n        }\n      }\n      KJ_UNREACHABLE;\n    }).split();\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),  // Promise for the result\n      heap<AsyncIoStreamWithGuards>(\n          kj::mv(ownStream),\n          kj::mv(kj::get<1>(split)) /* read guard (Promise for the ReleasedBuffer) */,\n          httpOutput.flush() /* write guard (void Promise) */)\n    };\n  }\n\nprivate:\n  HttpInputStreamImpl httpInput;\n  HttpOutputStream httpOutput;\n  kj::Own<AsyncIoStream> ownStream;\n  HttpClientSettings settings;\n  kj::Maybe<kj::Promise<void>> closeWatcherTask;\n  bool upgraded = false;\n  bool closed = false;\n\n  uint counter = 0;\n  // Counts requests for the sole purpose of detecting if more requests have been made after some\n  // point in history.\n\n  void watchForClose() {\n    closeWatcherTask = httpInput.awaitNextMessage()\n        .then([this](bool hasData) -> kj::Promise<void> {\n      if (hasData) {\n        // Uhh... The server sent some data before we asked for anything. Perhaps due to properties\n        // of this application, the server somehow already knows what the next request will be, and\n        // it is trying to optimize. Or maybe this is some sort of test and the server is just\n        // replaying a script. In any case, we will humor it -- leave the data in the buffer and\n        // let it become the response to the next request.\n        return kj::READY_NOW;\n      } else {\n        // EOF -- server disconnected.\n        closed = true;\n        if (httpOutput.isInBody()) {\n          // Huh, the application is still sending a request. We should let it finish. We do not\n          // need to proactively free the socket in this case because we know that we're not\n          // sitting in a reusable connection pool, because we know the application is still\n          // actively using the connection.\n          return kj::READY_NOW;\n        } else {\n          return httpOutput.flush().then([this]() {\n            // We might be sitting in NetworkAddressHttpClient's `availableClients` pool. We don't\n            // have a way to notify it to remove this client from the pool; instead, when it tries\n            // to pull this client from the pool later, it will notice the client is dead and will\n            // discard it then. But, we would like to avoid holding on to a socket forever. So,\n            // destroy the socket now.\n            // TODO(cleanup): Maybe we should arrange to proactively remove ourselves? Seems\n            //   like the code will be awkward.\n            ownStream = nullptr;\n          });\n        }\n      }\n    }).eagerlyEvaluate(nullptr);\n  }\n};\n\n}  // namespace\n\nkj::Promise<HttpClient::WebSocketResponse> HttpClient::openWebSocket(\n    kj::StringPtr url, const HttpHeaders& headers) {\n  return request(HttpMethod::GET, url, headers, kj::none)\n      .response.then([](HttpClient::Response&& response) -> WebSocketResponse {\n    kj::OneOf<kj::Own<kj::AsyncInputStream>, kj::Own<WebSocket>> body;\n    body.init<kj::Own<kj::AsyncInputStream>>(kj::mv(response.body));\n\n    return {\n      response.statusCode,\n      response.statusText,\n      response.headers,\n      kj::mv(body)\n    };\n  });\n}\n\nHttpClient::ConnectRequest HttpClient::connect(\n    kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) {\n  KJ_UNIMPLEMENTED(\"CONNECT is not implemented by this HttpClient\");\n}\n\nkj::Own<HttpClient> newHttpClient(\n    const HttpHeaderTable& responseHeaderTable, kj::AsyncIoStream& stream,\n    HttpClientSettings settings) {\n  return kj::heap<HttpClientImpl>(responseHeaderTable,\n      kj::Own<kj::AsyncIoStream>(&stream, kj::NullDisposer::instance),\n      kj::mv(settings));\n}\n\nHttpClient::Response HttpClientErrorHandler::handleProtocolError(\n      HttpHeaders::ProtocolError protocolError) {\n  KJ_FAIL_REQUIRE(protocolError.description) { break; }\n  return HttpClient::Response();\n}\n\nHttpClient::WebSocketResponse HttpClientErrorHandler::handleWebSocketProtocolError(\n      HttpHeaders::ProtocolError protocolError) {\n  auto response = handleProtocolError(protocolError);\n  return HttpClient::WebSocketResponse {\n    response.statusCode, response.statusText, response.headers, kj::mv(response.body)\n  };\n}\n\nkj::Exception WebSocketErrorHandler::handleWebSocketProtocolError(\n      WebSocket::ProtocolError protocolError) {\n  return KJ_EXCEPTION(FAILED, \"WebSocket protocol error\", protocolError.statusCode, protocolError.description);\n}\n\nclass PausableReadAsyncIoStream::PausableRead {\npublic:\n  PausableRead(\n      kj::PromiseFulfiller<size_t>& fulfiller, PausableReadAsyncIoStream& parent,\n      void* buffer, size_t minBytes, size_t maxBytes)\n      : fulfiller(fulfiller), parent(parent),\n        operationBuffer(buffer), operationMinBytes(minBytes), operationMaxBytes(maxBytes),\n        innerRead(parent.tryReadImpl(operationBuffer, operationMinBytes, operationMaxBytes).then(\n            [&fulfiller](size_t size) mutable -> kj::Promise<void> {\n          fulfiller.fulfill(kj::mv(size));\n          return kj::READY_NOW;\n        }, [&fulfiller](kj::Exception&& err) {\n          fulfiller.reject(kj::mv(err));\n        })) {\n    KJ_ASSERT(parent.maybePausableRead == kj::none);\n    parent.maybePausableRead = *this;\n  }\n\n  ~PausableRead() noexcept(false) {\n    parent.maybePausableRead = kj::none;\n  }\n\n  void pause() {\n    innerRead = nullptr;\n  }\n\n  void unpause() {\n    innerRead = parent.tryReadImpl(operationBuffer, operationMinBytes, operationMaxBytes).then(\n        [this](size_t size) -> kj::Promise<void> {\n      fulfiller.fulfill(kj::mv(size));\n      return kj::READY_NOW;\n    }, [this](kj::Exception&& err) {\n      fulfiller.reject(kj::mv(err));\n    });\n  }\n\n  void reject(kj::Exception&& exc) {\n    fulfiller.reject(kj::mv(exc));\n  }\nprivate:\n  kj::PromiseFulfiller<size_t>& fulfiller;\n  PausableReadAsyncIoStream& parent;\n\n  void* operationBuffer;\n  size_t operationMinBytes;\n  size_t operationMaxBytes;\n  // The parameters of the current tryRead call. Used to unpause a paused read.\n\n  kj::Promise<void> innerRead;\n  // The current pending read.\n};\n\n_::Deferred<kj::Function<void()>> PausableReadAsyncIoStream::trackRead() {\n  KJ_REQUIRE(!currentlyReading, \"only one read is allowed at any one time\");\n  currentlyReading = true;\n  return kj::defer<kj::Function<void()>>([this]() { currentlyReading = false; });\n}\n\n_::Deferred<kj::Function<void()>> PausableReadAsyncIoStream::trackWrite() {\n  KJ_REQUIRE(!currentlyWriting, \"only one write is allowed at any one time\");\n  currentlyWriting = true;\n  return kj::defer<kj::Function<void()>>([this]() { currentlyWriting = false; });\n}\n\nkj::Promise<size_t> PausableReadAsyncIoStream::tryRead(\n    void* buffer, size_t minBytes, size_t maxBytes) {\n  return kj::newAdaptedPromise<size_t, PausableRead>(*this, buffer, minBytes, maxBytes);\n}\n\nkj::Promise<size_t> PausableReadAsyncIoStream::tryReadImpl(\n    void* buffer, size_t minBytes, size_t maxBytes) {\n  // Hack: evalNow used here because `newAdaptedPromise` has a bug. We may need to change\n  // `PromiseDisposer::alloc` to not be `noexcept` but in order to do so we'll need to benchmark\n  // its performance.\n  return kj::evalNow([&]() -> kj::Promise<size_t> {\n    return inner->tryRead(buffer, minBytes, maxBytes).attach(trackRead());\n  });\n}\n\nkj::Maybe<uint64_t> PausableReadAsyncIoStream::tryGetLength() {\n  return inner->tryGetLength();\n}\n\nkj::Promise<uint64_t> PausableReadAsyncIoStream::pumpTo(\n    kj::AsyncOutputStream& output, uint64_t amount) {\n  return kj::unoptimizedPumpTo(*this, output, amount);\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::write(const void* buffer, size_t size) {\n  return inner->write(buffer, size).attach(trackWrite());\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::write(\n    kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) {\n  return inner->write(pieces).attach(trackWrite());\n}\n\nkj::Maybe<kj::Promise<uint64_t>> PausableReadAsyncIoStream::tryPumpFrom(\n    kj::AsyncInputStream& input, uint64_t amount) {\n  auto result = inner->tryPumpFrom(input, amount);\n  KJ_IF_SOME(r, result) {\n    return r.attach(trackWrite());\n  } else {\n    return kj::none;\n  }\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::whenWriteDisconnected() {\n  return inner->whenWriteDisconnected();\n}\n\nvoid PausableReadAsyncIoStream::shutdownWrite() {\n  inner->shutdownWrite();\n}\n\nvoid PausableReadAsyncIoStream::abortRead() {\n  inner->abortRead();\n}\n\nkj::Maybe<int> PausableReadAsyncIoStream::getFd() const {\n  return inner->getFd();\n}\n\nvoid PausableReadAsyncIoStream::pause() {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.pause();\n  }\n}\n\nvoid PausableReadAsyncIoStream::unpause() {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.unpause();\n  }\n}\n\nbool PausableReadAsyncIoStream::getCurrentlyReading() {\n  return currentlyReading;\n}\n\nbool PausableReadAsyncIoStream::getCurrentlyWriting() {\n  return currentlyWriting;\n}\n\nkj::Own<kj::AsyncIoStream> PausableReadAsyncIoStream::takeStream() {\n  return kj::mv(inner);\n}\n\nvoid PausableReadAsyncIoStream::replaceStream(kj::Own<kj::AsyncIoStream> stream) {\n  inner = kj::mv(stream);\n}\n\nvoid PausableReadAsyncIoStream::reject(kj::Exception&& exc) {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.reject(kj::mv(exc));\n  }\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass NetworkAddressHttpClient final: public HttpClient {\npublic:\n  NetworkAddressHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                           kj::Own<kj::NetworkAddress> address, HttpClientSettings settings)\n      : timer(timer),\n        responseHeaderTable(responseHeaderTable),\n        address(kj::mv(address)),\n        settings(kj::mv(settings)) {}\n\n  bool isDrained() {\n    // Returns true if there are no open connections.\n    return activeConnectionCount == 0 && availableClients.empty();\n  }\n\n  kj::Promise<void> onDrained() {\n    // Returns a promise which resolves the next time isDrained() transitions from false to true.\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    drainedFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    auto refcounted = getClient();\n    auto result = refcounted->client->request(method, url, headers, expectedBodySize);\n    result.body = result.body.attach(kj::addRef(*refcounted));\n    result.response = result.response.then(\n        [refcounted=kj::mv(refcounted)](Response&& response) mutable {\n      response.body = response.body.attach(kj::mv(refcounted));\n      return kj::mv(response);\n    });\n    return result;\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    auto refcounted = getClient();\n    auto result = refcounted->client->openWebSocket(url, headers);\n    return result.then(\n        [refcounted=kj::mv(refcounted)](WebSocketResponse&& response) mutable {\n      KJ_SWITCH_ONEOF(response.webSocketOrBody) {\n        KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n          response.webSocketOrBody = body.attach(kj::mv(refcounted));\n        }\n        KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n          // The only reason we need to attach the client to the WebSocket is because otherwise\n          // the response headers will be deleted prematurely. Otherwise, the WebSocket has taken\n          // ownership of the connection.\n          //\n          // TODO(perf): Maybe we could transfer ownership of the response headers specifically?\n          response.webSocketOrBody = ws.attach(kj::mv(refcounted));\n        }\n      }\n      return kj::mv(response);\n    });\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    auto refcounted = getClient();\n    auto request = refcounted->client->connect(host, headers, settings);\n    return ConnectRequest {\n      request.status.attach(kj::addRef(*refcounted)),\n      request.connection.attach(kj::mv(refcounted))\n    };\n  }\n\nprivate:\n  kj::Timer& timer;\n  const HttpHeaderTable& responseHeaderTable;\n  kj::Own<kj::NetworkAddress> address;\n  HttpClientSettings settings;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> drainedFulfiller;\n  uint activeConnectionCount = 0;\n\n  bool timeoutsScheduled = false;\n  kj::Promise<void> timeoutTask = nullptr;\n\n  struct AvailableClient {\n    kj::Own<HttpClientImpl> client;\n    kj::TimePoint expires;\n  };\n\n  std::deque<AvailableClient> availableClients;\n\n  struct RefcountedClient final: public kj::Refcounted {\n    RefcountedClient(NetworkAddressHttpClient& parent, kj::Own<HttpClientImpl> client)\n        : parent(parent), client(kj::mv(client)) {\n      ++parent.activeConnectionCount;\n    }\n    ~RefcountedClient() noexcept(false) {\n      --parent.activeConnectionCount;\n      KJ_IF_SOME(exception, kj::runCatchingExceptions([&]() {\n        parent.returnClientToAvailable(kj::mv(client));\n      })) {\n        KJ_LOG(ERROR, exception);\n      }\n    }\n\n    NetworkAddressHttpClient& parent;\n    kj::Own<HttpClientImpl> client;\n  };\n\n  kj::Own<RefcountedClient> getClient() {\n    for (;;) {\n      if (availableClients.empty()) {\n        auto stream = newPromisedStream(address->connect());\n        return kj::refcounted<RefcountedClient>(*this,\n          kj::heap<HttpClientImpl>(responseHeaderTable, kj::mv(stream), settings));\n      } else {\n        auto client = kj::mv(availableClients.back().client);\n        availableClients.pop_back();\n        if (client->canReuse()) {\n          return kj::refcounted<RefcountedClient>(*this, kj::mv(client));\n        }\n        // Whoops, this client's connection was closed by the server at some point. Discard.\n      }\n    }\n  }\n\n  void returnClientToAvailable(kj::Own<HttpClientImpl> client) {\n    // Only return the connection to the pool if it is reusable and if our settings indicate we\n    // should reuse connections.\n    if (client->canReuse() && settings.idleTimeout > 0 * kj::SECONDS) {\n      availableClients.push_back(AvailableClient {\n        kj::mv(client), timer.now() + settings.idleTimeout\n      });\n    }\n\n    // Call this either way because it also signals onDrained().\n    if (!timeoutsScheduled) {\n      timeoutsScheduled = true;\n      timeoutTask = applyTimeouts();\n    }\n  }\n\n  kj::Promise<void> applyTimeouts() {\n    if (availableClients.empty()) {\n      timeoutsScheduled = false;\n      if (activeConnectionCount == 0) {\n        KJ_IF_SOME(f, drainedFulfiller) {\n          f->fulfill();\n          drainedFulfiller = kj::none;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      auto time = availableClients.front().expires;\n      return timer.atTime(time).then([this,time]() {\n        while (!availableClients.empty() && availableClients.front().expires <= time) {\n          availableClients.pop_front();\n        }\n        return applyTimeouts();\n      });\n    }\n  }\n};\n\nclass TransitionaryAsyncIoStream final: public kj::AsyncIoStream {\n  // This specialised AsyncIoStream is used by NetworkHttpClient to support startTls.\npublic:\n  TransitionaryAsyncIoStream(kj::Own<kj::AsyncIoStream> unencryptedStream)\n      : inner(kj::heap<kj::PausableReadAsyncIoStream>(kj::mv(unencryptedStream))) {}\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return inner->tryRead(buffer, minBytes, maxBytes);\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return inner->tryGetLength();\n  }\n\n  kj::Promise<uint64_t> pumpTo(kj::AsyncOutputStream& output, uint64_t amount) override {\n    return inner->pumpTo(output, amount);\n  }\n\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n    return inner->write(buffer, size);\n  }\n\n  kj::Promise<void> write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n    return inner->write(pieces);\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(\n      kj::AsyncInputStream& input, uint64_t amount = kj::maxValue) override {\n    return inner->tryPumpFrom(input, amount);\n  }\n\n  kj::Promise<void> whenWriteDisconnected() override {\n    return inner->whenWriteDisconnected();\n  }\n\n  void shutdownWrite() override {\n    inner->shutdownWrite();\n  }\n\n  void abortRead() override {\n    inner->abortRead();\n  }\n\n  kj::Maybe<int> getFd() const override {\n    return inner->getFd();\n  }\n\n  void startTls(\n      kj::SecureNetworkWrapper* wrapper, kj::StringPtr expectedServerHostname) {\n    // Pause any potential pending reads.\n    inner->pause();\n\n    KJ_ON_SCOPE_FAILURE({\n      inner->reject(KJ_EXCEPTION(FAILED, \"StartTls failed.\"));\n    });\n\n    KJ_ASSERT(!inner->getCurrentlyReading() && !inner->getCurrentlyWriting(),\n        \"Cannot call startTls while reads/writes are outstanding\");\n    kj::Promise<kj::Own<kj::AsyncIoStream>> secureStream =\n        wrapper->wrapClient(inner->takeStream(), expectedServerHostname);\n    inner->replaceStream(kj::newPromisedStream(kj::mv(secureStream)));\n    // Resume any previous pending reads.\n    inner->unpause();\n  }\n\nprivate:\n  kj::Own<kj::PausableReadAsyncIoStream> inner;\n};\n\nclass PromiseNetworkAddressHttpClient final: public HttpClient {\n  // An HttpClient which waits for a promise to resolve then forwards all calls to the promised\n  // client.\n\npublic:\n  PromiseNetworkAddressHttpClient(kj::Promise<kj::Own<NetworkAddressHttpClient>> promise)\n      : promise(promise.then([this](kj::Own<NetworkAddressHttpClient>&& client) {\n          this->client = kj::mv(client);\n        }).fork()) {}\n\n  bool isDrained() {\n    KJ_IF_SOME(c, client) {\n      return c->isDrained();\n    } else {\n      return failed;\n    }\n  }\n\n  kj::Promise<void> onDrained() {\n    KJ_IF_SOME(c, client) {\n      return c->onDrained();\n    } else {\n      return promise.addBranch().then([this]() {\n        return KJ_ASSERT_NONNULL(client)->onDrained();\n      }, [this](kj::Exception&& e) {\n        // Connecting failed. Treat as immediately drained.\n        failed = true;\n        return kj::READY_NOW;\n      });\n    }\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    KJ_IF_SOME(c, client) {\n      return c->request(method, url, headers, expectedBodySize);\n    } else {\n      // This gets complicated since request() returns a pair of a stream and a promise.\n      auto urlCopy = kj::str(url);\n      auto headersCopy = headers.clone();\n      auto combined = promise.addBranch().then(\n          [this,method,expectedBodySize,url=kj::mv(urlCopy), headers=kj::mv(headersCopy)]()\n          -> kj::Tuple<kj::Own<kj::AsyncOutputStream>, kj::Promise<Response>> {\n        auto req = KJ_ASSERT_NONNULL(client)->request(method, url, headers, expectedBodySize);\n        return kj::tuple(kj::mv(req.body), kj::mv(req.response));\n      });\n\n      auto split = combined.split();\n      return {\n        newPromisedStream(kj::mv(kj::get<0>(split))),\n        kj::mv(kj::get<1>(split))\n      };\n    }\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    KJ_IF_SOME(c, client) {\n      return c->openWebSocket(url, headers);\n    } else {\n      auto urlCopy = kj::str(url);\n      auto headersCopy = headers.clone();\n      return promise.addBranch().then(\n          [this,url=kj::mv(urlCopy),headers=kj::mv(headersCopy)]() {\n        return KJ_ASSERT_NONNULL(client)->openWebSocket(url, headers);\n      });\n    }\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    KJ_IF_SOME(c, client) {\n      return c->connect(host, headers, settings);\n    } else {\n      auto split = promise.addBranch().then(\n          [this, host=kj::str(host), headers=headers.clone(), settings]() mutable\n          -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                       kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n        auto request = KJ_ASSERT_NONNULL(client)->connect(host, headers, kj::mv(settings));\n        return kj::tuple(kj::mv(request.status), kj::mv(request.connection));\n      }).split();\n\n      return ConnectRequest {\n        kj::mv(kj::get<0>(split)),\n        kj::newPromisedStream(kj::mv(kj::get<1>(split)))\n      };\n    }\n  }\n\nprivate:\n  kj::ForkedPromise<void> promise;\n  kj::Maybe<kj::Own<NetworkAddressHttpClient>> client;\n  bool failed = false;\n};\n\nclass NetworkHttpClient final: public HttpClient, private kj::TaskSet::ErrorHandler {\npublic:\n  NetworkHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                    kj::Network& network, kj::Maybe<kj::Network&> tlsNetwork,\n                    HttpClientSettings settings)\n      : timer(timer),\n        responseHeaderTable(responseHeaderTable),\n        network(network),\n        tlsNetwork(tlsNetwork),\n        settings(kj::mv(settings)),\n        tasks(*this) {}\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    // We need to parse the proxy-style URL to convert it to host-style.\n    // Use URL parsing options that avoid unnecessary rewrites.\n    Url::Options urlOptions;\n    urlOptions.allowEmpty = true;\n    urlOptions.percentDecode = false;\n\n    auto parsed = Url::parse(url, Url::HTTP_PROXY_REQUEST, urlOptions);\n    auto path = parsed.toString(Url::HTTP_REQUEST);\n    auto headersCopy = headers.clone();\n    headersCopy.set(HttpHeaderId::HOST, parsed.host);\n    return getClient(parsed).request(method, path, headersCopy, expectedBodySize);\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    // We need to parse the proxy-style URL to convert it to origin-form.\n    // https://www.rfc-editor.org/rfc/rfc9112.html#name-origin-form\n    // Use URL parsing options that avoid unnecessary rewrites.\n    Url::Options urlOptions;\n    urlOptions.allowEmpty = true;\n    urlOptions.percentDecode = false;\n\n    auto parsed = Url::parse(url, Url::HTTP_PROXY_REQUEST, urlOptions);\n    auto path = parsed.toString(Url::HTTP_REQUEST);\n    auto headersCopy = headers.clone();\n    headersCopy.set(HttpHeaderId::HOST, parsed.host);\n    return getClient(parsed).openWebSocket(path, headersCopy);\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers,\n      HttpConnectSettings connectSettings) override {\n    // We want to connect directly instead of going through a proxy here.\n    // https://github.com/capnproto/capnproto/pull/1454#discussion_r900414879\n    kj::Maybe<kj::Promise<kj::Own<kj::NetworkAddress>>> addr;\n    if (connectSettings.useTls) {\n      kj::Network& tlsNet = KJ_REQUIRE_NONNULL(tlsNetwork, \"this HttpClient doesn't support TLS\");\n      addr = tlsNet.parseAddress(host);\n    } else {\n      addr = network.parseAddress(host);\n    }\n\n    auto split = KJ_ASSERT_NONNULL(addr).then([this](auto address) {\n      return address->connect().then([this](auto connection)\n          -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                       kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n        return kj::tuple(\n            ConnectRequest::Status(\n              200,\n              kj::str(\"OK\"),\n              kj::heap<kj::HttpHeaders>(responseHeaderTable) // Empty headers\n            ),\n            kj::mv(connection));\n      }).attach(kj::mv(address));\n    }).split();\n\n    auto connection = kj::newPromisedStream(kj::mv(kj::get<1>(split)));\n\n    if (!connectSettings.useTls) {\n      KJ_IF_SOME(wrapper, settings.tlsContext) {\n        KJ_IF_SOME(tlsStarter, connectSettings.tlsStarter) {\n          auto transitConnectionRef = kj::refcountedWrapper(\n              kj::heap<TransitionaryAsyncIoStream>(kj::mv(connection)));\n          Function<kj::Promise<void>(kj::StringPtr)> cb =\n              [&wrapper, ref1 = transitConnectionRef->addWrappedRef()](\n              kj::StringPtr expectedServerHostname) mutable {\n            ref1->startTls(&wrapper, expectedServerHostname);\n            return kj::READY_NOW;\n          };\n          connection = transitConnectionRef->addWrappedRef();\n          tlsStarter = kj::mv(cb);\n        }\n      }\n    }\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),\n      kj::mv(connection)\n    };\n  }\n\nprivate:\n  kj::Timer& timer;\n  const HttpHeaderTable& responseHeaderTable;\n  kj::Network& network;\n  kj::Maybe<kj::Network&> tlsNetwork;\n  HttpClientSettings settings;\n\n  struct Host {\n    kj::String name;  // including port, if non-default\n    kj::Own<PromiseNetworkAddressHttpClient> client;\n  };\n\n  std::map<kj::StringPtr, Host> httpHosts;\n  std::map<kj::StringPtr, Host> httpsHosts;\n\n  struct RequestInfo {\n    HttpMethod method;\n    kj::String hostname;\n    kj::String path;\n    HttpHeaders headers;\n    kj::Maybe<uint64_t> expectedBodySize;\n  };\n\n  kj::TaskSet tasks;\n\n  HttpClient& getClient(kj::Url& parsed) {\n    bool isHttps = parsed.scheme == \"https\";\n    bool isHttp = parsed.scheme == \"http\";\n    KJ_REQUIRE(isHttp || isHttps);\n\n    auto& hosts = isHttps ? httpsHosts : httpHosts;\n\n    // Look for a cached client for this host.\n    // TODO(perf): It would be nice to recognize when different hosts have the same address and\n    //   reuse the same connection pool, but:\n    //   - We'd need a reliable way to compare NetworkAddresses, e.g. .equals() and .hashCode().\n    //     It's very Java... ick.\n    //   - Correctly handling TLS would be tricky: we'd need to verify that the new hostname is\n    //     on the certificate. When SNI is in use we might have to request an additional\n    //     certificate (is that possible?).\n    auto iter = hosts.find(parsed.host);\n\n    if (iter == hosts.end()) {\n      // Need to open a new connection.\n      kj::Network* networkToUse = &network;\n      if (isHttps) {\n        networkToUse = &KJ_REQUIRE_NONNULL(tlsNetwork, \"this HttpClient doesn't support HTTPS\");\n      }\n\n      auto promise = networkToUse->parseAddress(parsed.host, isHttps ? 443 : 80)\n          .then([this](kj::Own<kj::NetworkAddress> addr) {\n        return kj::heap<NetworkAddressHttpClient>(\n            timer, responseHeaderTable, kj::mv(addr), settings);\n      });\n\n      Host host {\n        kj::mv(parsed.host),\n        kj::heap<PromiseNetworkAddressHttpClient>(kj::mv(promise))\n      };\n      kj::StringPtr nameRef = host.name;\n\n      auto insertResult = hosts.insert(std::make_pair(nameRef, kj::mv(host)));\n      KJ_ASSERT(insertResult.second);\n      iter = insertResult.first;\n\n      tasks.add(handleCleanup(hosts, iter));\n    }\n\n    return *iter->second.client;\n  }\n\n  kj::Promise<void> handleCleanup(std::map<kj::StringPtr, Host>& hosts,\n                                  std::map<kj::StringPtr, Host>::iterator iter) {\n    return iter->second.client->onDrained()\n        .then([this,&hosts,iter]() -> kj::Promise<void> {\n      // Double-check that it's really drained to avoid race conditions.\n      if (iter->second.client->isDrained()) {\n        hosts.erase(iter);\n        return kj::READY_NOW;\n      } else {\n        return handleCleanup(hosts, iter);\n      }\n    });\n  }\n\n  void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }\n};\n\n}  // namespace\n\nkj::Own<HttpClient> newHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                                  kj::NetworkAddress& addr, HttpClientSettings settings) {\n  return kj::heap<NetworkAddressHttpClient>(timer, responseHeaderTable,\n      kj::Own<kj::NetworkAddress>(&addr, kj::NullDisposer::instance), kj::mv(settings));\n}\n\nkj::Own<HttpClient> newHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                                  kj::Network& network, kj::Maybe<kj::Network&> tlsNetwork,\n                                  HttpClientSettings settings) {\n  return kj::heap<NetworkHttpClient>(\n      timer, responseHeaderTable, network, tlsNetwork, kj::mv(settings));\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass ConcurrencyLimitingHttpClient final: public HttpClient {\npublic:\n  KJ_DISALLOW_COPY_AND_MOVE(ConcurrencyLimitingHttpClient);\n  ConcurrencyLimitingHttpClient(\n      kj::HttpClient& inner, uint maxConcurrentRequests,\n      kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback)\n      : inner(inner),\n        maxConcurrentRequests(maxConcurrentRequests),\n        countChangedCallback(kj::mv(countChangedCallback)) {}\n\n  ~ConcurrencyLimitingHttpClient() noexcept(false) {\n    if (concurrentRequests > 0) {\n      static bool logOnce KJ_UNUSED = ([&] {\n        KJ_LOG(ERROR, \"ConcurrencyLimitingHttpClient getting destroyed when concurrent requests \"\n            \"are still active\", concurrentRequests);\n        return true;\n      })();\n    }\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto request = inner.request(method, url, headers, expectedBodySize);\n      fireCountChanged();\n      auto promise = attachCounter(kj::mv(request.response), kj::mv(counter));\n      return { kj::mv(request.body), kj::mv(promise) };\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n    auto urlCopy = kj::str(url);\n    auto headersCopy = headers.clone();\n\n    auto combined = paf.promise\n        .then([this,\n               method,\n               urlCopy = kj::mv(urlCopy),\n               headersCopy = kj::mv(headersCopy),\n               expectedBodySize](ConnectionCounter&& counter) mutable {\n      auto req = inner.request(method, urlCopy, headersCopy, expectedBodySize);\n      return kj::tuple(kj::mv(req.body), attachCounter(kj::mv(req.response), kj::mv(counter)));\n    });\n    auto split = combined.split();\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n    return { newPromisedStream(kj::mv(kj::get<0>(split))), kj::mv(kj::get<1>(split)) };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const kj::HttpHeaders& headers) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto response = inner.openWebSocket(url, headers);\n      fireCountChanged();\n      return attachCounter(kj::mv(response), kj::mv(counter));\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n    auto urlCopy = kj::str(url);\n    auto headersCopy = headers.clone();\n\n    auto promise = paf.promise\n        .then([this,\n               urlCopy = kj::mv(urlCopy),\n               headersCopy = kj::mv(headersCopy)](ConnectionCounter&& counter) mutable {\n      return attachCounter(inner.openWebSocket(urlCopy, headersCopy), kj::mv(counter));\n    });\n\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n    return kj::mv(promise);\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const kj::HttpHeaders& headers, HttpConnectSettings settings) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto response = inner.connect(host, headers, settings);\n      fireCountChanged();\n      return attachCounter(kj::mv(response), kj::mv(counter));\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n\n    auto split = paf.promise\n        .then([this, host=kj::str(host), headers=headers.clone(), settings]\n              (ConnectionCounter&& counter) mutable\n                  -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                               kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n      auto request = attachCounter(inner.connect(host, headers, settings), kj::mv(counter));\n      return kj::tuple(kj::mv(request.status), kj::mv(request.connection));\n    }).split();\n\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),\n      kj::newPromisedStream(kj::mv(kj::get<1>(split)))\n    };\n  }\n\nprivate:\n  struct ConnectionCounter;\n\n  kj::HttpClient& inner;\n  uint maxConcurrentRequests;\n  uint concurrentRequests = 0;\n  kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback;\n\n  std::queue<kj::Own<kj::PromiseFulfiller<ConnectionCounter>>> pendingRequests;\n  // TODO(someday): want maximum cap on queue size?\n\n  struct ConnectionCounter final {\n    ConnectionCounter(ConcurrencyLimitingHttpClient& client) : parent(&client) {\n      ++parent->concurrentRequests;\n    }\n    KJ_DISALLOW_COPY(ConnectionCounter);\n    ~ConnectionCounter() noexcept(false) {\n      if (parent != nullptr) {\n        --parent->concurrentRequests;\n        parent->serviceQueue();\n        parent->fireCountChanged();\n      }\n    }\n    ConnectionCounter(ConnectionCounter&& other) : parent(other.parent) {\n      other.parent = nullptr;\n    }\n    ConnectionCounter& operator=(ConnectionCounter&& other) {\n      if (this != &other) {\n        this->parent = other.parent;\n        other.parent = nullptr;\n      }\n      return *this;\n    }\n\n    ConcurrencyLimitingHttpClient* parent;\n  };\n\n  void serviceQueue() {\n    while (concurrentRequests < maxConcurrentRequests && !pendingRequests.empty()) {\n      auto fulfiller = kj::mv(pendingRequests.front());\n      pendingRequests.pop();\n      // ConnectionCounter's destructor calls this function, so we can avoid unnecessary recursion\n      // if we only create a ConnectionCounter when we find a waiting fulfiller.\n      if (fulfiller->isWaiting()) {\n        fulfiller->fulfill(ConnectionCounter(*this));\n      }\n    }\n  }\n\n  void fireCountChanged() {\n    countChangedCallback(concurrentRequests, pendingRequests.size());\n  }\n\n  using WebSocketOrBody = kj::OneOf<kj::Own<kj::AsyncInputStream>, kj::Own<WebSocket>>;\n  static WebSocketOrBody attachCounter(WebSocketOrBody&& webSocketOrBody,\n                                       ConnectionCounter&& counter) {\n    KJ_SWITCH_ONEOF(webSocketOrBody) {\n      KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n        return ws.attach(kj::mv(counter));\n      }\n      KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n        return body.attach(kj::mv(counter));\n      }\n    }\n    KJ_UNREACHABLE;\n  }\n\n  static kj::Promise<WebSocketResponse> attachCounter(kj::Promise<WebSocketResponse>&& promise,\n                                                      ConnectionCounter&& counter) {\n    return promise.then([counter = kj::mv(counter)](WebSocketResponse&& response) mutable {\n      return WebSocketResponse {\n        response.statusCode,\n        response.statusText,\n        response.headers,\n        attachCounter(kj::mv(response.webSocketOrBody), kj::mv(counter))\n      };\n    });\n  }\n\n  static kj::Promise<Response> attachCounter(kj::Promise<Response>&& promise,\n                                             ConnectionCounter&& counter) {\n    return promise.then([counter = kj::mv(counter)](Response&& response) mutable {\n      return Response {\n        response.statusCode,\n        response.statusText,\n        response.headers,\n        response.body.attach(kj::mv(counter))\n      };\n    });\n  }\n\n  static ConnectRequest attachCounter(\n      ConnectRequest&& request,\n      ConnectionCounter&& counter) {\n    // Notice here that we are only attaching the counter to the connection stream. In the case\n    // where the connect tunnel request is rejected and the status promise resolves with an\n    // errorBody, there is a possibility that the consuming code might drop the connection stream\n    // and the counter while the error body stream is still be consumed. Technically speaking that\n    // means we could potentially exceed our concurrency limit temporarily but we consider that\n    // acceptable here since the error body is an exception path (plus not requiring that we\n    // attach to the errorBody keeps ConnectionCounter from having to be a refcounted heap\n    // allocation).\n    request.connection = request.connection.attach(kj::mv(counter));\n    return kj::mv(request);\n  }\n};\n\n}\n\nkj::Own<HttpClient> newConcurrencyLimitingHttpClient(\n    HttpClient& inner, uint maxConcurrentRequests,\n    kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback) {\n  return kj::heap<ConcurrencyLimitingHttpClient>(inner, maxConcurrentRequests,\n      kj::mv(countChangedCallback));\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpClientAdapter final: public HttpClient {\npublic:\n  HttpClientAdapter(HttpService& service): service(service) {}\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    // We have to clone the URL and headers because HttpService implementation are allowed to\n    // assume that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call.\n    auto urlCopy = kj::str(url);\n    auto headersCopy = kj::heap(headers.clone());\n\n    auto pipe = newOneWayPipe(expectedBodySize);\n\n    // TODO(cleanup): The ownership relationships here are a mess. Can we do something better\n    //   involving a PromiseAdapter, maybe?\n    auto paf = kj::newPromiseAndFulfiller<Response>();\n    auto responder = kj::refcounted<ResponseImpl>(method, kj::mv(paf.fulfiller));\n\n    auto requestPaf = kj::newPromiseAndFulfiller<kj::Promise<void>>();\n    responder->setPromise(kj::mv(requestPaf.promise));\n\n    auto promise = service.request(method, urlCopy, *headersCopy, *pipe.in, *responder)\n        .attach(kj::mv(pipe.in), kj::mv(urlCopy), kj::mv(headersCopy));\n    requestPaf.fulfiller->fulfill(kj::mv(promise));\n\n    return {\n      kj::mv(pipe.out),\n      paf.promise.attach(kj::mv(responder))\n    };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    // We have to clone the URL and headers because HttpService implementation are allowed to\n    // assume that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call. Also we need to add\n    // `Upgrade: websocket` so that headers.isWebSocket() returns true on the service side.\n    auto urlCopy = kj::str(url);\n    auto headersCopy = kj::heap(headers.clone());\n    headersCopy->set(HttpHeaderId::UPGRADE, \"websocket\");\n    KJ_DASSERT(headersCopy->isWebSocket());\n\n    auto paf = kj::newPromiseAndFulfiller<WebSocketResponse>();\n    auto responder = kj::refcounted<WebSocketResponseImpl>(kj::mv(paf.fulfiller));\n\n    auto requestPaf = kj::newPromiseAndFulfiller<kj::Promise<void>>();\n    responder->setPromise(kj::mv(requestPaf.promise));\n\n    auto in = kj::heap<NullInputStream>();\n    auto promise = service.request(HttpMethod::GET, urlCopy, *headersCopy, *in, *responder)\n        .attach(kj::mv(in), kj::mv(urlCopy), kj::mv(headersCopy));\n    requestPaf.fulfiller->fulfill(kj::mv(promise));\n\n    return paf.promise.attach(kj::mv(responder));\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    // We have to clone the host and the headers because HttpServer implementation are allowed to\n    // assusme that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call.\n    auto hostCopy = kj::str(host);\n    auto headersCopy = kj::heap(headers.clone());\n\n    // 1. Create a new TwoWayPipe, one will be returned with the ConnectRequest,\n    //    the other will be held by the ConnectResponseImpl.\n    auto pipe = kj::newTwoWayPipe();\n\n    // 2. Create a promise/fulfiller pair for the status. The promise will be\n    //    returned with the ConnectResponse, the fulfiller will be held by the\n    //    ConnectResponseImpl.\n    auto paf = kj::newPromiseAndFulfiller<ConnectRequest::Status>();\n\n    // 3. Create the ConnectResponseImpl\n    auto response = kj::refcounted<ConnectResponseImpl>(kj::mv(paf.fulfiller),\n                                                        kj::mv(pipe.ends[0]));\n\n    // 5. Call service.connect, passing in the tunnel.\n    //    The call to tunnel->getConnectStream() returns a guarded stream that will buffer\n    //    writes until the status is indicated by calling accept/reject.\n    auto connectStream = response->getConnectStream();\n    auto promise = service.connect(hostCopy, *headersCopy, *connectStream, *response, settings)\n        .eagerlyEvaluate([response=kj::mv(response),\n                          host=kj::mv(hostCopy),\n                          headers=kj::mv(headersCopy),\n                          connectStream=kj::mv(connectStream)](kj::Exception&& ex) mutable {\n      // A few things need to happen here.\n      //   1. We'll log the exception.\n      //   2. We'll break the pipe.\n      //   3. We'll reject the status promise if it is still pending.\n      //\n      // We'll do all of this within the ConnectResponseImpl, however, since it\n      // maintains the state necessary here.\n      response->handleException(kj::mv(ex), kj::mv(connectStream));\n    });\n\n    // TODO(bug): There's a challenge with attaching the service.connect promise to the\n    // connection stream below in that the client will likely drop the connection as soon\n    // as it reads EOF, but the promise representing the service connect() call may still\n    // be running and want to do some cleanup after it has sent EOF. That cleanup will be\n    // canceled. For regular HTTP calls, DelayedEofInputStream was created to address this\n    // exact issue but with connect() being bidirectional it's rather more difficult. We\n    // want a delay similar to what DelayedEofInputStream adds but only when both directions\n    // have been closed. That currently is not possible until we have an alternative to\n    // shutdownWrite() that returns a Promise (e.g. Promise<void> end()). For now, we can\n    // live with the current limitation.\n    return ConnectRequest {\n      kj::mv(paf.promise),\n      pipe.ends[1].attach(kj::mv(promise)),\n    };\n  }\n\nprivate:\n  HttpService& service;\n\n  class DelayedEofInputStream final: public kj::AsyncInputStream {\n    // An AsyncInputStream wrapper that, when it reaches EOF, delays the final read until some\n    // promise completes.\n\n  public:\n    DelayedEofInputStream(kj::Own<kj::AsyncInputStream> inner, kj::Promise<void> completionTask)\n        : inner(kj::mv(inner)), completionTask(kj::mv(completionTask)) {}\n\n    kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return wrap(minBytes, inner->tryRead(buffer, minBytes, maxBytes));\n    }\n\n    kj::Maybe<uint64_t> tryGetLength() override {\n      return inner->tryGetLength();\n    }\n\n    kj::Promise<uint64_t> pumpTo(kj::AsyncOutputStream& output, uint64_t amount) override {\n      return wrap(amount, inner->pumpTo(output, amount));\n    }\n\n  private:\n    kj::Own<kj::AsyncInputStream> inner;\n    kj::Maybe<kj::Promise<void>> completionTask;\n\n    template <typename T>\n    kj::Promise<T> wrap(T requested, kj::Promise<T> innerPromise) {\n      return innerPromise.then([this,requested](T actual) -> kj::Promise<T> {\n        if (actual < requested) {\n          // Must have reached EOF.\n          KJ_IF_SOME(t, completionTask) {\n            // Delay until completion.\n            auto result = t.then([actual]() { return actual; });\n            completionTask = kj::none;\n            return result;\n          } else {\n            // Must have called tryRead() again after we already signaled EOF. Fine.\n            return actual;\n          }\n        } else {\n          return actual;\n        }\n      }, [this](kj::Exception&& e) -> kj::Promise<T> {\n        // The stream threw an exception, but this exception is almost certainly just complaining\n        // that the other end of the stream was dropped. In all likelihood, the HttpService\n        // request() call itself will throw a much more interesting error -- we'd rather propagate\n        // that one, if so.\n        KJ_IF_SOME(t, completionTask) {\n          auto result = t.then([e = kj::mv(e)]() mutable -> kj::Promise<T> {\n            // Looks like the service didn't throw. I guess we should propagate the stream error\n            // after all.\n            return kj::mv(e);\n          });\n          completionTask = kj::none;\n          return result;\n        } else {\n          // Must have called tryRead() again after we already signaled EOF or threw. Fine.\n          return kj::mv(e);\n        }\n      });\n    }\n  };\n\n  class ResponseImpl final: public HttpService::Response, public kj::Refcounted {\n  public:\n    ResponseImpl(kj::HttpMethod method,\n                 kj::Own<kj::PromiseFulfiller<HttpClient::Response>> fulfiller)\n        : method(method), fulfiller(kj::mv(fulfiller)) {}\n\n    void setPromise(kj::Promise<void> promise) {\n      task = promise.eagerlyEvaluate([this](kj::Exception&& exception) {\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::mv(exception));\n        } else {\n          // We need to cause the response stream's read() to throw this, so we should propagate it.\n          kj::throwRecoverableException(kj::mv(exception));\n        }\n      });\n    }\n\n    kj::Own<kj::AsyncOutputStream> send(\n        uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      // The caller of HttpClient is allowed to assume that the statusText and headers remain\n      // valid until the body stream is dropped, but the HttpService implementation is allowed to\n      // send values that are only valid until send() returns, so we have to copy.\n      auto statusTextCopy = kj::str(statusText);\n      auto headersCopy = kj::heap(headers.clone());\n\n      if (method == kj::HttpMethod::HEAD || expectedBodySize.orDefault(1) == 0) {\n        // We're not expecting any body. We need to delay reporting completion to the client until\n        // the server side has actually returned from the service method, otherwise we may\n        // prematurely cancel it.\n\n        task = task.then([this,statusCode,statusTextCopy=kj::mv(statusTextCopy),\n                          headersCopy=kj::mv(headersCopy),expectedBodySize]() mutable {\n          fulfiller->fulfill({\n            statusCode, statusTextCopy, headersCopy.get(),\n            kj::heap<NullInputStream>(expectedBodySize)\n                .attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n          });\n        }).eagerlyEvaluate([](kj::Exception&& e) { KJ_LOG(ERROR, e); });\n        return kj::heap<NullOutputStream>();\n      } else {\n        auto pipe = newOneWayPipe(expectedBodySize);\n\n        // Wrap the stream in a wrapper that delays the last read (the one that signals EOF) until\n        // the service's request promise has finished.\n        auto wrapper = kj::heap<DelayedEofInputStream>(\n            kj::mv(pipe.in), task.attach(kj::addRef(*this)));\n\n        fulfiller->fulfill({\n          statusCode, statusTextCopy, headersCopy.get(),\n          wrapper.attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n        });\n        return kj::mv(pipe.out);\n      }\n    }\n\n    kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n      KJ_FAIL_REQUIRE(\"a WebSocket was not requested\");\n    }\n\n  private:\n    kj::HttpMethod method;\n    kj::Own<kj::PromiseFulfiller<HttpClient::Response>> fulfiller;\n    kj::Promise<void> task = nullptr;\n  };\n\n  class DelayedCloseWebSocket final: public WebSocket {\n    // A WebSocket wrapper that, when it reaches Close (in both directions), delays the final close\n    // operation until some promise completes.\n\n  public:\n    DelayedCloseWebSocket(kj::Own<kj::WebSocket> inner, kj::Promise<void> completionTask)\n        : inner(kj::mv(inner)), completionTask(kj::mv(completionTask)) {}\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      return inner->send(message);\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      return inner->send(message);\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      return inner->close(code, reason)\n          .then([this]() {\n        return afterSendClosed();\n      });\n    }\n    kj::Promise<void> disconnect() override {\n      return inner->disconnect();\n    }\n    void abort() override {\n      // Don't need to worry about completion task in this case -- cancelling it is reasonable.\n      inner->abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      return inner->whenAborted();\n    }\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return inner->receive(maxSize).then([this](Message&& message) -> kj::Promise<Message> {\n        if (message.is<WebSocket::Close>()) {\n          return afterReceiveClosed()\n              .then([message = kj::mv(message)]() mutable { return kj::mv(message); });\n        }\n        return kj::mv(message);\n      });\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return inner->pumpTo(other).then([this]() {\n        return afterReceiveClosed();\n      });\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      return other.pumpTo(*inner).then([this]() {\n        return afterSendClosed();\n      });\n    }\n\n    uint64_t sentByteCount() override { return inner->sentByteCount(); }\n    uint64_t receivedByteCount() override { return inner->receivedByteCount(); }\n\n  private:\n    kj::Own<kj::WebSocket> inner;\n    kj::Maybe<kj::Promise<void>> completionTask;\n\n    bool sentClose = false;\n    bool receivedClose = false;\n\n    kj::Promise<void> afterSendClosed() {\n      sentClose = true;\n      if (receivedClose) {\n        KJ_IF_SOME(t, completionTask) {\n          auto result = kj::mv(t);\n          completionTask = kj::none;\n          return result;\n        }\n      }\n      return kj::READY_NOW;\n    }\n\n    kj::Promise<void> afterReceiveClosed() {\n      receivedClose = true;\n      if (sentClose) {\n        KJ_IF_SOME(t, completionTask) {\n          auto result = kj::mv(t);\n          completionTask = kj::none;\n          return result;\n        }\n      }\n      return kj::READY_NOW;\n    }\n  };\n\n  class WebSocketResponseImpl final: public HttpService::Response, public kj::Refcounted {\n  public:\n    WebSocketResponseImpl(kj::Own<kj::PromiseFulfiller<HttpClient::WebSocketResponse>> fulfiller)\n        : fulfiller(kj::mv(fulfiller)) {}\n\n    void setPromise(kj::Promise<void> promise) {\n      task = promise.eagerlyEvaluate([this](kj::Exception&& exception) {\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::mv(exception));\n        } else {\n          // We need to cause the client-side WebSocket to throw on close, so propagate the\n          // exception.\n          kj::throwRecoverableException(kj::mv(exception));\n        }\n      });\n    }\n\n    kj::Own<kj::AsyncOutputStream> send(\n        uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      // The caller of HttpClient is allowed to assume that the statusText and headers remain\n      // valid until the body stream is dropped, but the HttpService implementation is allowed to\n      // send values that are only valid until send() returns, so we have to copy.\n      auto statusTextCopy = kj::str(statusText);\n      auto headersCopy = kj::heap(headers.clone());\n\n      if (expectedBodySize.orDefault(1) == 0) {\n        // We're not expecting any body. We need to delay reporting completion to the client until\n        // the server side has actually returned from the service method, otherwise we may\n        // prematurely cancel it.\n\n        task = task.then([this,statusCode,statusTextCopy=kj::mv(statusTextCopy),\n                          headersCopy=kj::mv(headersCopy),expectedBodySize]() mutable {\n          fulfiller->fulfill({\n            statusCode, statusTextCopy, headersCopy.get(),\n            kj::Own<AsyncInputStream>(kj::heap<NullInputStream>(expectedBodySize)\n                .attach(kj::mv(statusTextCopy), kj::mv(headersCopy)))\n          });\n        }).eagerlyEvaluate([](kj::Exception&& e) { KJ_LOG(ERROR, e); });\n        return kj::heap<NullOutputStream>();\n      } else {\n        auto pipe = newOneWayPipe(expectedBodySize);\n\n        // Wrap the stream in a wrapper that delays the last read (the one that signals EOF) until\n        // the service's request promise has finished.\n        kj::Own<AsyncInputStream> wrapper =\n            kj::heap<DelayedEofInputStream>(kj::mv(pipe.in), task.attach(kj::addRef(*this)));\n\n        fulfiller->fulfill({\n          statusCode, statusTextCopy, headersCopy.get(),\n          wrapper.attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n        });\n        return kj::mv(pipe.out);\n      }\n    }\n\n    kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n      // The caller of HttpClient is allowed to assume that the headers remain valid until the body\n      // stream is dropped, but the HttpService implementation is allowed to send headers that are\n      // only valid until acceptWebSocket() returns, so we have to copy.\n      auto headersCopy = kj::heap(headers.clone());\n\n      auto pipe = newWebSocketPipe();\n\n      // Wrap the client-side WebSocket in a wrapper that delays clean close of the WebSocket until\n      // the service's request promise has finished.\n      kj::Own<WebSocket> wrapper =\n          kj::heap<DelayedCloseWebSocket>(kj::mv(pipe.ends[0]), task.attach(kj::addRef(*this)));\n      fulfiller->fulfill({\n        101, \"Switching Protocols\", headersCopy.get(),\n        wrapper.attach(kj::mv(headersCopy))\n      });\n      return kj::mv(pipe.ends[1]);\n    }\n\n  private:\n    kj::Own<kj::PromiseFulfiller<HttpClient::WebSocketResponse>> fulfiller;\n    kj::Promise<void> task = nullptr;\n  };\n\n  class ConnectResponseImpl final: public HttpService::ConnectResponse, public kj::Refcounted {\n  public:\n    ConnectResponseImpl(\n        kj::Own<kj::PromiseFulfiller<HttpClient::ConnectRequest::Status>> fulfiller,\n        kj::Own<kj::AsyncIoStream> stream)\n        : fulfiller(kj::mv(fulfiller)),\n          streamAndFulfiller(initStreamsAndFulfiller(kj::mv(stream))) {}\n\n    ~ConnectResponseImpl() noexcept(false) {\n      if (fulfiller->isWaiting() || streamAndFulfiller.fulfiller->isWaiting()) {\n        auto ex = KJ_EXCEPTION(FAILED,\n            \"service's connect() implementation never called accept() nor reject()\");\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::cp(ex));\n        }\n        if (streamAndFulfiller.fulfiller->isWaiting()) {\n          streamAndFulfiller.fulfiller->reject(kj::mv(ex));\n        }\n      }\n    }\n\n    void accept(uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) override {\n      KJ_REQUIRE(statusCode >= 200 && statusCode < 300, \"the statusCode must be 2xx for accept\");\n      respond(statusCode, statusText, headers);\n    }\n\n    kj::Own<kj::AsyncOutputStream> reject(\n        uint statusCode,\n        kj::StringPtr statusText,\n        const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      KJ_REQUIRE(statusCode < 200 || statusCode >= 300,\n          \"the statusCode must not be 2xx for reject.\");\n      auto pipe = kj::newOneWayPipe();\n      respond(statusCode, statusText, headers, kj::mv(pipe.in));\n      return kj::mv(pipe.out);\n    }\n\n  private:\n    struct StreamsAndFulfiller {\n      // guarded is the wrapped/guarded stream that wraps a reference to\n      // the underlying stream but blocks reads until the connection is accepted\n      // or rejected.\n      // This will be handed off when getConnectStream() is called.\n      // The fulfiller is used to resolve the guard for the second stream. This will\n      // be fulfilled or rejected when accept/reject is called.\n      kj::Own<kj::AsyncIoStream> guarded;\n      kj::Own<kj::PromiseFulfiller<void>> fulfiller;\n    };\n\n    kj::Own<kj::PromiseFulfiller<HttpClient::ConnectRequest::Status>> fulfiller;\n    StreamsAndFulfiller streamAndFulfiller;\n    bool connectStreamDetached = false;\n\n    StreamsAndFulfiller initStreamsAndFulfiller(kj::Own<kj::AsyncIoStream> stream) {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      auto guarded = kj::heap<AsyncIoStreamWithGuards>(\n          kj::mv(stream),\n          kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none),\n          kj::mv(paf.promise));\n      return StreamsAndFulfiller {\n        kj::mv(guarded),\n        kj::mv(paf.fulfiller)\n      };\n    }\n\n    void handleException(kj::Exception&& ex, kj::Own<kj::AsyncIoStream> connectStream) {\n      // Reject the status promise if it is still pending...\n      if (fulfiller->isWaiting()) {\n        fulfiller->reject(kj::cp(ex));\n      }\n      if (streamAndFulfiller.fulfiller->isWaiting()) {\n        // If the guard hasn't yet ben released, we can fail the pending reads by\n        // rejecting the fulfiller here.\n        streamAndFulfiller.fulfiller->reject(kj::mv(ex));\n      } else {\n        // The guard has already been released at this point.\n        // TODO(connect): How to properly propagate the actual exception to the\n        // connect stream? Here we \"simply\" shut it down.\n        connectStream->abortRead();\n        connectStream->shutdownWrite();\n      }\n    }\n\n    kj::Own<kj::AsyncIoStream> getConnectStream() {\n      KJ_ASSERT(!connectStreamDetached, \"the connect stream was already detached\");\n      connectStreamDetached = true;\n      return streamAndFulfiller.guarded.attach(kj::addRef(*this));\n    }\n\n    void respond(uint statusCode,\n                 kj::StringPtr statusText,\n                 const HttpHeaders& headers,\n                 kj::Maybe<kj::Own<kj::AsyncInputStream>> errorBody = kj::none) {\n      if (errorBody == kj::none) {\n        streamAndFulfiller.fulfiller->fulfill();\n      } else {\n        streamAndFulfiller.fulfiller->reject(\n            KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n      }\n      fulfiller->fulfill(HttpClient::ConnectRequest::Status(\n          statusCode,\n          kj::str(statusText),\n          kj::heap(headers.clone()),\n          kj::mv(errorBody)));\n    }\n\n    friend class HttpClientAdapter;\n  };\n\n};\n\n}  // namespace\n\nkj::Own<HttpClient> newHttpClient(HttpService& service) {\n  return kj::heap<HttpClientAdapter>(service);\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpServiceAdapter final: public HttpService {\npublic:\n  HttpServiceAdapter(HttpClient& client): client(client) {}\n\n  kj::Promise<void> request(\n      HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) override {\n    if (!headers.isWebSocket()) {\n      auto innerReq = client.request(method, url, headers, requestBody.tryGetLength());\n\n      auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n      promises.add(requestBody.pumpTo(*innerReq.body).ignoreResult()\n          .attach(kj::mv(innerReq.body)).eagerlyEvaluate(nullptr));\n\n      promises.add(innerReq.response\n          .then([&response](HttpClient::Response&& innerResponse) {\n        auto out = response.send(\n            innerResponse.statusCode, innerResponse.statusText, *innerResponse.headers,\n            innerResponse.body->tryGetLength());\n        auto promise = innerResponse.body->pumpTo(*out);\n        return promise.ignoreResult().attach(kj::mv(out), kj::mv(innerResponse.body));\n      }));\n\n      return kj::joinPromisesFailFast(promises.finish());\n    } else {\n      return client.openWebSocket(url, headers)\n          .then([&response](HttpClient::WebSocketResponse&& innerResponse) -> kj::Promise<void> {\n        KJ_SWITCH_ONEOF(innerResponse.webSocketOrBody) {\n          KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n            auto ws2 = response.acceptWebSocket(*innerResponse.headers);\n            auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n            promises.add(ws->pumpTo(*ws2));\n            promises.add(ws2->pumpTo(*ws));\n            return kj::joinPromisesFailFast(promises.finish()).attach(kj::mv(ws), kj::mv(ws2));\n          }\n          KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n            auto out = response.send(\n                innerResponse.statusCode, innerResponse.statusText, *innerResponse.headers,\n                body->tryGetLength());\n            auto promise = body->pumpTo(*out);\n            return promise.ignoreResult().attach(kj::mv(out), kj::mv(body));\n          }\n        }\n        KJ_UNREACHABLE;\n      });\n    }\n  }\n\n  kj::Promise<void> connect(kj::StringPtr host,\n                            const HttpHeaders& headers,\n                            kj::AsyncIoStream& connection,\n                            ConnectResponse& response,\n                            HttpConnectSettings settings) override {\n    KJ_REQUIRE(!headers.isWebSocket(), \"WebSocket upgrade headers are not permitted in a connect.\");\n\n    auto request = client.connect(host, headers, settings);\n\n    // This operates optimistically. In order to support pipelining, we connect the\n    // input and outputs streams immediately, even if we're not yet certain that the\n    // tunnel can actually be established.\n    auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n\n    // For the inbound pipe (from the clients stream to the passed in stream)\n    // We want to guard reads pending the acceptance of the tunnel. If the\n    // tunnel is not accepted, the guard will be rejected, causing pending\n    // reads to fail.\n    auto paf = kj::newPromiseAndFulfiller<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>>();\n    auto io = kj::heap<AsyncIoStreamWithGuards>(\n        kj::mv(request.connection),\n        kj::mv(paf.promise) /* read guard */,\n        kj::READY_NOW /* write guard */);\n\n    // Writing from connection to io is unguarded and allowed immediately.\n    promises.add(connection.pumpTo(*io).then([&io=*io](uint64_t size) {\n      io.shutdownWrite();\n    }));\n\n    promises.add(io->pumpTo(connection).then([&connection](uint64_t size) {\n      connection.shutdownWrite();\n    }));\n\n    auto pumpPromise = kj::joinPromisesFailFast(promises.finish());\n\n    return request.status.then(\n        [&response,&connection,fulfiller=kj::mv(paf.fulfiller),\n         pumpPromise=kj::mv(pumpPromise)]\n        (HttpClient::ConnectRequest::Status status) mutable -> kj::Promise<void> {\n      if (status.statusCode >= 200 && status.statusCode < 300) {\n        // Release the read guard!\n        fulfiller->fulfill(kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none));\n        response.accept(status.statusCode, status.statusText, *status.headers);\n        return kj::mv(pumpPromise);\n      } else {\n        // If the connect request is rejected, we want to shutdown the tunnel\n        // and pipeline the status.errorBody to the AsyncOutputStream returned by\n        // reject if it exists.\n        pumpPromise = nullptr;\n        connection.shutdownWrite();\n        fulfiller->reject(KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n        KJ_IF_SOME(errorBody, status.errorBody) {\n          auto out = response.reject(status.statusCode, status.statusText, *status.headers,\n              errorBody->tryGetLength());\n          return errorBody->pumpTo(*out).then([](uint64_t) -> kj::Promise<void> {\n            return kj::READY_NOW;\n          }).attach(kj::mv(out), kj::mv(errorBody));\n        } else {\n          response.reject(status.statusCode, status.statusText, *status.headers, (uint64_t)0);\n          return kj::READY_NOW;\n        }\n      }\n    }).attach(kj::mv(io));\n  }\n\nprivate:\n  HttpClient& client;\n};\n\n}  // namespace\n\nkj::Own<HttpService> newHttpService(HttpClient& client) {\n  return kj::heap<HttpServiceAdapter>(client);\n}\n\n// =======================================================================================\n\nkj::Promise<void> HttpService::Response::sendError(\n    uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) {\n  auto stream = send(statusCode, statusText, headers, statusText.size());\n  auto promise = stream->write(statusText.begin(), statusText.size());\n  return promise.attach(kj::mv(stream));\n}\n\nkj::Promise<void> HttpService::Response::sendError(\n    uint statusCode, kj::StringPtr statusText, const HttpHeaderTable& headerTable) {\n  return sendError(statusCode, statusText, HttpHeaders(headerTable));\n}\n\nkj::Promise<void> HttpService::connect(\n    kj::StringPtr host,\n    const HttpHeaders& headers,\n    kj::AsyncIoStream& connection,\n    ConnectResponse& response,\n    kj::HttpConnectSettings settings) {\n  KJ_UNIMPLEMENTED(\"CONNECT is not implemented by this HttpService\");\n}\n\nclass HttpServer::Connection final: private HttpService::Response,\n                                    private HttpService::ConnectResponse,\n                                    private HttpServerErrorHandler {\npublic:\n  Connection(HttpServer& server, kj::AsyncIoStream& stream,\n             SuspendableHttpServiceFactory factory, kj::Maybe<SuspendedRequest> suspendedRequest,\n             bool wantCleanDrain)\n      : server(server),\n        stream(stream),\n        factory(kj::mv(factory)),\n        httpInput(makeHttpInput(stream, server.requestHeaderTable, kj::mv(suspendedRequest))),\n        httpOutput(stream),\n        wantCleanDrain(wantCleanDrain) {\n    ++server.connectionCount;\n  }\n  ~Connection() noexcept(false) {\n    if (--server.connectionCount == 0) {\n      KJ_IF_SOME(f, server.zeroConnectionsFulfiller) {\n        f->fulfill();\n      }\n    }\n  }\n\npublic:\n  // Each iteration of the loop decides if it wants to continue, or break the loop and return.\n  enum LoopResult {\n    CONTINUE_LOOP,\n    BREAK_LOOP_CONN_OK,\n    BREAK_LOOP_CONN_ERR,\n  };\n\n  kj::Promise<bool> startLoop() {\n    auto result = co_await startLoopImpl();\n    KJ_ASSERT(result != CONTINUE_LOOP);\n    co_return result == BREAK_LOOP_CONN_OK ? true : false;\n  }\n\n  kj::Promise<LoopResult> startLoopImpl() {\n    return loop().catch_([this](kj::Exception&& e) {\n      // Exception; report 5xx.\n\n      KJ_IF_SOME(p, webSocketError) {\n        // sendWebSocketError() was called. Finish sending and close the connection. Don't log\n        // the exception because it's probably a side-effect of this.\n        auto promise = kj::mv(p);\n        webSocketError = kj::none;\n        return kj::mv(promise);\n      }\n\n      KJ_IF_SOME(p, tunnelRejected) {\n        // reject() was called to reject a CONNECT request. Finish sending and close the connection.\n        // Don't log the exception because it's probably a side-effect of this.\n        auto promise = kj::mv(p);\n        tunnelRejected = kj::none;\n        return kj::mv(promise);\n      }\n\n      return sendError(kj::mv(e));\n    });\n  }\n\n  SuspendedRequest suspend(SuspendableRequest& suspendable) {\n    KJ_REQUIRE(httpInput.canSuspend(),\n        \"suspend() may only be called before the request body is consumed\");\n    KJ_DEFER(suspended = true);\n    auto released = httpInput.releaseBuffer();\n    return {\n      kj::mv(released.buffer),\n      released.leftover,\n      suspendable.method,\n      suspendable.url,\n      suspendable.headers.cloneShallow(),\n    };\n  }\n\nprivate:\n  HttpServer& server;\n  kj::AsyncIoStream& stream;\n\n  SuspendableHttpServiceFactory factory;\n  // Creates a new kj::Own<HttpService> for each request we handle on this connection.\n\n  HttpInputStreamImpl httpInput;\n  HttpOutputStream httpOutput;\n  kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> currentMethod;\n  bool timedOut = false;\n  bool closed = false;\n  bool upgraded = false;\n  bool webSocketOrConnectClosed = false;\n  bool closeAfterSend = false;  // True if send() should set Connection: close.\n  bool wantCleanDrain = false;\n  bool suspended = false;\n  kj::Maybe<kj::Promise<LoopResult>> webSocketError;\n  kj::Maybe<kj::Promise<LoopResult>> tunnelRejected;\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> tunnelWriteGuard;\n\n  static HttpInputStreamImpl makeHttpInput(\n      kj::AsyncIoStream& stream,\n      const kj::HttpHeaderTable& table,\n      kj::Maybe<SuspendedRequest> suspendedRequest) {\n    // Constructor helper function to create our HttpInputStreamImpl.\n\n    KJ_IF_SOME(sr, suspendedRequest) {\n      return HttpInputStreamImpl(stream,\n          sr.buffer.releaseAsChars(),\n          sr.leftover.asChars(),\n          sr.method,\n          sr.url,\n          kj::mv(sr.headers));\n    }\n    return HttpInputStreamImpl(stream, table);\n  }\n\n  kj::Promise<LoopResult> loop() {\n    bool firstRequest = true;\n\n    while (true) {\n      if (!firstRequest && server.draining && httpInput.isCleanDrain()) {\n        // Don't call awaitNextMessage() in this case because that will initiate a read() which will\n        // immediately be canceled, losing data.\n        co_return BREAK_LOOP_CONN_OK;\n      }\n\n      auto firstByte = httpInput.awaitNextMessage();\n\n      if (!firstRequest) {\n        // For requests after the first, require that the first byte arrive before the pipeline\n        // timeout, otherwise treat it like the connection was simply closed.\n        auto timeoutPromise = server.timer.afterDelay(server.settings.pipelineTimeout);\n\n        if (httpInput.isCleanDrain()) {\n          // If we haven't buffered any data, then we can safely drain here, so allow the wait to\n          // be canceled by the onDrain promise.\n          auto cleanDrainPromise = server.onDrain.addBranch()\n              .then([this]() -> kj::Promise<void> {\n            // This is a little tricky... drain() has been called, BUT we could have read some data\n            // into the buffer in the meantime, and we don't want to lose that. If any data has\n            // arrived, then we have no choice but to read the rest of the request and respond to\n            // it.\n            if (!httpInput.isCleanDrain()) {\n              return kj::NEVER_DONE;\n            }\n\n            // OK... As far as we know, no data has arrived in the buffer. However, unfortunately,\n            // we don't *really* know that, because read() is asynchronous. It may have already\n            // delivered some bytes, but we just haven't received the notification yet, because it's\n            // still queued on the event loop. As a horrible hack, we use evalLast(), so that any\n            // such pending notifications get a chance to be delivered.\n            // TODO(someday): Does this actually work on Windows, where the notification could also\n            //   be queued on the IOCP?\n            return kj::evalLast([this]() -> kj::Promise<void> {\n              if (httpInput.isCleanDrain()) {\n                return kj::READY_NOW;\n              } else {\n                return kj::NEVER_DONE;\n              }\n            });\n          });\n          timeoutPromise = timeoutPromise.exclusiveJoin(kj::mv(cleanDrainPromise));\n        }\n\n        firstByte = firstByte.exclusiveJoin(timeoutPromise.then([this]() -> bool {\n          timedOut = true;\n          return false;\n        }));\n      }\n\n      auto receivedHeaders = firstByte\n          .then([this,firstRequest](bool hasData)\n              -> kj::Promise<HttpHeaders::RequestConnectOrProtocolError> {\n        if (hasData) {\n          auto readHeaders = httpInput.readRequestHeaders();\n          if (!firstRequest) {\n            // On requests other than the first, the header timeout starts ticking when we receive\n            // the first byte of a pipeline response.\n            readHeaders = readHeaders.exclusiveJoin(\n                server.timer.afterDelay(server.settings.headerTimeout)\n                .then([this]() -> HttpHeaders::RequestConnectOrProtocolError {\n              timedOut = true;\n              return HttpHeaders::ProtocolError {\n                408, \"Request Timeout\",\n                \"Timed out waiting for next request headers.\", nullptr\n              };\n            }));\n          }\n          return kj::mv(readHeaders);\n        } else {\n          // Client closed connection or pipeline timed out with no bytes received. This is not an\n          // error, so don't report one.\n          this->closed = true;\n          return HttpHeaders::RequestConnectOrProtocolError(HttpHeaders::ProtocolError {\n            408, \"Request Timeout\",\n            \"Client closed connection or connection timeout \"\n            \"while waiting for request headers.\", nullptr\n          });\n        }\n      });\n\n      if (firstRequest) {\n        // On the first request, the header timeout starts ticking immediately upon request opening.\n        // NOTE: Since we assume that the client wouldn't have formed a connection if they did not\n        //   intend to send a request, we immediately treat this connection as having an active\n        //   request, i.e. we do NOT cancel it if drain() is called.\n        auto timeoutPromise = server.timer.afterDelay(server.settings.headerTimeout)\n            .then([this]() -> HttpHeaders::RequestConnectOrProtocolError {\n          timedOut = true;\n          return HttpHeaders::ProtocolError {\n            408, \"Request Timeout\",\n            \"Timed out waiting for initial request headers.\", nullptr\n          };\n        });\n        receivedHeaders = receivedHeaders.exclusiveJoin(kj::mv(timeoutPromise));\n      }\n\n      auto requestOrProtocolError = co_await receivedHeaders;\n      auto loopResult = co_await onHeaders(kj::mv(requestOrProtocolError));\n\n      switch (loopResult) {\n        case BREAK_LOOP_CONN_ERR:\n        case BREAK_LOOP_CONN_OK: co_return loopResult;\n        case CONTINUE_LOOP: {\n          firstRequest = false;\n        }\n      }\n    }\n  }\n\n  kj::Promise<LoopResult> onHeaders(HttpHeaders::RequestConnectOrProtocolError&& requestOrProtocolError) {\n    if (timedOut) {\n      // Client took too long to send anything, so we're going to close the connection. In\n      // theory, we should send back an HTTP 408 error -- it is designed exactly for this\n      // purpose. Alas, in practice, Google Chrome does not have any special handling for 408\n      // errors -- it will assume the error is a response to the next request it tries to send,\n      // and will happily serve the error to the user. OTOH, if we simply close the connection,\n      // Chrome does the \"right thing\", apparently. (Though I'm not sure what happens if a\n      // request is in-flight when we close... if it's a GET, the browser should retry. But if\n      // it's a POST, retrying may be dangerous. This is why 408 exists -- it unambiguously\n      // tells the client that it should retry.)\n      //\n      // Also note that if we ever decide to send 408 again, we might want to send some other\n      // error in the case that the server is draining, which also sets timedOut = true; see\n      // above.\n\n      co_await httpOutput.flush();\n      co_return (server.draining && httpInput.isCleanDrain()) ? BREAK_LOOP_CONN_OK : BREAK_LOOP_CONN_ERR;\n    }\n\n    if (closed) {\n      // Client closed connection. Close our end too.\n      co_await httpOutput.flush();\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    KJ_SWITCH_ONEOF(requestOrProtocolError) {\n      KJ_CASE_ONEOF(request, HttpHeaders::ConnectRequest) {\n        co_return co_await onConnect(request);\n      }\n      KJ_CASE_ONEOF(request, HttpHeaders::Request) {\n        co_return co_await onRequest(request);\n      }\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        // Bad request.\n\n        auto needClientGrace = protocolError.statusCode == 431;\n        if (needClientGrace) {\n          // We're going to reply with an error and close the connection.\n          // The client might not be able to read the error back. Read some data and wait\n          // a bit to give client a chance to finish writing.\n\n          auto dummy = kj::heap<HttpDiscardingEntityWriter>();\n          auto lengthGrace = kj::evalNow([&]() {\n            return httpInput.discard(*dummy, server.settings.canceledUploadGraceBytes);\n          }).catch_([](kj::Exception&& e) -> void { })\n            .attach(kj::mv(dummy));\n          auto timeGrace = server.timer.afterDelay(server.settings.canceledUploadGracePeriod);\n          co_await lengthGrace.exclusiveJoin(kj::mv(timeGrace));\n        }\n\n        // sendError() uses Response::send(), which requires that we have a currentMethod, but we\n        // never read one. GET seems like the correct choice here.\n        currentMethod = HttpMethod::GET;\n        co_return co_await sendError(kj::mv(protocolError));\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  kj::Promise<LoopResult> onConnect(HttpHeaders::ConnectRequest& request) {\n    auto& headers = httpInput.getHeaders();\n\n    currentMethod = HttpConnectMethod();\n\n    // The HTTP specification says that CONNECT requests have no meaningful payload\n    // but stops short of saying that CONNECT *cannot* have a payload. Implementations\n    // can choose to either accept payloads or reject them. We choose to reject it.\n    // Specifically, if there are Content-Length or Transfer-Encoding headers in the\n    // request headers, we'll automatically reject the CONNECT request.\n    //\n    // The key implication here is that any data that immediately follows the headers\n    // block of the CONNECT request is considered to be part of the tunnel if it is\n    // established.\n\n    if (headers.get(HttpHeaderId::CONTENT_LENGTH) != kj::none) {\n      co_return co_await sendError(HttpHeaders::ProtocolError {\n        400,\n        \"Bad Request\"_kj,\n        \"Bad Request\"_kj,\n        nullptr,\n      });\n    }\n    if (headers.get(HttpHeaderId::TRANSFER_ENCODING) != kj::none) {\n      co_return co_await sendError(HttpHeaders::ProtocolError {\n        400,\n        \"Bad Request\"_kj,\n        \"Bad Request\"_kj,\n        nullptr,\n      });\n    }\n\n    SuspendableRequest suspendable(*this, HttpConnectMethod(), request.authority, headers);\n    auto maybeService = factory(suspendable);\n\n    if (suspended) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    auto service = KJ_ASSERT_NONNULL(kj::mv(maybeService),\n        \"SuspendableHttpServiceFactory did not suspend, but returned kj::none.\");\n    auto connectStream = getConnectStream();\n    co_await service->connect(\n        request.authority, headers, *connectStream, *this, {})\n        .attach(kj::mv(service), kj::mv(connectStream));\n\n\n    KJ_IF_SOME(p, tunnelRejected) {\n      // reject() was called to reject a CONNECT attempt.\n      // Finish sending and close the connection.\n      auto promise = kj::mv(p);\n      tunnelRejected = kj::none;\n      co_return co_await promise;\n    }\n\n    if (httpOutput.isBroken()) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    co_await httpOutput.flush();\n    co_return BREAK_LOOP_CONN_ERR;\n  }\n\n  kj::Promise<LoopResult> onRequest(HttpHeaders::Request& request) {\n    auto& headers = httpInput.getHeaders();\n\n    currentMethod = request.method;\n\n    SuspendableRequest suspendable(*this, request.method, request.url, headers);\n    auto maybeService = factory(suspendable);\n\n    if (suspended) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    auto service = KJ_ASSERT_NONNULL(kj::mv(maybeService),\n        \"SuspendableHttpServiceFactory did not suspend, but returned kj::none.\");\n\n    // TODO(perf): If the client disconnects, should we cancel the response? Probably, to\n    //   prevent permanent deadlock. It's slightly weird in that arguably the client should\n    //   be able to shutdown the upstream but still wait on the downstream, but I believe many\n    //   other HTTP servers do similar things.\n\n    auto body = httpInput.getEntityBody(\n        HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n\n    co_await service->request(\n        request.method, request.url, headers, *body, *this).attach(kj::mv(service));\n    // Response done. Await next request.\n\n    KJ_IF_SOME(p, webSocketError) {\n      // sendWebSocketError() was called. Finish sending and close the connection.\n      auto promise = kj::mv(p);\n      webSocketError = kj::none;\n      co_return co_await promise;\n    }\n\n    if (upgraded) {\n      // We've upgraded to WebSocket, and by now we should have closed the WebSocket.\n      if (!webSocketOrConnectClosed) {\n        // This is gonna segfault later so abort now instead.\n        KJ_LOG(FATAL, \"Accepted WebSocket object must be destroyed before HttpService \"\n                      \"request handler completes.\");\n        abort();\n      }\n\n      // Once we start a WebSocket there's no going back to HTTP.\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    if (currentMethod != kj::none) {\n      co_return co_await sendError();\n    }\n\n    if (httpOutput.isBroken()) {\n      // We started a response but didn't finish it. But HttpService returns success?\n      // Perhaps it decided that it doesn't want to finish this response. We'll have to\n      // disconnect here. If the response body is not complete (e.g. Content-Length not\n      // reached), the client should notice. We don't want to log an error because this\n      // condition might be intentional on the service's part.\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    co_await httpOutput.flush();\n\n    if (httpInput.canReuse()) {\n      // Things look clean. Go ahead and accept the next request.\n\n      if (closeAfterSend) {\n        // We sent Connection: close, so drop the connection now.\n        co_return BREAK_LOOP_CONN_ERR;\n      } else {\n        // Note that we don't have to handle server.draining here because we'll take care\n        // of it the next time around the loop.\n        co_return CONTINUE_LOOP;\n      }\n    } else {\n      // Apparently, the application did not read the request body. Maybe this is a bug,\n      // or maybe not: maybe the client tried to upload too much data and the application\n      // legitimately wants to cancel the upload without reading all it it.\n      //\n      // We have a problem, though: We did send a response, and we didn't send\n      // `Connection: close`, so the client may expect that it can send another request.\n      // Perhaps the client has even finished sending the previous request's body, in\n      // which case the moment it finishes receiving the response, it could be completely\n      // within its rights to start a new request. If we close the socket now, we might\n      // interrupt that new request.\n      //\n      // Or maybe we did send `Connection: close`, as indicated by `closeAfterSend` being\n      // true. Even in that case, we should still try to read and ignore the request,\n      // otherwise when we close the connection the client may get a \"connection reset\"\n      // error before they get a chance to actually read the response body that we sent\n      // them.\n      //\n      // There's no way we can get out of this perfectly cleanly. HTTP just isn't good\n      // enough at connection management. The best we can do is give the client some grace\n      // period and then abort the connection.\n\n      auto dummy = kj::heap<HttpDiscardingEntityWriter>();\n      auto lengthGrace = kj::evalNow([&]() {\n        return body->pumpTo(*dummy, server.settings.canceledUploadGraceBytes);\n      }).catch_([](kj::Exception&& e) -> uint64_t {\n        // Reading from the input failed in some way. This may actually be the whole\n        // reason we got here in the first place so don't propagate this error, just\n        // give up on discarding the input.\n        return 0;  // This zero is ignored but `canReuse()` will return false below.\n      }).then([this](uint64_t amount) {\n        if (httpInput.canReuse()) {\n          // Success, we can continue.\n          return true;\n        } else {\n          // Still more data. Give up.\n          return false;\n        }\n      });\n      lengthGrace = lengthGrace.attach(kj::mv(dummy), kj::mv(body));\n\n      auto timeGrace = server.timer.afterDelay(server.settings.canceledUploadGracePeriod)\n          .then([]() { return false; });\n\n      auto clean = co_await lengthGrace.exclusiveJoin(kj::mv(timeGrace));\n      if (clean && !closeAfterSend) {\n        // We recovered. Continue loop.\n        co_return CONTINUE_LOOP;\n      } else {\n        // Client still not done, or we sent Connection: close and so want to drop the\n        // connection anyway. Return broken.\n        co_return BREAK_LOOP_CONN_ERR;\n      }\n    }\n  }\n\n  kj::Own<kj::AsyncOutputStream> send(\n      uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n      kj::Maybe<uint64_t> expectedBodySize) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    currentMethod = kj::none;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n    kj::String lengthStr;\n\n    if (!closeAfterSend) {\n      // Check if application wants us to close connections.\n      //\n      // If the application used listenHttpCleanDrain() to listen, then it expects that after a\n      // clean drain, the connection is still open and can receive more requests. Otherwise, after\n      // receiving drain(), we will close the connection, so we should send a `Connection: close`\n      // header.\n      if (server.draining && !wantCleanDrain) {\n        closeAfterSend = true;\n      } else KJ_IF_SOME(c, server.settings.callbacks) {\n        // The application has registered its own callback to decide whether to send\n        // `Connection: close`.\n        if (c.shouldClose()) {\n          closeAfterSend = true;\n        }\n      }\n    }\n\n    if (closeAfterSend) {\n      connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"close\";\n    }\n\n    bool isHeadRequest = method.tryGet<HttpMethod>().map([](auto& m) {\n        return m == HttpMethod::HEAD;\n      }).orDefault(false);\n\n    if (statusCode == 204 || statusCode == 304) {\n      // No entity-body.\n    } else if (statusCode == 205) {\n      // Status code 205 also has no body, but unlike 204 and 304, it must explicitly encode an\n      // empty body, e.g. using content-length: 0. I'm guessing this is one of those things,\n      // where some early clients expected an explicit body while others assumed an empty body,\n      // and so the standard had to choose the common denominator.\n      //\n      // Spec: https://tools.ietf.org/html/rfc7231#section-6.3.6\n      connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = \"0\";\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      // HACK: We interpret a zero-length expected body length on responses to HEAD requests to\n      //   mean \"don't set a Content-Length header at all.\" This provides a way to omit a body\n      //   header on HEAD responses with non-null-body status codes. This is a hack that *only*\n      //   makes sense for HEAD responses.\n      if (!isHeadRequest || s > 0) {\n        lengthStr = kj::str(s);\n        connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = lengthStr;\n      }\n    } else {\n      connectionHeaders[HttpHeaders::BuiltinIndices::TRANSFER_ENCODING] = \"chunked\";\n    }\n\n    // For HEAD requests, if the application specified a Content-Length or Transfer-Encoding\n    // header, use that instead of whatever we decided above.\n    kj::ArrayPtr<kj::StringPtr> connectionHeadersArray = connectionHeaders;\n    if (isHeadRequest) {\n      if (headers.get(HttpHeaderId::CONTENT_LENGTH) != kj::none ||\n          headers.get(HttpHeaderId::TRANSFER_ENCODING) != kj::none) {\n        connectionHeadersArray = connectionHeadersArray\n            .slice(0, HttpHeaders::HEAD_RESPONSE_CONNECTION_HEADERS_COUNT);\n      }\n    }\n\n    httpOutput.writeHeaders(headers.serializeResponse(\n        statusCode, statusText, connectionHeadersArray));\n\n    kj::Own<kj::AsyncOutputStream> bodyStream;\n    if (isHeadRequest) {\n      // Ignore entity-body.\n      httpOutput.finishBody();\n      return heap<HttpDiscardingEntityWriter>();\n    } else if (statusCode == 204 || statusCode == 205 || statusCode == 304) {\n      // No entity-body.\n      httpOutput.finishBody();\n      return heap<HttpNullEntityWriter>();\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      return heap<HttpFixedLengthEntityWriter>(httpOutput, s);\n    } else {\n      return heap<HttpChunkedEntityWriter>(httpOutput);\n    }\n  }\n\n  kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n    auto& requestHeaders = httpInput.getHeaders();\n    KJ_REQUIRE(requestHeaders.isWebSocket(),\n        \"can't call acceptWebSocket() if the request headers didn't have Upgrade: WebSocket\");\n\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    KJ_REQUIRE(method.tryGet<HttpMethod>().map([](auto& m) {\n      return m == HttpMethod::GET;\n    }).orDefault(false), \"WebSocket must be initiated with a GET request.\");\n\n    if (requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_VERSION).orDefault(nullptr) != \"13\") {\n      return sendWebSocketError(\"The requested WebSocket version is not supported.\");\n    }\n\n    kj::String key;\n    KJ_IF_SOME(k, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_KEY)) {\n      key = kj::str(k);\n    } else {\n      return sendWebSocketError(\"Missing Sec-WebSocket-Key\");\n    }\n\n    kj::Maybe<CompressionParameters> acceptedParameters;\n    kj::String agreedParameters;\n    auto compressionMode = server.settings.webSocketCompressionMode;\n    if (compressionMode == HttpServerSettings::AUTOMATIC_COMPRESSION) {\n      // If AUTOMATIC_COMPRESSION is enabled, we ignore the `headers` passed by the application and\n      // strictly refer to the `requestHeaders` from the client.\n      KJ_IF_SOME(value, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // Perform compression parameter negotiation.\n        KJ_IF_SOME(config, _::tryParseExtensionOffers(value)) {\n          acceptedParameters = kj::mv(config);\n        }\n      }\n    } else if (compressionMode == HttpServerSettings::MANUAL_COMPRESSION) {\n      // If MANUAL_COMPRESSION is enabled, we use the `headers` passed in by the application, and\n      // try to find a configuration that respects both the server's preferred configuration,\n      // as well as the client's requested configuration.\n      KJ_IF_SOME(value, headers.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // First, we get the manual configuration using `headers`.\n        KJ_IF_SOME(manualConfig, _::tryParseExtensionOffers(value)) {\n          KJ_IF_SOME(requestOffers, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n            // Next, we to find a configuration that both the client and server can accept.\n            acceptedParameters = _::tryParseAllExtensionOffers(requestOffers, manualConfig);\n          }\n        }\n      }\n    }\n\n    auto websocketAccept = generateWebSocketAccept(key);\n\n    kj::StringPtr connectionHeaders[HttpHeaders::WEBSOCKET_CONNECTION_HEADERS_COUNT];\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_ACCEPT] = websocketAccept;\n    connectionHeaders[HttpHeaders::BuiltinIndices::UPGRADE] = \"websocket\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"Upgrade\";\n    KJ_IF_SOME(parameters, acceptedParameters) {\n      agreedParameters = _::generateExtensionResponse(parameters);\n      connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_EXTENSIONS] = agreedParameters;\n    }\n\n    // Since we're about to write headers, we should nullify `currentMethod`. This tells\n    // `sendError(kj::Exception)` (called from `HttpServer::Connection::startLoop()`) not to expose\n    // the `HttpService::Response&` reference to the HttpServer's error `handleApplicationError()`\n    // callback. This prevents the error handler from inadvertently trying to send another error on\n    // the connection.\n    currentMethod = kj::none;\n\n    httpOutput.writeHeaders(headers.serializeResponse(\n        101, \"Switching Protocols\", connectionHeaders));\n\n    upgraded = true;\n    // We need to give the WebSocket an Own<AsyncIoStream>, but we only have a reference. This is\n    // safe because the application is expected to drop the WebSocket object before returning\n    // from the request handler. For some extra safety, we check that webSocketOrConnectClosed has\n    // been set true when the handler returns.\n    auto deferNoteClosed = kj::defer([this]() { webSocketOrConnectClosed = true; });\n    kj::Own<kj::AsyncIoStream> ownStream(&stream, kj::NullDisposer::instance);\n    return upgradeToWebSocket(ownStream.attach(kj::mv(deferNoteClosed)),\n                              httpInput, httpOutput, kj::none, kj::mv(acceptedParameters),\n                             server.settings.webSocketErrorHandler);\n  }\n\n  kj::Promise<LoopResult> sendError(HttpHeaders::ProtocolError protocolError) {\n    closeAfterSend = true;\n\n    // Client protocol errors always happen on request headers parsing, before we call into the\n    // HttpService, meaning no response has been sent and we can provide a Response object.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleClientProtocolError(\n        kj::mv(protocolError), *this);\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> sendError(kj::Exception&& exception) {\n    closeAfterSend = true;\n\n    // We only provide the Response object if we know we haven't already sent a response.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleApplicationError(\n        kj::mv(exception), currentMethod.map([this](auto&&) -> Response& { return *this; }));\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> sendError() {\n    closeAfterSend = true;\n\n    // We can provide a Response object, since none has already been sent.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleNoResponse(*this);\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> finishSendingError(kj::Promise<void> promise) {\n    co_await promise;\n    if (!httpOutput.isBroken()) {\n      // Skip flush for broken streams, since it will throw an exception that may be worse than\n      // the one we just handled.\n      co_await httpOutput.flush();\n    }\n    co_return BREAK_LOOP_CONN_ERR;\n  }\n\n  kj::Own<WebSocket> sendWebSocketError(StringPtr errorMessage) {\n    kj::Exception exception = KJ_EXCEPTION(FAILED,\n        \"received bad WebSocket handshake\", errorMessage);\n    webSocketError = sendError(\n        HttpHeaders::ProtocolError { 400, \"Bad Request\", errorMessage, nullptr });\n    kj::throwRecoverableException(kj::mv(exception));\n\n    // Fallback path when exceptions are disabled.\n    class BrokenWebSocket final: public WebSocket {\n    public:\n      BrokenWebSocket(kj::Exception exception): exception(kj::mv(exception)) {}\n\n      kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> disconnect() override {\n        return kj::cp(exception);\n      }\n      void abort() override {\n        kj::throwRecoverableException(kj::cp(exception));\n      }\n      kj::Promise<void> whenAborted() override {\n        return kj::cp(exception);\n      }\n      kj::Promise<Message> receive(size_t maxSize) override {\n        return kj::cp(exception);\n      }\n\n      uint64_t sentByteCount() override { KJ_FAIL_ASSERT(\"received bad WebSocket handshake\"); }\n      uint64_t receivedByteCount() override { KJ_FAIL_ASSERT(\"received bad WebSocket handshake\"); }\n\n    private:\n      kj::Exception exception;\n    };\n\n    return kj::heap<BrokenWebSocket>(KJ_EXCEPTION(FAILED,\n        \"received bad WebSocket handshake\", errorMessage));\n  }\n\n  kj::Own<kj::AsyncIoStream> getConnectStream() {\n    // Returns an AsyncIoStream over the internal stream but that waits for a Promise to be\n    // resolved to allow writes after either accept or reject are called. Reads are allowed\n    // immediately.\n    KJ_REQUIRE(tunnelWriteGuard == kj::none, \"the tunnel stream was already retrieved\");\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    tunnelWriteGuard = kj::mv(paf.fulfiller);\n\n    kj::Own<kj::AsyncIoStream> ownStream(&stream, kj::NullDisposer::instance);\n    auto releasedBuffer = httpInput.releaseBuffer();\n    auto deferNoteClosed = kj::defer([this]() { webSocketOrConnectClosed = true; });\n    return kj::heap<AsyncIoStreamWithGuards>(\n        kj::heap<AsyncIoStreamWithInitialBuffer>(\n            kj::mv(ownStream),\n            kj::mv(releasedBuffer.buffer),\n            releasedBuffer.leftover).attach(kj::mv(deferNoteClosed)),\n        kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none),\n        kj::mv(paf.promise));\n  }\n\n  void accept(uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    currentMethod = kj::none;\n    KJ_ASSERT(method.is<HttpConnectMethod>(), \"only use accept() with CONNECT requests\");\n    KJ_REQUIRE(statusCode >= 200 && statusCode < 300, \"the statusCode must be 2xx for accept\");\n    tunnelRejected = kj::none;\n\n    auto& fulfiller = KJ_ASSERT_NONNULL(tunnelWriteGuard, \"the tunnel stream was not initialized\");\n    httpOutput.writeHeaders(headers.serializeResponse(statusCode, statusText));\n    auto promise = httpOutput.flush().then([&fulfiller]() {\n      fulfiller->fulfill();\n    }).eagerlyEvaluate(nullptr);\n    fulfiller = fulfiller.attach(kj::mv(promise));\n  }\n\n  kj::Own<kj::AsyncOutputStream> reject(\n      uint statusCode,\n      kj::StringPtr statusText,\n      const HttpHeaders& headers,\n      kj::Maybe<uint64_t> expectedBodySize) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    KJ_REQUIRE(method.is<HttpConnectMethod>(), \"Only use reject() with CONNECT requests.\");\n    KJ_REQUIRE(statusCode < 200 || statusCode >= 300, \"the statusCode must not be 2xx for reject.\");\n    tunnelRejected = Maybe<kj::Promise<LoopResult>>(BREAK_LOOP_CONN_OK);\n\n    auto& fulfiller = KJ_ASSERT_NONNULL(tunnelWriteGuard, \"the tunnel stream was not initialized\");\n    fulfiller->reject(KJ_EXCEPTION(DISCONNECTED, \"the tunnel request was rejected\"));\n    closeAfterSend = true;\n    return send(statusCode, statusText, headers, expectedBodySize);\n  }\n};\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       HttpService& service, Settings settings)\n    : HttpServer(timer, requestHeaderTable, &service, settings,\n                 kj::newPromiseAndFulfiller<void>()) {}\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       HttpServiceFactory serviceFactory, Settings settings)\n    : HttpServer(timer, requestHeaderTable, kj::mv(serviceFactory), settings,\n                 kj::newPromiseAndFulfiller<void>()) {}\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       kj::OneOf<HttpService*, HttpServiceFactory> service,\n                       Settings settings, kj::PromiseFulfillerPair<void> paf)\n    : timer(timer), requestHeaderTable(requestHeaderTable), service(kj::mv(service)),\n      settings(settings), onDrain(paf.promise.fork()), drainFulfiller(kj::mv(paf.fulfiller)),\n      tasks(*this) {}\n\nkj::Promise<void> HttpServer::drain() {\n  KJ_REQUIRE(!draining, \"you can only call drain() once\");\n\n  draining = true;\n  drainFulfiller->fulfill();\n\n  if (connectionCount == 0) {\n    return kj::READY_NOW;\n  } else {\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    zeroConnectionsFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n}\n\nkj::Promise<void> HttpServer::listenHttp(kj::ConnectionReceiver& port) {\n  return listenLoop(port).exclusiveJoin(onDrain.addBranch());\n}\n\nkj::Promise<void> HttpServer::listenLoop(kj::ConnectionReceiver& port) {\n  for (;;) {\n    auto connection = co_await port.accept();\n    tasks.add(kj::evalNow([&]() { return listenHttp(kj::mv(connection)); }));\n  }\n}\n\nkj::Promise<void> HttpServer::listenHttp(kj::Own<kj::AsyncIoStream> connection) {\n  auto promise = listenHttpImpl(*connection, false /* wantCleanDrain */).ignoreResult();\n\n  // eagerlyEvaluate() to maintain historical guarantee that this method eagerly closes the\n  // connection when done.\n  return promise.attach(kj::mv(connection)).eagerlyEvaluate(nullptr);\n}\n\nkj::Promise<bool> HttpServer::listenHttpCleanDrain(kj::AsyncIoStream& connection) {\n  return listenHttpImpl(connection, true /* wantCleanDrain */);\n}\n\nkj::Promise<bool> HttpServer::listenHttpImpl(kj::AsyncIoStream& connection, bool wantCleanDrain) {\n  kj::Own<HttpService> srv;\n\n  KJ_SWITCH_ONEOF(service) {\n    KJ_CASE_ONEOF(ptr, HttpService*) {\n      // Fake Own okay because we can assume the HttpService outlives this HttpServer, and we can\n      // assume `this` HttpServer outlives the returned `listenHttpCleanDrain()` promise, which will\n      // own the fake Own.\n      srv = kj::Own<HttpService>(ptr, kj::NullDisposer::instance);\n    }\n    KJ_CASE_ONEOF(func, HttpServiceFactory) {\n      srv = func(connection);\n    }\n  }\n\n  KJ_ASSERT(srv.get() != nullptr);\n\n  return listenHttpImpl(connection, [srv = kj::mv(srv)](SuspendableRequest&) mutable {\n    // This factory function will be owned by the Connection object, meaning the Connection object\n    // will own the HttpService. We also know that the Connection object outlives all\n    // service.request() promises (service.request() is called from a Connection member function).\n    // The Owns we return from this function are attached to the service.request() promises,\n    // meaning this factory function will outlive all Owns we return. So, it's safe to return a fake\n    // Own.\n    return kj::Own<HttpService>(srv.get(), kj::NullDisposer::instance);\n  }, kj::none /* suspendedRequest */, wantCleanDrain);\n}\n\nkj::Promise<bool> HttpServer::listenHttpCleanDrain(kj::AsyncIoStream& connection,\n    SuspendableHttpServiceFactory factory,\n    kj::Maybe<SuspendedRequest> suspendedRequest) {\n  // Don't close on drain, because a \"clean drain\" means we return the connection to the\n  // application still-open between requests so that it can continue serving future HTTP requests\n  // on it.\n  return listenHttpImpl(connection, kj::mv(factory), kj::mv(suspendedRequest),\n                        true /* wantCleanDrain */);\n}\n\nkj::Promise<bool> HttpServer::listenHttpImpl(kj::AsyncIoStream& connection,\n    SuspendableHttpServiceFactory factory,\n    kj::Maybe<SuspendedRequest> suspendedRequest,\n    bool wantCleanDrain) {\n  Connection obj(*this, connection, kj::mv(factory), kj::mv(suspendedRequest), wantCleanDrain);\n\n  // Start reading requests and responding to them, but immediately cancel processing if the client\n  // disconnects.\n  co_return co_await obj\n      .startLoop()\n      .exclusiveJoin(connection.whenWriteDisconnected().then([]() {return false;}))\n      // Eagerly evaluate so that we drop the connection when the promise resolves, even if the caller\n      // doesn't eagerly evaluate.\n      .eagerlyEvaluate(nullptr);\n}\n\nnamespace {\nvoid defaultHandleListenLoopException(kj::Exception&& exception) {\n  KJ_LOG(ERROR, \"unhandled exception in HTTP server\", exception);\n}\n}  // namespace\n\nvoid HttpServer::taskFailed(kj::Exception&& exception) {\n  KJ_IF_SOME(handler, settings.errorHandler) {\n    handler.handleListenLoopException(kj::mv(exception));\n  } else {\n    defaultHandleListenLoopException(kj::mv(exception));\n  }\n}\n\nHttpServer::SuspendedRequest::SuspendedRequest(\n    kj::Array<byte> bufferParam, kj::ArrayPtr<byte> leftoverParam,\n    kj::OneOf<HttpMethod, HttpConnectMethod> method,\n    kj::StringPtr url, HttpHeaders headers)\n    : buffer(kj::mv(bufferParam)),\n      leftover(leftoverParam),\n      method(method),\n      url(url),\n      headers(kj::mv(headers)) {\n  if (leftover.size() > 0) {\n    // We have a `leftover`; make sure it is a slice of `buffer`.\n    KJ_ASSERT(leftover.begin() >= buffer.begin() && leftover.begin() <= buffer.end());\n    KJ_ASSERT(leftover.end() >= buffer.begin() && leftover.end() <= buffer.end());\n  } else {\n    // We have no `leftover`, but we still expect it to point into `buffer` somewhere. This is\n    // important so that `messageHeaderEnd` is initialized correctly in HttpInputStreamImpl's\n    // constructor.\n    KJ_ASSERT(leftover.begin() >= buffer.begin() && leftover.begin() <= buffer.end());\n  }\n}\n\nHttpServer::SuspendedRequest HttpServer::SuspendableRequest::suspend() {\n  return connection.suspend(*this);\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleClientProtocolError(\n    HttpHeaders::ProtocolError protocolError, kj::HttpService::Response& response) {\n  // Default error handler implementation.\n\n  HttpHeaderTable headerTable {};\n  HttpHeaders headers(headerTable);\n  headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n  auto errorMessage = kj::str(\"ERROR: \", protocolError.description);\n  auto body = response.send(protocolError.statusCode, protocolError.statusMessage,\n                            headers, errorMessage.size());\n\n  return body->write(errorMessage.begin(), errorMessage.size())\n      .attach(kj::mv(errorMessage), kj::mv(body));\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleApplicationError(\n    kj::Exception exception, kj::Maybe<kj::HttpService::Response&> response) {\n  // Default error handler implementation.\n\n  if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n    // How do we tell an HTTP client that there was a transient network error, and it should\n    // try again immediately? There's no HTTP status code for this (503 is meant for \"try\n    // again later, not now\"). Here's an idea: Don't send any response; just close the\n    // connection, so that it looks like the connection between the HTTP client and server\n    // was dropped. A good client should treat this exactly the way we want.\n    //\n    // We also bail here to avoid logging the disconnection, which isn't very interesting.\n    return kj::READY_NOW;\n  }\n\n  KJ_IF_SOME(r, response) {\n    KJ_LOG(INFO, \"threw exception while serving HTTP response\", exception);\n\n    HttpHeaderTable headerTable {};\n    HttpHeaders headers(headerTable);\n    headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n    kj::String errorMessage;\n    kj::Own<AsyncOutputStream> body;\n\n    if (exception.getType() == kj::Exception::Type::OVERLOADED) {\n      errorMessage = kj::str(\n          \"ERROR: The server is temporarily unable to handle your request. Details:\\n\\n\", exception);\n      body = r.send(503, \"Service Unavailable\", headers, errorMessage.size());\n    } else if (exception.getType() == kj::Exception::Type::UNIMPLEMENTED) {\n      errorMessage = kj::str(\n          \"ERROR: The server does not implement this operation. Details:\\n\\n\", exception);\n      body = r.send(501, \"Not Implemented\", headers, errorMessage.size());\n    } else {\n      errorMessage = kj::str(\n          \"ERROR: The server threw an exception. Details:\\n\\n\", exception);\n      body = r.send(500, \"Internal Server Error\", headers, errorMessage.size());\n    }\n\n    return body->write(errorMessage.begin(), errorMessage.size())\n        .attach(kj::mv(errorMessage), kj::mv(body));\n  }\n\n  KJ_LOG(ERROR, \"HttpService threw exception after generating a partial response\",\n                \"too late to report error to client\", exception);\n  return kj::READY_NOW;\n}\n\nvoid HttpServerErrorHandler::handleListenLoopException(kj::Exception&& exception) {\n  defaultHandleListenLoopException(kj::mv(exception));\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleNoResponse(kj::HttpService::Response& response) {\n  HttpHeaderTable headerTable {};\n  HttpHeaders headers(headerTable);\n  headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n  constexpr auto errorMessage = \"ERROR: The HttpService did not generate a response.\"_kj;\n  auto body = response.send(500, \"Internal Server Error\", headers, errorMessage.size());\n\n  return body->write(errorMessage.begin(), errorMessage.size()).attach(kj::mv(body));\n}\n\n} // namespace kj\n"], "fixing_code": ["// Copyright (c) 2017 Sandstorm Development Group, Inc. and contributors\n// Licensed under the MIT License:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include \"http.h\"\n#include \"kj/exception.h\"\n#include \"url.h\"\n#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include <kj/string.h>\n#include <unordered_map>\n#include <stdlib.h>\n#include <kj/encoding.h>\n#include <deque>\n#include <queue>\n#include <map>\n#if KJ_HAS_ZLIB\n#include <zlib.h>\n#endif // KJ_HAS_ZLIB\n\nnamespace kj {\n\n// =======================================================================================\n// SHA-1 implementation from https://github.com/clibs/sha1\n//\n// The WebSocket standard depends on SHA-1. ARRRGGGHHHHH.\n//\n// Any old checksum would have served the purpose, or hell, even just returning the header\n// verbatim. But NO, they decided to throw a whole complicated hash algorithm in there, AND\n// THEY CHOSE A BROKEN ONE THAT WE OTHERWISE WOULDN'T NEED ANYMORE.\n//\n// TODO(cleanup): Move this to a shared hashing library. Maybe. Or maybe don't, because no one\n//   should be using SHA-1 anymore.\n//\n// THIS USAGE IS NOT SECURITY SENSITIVE. IF YOU REPORT A SECURITY ISSUE BECAUSE YOU SAW SHA1 IN THE\n// SOURCE CODE I WILL MAKE FUN OF YOU.\n\n/*\nSHA-1 in C\nBy Steve Reid <steve@edmweb.com>\n100% Public Domain\nTest Vectors (from FIPS PUB 180-1)\n\"abc\"\n  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D\n\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1\nA million repetitions of \"a\"\n  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F\n*/\n\n/* #define LITTLE_ENDIAN * This should be #define'd already, if true. */\n/* #define SHA1HANDSOFF * Copies data before messing with it. */\n\n#define SHA1HANDSOFF\n\ntypedef struct\n{\n    uint32_t state[5];\n    uint32_t count[2];\n    unsigned char buffer[64];\n} SHA1_CTX;\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\n/* blk0() and blk() perform the initial expand. */\n/* I got the idea of expanding during the round function from SSLeay */\n#if BYTE_ORDER == LITTLE_ENDIAN\n#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \\\n    |(rol(block->l[i],8)&0x00FF00FF))\n#elif BYTE_ORDER == BIG_ENDIAN\n#define blk0(i) block->l[i]\n#else\n#error \"Endianness not defined!\"\n#endif\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n\n/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */\n#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n\n\n/* Hash a single 512-bit block. This is the core of the algorithm. */\n\nvoid SHA1Transform(\n    uint32_t state[5],\n    const unsigned char buffer[64]\n)\n{\n    uint32_t a, b, c, d, e;\n\n    typedef union\n    {\n        unsigned char c[64];\n        uint32_t l[16];\n    } CHAR64LONG16;\n\n#ifdef SHA1HANDSOFF\n    CHAR64LONG16 block[1];      /* use array to appear as a pointer */\n\n    memcpy(block, buffer, 64);\n#else\n    /* The following had better never be used because it causes the\n     * pointer-to-const buffer to be cast into a pointer to non-const.\n     * And the result is written through.  I threw a \"const\" in, hoping\n     * this will cause a diagnostic.\n     */\n    CHAR64LONG16 *block = (const CHAR64LONG16 *) buffer;\n#endif\n    /* Copy context->state[] to working vars */\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    /* 4 rounds of 20 operations each. Loop unrolled. */\n    R0(a, b, c, d, e, 0);\n    R0(e, a, b, c, d, 1);\n    R0(d, e, a, b, c, 2);\n    R0(c, d, e, a, b, 3);\n    R0(b, c, d, e, a, 4);\n    R0(a, b, c, d, e, 5);\n    R0(e, a, b, c, d, 6);\n    R0(d, e, a, b, c, 7);\n    R0(c, d, e, a, b, 8);\n    R0(b, c, d, e, a, 9);\n    R0(a, b, c, d, e, 10);\n    R0(e, a, b, c, d, 11);\n    R0(d, e, a, b, c, 12);\n    R0(c, d, e, a, b, 13);\n    R0(b, c, d, e, a, 14);\n    R0(a, b, c, d, e, 15);\n    R1(e, a, b, c, d, 16);\n    R1(d, e, a, b, c, 17);\n    R1(c, d, e, a, b, 18);\n    R1(b, c, d, e, a, 19);\n    R2(a, b, c, d, e, 20);\n    R2(e, a, b, c, d, 21);\n    R2(d, e, a, b, c, 22);\n    R2(c, d, e, a, b, 23);\n    R2(b, c, d, e, a, 24);\n    R2(a, b, c, d, e, 25);\n    R2(e, a, b, c, d, 26);\n    R2(d, e, a, b, c, 27);\n    R2(c, d, e, a, b, 28);\n    R2(b, c, d, e, a, 29);\n    R2(a, b, c, d, e, 30);\n    R2(e, a, b, c, d, 31);\n    R2(d, e, a, b, c, 32);\n    R2(c, d, e, a, b, 33);\n    R2(b, c, d, e, a, 34);\n    R2(a, b, c, d, e, 35);\n    R2(e, a, b, c, d, 36);\n    R2(d, e, a, b, c, 37);\n    R2(c, d, e, a, b, 38);\n    R2(b, c, d, e, a, 39);\n    R3(a, b, c, d, e, 40);\n    R3(e, a, b, c, d, 41);\n    R3(d, e, a, b, c, 42);\n    R3(c, d, e, a, b, 43);\n    R3(b, c, d, e, a, 44);\n    R3(a, b, c, d, e, 45);\n    R3(e, a, b, c, d, 46);\n    R3(d, e, a, b, c, 47);\n    R3(c, d, e, a, b, 48);\n    R3(b, c, d, e, a, 49);\n    R3(a, b, c, d, e, 50);\n    R3(e, a, b, c, d, 51);\n    R3(d, e, a, b, c, 52);\n    R3(c, d, e, a, b, 53);\n    R3(b, c, d, e, a, 54);\n    R3(a, b, c, d, e, 55);\n    R3(e, a, b, c, d, 56);\n    R3(d, e, a, b, c, 57);\n    R3(c, d, e, a, b, 58);\n    R3(b, c, d, e, a, 59);\n    R4(a, b, c, d, e, 60);\n    R4(e, a, b, c, d, 61);\n    R4(d, e, a, b, c, 62);\n    R4(c, d, e, a, b, 63);\n    R4(b, c, d, e, a, 64);\n    R4(a, b, c, d, e, 65);\n    R4(e, a, b, c, d, 66);\n    R4(d, e, a, b, c, 67);\n    R4(c, d, e, a, b, 68);\n    R4(b, c, d, e, a, 69);\n    R4(a, b, c, d, e, 70);\n    R4(e, a, b, c, d, 71);\n    R4(d, e, a, b, c, 72);\n    R4(c, d, e, a, b, 73);\n    R4(b, c, d, e, a, 74);\n    R4(a, b, c, d, e, 75);\n    R4(e, a, b, c, d, 76);\n    R4(d, e, a, b, c, 77);\n    R4(c, d, e, a, b, 78);\n    R4(b, c, d, e, a, 79);\n    /* Add the working vars back into context.state[] */\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    /* Wipe variables */\n    a = b = c = d = e = 0;\n#ifdef SHA1HANDSOFF\n    memset(block, '\\0', sizeof(block));\n#endif\n}\n\n\n/* SHA1Init - Initialize new context */\n\nvoid SHA1Init(\n    SHA1_CTX * context\n)\n{\n    /* SHA1 initialization constants */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xEFCDAB89;\n    context->state[2] = 0x98BADCFE;\n    context->state[3] = 0x10325476;\n    context->state[4] = 0xC3D2E1F0;\n    context->count[0] = context->count[1] = 0;\n}\n\n\n/* Run your data through this. */\n\nvoid SHA1Update(\n    SHA1_CTX * context,\n    const unsigned char *data,\n    uint32_t len\n)\n{\n    uint32_t i;\n\n    uint32_t j;\n\n    j = context->count[0];\n    if ((context->count[0] += len << 3) < j)\n        context->count[1]++;\n    context->count[1] += (len >> 29);\n    j = (j >> 3) & 63;\n    if ((j + len) > 63)\n    {\n        memcpy(&context->buffer[j], data, (i = 64 - j));\n        SHA1Transform(context->state, context->buffer);\n        for (; i + 63 < len; i += 64)\n        {\n            SHA1Transform(context->state, &data[i]);\n        }\n        j = 0;\n    }\n    else\n        i = 0;\n    memcpy(&context->buffer[j], &data[i], len - i);\n}\n\n\n/* Add padding and return the message digest. */\n\nvoid SHA1Final(\n    unsigned char digest[20],\n    SHA1_CTX * context\n)\n{\n    unsigned i;\n\n    unsigned char finalcount[8];\n\n    unsigned char c;\n\n#if 0    /* untested \"improvement\" by DHR */\n    /* Convert context->count to a sequence of bytes\n     * in finalcount.  Second element first, but\n     * big-endian order within element.\n     * But we do it all backwards.\n     */\n    unsigned char *fcp = &finalcount[8];\n    for (i = 0; i < 2; i++)\n    {\n        uint32_t t = context->count[i];\n        int j;\n        for (j = 0; j < 4; t >>= 8, j++)\n            *--fcp = (unsigned char) t}\n#else\n    for (i = 0; i < 8; i++)\n    {\n        finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);      /* Endian independent */\n    }\n#endif\n    c = 0200;\n    SHA1Update(context, &c, 1);\n    while ((context->count[0] & 504) != 448)\n    {\n        c = 0000;\n        SHA1Update(context, &c, 1);\n    }\n    SHA1Update(context, finalcount, 8); /* Should cause a SHA1Transform() */\n    for (i = 0; i < 20; i++)\n    {\n        digest[i] = (unsigned char)\n            ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n    }\n    /* Wipe variables */\n    memset(context, '\\0', sizeof(*context));\n    memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\n// End SHA-1 implementation.\n// =======================================================================================\n\nstatic const char* METHOD_NAMES[] = {\n#define METHOD_NAME(id) #id,\nKJ_HTTP_FOR_EACH_METHOD(METHOD_NAME)\n#undef METHOD_NAME\n};\n\nkj::StringPtr KJ_STRINGIFY(HttpMethod method) {\n  auto index = static_cast<uint>(method);\n  KJ_ASSERT(index < size(METHOD_NAMES), \"invalid HTTP method\");\n\n  return METHOD_NAMES[index];\n}\n\nkj::StringPtr KJ_STRINGIFY(HttpConnectMethod method) {\n  return \"CONNECT\"_kj;\n}\n\nstatic kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> consumeHttpMethod(char*& ptr) {\n  char* p = ptr;\n\n#define EXPECT_REST(prefix, suffix) \\\n  if (strncmp(p, #suffix, sizeof(#suffix)-1) == 0) { \\\n    ptr = p + (sizeof(#suffix)-1); \\\n    return kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>>(HttpMethod::prefix##suffix); \\\n  } else { \\\n    return kj::none; \\\n  }\n\n  switch (*p++) {\n    case 'A': EXPECT_REST(A,CL)\n    case 'C':\n      switch (*p++) {\n        case 'H': EXPECT_REST(CH,ECKOUT)\n        case 'O':\n          switch (*p++) {\n            case 'P': EXPECT_REST(COP,Y)\n            case 'N':\n              if (strncmp(p, \"NECT\", 4) == 0) {\n                ptr = p + 4;\n                return kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>>(HttpConnectMethod());\n              } else {\n                return kj::none;\n              }\n            default: return kj::none;\n          }\n        default: return kj::none;\n      }\n    case 'D': EXPECT_REST(D,ELETE)\n    case 'G': EXPECT_REST(G,ET)\n    case 'H': EXPECT_REST(H,EAD)\n    case 'L': EXPECT_REST(L,OCK)\n    case 'M':\n      switch (*p++) {\n        case 'E': EXPECT_REST(ME,RGE)\n        case 'K':\n          switch (*p++) {\n            case 'A': EXPECT_REST(MKA,CTIVITY)\n            case 'C': EXPECT_REST(MKC,OL)\n            default: return kj::none;\n          }\n        case 'O': EXPECT_REST(MO,VE)\n        case 'S': EXPECT_REST(MS,EARCH)\n        default: return kj::none;\n      }\n    case 'N': EXPECT_REST(N,OTIFY)\n    case 'O': EXPECT_REST(O,PTIONS)\n    case 'P':\n      switch (*p++) {\n        case 'A': EXPECT_REST(PA,TCH)\n        case 'O': EXPECT_REST(PO,ST)\n        case 'R':\n          if (*p++ != 'O' || *p++ != 'P') return kj::none;\n          switch (*p++) {\n            case 'F': EXPECT_REST(PROPF,IND)\n            case 'P': EXPECT_REST(PROPP,ATCH)\n            default: return kj::none;\n          }\n        case 'U':\n          switch (*p++) {\n            case 'R': EXPECT_REST(PUR,GE)\n            case 'T': EXPECT_REST(PUT,)\n            default: return kj::none;\n          }\n        default: return kj::none;\n      }\n    case 'R': EXPECT_REST(R,EPORT)\n    case 'S':\n      switch (*p++) {\n        case 'E': EXPECT_REST(SE,ARCH)\n        case 'U': EXPECT_REST(SU,BSCRIBE)\n        default: return kj::none;\n      }\n    case 'T': EXPECT_REST(T,RACE)\n    case 'U':\n      if (*p++ != 'N') return kj::none;\n      switch (*p++) {\n        case 'L': EXPECT_REST(UNL,OCK)\n        case 'S': EXPECT_REST(UNS,UBSCRIBE)\n        default: return kj::none;\n      }\n    default: return kj::none;\n  }\n#undef EXPECT_REST\n}\n\nkj::Maybe<HttpMethod> tryParseHttpMethod(kj::StringPtr name) {\n  KJ_IF_SOME(method, tryParseHttpMethodAllowingConnect(name)) {\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) { return m; }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) { return kj::none; }\n    }\n    KJ_UNREACHABLE;\n  } else {\n    return kj::none;\n  }\n}\n\nkj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> tryParseHttpMethodAllowingConnect(\n    kj::StringPtr name) {\n  // const_cast OK because we don't actually access it. consumeHttpMethod() is also called by some\n  // code later than explicitly needs to use a non-const pointer.\n  char* ptr = const_cast<char*>(name.begin());\n  auto result = consumeHttpMethod(ptr);\n  if (*ptr == '\\0') {\n    return result;\n  } else {\n    return kj::none;\n  }\n}\n\n// =======================================================================================\n\nnamespace {\n\nconstexpr char WEBSOCKET_GUID[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n// From RFC6455.\n\nstatic kj::String generateWebSocketAccept(kj::StringPtr key) {\n  // WebSocket demands we do a SHA-1 here. ARRGHH WHY SHA-1 WHYYYYYY?\n  SHA1_CTX ctx;\n  byte digest[20];\n  SHA1Init(&ctx);\n  SHA1Update(&ctx, key.asBytes().begin(), key.size());\n  SHA1Update(&ctx, reinterpret_cast<const byte*>(WEBSOCKET_GUID), strlen(WEBSOCKET_GUID));\n  SHA1Final(digest, &ctx);\n  return kj::encodeBase64(digest);\n}\n\nconstexpr auto HTTP_SEPARATOR_CHARS = kj::parse::anyOfChars(\"()<>@,;:\\\\\\\"/[]?={} \\t\");\n// RFC2616 section 2.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\n\nconstexpr auto HTTP_TOKEN_CHARS =\n    kj::parse::controlChar.orChar('\\x7f')\n    .orGroup(kj::parse::whitespaceChar)\n    .orGroup(HTTP_SEPARATOR_CHARS)\n    .invert();\n// RFC2616 section 2.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\n\nconstexpr auto HTTP_HEADER_NAME_CHARS = HTTP_TOKEN_CHARS;\n// RFC2616 section 4.2: https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n\nstatic void requireValidHeaderName(kj::StringPtr name) {\n  for (char c: name) {\n    KJ_REQUIRE(HTTP_HEADER_NAME_CHARS.contains(c), \"invalid header name\", name);\n  }\n}\n\nstatic void requireValidHeaderValue(kj::StringPtr value) {\n  KJ_REQUIRE(HttpHeaders::isValidHeaderValue(value), \"invalid header value\",\n      kj::encodeCEscape(value));\n}\n\nstatic const char* BUILTIN_HEADER_NAMES[] = {\n  // Indexed by header ID, which includes connection headers, so we include those names too.\n#define HEADER_NAME(id, name) name,\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(HEADER_NAME)\n#undef HEADER_NAME\n};\n\n}  // namespace\n\n#define HEADER_ID(id, name) constexpr uint HttpHeaders::BuiltinIndices::id;\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(HEADER_ID)\n#undef HEADER_ID\n\n#define DEFINE_HEADER(id, name) \\\nconst HttpHeaderId HttpHeaderId::id(nullptr, HttpHeaders::BuiltinIndices::id);\nKJ_HTTP_FOR_EACH_BUILTIN_HEADER(DEFINE_HEADER)\n#undef DEFINE_HEADER\n\nkj::StringPtr HttpHeaderId::toString() const {\n  if (table == nullptr) {\n    KJ_ASSERT(id < kj::size(BUILTIN_HEADER_NAMES));\n    return BUILTIN_HEADER_NAMES[id];\n  } else {\n    return table->idToString(*this);\n  }\n}\n\nnamespace {\n\nstruct HeaderNameHash {\n  size_t operator()(kj::StringPtr s) const {\n    size_t result = 5381;\n    for (byte b: s.asBytes()) {\n      // Masking bit 0x20 makes our hash case-insensitive while conveniently avoiding any\n      // collisions that would matter for header names.\n      result = ((result << 5) + result) ^ (b & ~0x20);\n    }\n    return result;\n  }\n\n  bool operator()(kj::StringPtr a, kj::StringPtr b) const {\n    // TODO(perf): I wonder if we can beat strcasecmp() by masking bit 0x20 from each byte. We'd\n    //   need to prohibit one of the technically-legal characters '^' or '~' from header names\n    //   since they'd otherwise be ambiguous, but otherwise there is no ambiguity.\n#if _MSC_VER\n    return _stricmp(a.cStr(), b.cStr()) == 0;\n#else\n    return strcasecmp(a.cStr(), b.cStr()) == 0;\n#endif\n  }\n};\n\n}  // namespace\n\nstruct HttpHeaderTable::IdsByNameMap {\n  // TODO(perf): If we were cool we could maybe use a perfect hash here, since our hashtable is\n  //   static once built.\n\n  std::unordered_map<kj::StringPtr, uint, HeaderNameHash, HeaderNameHash> map;\n};\n\nHttpHeaderTable::Builder::Builder()\n    : table(kj::heap<HttpHeaderTable>()) {\n  table->buildStatus = BuildStatus::BUILDING;\n}\n\nHttpHeaderId HttpHeaderTable::Builder::add(kj::StringPtr name) {\n  requireValidHeaderName(name);\n\n  auto insertResult = table->idsByName->map.insert(std::make_pair(name, table->namesById.size()));\n  if (insertResult.second) {\n    table->namesById.add(name);\n  }\n  return HttpHeaderId(table, insertResult.first->second);\n}\n\nHttpHeaderTable::HttpHeaderTable()\n    : idsByName(kj::heap<IdsByNameMap>()) {\n#define ADD_HEADER(id, name) \\\n  namesById.add(name); \\\n  idsByName->map.insert(std::make_pair(name, HttpHeaders::BuiltinIndices::id));\n  KJ_HTTP_FOR_EACH_BUILTIN_HEADER(ADD_HEADER);\n#undef ADD_HEADER\n}\nHttpHeaderTable::~HttpHeaderTable() noexcept(false) {}\n\nkj::Maybe<HttpHeaderId> HttpHeaderTable::stringToId(kj::StringPtr name) const {\n  auto iter = idsByName->map.find(name);\n  if (iter == idsByName->map.end()) {\n    return kj::none;\n  } else {\n    return HttpHeaderId(this, iter->second);\n  }\n}\n\n// =======================================================================================\n\nbool HttpHeaders::isValidHeaderValue(kj::StringPtr value) {\n  for (char c: value) {\n    // While the HTTP spec suggests that only printable ASCII characters are allowed in header\n    // values, reality has a different opinion. See: https://github.com/httpwg/http11bis/issues/19\n    // We follow the browsers' lead.\n    if (c == '\\0' || c == '\\r' || c == '\\n') {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nHttpHeaders::HttpHeaders(const HttpHeaderTable& table)\n    : table(&table),\n      indexedHeaders(kj::heapArray<kj::StringPtr>(table.idCount())) {\n  KJ_ASSERT(\n      table.isReady(), \"HttpHeaders object was constructed from \"\n      \"HttpHeaderTable that wasn't fully built yet at the time of construction\");\n}\n\nvoid HttpHeaders::clear() {\n  for (auto& header: indexedHeaders) {\n    header = nullptr;\n  }\n\n  unindexedHeaders.clear();\n}\n\nsize_t HttpHeaders::size() const {\n  size_t result = unindexedHeaders.size();\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      ++result;\n    }\n  }\n  return result;\n}\n\nHttpHeaders HttpHeaders::clone() const {\n  HttpHeaders result(*table);\n\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      result.indexedHeaders[i] = result.cloneToOwn(indexedHeaders[i]);\n    }\n  }\n\n  result.unindexedHeaders.resize(unindexedHeaders.size());\n  for (auto i: kj::indices(unindexedHeaders)) {\n    result.unindexedHeaders[i].name = result.cloneToOwn(unindexedHeaders[i].name);\n    result.unindexedHeaders[i].value = result.cloneToOwn(unindexedHeaders[i].value);\n  }\n\n  return result;\n}\n\nHttpHeaders HttpHeaders::cloneShallow() const {\n  HttpHeaders result(*table);\n\n  for (auto i: kj::indices(indexedHeaders)) {\n    if (indexedHeaders[i] != nullptr) {\n      result.indexedHeaders[i] = indexedHeaders[i];\n    }\n  }\n\n  result.unindexedHeaders.resize(unindexedHeaders.size());\n  for (auto i: kj::indices(unindexedHeaders)) {\n    result.unindexedHeaders[i] = unindexedHeaders[i];\n  }\n\n  return result;\n}\n\nkj::StringPtr HttpHeaders::cloneToOwn(kj::StringPtr str) {\n  auto copy = kj::heapString(str);\n  kj::StringPtr result = copy;\n  ownedStrings.add(copy.releaseArray());\n  return result;\n}\n\n\nnamespace {\n\ntemplate <char... chars>\nconstexpr bool fastCaseCmp(const char* actual);\n\n}  // namespace\n\nbool HttpHeaders::isWebSocket() const {\n  return fastCaseCmp<'w', 'e', 'b', 's', 'o', 'c', 'k', 'e', 't'>(\n      get(HttpHeaderId::UPGRADE).orDefault(nullptr).cStr());\n}\n\nvoid HttpHeaders::set(HttpHeaderId id, kj::StringPtr value) {\n  id.requireFrom(*table);\n  requireValidHeaderValue(value);\n\n  indexedHeaders[id.id] = value;\n}\n\nvoid HttpHeaders::set(HttpHeaderId id, kj::String&& value) {\n  set(id, kj::StringPtr(value));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::add(kj::StringPtr name, kj::StringPtr value) {\n  requireValidHeaderName(name);\n  requireValidHeaderValue(value);\n\n  addNoCheck(name, value);\n}\n\nvoid HttpHeaders::add(kj::StringPtr name, kj::String&& value) {\n  add(name, kj::StringPtr(value));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::add(kj::String&& name, kj::String&& value) {\n  add(kj::StringPtr(name), kj::StringPtr(value));\n  takeOwnership(kj::mv(name));\n  takeOwnership(kj::mv(value));\n}\n\nvoid HttpHeaders::addNoCheck(kj::StringPtr name, kj::StringPtr value) {\n  KJ_IF_SOME(id, table->stringToId(name)) {\n    if (indexedHeaders[id.id] == nullptr) {\n      indexedHeaders[id.id] = value;\n    } else {\n      // Duplicate HTTP headers are equivalent to the values being separated by a comma.\n\n#if _MSC_VER\n      if (_stricmp(name.cStr(), \"set-cookie\") == 0) {\n#else\n      if (strcasecmp(name.cStr(), \"set-cookie\") == 0) {\n#endif\n        // Uh-oh, Set-Cookie will be corrupted if we try to concatenate it. We'll make it an\n        // unindexed header, which is weird, but the alternative is guaranteed corruption, so...\n        // TODO(cleanup): Maybe HttpHeaders should just special-case set-cookie in general?\n        unindexedHeaders.add(Header {name, value});\n      } else {\n        auto concat = kj::str(indexedHeaders[id.id], \", \", value);\n        indexedHeaders[id.id] = concat;\n        ownedStrings.add(concat.releaseArray());\n      }\n    }\n  } else {\n    unindexedHeaders.add(Header {name, value});\n  }\n}\n\nvoid HttpHeaders::takeOwnership(kj::String&& string) {\n  ownedStrings.add(string.releaseArray());\n}\nvoid HttpHeaders::takeOwnership(kj::Array<char>&& chars) {\n  ownedStrings.add(kj::mv(chars));\n}\nvoid HttpHeaders::takeOwnership(HttpHeaders&& otherHeaders) {\n  for (auto& str: otherHeaders.ownedStrings) {\n    ownedStrings.add(kj::mv(str));\n  }\n  otherHeaders.ownedStrings.clear();\n}\n\n// -----------------------------------------------------------------------------\n\nstatic inline const char* skipSpace(const char* p) {\n  for (;;) {\n    switch (*p) {\n      case '\\t':\n      case ' ':\n        ++p;\n        break;\n      default:\n        return p;\n    }\n  }\n}\nstatic inline char* skipSpace(char* p) {\n  return const_cast<char*>(skipSpace(const_cast<const char*>(p)));\n}\n\nstatic kj::Maybe<kj::StringPtr> consumeWord(char*& ptr) {\n  char* start = skipSpace(ptr);\n  char* p = start;\n\n  for (;;) {\n    switch (*p) {\n      case '\\0':\n        ptr = p;\n        return kj::StringPtr(start, p);\n\n      case '\\t':\n      case ' ': {\n        char* end = p++;\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      case '\\n':\n      case '\\r':\n        // Not expecting EOL!\n        return kj::none;\n\n      default:\n        ++p;\n        break;\n    }\n  }\n}\n\nstatic kj::Maybe<uint> consumeNumber(const char*& ptr) {\n  const char* start = skipSpace(ptr);\n  const char* p = start;\n\n  uint result = 0;\n\n  for (;;) {\n    const char c = *p;\n    if ('0' <= c && c <= '9') {\n      result = result * 10 + (c - '0');\n      ++p;\n    } else {\n      if (p == start) return kj::none;\n      ptr = p;\n      return result;\n    }\n  }\n}\nstatic kj::Maybe<uint> consumeNumber(char*& ptr) {\n  const char* constPtr = ptr;\n  auto result = consumeNumber(constPtr);\n  ptr = const_cast<char*>(constPtr);\n  return result;\n}\n\nstatic kj::StringPtr consumeLine(char*& ptr) {\n  char* start = skipSpace(ptr);\n  char* p = start;\n\n  for (;;) {\n    switch (*p) {\n      case '\\0':\n        ptr = p;\n        return kj::StringPtr(start, p);\n\n      case '\\r': {\n        char* end = p++;\n        if (*p == '\\n') ++p;\n\n        if (*p == ' ' || *p == '\\t') {\n          // Whoa, continuation line. These are deprecated, but historically a line starting with\n          // a space was treated as a continuation of the previous line. The behavior should be\n          // the same as if the \\r\\n were replaced with spaces, so let's do that here to prevent\n          // confusion later.\n          *end = ' ';\n          p[-1] = ' ';\n          break;\n        }\n\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      case '\\n': {\n        char* end = p++;\n\n        if (*p == ' ' || *p == '\\t') {\n          // Whoa, continuation line. These are deprecated, but historically a line starting with\n          // a space was treated as a continuation of the previous line. The behavior should be\n          // the same as if the \\n were replaced with spaces, so let's do that here to prevent\n          // confusion later.\n          *end = ' ';\n          break;\n        }\n\n        ptr = p;\n        *end = '\\0';\n        return kj::StringPtr(start, end);\n      }\n\n      default:\n        ++p;\n        break;\n    }\n  }\n}\n\nstatic kj::Maybe<kj::StringPtr> consumeHeaderName(char*& ptr) {\n  // Do NOT skip spaces before the header name. Leading spaces indicate a continuation line; they\n  // should have been handled in consumeLine().\n  char* p = ptr;\n\n  char* start = p;\n  while (HTTP_HEADER_NAME_CHARS.contains(*p)) ++p;\n  char* end = p;\n\n  p = skipSpace(p);\n\n  if (end == start || *p != ':') return kj::none;\n  ++p;\n\n  p = skipSpace(p);\n\n  *end = '\\0';\n  ptr = p;\n  return kj::StringPtr(start, end);\n}\n\nstatic char* trimHeaderEnding(kj::ArrayPtr<char> content) {\n  // Trim off the trailing \\r\\n from a header blob.\n\n  if (content.size() < 2) return nullptr;\n\n  // Remove trailing \\r\\n\\r\\n and replace with \\0 sentinel char.\n  char* end = content.end();\n\n  if (end[-1] != '\\n') return nullptr;\n  --end;\n  if (end[-1] == '\\r') --end;\n  *end = '\\0';\n\n  return end;\n}\n\nHttpHeaders::RequestOrProtocolError HttpHeaders::tryParseRequest(kj::ArrayPtr<char> content) {\n  KJ_SWITCH_ONEOF(tryParseRequestOrConnect(content)) {\n    KJ_CASE_ONEOF(request, Request) {\n      return kj::mv(request);\n    }\n    KJ_CASE_ONEOF(error, ProtocolError) {\n      return kj::mv(error);\n    }\n    KJ_CASE_ONEOF(connect, ConnectRequest) {\n      return ProtocolError { 501, \"Not Implemented\",\n          \"Unrecognized request method.\", content };\n    }\n  }\n  KJ_UNREACHABLE;\n}\n\nHttpHeaders::RequestConnectOrProtocolError HttpHeaders::tryParseRequestOrConnect(\n    kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) {\n    return ProtocolError { 400, \"Bad Request\",\n        \"Request headers have no terminal newline.\", content };\n  }\n\n  char* ptr = content.begin();\n\n  HttpHeaders::RequestConnectOrProtocolError result;\n\n  KJ_IF_SOME(method, consumeHttpMethod(ptr)) {\n    if (*ptr != ' ' && *ptr != '\\t') {\n      return ProtocolError { 501, \"Not Implemented\",\n          \"Unrecognized request method.\", content };\n    }\n    ++ptr;\n\n    kj::Maybe<StringPtr> path;\n    KJ_IF_SOME(p, consumeWord(ptr)) {\n      path = p;\n    } else {\n      return ProtocolError { 400, \"Bad Request\",\n          \"Invalid request line.\", content };\n    }\n\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) {\n        result = HttpHeaders::Request { m, KJ_ASSERT_NONNULL(path) };\n      }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) {\n        result = HttpHeaders::ConnectRequest { KJ_ASSERT_NONNULL(path) };\n      }\n    }\n  } else {\n    return ProtocolError { 501, \"Not Implemented\",\n        \"Unrecognized request method.\", content };\n  }\n\n  // Ignore rest of line. Don't care about \"HTTP/1.1\" or whatever.\n  consumeLine(ptr);\n\n  if (!parseHeaders(ptr, end)) {\n    return ProtocolError { 400, \"Bad Request\",\n        \"The headers sent by your client are not valid.\", content };\n  }\n\n  return result;\n}\n\nHttpHeaders::ResponseOrProtocolError HttpHeaders::tryParseResponse(kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Response headers have no terminal newline.\", content };\n  }\n\n  char* ptr = content.begin();\n\n  HttpHeaders::Response response;\n\n  KJ_IF_SOME(version, consumeWord(ptr)) {\n    if (!version.startsWith(\"HTTP/\")) {\n      return ProtocolError { 502, \"Bad Gateway\",\n          \"Invalid response status line (invalid protocol).\", content };\n    }\n  } else {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Invalid response status line (no spaces).\", content };\n  }\n\n  KJ_IF_SOME(code, consumeNumber(ptr)) {\n    response.statusCode = code;\n  } else {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"Invalid response status line (invalid status code).\", content };\n  }\n\n  response.statusText = consumeLine(ptr);\n\n  if (!parseHeaders(ptr, end)) {\n    return ProtocolError { 502, \"Bad Gateway\",\n        \"The headers sent by the server are not valid.\", content };\n  }\n\n  return response;\n}\n\nbool HttpHeaders::tryParse(kj::ArrayPtr<char> content) {\n  char* end = trimHeaderEnding(content);\n  if (end == nullptr) return false;\n\n  char* ptr = content.begin();\n  return parseHeaders(ptr, end);\n}\n\nbool HttpHeaders::parseHeaders(char* ptr, char* end) {\n  while (*ptr != '\\0') {\n    KJ_IF_SOME(name, consumeHeaderName(ptr)) {\n      kj::StringPtr line = consumeLine(ptr);\n      addNoCheck(name, line);\n    } else {\n      return false;\n    }\n  }\n\n  return ptr == end;\n}\n\n// -----------------------------------------------------------------------------\n\nkj::String HttpHeaders::serializeRequest(\n    HttpMethod method, kj::StringPtr url,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  return serialize(kj::toCharSequence(method), url, kj::StringPtr(\"HTTP/1.1\"), connectionHeaders);\n}\n\nkj::String HttpHeaders::serializeConnectRequest(\n    kj::StringPtr authority,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  return serialize(\"CONNECT\"_kj, authority, kj::StringPtr(\"HTTP/1.1\"), connectionHeaders);\n}\n\nkj::String HttpHeaders::serializeResponse(\n    uint statusCode, kj::StringPtr statusText,\n    kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  auto statusCodeStr = kj::toCharSequence(statusCode);\n\n  return serialize(kj::StringPtr(\"HTTP/1.1\"), statusCodeStr, statusText, connectionHeaders);\n}\n\nkj::String HttpHeaders::serialize(kj::ArrayPtr<const char> word1,\n                                  kj::ArrayPtr<const char> word2,\n                                  kj::ArrayPtr<const char> word3,\n                                  kj::ArrayPtr<const kj::StringPtr> connectionHeaders) const {\n  const kj::StringPtr space = \" \";\n  const kj::StringPtr newline = \"\\r\\n\";\n  const kj::StringPtr colon = \": \";\n\n  size_t size = 2;  // final \\r\\n\n  if (word1 != nullptr) {\n    size += word1.size() + word2.size() + word3.size() + 4;\n  }\n  KJ_ASSERT(connectionHeaders.size() <= indexedHeaders.size());\n  for (auto i: kj::indices(indexedHeaders)) {\n    kj::StringPtr value = i < connectionHeaders.size() ? connectionHeaders[i] : indexedHeaders[i];\n    if (value != nullptr) {\n      size += table->idToString(HttpHeaderId(table, i)).size() + value.size() + 4;\n    }\n  }\n  for (auto& header: unindexedHeaders) {\n    size += header.name.size() + header.value.size() + 4;\n  }\n\n  String result = heapString(size);\n  char* ptr = result.begin();\n\n  if (word1 != nullptr) {\n    ptr = kj::_::fill(ptr, word1, space, word2, space, word3, newline);\n  }\n  for (auto i: kj::indices(indexedHeaders)) {\n    kj::StringPtr value = i < connectionHeaders.size() ? connectionHeaders[i] : indexedHeaders[i];\n    if (value != nullptr) {\n      ptr = kj::_::fill(ptr, table->idToString(HttpHeaderId(table, i)), colon, value, newline);\n    }\n  }\n  for (auto& header: unindexedHeaders) {\n    ptr = kj::_::fill(ptr, header.name, colon, header.value, newline);\n  }\n  ptr = kj::_::fill(ptr, newline);\n\n  KJ_ASSERT(ptr == result.end());\n  return result;\n}\n\nkj::String HttpHeaders::toString() const {\n  return serialize(nullptr, nullptr, nullptr, nullptr);\n}\n\n// -----------------------------------------------------------------------------\n\n\nnamespace {\n\n// The functions below parse HTTP \"ranges specifiers\" set in `Range` headers and defined by\n// RFC9110 section 14.1: https://www.rfc-editor.org/rfc/rfc9110#section-14.1.\n//\n// Ranges specifiers consist of a case-insensitive \"range unit\", followed by an '=', followed by a\n// comma separated list of \"range specs\". We currently only support byte ranges, with a range unit\n// of \"bytes\". A byte range spec can either be:\n//\n// - An \"int range\" consisting of an inclusive start index, followed by a '-', and optionally an\n//   inclusive end index (e.g. \"2-5\", \"7-7\", \"9-\"). Satisfiable if the start index is less than\n//   the content length. Note the end index defaults to, and is clamped to the content length.\n// - A \"suffix range\" consisting of a '-', followed by a suffix length (e.g. \"-5\"). Satisfiable\n//   if the suffix length is not 0. Note the suffix length is clamped to the content length.\n//\n// A full ranges specifier might look something like \"bytes=2-4,-1\", which requests bytes 2 through\n// 4, and the last byte.\n//\n// A range spec is invalid if it doesn't match the above structure, or if it is an int range\n// with an end index > start index. A ranges specifier is invalid if any of its range specs are.\n// A byte ranges specifier is satisfiable if at least one of its range specs are.\n//\n// `tryParseHttpRangeHeader()` will return an array of satisfiable ranges, unless the ranges\n// specifier is invalid.\n\nstatic bool consumeByteRangeUnit(const char*& ptr) {\n  const char* p = ptr;\n  p = skipSpace(p);\n\n  // Match case-insensitive \"bytes\"\n  if (*p != 'b' && *p != 'B') return false;\n  if (*(++p) != 'y' && *p != 'Y') return false;\n  if (*(++p) != 't' && *p != 'T') return false;\n  if (*(++p) != 'e' && *p != 'E') return false;\n  if (*(++p) != 's' && *p != 'S') return false;\n  ++p;\n\n  p = skipSpace(p);\n  ptr = p;\n  return true;\n}\n\nstatic kj::Maybe<HttpByteRange> consumeIntRange(const char*& ptr, uint64_t contentLength) {\n  const char* p = ptr;\n  p = skipSpace(p);\n  uint firstPos;\n  KJ_IF_SOME(n, consumeNumber(p)) {\n    firstPos = n;\n  } else {\n    return kj::none;\n  }\n  p = skipSpace(p);\n  if (*(p++) != '-') return kj::none;\n  p = skipSpace(p);\n  auto maybeLastPos = consumeNumber(p);\n  p = skipSpace(p);\n\n  KJ_IF_SOME(lastPos, maybeLastPos) {\n    // \"An int-range is invalid if the last-pos value is present and less than the first-pos\"\n    if (firstPos > lastPos) return kj::none;\n    // \"if the value is greater than or equal to the current length of the representation data\n    // ... interpreted as the remainder of the representation\"\n    if (lastPos >= contentLength) lastPos = contentLength - 1;\n    ptr = p;\n    return HttpByteRange { firstPos, lastPos };\n  } else {\n    // \"if the last-pos value is absent ... interpreted as the remainder of the representation\"\n    ptr = p;\n    return HttpByteRange { firstPos, contentLength - 1 };\n  }\n}\n\nstatic kj::Maybe<HttpByteRange> consumeSuffixRange(const char*& ptr, uint64_t contentLength) {\n  const char* p = ptr;\n  p = skipSpace(p);\n  if (*(p++) != '-') return kj::none;\n  p = skipSpace(p);\n  uint suffixLength;\n  KJ_IF_SOME(n, consumeNumber(p)) {\n    suffixLength = n;\n  } else {\n    return kj::none;\n  }\n  p = skipSpace(p);\n\n  ptr = p;\n  if (suffixLength >= contentLength) {\n    // \"if the selected representation is shorter than the specified suffix-length, the entire\n    // representation is used\"\n    return HttpByteRange { 0, contentLength - 1 };\n  } else {\n    return HttpByteRange { contentLength - suffixLength, contentLength - 1 };\n  }\n}\n\nstatic kj::Maybe<HttpByteRange> consumeRangeSpec(const char*& ptr, uint64_t contentLength) {\n  KJ_IF_SOME(range, consumeIntRange(ptr, contentLength)) {\n    return range;\n  } else {\n    // If we failed to consume an int range, try consume a suffix range instead\n    return consumeSuffixRange(ptr, contentLength);\n  }\n}\n\n}  // namespace\n\nkj::String KJ_STRINGIFY(HttpByteRange range) {\n  return kj::str(range.start, \"-\", range.end);\n}\n\nHttpRanges tryParseHttpRangeHeader(kj::ArrayPtr<const char> value, uint64_t contentLength) {\n  const char* p = value.begin();\n  if (!consumeByteRangeUnit(p)) return HttpUnsatisfiableRange {};\n  if (*(p++) != '=') return HttpUnsatisfiableRange {};\n\n  auto fullRange = false;\n  kj::Vector<HttpByteRange> satisfiableRanges;\n  do {\n    KJ_IF_SOME(range, consumeRangeSpec(p, contentLength)) {\n      // Don't record more ranges if we've already recorded a full range\n      if (!fullRange && range.start <= range.end) {\n        if (range.start == 0 && range.end == contentLength - 1) {\n          // A range evaluated to the full range, but still need to check rest are valid\n          fullRange = true;\n        } else {\n          // \"a valid bytes range-spec is satisfiable if it is either:\n          // - an int-range with a first-pos that is less than the current length of the selected\n          //   representation or\n          // - a suffix-range with a non-zero suffix-length\"\n          satisfiableRanges.add(range);\n        }\n      }\n    } else {\n      // If we failed to parse a range, the whole range specification is invalid\n      return HttpUnsatisfiableRange {};\n    }\n  } while (*(p++) == ',');\n\n  if ((--p) != value.end()) return HttpUnsatisfiableRange {};\n  if (fullRange) return HttpEverythingRange {};\n  // \"A valid ranges-specifier is \"satisfiable\" if it contains at least one range-spec that is\n  // satisfiable\"\n  if (satisfiableRanges.size() == 0) return HttpUnsatisfiableRange {};\n  return satisfiableRanges.releaseAsArray();\n}\n\n// =======================================================================================\n\nnamespace {\n\ntemplate <typename Subclass>\nclass WrappableStreamMixin {\n  // Both HttpInputStreamImpl and HttpOutputStream are commonly wrapped by a class that implements\n  // a particular type of body stream, such as a chunked body or a fixed-length body. That wrapper\n  // stream is passed back to the application to represent the specific request/response body, but\n  // the inner stream is associated with the connection and can be reused several times.\n  //\n  // It's easy for applications to screw up and hold on to a body stream beyond the lifetime of the\n  // underlying connection stream. This used to lead to UAF. This mixin class implements behavior\n  // that detached the wrapper if it outlives the wrapped stream, so that we log errors and\n\npublic:\n  WrappableStreamMixin() = default;\n  WrappableStreamMixin(WrappableStreamMixin&& other) {\n    // This constructor is only needed by HttpServer::Connection::makeHttpInput() which constructs\n    // a new stream and returns it. Technically the constructor will always be elided anyway.\n    KJ_REQUIRE(other.currentWrapper == nullptr, \"can't move a wrappable object that has wrappers!\");\n  }\n  KJ_DISALLOW_COPY(WrappableStreamMixin);\n\n  ~WrappableStreamMixin() noexcept(false) {\n    KJ_IF_SOME(w, currentWrapper) {\n      KJ_LOG(ERROR, \"HTTP connection destroyed while HTTP body streams still exist\",\n          kj::getStackTrace());\n      w = nullptr;\n    }\n  }\n\n  void setCurrentWrapper(kj::Maybe<Subclass&>& weakRef) {\n    // Tracks the current `HttpEntityBodyReader` instance which is wrapping this stream. There can\n    // be only one wrapper at a time, and the wrapper must be destroyed before the underlying HTTP\n    // connection is torn down. The purpose of tracking the wrapper here is to detect when these\n    // rules are violated by apps, and log an error instead of going UB.\n    //\n    // `weakRef` is the wrapper's pointer to this object. If the underlying stream is destroyed\n    // before the wrapper, then `weakRef` will be nulled out.\n\n    // The API should prevent an app from obtaining multiple wrappers with the same backing stream.\n    KJ_ASSERT(currentWrapper == kj::none,\n        \"bug in KJ HTTP: only one HTTP stream wrapper can exist at a time\");\n\n    currentWrapper = weakRef;\n    weakRef = static_cast<Subclass&>(*this);\n  }\n\n  void unsetCurrentWrapper(kj::Maybe<Subclass&>& weakRef) {\n    auto& current = KJ_ASSERT_NONNULL(currentWrapper);\n    KJ_ASSERT(&current == &weakRef,\n        \"bug in KJ HTTP: unsetCurrentWrapper() passed the wrong wrapper\");\n    weakRef = kj::none;\n    currentWrapper = kj::none;\n  }\n\nprivate:\n  kj::Maybe<kj::Maybe<Subclass&>&> currentWrapper;\n};\n\n// =======================================================================================\n\nstatic constexpr size_t MIN_BUFFER = 4096;\nstatic constexpr size_t MAX_BUFFER = 128 * 1024;\nstatic constexpr size_t MAX_CHUNK_HEADER_SIZE = 32;\n\nclass HttpInputStreamImpl final: public HttpInputStream,\n                                 public WrappableStreamMixin<HttpInputStreamImpl> {\nprivate:\n  static kj::OneOf<HttpHeaders::Request, HttpHeaders::ConnectRequest> getResumingRequest(\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      kj::StringPtr url) {\n    KJ_SWITCH_ONEOF(method) {\n      KJ_CASE_ONEOF(m, HttpMethod) {\n        return HttpHeaders::Request { m, url };\n      }\n      KJ_CASE_ONEOF(m, HttpConnectMethod) {\n        return HttpHeaders::ConnectRequest { url };\n      }\n    }\n    KJ_UNREACHABLE;\n  }\npublic:\n  explicit HttpInputStreamImpl(AsyncInputStream& inner, const HttpHeaderTable& table)\n      : inner(inner), headerBuffer(kj::heapArray<char>(MIN_BUFFER)), headers(table) {\n  }\n\n  explicit HttpInputStreamImpl(AsyncInputStream& inner,\n      kj::Array<char> headerBufferParam,\n      kj::ArrayPtr<char> leftoverParam,\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      kj::StringPtr url,\n      HttpHeaders headers)\n      : inner(inner),\n        headerBuffer(kj::mv(headerBufferParam)),\n        // Initialize `messageHeaderEnd` to a safe value, we'll adjust it below.\n        messageHeaderEnd(leftoverParam.begin() - headerBuffer.begin()),\n        leftover(leftoverParam),\n        headers(kj::mv(headers)),\n        resumingRequest(getResumingRequest(method, url)) {\n    // Constructor used for resuming a SuspendedRequest.\n\n    // We expect headerBuffer to look like this:\n    //   <method> <url> <headers> [CR] LF <leftover>\n    // We initialized `messageHeaderEnd` to the beginning of `leftover`, but we want to point it at\n    // the CR (or LF if there's no CR).\n    KJ_REQUIRE(messageHeaderEnd >= 2 && leftover.end() <= headerBuffer.end(),\n        \"invalid SuspendedRequest - leftover buffer not where it should be\");\n    KJ_REQUIRE(leftover.begin()[-1] == '\\n', \"invalid SuspendedRequest - missing LF\");\n    messageHeaderEnd -= 1 + (leftover.begin()[-2] == '\\r');\n\n    // We're in the middle of a message, so set up our state as such. Note that the only way to\n    // resume a SuspendedRequest is via an HttpServer, but HttpServers never call\n    // `awaitNextMessage()` before fully reading request bodies, meaning we expect that\n    // `messageReadQueue` will never be used.\n    ++pendingMessageCount;\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    onMessageDone = kj::mv(paf.fulfiller);\n    messageReadQueue = kj::mv(paf.promise);\n  }\n\n  bool canReuse() {\n    return !broken && pendingMessageCount == 0;\n  }\n\n  bool canSuspend() {\n    // We are at a suspendable point if we've parsed the headers, but haven't consumed anything\n    // beyond that.\n    //\n    // TODO(cleanup): This is a silly check; we need a more defined way to track the state of the\n    //   stream.\n    bool messageHeaderEndLooksRight =\n        (leftover.begin() - (headerBuffer.begin() + messageHeaderEnd) == 2 &&\n            leftover.begin()[-1] == '\\n' && leftover.begin()[-2] == '\\r')\n        || (leftover.begin() - (headerBuffer.begin() + messageHeaderEnd) == 1 &&\n            leftover.begin()[-1] == '\\n');\n\n    return !broken && headerBuffer.size() > 0 && messageHeaderEndLooksRight;\n  }\n\n  // ---------------------------------------------------------------------------\n  // public interface\n\n  kj::Promise<Request> readRequest() override {\n    auto requestOrProtocolError = co_await readRequestHeaders();\n    auto request = KJ_REQUIRE_NONNULL(\n        requestOrProtocolError.tryGet<HttpHeaders::Request>(), \"bad request\");\n    auto body = getEntityBody(HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n\n    co_return { request.method, request.url, headers, kj::mv(body) };\n  }\n\n  kj::Promise<kj::OneOf<Request, Connect>> readRequestAllowingConnect() override {\n    auto requestOrProtocolError = co_await readRequestHeaders();\n    KJ_SWITCH_ONEOF(requestOrProtocolError) {\n      KJ_CASE_ONEOF(request, HttpHeaders::Request) {\n        auto body = getEntityBody(HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n        co_return HttpInputStream::Request { request.method, request.url, headers, kj::mv(body) };\n      }\n      KJ_CASE_ONEOF(request, HttpHeaders::ConnectRequest) {\n        auto body = getEntityBody(HttpInputStreamImpl::REQUEST, HttpConnectMethod(), 0, headers);\n        co_return HttpInputStream::Connect { request.authority, headers, kj::mv(body) };\n      }\n      KJ_CASE_ONEOF(error, HttpHeaders::ProtocolError) {\n        KJ_FAIL_REQUIRE(\"bad request\");\n      }\n    }\n    KJ_UNREACHABLE;\n  }\n\n  kj::Promise<Response> readResponse(HttpMethod requestMethod) override {\n    auto responseOrProtocolError = co_await readResponseHeaders();\n    auto response = KJ_REQUIRE_NONNULL(\n        responseOrProtocolError.tryGet<HttpHeaders::Response>(), \"bad response\");\n    auto body = getEntityBody(HttpInputStreamImpl::RESPONSE, requestMethod,\n                              response.statusCode, headers);\n\n    co_return { response.statusCode, response.statusText, headers, kj::mv(body) };\n  }\n\n  kj::Promise<Message> readMessage() override {\n    auto textOrError = co_await readMessageHeaders();\n    KJ_REQUIRE(textOrError.is<kj::ArrayPtr<char>>(), \"bad message\");\n    auto text = textOrError.get<kj::ArrayPtr<char>>();\n    headers.clear();\n    KJ_REQUIRE(headers.tryParse(text), \"bad message\");\n    auto body = getEntityBody(HttpInputStreamImpl::RESPONSE, HttpMethod::GET, 0, headers);\n\n    co_return { headers, kj::mv(body) };\n  }\n\n  // ---------------------------------------------------------------------------\n  // Stream locking: While an entity-body is being read, the body stream \"locks\" the underlying\n  // HTTP stream. Once the entity-body is complete, we can read the next pipelined message.\n\n  void finishRead() {\n    // Called when entire request has been read.\n\n    KJ_REQUIRE_NONNULL(onMessageDone)->fulfill();\n    onMessageDone = kj::none;\n    --pendingMessageCount;\n  }\n\n  void abortRead() {\n    // Called when a body input stream was destroyed without reading to the end.\n\n    KJ_REQUIRE_NONNULL(onMessageDone)->reject(KJ_EXCEPTION(FAILED,\n        \"application did not finish reading previous HTTP response body\",\n        \"can't read next pipelined request/response\"));\n    onMessageDone = kj::none;\n    broken = true;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  kj::Promise<bool> awaitNextMessage() override {\n    // Waits until more data is available, but doesn't consume it. Returns false on EOF.\n    //\n    // Used on the server after a request is handled, to check for pipelined requests.\n    //\n    // Used on the client to detect when idle connections are closed from the server end. (In this\n    // case, the promise always returns false or is canceled.)\n\n    if (resumingRequest != kj::none) {\n      // We're resuming a request, so report that we have a message.\n      co_return true;\n    }\n\n    if (onMessageDone != kj::none) {\n      // We're still working on reading the previous body.\n      auto fork = messageReadQueue.fork();\n      messageReadQueue = fork.addBranch();\n      co_await fork;\n    }\n\n    for (;;) {\n      snarfBufferedLineBreak();\n\n      if (!lineBreakBeforeNextHeader && leftover != nullptr) {\n        co_return true;\n      }\n\n      auto amount = co_await inner.tryRead(headerBuffer.begin(), 1, headerBuffer.size());\n      if (amount == 0) {\n        co_return false;\n      }\n\n      leftover = headerBuffer.slice(0, amount);\n    }\n  }\n\n  bool isCleanDrain() {\n    // Returns whether we can cleanly drain the stream at this point.\n    if (onMessageDone != kj::none) return false;\n    snarfBufferedLineBreak();\n    return !lineBreakBeforeNextHeader && leftover == nullptr;\n  }\n\n  kj::Promise<kj::OneOf<kj::ArrayPtr<char>, HttpHeaders::ProtocolError>> readMessageHeaders() {\n    ++pendingMessageCount;\n    auto paf = kj::newPromiseAndFulfiller<void>();\n\n    auto nextMessageReady = kj::mv(messageReadQueue);\n    messageReadQueue = kj::mv(paf.promise);\n\n    co_await nextMessageReady;\n    onMessageDone = kj::mv(paf.fulfiller);\n\n    co_return co_await readHeader(HeaderType::MESSAGE, 0, 0);\n  }\n\n  kj::Promise<kj::OneOf<uint64_t, HttpHeaders::ProtocolError>> readChunkHeader() {\n    KJ_REQUIRE(onMessageDone != kj::none);\n\n    // We use the portion of the header after the end of message headers.\n    auto textOrError = co_await readHeader(HeaderType::CHUNK, messageHeaderEnd, messageHeaderEnd);\n\n    KJ_SWITCH_ONEOF(textOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        KJ_REQUIRE(text.size() > 0) { break; }\n\n        uint64_t value = 0;\n        for (char c: text) {\n          if ('0' <= c && c <= '9') {\n            value = value * 16 + (c - '0');\n          } else if ('a' <= c && c <= 'f') {\n            value = value * 16 + (c - 'a' + 10);\n          } else if ('A' <= c && c <= 'F') {\n            value = value * 16 + (c - 'A' + 10);\n          } else {\n            KJ_FAIL_REQUIRE(\"invalid HTTP chunk size\", text, text.asBytes()) { break; }\n            co_return value;\n          }\n        }\n\n        co_return value;\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline kj::Promise<HttpHeaders::RequestConnectOrProtocolError> readRequestHeaders() {\n    KJ_IF_SOME(resuming, resumingRequest) {\n      KJ_DEFER(resumingRequest = kj::none);\n      co_return HttpHeaders::RequestConnectOrProtocolError(resuming);\n    }\n\n    auto textOrError = co_await readMessageHeaders();\n    KJ_SWITCH_ONEOF(textOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        headers.clear();\n        co_return headers.tryParseRequestOrConnect(text);\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline kj::Promise<HttpHeaders::ResponseOrProtocolError> readResponseHeaders() {\n    // Note: readResponseHeaders() could be called multiple times concurrently when pipelining\n    //   requests. readMessageHeaders() will serialize these, but it's important not to mess with\n    //   state (like calling headers.clear()) before said serialization has taken place.\n    auto headersOrError = co_await readMessageHeaders();\n    KJ_SWITCH_ONEOF(headersOrError) {\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        co_return protocolError;\n      }\n      KJ_CASE_ONEOF(text, kj::ArrayPtr<char>) {\n        headers.clear();\n        co_return headers.tryParseResponse(text);\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  inline const HttpHeaders& getHeaders() const { return headers; }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n    // Read message body data.\n\n    KJ_REQUIRE(onMessageDone != kj::none);\n\n    if (leftover == nullptr) {\n      // No leftovers. Forward directly to inner stream.\n      co_return co_await inner.tryRead(buffer, minBytes, maxBytes);\n    } else if (leftover.size() >= maxBytes) {\n      // Didn't even read the entire leftover buffer.\n      memcpy(buffer, leftover.begin(), maxBytes);\n      leftover = leftover.slice(maxBytes, leftover.size());\n      co_return maxBytes;\n    } else {\n      // Read the entire leftover buffer, plus some.\n      memcpy(buffer, leftover.begin(), leftover.size());\n      size_t copied = leftover.size();\n      leftover = nullptr;\n      if (copied >= minBytes) {\n        // Got enough to stop here.\n        co_return copied;\n      } else {\n        // Read the rest from the underlying stream.\n        auto n = co_await inner.tryRead(reinterpret_cast<byte*>(buffer) + copied,\n                             minBytes - copied, maxBytes - copied);\n        co_return n + copied;\n      }\n    }\n  }\n\n  enum RequestOrResponse {\n    REQUEST,\n    RESPONSE\n  };\n\n  kj::Own<kj::AsyncInputStream> getEntityBody(\n      RequestOrResponse type,\n      kj::OneOf<HttpMethod, HttpConnectMethod> method,\n      uint statusCode,\n      const kj::HttpHeaders& headers);\n\n  struct ReleasedBuffer {\n    kj::Array<byte> buffer;\n    kj::ArrayPtr<byte> leftover;\n  };\n\n  ReleasedBuffer releaseBuffer() {\n    return { headerBuffer.releaseAsBytes(), leftover.asBytes() };\n  }\n\n  kj::Promise<void> discard(AsyncOutputStream &output, size_t maxBytes) {\n    // Used to read and discard the input during error handling.\n    return inner.pumpTo(output, maxBytes).ignoreResult();\n  }\n\nprivate:\n  AsyncInputStream& inner;\n  kj::Array<char> headerBuffer;\n\n  size_t messageHeaderEnd = 0;\n  // Position in headerBuffer where the message headers end -- further buffer space can\n  // be used for chunk headers.\n\n  kj::ArrayPtr<char> leftover;\n  // Data in headerBuffer that comes immediately after the header content, if any.\n\n  HttpHeaders headers;\n  // Parsed headers, after a call to parseAwaited*().\n\n  kj::Maybe<kj::OneOf<HttpHeaders::Request, HttpHeaders::ConnectRequest>> resumingRequest;\n  // Non-null if we're resuming a SuspendedRequest.\n\n  bool lineBreakBeforeNextHeader = false;\n  // If true, the next await should expect to start with a spurious '\\n' or '\\r\\n'. This happens\n  // as a side-effect of HTTP chunked encoding, where such a newline is added to the end of each\n  // chunk, for no good reason.\n\n  bool broken = false;\n  // Becomes true if the caller failed to read the whole entity-body before closing the stream.\n\n  uint pendingMessageCount = 0;\n  // Number of reads we have queued up.\n\n  kj::Promise<void> messageReadQueue = kj::READY_NOW;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> onMessageDone;\n  // Fulfill once the current message has been completely read. Unblocks reading of the next\n  // message headers.\n\n  enum class HeaderType {\n    MESSAGE,\n    CHUNK\n  };\n\n  kj::Promise<kj::OneOf<kj::ArrayPtr<char>, HttpHeaders::ProtocolError>> readHeader(\n      HeaderType type, size_t bufferStart, size_t bufferEnd) {\n    // Reads the HTTP message header or a chunk header (as in transfer-encoding chunked) and\n    // returns the buffer slice containing it.\n    //\n    // The main source of complication here is that we want to end up with one continuous buffer\n    // containing the result, and that the input is delimited by newlines rather than by an upfront\n    // length.\n\n    for (;;) {\n      kj::Promise<size_t> readPromise = nullptr;\n\n      // Figure out where we're reading from.\n      if (leftover != nullptr) {\n        // Some data is still left over from the previous message, so start with that.\n\n        // This can only happen if this is the initial run through the loop.\n        KJ_ASSERT(bufferStart == bufferEnd);\n\n        // OK, set bufferStart and bufferEnd to both point to the start of the leftover, and then\n        // fake a read promise as if we read the bytes from the leftover.\n        bufferStart = leftover.begin() - headerBuffer.begin();\n        bufferEnd = bufferStart;\n        readPromise = leftover.size();\n        leftover = nullptr;\n      } else {\n        // Need to read more data from the underlying stream.\n\n        if (bufferEnd == headerBuffer.size()) {\n          // Out of buffer space.\n\n          // Maybe we can move bufferStart backwards to make more space at the end?\n          size_t minStart = type == HeaderType::MESSAGE ? 0 : messageHeaderEnd;\n\n          if (bufferStart > minStart) {\n            // Move to make space.\n            memmove(headerBuffer.begin() + minStart, headerBuffer.begin() + bufferStart,\n                    bufferEnd - bufferStart);\n            bufferEnd = bufferEnd - bufferStart + minStart;\n            bufferStart = minStart;\n          } else {\n            // Really out of buffer space. Grow the buffer.\n            if (type != HeaderType::MESSAGE) {\n              // Can't grow because we'd invalidate the HTTP headers.\n              kj::throwFatalException(KJ_EXCEPTION(FAILED, \"invalid HTTP chunk size\"));\n            }\n            if (headerBuffer.size() >= MAX_BUFFER) {\n              co_return HttpHeaders::ProtocolError {\n                  .statusCode = 431,\n                  .statusMessage = \"Request Header Fields Too Large\",\n                  .description = \"header too large.\" };\n            }\n            auto newBuffer = kj::heapArray<char>(headerBuffer.size() * 2);\n            memcpy(newBuffer.begin(), headerBuffer.begin(), headerBuffer.size());\n            headerBuffer = kj::mv(newBuffer);\n          }\n        }\n\n        // How many bytes will we read?\n        size_t maxBytes = headerBuffer.size() - bufferEnd;\n\n        if (type == HeaderType::CHUNK) {\n          // Roughly limit the amount of data we read to MAX_CHUNK_HEADER_SIZE.\n          // TODO(perf): This is mainly to avoid copying a lot of body data into our buffer just to\n          //   copy it again when it is read. But maybe the copy would be cheaper than overhead of\n          //   extra event loop turns?\n          KJ_REQUIRE(bufferEnd - bufferStart <= MAX_CHUNK_HEADER_SIZE, \"invalid HTTP chunk size\");\n          maxBytes = kj::min(maxBytes, MAX_CHUNK_HEADER_SIZE);\n        }\n\n        readPromise = inner.read(headerBuffer.begin() + bufferEnd, 1, maxBytes);\n      }\n\n      auto amount = co_await readPromise;\n\n      if (lineBreakBeforeNextHeader) {\n        // Hackily deal with expected leading line break.\n        if (bufferEnd == bufferStart && headerBuffer[bufferEnd] == '\\r') {\n          ++bufferEnd;\n          --amount;\n        }\n\n        if (amount > 0 && headerBuffer[bufferEnd] == '\\n') {\n          lineBreakBeforeNextHeader = false;\n          ++bufferEnd;\n          --amount;\n\n          // Cut the leading line break out of the buffer entirely.\n          bufferStart = bufferEnd;\n        }\n\n        if (amount == 0) {\n          continue;\n        }\n      }\n\n      size_t pos = bufferEnd;\n      size_t newEnd = pos + amount;\n\n      for (;;) {\n        // Search for next newline.\n        char* nl = reinterpret_cast<char*>(\n            memchr(headerBuffer.begin() + pos, '\\n', newEnd - pos));\n        if (nl == nullptr) {\n          // No newline found. Wait for more data.\n          bufferEnd = newEnd;\n          break;\n        }\n\n        // Is this newline which we found the last of the header? For a chunk header, always. For\n        // a message header, we search for two newlines in a row. We accept either \"\\r\\n\" or just\n        // \"\\n\" as a newline sequence (though the standard requires \"\\r\\n\").\n        if (type == HeaderType::CHUNK ||\n            (nl - headerBuffer.begin() >= 4 &&\n             ((nl[-1] == '\\r' && nl[-2] == '\\n') || (nl[-1] == '\\n')))) {\n          // OK, we've got all the data!\n\n          size_t endIndex = nl + 1 - headerBuffer.begin();\n          size_t leftoverStart = endIndex;\n\n          // Strip off the last newline from end.\n          endIndex -= 1 + (nl[-1] == '\\r');\n\n          if (type == HeaderType::MESSAGE) {\n            if (headerBuffer.size() - newEnd < MAX_CHUNK_HEADER_SIZE) {\n              // Ugh, there's not enough space for the secondary await buffer. Grow once more.\n              auto newBuffer = kj::heapArray<char>(headerBuffer.size() * 2);\n              memcpy(newBuffer.begin(), headerBuffer.begin(), headerBuffer.size());\n              headerBuffer = kj::mv(newBuffer);\n            }\n            messageHeaderEnd = endIndex;\n          } else {\n            // For some reason, HTTP specifies that there will be a line break after each chunk.\n            lineBreakBeforeNextHeader = true;\n          }\n\n          auto result = headerBuffer.slice(bufferStart, endIndex);\n          leftover = headerBuffer.slice(leftoverStart, newEnd);\n          co_return result;\n        } else {\n          pos = nl - headerBuffer.begin() + 1;\n        }\n      }\n\n      // If we're here, we broke out of the inner loop because we need to read more data.\n    }\n  }\n\n  void snarfBufferedLineBreak() {\n    // Slightly-crappy code to snarf the expected line break. This will actually eat the leading\n    // regex /\\r*\\n?/.\n    while (lineBreakBeforeNextHeader && leftover.size() > 0) {\n      if (leftover[0] == '\\r') {\n        leftover = leftover.slice(1, leftover.size());\n      } else if (leftover[0] == '\\n') {\n        leftover = leftover.slice(1, leftover.size());\n        lineBreakBeforeNextHeader = false;\n      } else {\n        // Err, missing line break, whatever.\n        lineBreakBeforeNextHeader = false;\n      }\n    }\n  }\n};\n\n// -----------------------------------------------------------------------------\n\nclass HttpEntityBodyReader: public kj::AsyncInputStream {\npublic:\n  HttpEntityBodyReader(HttpInputStreamImpl& inner) {\n    inner.setCurrentWrapper(weakInner);\n  }\n  ~HttpEntityBodyReader() noexcept(false) {\n    if (!finished) {\n      KJ_IF_SOME(inner, weakInner) {\n        inner.unsetCurrentWrapper(weakInner);\n        inner.abortRead();\n      } else {\n        // Since we're in a destructor, log an error instead of throwing.\n        KJ_LOG(ERROR, \"HTTP body input stream outlived underlying connection\", kj::getStackTrace());\n      }\n    }\n  }\n\nprotected:\n  HttpInputStreamImpl& getInner() {\n    KJ_IF_SOME(i, weakInner) {\n      return i;\n    } else if (finished) {\n      // This is a bug in the implementations in this file, not the app.\n      KJ_FAIL_ASSERT(\"bug in KJ HTTP: tried to access inner stream after it had been released\");\n    } else {\n      KJ_FAIL_REQUIRE(\"HTTP body input stream outlived underlying connection\");\n    }\n  }\n\n  void doneReading() {\n    auto& inner = getInner();\n    inner.unsetCurrentWrapper(weakInner);\n    finished = true;\n    inner.finishRead();\n  }\n\n  inline bool alreadyDone() { return weakInner == kj::none; }\n\nprivate:\n  kj::Maybe<HttpInputStreamImpl&> weakInner;\n  bool finished = false;\n};\n\nclass HttpNullEntityReader final: public HttpEntityBodyReader {\n  // Stream for an entity-body which is not present. Always returns EOF on read, but tryGetLength()\n  // may indicate non-zero in the special case of a response to a HEAD request.\n\npublic:\n  HttpNullEntityReader(HttpInputStreamImpl& inner, kj::Maybe<uint64_t> length)\n      : HttpEntityBodyReader(inner), length(length) {\n    // `length` is what to return from tryGetLength(). For a response to a HEAD request, this may\n    // be non-zero.\n    doneReading();\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return length;\n  }\n\nprivate:\n  kj::Maybe<uint64_t> length;\n};\n\nclass HttpConnectionCloseEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads until EOF.\n\npublic:\n  HttpConnectionCloseEntityReader(HttpInputStreamImpl& inner)\n      : HttpEntityBodyReader(inner) {}\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    if (alreadyDone()) co_return 0;\n\n    auto amount = co_await getInner().tryRead(buffer, minBytes, maxBytes);\n    if (amount < minBytes) {\n      doneReading();\n    }\n    co_return amount;\n  }\n};\n\nclass HttpFixedLengthEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads only up to a fixed length from the underlying stream, then emulates EOF.\n\npublic:\n  HttpFixedLengthEntityReader(HttpInputStreamImpl& inner, size_t length)\n      : HttpEntityBodyReader(inner), length(length) {\n    if (length == 0) doneReading();\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return length;\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(clean, \"can't read more data after a previous read didn't complete\");\n    clean = false;\n\n    size_t alreadyRead = 0;\n\n    for (;;) {\n      if (length == 0) {\n        clean = true;\n        co_return 0;\n      }\n\n      // We have to set minBytes to 1 here so that if we read any data at all, we update our\n      // counter immediately, so that we still know where we are in case of cancellation.\n      auto amount = co_await getInner().tryRead(buffer, 1, kj::min(maxBytes, length));\n\n      length -= amount;\n      if (length > 0) {\n        // We haven't reached the end of the entity body yet.\n        if (amount == 0) {\n          size_t expectedLength = length + alreadyRead;\n          kj::throwRecoverableException(KJ_EXCEPTION(\n            DISCONNECTED,\n            \"premature EOF in HTTP entity body; did not reach Content-Length\",\n            expectedLength,\n            alreadyRead\n          ));\n        } else if (amount < minBytes) {\n          // We requested a minimum 1 byte above, but our own caller actually set a larger minimum\n          // which has not yet been reached. Keep trying until we reach it.\n          buffer = reinterpret_cast<byte*>(buffer) + amount;\n          minBytes -= amount;\n          maxBytes -= amount;\n          alreadyRead += amount;\n          continue;\n        }\n      } else if (length == 0) {\n        doneReading();\n      }\n      clean = true;\n      co_return amount + alreadyRead;\n    }\n  }\n\nprivate:\n  size_t length;\n  bool clean = true;\n};\n\nclass HttpChunkedEntityReader final: public HttpEntityBodyReader {\n  // Stream which reads a Transfer-Encoding: Chunked stream.\n\npublic:\n  HttpChunkedEntityReader(HttpInputStreamImpl& inner)\n      : HttpEntityBodyReader(inner) {}\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(clean, \"can't read more data after a previous read didn't complete\");\n    clean = false;\n\n    size_t alreadyRead = 0;\n\n    for (;;) {\n      if (alreadyDone()) {\n        clean = true;\n        co_return alreadyRead;\n      } else if (chunkSize == 0) {\n        // Read next chunk header.\n        auto nextChunkSizeOrError = co_await getInner().readChunkHeader();\n        KJ_REQUIRE(nextChunkSizeOrError.is<uint64_t>(), \"bad header\");\n        auto nextChunkSize = nextChunkSizeOrError.get<uint64_t>();\n        if (nextChunkSize == 0) {\n          doneReading();\n        }\n\n        chunkSize = nextChunkSize;\n        continue;\n      } else {\n        // Read current chunk.\n        // We have to set minBytes to 1 here so that if we read any data at all, we update our\n        // counter immediately, so that we still know where we are in case of cancellation.\n        auto amount = co_await getInner().tryRead(buffer, 1, kj::min(maxBytes, chunkSize));\n\n        chunkSize -= amount;\n        if (amount == 0) {\n          kj::throwRecoverableException(KJ_EXCEPTION(DISCONNECTED, \"premature EOF in HTTP chunk\"));\n        } else if (amount < minBytes) {\n          // We requested a minimum 1 byte above, but our own caller actually set a larger minimum\n          // which has not yet been reached. Keep trying until we reach it.\n          buffer = reinterpret_cast<byte*>(buffer) + amount;\n          minBytes -= amount;\n          maxBytes -= amount;\n          alreadyRead += amount;\n          continue;\n        }\n        clean = true;\n        co_return alreadyRead + amount;\n      }\n    }\n  }\n\nprivate:\n  size_t chunkSize = 0;\n  bool clean = true;\n};\n\ntemplate <char...>\nstruct FastCaseCmp;\n\ntemplate <char first, char... rest>\nstruct FastCaseCmp<first, rest...> {\n  static constexpr bool apply(const char* actual) {\n    return\n      ('a' <= first && first <= 'z') || ('A' <= first && first <= 'Z')\n        ? (*actual | 0x20) == (first | 0x20) && FastCaseCmp<rest...>::apply(actual + 1)\n        : *actual == first && FastCaseCmp<rest...>::apply(actual + 1);\n  }\n};\n\ntemplate <>\nstruct FastCaseCmp<> {\n  static constexpr bool apply(const char* actual) {\n    return *actual == '\\0';\n  }\n};\n\ntemplate <char... chars>\nconstexpr bool fastCaseCmp(const char* actual) {\n  return FastCaseCmp<chars...>::apply(actual);\n}\n\n// Tests\nstatic_assert(fastCaseCmp<'f','O','o','B','1'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B','2'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'n','O','o','B','1'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B'>(\"FooB1\"), \"\");\nstatic_assert(!fastCaseCmp<'f','O','o','B','1','a'>(\"FooB1\"), \"\");\n\nkj::Own<kj::AsyncInputStream> HttpInputStreamImpl::getEntityBody(\n    RequestOrResponse type,\n    kj::OneOf<HttpMethod, HttpConnectMethod> method,\n    uint statusCode,\n    const kj::HttpHeaders& headers) {\n  KJ_REQUIRE(headerBuffer.size() > 0, \"Cannot get entity body after header buffer release.\");\n\n  auto isHeadRequest = method.tryGet<HttpMethod>().map([](auto& m) {\n    return m == HttpMethod::HEAD;\n  }).orDefault(false);\n\n  auto isConnectRequest = method.is<HttpConnectMethod>();\n\n  // Rules to determine how HTTP entity-body is delimited:\n  //   https://tools.ietf.org/html/rfc7230#section-3.3.3\n  // #1\n  if (type == RESPONSE) {\n    if (isHeadRequest) {\n      // Body elided.\n      kj::Maybe<uint64_t> length;\n      KJ_IF_SOME(cl, headers.get(HttpHeaderId::CONTENT_LENGTH)) {\n        length = strtoull(cl.cStr(), nullptr, 10);\n      } else if (headers.get(HttpHeaderId::TRANSFER_ENCODING) == kj::none) {\n        // HACK: Neither Content-Length nor Transfer-Encoding header in response to HEAD\n        //   request. Propagate this fact with a 0 expected body length.\n        length = uint64_t(0);\n      }\n      return kj::heap<HttpNullEntityReader>(*this, length);\n    } else if (isConnectRequest && statusCode >= 200 && statusCode < 300) {\n      KJ_FAIL_ASSERT(\"a CONNECT response with a 2xx status does not have an entity body to get\");\n    } else if (statusCode == 204 || statusCode == 304) {\n      // No body.\n      return kj::heap<HttpNullEntityReader>(*this, uint64_t(0));\n    }\n  }\n\n  // For CONNECT requests messages, we let the rest of the logic play out.\n  // We already check before here to ensure that Transfer-Encoding and\n  // Content-Length headers are not present in which case the code below\n  // does the right thing.\n\n  // #3\n  KJ_IF_SOME(te, headers.get(HttpHeaderId::TRANSFER_ENCODING)) {\n    // TODO(someday): Support pluggable transfer encodings? Or at least gzip?\n    // TODO(someday): Support stacked transfer encodings, e.g. \"gzip, chunked\".\n\n    // NOTE: #3\u00b63 is ambiguous about what should happen if Transfer-Encoding and Content-Length are\n    //   both present. It says that Transfer-Encoding takes precedence, but also that the request\n    //   \"ought to be handled as an error\", and that proxies \"MUST\" drop the Content-Length before\n    //   forwarding. We ignore the vague \"ought to\" part and implement the other two. (The\n    //   dropping of Content-Length will happen naturally if/when the message is sent back out to\n    //   the network.)\n    if (fastCaseCmp<'c','h','u','n','k','e','d'>(te.cStr())) {\n      // #3\u00b61\n      return kj::heap<HttpChunkedEntityReader>(*this);\n    } else if (fastCaseCmp<'i','d','e','n','t','i','t','y'>(te.cStr())) {\n      // #3\u00b62\n      KJ_REQUIRE(type != REQUEST, \"request body cannot have Transfer-Encoding other than chunked\");\n      return kj::heap<HttpConnectionCloseEntityReader>(*this);\n    }\n\n    KJ_FAIL_REQUIRE(\"unknown transfer encoding\", te) { break; };\n  }\n\n  // #4 and #5\n  KJ_IF_SOME(cl, headers.get(HttpHeaderId::CONTENT_LENGTH)) {\n    // NOTE: By spec, multiple Content-Length values are allowed as long as they are the same, e.g.\n    //   \"Content-Length: 5, 5, 5\". Hopefully no one actually does that...\n    char* end;\n    uint64_t length = strtoull(cl.cStr(), &end, 10);\n    if (end > cl.begin() && *end == '\\0') {\n      // #5\n      return kj::heap<HttpFixedLengthEntityReader>(*this, length);\n    } else {\n      // #4 (bad content-length)\n      KJ_FAIL_REQUIRE(\"invalid Content-Length header value\", cl);\n    }\n  }\n\n  // #6\n  if (type == REQUEST) {\n    // Lack of a Content-Length or Transfer-Encoding means no body for requests.\n    return kj::heap<HttpNullEntityReader>(*this, uint64_t(0));\n  }\n\n  // RFC 2616 permitted \"multipart/byteranges\" responses to be self-delimiting, but this was\n  // mercifully removed in RFC 7230, and new exceptions of this type are disallowed:\n  //   https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4\n  //   https://tools.ietf.org/html/rfc7230#page-81\n  // To be extra-safe, we'll reject a multipart/byteranges response that lacks transfer-encoding\n  // and content-length.\n  KJ_IF_SOME(type, headers.get(HttpHeaderId::CONTENT_TYPE)) {\n    if (type.startsWith(\"multipart/byteranges\")) {\n      KJ_FAIL_REQUIRE(\n          \"refusing to handle multipart/byteranges response without transfer-encoding nor \"\n          \"content-length due to ambiguity between RFC 2616 vs RFC 7230.\");\n    }\n  }\n\n  // #7\n  return kj::heap<HttpConnectionCloseEntityReader>(*this);\n}\n\n}  // namespace\n\nkj::Own<HttpInputStream> newHttpInputStream(\n    kj::AsyncInputStream& input, const HttpHeaderTable& table) {\n  return kj::heap<HttpInputStreamImpl>(input, table);\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpOutputStream: public WrappableStreamMixin<HttpOutputStream> {\npublic:\n  HttpOutputStream(AsyncOutputStream& inner): inner(inner) {}\n\n  bool isInBody() {\n    return inBody;\n  }\n\n  bool canReuse() {\n    return !inBody && !broken && !writeInProgress;\n  }\n\n  bool canWriteBodyData() {\n    return !writeInProgress && inBody;\n  }\n\n  bool isBroken() {\n    return broken;\n  }\n\n  void writeHeaders(String content) {\n    // Writes some header content and begins a new entity body.\n\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\") { return; }\n    KJ_REQUIRE(!inBody, \"previous HTTP message body incomplete; can't write more messages\");\n    inBody = true;\n\n    queueWrite(kj::mv(content));\n  }\n\n  void writeBodyData(kj::String content) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\") { return; }\n    KJ_REQUIRE(inBody) { return; }\n\n    queueWrite(kj::mv(content));\n  }\n\n  kj::Promise<void> writeBodyData(const void* buffer, size_t size) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    co_await inner.write(buffer, size);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n  }\n\n  kj::Promise<void> writeBodyData(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    co_await inner.write(pieces);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n  }\n\n  Promise<uint64_t> pumpBodyFrom(AsyncInputStream& input, uint64_t amount) {\n    KJ_REQUIRE(!writeInProgress, \"concurrent write()s not allowed\");\n    KJ_REQUIRE(inBody);\n\n    writeInProgress = true;\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n\n    co_await fork;\n    auto actual = co_await input.pumpTo(inner, amount);\n\n    // We intentionally don't use KJ_DEFER to clean this up because if an exception is thrown, we\n    // want to block further writes.\n    writeInProgress = false;\n    co_return actual;\n  }\n\n  void finishBody() {\n    // Called when entire body was written.\n\n    KJ_REQUIRE(inBody) { return; }\n    inBody = false;\n\n    if (writeInProgress) {\n      // It looks like the last write never completed -- possibly because it was canceled or threw\n      // an exception. We must treat this equivalent to abortBody().\n      broken = true;\n\n      // Cancel any writes that are still queued.\n      writeQueue = KJ_EXCEPTION(FAILED,\n          \"previous HTTP message body incomplete; can't write more messages\");\n    }\n  }\n\n  void abortBody() {\n    // Called if the application failed to write all expected body bytes.\n    KJ_REQUIRE(inBody) { return; }\n    inBody = false;\n    broken = true;\n\n    // Cancel any writes that are still queued.\n    writeQueue = KJ_EXCEPTION(FAILED,\n        \"previous HTTP message body incomplete; can't write more messages\");\n  }\n\n  kj::Promise<void> flush() {\n    auto fork = writeQueue.fork();\n    writeQueue = fork.addBranch();\n    return fork.addBranch();\n  }\n\n  Promise<void> whenWriteDisconnected() {\n    return inner.whenWriteDisconnected();\n  }\n\n  bool isWriteInProgress() { return writeInProgress; }\n\nprivate:\n  AsyncOutputStream& inner;\n  kj::Promise<void> writeQueue = kj::READY_NOW;\n  bool inBody = false;\n  bool broken = false;\n\n  bool writeInProgress = false;\n  // True if a write method has been called and has not completed successfully. In the case that\n  // a write throws an exception or is canceled, this remains true forever. In these cases, the\n  // underlying stream is in an inconsistent state and cannot be reused.\n\n  void queueWrite(kj::String content) {\n    // We only use queueWrite() in cases where we can take ownership of the write buffer, and where\n    // it is convenient if we can return `void` rather than a promise.  In particular, this is used\n    // to write headers and chunk boundaries. Writes of application data do not go into\n    // `writeQueue` because this would prevent cancellation. Instead, they wait until `writeQueue`\n    // is empty, then they make the write directly, using `writeInProgress` to detect and block\n    // concurrent writes.\n\n    writeQueue = writeQueue.then([this,content=kj::mv(content)]() mutable {\n      auto promise = inner.write(content.begin(), content.size());\n      return promise.attach(kj::mv(content));\n    });\n  }\n};\n\nclass HttpEntityBodyWriter: public kj::AsyncOutputStream {\npublic:\n  HttpEntityBodyWriter(HttpOutputStream& inner) {\n    inner.setCurrentWrapper(weakInner);\n  }\n  ~HttpEntityBodyWriter() noexcept(false) {\n    if (!finished) {\n      KJ_IF_SOME(inner, weakInner) {\n        inner.unsetCurrentWrapper(weakInner);\n        inner.abortBody();\n      } else {\n        // Since we're in a destructor, log an error instead of throwing.\n        KJ_LOG(ERROR, \"HTTP body output stream outlived underlying connection\",\n            kj::getStackTrace());\n      }\n    }\n  }\n\nprotected:\n  HttpOutputStream& getInner() {\n    KJ_IF_SOME(i, weakInner) {\n      return i;\n    } else if (finished) {\n      // This is a bug in the implementations in this file, not the app.\n      KJ_FAIL_ASSERT(\"bug in KJ HTTP: tried to access inner stream after it had been released\");\n    } else {\n      KJ_FAIL_REQUIRE(\"HTTP body output stream outlived underlying connection\");\n    }\n  }\n\n  void doneWriting() {\n    auto& inner = getInner();\n    inner.unsetCurrentWrapper(weakInner);\n    finished = true;\n    inner.finishBody();\n  }\n\n  inline bool alreadyDone() { return weakInner == kj::none; }\n\nprivate:\n  kj::Maybe<HttpOutputStream&> weakInner;\n  bool finished = false;\n};\n\nclass HttpNullEntityWriter final: public kj::AsyncOutputStream {\n  // Does not inherit HttpEntityBodyWriter because it doesn't actually write anything.\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return KJ_EXCEPTION(FAILED, \"HTTP message has no entity-body; can't write()\");\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return KJ_EXCEPTION(FAILED, \"HTTP message has no entity-body; can't write()\");\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n};\n\nclass HttpDiscardingEntityWriter final: public kj::AsyncOutputStream {\n  // Does not inherit HttpEntityBodyWriter because it doesn't actually write anything.\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n};\n\nclass HttpFixedLengthEntityWriter final: public HttpEntityBodyWriter {\npublic:\n  HttpFixedLengthEntityWriter(HttpOutputStream& inner, uint64_t length)\n      : HttpEntityBodyWriter(inner), length(length) {\n    if (length == 0) doneWriting();\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (size == 0) co_return;\n    KJ_REQUIRE(size <= length, \"overwrote Content-Length\");\n    length -= size;\n\n    co_await getInner().writeBodyData(buffer, size);\n    if (length == 0) doneWriting();\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    uint64_t size = 0;\n    for (auto& piece: pieces) size += piece.size();\n\n    if (size == 0) co_return;\n    KJ_REQUIRE(size <= length, \"overwrote Content-Length\");\n    length -= size;\n\n    co_await getInner().writeBodyData(pieces);\n    if (length == 0) doneWriting();\n  }\n\n  Maybe<Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input, uint64_t amount) override {\n    return pumpFrom(input, amount);\n  }\n\n  Promise<uint64_t> pumpFrom(AsyncInputStream& input, uint64_t amount) {\n    if (amount == 0) co_return 0;\n\n    bool overshot = amount > length;\n    if (overshot) {\n      // Hmm, the requested amount was too large, but it's common to specify kj::max as the amount\n      // to pump, in which case we pump to EOF. Let's try to verify whether EOF is where we\n      // expect it to be.\n      KJ_IF_SOME(available, input.tryGetLength()) {\n        // Great, the stream knows how large it is. If it's indeed larger than the space available\n        // then let's abort.\n        KJ_REQUIRE(available <= length, \"overwrote Content-Length\");\n      } else {\n        // OK, we have no idea how large the input is, so we'll have to check later.\n      }\n    }\n\n    amount = kj::min(amount, length);\n    length -= amount;\n    uint64_t actual = amount;\n\n    if (amount != 0) {\n      actual = co_await getInner().pumpBodyFrom(input, amount);\n      length += amount - actual;\n      if (length == 0) doneWriting();\n    }\n\n    if (overshot) {\n        if (actual == amount) {\n          // We read exactly the amount expected. In order to detect an overshoot, we have to\n          // try reading one more byte. Ugh.\n          static byte junk;\n          auto extra = co_await input.tryRead(&junk, 1, 1);\n          KJ_REQUIRE(extra == 0, \"overwrote Content-Length\");\n        } else {\n          // We actually read less data than requested so we couldn't have overshot. In fact, we\n          // undershot.\n        }\n    }\n\n    co_return actual;\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return getInner().whenWriteDisconnected();\n  }\n\nprivate:\n  uint64_t length;\n};\n\nclass HttpChunkedEntityWriter final: public HttpEntityBodyWriter {\npublic:\n  HttpChunkedEntityWriter(HttpOutputStream& inner)\n      : HttpEntityBodyWriter(inner) {}\n  ~HttpChunkedEntityWriter() noexcept(false) {\n    if (!alreadyDone()) {\n      auto& inner = getInner();\n      if (inner.canWriteBodyData()) {\n        inner.writeBodyData(kj::str(\"0\\r\\n\\r\\n\"));\n        doneWriting();\n      }\n    }\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (size == 0) return kj::READY_NOW;  // can't encode zero-size chunk since it indicates EOF.\n\n    auto header = kj::str(kj::hex(size), \"\\r\\n\");\n    auto parts = kj::heapArray<ArrayPtr<const byte>>(3);\n    parts[0] = header.asBytes();\n    parts[1] = kj::arrayPtr(reinterpret_cast<const byte*>(buffer), size);\n    parts[2] = kj::StringPtr(\"\\r\\n\").asBytes();\n\n    auto promise = getInner().writeBodyData(parts.asPtr());\n    return promise.attach(kj::mv(header), kj::mv(parts));\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    uint64_t size = 0;\n    for (auto& piece: pieces) size += piece.size();\n\n    if (size == 0) return kj::READY_NOW;  // can't encode zero-size chunk since it indicates EOF.\n\n    auto header = kj::str(kj::hex(size), \"\\r\\n\");\n    auto partsBuilder = kj::heapArrayBuilder<ArrayPtr<const byte>>(pieces.size() + 2);\n    partsBuilder.add(header.asBytes());\n    for (auto& piece: pieces) {\n      partsBuilder.add(piece);\n    }\n    partsBuilder.add(kj::StringPtr(\"\\r\\n\").asBytes());\n\n    auto parts = partsBuilder.finish();\n    auto promise = getInner().writeBodyData(parts.asPtr());\n    return promise.attach(kj::mv(header), kj::mv(parts));\n  }\n\n  Maybe<Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input, uint64_t amount) override {\n    KJ_IF_SOME(l, input.tryGetLength()) {\n      return pumpImpl(input, kj::min(amount, l));\n    } else {\n      // Need to use naive read/write loop.\n      return kj::none;\n    }\n  }\n\n  Promise<uint64_t> pumpImpl(AsyncInputStream& input, uint64_t length) {\n    // Hey, we know exactly how large the input is, so we can write just one chunk.\n    getInner().writeBodyData(kj::str(kj::hex(length), \"\\r\\n\"));\n    auto actual = co_await getInner().pumpBodyFrom(input, length);\n\n    if (actual < length) {\n      getInner().abortBody();\n      KJ_FAIL_REQUIRE(\n          \"value returned by input.tryGetLength() was greater than actual bytes transferred\") {\n        break;\n      }\n    }\n\n    getInner().writeBodyData(kj::str(\"\\r\\n\"));\n    co_return actual;\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return getInner().whenWriteDisconnected();\n  }\n};\n\n// =======================================================================================\n\nclass WebSocketImpl final: public WebSocket, private WebSocketErrorHandler {\npublic:\n  WebSocketImpl(kj::Own<kj::AsyncIoStream> stream,\n                kj::Maybe<EntropySource&> maskKeyGenerator,\n                kj::Maybe<CompressionParameters> compressionConfigParam = kj::none,\n                kj::Maybe<WebSocketErrorHandler&> errorHandler = kj::none,\n                kj::Array<byte> buffer = kj::heapArray<byte>(4096),\n                kj::ArrayPtr<byte> leftover = nullptr,\n                kj::Maybe<kj::Promise<void>> waitBeforeSend = kj::none)\n      : stream(kj::mv(stream)), maskKeyGenerator(maskKeyGenerator),\n        compressionConfig(kj::mv(compressionConfigParam)),\n        errorHandler(errorHandler.orDefault(*this)),\n        sendingPong(kj::mv(waitBeforeSend)),\n        recvBuffer(kj::mv(buffer)), recvData(leftover) {\n#if KJ_HAS_ZLIB\n    KJ_IF_SOME(config, compressionConfig) {\n      compressionContext.emplace(ZlibContext::Mode::COMPRESS, config);\n      decompressionContext.emplace(ZlibContext::Mode::DECOMPRESS, config);\n    }\n#else\n    KJ_REQUIRE(compressionConfig == kj::none,\n        \"WebSocket compression is only supported if KJ is compiled with Zlib.\");\n#endif // KJ_HAS_ZLIB\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    return sendImpl(OPCODE_BINARY, message);\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    return sendImpl(OPCODE_TEXT, message.asBytes());\n  }\n\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    kj::Array<byte> payload;\n    if (code == 1005) {\n      KJ_REQUIRE(reason.size() == 0, \"WebSocket close code 1005 cannot have a reason\");\n\n      // code 1005 -- leave payload empty\n    } else {\n      payload = heapArray<byte>(reason.size() + 2);\n      payload[0] = code >> 8;\n      payload[1] = code;\n      memcpy(payload.begin() + 2, reason.begin(), reason.size());\n    }\n\n    auto promise = sendImpl(OPCODE_CLOSE, payload);\n    return promise.attach(kj::mv(payload));\n  }\n\n  kj::Promise<void> disconnect() override {\n    KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n\n    KJ_IF_SOME(p, sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      currentlySending = true;\n      auto promise = p.then([this]() {\n        currentlySending = false;\n        return disconnect();\n      });\n      sendingPong = kj::none;\n      return promise;\n    }\n\n    disconnected = true;\n\n    stream->shutdownWrite();\n    return kj::READY_NOW;\n  }\n\n  void abort() override {\n    queuedPong = kj::none;\n    sendingPong = kj::none;\n    disconnected = true;\n    stream->abortRead();\n    stream->shutdownWrite();\n  }\n\n  kj::Promise<void> whenAborted() override {\n    return stream->whenWriteDisconnected();\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    size_t headerSize = Header::headerSize(recvData.begin(), recvData.size());\n\n    if (headerSize > recvData.size()) {\n      if (recvData.begin() != recvBuffer.begin()) {\n        // Move existing data to front of buffer.\n        if (recvData.size() > 0) {\n          memmove(recvBuffer.begin(), recvData.begin(), recvData.size());\n        }\n        recvData = recvBuffer.slice(0, recvData.size());\n      }\n\n      return stream->tryRead(recvData.end(), 1, recvBuffer.end() - recvData.end())\n          .then([this,maxSize](size_t actual) -> kj::Promise<Message> {\n        receivedBytes += actual;\n        if (actual == 0) {\n          if (recvData.size() > 0) {\n            return KJ_EXCEPTION(DISCONNECTED, \"WebSocket EOF in frame header\");\n          } else {\n            // It's incorrect for the WebSocket to disconnect without sending `Close`.\n            return KJ_EXCEPTION(DISCONNECTED,\n                \"WebSocket disconnected between frames without sending `Close`.\");\n          }\n        }\n\n        recvData = recvBuffer.slice(0, recvData.size() + actual);\n        return receive(maxSize);\n      });\n    }\n\n    auto& recvHeader = *reinterpret_cast<Header*>(recvData.begin());\n    if (recvHeader.hasRsv2or3()) {\n      return errorHandler.handleWebSocketProtocolError({\n        1002, \"Received frame had RSV bits 2 or 3 set\",\n      });\n    }\n\n    recvData = recvData.slice(headerSize, recvData.size());\n\n    size_t payloadLen = recvHeader.getPayloadLen();\n    if (payloadLen > maxSize) {\n      return errorHandler.handleWebSocketProtocolError({\n        1009, kj::str(\"Message is too large: \", payloadLen, \" > \", maxSize)\n      });\n    }\n\n    auto opcode = recvHeader.getOpcode();\n    bool isData = opcode < OPCODE_FIRST_CONTROL;\n    if (opcode == OPCODE_CONTINUATION) {\n      if (fragments.empty()) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Unexpected continuation frame\"\n        });\n      }\n\n      opcode = fragmentOpcode;\n    } else if (isData) {\n      if (!fragments.empty()) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Missing continuation frame\"\n        });\n      }\n    }\n\n    bool isFin = recvHeader.isFin();\n    bool isCompressed = false;\n\n    kj::Array<byte> message;           // space to allocate\n    byte* payloadTarget;               // location into which to read payload (size is payloadLen)\n    kj::Maybe<size_t> originalMaxSize; // maxSize from first `receive()` call\n    if (isFin) {\n      size_t amountToAllocate;\n      if (recvHeader.isCompressed() || fragmentCompressed) {\n        // Add 4 since we append 0x00 0x00 0xFF 0xFF to the tail of the payload.\n        // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n        amountToAllocate = payloadLen + 4;\n        isCompressed = true;\n      } else {\n        // Add space for NUL terminator when allocating text message.\n        amountToAllocate = payloadLen + (opcode == OPCODE_TEXT && isFin);\n      }\n\n      if (isData && !fragments.empty()) {\n        // Final frame of a fragmented message. Gather the fragments.\n        size_t offset = 0;\n        for (auto& fragment: fragments) offset += fragment.size();\n        message = kj::heapArray<byte>(offset + amountToAllocate);\n        originalMaxSize = offset + maxSize; // gives us back the original maximum message size.\n\n        offset = 0;\n        for (auto& fragment: fragments) {\n          memcpy(message.begin() + offset, fragment.begin(), fragment.size());\n          offset += fragment.size();\n        }\n        payloadTarget = message.begin() + offset;\n\n        fragments.clear();\n        fragmentOpcode = 0;\n        fragmentCompressed = false;\n      } else {\n        // Single-frame message.\n        message = kj::heapArray<byte>(amountToAllocate);\n        originalMaxSize = maxSize; // gives us back the original maximum message size.\n        payloadTarget = message.begin();\n      }\n    } else {\n      // Fragmented message, and this isn't the final fragment.\n      if (!isData) {\n        return errorHandler.handleWebSocketProtocolError({\n          1002, \"Received fragmented control frame\"\n        });\n      }\n\n      message = kj::heapArray<byte>(payloadLen);\n      payloadTarget = message.begin();\n      if (fragments.empty()) {\n        // This is the first fragment, so set the opcode.\n        fragmentOpcode = opcode;\n        fragmentCompressed = recvHeader.isCompressed();\n      }\n    }\n\n    Mask mask = recvHeader.getMask();\n\n    auto handleMessage =\n        [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,\n         isCompressed,message=kj::mv(message)]() mutable\n        -> kj::Promise<Message> {\n      if (!mask.isZero()) {\n        mask.apply(kj::arrayPtr(payloadTarget, payloadLen));\n      }\n\n      if (!isFin) {\n        // Add fragment to the list and loop.\n        auto newMax = maxSize - message.size();\n        fragments.add(kj::mv(message));\n        return receive(newMax);\n      }\n\n      switch (opcode) {\n        case OPCODE_CONTINUATION:\n          // Shouldn't get here; handled above.\n          KJ_UNREACHABLE;\n        case OPCODE_TEXT:\n#if KJ_HAS_ZLIB\n          if (isCompressed) {\n            auto& config = KJ_ASSERT_NONNULL(compressionConfig);\n            auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);\n            KJ_ASSERT(message.size() >= 4);\n            auto tail = message.slice(message.size() - 4, message.size());\n            // Note that we added an additional 4 bytes to `message`s capacity to account for these\n            // extra bytes. See `amountToAllocate` in the if(recvHeader.isCompressed()) block above.\n            const byte tailBytes[] = {0x00, 0x00, 0xFF, 0xFF};\n            memcpy(tail.begin(), tailBytes, sizeof(tailBytes));\n            // We have to append 0x00 0x00 0xFF 0xFF to the message before inflating.\n            // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n            if (config.inboundNoContextTakeover) {\n              // We must reset context on each message.\n              decompressor.reset();\n            }\n            bool addNullTerminator = true;\n            // We want to add the null terminator when receiving a TEXT message.\n            auto decompressed = decompressor.processMessage(message, originalMaxSize,\n                addNullTerminator);\n            return Message(kj::String(decompressed.releaseAsChars()));\n          }\n#endif // KJ_HAS_ZLIB\n          message.back() = '\\0';\n          return Message(kj::String(message.releaseAsChars()));\n        case OPCODE_BINARY:\n#if KJ_HAS_ZLIB\n          if (isCompressed) {\n            auto& config = KJ_ASSERT_NONNULL(compressionConfig);\n            auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);\n            KJ_ASSERT(message.size() >= 4);\n            auto tail = message.slice(message.size() - 4, message.size());\n            // Note that we added an additional 4 bytes to `message`s capacity to account for these\n            // extra bytes. See `amountToAllocate` in the if(recvHeader.isCompressed()) block above.\n            const byte tailBytes[] = {0x00, 0x00, 0xFF, 0xFF};\n            memcpy(tail.begin(), tailBytes, sizeof(tailBytes));\n            // We have to append 0x00 0x00 0xFF 0xFF to the message before inflating.\n            // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.2\n            if (config.inboundNoContextTakeover) {\n              // We must reset context on each message.\n              decompressor.reset();\n            }\n            auto decompressed = decompressor.processMessage(message, originalMaxSize);\n            return Message(decompressed.releaseAsBytes());\n          }\n#endif // KJ_HAS_ZLIB\n          return Message(message.releaseAsBytes());\n        case OPCODE_CLOSE:\n          if (message.size() < 2) {\n            return Message(Close { 1005, nullptr });\n          } else {\n            uint16_t status = (static_cast<uint16_t>(message[0]) << 8)\n                            | (static_cast<uint16_t>(message[1])     );\n            return Message(Close {\n              status, kj::heapString(message.slice(2, message.size()).asChars())\n            });\n          }\n        case OPCODE_PING:\n          // Send back a pong.\n          queuePong(kj::mv(message));\n          return receive(maxSize);\n        case OPCODE_PONG:\n          // Unsolicited pong. Ignore.\n          return receive(maxSize);\n        default:\n          return errorHandler.handleWebSocketProtocolError({\n            1002, kj::str(\"Unknown opcode \", opcode)\n          });\n      }\n    };\n\n    if (payloadLen <= recvData.size()) {\n      // All data already received.\n      memcpy(payloadTarget, recvData.begin(), payloadLen);\n      recvData = recvData.slice(payloadLen, recvData.size());\n      return handleMessage();\n    } else {\n      // Need to read more data.\n      memcpy(payloadTarget, recvData.begin(), recvData.size());\n      size_t remaining = payloadLen - recvData.size();\n      auto promise = stream->tryRead(payloadTarget + recvData.size(), remaining, remaining)\n          .then([this, remaining](size_t amount) {\n        receivedBytes += amount;\n        if (amount < remaining) {\n          kj::throwRecoverableException(KJ_EXCEPTION(DISCONNECTED, \"WebSocket EOF in message\"));\n        }\n      });\n      recvData = nullptr;\n      return promise.then(kj::mv(handleMessage));\n    }\n  }\n\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    KJ_IF_SOME(optOther, kj::dynamicDowncastIfAvailable<WebSocketImpl>(other)) {\n      // Both WebSockets are raw WebSockets, so we can pump the streams directly rather than read\n      // whole messages.\n\n      if ((maskKeyGenerator == kj::none) == (optOther.maskKeyGenerator == kj::none)) {\n        // Oops, it appears that we either believe we are the client side of both sockets, or we\n        // are the server side of both sockets. Since clients must \"mask\" their outgoing frames but\n        // servers must *not* do so, we can't direct-pump. Sad.\n        return kj::none;\n      }\n\n      KJ_IF_SOME(config, compressionConfig) {\n        KJ_IF_SOME(otherConfig, optOther.compressionConfig) {\n          if (config.outboundMaxWindowBits != otherConfig.inboundMaxWindowBits ||\n              config.inboundMaxWindowBits != otherConfig.outboundMaxWindowBits ||\n              config.inboundNoContextTakeover!= otherConfig.outboundNoContextTakeover ||\n              config.outboundNoContextTakeover!= otherConfig.inboundNoContextTakeover) {\n            // Compression configurations differ.\n            return kj::none;\n          }\n        } else {\n          // Only one websocket uses compression.\n          return kj::none;\n        }\n      } else {\n        if (optOther.compressionConfig != kj::none) {\n          // Only one websocket uses compression.\n          return kj::none;\n        }\n      }\n      // Both websockets use compatible compression configurations so we can pump directly.\n\n      // Check same error conditions as with sendImpl().\n      KJ_REQUIRE(!disconnected, \"WebSocket can't send after disconnect()\");\n      KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n      currentlySending = true;\n\n      // If the application chooses to pump messages out, but receives incoming messages normally\n      // with `receive()`, then we will receive pings and attempt to send pongs. But we can't\n      // safely insert a pong in the middle of a pumped stream. We kind of don't have a choice\n      // except to drop them on the floor, which is what will happen if we set `hasSentClose` true.\n      // Hopefully most apps that set up a pump do so in both directions at once, and so pings will\n      // flow through and pongs will flow back.\n      hasSentClose = true;\n\n      return optOther.optimizedPumpTo(*this);\n    }\n\n    return kj::none;\n  }\n\n  uint64_t sentByteCount() override { return sentBytes; }\n\n  uint64_t receivedByteCount() override { return receivedBytes; }\n\n  kj::Maybe<kj::String> getPreferredExtensions(ExtensionsContext ctx) override {\n    if (maskKeyGenerator == kj::none) {\n      // `this` is the server side of a websocket.\n      if (ctx == ExtensionsContext::REQUEST) {\n        // The other WebSocket is (going to be) the client side of a WebSocket, i.e. this is a\n        // proxying pass-through scenario. Optimization is possible. Confusingly, we have to use\n        // generateExtensionResponse() (even though we're generating headers to be passed in a\n        // request) because this is the function that correctly maps our config's inbound/outbound\n        // to client/server.\n        KJ_IF_SOME(c, compressionConfig) {\n          return _::generateExtensionResponse(c);\n        } else {\n          return kj::String(nullptr);  // recommend no compression\n        }\n      } else {\n        // We're apparently arranging to pump from the server side of one WebSocket to the server\n        // side of another; i.e., we are a server, we have two clients, and we're trying to pump\n        // between them. We cannot optimize this case, because the masking requirements are\n        // different for client->server vs. server->client messages. Since we have to parse out\n        // the messages anyway there's no point in trying to match extensions, so return null.\n        return kj::none;\n      }\n    } else {\n      // `this` is the client side of a websocket.\n      if (ctx == ExtensionsContext::RESPONSE) {\n        // The other WebSocket is (going to be) the server side of a WebSocket, i.e. this is a\n        // proxying pass-through scenario. Optimization is possible. Confusingly, we have to use\n        // generateExtensionRequest() (even though we're generating headers to be passed in a\n        // response) because this is the function that correctly maps our config's inbound/outbound\n        // to server/client.\n        KJ_IF_SOME(c, compressionConfig) {\n          CompressionParameters arr[1]{c};\n          return _::generateExtensionRequest(arr);\n        } else {\n          return kj::String(nullptr);  // recommend no compression\n        }\n      } else {\n        // We're apparently arranging to pump from the client side of one WebSocket to the client\n        // side of another; i.e., we are a client, we are connected to two servers, and we're\n        // trying to pump between them. We cannot optimize this case, because the masking\n        // requirements are different for client->server vs. server->client messages. Since we have\n        // to parse out the messages anyway there's no point in trying to match extensions, so\n        // return null.\n        return kj::none;\n      }\n    }\n  }\n\nprivate:\n  class Mask {\n  public:\n    Mask(): maskBytes { 0, 0, 0, 0 } {}\n    Mask(const byte* ptr) { memcpy(maskBytes, ptr, 4); }\n\n    Mask(kj::Maybe<EntropySource&> generator) {\n      KJ_IF_SOME(g, generator) {\n        g.generate(maskBytes);\n      } else {\n        memset(maskBytes, 0, 4);\n      }\n    }\n\n    void apply(kj::ArrayPtr<byte> bytes) const {\n      apply(bytes.begin(), bytes.size());\n    }\n\n    void copyTo(byte* output) const {\n      memcpy(output, maskBytes, 4);\n    }\n\n    bool isZero() const {\n      return (maskBytes[0] | maskBytes[1] | maskBytes[2] | maskBytes[3]) == 0;\n    }\n\n  private:\n    byte maskBytes[4];\n\n    void apply(byte* __restrict__ bytes, size_t size) const {\n      for (size_t i = 0; i < size; i++) {\n        bytes[i] ^= maskBytes[i % 4];\n      }\n    }\n  };\n\n  class Header {\n  public:\n    kj::ArrayPtr<const byte> compose(bool fin, bool compressed, byte opcode, uint64_t payloadLen,\n        Mask mask) {\n      bytes[0] = (fin ? FIN_MASK : 0) | (compressed ? RSV1_MASK : 0) | opcode;\n      // Note that we can only set the compressed bit on DATA frames.\n      bool hasMask = !mask.isZero();\n\n      size_t fill;\n\n      if (payloadLen < 126) {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | payloadLen;\n        if (hasMask) {\n          mask.copyTo(bytes + 2);\n          fill = 6;\n        } else {\n          fill = 2;\n        }\n      } else if (payloadLen < 65536) {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | 126;\n        bytes[2] = static_cast<byte>(payloadLen >> 8);\n        bytes[3] = static_cast<byte>(payloadLen     );\n        if (hasMask) {\n          mask.copyTo(bytes + 4);\n          fill = 8;\n        } else {\n          fill = 4;\n        }\n      } else {\n        bytes[1] = (hasMask ? USE_MASK_MASK : 0) | 127;\n        bytes[2] = static_cast<byte>(payloadLen >> 56);\n        bytes[3] = static_cast<byte>(payloadLen >> 48);\n        bytes[4] = static_cast<byte>(payloadLen >> 40);\n        bytes[5] = static_cast<byte>(payloadLen >> 42);\n        bytes[6] = static_cast<byte>(payloadLen >> 24);\n        bytes[7] = static_cast<byte>(payloadLen >> 16);\n        bytes[8] = static_cast<byte>(payloadLen >>  8);\n        bytes[9] = static_cast<byte>(payloadLen      );\n        if (hasMask) {\n          mask.copyTo(bytes + 10);\n          fill = 14;\n        } else {\n          fill = 10;\n        }\n      }\n\n      return arrayPtr(bytes, fill);\n    }\n\n    bool isFin() const {\n      return bytes[0] & FIN_MASK;\n    }\n\n    bool isCompressed() const {\n      return bytes[0] & RSV1_MASK;\n    }\n\n    bool hasRsv2or3() const {\n      return bytes[0] & RSV2_3_MASK;\n    }\n\n    byte getOpcode() const {\n      return bytes[0] & OPCODE_MASK;\n    }\n\n    uint64_t getPayloadLen() const {\n      byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n      if (payloadLen == 127) {\n        return (static_cast<uint64_t>(bytes[2]) << 56)\n             | (static_cast<uint64_t>(bytes[3]) << 48)\n             | (static_cast<uint64_t>(bytes[4]) << 40)\n             | (static_cast<uint64_t>(bytes[5]) << 32)\n             | (static_cast<uint64_t>(bytes[6]) << 24)\n             | (static_cast<uint64_t>(bytes[7]) << 16)\n             | (static_cast<uint64_t>(bytes[8]) <<  8)\n             | (static_cast<uint64_t>(bytes[9])      );\n      } else if (payloadLen == 126) {\n        return (static_cast<uint64_t>(bytes[2]) <<  8)\n             | (static_cast<uint64_t>(bytes[3])      );\n      } else {\n        return payloadLen;\n      }\n    }\n\n    Mask getMask() const {\n      if (bytes[1] & USE_MASK_MASK) {\n        byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n        if (payloadLen == 127) {\n          return Mask(bytes + 10);\n        } else if (payloadLen == 126) {\n          return Mask(bytes + 4);\n        } else {\n          return Mask(bytes + 2);\n        }\n      } else {\n        return Mask();\n      }\n    }\n\n    static size_t headerSize(byte const* bytes, size_t sizeSoFar) {\n      if (sizeSoFar < 2) return 2;\n\n      size_t required = 2;\n\n      if (bytes[1] & USE_MASK_MASK) {\n        required += 4;\n      }\n\n      byte payloadLen = bytes[1] & PAYLOAD_LEN_MASK;\n      if (payloadLen == 127) {\n        required += 8;\n      } else if (payloadLen == 126) {\n        required += 2;\n      }\n\n      return required;\n    }\n\n  private:\n    byte bytes[14];\n\n    static constexpr byte FIN_MASK = 0x80;\n    static constexpr byte RSV2_3_MASK = 0x30;\n    static constexpr byte RSV1_MASK = 0x40;\n    static constexpr byte OPCODE_MASK = 0x0f;\n\n    static constexpr byte USE_MASK_MASK = 0x80;\n    static constexpr byte PAYLOAD_LEN_MASK = 0x7f;\n  };\n\n#if KJ_HAS_ZLIB\n  class ZlibContext {\n    // `ZlibContext` is the WebSocket's interface to Zlib's compression/decompression functions.\n    // Depending on the `mode`, `ZlibContext` will act as a compressor or a decompressor.\n  public:\n    enum class Mode {\n      COMPRESS,\n      DECOMPRESS,\n    };\n\n    struct Result {\n      int processResult = 0;\n      kj::Array<const byte> buffer;\n      size_t size = 0; // Number of bytes used; size <= buffer.size().\n    };\n\n    ZlibContext(Mode mode, const CompressionParameters& config) : mode(mode) {\n      switch (mode) {\n        case Mode::COMPRESS: {\n          int windowBits = -config.outboundMaxWindowBits.orDefault(15);\n          // We use negative values because we want to use raw deflate.\n          if(windowBits == -8) {\n            // Zlib cannot accept `windowBits` of 8 for the deflater. However, due to an\n            // implementation quirk, `windowBits` of 8 and 9 would both use 250 bytes.\n            // Therefore, a decompressor using `windowBits` of 8 could safely inflate a message\n            // that a zlib client compressed using `windowBits` = 9.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=691074\n            windowBits = -9;\n          }\n          int result = deflateInit2(\n              &ctx,\n              Z_DEFAULT_COMPRESSION,\n              Z_DEFLATED,\n              windowBits,\n              8,  // memLevel = 8 is the default\n              Z_DEFAULT_STRATEGY);\n          KJ_REQUIRE(result == Z_OK, \"Failed to initialize compression context (deflate).\");\n          break;\n        }\n        case Mode::DECOMPRESS: {\n          int windowBits = -config.inboundMaxWindowBits.orDefault(15);\n          // We use negative values because we want to use raw inflate.\n          int result = inflateInit2(&ctx, windowBits);\n          KJ_REQUIRE(result == Z_OK, \"Failed to initialize decompression context (inflate).\");\n          break;\n        }\n      }\n    }\n\n    ~ZlibContext() noexcept(false) {\n      switch (mode) {\n        case Mode::COMPRESS:\n          deflateEnd(&ctx);\n          break;\n        case Mode::DECOMPRESS:\n          inflateEnd(&ctx);\n          break;\n      }\n    }\n\n    KJ_DISALLOW_COPY_AND_MOVE(ZlibContext);\n\n    kj::Array<kj::byte> processMessage(kj::ArrayPtr<const byte> message,\n        kj::Maybe<size_t> maxSize = kj::none,\n        bool addNullTerminator = false) {\n      // If `this` is the compressor, calling `processMessage()` will compress the `message`.\n      // Likewise, if `this` is the decompressor, `processMessage()` will decompress the `message`.\n      //\n      // `maxSize` is only passed in when decompressing, since we want to ensure the decompressed\n      // message is smaller than the `maxSize` passed to `receive()`.\n      //\n      // If (de)compression is successful, the result is returned as a Vector, otherwise,\n      // an Exception is thrown.\n\n      ctx.next_in = const_cast<byte*>(reinterpret_cast<const byte*>(message.begin()));\n      ctx.avail_in = message.size();\n\n      kj::Vector<Result> parts(processLoop(maxSize));\n\n      size_t amountToAllocate = 0;\n      for (const auto& part : parts) {\n        amountToAllocate += part.size;\n      }\n\n      if (addNullTerminator) {\n        // Add space for the null-terminator.\n        amountToAllocate += 1;\n      }\n\n      kj::Array<kj::byte> processedMessage = kj::heapArray<kj::byte>(amountToAllocate);\n      size_t currentIndex = 0; // Current index into processedMessage.\n      for (const auto& part : parts) {\n        memcpy(&processedMessage[currentIndex], part.buffer.begin(), part.size);\n        // We need to use `part.size` to determine the number of useful bytes, since data after\n        // `part.size` is unused (and probably junk).\n        currentIndex += part.size;\n      }\n\n      if (addNullTerminator) {\n        processedMessage[currentIndex++] = '\\0';\n      }\n\n      KJ_ASSERT(currentIndex == processedMessage.size());\n\n      return kj::mv(processedMessage);\n    }\n\n    void reset() {\n      // Resets the (de)compression context. This should only be called when the (de)compressor uses\n      // client/server_no_context_takeover.\n      switch (mode) {\n        case Mode::COMPRESS: {\n          KJ_ASSERT(deflateReset(&ctx) == Z_OK, \"deflateReset() failed.\");\n          break;\n        }\n        case Mode::DECOMPRESS: {\n          KJ_ASSERT(inflateReset(&ctx) == Z_OK, \"inflateReset failed.\");\n          break;\n        }\n      }\n\n    }\n\n  private:\n    Result pumpOnce() {\n      // Prepares Zlib's internal state for a call to deflate/inflate, then calls the relevant\n      // function to process the input buffer. It is assumed that the caller has already set up\n      // Zlib's input buffer.\n      //\n      // Since calls to deflate/inflate will process data until the input is empty, or until the\n      // output is full, multiple calls to `pumpOnce()` may be required to process the entire\n      // message. We're done processing once either `result` is `Z_STREAM_END`, or we get\n      // `Z_BUF_ERROR` and did not write any more output.\n      size_t bufSize = 4096;\n      Array<kj::byte> buffer = kj::heapArray<kj::byte>(bufSize);\n      ctx.next_out = buffer.begin();\n      ctx.avail_out = bufSize;\n\n      int result = Z_OK;\n\n      switch (mode) {\n        case Mode::COMPRESS:\n          result = deflate(&ctx, Z_SYNC_FLUSH);\n          KJ_REQUIRE(result == Z_OK || result == Z_BUF_ERROR || result == Z_STREAM_END,\n                      \"Compression failed\", result);\n          break;\n        case Mode::DECOMPRESS:\n          result = inflate(&ctx, Z_SYNC_FLUSH);\n          KJ_REQUIRE(result == Z_OK || result == Z_BUF_ERROR || result == Z_STREAM_END,\n                      \"Decompression failed\", result, \" with reason\", ctx.msg);\n          break;\n      }\n\n      return Result {\n        result,\n        kj::mv(buffer),\n        bufSize - ctx.avail_out,\n      };\n    }\n\n    kj::Vector<Result> processLoop(kj::Maybe<size_t> maxSize) {\n      // Since Zlib buffers the writes, we want to continue processing until there's nothing left.\n      kj::Vector<Result> output;\n      size_t totalBytesProcessed = 0;\n      for (;;) {\n        Result result = pumpOnce();\n\n        auto status = result.processResult;\n        auto bytesProcessed = result.size;\n        if (bytesProcessed > 0) {\n          output.add(kj::mv(result));\n          totalBytesProcessed += bytesProcessed;\n          KJ_IF_SOME(m, maxSize) {\n            // This is only non-null for `receive` calls, so we must be decompressing. We don't want\n            // the decompressed message to OOM us, so let's make sure it's not too big.\n            KJ_REQUIRE(totalBytesProcessed < m,\n                \"Decompressed WebSocket message is too large\");\n          }\n        }\n\n        if ((ctx.avail_in == 0 && ctx.avail_out != 0) || status == Z_STREAM_END) {\n          // If we're out of input to consume, and we have space in the output buffer, then we must\n          // have flushed the remaining message, so we're done pumping. Alternatively, if we found a\n          // BFINAL deflate block, then we know the stream is completely finished.\n          if (status == Z_STREAM_END) {\n            reset();\n          }\n          return kj::mv(output);\n        }\n      }\n    }\n\n    Mode mode;\n    z_stream ctx = {};\n  };\n#endif // KJ_HAS_ZLIB\n\n  static constexpr byte OPCODE_CONTINUATION = 0;\n  static constexpr byte OPCODE_TEXT         = 1;\n  static constexpr byte OPCODE_BINARY       = 2;\n  static constexpr byte OPCODE_CLOSE        = 8;\n  static constexpr byte OPCODE_PING         = 9;\n  static constexpr byte OPCODE_PONG         = 10;\n\n  static constexpr byte OPCODE_FIRST_CONTROL = 8;\n\n  // ---------------------------------------------------------------------------\n\n  kj::Own<kj::AsyncIoStream> stream;\n  kj::Maybe<EntropySource&> maskKeyGenerator;\n  kj::Maybe<CompressionParameters> compressionConfig;\n  WebSocketErrorHandler& errorHandler;\n#if KJ_HAS_ZLIB\n  kj::Maybe<ZlibContext> compressionContext;\n  kj::Maybe<ZlibContext> decompressionContext;\n#endif // KJ_HAS_ZLIB\n\n  bool hasSentClose = false;\n  bool disconnected = false;\n  bool currentlySending = false;\n  Header sendHeader;\n  kj::ArrayPtr<const byte> sendParts[2];\n\n  kj::Maybe<kj::Array<byte>> queuedPong;\n  // queuedPong holds the body of the next pong to write, cleared when the pong is written.  If a\n  // more recent ping arrives before the pong is actually written, we can update this value to\n  // instead respond to the more recent ping.\n\n  kj::Maybe<kj::Promise<void>> sendingPong;\n  // If a Pong is being sent asynchronously in response to a Ping, this is a promise for the\n  // completion of that send.\n  //\n  // Additionally, this member is used if we need to block our first send on WebSocket startup,\n  // e.g. because we need to wait for HTTP handshake writes to flush before we can start sending\n  // WebSocket data. `sendingPong` was overloaded for this use case because the logic is the same.\n  // Perhaps it should be renamed to `blockSend` or `writeQueue`.\n\n  uint fragmentOpcode = 0;\n  bool fragmentCompressed = false;\n  // For fragmented messages, was the first frame compressed?\n  // Note that subsequent frames of a compressed message will not set the RSV1 bit.\n  kj::Vector<kj::Array<byte>> fragments;\n  // If `fragments` is non-empty, we've already received some fragments of a message.\n  // `fragmentOpcode` is the original opcode.\n\n  kj::Array<byte> recvBuffer;\n  kj::ArrayPtr<byte> recvData;\n\n  uint64_t sentBytes = 0;\n  uint64_t receivedBytes = 0;\n\n  kj::Promise<void> sendImpl(byte opcode, kj::ArrayPtr<const byte> message) {\n    KJ_REQUIRE(!disconnected, \"WebSocket can't send after disconnect()\");\n    KJ_REQUIRE(!currentlySending, \"another message send is already in progress\");\n\n    currentlySending = true;\n\n    KJ_IF_SOME(p, sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      auto promise = p.then([this, opcode, message]() {\n        currentlySending = false;\n        return sendImpl(opcode, message);\n      });\n      sendingPong = kj::none;\n      return promise;\n    }\n\n    // We don't stop the application from sending further messages after close() -- this is the\n    // application's error to make. But, we do want to make sure we don't send any PONGs after a\n    // close, since that would be our error. So we stack whether we closed for that reason.\n    hasSentClose = hasSentClose || opcode == OPCODE_CLOSE;\n\n    Mask mask(maskKeyGenerator);\n\n    bool useCompression = false;\n    kj::Maybe<kj::Array<byte>> compressedMessage;\n    if (opcode == OPCODE_BINARY || opcode == OPCODE_TEXT) {\n      // We can only compress data frames.\n#if KJ_HAS_ZLIB\n      KJ_IF_SOME(config, compressionConfig) {\n        useCompression = true;\n        // Compress `message` according to `compressionConfig`s outbound parameters.\n        auto& compressor = KJ_ASSERT_NONNULL(compressionContext);\n        if (config.outboundNoContextTakeover) {\n          // We must reset context on each message.\n          compressor.reset();\n        }\n        auto& innerMessage = compressedMessage.emplace(compressor.processMessage(message));\n        if (message.size() > 0) {\n          KJ_ASSERT(innerMessage.asPtr().endsWith({0x00, 0x00, 0xFF, 0xFF}));\n          message = innerMessage.slice(0, innerMessage.size() - 4);\n          // Strip 0x00 0x00 0xFF 0xFF off the tail.\n          // See: https://datatracker.ietf.org/doc/html/rfc7692#section-7.2.1\n        } else {\n          // RFC 7692 (7.2.3.6) specifies that an empty uncompressed DEFLATE block (0x00) should be\n          // built if the compression library doesn't generate data when the input is empty.\n          message = compressedMessage.emplace(kj::heapArray<byte>({0x00}));\n        }\n      }\n#endif // KJ_HAS_ZLIB\n    }\n\n    kj::Array<byte> ownMessage;\n    if (!mask.isZero()) {\n      // Sadness, we have to make a copy to apply the mask.\n      ownMessage = kj::heapArray(message);\n      mask.apply(ownMessage);\n      message = ownMessage;\n    }\n\n    sendParts[0] = sendHeader.compose(true, useCompression, opcode, message.size(), mask);\n    sendParts[1] = message;\n    KJ_ASSERT(!sendHeader.hasRsv2or3(), \"RSV bits 2 and 3 must be 0, as we do not currently \"\n        \"support an extension that would set these bits\");\n\n    auto promise = stream->write(sendParts).attach(kj::mv(compressedMessage));\n    if (!mask.isZero()) {\n      promise = promise.attach(kj::mv(ownMessage));\n    }\n    return promise.then([this, size = sendParts[0].size() + sendParts[1].size()]() {\n      currentlySending = false;\n\n      // Send queued pong if needed.\n      if (queuedPong != kj::none) {\n        setUpSendingPong();\n      }\n      sentBytes += size;\n    });\n  }\n\n  void queuePong(kj::Array<byte> payload) {\n    bool alreadyWaitingForPongWrite = (queuedPong != kj::none);\n\n    // Note: According to spec, if the server receives a second ping before responding to the\n    //   previous one, it can opt to respond only to the last ping. So we don't have to check if\n    //   queuedPong is already non-null.\n    queuedPong = kj::mv(payload);\n\n    if (currentlySending) {\n      // There is a message-send in progress, so we cannot write to the stream now.  We will set\n      // up the pong write at the end of the message-send.\n      return;\n    }\n    if (alreadyWaitingForPongWrite) {\n      // We were already waiting for a pong to be written; don't need to queue another write.\n      return;\n    }\n    setUpSendingPong();\n  }\n\n  void setUpSendingPong() {\n    KJ_IF_SOME(promise, sendingPong) {\n      sendingPong = promise.then([this]() mutable {\n        return writeQueuedPong();\n      });\n    } else {\n      sendingPong = writeQueuedPong();\n    }\n  }\n\n  kj::Promise<void> writeQueuedPong() {\n    KJ_IF_SOME(q, queuedPong) {\n      kj::Array<byte> payload = kj::mv(q);\n      queuedPong = kj::none;\n\n      if (hasSentClose || disconnected) {\n        return kj::READY_NOW;\n      }\n\n      sendParts[0] = sendHeader.compose(true, false, OPCODE_PONG,\n                                        payload.size(), Mask(maskKeyGenerator));\n      sendParts[1] = payload;\n      return stream->write(sendParts).attach(kj::mv(payload));\n    } else {\n      return kj::READY_NOW;\n    }\n  }\n\n  kj::Promise<void> optimizedPumpTo(WebSocketImpl& other) {\n    KJ_IF_SOME(p, other.sendingPong) {\n      // We recently sent a pong, make sure it's finished before proceeding.\n      auto promise = p.then([this, &other]() {\n        return optimizedPumpTo(other);\n      });\n      other.sendingPong = kj::none;\n      return promise;\n    }\n\n    if (recvData.size() > 0) {\n      // We have some data buffered. Write it first.\n      return other.stream->write(recvData.begin(), recvData.size())\n          .then([this, &other, size = recvData.size()]() {\n        recvData = nullptr;\n        other.sentBytes += size;\n        return optimizedPumpTo(other);\n      });\n    }\n\n    auto cancelPromise = other.stream->whenWriteDisconnected()\n        .then([this]() -> kj::Promise<void> {\n      this->abort();\n      return KJ_EXCEPTION(DISCONNECTED,\n          \"destination of WebSocket pump disconnected prematurely\");\n    });\n\n    // There's no buffered incoming data, so start pumping stream now.\n    return stream->pumpTo(*other.stream).then([this, &other](size_t s) -> kj::Promise<void> {\n      // WebSocket pumps are expected to include end-of-stream.\n      other.disconnected = true;\n      other.stream->shutdownWrite();\n      receivedBytes += s;\n      other.sentBytes += s;\n      return kj::READY_NOW;\n    }, [&other](kj::Exception&& e) -> kj::Promise<void> {\n      // We don't know if it was a read or a write that threw. If it was a read that threw, we need\n      // to send a disconnect on the destination. If it was the destination that threw, it\n      // shouldn't hurt to disconnect() it again, but we'll catch and squelch any exceptions.\n      other.disconnected = true;\n      kj::runCatchingExceptions([&other]() { other.stream->shutdownWrite(); });\n      return kj::mv(e);\n    }).exclusiveJoin(kj::mv(cancelPromise));\n  }\n};\n\nkj::Own<WebSocket> upgradeToWebSocket(\n    kj::Own<kj::AsyncIoStream> stream, HttpInputStreamImpl& httpInput, HttpOutputStream& httpOutput,\n    kj::Maybe<EntropySource&> maskKeyGenerator,\n    kj::Maybe<CompressionParameters> compressionConfig = kj::none,\n    kj::Maybe<WebSocketErrorHandler&> errorHandler = kj::none) {\n  // Create a WebSocket upgraded from an HTTP stream.\n  auto releasedBuffer = httpInput.releaseBuffer();\n  return kj::heap<WebSocketImpl>(kj::mv(stream), maskKeyGenerator,\n                                 kj::mv(compressionConfig), errorHandler,\n                                 kj::mv(releasedBuffer.buffer),\n                                 releasedBuffer.leftover, httpOutput.flush());\n}\n\n}  // namespace\n\nkj::Own<WebSocket> newWebSocket(kj::Own<kj::AsyncIoStream> stream,\n                                kj::Maybe<EntropySource&> maskKeyGenerator,\n                                kj::Maybe<CompressionParameters> compressionConfig,\n                                kj::Maybe<WebSocketErrorHandler&> errorHandler) {\n  return kj::heap<WebSocketImpl>(kj::mv(stream), maskKeyGenerator, kj::mv(compressionConfig), errorHandler);\n}\n\nstatic kj::Promise<void> pumpWebSocketLoop(WebSocket& from, WebSocket& to) {\n  return from.receive().then([&from,&to](WebSocket::Message&& message) {\n    KJ_SWITCH_ONEOF(message) {\n      KJ_CASE_ONEOF(text, kj::String) {\n        return to.send(text)\n            .attach(kj::mv(text))\n            .then([&from,&to]() { return pumpWebSocketLoop(from, to); });\n      }\n      KJ_CASE_ONEOF(data, kj::Array<byte>) {\n        return to.send(data)\n            .attach(kj::mv(data))\n            .then([&from,&to]() { return pumpWebSocketLoop(from, to); });\n      }\n      KJ_CASE_ONEOF(close, WebSocket::Close) {\n        // Once a close has passed through, the pump is complete.\n        return to.close(close.code, close.reason)\n            .attach(kj::mv(close));\n      }\n    }\n    KJ_UNREACHABLE;\n  }, [&to](kj::Exception&& e) {\n    if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n      return to.disconnect();\n    } else {\n      return to.close(1002, e.getDescription());\n    }\n  });\n}\n\nkj::Promise<void> WebSocket::pumpTo(WebSocket& other) {\n  KJ_IF_SOME(p, other.tryPumpFrom(*this)) {\n    // Yay, optimized pump!\n    return kj::mv(p);\n  } else {\n    // Fall back to default implementation.\n    return kj::evalNow([&]() {\n      auto cancelPromise = other.whenAborted().then([this]() -> kj::Promise<void> {\n        this->abort();\n        return KJ_EXCEPTION(DISCONNECTED,\n            \"destination of WebSocket pump disconnected prematurely\");\n      });\n      return pumpWebSocketLoop(*this, other).exclusiveJoin(kj::mv(cancelPromise));\n    });\n  }\n}\n\nkj::Maybe<kj::Promise<void>> WebSocket::tryPumpFrom(WebSocket& other) {\n  return kj::none;\n}\n\nnamespace {\n\nclass WebSocketPipeImpl final: public WebSocket, public kj::Refcounted {\n  // Represents one direction of a WebSocket pipe.\n  //\n  // This class behaves as a \"loopback\" WebSocket: a message sent using send() is received using\n  // receive(), on the same object. This is *not* how WebSocket implementations usually behave.\n  // But, this object is actually used to implement only one direction of a bidirectional pipe. At\n  // another layer above this, the pipe is actually composed of two WebSocketPipeEnd instances,\n  // which layer on top of two WebSocketPipeImpl instances representing the two directions. So,\n  // send() calls on a WebSocketPipeImpl instance always come from one of the two WebSocketPipeEnds\n  // while receive() calls come from the other end.\n\npublic:\n  ~WebSocketPipeImpl() noexcept(false) {\n    KJ_REQUIRE(state == kj::none || ownState.get() != nullptr,\n        \"destroying WebSocketPipe with operation still in-progress; probably going to segfault\") {\n      // Don't std::terminate().\n      break;\n    }\n  }\n\n  void abort() override {\n    KJ_IF_SOME(s, state) {\n      s.abort();\n    } else {\n      ownState = heap<Aborted>();\n      state = *ownState;\n\n      aborted = true;\n      KJ_IF_SOME(f, abortedFulfiller) {\n        f->fulfill();\n        abortedFulfiller = kj::none;\n      }\n    }\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    KJ_IF_SOME(s, state) {\n      return s.send(message).then([&, size = message.size()]() { transferredBytes += size; });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(message))\n          .then([&, size = message.size()]() { transferredBytes += size; });\n    }\n  }\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    KJ_IF_SOME(s, state) {\n      return s.send(message).then([&, size = message.size()]() { transferredBytes += size; });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(message))\n          .then([&, size = message.size()]() { transferredBytes += size; });\n    }\n  }\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    KJ_IF_SOME(s, state) {\n      return s.close(code, reason)\n          .then([&, size = reason.size()]() { transferredBytes += (2 +size); });\n    } else {\n      return newAdaptedPromise<void, BlockedSend>(*this, MessagePtr(ClosePtr { code, reason }))\n          .then([&, size = reason.size()]() { transferredBytes += (2 +size); });\n    }\n  }\n  kj::Promise<void> disconnect() override {\n    KJ_IF_SOME(s, state) {\n      return s.disconnect();\n    } else {\n      ownState = heap<Disconnected>();\n      state = *ownState;\n      return kj::READY_NOW;\n    }\n  }\n  kj::Promise<void> whenAborted() override {\n    if (aborted) {\n      return kj::READY_NOW;\n    } else KJ_IF_SOME(p, abortedPromise) {\n      return p.addBranch();\n    } else {\n      auto paf = newPromiseAndFulfiller<void>();\n      abortedFulfiller = kj::mv(paf.fulfiller);\n      auto fork = paf.promise.fork();\n      auto result = fork.addBranch();\n      abortedPromise = kj::mv(fork);\n      return result;\n    }\n  }\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    KJ_IF_SOME(s, state) {\n      return s.tryPumpFrom(other);\n    } else {\n      return newAdaptedPromise<void, BlockedPumpFrom>(*this, other);\n    }\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    KJ_IF_SOME(s, state) {\n      return s.receive(maxSize);\n    } else {\n      return newAdaptedPromise<Message, BlockedReceive>(*this, maxSize);\n    }\n  }\n  kj::Promise<void> pumpTo(WebSocket& other) override {\n    auto onAbort = other.whenAborted()\n        .then([]() -> kj::Promise<void> {\n      return KJ_EXCEPTION(DISCONNECTED, \"WebSocket was aborted\");\n    });\n\n    KJ_IF_SOME(s, state) {\n      auto before = other.receivedByteCount();\n      return s.pumpTo(other).attach(kj::defer([this, &other, before]() {\n        transferredBytes += other.receivedByteCount() - before;\n      })).exclusiveJoin(kj::mv(onAbort));\n    } else {\n      return newAdaptedPromise<void, BlockedPumpTo>(*this, other).exclusiveJoin(kj::mv(onAbort));\n    }\n  }\n\n  uint64_t sentByteCount() override {\n    return transferredBytes;\n  }\n  uint64_t receivedByteCount() override {\n    return transferredBytes;\n  }\n\nprivate:\n  kj::Maybe<WebSocket&> state;\n  // Object-oriented state! If any method call is blocked waiting on activity from the other end,\n  // then `state` is non-null and method calls should be forwarded to it. If no calls are\n  // outstanding, `state` is null.\n\n  kj::Own<WebSocket> ownState;\n\n  uint64_t transferredBytes = 0;\n\n  bool aborted = false;\n  Maybe<Own<PromiseFulfiller<void>>> abortedFulfiller = kj::none;\n  Maybe<ForkedPromise<void>> abortedPromise = kj::none;\n\n  void endState(WebSocket& obj) {\n    KJ_IF_SOME(s, state) {\n      if (&s == &obj) {\n        state = kj::none;\n      }\n    }\n  }\n\n  struct ClosePtr {\n    uint16_t code;\n    kj::StringPtr reason;\n  };\n  typedef kj::OneOf<kj::ArrayPtr<const char>, kj::ArrayPtr<const byte>, ClosePtr> MessagePtr;\n\n  class BlockedSend final: public WebSocket {\n  public:\n    BlockedSend(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe, MessagePtr message)\n        : fulfiller(fulfiller), pipe(pipe), message(kj::mv(message)) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedSend() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill();\n      pipe.endState(*this);\n      KJ_SWITCH_ONEOF(message) {\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const char>) {\n          return Message(kj::str(arr));\n        }\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const byte>) {\n          auto copy = kj::heapArray<byte>(arr.size());\n          memcpy(copy.begin(), arr.begin(), arr.size());\n          return Message(kj::mv(copy));\n        }\n        KJ_CASE_ONEOF(close, ClosePtr) {\n          return Message(Close { close.code, kj::str(close.reason) });\n        }\n      }\n      KJ_UNREACHABLE;\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      kj::Promise<void> promise = nullptr;\n      KJ_SWITCH_ONEOF(message) {\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const char>) {\n          promise = other.send(arr);\n        }\n        KJ_CASE_ONEOF(arr, kj::ArrayPtr<const byte>) {\n          promise = other.send(arr);\n        }\n        KJ_CASE_ONEOF(close, ClosePtr) {\n          promise = other.close(close.code, close.reason);\n        }\n      }\n      return canceler.wrap(promise.then([this,&other]() {\n        canceler.release();\n        fulfiller.fulfill();\n        pipe.endState(*this);\n        return pipe.pumpTo(other);\n      }, [this](kj::Exception&& e) -> kj::Promise<void> {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        return kj::mv(e);\n      }));\n    }\n\n  uint64_t sentByteCount() override {\n    KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n  }\n  uint64_t receivedByteCount() override {\n    KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n   }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    MessagePtr message;\n    Canceler canceler;\n  };\n\n  class BlockedPumpFrom final: public WebSocket {\n  public:\n    BlockedPumpFrom(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe,\n                    WebSocket& input)\n        : fulfiller(fulfiller), pipe(pipe), input(input) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedPumpFrom() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message send is already in progress\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message receive is already in progress\");\n      return canceler.wrap(input.receive(maxSize)\n          .then([this](Message message) {\n        if (message.is<Close>()) {\n          canceler.release();\n          fulfiller.fulfill();\n          pipe.endState(*this);\n        }\n        return kj::mv(message);\n      }, [this](kj::Exception&& e) -> Message {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        kj::throwRecoverableException(kj::mv(e));\n        return Message(kj::String());\n      }));\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message receive is already in progress\");\n      return canceler.wrap(input.pumpTo(other)\n          .then([this]() {\n        canceler.release();\n        fulfiller.fulfill();\n        pipe.endState(*this);\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    WebSocket& input;\n    Canceler canceler;\n  };\n\n  class BlockedReceive final: public WebSocket {\n  public:\n    BlockedReceive(kj::PromiseFulfiller<Message>& fulfiller, WebSocketPipeImpl& pipe,\n                   size_t maxSize)\n        : fulfiller(fulfiller), pipe(pipe), maxSize(maxSize) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedReceive() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\"));\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      auto copy = kj::heapArray<byte>(message.size());\n      memcpy(copy.begin(), message.begin(), message.size());\n      fulfiller.fulfill(Message(kj::mv(copy)));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill(Message(kj::str(message)));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.fulfill(Message(Close { code, kj::str(reason) }));\n      pipe.endState(*this);\n      return kj::READY_NOW;\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      fulfiller.reject(KJ_EXCEPTION(DISCONNECTED, \"WebSocket disconnected\"));\n      pipe.endState(*this);\n      return pipe.disconnect();\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"already pumping\");\n      return canceler.wrap(other.receive(maxSize).then([this,&other](Message message) {\n        canceler.release();\n        fulfiller.fulfill(kj::mv(message));\n        pipe.endState(*this);\n        return other.pumpTo(pipe);\n      }, [this](kj::Exception&& e) -> kj::Promise<void> {\n        canceler.release();\n        fulfiller.reject(kj::cp(e));\n        pipe.endState(*this);\n        return kj::mv(e);\n      }));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<Message>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    size_t maxSize;\n    Canceler canceler;\n  };\n\n  class BlockedPumpTo final: public WebSocket {\n  public:\n    BlockedPumpTo(kj::PromiseFulfiller<void>& fulfiller, WebSocketPipeImpl& pipe, WebSocket& output)\n        : fulfiller(fulfiller), pipe(pipe), output(output) {\n      KJ_REQUIRE(pipe.state == kj::none);\n      pipe.state = *this;\n    }\n    ~BlockedPumpTo() noexcept(false) {\n      pipe.endState(*this);\n    }\n\n    void abort() override {\n      canceler.cancel(\"other end of WebSocketPipe was destroyed\");\n\n      // abort() is called when the pipe end is dropped. This should be treated as disconnecting,\n      // so pumpTo() should complete normally.\n      fulfiller.fulfill();\n\n      pipe.endState(*this);\n      pipe.abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.send(message));\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.send(message));\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.close(code, reason).then([this]() {\n        // A pump is expected to end upon seeing a Close message.\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n    kj::Promise<void> disconnect() override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(output.disconnect().then([this]() {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n        return pipe.disconnect();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_REQUIRE(canceler.isEmpty(), \"another message send is already in progress\");\n      return canceler.wrap(other.pumpTo(output).then([this]() {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.fulfill();\n      }, [this](kj::Exception&& e) {\n        canceler.release();\n        pipe.endState(*this);\n        fulfiller.reject(kj::cp(e));\n        kj::throwRecoverableException(kj::mv(e));\n      }));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      KJ_FAIL_ASSERT(\"another message receive is already in progress\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  private:\n    kj::PromiseFulfiller<void>& fulfiller;\n    WebSocketPipeImpl& pipe;\n    WebSocket& output;\n    Canceler canceler;\n  };\n\n  class Disconnected final: public WebSocket {\n  public:\n    void abort() override {\n      // can ignore\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      KJ_FAIL_REQUIRE(\"can't send() after disconnect()\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      KJ_FAIL_REQUIRE(\"can't send() after disconnect()\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      KJ_FAIL_REQUIRE(\"can't close() after disconnect()\");\n    }\n    kj::Promise<void> disconnect() override {\n      return kj::READY_NOW;\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      KJ_FAIL_REQUIRE(\"can't tryPumpFrom() after disconnect()\");\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"WebSocket disconnected\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return kj::READY_NOW;\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n\n  };\n\n  class Aborted final: public WebSocket {\n  public:\n    void abort() override {\n      // can ignore\n    }\n    kj::Promise<void> whenAborted() override {\n      KJ_FAIL_ASSERT(\"can't get here -- implemented by WebSocketPipeImpl\");\n    }\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> disconnect() override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      return kj::Promise<void>(KJ_EXCEPTION(DISCONNECTED,\n          \"other end of WebSocketPipe was destroyed\"));\n    }\n\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return KJ_EXCEPTION(DISCONNECTED, \"other end of WebSocketPipe was destroyed\");\n    }\n\n    uint64_t sentByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n    uint64_t receivedByteCount() override {\n      KJ_FAIL_ASSERT(\"Bytes are not counted for the individual states of WebSocketPipeImpl.\");\n    }\n  };\n};\n\nclass WebSocketPipeEnd final: public WebSocket {\npublic:\n  WebSocketPipeEnd(kj::Own<WebSocketPipeImpl> in, kj::Own<WebSocketPipeImpl> out)\n      : in(kj::mv(in)), out(kj::mv(out)) {}\n  ~WebSocketPipeEnd() noexcept(false) {\n    in->abort();\n    out->abort();\n  }\n\n  kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n    return out->send(message);\n  }\n  kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n    return out->send(message);\n  }\n  kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n    return out->close(code, reason);\n  }\n  kj::Promise<void> disconnect() override {\n    return out->disconnect();\n  }\n  void abort() override {\n    in->abort();\n    out->abort();\n  }\n  kj::Promise<void> whenAborted() override {\n    return out->whenAborted();\n  }\n  kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n    return out->tryPumpFrom(other);\n  }\n\n  kj::Promise<Message> receive(size_t maxSize) override {\n    return in->receive(maxSize);\n  }\n  kj::Promise<void> pumpTo(WebSocket& other) override {\n    return in->pumpTo(other);\n  }\n\n  uint64_t sentByteCount() override { return out->sentByteCount(); }\n  uint64_t receivedByteCount() override { return in->sentByteCount(); }\n\nprivate:\n  kj::Own<WebSocketPipeImpl> in;\n  kj::Own<WebSocketPipeImpl> out;\n};\n\n}  // namespace\n\nWebSocketPipe newWebSocketPipe() {\n  auto pipe1 = kj::refcounted<WebSocketPipeImpl>();\n  auto pipe2 = kj::refcounted<WebSocketPipeImpl>();\n\n  auto end1 = kj::heap<WebSocketPipeEnd>(kj::addRef(*pipe1), kj::addRef(*pipe2));\n  auto end2 = kj::heap<WebSocketPipeEnd>(kj::mv(pipe2), kj::mv(pipe1));\n\n  return { { kj::mv(end1), kj::mv(end2) } };\n}\n\n// =======================================================================================\nclass AsyncIoStreamWithInitialBuffer final: public kj::AsyncIoStream {\n  // An AsyncIoStream implementation that accepts an initial buffer of data\n  // to be read out first, and is optionally capable of deferring writes\n  // until a given waitBeforeSend promise is fulfilled.\n  //\n  // Instances are created with a leftoverBackingBuffer (a kj::Array<byte>)\n  // and a leftover kj::ArrayPtr<byte> that provides a view into the backing\n  // buffer representing the queued data that is pending to be read. Calling\n  // tryRead will consume the data from the leftover first. Once leftover has\n  // been fully consumed, reads will defer to the underlying stream.\npublic:\n  AsyncIoStreamWithInitialBuffer(kj::Own<kj::AsyncIoStream> stream,\n                                 kj::Array<byte> leftoverBackingBuffer,\n                                 kj::ArrayPtr<byte> leftover)\n                                 : stream(kj::mv(stream)),\n                                   leftoverBackingBuffer(kj::mv(leftoverBackingBuffer)),\n                                   leftover(leftover) {}\n\n  void shutdownWrite() override {\n    stream->shutdownWrite();\n  }\n\n  // AsyncInputStream\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_REQUIRE(maxBytes >= minBytes);\n    auto destination = static_cast<byte*>(buffer);\n\n    // If there are at least minBytes available in the leftover buffer...\n    if (leftover.size() >= minBytes) {\n      // We are going to immediately read up to maxBytes from the leftover buffer...\n      auto bytesToCopy = kj::min(maxBytes, leftover.size());\n      memcpy(destination, leftover.begin(), bytesToCopy);\n      leftover = leftover.slice(bytesToCopy, leftover.size());\n\n      // If we've consumed all of the data in the leftover buffer, go ahead and free it.\n      if (leftover.size() == 0) {\n        leftoverBackingBuffer = nullptr;\n      }\n\n      return bytesToCopy;\n    } else {\n      // We know here that leftover.size() is less than minBytes, but it might not\n      // be zero. Copy everything from leftover into the destination buffer then read\n      // the rest from the underlying stream.\n      auto bytesToCopy = leftover.size();\n      KJ_DASSERT(bytesToCopy < minBytes);\n\n      if (bytesToCopy > 0) {\n        memcpy(destination, leftover.begin(), bytesToCopy);\n        leftoverBackingBuffer = nullptr;\n        minBytes -= bytesToCopy;\n        maxBytes -= bytesToCopy;\n        KJ_DASSERT(minBytes >= 1);\n        KJ_DASSERT(maxBytes >= minBytes);\n      }\n\n      return stream->tryRead(destination + bytesToCopy, minBytes, maxBytes)\n          .then([bytesToCopy](size_t amount) { return amount + bytesToCopy; });\n    }\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    // For a CONNECT pipe, we have no idea how much data there is going to be.\n    return kj::none;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output,\n                               uint64_t amount = kj::maxValue) override {\n    return pumpLoop(output, amount, 0);\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input,\n                                               uint64_t amount = kj::maxValue) override {\n    return input.pumpTo(*stream, amount);\n  }\n\n  // AsyncOutputStream\n  Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return stream->write(pieces);\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    return stream->whenWriteDisconnected();\n  }\n\nprivate:\n\n  kj::Promise<uint64_t> pumpLoop(\n      kj::AsyncOutputStream& output,\n      uint64_t remaining,\n      uint64_t total) {\n    // If there is any data remaining in the leftover queue, we'll write it out first to output.\n    if (leftover.size() > 0) {\n      auto bytesToWrite = kj::min(leftover.size(), remaining);\n      return output.write(leftover.begin(), bytesToWrite).then(\n          [this, &output, remaining, total, bytesToWrite]() mutable -> kj::Promise<uint64_t> {\n        leftover = leftover.slice(bytesToWrite, leftover.size());\n        // If the leftover buffer has been fully consumed, go ahead and free it now.\n        if (leftover.size() == 0) {\n          leftoverBackingBuffer = nullptr;\n        }\n        remaining -= bytesToWrite;\n        total += bytesToWrite;\n\n        if (remaining == 0) {\n          return total;\n        }\n        return pumpLoop(output, remaining, total);\n      });\n    } else {\n      // Otherwise, we are just going to defer to stream's pumpTo, making sure to\n      // account for the total amount we've already written from the leftover queue.\n      return stream->pumpTo(output, remaining).then([total](auto read) {\n        return total + read;\n      });\n    }\n  };\n\n  kj::Own<kj::AsyncIoStream> stream;\n  kj::Array<byte> leftoverBackingBuffer;\n  kj::ArrayPtr<byte> leftover;\n};\n\nclass AsyncIoStreamWithGuards final: public kj::AsyncIoStream,\n                                     private kj::TaskSet::ErrorHandler {\n  // This AsyncIoStream adds separate kj::Promise guards to both the input and output,\n  // delaying reads and writes until each relevant guard is resolved.\n  //\n  // When the read guard promise resolves, it may provide a released buffer that will\n  // be read out first.\n  // The primary use case for this impl is to support pipelined CONNECT calls which\n  // optimistically allow outbound writes to happen while establishing the CONNECT\n  // tunnel has not yet been completed. If the guard promise rejects, the stream\n  // is permanently errored and existing pending calls (reads and writes) are canceled.\npublic:\n  AsyncIoStreamWithGuards(\n      kj::Own<kj::AsyncIoStream> inner,\n      kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>> readGuard,\n      kj::Promise<void> writeGuard)\n      : inner(kj::mv(inner)),\n        readGuard(handleReadGuard(kj::mv(readGuard))),\n        writeGuard(handleWriteGuard(kj::mv(writeGuard))),\n        tasks(*this) {}\n\n  // AsyncInputStream\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    if (readGuardReleased) {\n      return inner->tryRead(buffer, minBytes, maxBytes);\n    }\n    return readGuard.addBranch().then([this, buffer, minBytes, maxBytes] {\n      return inner->tryRead(buffer, minBytes, maxBytes);\n    });\n  }\n\n  Maybe<uint64_t> tryGetLength() override {\n    return kj::none;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount = kj::maxValue) override {\n    if (readGuardReleased) {\n      return inner->pumpTo(output, amount);\n    }\n    return readGuard.addBranch().then([this, &output, amount] {\n      return inner->pumpTo(output, amount);\n    });\n  }\n\n  // AsyncOutputStream\n\n  void shutdownWrite() override {\n    if (writeGuardReleased) {\n      inner->shutdownWrite();\n    } else {\n      tasks.add(writeGuard.addBranch().then([this]() { inner->shutdownWrite(); }));\n    }\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(AsyncInputStream& input,\n                                               uint64_t amount = kj::maxValue) override {\n    if (writeGuardReleased) {\n      return input.pumpTo(*inner, amount);\n    } else {\n      return writeGuard.addBranch().then([this,&input,amount]() {\n        return input.pumpTo(*inner, amount);\n      });\n    }\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    if (writeGuardReleased) {\n      return inner->write(buffer, size);\n    } else {\n      return writeGuard.addBranch().then([this,buffer,size]() {\n        return inner->write(buffer, size);\n      });\n    }\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    if (writeGuardReleased) {\n      return inner->write(pieces);\n    } else {\n      return writeGuard.addBranch().then([this, pieces]() {\n        return inner->write(pieces);\n      });\n    }\n  }\n\n  Promise<void> whenWriteDisconnected() override {\n    if (writeGuardReleased) {\n      return inner->whenWriteDisconnected();\n    } else {\n      return writeGuard.addBranch().then([this]() {\n        return inner->whenWriteDisconnected();\n      }, [](kj::Exception&& e) mutable -> kj::Promise<void> {\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          return kj::READY_NOW;\n        } else {\n          return kj::mv(e);\n        }\n      });\n    }\n  }\n\nprivate:\n  kj::Own<kj::AsyncIoStream> inner;\n  kj::ForkedPromise<void> readGuard;\n  kj::ForkedPromise<void> writeGuard;\n  bool readGuardReleased = false;\n  bool writeGuardReleased = false;\n  kj::TaskSet tasks;\n  // Set of tasks used to call `shutdownWrite` after write guard is released.\n\n  void taskFailed(kj::Exception&& exception) override {\n    // This `taskFailed` callback is only used when `shutdownWrite` is being called. Because we\n    // don't care about DISCONNECTED exceptions when `shutdownWrite` is called we ignore this\n    // class of exceptions here.\n    if (exception.getType() != kj::Exception::Type::DISCONNECTED) {\n      KJ_LOG(ERROR, exception);\n    }\n  }\n\n  kj::ForkedPromise<void> handleWriteGuard(kj::Promise<void> guard) {\n    return guard.then([this]() {\n      writeGuardReleased = true;\n    }).fork();\n  }\n\n  kj::ForkedPromise<void> handleReadGuard(\n      kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>> guard) {\n    return guard.then([this](kj::Maybe<HttpInputStreamImpl::ReleasedBuffer> buffer) mutable {\n      readGuardReleased = true;\n      KJ_IF_SOME(b, buffer) {\n        if (b.leftover.size() > 0) {\n          // We only need to replace the inner stream if a non-empty buffer is provided.\n          inner = heap<AsyncIoStreamWithInitialBuffer>(\n              kj::mv(inner),\n              kj::mv(b.buffer), b.leftover);\n        }\n      }\n    }).fork();\n  }\n};\n\n// =======================================================================================\n\nnamespace _ { // private implementation details\n\nkj::ArrayPtr<const char> splitNext(kj::ArrayPtr<const char>& cursor, char delimiter) {\n  // Consumes and returns the next item in a delimited list.\n  //\n  // If a delimiter is found:\n  //  - `cursor` is updated to point to the rest of the string after the delimiter.\n  //  - The text before the delimiter is returned.\n  // If no delimiter is found:\n  //  - `cursor` is updated to an empty string.\n  //  - The text that had been in `cursor` is returned.\n  //\n  // (It's up to the caller to stop the loop once `cursor` is empty.)\n  KJ_IF_SOME(index, cursor.findFirst(delimiter)) {\n    auto part = cursor.slice(0, index);\n    cursor = cursor.slice(index + 1, cursor.size());\n    return part;\n  }\n  kj::ArrayPtr<const char> result(kj::mv(cursor));\n  cursor = nullptr;\n\n  return result;\n}\n\nvoid stripLeadingAndTrailingSpace(ArrayPtr<const char>& str) {\n  // Remove any leading/trailing spaces from `str`, modifying it in-place.\n  while (str.size() > 0 && (str[0] == ' ' || str[0] == '\\t')) {\n    str = str.slice(1, str.size());\n  }\n  while (str.size() > 0 && (str.back() == ' ' || str.back() == '\\t')) {\n    str = str.slice(0, str.size() - 1);\n  }\n}\n\nkj::Vector<kj::ArrayPtr<const char>> splitParts(kj::ArrayPtr<const char> input, char delim) {\n  // Given a string `input` and a delimiter `delim`, split the string into a vector of substrings,\n  // separated by the delimiter. Note that leading/trailing whitespace is stripped from each element.\n  kj::Vector<kj::ArrayPtr<const char>> parts;\n\n  while (input.size() != 0) {\n    auto part = splitNext(input, delim);\n    stripLeadingAndTrailingSpace(part);\n    parts.add(kj::mv(part));\n  }\n\n  return parts;\n}\n\nkj::Array<KeyMaybeVal> toKeysAndVals(const kj::ArrayPtr<kj::ArrayPtr<const char>>& params) {\n  // Given a collection of parameters (a single offer), parse the parameters into <key, MaybeValue>\n  // pairs. If the parameter contains an `=`, we set the `key` to everything before, and the `value`\n  // to everything after. Otherwise, we set the `key` to be the entire parameter.\n  // Either way, both the key and value (if it exists) are stripped of leading & trailing whitespace.\n  auto result = kj::heapArray<KeyMaybeVal>(params.size());\n  size_t count = 0;\n  for (const auto& param : params) {\n    kj::ArrayPtr<const char> key;\n    kj::Maybe<kj::ArrayPtr<const char>> value;\n\n    KJ_IF_SOME(index, param.findFirst('=')) {\n      // Found '=' so we have a value.\n      key = param.slice(0, index);\n      stripLeadingAndTrailingSpace(key);\n      value = param.slice(index + 1, param.size());\n      KJ_IF_SOME(v, value) {\n        stripLeadingAndTrailingSpace(v);\n      }\n    } else {\n      key = kj::mv(param);\n    }\n\n    result[count].key = kj::mv(key);\n    result[count].val = kj::mv(value);\n    ++count;\n  }\n  return kj::mv(result);\n}\n\nstruct ParamType {\n  enum { CLIENT, SERVER } side;\n  enum { NO_CONTEXT_TAKEOVER, MAX_WINDOW_BITS } property;\n};\n\ninline kj::Maybe<ParamType> parseKeyName(kj::ArrayPtr<const char>& key) {\n  // Returns a `ParamType` struct if the `key` is valid and kj::none if invalid.\n\n  if (key == \"client_no_context_takeover\"_kj) {\n    return ParamType { ParamType::CLIENT, ParamType::NO_CONTEXT_TAKEOVER };\n  } else if (key == \"server_no_context_takeover\"_kj) {\n    return ParamType { ParamType::SERVER, ParamType::NO_CONTEXT_TAKEOVER };\n  } else if (key == \"client_max_window_bits\"_kj) {\n    return ParamType { ParamType::CLIENT, ParamType::MAX_WINDOW_BITS };\n  } else if (key == \"server_max_window_bits\"_kj) {\n    return ParamType { ParamType::SERVER, ParamType::MAX_WINDOW_BITS };\n  }\n  return kj::none;\n}\n\nkj::Maybe<UnverifiedConfig> populateUnverifiedConfig(kj::Array<KeyMaybeVal>& params) {\n  // Given a collection of <key, MaybeValue> pairs, attempt to populate an `UnverifiedConfig` struct.\n  // If the struct cannot be populated, we return null.\n  //\n  // This function populates the struct with what it finds, it does not perform bounds checking or\n  // concern itself with valid `Value`s (so long as the `Value` is non-empty).\n  //\n  // The following issues would prevent a struct from being populated:\n  //  Key issues:\n  //    - `Key` is invalid (see `parseKeyName()`).\n  //    - `Key` is repeated.\n  //  Value issues:\n  //    - Got a `Value` when none was expected (only the `max_window_bits` parameters expect values).\n  //    - Got an empty `Value` (0 characters, or all whitespace characters).\n\n  if (params.size() > 4) {\n    // We expect 4 `Key`s at most, having more implies repeats/invalid keys are present.\n    return kj::none;\n  }\n\n  UnverifiedConfig config;\n\n  for (auto& param : params) {\n    KJ_IF_SOME(paramType, parseKeyName(param.key)) {\n      // `Key` is valid, but we still want to check for repeats.\n      const auto& side = paramType.side;\n      const auto& property = paramType.property;\n\n      if (property == ParamType::NO_CONTEXT_TAKEOVER) {\n        auto& takeOverSetting = (side == ParamType::CLIENT) ?\n            config.clientNoContextTakeover : config.serverNoContextTakeover;\n\n        if (takeOverSetting == true) {\n          // This `Key` is a repeat; invalid config.\n          return kj::none;\n        }\n\n        if (param.val != kj::none) {\n          // The `x_no_context_takeover` parameter shouldn't have a value; invalid config.\n          return kj::none;\n        }\n\n        takeOverSetting = true;\n      } else if (property == ParamType::MAX_WINDOW_BITS) {\n        auto& maxBitsSetting =\n            (side == ParamType::CLIENT) ? config.clientMaxWindowBits : config.serverMaxWindowBits;\n\n        if (maxBitsSetting != kj::none) {\n          // This `Key` is a repeat; invalid config.\n          return kj::none;\n        }\n\n        KJ_IF_SOME(value, param.val) {\n          if (value.size() == 0) {\n            // This is equivalent to `x_max_window_bits=`, since we got an \"=\" we expected a token\n            // to follow.\n            return kj::none;\n          }\n          maxBitsSetting = param.val;\n        } else {\n          // We know we got this `max_window_bits` parameter in a Request/Response, and we also know\n          // that it didn't include an \"=\" (otherwise the value wouldn't be null).\n          // It's important to retain the information that the parameter was received *without* a\n          // corresponding value, as this may determine whether the offer is valid or not.\n          //\n          // To retain this information, we'll set `maxBitsSetting` to be an empty ArrayPtr so this\n          // can be dealt with properly later.\n          maxBitsSetting = ArrayPtr<const char>();\n        }\n      }\n    } else {\n      // Invalid parameter.\n      return kj::none;\n    }\n  }\n  return kj::mv(config);\n}\n\nkj::Maybe<CompressionParameters> validateCompressionConfig(UnverifiedConfig&& config,\n    bool isAgreement) {\n  // Verifies that the `config` is valid depending on whether we're validating a Request (offer) or\n  // a Response (agreement). This essentially consumes the `UnverifiedConfig` and converts it into a\n  // `CompressionParameters` struct.\n  CompressionParameters result;\n\n  KJ_IF_SOME(serverBits, config.serverMaxWindowBits) {\n    if (serverBits.size() == 0) {\n      // This means `server_max_window_bits` was passed without a value. Since a value is required,\n      // this config is invalid.\n      return kj::none;\n    } else {\n      KJ_IF_SOME(bits, kj::str(serverBits).tryParseAs<size_t>()) {\n        if (bits < 8 || 15 < bits) {\n          // Out of range -- invalid.\n          return kj::none;\n        }\n        if (isAgreement) {\n          result.inboundMaxWindowBits = bits;\n        } else {\n          result.outboundMaxWindowBits = bits;\n        }\n      } else {\n        // Invalid ABNF, expected 1*DIGIT.\n        return kj::none;\n      }\n    }\n  }\n\n  KJ_IF_SOME(clientBits, config.clientMaxWindowBits) {\n    if (clientBits.size() == 0) {\n      if (!isAgreement) {\n        // `client_max_window_bits` does not need to have a value in an offer, let's set it to 15\n        // to get the best level of compression.\n        result.inboundMaxWindowBits = 15;\n      } else {\n        // `client_max_window_bits` must have a value in a Response.\n        return kj::none;\n      }\n    } else {\n      KJ_IF_SOME(bits, kj::str(clientBits).tryParseAs<size_t>()) {\n        if (bits < 8 || 15 < bits) {\n          // Out of range -- invalid.\n          return kj::none;\n        }\n        if (isAgreement) {\n          result.outboundMaxWindowBits = bits;\n        } else {\n          result.inboundMaxWindowBits = bits;\n        }\n      } else {\n        // Invalid ABNF, expected 1*DIGIT.\n        return kj::none;\n      }\n    }\n  }\n\n  if (isAgreement) {\n    result.outboundNoContextTakeover = config.clientNoContextTakeover;\n    result.inboundNoContextTakeover = config.serverNoContextTakeover;\n  } else {\n    result.inboundNoContextTakeover = config.clientNoContextTakeover;\n    result.outboundNoContextTakeover = config.serverNoContextTakeover;\n  }\n  return kj::mv(result);\n}\n\ninline kj::Maybe<CompressionParameters> tryExtractParameters(\n    kj::Vector<kj::ArrayPtr<const char>>& configuration,\n    bool isAgreement) {\n  // If the `configuration` is structured correctly and has no invalid parameters/values, we will\n  // return a populated `CompressionParameters` struct.\n  if (configuration.size() == 1) {\n    // Plain `permessage-deflate`.\n    return CompressionParameters{};\n  }\n  auto params = configuration.slice(1, configuration.size());\n  auto keyMaybeValuePairs = toKeysAndVals(params);\n  // Parse parameter strings into parameter[=value] pairs.\n  auto maybeUnverified = populateUnverifiedConfig(keyMaybeValuePairs);\n  KJ_IF_SOME(unverified, maybeUnverified) {\n    // Parsing succeeded, i.e. the parameter (`key`) names are valid and we don't have\n    // values for `x_no_context_takeover` parameters (the configuration is structured correctly).\n    // All that's left is to check the `x_max_window_bits` values (if any are present).\n    KJ_IF_SOME(validConfig, validateCompressionConfig(kj::mv(unverified), isAgreement)) {\n      return kj::mv(validConfig);\n    }\n  }\n  return kj::none;\n}\n\nkj::Vector<CompressionParameters> findValidExtensionOffers(StringPtr offers) {\n  // A function to be called by the client that wants to offer extensions through\n  // `Sec-WebSocket-Extensions`. This function takes the value of the header (a string) and\n  // populates a Vector of all the valid offers.\n  kj::Vector<CompressionParameters> result;\n\n  auto extensions = splitParts(offers, ',');\n\n  for (const auto& offer : extensions) {\n    auto splitOffer = splitParts(offer, ';');\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      continue;\n    }\n    KJ_IF_SOME(validated, tryExtractParameters(splitOffer, false)) {\n      // We need to swap the inbound/outbound properties since `tryExtractParameters` thinks we're\n      // parsing as the server (`isAgreement` is false).\n      auto tempCtx = validated.inboundNoContextTakeover;\n      validated.inboundNoContextTakeover = validated.outboundNoContextTakeover;\n      validated.outboundNoContextTakeover = tempCtx;\n      auto tempWindow = validated.inboundMaxWindowBits;\n      validated.inboundMaxWindowBits = validated.outboundMaxWindowBits;\n      validated.outboundMaxWindowBits = tempWindow;\n      result.add(kj::mv(validated));\n    }\n  }\n\n  return kj::mv(result);\n}\n\nkj::String generateExtensionRequest(const ArrayPtr<CompressionParameters>& extensions) {\n  // Build the `Sec-WebSocket-Extensions` request from the validated parameters.\n  constexpr auto EXT = \"permessage-deflate\"_kj;\n  auto offers = kj::heapArray<String>(extensions.size());\n  size_t i = 0;\n  for (const auto& offer : extensions) {\n    offers[i] = kj::str(EXT);\n    if (offer.outboundNoContextTakeover) {\n      offers[i] = kj::str(offers[i], \"; client_no_context_takeover\");\n    }\n    if (offer.inboundNoContextTakeover) {\n      offers[i] = kj::str(offers[i], \"; server_no_context_takeover\");\n    }\n    if (offer.outboundMaxWindowBits != kj::none) {\n      auto w = KJ_ASSERT_NONNULL(offer.outboundMaxWindowBits);\n      offers[i] = kj::str(offers[i], \"; client_max_window_bits=\", w);\n    }\n    if (offer.inboundMaxWindowBits != kj::none) {\n      auto w = KJ_ASSERT_NONNULL(offer.inboundMaxWindowBits);\n      offers[i] = kj::str(offers[i], \"; server_max_window_bits=\", w);\n    }\n    ++i;\n  }\n  return kj::strArray(offers, \", \");\n}\n\nkj::Maybe<CompressionParameters> tryParseExtensionOffers(StringPtr offers) {\n  // Given a string of offers, accept the first valid offer by returning a `CompressionParameters`\n  // struct. If there are no valid offers, return `kj::none`.\n  auto splitOffers = splitParts(offers, ',');\n\n  for (const auto& offer : splitOffers) {\n    auto splitOffer = splitParts(offer, ';');\n\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      // Extension token was invalid.\n      continue;\n    }\n    KJ_IF_SOME(config, tryExtractParameters(splitOffer, false)) {\n      return kj::mv(config);\n    }\n  }\n  return kj::none;\n}\n\nkj::Maybe<CompressionParameters> tryParseAllExtensionOffers(StringPtr offers,\n    CompressionParameters manualConfig) {\n  // Similar to `tryParseExtensionOffers()`, however, this function is called when parsing in\n  // `MANUAL_COMPRESSION` mode. In some cases, the server's configuration might not support the\n  // `server_no_context_takeover` or `server_max_window_bits` parameters. Essentially, this function\n  // will look at all the client's offers, and accept the first one that it can support.\n  //\n  // We differentiate these functions because in `AUTOMATIC_COMPRESSION` mode, KJ can support these\n  // server restricting compression parameters.\n  auto splitOffers = splitParts(offers, ',');\n\n  for (const auto& offer : splitOffers) {\n    auto splitOffer = splitParts(offer, ';');\n\n    if (splitOffer.front() != \"permessage-deflate\"_kj) {\n      // Extension token was invalid.\n      continue;\n    }\n    KJ_IF_SOME(config, tryExtractParameters(splitOffer, false)) {\n      KJ_IF_SOME(finalConfig, compareClientAndServerConfigs(config, manualConfig)) {\n        // Found a compatible configuration between the server's config and client's offer.\n        return kj::mv(finalConfig);\n      }\n    }\n  }\n  return kj::none;\n}\n\nkj::Maybe<CompressionParameters> compareClientAndServerConfigs(CompressionParameters requestConfig,\n    CompressionParameters manualConfig) {\n  // We start from the `manualConfig` and go through a series of filters to get a compression\n  // configuration that both the client and the server can agree upon. If no agreement can be made,\n  // we return null.\n\n  CompressionParameters acceptedParameters = manualConfig;\n\n  // We only need to modify `client_no_context_takeover` and `server_no_context_takeover` when\n  // `manualConfig` doesn't include them.\n  if (manualConfig.inboundNoContextTakeover == false) {\n    acceptedParameters.inboundNoContextTakeover = false;\n  }\n\n  if (manualConfig.outboundNoContextTakeover == false) {\n    acceptedParameters.outboundNoContextTakeover = false;\n    if (requestConfig.outboundNoContextTakeover == true) {\n      // The client has told the server to not use context takeover. This is not a \"hint\",\n      // rather it is a restriction on the server's configuration. If the server does not support\n      // the configuration, it must reject the offer.\n      return kj::none;\n    }\n  }\n\n  // client_max_window_bits\n  if (requestConfig.inboundMaxWindowBits != kj::none &&\n      manualConfig.inboundMaxWindowBits != kj::none)  {\n    // We want `min(requestConfig, manualConfig)` in this case.\n    auto reqBits = KJ_ASSERT_NONNULL(requestConfig.inboundMaxWindowBits);\n    auto manualBits = KJ_ASSERT_NONNULL(manualConfig.inboundMaxWindowBits);\n    if (reqBits < manualBits) {\n      acceptedParameters.inboundMaxWindowBits = reqBits;\n    }\n  } else {\n    // We will not reply with `client_max_window_bits`.\n    acceptedParameters.inboundMaxWindowBits = kj::none;\n  }\n\n  // server_max_window_bits\n  if (manualConfig.outboundMaxWindowBits != kj::none) {\n    auto manualBits = KJ_ASSERT_NONNULL(manualConfig.outboundMaxWindowBits);\n    if (requestConfig.outboundMaxWindowBits != kj::none) {\n      // We want `min(requestConfig, manualConfig)` in this case.\n      auto reqBits = KJ_ASSERT_NONNULL(requestConfig.outboundMaxWindowBits);\n      if (reqBits < manualBits) {\n        acceptedParameters.outboundMaxWindowBits = reqBits;\n      }\n    }\n  } else {\n    acceptedParameters.outboundMaxWindowBits = kj::none;\n    if (requestConfig.outboundMaxWindowBits != kj::none) {\n      // The client has told the server to use `server_max_window_bits`. This is not a \"hint\",\n      // rather it is a restriction on the server's configuration. If the server does not support\n      // the configuration, it must reject the offer.\n      return kj::none;\n    }\n  }\n  return acceptedParameters;\n}\n\nkj::String generateExtensionResponse(const CompressionParameters& parameters) {\n  // Build the `Sec-WebSocket-Extensions` response from the agreed parameters.\n  kj::String response = kj::str(\"permessage-deflate\");\n  if (parameters.inboundNoContextTakeover) {\n    response = kj::str(response, \"; client_no_context_takeover\");\n  }\n  if (parameters.outboundNoContextTakeover) {\n    response = kj::str(response, \"; server_no_context_takeover\");\n  }\n  if (parameters.inboundMaxWindowBits != kj::none) {\n    auto w = KJ_REQUIRE_NONNULL(parameters.inboundMaxWindowBits);\n    response = kj::str(response, \"; client_max_window_bits=\", w);\n  }\n  if (parameters.outboundMaxWindowBits != kj::none) {\n    auto w = KJ_REQUIRE_NONNULL(parameters.outboundMaxWindowBits);\n    response = kj::str(response, \"; server_max_window_bits=\", w);\n  }\n  return kj::mv(response);\n}\n\nkj::OneOf<CompressionParameters, kj::Exception> tryParseExtensionAgreement(\n    const Maybe<CompressionParameters>& clientOffer,\n    StringPtr agreedParameters) {\n  // Like `tryParseExtensionOffers`, but called by the client when parsing the server's Response.\n  // If the client must decline the agreement, we want to provide some details about what went wrong\n  // (since the client has to fail the connection).\n  constexpr auto FAILURE = \"Server failed WebSocket handshake: \"_kj;\n  auto e = KJ_EXCEPTION(FAILED);\n\n  if (clientOffer == kj::none) {\n    // We've received extensions when we did not send any in the first place.\n    e.setDescription(\n        kj::str(FAILURE, \"added Sec-WebSocket-Extensions when client did not offer any.\"));\n    return kj::mv(e);\n  }\n\n  auto offers = splitParts(agreedParameters, ',');\n  if (offers.size() != 1) {\n    constexpr auto EXPECT = \"expected exactly one extension (permessage-deflate) but received \"\n                            \"more than one.\"_kj;\n    e.setDescription(kj::str(FAILURE, EXPECT));\n    return kj::mv(e);\n  }\n  auto splitOffer = splitParts(offers.front(), ';');\n\n  if (splitOffer.front() != \"permessage-deflate\"_kj) {\n    e.setDescription(kj::str(FAILURE, \"response included a Sec-WebSocket-Extensions value that was \"\n                                      \"not permessage-deflate.\"));\n    return kj::mv(e);\n  }\n\n  // Verify the parameters of our single extension, and compare it with the clients original offer.\n  KJ_IF_SOME(config, tryExtractParameters(splitOffer, true)) {\n    const auto& client = KJ_ASSERT_NONNULL(clientOffer);\n    // The server might have ignored the client's hints regarding its compressor's configuration.\n    // That's fine, but as the client, we still want to use those outbound compression parameters.\n    if (config.outboundMaxWindowBits == kj::none) {\n      config.outboundMaxWindowBits = client.outboundMaxWindowBits;\n    } else KJ_IF_SOME(value, client.outboundMaxWindowBits) {\n      if (value < KJ_ASSERT_NONNULL(config.outboundMaxWindowBits)) {\n        // If the client asked for a value smaller than what the server responded with, use the\n        // value that the client originally specified.\n        config.outboundMaxWindowBits = value;\n      }\n    }\n    if (config.outboundNoContextTakeover == false) {\n      config.outboundNoContextTakeover = client.outboundNoContextTakeover;\n    }\n    return kj::mv(config);\n  }\n\n  // There was a problem parsing the server's `Sec-WebSocket-Extensions` response.\n  e.setDescription(kj::str(FAILURE, \"the Sec-WebSocket-Extensions header in the Response included \"\n      \"an invalid value.\"));\n  return kj::mv(e);\n}\n} // namespace _ (private)\nnamespace {\nclass NullInputStream final: public kj::AsyncInputStream {\npublic:\n  NullInputStream(kj::Maybe<size_t> expectedLength = size_t(0))\n      : expectedLength(expectedLength) {}\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return expectedLength;\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount) override {\n    return constPromise<uint64_t, 0>();\n  }\n\nprivate:\n  kj::Maybe<size_t> expectedLength;\n};\n\nclass NullOutputStream final: public kj::AsyncOutputStream {\npublic:\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n\n  // We can't really optimize tryPumpFrom() unless AsyncInputStream grows a skip() method.\n};\n\nclass NullIoStream final: public kj::AsyncIoStream {\npublic:\n  void shutdownWrite() override {}\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    return kj::READY_NOW;\n  }\n  Promise<void> whenWriteDisconnected() override {\n    return kj::NEVER_DONE;\n  }\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return constPromise<size_t, 0>();\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return kj::Maybe<uint64_t>((uint64_t)0);\n  }\n\n  kj::Promise<uint64_t> pumpTo(AsyncOutputStream& output, uint64_t amount) override {\n    return constPromise<uint64_t, 0>();\n  }\n};\n\nclass HttpClientImpl final: public HttpClient,\n                            private HttpClientErrorHandler {\npublic:\n  HttpClientImpl(const HttpHeaderTable& responseHeaderTable, kj::Own<kj::AsyncIoStream> rawStream,\n                 HttpClientSettings settings)\n      : httpInput(*rawStream, responseHeaderTable),\n        httpOutput(*rawStream),\n        ownStream(kj::mv(rawStream)),\n        settings(kj::mv(settings)) {}\n\n  bool canReuse() {\n    // Returns true if we can immediately reuse this HttpClient for another message (so all\n    // previous messages have been fully read).\n\n    return !upgraded && !closed && httpInput.canReuse() && httpOutput.canReuse();\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    KJ_REQUIRE(httpOutput.canReuse(),\n        \"can't start new request until previous request body has been fully written\");\n    closeWatcherTask = kj::none;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n    kj::String lengthStr;\n\n    bool isGet = method == HttpMethod::GET || method == HttpMethod::HEAD;\n    bool hasBody;\n\n    KJ_IF_SOME(s, expectedBodySize) {\n      if (isGet && s == 0) {\n        // GET with empty body; don't send any Content-Length.\n        hasBody = false;\n      } else {\n        lengthStr = kj::str(s);\n        connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = lengthStr;\n        hasBody = true;\n      }\n    } else {\n      if (isGet && headers.get(HttpHeaderId::TRANSFER_ENCODING) == kj::none) {\n        // GET with empty body; don't send any Transfer-Encoding.\n        hasBody = false;\n      } else {\n        // HACK: Normally GET requests shouldn't have bodies. But, if the caller set a\n        //   Transfer-Encoding header on a GET, we use this as a special signal that it might\n        //   actually want to send a body. This allows pass-through of a GET request with a chunked\n        //   body to \"just work\". We strongly discourage writing any new code that sends\n        //   full-bodied GETs.\n        connectionHeaders[HttpHeaders::BuiltinIndices::TRANSFER_ENCODING] = \"chunked\";\n        hasBody = true;\n      }\n    }\n\n    httpOutput.writeHeaders(headers.serializeRequest(method, url, connectionHeaders));\n\n    kj::Own<kj::AsyncOutputStream> bodyStream;\n    if (!hasBody) {\n      // No entity-body.\n      httpOutput.finishBody();\n      bodyStream = heap<HttpNullEntityWriter>();\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      bodyStream = heap<HttpFixedLengthEntityWriter>(httpOutput, s);\n    } else {\n      bodyStream = heap<HttpChunkedEntityWriter>(httpOutput);\n    }\n\n    auto id = ++counter;\n\n    auto responsePromise = httpInput.readResponseHeaders().then(\n        [this,method,id](HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError)\n            -> HttpClient::Response {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          HttpClient::Response result {\n            response.statusCode,\n            response.statusText,\n            &responseHeaders,\n            httpInput.getEntityBody(\n                HttpInputStreamImpl::RESPONSE, method, response.statusCode, responseHeaders)\n          };\n\n          if (fastCaseCmp<'c', 'l', 'o', 's', 'e'>(\n              responseHeaders.get(HttpHeaderId::CONNECTION).orDefault(nullptr).cStr())) {\n            closed = true;\n          } else if (counter == id) {\n            watchForClose();\n          } else {\n            // Another request was already queued after this one, so we don't want to watch for\n            // stream closure because we're fully expecting another response.\n          }\n          return result;\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          closed = true;\n          return settings.errorHandler.orDefault(*this).handleProtocolError(\n              kj::mv(protocolError));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n\n    return { kj::mv(bodyStream), kj::mv(responsePromise) };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    closeWatcherTask = kj::none;\n\n    // Mark upgraded for now, even though the upgrade could fail, because we can't allow pipelined\n    // requests in the meantime.\n    upgraded = true;\n\n    byte keyBytes[16];\n    KJ_ASSERT_NONNULL(settings.entropySource,\n        \"can't use openWebSocket() because no EntropySource was provided when creating the \"\n        \"HttpClient\").generate(keyBytes);\n    auto keyBase64 = kj::encodeBase64(keyBytes);\n\n    kj::StringPtr connectionHeaders[HttpHeaders::WEBSOCKET_CONNECTION_HEADERS_COUNT];\n    connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"Upgrade\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::UPGRADE] = \"websocket\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_VERSION] = \"13\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_KEY] = keyBase64;\n\n    kj::Maybe<kj::String> offeredExtensions;\n    kj::Maybe<CompressionParameters> clientOffer;\n    kj::Vector<CompressionParameters> extensions;\n    auto compressionMode = settings.webSocketCompressionMode;\n\n    if (compressionMode == HttpClientSettings::MANUAL_COMPRESSION) {\n      KJ_IF_SOME(value, headers.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // Strip all `Sec-WebSocket-Extensions` except for `permessage-deflate`.\n        extensions = _::findValidExtensionOffers(value);\n      }\n    } else if (compressionMode == HttpClientSettings::AUTOMATIC_COMPRESSION) {\n      // If AUTOMATIC_COMPRESSION is enabled, we send `Sec-WebSocket-Extensions: permessage-deflate`\n      // to the server and ignore the `headers` provided by the caller.\n      extensions.add(CompressionParameters());\n    }\n\n    if (extensions.size() > 0) {\n      clientOffer = extensions.front();\n      // We hold on to a copy of the client's most preferred offer so even if the server\n      // ignores `client_no_context_takeover` or `client_max_window_bits`, we can still refer to\n      // the original offer made by the client (thereby allowing the client to use these parameters).\n      //\n      // It's safe to ignore the remaining offers because:\n      //  1. Offers are ordered by preference.\n      //  2. `client_x` parameters are hints to the server and do not result in rejections, so the\n      //     client is likely to put them in every offer anyways.\n      connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_EXTENSIONS] =\n          offeredExtensions.emplace(_::generateExtensionRequest(extensions.asPtr()));\n    }\n\n    httpOutput.writeHeaders(headers.serializeRequest(HttpMethod::GET, url, connectionHeaders));\n\n    // No entity-body.\n    httpOutput.finishBody();\n\n    auto id = ++counter;\n\n    return httpInput.readResponseHeaders()\n        .then([this,id,keyBase64 = kj::mv(keyBase64),clientOffer = kj::mv(clientOffer)](\n            HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError)\n            -> HttpClient::WebSocketResponse {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          if (response.statusCode == 101) {\n            if (!fastCaseCmp<'w', 'e', 'b', 's', 'o', 'c', 'k', 'e', 't'>(\n                    responseHeaders.get(HttpHeaderId::UPGRADE).orDefault(nullptr).cStr())) {\n              kj::String ownMessage;\n              kj::StringPtr message;\n              KJ_IF_SOME(actual, responseHeaders.get(HttpHeaderId::UPGRADE)) {\n                ownMessage = kj::str(\n                    \"Server failed WebSocket handshake: incorrect Upgrade header: \"\n                    \"expected 'websocket', got '\", actual, \"'.\");\n                message = ownMessage;\n              } else {\n                message = \"Server failed WebSocket handshake: missing Upgrade header.\";\n              }\n              return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                502, \"Bad Gateway\", message, nullptr\n              });\n            }\n\n            auto expectedAccept = generateWebSocketAccept(keyBase64);\n            if (responseHeaders.get(HttpHeaderId::SEC_WEBSOCKET_ACCEPT).orDefault(nullptr)\n                  != expectedAccept) {\n              kj::String ownMessage;\n              kj::StringPtr message;\n              KJ_IF_SOME(actual, responseHeaders.get(HttpHeaderId::SEC_WEBSOCKET_ACCEPT)) {\n                ownMessage = kj::str(\n                    \"Server failed WebSocket handshake: incorrect Sec-WebSocket-Accept header: \"\n                    \"expected '\", expectedAccept, \"', got '\", actual, \"'.\");\n                message = ownMessage;\n              } else {\n                message = \"Server failed WebSocket handshake: missing Upgrade header.\";\n              }\n              return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                502, \"Bad Gateway\", message, nullptr\n              });\n            }\n\n            kj::Maybe<CompressionParameters> compressionParameters;\n            if (settings.webSocketCompressionMode != HttpClientSettings::NO_COMPRESSION) {\n              KJ_IF_SOME(agreedParameters, responseHeaders.get(\n                  HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n\n                auto parseResult = _::tryParseExtensionAgreement(clientOffer,\n                    agreedParameters);\n                if (parseResult.is<kj::Exception>()) {\n                  return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError({\n                    502, \"Bad Gateway\", parseResult.get<kj::Exception>().getDescription(), nullptr});\n                }\n                compressionParameters.emplace(kj::mv(parseResult.get<CompressionParameters>()));\n              }\n            }\n\n            return {\n              response.statusCode,\n              response.statusText,\n              &httpInput.getHeaders(),\n              upgradeToWebSocket(kj::mv(ownStream), httpInput, httpOutput, settings.entropySource,\n                  kj::mv(compressionParameters)),\n            };\n          } else {\n            upgraded = false;\n            HttpClient::WebSocketResponse result {\n              response.statusCode,\n              response.statusText,\n              &responseHeaders,\n              httpInput.getEntityBody(HttpInputStreamImpl::RESPONSE, HttpMethod::GET,\n                                      response.statusCode, responseHeaders)\n            };\n            if (fastCaseCmp<'c', 'l', 'o', 's', 'e'>(\n                responseHeaders.get(HttpHeaderId::CONNECTION).orDefault(nullptr).cStr())) {\n              closed = true;\n            } else if (counter == id) {\n              watchForClose();\n            } else {\n              // Another request was already queued after this one, so we don't want to watch for\n              // stream closure because we're fully expecting another response.\n            }\n            return result;\n          }\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          return settings.errorHandler.orDefault(*this).handleWebSocketProtocolError(\n              kj::mv(protocolError));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    KJ_REQUIRE(!upgraded,\n        \"can't make further requests on this HttpClient because it has been or is in the process \"\n        \"of being upgraded\");\n    KJ_REQUIRE(!closed,\n        \"this HttpClient's connection has been closed by the server or due to an error\");\n    KJ_REQUIRE(httpOutput.canReuse(),\n        \"can't start new request until previous request body has been fully written\");\n\n    if (settings.useTls) {\n      KJ_UNIMPLEMENTED(\"This HttpClient does not support TLS.\");\n    }\n\n    closeWatcherTask = kj::none;\n\n    // Mark upgraded for now even though the tunnel could fail, because we can't allow pipelined\n    // requests in the meantime.\n    upgraded = true;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n\n    httpOutput.writeHeaders(headers.serializeConnectRequest(host, connectionHeaders));\n\n    auto id = ++counter;\n\n    auto split = httpInput.readResponseHeaders().then(\n        [this, id](HttpHeaders::ResponseOrProtocolError&& responseOrProtocolError) mutable\n            -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                         kj::Promise<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>>> {\n      KJ_SWITCH_ONEOF(responseOrProtocolError) {\n        KJ_CASE_ONEOF(response, HttpHeaders::Response) {\n          auto& responseHeaders = httpInput.getHeaders();\n          if (response.statusCode < 200 || response.statusCode >= 300) {\n            // Any statusCode that is not in the 2xx range in interpreted\n            // as an HTTP response. Any status code in the 2xx range is\n            // interpreted as a successful CONNECT response.\n            closed = true;\n            return kj::tuple(ConnectRequest::Status(\n              response.statusCode,\n              kj::str(response.statusText),\n              kj::heap(responseHeaders.clone()),\n              httpInput.getEntityBody(\n                  HttpInputStreamImpl::RESPONSE,\n                  HttpConnectMethod(),\n                  response.statusCode,\n                  responseHeaders)),\n              KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n          }\n          KJ_ASSERT(counter == id);\n          return kj::tuple(ConnectRequest::Status(\n            response.statusCode,\n            kj::str(response.statusText),\n            kj::heap(responseHeaders.clone())\n          ), kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(httpInput.releaseBuffer()));\n        }\n        KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n          closed = true;\n          auto response = handleProtocolError(protocolError);\n          return kj::tuple(ConnectRequest::Status(\n            response.statusCode,\n            kj::str(response.statusText),\n            kj::heap(response.headers->clone()),\n            kj::mv(response.body)\n          ), KJ_EXCEPTION(DISCONNECTED, \"the connect request errored\"));\n        }\n      }\n      KJ_UNREACHABLE;\n    }).split();\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),  // Promise for the result\n      heap<AsyncIoStreamWithGuards>(\n          kj::mv(ownStream),\n          kj::mv(kj::get<1>(split)) /* read guard (Promise for the ReleasedBuffer) */,\n          httpOutput.flush() /* write guard (void Promise) */)\n    };\n  }\n\nprivate:\n  HttpInputStreamImpl httpInput;\n  HttpOutputStream httpOutput;\n  kj::Own<AsyncIoStream> ownStream;\n  HttpClientSettings settings;\n  kj::Maybe<kj::Promise<void>> closeWatcherTask;\n  bool upgraded = false;\n  bool closed = false;\n\n  uint counter = 0;\n  // Counts requests for the sole purpose of detecting if more requests have been made after some\n  // point in history.\n\n  void watchForClose() {\n    closeWatcherTask = httpInput.awaitNextMessage()\n        .then([this](bool hasData) -> kj::Promise<void> {\n      if (hasData) {\n        // Uhh... The server sent some data before we asked for anything. Perhaps due to properties\n        // of this application, the server somehow already knows what the next request will be, and\n        // it is trying to optimize. Or maybe this is some sort of test and the server is just\n        // replaying a script. In any case, we will humor it -- leave the data in the buffer and\n        // let it become the response to the next request.\n        return kj::READY_NOW;\n      } else {\n        // EOF -- server disconnected.\n        closed = true;\n        if (httpOutput.isInBody()) {\n          // Huh, the application is still sending a request. We should let it finish. We do not\n          // need to proactively free the socket in this case because we know that we're not\n          // sitting in a reusable connection pool, because we know the application is still\n          // actively using the connection.\n          return kj::READY_NOW;\n        } else {\n          return httpOutput.flush().then([this]() {\n            // We might be sitting in NetworkAddressHttpClient's `availableClients` pool. We don't\n            // have a way to notify it to remove this client from the pool; instead, when it tries\n            // to pull this client from the pool later, it will notice the client is dead and will\n            // discard it then. But, we would like to avoid holding on to a socket forever. So,\n            // destroy the socket now.\n            // TODO(cleanup): Maybe we should arrange to proactively remove ourselves? Seems\n            //   like the code will be awkward.\n            ownStream = nullptr;\n          });\n        }\n      }\n    }).eagerlyEvaluate(nullptr);\n  }\n};\n\n}  // namespace\n\nkj::Promise<HttpClient::WebSocketResponse> HttpClient::openWebSocket(\n    kj::StringPtr url, const HttpHeaders& headers) {\n  return request(HttpMethod::GET, url, headers, kj::none)\n      .response.then([](HttpClient::Response&& response) -> WebSocketResponse {\n    kj::OneOf<kj::Own<kj::AsyncInputStream>, kj::Own<WebSocket>> body;\n    body.init<kj::Own<kj::AsyncInputStream>>(kj::mv(response.body));\n\n    return {\n      response.statusCode,\n      response.statusText,\n      response.headers,\n      kj::mv(body)\n    };\n  });\n}\n\nHttpClient::ConnectRequest HttpClient::connect(\n    kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) {\n  KJ_UNIMPLEMENTED(\"CONNECT is not implemented by this HttpClient\");\n}\n\nkj::Own<HttpClient> newHttpClient(\n    const HttpHeaderTable& responseHeaderTable, kj::AsyncIoStream& stream,\n    HttpClientSettings settings) {\n  return kj::heap<HttpClientImpl>(responseHeaderTable,\n      kj::Own<kj::AsyncIoStream>(&stream, kj::NullDisposer::instance),\n      kj::mv(settings));\n}\n\nHttpClient::Response HttpClientErrorHandler::handleProtocolError(\n      HttpHeaders::ProtocolError protocolError) {\n  KJ_FAIL_REQUIRE(protocolError.description) { break; }\n  return HttpClient::Response();\n}\n\nHttpClient::WebSocketResponse HttpClientErrorHandler::handleWebSocketProtocolError(\n      HttpHeaders::ProtocolError protocolError) {\n  auto response = handleProtocolError(protocolError);\n  return HttpClient::WebSocketResponse {\n    response.statusCode, response.statusText, response.headers, kj::mv(response.body)\n  };\n}\n\nkj::Exception WebSocketErrorHandler::handleWebSocketProtocolError(\n      WebSocket::ProtocolError protocolError) {\n  return KJ_EXCEPTION(FAILED, \"WebSocket protocol error\", protocolError.statusCode, protocolError.description);\n}\n\nclass PausableReadAsyncIoStream::PausableRead {\npublic:\n  PausableRead(\n      kj::PromiseFulfiller<size_t>& fulfiller, PausableReadAsyncIoStream& parent,\n      void* buffer, size_t minBytes, size_t maxBytes)\n      : fulfiller(fulfiller), parent(parent),\n        operationBuffer(buffer), operationMinBytes(minBytes), operationMaxBytes(maxBytes),\n        innerRead(parent.tryReadImpl(operationBuffer, operationMinBytes, operationMaxBytes).then(\n            [&fulfiller](size_t size) mutable -> kj::Promise<void> {\n          fulfiller.fulfill(kj::mv(size));\n          return kj::READY_NOW;\n        }, [&fulfiller](kj::Exception&& err) {\n          fulfiller.reject(kj::mv(err));\n        })) {\n    KJ_ASSERT(parent.maybePausableRead == kj::none);\n    parent.maybePausableRead = *this;\n  }\n\n  ~PausableRead() noexcept(false) {\n    parent.maybePausableRead = kj::none;\n  }\n\n  void pause() {\n    innerRead = nullptr;\n  }\n\n  void unpause() {\n    innerRead = parent.tryReadImpl(operationBuffer, operationMinBytes, operationMaxBytes).then(\n        [this](size_t size) -> kj::Promise<void> {\n      fulfiller.fulfill(kj::mv(size));\n      return kj::READY_NOW;\n    }, [this](kj::Exception&& err) {\n      fulfiller.reject(kj::mv(err));\n    });\n  }\n\n  void reject(kj::Exception&& exc) {\n    fulfiller.reject(kj::mv(exc));\n  }\nprivate:\n  kj::PromiseFulfiller<size_t>& fulfiller;\n  PausableReadAsyncIoStream& parent;\n\n  void* operationBuffer;\n  size_t operationMinBytes;\n  size_t operationMaxBytes;\n  // The parameters of the current tryRead call. Used to unpause a paused read.\n\n  kj::Promise<void> innerRead;\n  // The current pending read.\n};\n\n_::Deferred<kj::Function<void()>> PausableReadAsyncIoStream::trackRead() {\n  KJ_REQUIRE(!currentlyReading, \"only one read is allowed at any one time\");\n  currentlyReading = true;\n  return kj::defer<kj::Function<void()>>([this]() { currentlyReading = false; });\n}\n\n_::Deferred<kj::Function<void()>> PausableReadAsyncIoStream::trackWrite() {\n  KJ_REQUIRE(!currentlyWriting, \"only one write is allowed at any one time\");\n  currentlyWriting = true;\n  return kj::defer<kj::Function<void()>>([this]() { currentlyWriting = false; });\n}\n\nkj::Promise<size_t> PausableReadAsyncIoStream::tryRead(\n    void* buffer, size_t minBytes, size_t maxBytes) {\n  return kj::newAdaptedPromise<size_t, PausableRead>(*this, buffer, minBytes, maxBytes);\n}\n\nkj::Promise<size_t> PausableReadAsyncIoStream::tryReadImpl(\n    void* buffer, size_t minBytes, size_t maxBytes) {\n  // Hack: evalNow used here because `newAdaptedPromise` has a bug. We may need to change\n  // `PromiseDisposer::alloc` to not be `noexcept` but in order to do so we'll need to benchmark\n  // its performance.\n  return kj::evalNow([&]() -> kj::Promise<size_t> {\n    return inner->tryRead(buffer, minBytes, maxBytes).attach(trackRead());\n  });\n}\n\nkj::Maybe<uint64_t> PausableReadAsyncIoStream::tryGetLength() {\n  return inner->tryGetLength();\n}\n\nkj::Promise<uint64_t> PausableReadAsyncIoStream::pumpTo(\n    kj::AsyncOutputStream& output, uint64_t amount) {\n  return kj::unoptimizedPumpTo(*this, output, amount);\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::write(const void* buffer, size_t size) {\n  return inner->write(buffer, size).attach(trackWrite());\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::write(\n    kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) {\n  return inner->write(pieces).attach(trackWrite());\n}\n\nkj::Maybe<kj::Promise<uint64_t>> PausableReadAsyncIoStream::tryPumpFrom(\n    kj::AsyncInputStream& input, uint64_t amount) {\n  auto result = inner->tryPumpFrom(input, amount);\n  KJ_IF_SOME(r, result) {\n    return r.attach(trackWrite());\n  } else {\n    return kj::none;\n  }\n}\n\nkj::Promise<void> PausableReadAsyncIoStream::whenWriteDisconnected() {\n  return inner->whenWriteDisconnected();\n}\n\nvoid PausableReadAsyncIoStream::shutdownWrite() {\n  inner->shutdownWrite();\n}\n\nvoid PausableReadAsyncIoStream::abortRead() {\n  inner->abortRead();\n}\n\nkj::Maybe<int> PausableReadAsyncIoStream::getFd() const {\n  return inner->getFd();\n}\n\nvoid PausableReadAsyncIoStream::pause() {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.pause();\n  }\n}\n\nvoid PausableReadAsyncIoStream::unpause() {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.unpause();\n  }\n}\n\nbool PausableReadAsyncIoStream::getCurrentlyReading() {\n  return currentlyReading;\n}\n\nbool PausableReadAsyncIoStream::getCurrentlyWriting() {\n  return currentlyWriting;\n}\n\nkj::Own<kj::AsyncIoStream> PausableReadAsyncIoStream::takeStream() {\n  return kj::mv(inner);\n}\n\nvoid PausableReadAsyncIoStream::replaceStream(kj::Own<kj::AsyncIoStream> stream) {\n  inner = kj::mv(stream);\n}\n\nvoid PausableReadAsyncIoStream::reject(kj::Exception&& exc) {\n  KJ_IF_SOME(pausable, maybePausableRead) {\n    pausable.reject(kj::mv(exc));\n  }\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass NetworkAddressHttpClient final: public HttpClient {\npublic:\n  NetworkAddressHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                           kj::Own<kj::NetworkAddress> address, HttpClientSettings settings)\n      : timer(timer),\n        responseHeaderTable(responseHeaderTable),\n        address(kj::mv(address)),\n        settings(kj::mv(settings)) {}\n\n  bool isDrained() {\n    // Returns true if there are no open connections.\n    return activeConnectionCount == 0 && availableClients.empty();\n  }\n\n  kj::Promise<void> onDrained() {\n    // Returns a promise which resolves the next time isDrained() transitions from false to true.\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    drainedFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    auto refcounted = getClient();\n    auto result = refcounted->client->request(method, url, headers, expectedBodySize);\n    result.body = result.body.attach(kj::addRef(*refcounted));\n    result.response = result.response.then(\n        [refcounted=kj::mv(refcounted)](Response&& response) mutable {\n      response.body = response.body.attach(kj::mv(refcounted));\n      return kj::mv(response);\n    });\n    return result;\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    auto refcounted = getClient();\n    auto result = refcounted->client->openWebSocket(url, headers);\n    return result.then(\n        [refcounted=kj::mv(refcounted)](WebSocketResponse&& response) mutable {\n      KJ_SWITCH_ONEOF(response.webSocketOrBody) {\n        KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n          response.webSocketOrBody = body.attach(kj::mv(refcounted));\n        }\n        KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n          // The only reason we need to attach the client to the WebSocket is because otherwise\n          // the response headers will be deleted prematurely. Otherwise, the WebSocket has taken\n          // ownership of the connection.\n          //\n          // TODO(perf): Maybe we could transfer ownership of the response headers specifically?\n          response.webSocketOrBody = ws.attach(kj::mv(refcounted));\n        }\n      }\n      return kj::mv(response);\n    });\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    auto refcounted = getClient();\n    auto request = refcounted->client->connect(host, headers, settings);\n    return ConnectRequest {\n      request.status.attach(kj::addRef(*refcounted)),\n      request.connection.attach(kj::mv(refcounted))\n    };\n  }\n\nprivate:\n  kj::Timer& timer;\n  const HttpHeaderTable& responseHeaderTable;\n  kj::Own<kj::NetworkAddress> address;\n  HttpClientSettings settings;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> drainedFulfiller;\n  uint activeConnectionCount = 0;\n\n  bool timeoutsScheduled = false;\n  kj::Promise<void> timeoutTask = nullptr;\n\n  struct AvailableClient {\n    kj::Own<HttpClientImpl> client;\n    kj::TimePoint expires;\n  };\n\n  std::deque<AvailableClient> availableClients;\n\n  struct RefcountedClient final: public kj::Refcounted {\n    RefcountedClient(NetworkAddressHttpClient& parent, kj::Own<HttpClientImpl> client)\n        : parent(parent), client(kj::mv(client)) {\n      ++parent.activeConnectionCount;\n    }\n    ~RefcountedClient() noexcept(false) {\n      --parent.activeConnectionCount;\n      KJ_IF_SOME(exception, kj::runCatchingExceptions([&]() {\n        parent.returnClientToAvailable(kj::mv(client));\n      })) {\n        KJ_LOG(ERROR, exception);\n      }\n    }\n\n    NetworkAddressHttpClient& parent;\n    kj::Own<HttpClientImpl> client;\n  };\n\n  kj::Own<RefcountedClient> getClient() {\n    for (;;) {\n      if (availableClients.empty()) {\n        auto stream = newPromisedStream(address->connect());\n        return kj::refcounted<RefcountedClient>(*this,\n          kj::heap<HttpClientImpl>(responseHeaderTable, kj::mv(stream), settings));\n      } else {\n        auto client = kj::mv(availableClients.back().client);\n        availableClients.pop_back();\n        if (client->canReuse()) {\n          return kj::refcounted<RefcountedClient>(*this, kj::mv(client));\n        }\n        // Whoops, this client's connection was closed by the server at some point. Discard.\n      }\n    }\n  }\n\n  void returnClientToAvailable(kj::Own<HttpClientImpl> client) {\n    // Only return the connection to the pool if it is reusable and if our settings indicate we\n    // should reuse connections.\n    if (client->canReuse() && settings.idleTimeout > 0 * kj::SECONDS) {\n      availableClients.push_back(AvailableClient {\n        kj::mv(client), timer.now() + settings.idleTimeout\n      });\n    }\n\n    // Call this either way because it also signals onDrained().\n    if (!timeoutsScheduled) {\n      timeoutsScheduled = true;\n      timeoutTask = applyTimeouts();\n    }\n  }\n\n  kj::Promise<void> applyTimeouts() {\n    if (availableClients.empty()) {\n      timeoutsScheduled = false;\n      if (activeConnectionCount == 0) {\n        KJ_IF_SOME(f, drainedFulfiller) {\n          f->fulfill();\n          drainedFulfiller = kj::none;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      auto time = availableClients.front().expires;\n      return timer.atTime(time).then([this,time]() {\n        while (!availableClients.empty() && availableClients.front().expires <= time) {\n          availableClients.pop_front();\n        }\n        return applyTimeouts();\n      });\n    }\n  }\n};\n\nclass TransitionaryAsyncIoStream final: public kj::AsyncIoStream {\n  // This specialised AsyncIoStream is used by NetworkHttpClient to support startTls.\npublic:\n  TransitionaryAsyncIoStream(kj::Own<kj::AsyncIoStream> unencryptedStream)\n      : inner(kj::heap<kj::PausableReadAsyncIoStream>(kj::mv(unencryptedStream))) {}\n\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return inner->tryRead(buffer, minBytes, maxBytes);\n  }\n\n  kj::Maybe<uint64_t> tryGetLength() override {\n    return inner->tryGetLength();\n  }\n\n  kj::Promise<uint64_t> pumpTo(kj::AsyncOutputStream& output, uint64_t amount) override {\n    return inner->pumpTo(output, amount);\n  }\n\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n    return inner->write(buffer, size);\n  }\n\n  kj::Promise<void> write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n    return inner->write(pieces);\n  }\n\n  kj::Maybe<kj::Promise<uint64_t>> tryPumpFrom(\n      kj::AsyncInputStream& input, uint64_t amount = kj::maxValue) override {\n    return inner->tryPumpFrom(input, amount);\n  }\n\n  kj::Promise<void> whenWriteDisconnected() override {\n    return inner->whenWriteDisconnected();\n  }\n\n  void shutdownWrite() override {\n    inner->shutdownWrite();\n  }\n\n  void abortRead() override {\n    inner->abortRead();\n  }\n\n  kj::Maybe<int> getFd() const override {\n    return inner->getFd();\n  }\n\n  void startTls(\n      kj::SecureNetworkWrapper* wrapper, kj::StringPtr expectedServerHostname) {\n    // Pause any potential pending reads.\n    inner->pause();\n\n    KJ_ON_SCOPE_FAILURE({\n      inner->reject(KJ_EXCEPTION(FAILED, \"StartTls failed.\"));\n    });\n\n    KJ_ASSERT(!inner->getCurrentlyReading() && !inner->getCurrentlyWriting(),\n        \"Cannot call startTls while reads/writes are outstanding\");\n    kj::Promise<kj::Own<kj::AsyncIoStream>> secureStream =\n        wrapper->wrapClient(inner->takeStream(), expectedServerHostname);\n    inner->replaceStream(kj::newPromisedStream(kj::mv(secureStream)));\n    // Resume any previous pending reads.\n    inner->unpause();\n  }\n\nprivate:\n  kj::Own<kj::PausableReadAsyncIoStream> inner;\n};\n\nclass PromiseNetworkAddressHttpClient final: public HttpClient {\n  // An HttpClient which waits for a promise to resolve then forwards all calls to the promised\n  // client.\n\npublic:\n  PromiseNetworkAddressHttpClient(kj::Promise<kj::Own<NetworkAddressHttpClient>> promise)\n      : promise(promise.then([this](kj::Own<NetworkAddressHttpClient>&& client) {\n          this->client = kj::mv(client);\n        }).fork()) {}\n\n  bool isDrained() {\n    KJ_IF_SOME(c, client) {\n      return c->isDrained();\n    } else {\n      return failed;\n    }\n  }\n\n  kj::Promise<void> onDrained() {\n    KJ_IF_SOME(c, client) {\n      return c->onDrained();\n    } else {\n      return promise.addBranch().then([this]() {\n        return KJ_ASSERT_NONNULL(client)->onDrained();\n      }, [this](kj::Exception&& e) {\n        // Connecting failed. Treat as immediately drained.\n        failed = true;\n        return kj::READY_NOW;\n      });\n    }\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    KJ_IF_SOME(c, client) {\n      return c->request(method, url, headers, expectedBodySize);\n    } else {\n      // This gets complicated since request() returns a pair of a stream and a promise.\n      auto urlCopy = kj::str(url);\n      auto headersCopy = headers.clone();\n      auto combined = promise.addBranch().then(\n          [this,method,expectedBodySize,url=kj::mv(urlCopy), headers=kj::mv(headersCopy)]()\n          -> kj::Tuple<kj::Own<kj::AsyncOutputStream>, kj::Promise<Response>> {\n        auto req = KJ_ASSERT_NONNULL(client)->request(method, url, headers, expectedBodySize);\n        return kj::tuple(kj::mv(req.body), kj::mv(req.response));\n      });\n\n      auto split = combined.split();\n      return {\n        newPromisedStream(kj::mv(kj::get<0>(split))),\n        kj::mv(kj::get<1>(split))\n      };\n    }\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    KJ_IF_SOME(c, client) {\n      return c->openWebSocket(url, headers);\n    } else {\n      auto urlCopy = kj::str(url);\n      auto headersCopy = headers.clone();\n      return promise.addBranch().then(\n          [this,url=kj::mv(urlCopy),headers=kj::mv(headersCopy)]() {\n        return KJ_ASSERT_NONNULL(client)->openWebSocket(url, headers);\n      });\n    }\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    KJ_IF_SOME(c, client) {\n      return c->connect(host, headers, settings);\n    } else {\n      auto split = promise.addBranch().then(\n          [this, host=kj::str(host), headers=headers.clone(), settings]() mutable\n          -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                       kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n        auto request = KJ_ASSERT_NONNULL(client)->connect(host, headers, kj::mv(settings));\n        return kj::tuple(kj::mv(request.status), kj::mv(request.connection));\n      }).split();\n\n      return ConnectRequest {\n        kj::mv(kj::get<0>(split)),\n        kj::newPromisedStream(kj::mv(kj::get<1>(split)))\n      };\n    }\n  }\n\nprivate:\n  kj::ForkedPromise<void> promise;\n  kj::Maybe<kj::Own<NetworkAddressHttpClient>> client;\n  bool failed = false;\n};\n\nclass NetworkHttpClient final: public HttpClient, private kj::TaskSet::ErrorHandler {\npublic:\n  NetworkHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                    kj::Network& network, kj::Maybe<kj::Network&> tlsNetwork,\n                    HttpClientSettings settings)\n      : timer(timer),\n        responseHeaderTable(responseHeaderTable),\n        network(network),\n        tlsNetwork(tlsNetwork),\n        settings(kj::mv(settings)),\n        tasks(*this) {}\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    // We need to parse the proxy-style URL to convert it to host-style.\n    // Use URL parsing options that avoid unnecessary rewrites.\n    Url::Options urlOptions;\n    urlOptions.allowEmpty = true;\n    urlOptions.percentDecode = false;\n\n    auto parsed = Url::parse(url, Url::HTTP_PROXY_REQUEST, urlOptions);\n    auto path = parsed.toString(Url::HTTP_REQUEST);\n    auto headersCopy = headers.clone();\n    headersCopy.set(HttpHeaderId::HOST, parsed.host);\n    return getClient(parsed).request(method, path, headersCopy, expectedBodySize);\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    // We need to parse the proxy-style URL to convert it to origin-form.\n    // https://www.rfc-editor.org/rfc/rfc9112.html#name-origin-form\n    // Use URL parsing options that avoid unnecessary rewrites.\n    Url::Options urlOptions;\n    urlOptions.allowEmpty = true;\n    urlOptions.percentDecode = false;\n\n    auto parsed = Url::parse(url, Url::HTTP_PROXY_REQUEST, urlOptions);\n    auto path = parsed.toString(Url::HTTP_REQUEST);\n    auto headersCopy = headers.clone();\n    headersCopy.set(HttpHeaderId::HOST, parsed.host);\n    return getClient(parsed).openWebSocket(path, headersCopy);\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers,\n      HttpConnectSettings connectSettings) override {\n    // We want to connect directly instead of going through a proxy here.\n    // https://github.com/capnproto/capnproto/pull/1454#discussion_r900414879\n    kj::Maybe<kj::Promise<kj::Own<kj::NetworkAddress>>> addr;\n    if (connectSettings.useTls) {\n      kj::Network& tlsNet = KJ_REQUIRE_NONNULL(tlsNetwork, \"this HttpClient doesn't support TLS\");\n      addr = tlsNet.parseAddress(host);\n    } else {\n      addr = network.parseAddress(host);\n    }\n\n    auto split = KJ_ASSERT_NONNULL(addr).then([this](auto address) {\n      return address->connect().then([this](auto connection)\n          -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                       kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n        return kj::tuple(\n            ConnectRequest::Status(\n              200,\n              kj::str(\"OK\"),\n              kj::heap<kj::HttpHeaders>(responseHeaderTable) // Empty headers\n            ),\n            kj::mv(connection));\n      }).attach(kj::mv(address));\n    }).split();\n\n    auto connection = kj::newPromisedStream(kj::mv(kj::get<1>(split)));\n\n    if (!connectSettings.useTls) {\n      KJ_IF_SOME(wrapper, settings.tlsContext) {\n        KJ_IF_SOME(tlsStarter, connectSettings.tlsStarter) {\n          auto transitConnectionRef = kj::refcountedWrapper(\n              kj::heap<TransitionaryAsyncIoStream>(kj::mv(connection)));\n          Function<kj::Promise<void>(kj::StringPtr)> cb =\n              [&wrapper, ref1 = transitConnectionRef->addWrappedRef()](\n              kj::StringPtr expectedServerHostname) mutable {\n            ref1->startTls(&wrapper, expectedServerHostname);\n            return kj::READY_NOW;\n          };\n          connection = transitConnectionRef->addWrappedRef();\n          tlsStarter = kj::mv(cb);\n        }\n      }\n    }\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),\n      kj::mv(connection)\n    };\n  }\n\nprivate:\n  kj::Timer& timer;\n  const HttpHeaderTable& responseHeaderTable;\n  kj::Network& network;\n  kj::Maybe<kj::Network&> tlsNetwork;\n  HttpClientSettings settings;\n\n  struct Host {\n    kj::String name;  // including port, if non-default\n    kj::Own<PromiseNetworkAddressHttpClient> client;\n  };\n\n  std::map<kj::StringPtr, Host> httpHosts;\n  std::map<kj::StringPtr, Host> httpsHosts;\n\n  struct RequestInfo {\n    HttpMethod method;\n    kj::String hostname;\n    kj::String path;\n    HttpHeaders headers;\n    kj::Maybe<uint64_t> expectedBodySize;\n  };\n\n  kj::TaskSet tasks;\n\n  HttpClient& getClient(kj::Url& parsed) {\n    bool isHttps = parsed.scheme == \"https\";\n    bool isHttp = parsed.scheme == \"http\";\n    KJ_REQUIRE(isHttp || isHttps);\n\n    auto& hosts = isHttps ? httpsHosts : httpHosts;\n\n    // Look for a cached client for this host.\n    // TODO(perf): It would be nice to recognize when different hosts have the same address and\n    //   reuse the same connection pool, but:\n    //   - We'd need a reliable way to compare NetworkAddresses, e.g. .equals() and .hashCode().\n    //     It's very Java... ick.\n    //   - Correctly handling TLS would be tricky: we'd need to verify that the new hostname is\n    //     on the certificate. When SNI is in use we might have to request an additional\n    //     certificate (is that possible?).\n    auto iter = hosts.find(parsed.host);\n\n    if (iter == hosts.end()) {\n      // Need to open a new connection.\n      kj::Network* networkToUse = &network;\n      if (isHttps) {\n        networkToUse = &KJ_REQUIRE_NONNULL(tlsNetwork, \"this HttpClient doesn't support HTTPS\");\n      }\n\n      auto promise = networkToUse->parseAddress(parsed.host, isHttps ? 443 : 80)\n          .then([this](kj::Own<kj::NetworkAddress> addr) {\n        return kj::heap<NetworkAddressHttpClient>(\n            timer, responseHeaderTable, kj::mv(addr), settings);\n      });\n\n      Host host {\n        kj::mv(parsed.host),\n        kj::heap<PromiseNetworkAddressHttpClient>(kj::mv(promise))\n      };\n      kj::StringPtr nameRef = host.name;\n\n      auto insertResult = hosts.insert(std::make_pair(nameRef, kj::mv(host)));\n      KJ_ASSERT(insertResult.second);\n      iter = insertResult.first;\n\n      tasks.add(handleCleanup(hosts, iter));\n    }\n\n    return *iter->second.client;\n  }\n\n  kj::Promise<void> handleCleanup(std::map<kj::StringPtr, Host>& hosts,\n                                  std::map<kj::StringPtr, Host>::iterator iter) {\n    return iter->second.client->onDrained()\n        .then([this,&hosts,iter]() -> kj::Promise<void> {\n      // Double-check that it's really drained to avoid race conditions.\n      if (iter->second.client->isDrained()) {\n        hosts.erase(iter);\n        return kj::READY_NOW;\n      } else {\n        return handleCleanup(hosts, iter);\n      }\n    });\n  }\n\n  void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }\n};\n\n}  // namespace\n\nkj::Own<HttpClient> newHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                                  kj::NetworkAddress& addr, HttpClientSettings settings) {\n  return kj::heap<NetworkAddressHttpClient>(timer, responseHeaderTable,\n      kj::Own<kj::NetworkAddress>(&addr, kj::NullDisposer::instance), kj::mv(settings));\n}\n\nkj::Own<HttpClient> newHttpClient(kj::Timer& timer, const HttpHeaderTable& responseHeaderTable,\n                                  kj::Network& network, kj::Maybe<kj::Network&> tlsNetwork,\n                                  HttpClientSettings settings) {\n  return kj::heap<NetworkHttpClient>(\n      timer, responseHeaderTable, network, tlsNetwork, kj::mv(settings));\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass ConcurrencyLimitingHttpClient final: public HttpClient {\npublic:\n  KJ_DISALLOW_COPY_AND_MOVE(ConcurrencyLimitingHttpClient);\n  ConcurrencyLimitingHttpClient(\n      kj::HttpClient& inner, uint maxConcurrentRequests,\n      kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback)\n      : inner(inner),\n        maxConcurrentRequests(maxConcurrentRequests),\n        countChangedCallback(kj::mv(countChangedCallback)) {}\n\n  ~ConcurrencyLimitingHttpClient() noexcept(false) {\n    if (concurrentRequests > 0) {\n      static bool logOnce KJ_UNUSED = ([&] {\n        KJ_LOG(ERROR, \"ConcurrencyLimitingHttpClient getting destroyed when concurrent requests \"\n            \"are still active\", concurrentRequests);\n        return true;\n      })();\n    }\n  }\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto request = inner.request(method, url, headers, expectedBodySize);\n      fireCountChanged();\n      auto promise = attachCounter(kj::mv(request.response), kj::mv(counter));\n      return { kj::mv(request.body), kj::mv(promise) };\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n    auto urlCopy = kj::str(url);\n    auto headersCopy = headers.clone();\n\n    auto combined = paf.promise\n        .then([this,\n               method,\n               urlCopy = kj::mv(urlCopy),\n               headersCopy = kj::mv(headersCopy),\n               expectedBodySize](ConnectionCounter&& counter) mutable {\n      auto req = inner.request(method, urlCopy, headersCopy, expectedBodySize);\n      return kj::tuple(kj::mv(req.body), attachCounter(kj::mv(req.response), kj::mv(counter)));\n    });\n    auto split = combined.split();\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n    return { newPromisedStream(kj::mv(kj::get<0>(split))), kj::mv(kj::get<1>(split)) };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const kj::HttpHeaders& headers) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto response = inner.openWebSocket(url, headers);\n      fireCountChanged();\n      return attachCounter(kj::mv(response), kj::mv(counter));\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n    auto urlCopy = kj::str(url);\n    auto headersCopy = headers.clone();\n\n    auto promise = paf.promise\n        .then([this,\n               urlCopy = kj::mv(urlCopy),\n               headersCopy = kj::mv(headersCopy)](ConnectionCounter&& counter) mutable {\n      return attachCounter(inner.openWebSocket(urlCopy, headersCopy), kj::mv(counter));\n    });\n\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n    return kj::mv(promise);\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const kj::HttpHeaders& headers, HttpConnectSettings settings) override {\n    if (concurrentRequests < maxConcurrentRequests) {\n      auto counter = ConnectionCounter(*this);\n      auto response = inner.connect(host, headers, settings);\n      fireCountChanged();\n      return attachCounter(kj::mv(response), kj::mv(counter));\n    }\n\n    auto paf = kj::newPromiseAndFulfiller<ConnectionCounter>();\n\n    auto split = paf.promise\n        .then([this, host=kj::str(host), headers=headers.clone(), settings]\n              (ConnectionCounter&& counter) mutable\n                  -> kj::Tuple<kj::Promise<ConnectRequest::Status>,\n                               kj::Promise<kj::Own<kj::AsyncIoStream>>> {\n      auto request = attachCounter(inner.connect(host, headers, settings), kj::mv(counter));\n      return kj::tuple(kj::mv(request.status), kj::mv(request.connection));\n    }).split();\n\n    pendingRequests.push(kj::mv(paf.fulfiller));\n    fireCountChanged();\n\n    return ConnectRequest {\n      kj::mv(kj::get<0>(split)),\n      kj::newPromisedStream(kj::mv(kj::get<1>(split)))\n    };\n  }\n\nprivate:\n  struct ConnectionCounter;\n\n  kj::HttpClient& inner;\n  uint maxConcurrentRequests;\n  uint concurrentRequests = 0;\n  kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback;\n\n  std::queue<kj::Own<kj::PromiseFulfiller<ConnectionCounter>>> pendingRequests;\n  // TODO(someday): want maximum cap on queue size?\n\n  struct ConnectionCounter final {\n    ConnectionCounter(ConcurrencyLimitingHttpClient& client) : parent(&client) {\n      ++parent->concurrentRequests;\n    }\n    KJ_DISALLOW_COPY(ConnectionCounter);\n    ~ConnectionCounter() noexcept(false) {\n      if (parent != nullptr) {\n        --parent->concurrentRequests;\n        parent->serviceQueue();\n        parent->fireCountChanged();\n      }\n    }\n    ConnectionCounter(ConnectionCounter&& other) : parent(other.parent) {\n      other.parent = nullptr;\n    }\n    ConnectionCounter& operator=(ConnectionCounter&& other) {\n      if (this != &other) {\n        this->parent = other.parent;\n        other.parent = nullptr;\n      }\n      return *this;\n    }\n\n    ConcurrencyLimitingHttpClient* parent;\n  };\n\n  void serviceQueue() {\n    while (concurrentRequests < maxConcurrentRequests && !pendingRequests.empty()) {\n      auto fulfiller = kj::mv(pendingRequests.front());\n      pendingRequests.pop();\n      // ConnectionCounter's destructor calls this function, so we can avoid unnecessary recursion\n      // if we only create a ConnectionCounter when we find a waiting fulfiller.\n      if (fulfiller->isWaiting()) {\n        fulfiller->fulfill(ConnectionCounter(*this));\n      }\n    }\n  }\n\n  void fireCountChanged() {\n    countChangedCallback(concurrentRequests, pendingRequests.size());\n  }\n\n  using WebSocketOrBody = kj::OneOf<kj::Own<kj::AsyncInputStream>, kj::Own<WebSocket>>;\n  static WebSocketOrBody attachCounter(WebSocketOrBody&& webSocketOrBody,\n                                       ConnectionCounter&& counter) {\n    KJ_SWITCH_ONEOF(webSocketOrBody) {\n      KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n        return ws.attach(kj::mv(counter));\n      }\n      KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n        return body.attach(kj::mv(counter));\n      }\n    }\n    KJ_UNREACHABLE;\n  }\n\n  static kj::Promise<WebSocketResponse> attachCounter(kj::Promise<WebSocketResponse>&& promise,\n                                                      ConnectionCounter&& counter) {\n    return promise.then([counter = kj::mv(counter)](WebSocketResponse&& response) mutable {\n      return WebSocketResponse {\n        response.statusCode,\n        response.statusText,\n        response.headers,\n        attachCounter(kj::mv(response.webSocketOrBody), kj::mv(counter))\n      };\n    });\n  }\n\n  static kj::Promise<Response> attachCounter(kj::Promise<Response>&& promise,\n                                             ConnectionCounter&& counter) {\n    return promise.then([counter = kj::mv(counter)](Response&& response) mutable {\n      return Response {\n        response.statusCode,\n        response.statusText,\n        response.headers,\n        response.body.attach(kj::mv(counter))\n      };\n    });\n  }\n\n  static ConnectRequest attachCounter(\n      ConnectRequest&& request,\n      ConnectionCounter&& counter) {\n    // Notice here that we are only attaching the counter to the connection stream. In the case\n    // where the connect tunnel request is rejected and the status promise resolves with an\n    // errorBody, there is a possibility that the consuming code might drop the connection stream\n    // and the counter while the error body stream is still be consumed. Technically speaking that\n    // means we could potentially exceed our concurrency limit temporarily but we consider that\n    // acceptable here since the error body is an exception path (plus not requiring that we\n    // attach to the errorBody keeps ConnectionCounter from having to be a refcounted heap\n    // allocation).\n    request.connection = request.connection.attach(kj::mv(counter));\n    return kj::mv(request);\n  }\n};\n\n}\n\nkj::Own<HttpClient> newConcurrencyLimitingHttpClient(\n    HttpClient& inner, uint maxConcurrentRequests,\n    kj::Function<void(uint runningCount, uint pendingCount)> countChangedCallback) {\n  return kj::heap<ConcurrencyLimitingHttpClient>(inner, maxConcurrentRequests,\n      kj::mv(countChangedCallback));\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpClientAdapter final: public HttpClient {\npublic:\n  HttpClientAdapter(HttpService& service): service(service) {}\n\n  Request request(HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n                  kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n    // We have to clone the URL and headers because HttpService implementation are allowed to\n    // assume that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call.\n    auto urlCopy = kj::str(url);\n    auto headersCopy = kj::heap(headers.clone());\n\n    auto pipe = newOneWayPipe(expectedBodySize);\n\n    // TODO(cleanup): The ownership relationships here are a mess. Can we do something better\n    //   involving a PromiseAdapter, maybe?\n    auto paf = kj::newPromiseAndFulfiller<Response>();\n    auto responder = kj::refcounted<ResponseImpl>(method, kj::mv(paf.fulfiller));\n\n    auto requestPaf = kj::newPromiseAndFulfiller<kj::Promise<void>>();\n    responder->setPromise(kj::mv(requestPaf.promise));\n\n    auto promise = service.request(method, urlCopy, *headersCopy, *pipe.in, *responder)\n        .attach(kj::mv(pipe.in), kj::mv(urlCopy), kj::mv(headersCopy));\n    requestPaf.fulfiller->fulfill(kj::mv(promise));\n\n    return {\n      kj::mv(pipe.out),\n      paf.promise.attach(kj::mv(responder))\n    };\n  }\n\n  kj::Promise<WebSocketResponse> openWebSocket(\n      kj::StringPtr url, const HttpHeaders& headers) override {\n    // We have to clone the URL and headers because HttpService implementation are allowed to\n    // assume that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call. Also we need to add\n    // `Upgrade: websocket` so that headers.isWebSocket() returns true on the service side.\n    auto urlCopy = kj::str(url);\n    auto headersCopy = kj::heap(headers.clone());\n    headersCopy->set(HttpHeaderId::UPGRADE, \"websocket\");\n    KJ_DASSERT(headersCopy->isWebSocket());\n\n    auto paf = kj::newPromiseAndFulfiller<WebSocketResponse>();\n    auto responder = kj::refcounted<WebSocketResponseImpl>(kj::mv(paf.fulfiller));\n\n    auto requestPaf = kj::newPromiseAndFulfiller<kj::Promise<void>>();\n    responder->setPromise(kj::mv(requestPaf.promise));\n\n    auto in = kj::heap<NullInputStream>();\n    auto promise = service.request(HttpMethod::GET, urlCopy, *headersCopy, *in, *responder)\n        .attach(kj::mv(in), kj::mv(urlCopy), kj::mv(headersCopy));\n    requestPaf.fulfiller->fulfill(kj::mv(promise));\n\n    return paf.promise.attach(kj::mv(responder));\n  }\n\n  ConnectRequest connect(\n      kj::StringPtr host, const HttpHeaders& headers, HttpConnectSettings settings) override {\n    // We have to clone the host and the headers because HttpServer implementation are allowed to\n    // assusme that they remain valid until the service handler completes whereas HttpClient callers\n    // are allowed to destroy them immediately after the call.\n    auto hostCopy = kj::str(host);\n    auto headersCopy = kj::heap(headers.clone());\n\n    // 1. Create a new TwoWayPipe, one will be returned with the ConnectRequest,\n    //    the other will be held by the ConnectResponseImpl.\n    auto pipe = kj::newTwoWayPipe();\n\n    // 2. Create a promise/fulfiller pair for the status. The promise will be\n    //    returned with the ConnectResponse, the fulfiller will be held by the\n    //    ConnectResponseImpl.\n    auto paf = kj::newPromiseAndFulfiller<ConnectRequest::Status>();\n\n    // 3. Create the ConnectResponseImpl\n    auto response = kj::refcounted<ConnectResponseImpl>(kj::mv(paf.fulfiller),\n                                                        kj::mv(pipe.ends[0]));\n\n    // 5. Call service.connect, passing in the tunnel.\n    //    The call to tunnel->getConnectStream() returns a guarded stream that will buffer\n    //    writes until the status is indicated by calling accept/reject.\n    auto connectStream = response->getConnectStream();\n    auto promise = service.connect(hostCopy, *headersCopy, *connectStream, *response, settings)\n        .eagerlyEvaluate([response=kj::mv(response),\n                          host=kj::mv(hostCopy),\n                          headers=kj::mv(headersCopy),\n                          connectStream=kj::mv(connectStream)](kj::Exception&& ex) mutable {\n      // A few things need to happen here.\n      //   1. We'll log the exception.\n      //   2. We'll break the pipe.\n      //   3. We'll reject the status promise if it is still pending.\n      //\n      // We'll do all of this within the ConnectResponseImpl, however, since it\n      // maintains the state necessary here.\n      response->handleException(kj::mv(ex), kj::mv(connectStream));\n    });\n\n    // TODO(bug): There's a challenge with attaching the service.connect promise to the\n    // connection stream below in that the client will likely drop the connection as soon\n    // as it reads EOF, but the promise representing the service connect() call may still\n    // be running and want to do some cleanup after it has sent EOF. That cleanup will be\n    // canceled. For regular HTTP calls, DelayedEofInputStream was created to address this\n    // exact issue but with connect() being bidirectional it's rather more difficult. We\n    // want a delay similar to what DelayedEofInputStream adds but only when both directions\n    // have been closed. That currently is not possible until we have an alternative to\n    // shutdownWrite() that returns a Promise (e.g. Promise<void> end()). For now, we can\n    // live with the current limitation.\n    return ConnectRequest {\n      kj::mv(paf.promise),\n      pipe.ends[1].attach(kj::mv(promise)),\n    };\n  }\n\nprivate:\n  HttpService& service;\n\n  class DelayedEofInputStream final: public kj::AsyncInputStream {\n    // An AsyncInputStream wrapper that, when it reaches EOF, delays the final read until some\n    // promise completes.\n\n  public:\n    DelayedEofInputStream(kj::Own<kj::AsyncInputStream> inner, kj::Promise<void> completionTask)\n        : inner(kj::mv(inner)), completionTask(kj::mv(completionTask)) {}\n\n    kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return wrap(minBytes, inner->tryRead(buffer, minBytes, maxBytes));\n    }\n\n    kj::Maybe<uint64_t> tryGetLength() override {\n      return inner->tryGetLength();\n    }\n\n    kj::Promise<uint64_t> pumpTo(kj::AsyncOutputStream& output, uint64_t amount) override {\n      return wrap(amount, inner->pumpTo(output, amount));\n    }\n\n  private:\n    kj::Own<kj::AsyncInputStream> inner;\n    kj::Maybe<kj::Promise<void>> completionTask;\n\n    template <typename T>\n    kj::Promise<T> wrap(T requested, kj::Promise<T> innerPromise) {\n      return innerPromise.then([this,requested](T actual) -> kj::Promise<T> {\n        if (actual < requested) {\n          // Must have reached EOF.\n          KJ_IF_SOME(t, completionTask) {\n            // Delay until completion.\n            auto result = t.then([actual]() { return actual; });\n            completionTask = kj::none;\n            return result;\n          } else {\n            // Must have called tryRead() again after we already signaled EOF. Fine.\n            return actual;\n          }\n        } else {\n          return actual;\n        }\n      }, [this](kj::Exception&& e) -> kj::Promise<T> {\n        // The stream threw an exception, but this exception is almost certainly just complaining\n        // that the other end of the stream was dropped. In all likelihood, the HttpService\n        // request() call itself will throw a much more interesting error -- we'd rather propagate\n        // that one, if so.\n        KJ_IF_SOME(t, completionTask) {\n          auto result = t.then([e = kj::mv(e)]() mutable -> kj::Promise<T> {\n            // Looks like the service didn't throw. I guess we should propagate the stream error\n            // after all.\n            return kj::mv(e);\n          });\n          completionTask = kj::none;\n          return result;\n        } else {\n          // Must have called tryRead() again after we already signaled EOF or threw. Fine.\n          return kj::mv(e);\n        }\n      });\n    }\n  };\n\n  class ResponseImpl final: public HttpService::Response, public kj::Refcounted {\n  public:\n    ResponseImpl(kj::HttpMethod method,\n                 kj::Own<kj::PromiseFulfiller<HttpClient::Response>> fulfiller)\n        : method(method), fulfiller(kj::mv(fulfiller)) {}\n\n    void setPromise(kj::Promise<void> promise) {\n      task = promise.eagerlyEvaluate([this](kj::Exception&& exception) {\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::mv(exception));\n        } else {\n          // We need to cause the response stream's read() to throw this, so we should propagate it.\n          kj::throwRecoverableException(kj::mv(exception));\n        }\n      });\n    }\n\n    kj::Own<kj::AsyncOutputStream> send(\n        uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      // The caller of HttpClient is allowed to assume that the statusText and headers remain\n      // valid until the body stream is dropped, but the HttpService implementation is allowed to\n      // send values that are only valid until send() returns, so we have to copy.\n      auto statusTextCopy = kj::str(statusText);\n      auto headersCopy = kj::heap(headers.clone());\n\n      if (method == kj::HttpMethod::HEAD || expectedBodySize.orDefault(1) == 0) {\n        // We're not expecting any body. We need to delay reporting completion to the client until\n        // the server side has actually returned from the service method, otherwise we may\n        // prematurely cancel it.\n\n        task = task.then([this,statusCode,statusTextCopy=kj::mv(statusTextCopy),\n                          headersCopy=kj::mv(headersCopy),expectedBodySize]() mutable {\n          fulfiller->fulfill({\n            statusCode, statusTextCopy, headersCopy.get(),\n            kj::heap<NullInputStream>(expectedBodySize)\n                .attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n          });\n        }).eagerlyEvaluate([](kj::Exception&& e) { KJ_LOG(ERROR, e); });\n        return kj::heap<NullOutputStream>();\n      } else {\n        auto pipe = newOneWayPipe(expectedBodySize);\n\n        // Wrap the stream in a wrapper that delays the last read (the one that signals EOF) until\n        // the service's request promise has finished.\n        auto wrapper = kj::heap<DelayedEofInputStream>(\n            kj::mv(pipe.in), task.attach(kj::addRef(*this)));\n\n        fulfiller->fulfill({\n          statusCode, statusTextCopy, headersCopy.get(),\n          wrapper.attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n        });\n        return kj::mv(pipe.out);\n      }\n    }\n\n    kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n      KJ_FAIL_REQUIRE(\"a WebSocket was not requested\");\n    }\n\n  private:\n    kj::HttpMethod method;\n    kj::Own<kj::PromiseFulfiller<HttpClient::Response>> fulfiller;\n    kj::Promise<void> task = nullptr;\n  };\n\n  class DelayedCloseWebSocket final: public WebSocket {\n    // A WebSocket wrapper that, when it reaches Close (in both directions), delays the final close\n    // operation until some promise completes.\n\n  public:\n    DelayedCloseWebSocket(kj::Own<kj::WebSocket> inner, kj::Promise<void> completionTask)\n        : inner(kj::mv(inner)), completionTask(kj::mv(completionTask)) {}\n\n    kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n      return inner->send(message);\n    }\n    kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n      return inner->send(message);\n    }\n    kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n      return inner->close(code, reason)\n          .then([this]() {\n        return afterSendClosed();\n      });\n    }\n    kj::Promise<void> disconnect() override {\n      return inner->disconnect();\n    }\n    void abort() override {\n      // Don't need to worry about completion task in this case -- cancelling it is reasonable.\n      inner->abort();\n    }\n    kj::Promise<void> whenAborted() override {\n      return inner->whenAborted();\n    }\n    kj::Promise<Message> receive(size_t maxSize) override {\n      return inner->receive(maxSize).then([this](Message&& message) -> kj::Promise<Message> {\n        if (message.is<WebSocket::Close>()) {\n          return afterReceiveClosed()\n              .then([message = kj::mv(message)]() mutable { return kj::mv(message); });\n        }\n        return kj::mv(message);\n      });\n    }\n    kj::Promise<void> pumpTo(WebSocket& other) override {\n      return inner->pumpTo(other).then([this]() {\n        return afterReceiveClosed();\n      });\n    }\n    kj::Maybe<kj::Promise<void>> tryPumpFrom(WebSocket& other) override {\n      return other.pumpTo(*inner).then([this]() {\n        return afterSendClosed();\n      });\n    }\n\n    uint64_t sentByteCount() override { return inner->sentByteCount(); }\n    uint64_t receivedByteCount() override { return inner->receivedByteCount(); }\n\n  private:\n    kj::Own<kj::WebSocket> inner;\n    kj::Maybe<kj::Promise<void>> completionTask;\n\n    bool sentClose = false;\n    bool receivedClose = false;\n\n    kj::Promise<void> afterSendClosed() {\n      sentClose = true;\n      if (receivedClose) {\n        KJ_IF_SOME(t, completionTask) {\n          auto result = kj::mv(t);\n          completionTask = kj::none;\n          return result;\n        }\n      }\n      return kj::READY_NOW;\n    }\n\n    kj::Promise<void> afterReceiveClosed() {\n      receivedClose = true;\n      if (sentClose) {\n        KJ_IF_SOME(t, completionTask) {\n          auto result = kj::mv(t);\n          completionTask = kj::none;\n          return result;\n        }\n      }\n      return kj::READY_NOW;\n    }\n  };\n\n  class WebSocketResponseImpl final: public HttpService::Response, public kj::Refcounted {\n  public:\n    WebSocketResponseImpl(kj::Own<kj::PromiseFulfiller<HttpClient::WebSocketResponse>> fulfiller)\n        : fulfiller(kj::mv(fulfiller)) {}\n\n    void setPromise(kj::Promise<void> promise) {\n      task = promise.eagerlyEvaluate([this](kj::Exception&& exception) {\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::mv(exception));\n        } else {\n          // We need to cause the client-side WebSocket to throw on close, so propagate the\n          // exception.\n          kj::throwRecoverableException(kj::mv(exception));\n        }\n      });\n    }\n\n    kj::Own<kj::AsyncOutputStream> send(\n        uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      // The caller of HttpClient is allowed to assume that the statusText and headers remain\n      // valid until the body stream is dropped, but the HttpService implementation is allowed to\n      // send values that are only valid until send() returns, so we have to copy.\n      auto statusTextCopy = kj::str(statusText);\n      auto headersCopy = kj::heap(headers.clone());\n\n      if (expectedBodySize.orDefault(1) == 0) {\n        // We're not expecting any body. We need to delay reporting completion to the client until\n        // the server side has actually returned from the service method, otherwise we may\n        // prematurely cancel it.\n\n        task = task.then([this,statusCode,statusTextCopy=kj::mv(statusTextCopy),\n                          headersCopy=kj::mv(headersCopy),expectedBodySize]() mutable {\n          fulfiller->fulfill({\n            statusCode, statusTextCopy, headersCopy.get(),\n            kj::Own<AsyncInputStream>(kj::heap<NullInputStream>(expectedBodySize)\n                .attach(kj::mv(statusTextCopy), kj::mv(headersCopy)))\n          });\n        }).eagerlyEvaluate([](kj::Exception&& e) { KJ_LOG(ERROR, e); });\n        return kj::heap<NullOutputStream>();\n      } else {\n        auto pipe = newOneWayPipe(expectedBodySize);\n\n        // Wrap the stream in a wrapper that delays the last read (the one that signals EOF) until\n        // the service's request promise has finished.\n        kj::Own<AsyncInputStream> wrapper =\n            kj::heap<DelayedEofInputStream>(kj::mv(pipe.in), task.attach(kj::addRef(*this)));\n\n        fulfiller->fulfill({\n          statusCode, statusTextCopy, headersCopy.get(),\n          wrapper.attach(kj::mv(statusTextCopy), kj::mv(headersCopy))\n        });\n        return kj::mv(pipe.out);\n      }\n    }\n\n    kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n      // The caller of HttpClient is allowed to assume that the headers remain valid until the body\n      // stream is dropped, but the HttpService implementation is allowed to send headers that are\n      // only valid until acceptWebSocket() returns, so we have to copy.\n      auto headersCopy = kj::heap(headers.clone());\n\n      auto pipe = newWebSocketPipe();\n\n      // Wrap the client-side WebSocket in a wrapper that delays clean close of the WebSocket until\n      // the service's request promise has finished.\n      kj::Own<WebSocket> wrapper =\n          kj::heap<DelayedCloseWebSocket>(kj::mv(pipe.ends[0]), task.attach(kj::addRef(*this)));\n      fulfiller->fulfill({\n        101, \"Switching Protocols\", headersCopy.get(),\n        wrapper.attach(kj::mv(headersCopy))\n      });\n      return kj::mv(pipe.ends[1]);\n    }\n\n  private:\n    kj::Own<kj::PromiseFulfiller<HttpClient::WebSocketResponse>> fulfiller;\n    kj::Promise<void> task = nullptr;\n  };\n\n  class ConnectResponseImpl final: public HttpService::ConnectResponse, public kj::Refcounted {\n  public:\n    ConnectResponseImpl(\n        kj::Own<kj::PromiseFulfiller<HttpClient::ConnectRequest::Status>> fulfiller,\n        kj::Own<kj::AsyncIoStream> stream)\n        : fulfiller(kj::mv(fulfiller)),\n          streamAndFulfiller(initStreamsAndFulfiller(kj::mv(stream))) {}\n\n    ~ConnectResponseImpl() noexcept(false) {\n      if (fulfiller->isWaiting() || streamAndFulfiller.fulfiller->isWaiting()) {\n        auto ex = KJ_EXCEPTION(FAILED,\n            \"service's connect() implementation never called accept() nor reject()\");\n        if (fulfiller->isWaiting()) {\n          fulfiller->reject(kj::cp(ex));\n        }\n        if (streamAndFulfiller.fulfiller->isWaiting()) {\n          streamAndFulfiller.fulfiller->reject(kj::mv(ex));\n        }\n      }\n    }\n\n    void accept(uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) override {\n      KJ_REQUIRE(statusCode >= 200 && statusCode < 300, \"the statusCode must be 2xx for accept\");\n      respond(statusCode, statusText, headers);\n    }\n\n    kj::Own<kj::AsyncOutputStream> reject(\n        uint statusCode,\n        kj::StringPtr statusText,\n        const HttpHeaders& headers,\n        kj::Maybe<uint64_t> expectedBodySize = kj::none) override {\n      KJ_REQUIRE(statusCode < 200 || statusCode >= 300,\n          \"the statusCode must not be 2xx for reject.\");\n      auto pipe = kj::newOneWayPipe();\n      respond(statusCode, statusText, headers, kj::mv(pipe.in));\n      return kj::mv(pipe.out);\n    }\n\n  private:\n    struct StreamsAndFulfiller {\n      // guarded is the wrapped/guarded stream that wraps a reference to\n      // the underlying stream but blocks reads until the connection is accepted\n      // or rejected.\n      // This will be handed off when getConnectStream() is called.\n      // The fulfiller is used to resolve the guard for the second stream. This will\n      // be fulfilled or rejected when accept/reject is called.\n      kj::Own<kj::AsyncIoStream> guarded;\n      kj::Own<kj::PromiseFulfiller<void>> fulfiller;\n    };\n\n    kj::Own<kj::PromiseFulfiller<HttpClient::ConnectRequest::Status>> fulfiller;\n    StreamsAndFulfiller streamAndFulfiller;\n    bool connectStreamDetached = false;\n\n    StreamsAndFulfiller initStreamsAndFulfiller(kj::Own<kj::AsyncIoStream> stream) {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      auto guarded = kj::heap<AsyncIoStreamWithGuards>(\n          kj::mv(stream),\n          kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none),\n          kj::mv(paf.promise));\n      return StreamsAndFulfiller {\n        kj::mv(guarded),\n        kj::mv(paf.fulfiller)\n      };\n    }\n\n    void handleException(kj::Exception&& ex, kj::Own<kj::AsyncIoStream> connectStream) {\n      // Reject the status promise if it is still pending...\n      if (fulfiller->isWaiting()) {\n        fulfiller->reject(kj::cp(ex));\n      }\n      if (streamAndFulfiller.fulfiller->isWaiting()) {\n        // If the guard hasn't yet ben released, we can fail the pending reads by\n        // rejecting the fulfiller here.\n        streamAndFulfiller.fulfiller->reject(kj::mv(ex));\n      } else {\n        // The guard has already been released at this point.\n        // TODO(connect): How to properly propagate the actual exception to the\n        // connect stream? Here we \"simply\" shut it down.\n        connectStream->abortRead();\n        connectStream->shutdownWrite();\n      }\n    }\n\n    kj::Own<kj::AsyncIoStream> getConnectStream() {\n      KJ_ASSERT(!connectStreamDetached, \"the connect stream was already detached\");\n      connectStreamDetached = true;\n      return streamAndFulfiller.guarded.attach(kj::addRef(*this));\n    }\n\n    void respond(uint statusCode,\n                 kj::StringPtr statusText,\n                 const HttpHeaders& headers,\n                 kj::Maybe<kj::Own<kj::AsyncInputStream>> errorBody = kj::none) {\n      if (errorBody == kj::none) {\n        streamAndFulfiller.fulfiller->fulfill();\n      } else {\n        streamAndFulfiller.fulfiller->reject(\n            KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n      }\n      fulfiller->fulfill(HttpClient::ConnectRequest::Status(\n          statusCode,\n          kj::str(statusText),\n          kj::heap(headers.clone()),\n          kj::mv(errorBody)));\n    }\n\n    friend class HttpClientAdapter;\n  };\n\n};\n\n}  // namespace\n\nkj::Own<HttpClient> newHttpClient(HttpService& service) {\n  return kj::heap<HttpClientAdapter>(service);\n}\n\n// =======================================================================================\n\nnamespace {\n\nclass HttpServiceAdapter final: public HttpService {\npublic:\n  HttpServiceAdapter(HttpClient& client): client(client) {}\n\n  kj::Promise<void> request(\n      HttpMethod method, kj::StringPtr url, const HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) override {\n    if (!headers.isWebSocket()) {\n      auto innerReq = client.request(method, url, headers, requestBody.tryGetLength());\n\n      auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n      promises.add(requestBody.pumpTo(*innerReq.body).ignoreResult()\n          .attach(kj::mv(innerReq.body)).eagerlyEvaluate(nullptr));\n\n      promises.add(innerReq.response\n          .then([&response](HttpClient::Response&& innerResponse) {\n        auto out = response.send(\n            innerResponse.statusCode, innerResponse.statusText, *innerResponse.headers,\n            innerResponse.body->tryGetLength());\n        auto promise = innerResponse.body->pumpTo(*out);\n        return promise.ignoreResult().attach(kj::mv(out), kj::mv(innerResponse.body));\n      }));\n\n      return kj::joinPromisesFailFast(promises.finish());\n    } else {\n      return client.openWebSocket(url, headers)\n          .then([&response](HttpClient::WebSocketResponse&& innerResponse) -> kj::Promise<void> {\n        KJ_SWITCH_ONEOF(innerResponse.webSocketOrBody) {\n          KJ_CASE_ONEOF(ws, kj::Own<WebSocket>) {\n            auto ws2 = response.acceptWebSocket(*innerResponse.headers);\n            auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n            promises.add(ws->pumpTo(*ws2));\n            promises.add(ws2->pumpTo(*ws));\n            return kj::joinPromisesFailFast(promises.finish()).attach(kj::mv(ws), kj::mv(ws2));\n          }\n          KJ_CASE_ONEOF(body, kj::Own<kj::AsyncInputStream>) {\n            auto out = response.send(\n                innerResponse.statusCode, innerResponse.statusText, *innerResponse.headers,\n                body->tryGetLength());\n            auto promise = body->pumpTo(*out);\n            return promise.ignoreResult().attach(kj::mv(out), kj::mv(body));\n          }\n        }\n        KJ_UNREACHABLE;\n      });\n    }\n  }\n\n  kj::Promise<void> connect(kj::StringPtr host,\n                            const HttpHeaders& headers,\n                            kj::AsyncIoStream& connection,\n                            ConnectResponse& response,\n                            HttpConnectSettings settings) override {\n    KJ_REQUIRE(!headers.isWebSocket(), \"WebSocket upgrade headers are not permitted in a connect.\");\n\n    auto request = client.connect(host, headers, settings);\n\n    // This operates optimistically. In order to support pipelining, we connect the\n    // input and outputs streams immediately, even if we're not yet certain that the\n    // tunnel can actually be established.\n    auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n\n    // For the inbound pipe (from the clients stream to the passed in stream)\n    // We want to guard reads pending the acceptance of the tunnel. If the\n    // tunnel is not accepted, the guard will be rejected, causing pending\n    // reads to fail.\n    auto paf = kj::newPromiseAndFulfiller<kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>>();\n    auto io = kj::heap<AsyncIoStreamWithGuards>(\n        kj::mv(request.connection),\n        kj::mv(paf.promise) /* read guard */,\n        kj::READY_NOW /* write guard */);\n\n    // Writing from connection to io is unguarded and allowed immediately.\n    promises.add(connection.pumpTo(*io).then([&io=*io](uint64_t size) {\n      io.shutdownWrite();\n    }));\n\n    promises.add(io->pumpTo(connection).then([&connection](uint64_t size) {\n      connection.shutdownWrite();\n    }));\n\n    auto pumpPromise = kj::joinPromisesFailFast(promises.finish());\n\n    return request.status.then(\n        [&response,&connection,fulfiller=kj::mv(paf.fulfiller),\n         pumpPromise=kj::mv(pumpPromise)]\n        (HttpClient::ConnectRequest::Status status) mutable -> kj::Promise<void> {\n      if (status.statusCode >= 200 && status.statusCode < 300) {\n        // Release the read guard!\n        fulfiller->fulfill(kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none));\n        response.accept(status.statusCode, status.statusText, *status.headers);\n        return kj::mv(pumpPromise);\n      } else {\n        // If the connect request is rejected, we want to shutdown the tunnel\n        // and pipeline the status.errorBody to the AsyncOutputStream returned by\n        // reject if it exists.\n        pumpPromise = nullptr;\n        connection.shutdownWrite();\n        fulfiller->reject(KJ_EXCEPTION(DISCONNECTED, \"the connect request was rejected\"));\n        KJ_IF_SOME(errorBody, status.errorBody) {\n          auto out = response.reject(status.statusCode, status.statusText, *status.headers,\n              errorBody->tryGetLength());\n          return errorBody->pumpTo(*out).then([](uint64_t) -> kj::Promise<void> {\n            return kj::READY_NOW;\n          }).attach(kj::mv(out), kj::mv(errorBody));\n        } else {\n          response.reject(status.statusCode, status.statusText, *status.headers, (uint64_t)0);\n          return kj::READY_NOW;\n        }\n      }\n    }).attach(kj::mv(io));\n  }\n\nprivate:\n  HttpClient& client;\n};\n\n}  // namespace\n\nkj::Own<HttpService> newHttpService(HttpClient& client) {\n  return kj::heap<HttpServiceAdapter>(client);\n}\n\n// =======================================================================================\n\nkj::Promise<void> HttpService::Response::sendError(\n    uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) {\n  auto stream = send(statusCode, statusText, headers, statusText.size());\n  auto promise = stream->write(statusText.begin(), statusText.size());\n  return promise.attach(kj::mv(stream));\n}\n\nkj::Promise<void> HttpService::Response::sendError(\n    uint statusCode, kj::StringPtr statusText, const HttpHeaderTable& headerTable) {\n  return sendError(statusCode, statusText, HttpHeaders(headerTable));\n}\n\nkj::Promise<void> HttpService::connect(\n    kj::StringPtr host,\n    const HttpHeaders& headers,\n    kj::AsyncIoStream& connection,\n    ConnectResponse& response,\n    kj::HttpConnectSettings settings) {\n  KJ_UNIMPLEMENTED(\"CONNECT is not implemented by this HttpService\");\n}\n\nclass HttpServer::Connection final: private HttpService::Response,\n                                    private HttpService::ConnectResponse,\n                                    private HttpServerErrorHandler {\npublic:\n  Connection(HttpServer& server, kj::AsyncIoStream& stream,\n             SuspendableHttpServiceFactory factory, kj::Maybe<SuspendedRequest> suspendedRequest,\n             bool wantCleanDrain)\n      : server(server),\n        stream(stream),\n        factory(kj::mv(factory)),\n        httpInput(makeHttpInput(stream, server.requestHeaderTable, kj::mv(suspendedRequest))),\n        httpOutput(stream),\n        wantCleanDrain(wantCleanDrain) {\n    ++server.connectionCount;\n  }\n  ~Connection() noexcept(false) {\n    if (--server.connectionCount == 0) {\n      KJ_IF_SOME(f, server.zeroConnectionsFulfiller) {\n        f->fulfill();\n      }\n    }\n  }\n\npublic:\n  // Each iteration of the loop decides if it wants to continue, or break the loop and return.\n  enum LoopResult {\n    CONTINUE_LOOP,\n    BREAK_LOOP_CONN_OK,\n    BREAK_LOOP_CONN_ERR,\n  };\n\n  kj::Promise<bool> startLoop() {\n    auto result = co_await startLoopImpl();\n    KJ_ASSERT(result != CONTINUE_LOOP);\n    co_return result == BREAK_LOOP_CONN_OK ? true : false;\n  }\n\n  kj::Promise<LoopResult> startLoopImpl() {\n    return loop().catch_([this](kj::Exception&& e) {\n      // Exception; report 5xx.\n\n      KJ_IF_SOME(p, webSocketError) {\n        // sendWebSocketError() was called. Finish sending and close the connection. Don't log\n        // the exception because it's probably a side-effect of this.\n        auto promise = kj::mv(p);\n        webSocketError = kj::none;\n        return kj::mv(promise);\n      }\n\n      KJ_IF_SOME(p, tunnelRejected) {\n        // reject() was called to reject a CONNECT request. Finish sending and close the connection.\n        // Don't log the exception because it's probably a side-effect of this.\n        auto promise = kj::mv(p);\n        tunnelRejected = kj::none;\n        return kj::mv(promise);\n      }\n\n      return sendError(kj::mv(e));\n    });\n  }\n\n  SuspendedRequest suspend(SuspendableRequest& suspendable) {\n    KJ_REQUIRE(httpInput.canSuspend(),\n        \"suspend() may only be called before the request body is consumed\");\n    KJ_DEFER(suspended = true);\n    auto released = httpInput.releaseBuffer();\n    return {\n      kj::mv(released.buffer),\n      released.leftover,\n      suspendable.method,\n      suspendable.url,\n      suspendable.headers.cloneShallow(),\n    };\n  }\n\nprivate:\n  HttpServer& server;\n  kj::AsyncIoStream& stream;\n\n  SuspendableHttpServiceFactory factory;\n  // Creates a new kj::Own<HttpService> for each request we handle on this connection.\n\n  HttpInputStreamImpl httpInput;\n  HttpOutputStream httpOutput;\n  kj::Maybe<kj::OneOf<HttpMethod, HttpConnectMethod>> currentMethod;\n  bool timedOut = false;\n  bool closed = false;\n  bool upgraded = false;\n  bool webSocketOrConnectClosed = false;\n  bool closeAfterSend = false;  // True if send() should set Connection: close.\n  bool wantCleanDrain = false;\n  bool suspended = false;\n  kj::Maybe<kj::Promise<LoopResult>> webSocketError;\n  kj::Maybe<kj::Promise<LoopResult>> tunnelRejected;\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> tunnelWriteGuard;\n\n  static HttpInputStreamImpl makeHttpInput(\n      kj::AsyncIoStream& stream,\n      const kj::HttpHeaderTable& table,\n      kj::Maybe<SuspendedRequest> suspendedRequest) {\n    // Constructor helper function to create our HttpInputStreamImpl.\n\n    KJ_IF_SOME(sr, suspendedRequest) {\n      return HttpInputStreamImpl(stream,\n          sr.buffer.releaseAsChars(),\n          sr.leftover.asChars(),\n          sr.method,\n          sr.url,\n          kj::mv(sr.headers));\n    }\n    return HttpInputStreamImpl(stream, table);\n  }\n\n  kj::Promise<LoopResult> loop() {\n    bool firstRequest = true;\n\n    while (true) {\n      if (!firstRequest && server.draining && httpInput.isCleanDrain()) {\n        // Don't call awaitNextMessage() in this case because that will initiate a read() which will\n        // immediately be canceled, losing data.\n        co_return BREAK_LOOP_CONN_OK;\n      }\n\n      auto firstByte = httpInput.awaitNextMessage();\n\n      if (!firstRequest) {\n        // For requests after the first, require that the first byte arrive before the pipeline\n        // timeout, otherwise treat it like the connection was simply closed.\n        auto timeoutPromise = server.timer.afterDelay(server.settings.pipelineTimeout);\n\n        if (httpInput.isCleanDrain()) {\n          // If we haven't buffered any data, then we can safely drain here, so allow the wait to\n          // be canceled by the onDrain promise.\n          auto cleanDrainPromise = server.onDrain.addBranch()\n              .then([this]() -> kj::Promise<void> {\n            // This is a little tricky... drain() has been called, BUT we could have read some data\n            // into the buffer in the meantime, and we don't want to lose that. If any data has\n            // arrived, then we have no choice but to read the rest of the request and respond to\n            // it.\n            if (!httpInput.isCleanDrain()) {\n              return kj::NEVER_DONE;\n            }\n\n            // OK... As far as we know, no data has arrived in the buffer. However, unfortunately,\n            // we don't *really* know that, because read() is asynchronous. It may have already\n            // delivered some bytes, but we just haven't received the notification yet, because it's\n            // still queued on the event loop. As a horrible hack, we use evalLast(), so that any\n            // such pending notifications get a chance to be delivered.\n            // TODO(someday): Does this actually work on Windows, where the notification could also\n            //   be queued on the IOCP?\n            return kj::evalLast([this]() -> kj::Promise<void> {\n              if (httpInput.isCleanDrain()) {\n                return kj::READY_NOW;\n              } else {\n                return kj::NEVER_DONE;\n              }\n            });\n          });\n          timeoutPromise = timeoutPromise.exclusiveJoin(kj::mv(cleanDrainPromise));\n        }\n\n        firstByte = firstByte.exclusiveJoin(timeoutPromise.then([this]() -> bool {\n          timedOut = true;\n          return false;\n        }));\n      }\n\n      auto receivedHeaders = firstByte\n          .then([this,firstRequest](bool hasData)\n              -> kj::Promise<HttpHeaders::RequestConnectOrProtocolError> {\n        if (hasData) {\n          auto readHeaders = httpInput.readRequestHeaders();\n          if (!firstRequest) {\n            // On requests other than the first, the header timeout starts ticking when we receive\n            // the first byte of a pipeline response.\n            readHeaders = readHeaders.exclusiveJoin(\n                server.timer.afterDelay(server.settings.headerTimeout)\n                .then([this]() -> HttpHeaders::RequestConnectOrProtocolError {\n              timedOut = true;\n              return HttpHeaders::ProtocolError {\n                408, \"Request Timeout\",\n                \"Timed out waiting for next request headers.\", nullptr\n              };\n            }));\n          }\n          return kj::mv(readHeaders);\n        } else {\n          // Client closed connection or pipeline timed out with no bytes received. This is not an\n          // error, so don't report one.\n          this->closed = true;\n          return HttpHeaders::RequestConnectOrProtocolError(HttpHeaders::ProtocolError {\n            408, \"Request Timeout\",\n            \"Client closed connection or connection timeout \"\n            \"while waiting for request headers.\", nullptr\n          });\n        }\n      });\n\n      if (firstRequest) {\n        // On the first request, the header timeout starts ticking immediately upon request opening.\n        // NOTE: Since we assume that the client wouldn't have formed a connection if they did not\n        //   intend to send a request, we immediately treat this connection as having an active\n        //   request, i.e. we do NOT cancel it if drain() is called.\n        auto timeoutPromise = server.timer.afterDelay(server.settings.headerTimeout)\n            .then([this]() -> HttpHeaders::RequestConnectOrProtocolError {\n          timedOut = true;\n          return HttpHeaders::ProtocolError {\n            408, \"Request Timeout\",\n            \"Timed out waiting for initial request headers.\", nullptr\n          };\n        });\n        receivedHeaders = receivedHeaders.exclusiveJoin(kj::mv(timeoutPromise));\n      }\n\n      auto requestOrProtocolError = co_await receivedHeaders;\n      auto loopResult = co_await onHeaders(kj::mv(requestOrProtocolError));\n\n      switch (loopResult) {\n        case BREAK_LOOP_CONN_ERR:\n        case BREAK_LOOP_CONN_OK: co_return loopResult;\n        case CONTINUE_LOOP: {\n          firstRequest = false;\n        }\n      }\n    }\n  }\n\n  kj::Promise<LoopResult> onHeaders(HttpHeaders::RequestConnectOrProtocolError&& requestOrProtocolError) {\n    if (timedOut) {\n      // Client took too long to send anything, so we're going to close the connection. In\n      // theory, we should send back an HTTP 408 error -- it is designed exactly for this\n      // purpose. Alas, in practice, Google Chrome does not have any special handling for 408\n      // errors -- it will assume the error is a response to the next request it tries to send,\n      // and will happily serve the error to the user. OTOH, if we simply close the connection,\n      // Chrome does the \"right thing\", apparently. (Though I'm not sure what happens if a\n      // request is in-flight when we close... if it's a GET, the browser should retry. But if\n      // it's a POST, retrying may be dangerous. This is why 408 exists -- it unambiguously\n      // tells the client that it should retry.)\n      //\n      // Also note that if we ever decide to send 408 again, we might want to send some other\n      // error in the case that the server is draining, which also sets timedOut = true; see\n      // above.\n\n      co_await httpOutput.flush();\n      co_return (server.draining && httpInput.isCleanDrain()) ? BREAK_LOOP_CONN_OK : BREAK_LOOP_CONN_ERR;\n    }\n\n    if (closed) {\n      // Client closed connection. Close our end too.\n      co_await httpOutput.flush();\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    KJ_SWITCH_ONEOF(requestOrProtocolError) {\n      KJ_CASE_ONEOF(request, HttpHeaders::ConnectRequest) {\n        co_return co_await onConnect(request);\n      }\n      KJ_CASE_ONEOF(request, HttpHeaders::Request) {\n        co_return co_await onRequest(request);\n      }\n      KJ_CASE_ONEOF(protocolError, HttpHeaders::ProtocolError) {\n        // Bad request.\n\n        auto needClientGrace = protocolError.statusCode == 431;\n        if (needClientGrace) {\n          // We're going to reply with an error and close the connection.\n          // The client might not be able to read the error back. Read some data and wait\n          // a bit to give client a chance to finish writing.\n\n          auto dummy = kj::heap<HttpDiscardingEntityWriter>();\n          auto lengthGrace = kj::evalNow([&]() {\n            return httpInput.discard(*dummy, server.settings.canceledUploadGraceBytes);\n          }).catch_([](kj::Exception&& e) -> void { })\n            .attach(kj::mv(dummy));\n          auto timeGrace = server.timer.afterDelay(server.settings.canceledUploadGracePeriod);\n          co_await lengthGrace.exclusiveJoin(kj::mv(timeGrace));\n        }\n\n        // sendError() uses Response::send(), which requires that we have a currentMethod, but we\n        // never read one. GET seems like the correct choice here.\n        currentMethod = HttpMethod::GET;\n        co_return co_await sendError(kj::mv(protocolError));\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }\n\n  kj::Promise<LoopResult> onConnect(HttpHeaders::ConnectRequest& request) {\n    auto& headers = httpInput.getHeaders();\n\n    currentMethod = HttpConnectMethod();\n\n    // The HTTP specification says that CONNECT requests have no meaningful payload\n    // but stops short of saying that CONNECT *cannot* have a payload. Implementations\n    // can choose to either accept payloads or reject them. We choose to reject it.\n    // Specifically, if there are Content-Length or Transfer-Encoding headers in the\n    // request headers, we'll automatically reject the CONNECT request.\n    //\n    // The key implication here is that any data that immediately follows the headers\n    // block of the CONNECT request is considered to be part of the tunnel if it is\n    // established.\n\n    if (headers.get(HttpHeaderId::CONTENT_LENGTH) != kj::none) {\n      co_return co_await sendError(HttpHeaders::ProtocolError {\n        400,\n        \"Bad Request\"_kj,\n        \"Bad Request\"_kj,\n        nullptr,\n      });\n    }\n    if (headers.get(HttpHeaderId::TRANSFER_ENCODING) != kj::none) {\n      co_return co_await sendError(HttpHeaders::ProtocolError {\n        400,\n        \"Bad Request\"_kj,\n        \"Bad Request\"_kj,\n        nullptr,\n      });\n    }\n\n    SuspendableRequest suspendable(*this, HttpConnectMethod(), request.authority, headers);\n    auto maybeService = factory(suspendable);\n\n    if (suspended) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    auto service = KJ_ASSERT_NONNULL(kj::mv(maybeService),\n        \"SuspendableHttpServiceFactory did not suspend, but returned kj::none.\");\n    auto connectStream = getConnectStream();\n    co_await service->connect(\n        request.authority, headers, *connectStream, *this, {})\n        .attach(kj::mv(service), kj::mv(connectStream));\n\n\n    KJ_IF_SOME(p, tunnelRejected) {\n      // reject() was called to reject a CONNECT attempt.\n      // Finish sending and close the connection.\n      auto promise = kj::mv(p);\n      tunnelRejected = kj::none;\n      co_return co_await promise;\n    }\n\n    if (httpOutput.isBroken()) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    co_await httpOutput.flush();\n    co_return BREAK_LOOP_CONN_ERR;\n  }\n\n  kj::Promise<LoopResult> onRequest(HttpHeaders::Request& request) {\n    auto& headers = httpInput.getHeaders();\n\n    currentMethod = request.method;\n\n    SuspendableRequest suspendable(*this, request.method, request.url, headers);\n    auto maybeService = factory(suspendable);\n\n    if (suspended) {\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    auto service = KJ_ASSERT_NONNULL(kj::mv(maybeService),\n        \"SuspendableHttpServiceFactory did not suspend, but returned kj::none.\");\n\n    // TODO(perf): If the client disconnects, should we cancel the response? Probably, to\n    //   prevent permanent deadlock. It's slightly weird in that arguably the client should\n    //   be able to shutdown the upstream but still wait on the downstream, but I believe many\n    //   other HTTP servers do similar things.\n\n    auto body = httpInput.getEntityBody(\n        HttpInputStreamImpl::REQUEST, request.method, 0, headers);\n\n    co_await service->request(\n        request.method, request.url, headers, *body, *this).attach(kj::mv(service));\n    // Response done. Await next request.\n\n    KJ_IF_SOME(p, webSocketError) {\n      // sendWebSocketError() was called. Finish sending and close the connection.\n      auto promise = kj::mv(p);\n      webSocketError = kj::none;\n      co_return co_await promise;\n    }\n\n    if (upgraded) {\n      // We've upgraded to WebSocket, and by now we should have closed the WebSocket.\n      if (!webSocketOrConnectClosed) {\n        // This is gonna segfault later so abort now instead.\n        KJ_LOG(FATAL, \"Accepted WebSocket object must be destroyed before HttpService \"\n                      \"request handler completes.\");\n        abort();\n      }\n\n      // Once we start a WebSocket there's no going back to HTTP.\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    if (currentMethod != kj::none) {\n      co_return co_await sendError();\n    }\n\n    if (httpOutput.isBroken()) {\n      // We started a response but didn't finish it. But HttpService returns success?\n      // Perhaps it decided that it doesn't want to finish this response. We'll have to\n      // disconnect here. If the response body is not complete (e.g. Content-Length not\n      // reached), the client should notice. We don't want to log an error because this\n      // condition might be intentional on the service's part.\n      co_return BREAK_LOOP_CONN_ERR;\n    }\n\n    co_await httpOutput.flush();\n\n    if (httpInput.canReuse()) {\n      // Things look clean. Go ahead and accept the next request.\n\n      if (closeAfterSend) {\n        // We sent Connection: close, so drop the connection now.\n        co_return BREAK_LOOP_CONN_ERR;\n      } else {\n        // Note that we don't have to handle server.draining here because we'll take care\n        // of it the next time around the loop.\n        co_return CONTINUE_LOOP;\n      }\n    } else {\n      // Apparently, the application did not read the request body. Maybe this is a bug,\n      // or maybe not: maybe the client tried to upload too much data and the application\n      // legitimately wants to cancel the upload without reading all it it.\n      //\n      // We have a problem, though: We did send a response, and we didn't send\n      // `Connection: close`, so the client may expect that it can send another request.\n      // Perhaps the client has even finished sending the previous request's body, in\n      // which case the moment it finishes receiving the response, it could be completely\n      // within its rights to start a new request. If we close the socket now, we might\n      // interrupt that new request.\n      //\n      // Or maybe we did send `Connection: close`, as indicated by `closeAfterSend` being\n      // true. Even in that case, we should still try to read and ignore the request,\n      // otherwise when we close the connection the client may get a \"connection reset\"\n      // error before they get a chance to actually read the response body that we sent\n      // them.\n      //\n      // There's no way we can get out of this perfectly cleanly. HTTP just isn't good\n      // enough at connection management. The best we can do is give the client some grace\n      // period and then abort the connection.\n\n      auto dummy = kj::heap<HttpDiscardingEntityWriter>();\n      auto lengthGrace = kj::evalNow([&]() {\n        return body->pumpTo(*dummy, server.settings.canceledUploadGraceBytes);\n      }).catch_([](kj::Exception&& e) -> uint64_t {\n        // Reading from the input failed in some way. This may actually be the whole\n        // reason we got here in the first place so don't propagate this error, just\n        // give up on discarding the input.\n        return 0;  // This zero is ignored but `canReuse()` will return false below.\n      }).then([this](uint64_t amount) {\n        if (httpInput.canReuse()) {\n          // Success, we can continue.\n          return true;\n        } else {\n          // Still more data. Give up.\n          return false;\n        }\n      });\n      lengthGrace = lengthGrace.attach(kj::mv(dummy), kj::mv(body));\n\n      auto timeGrace = server.timer.afterDelay(server.settings.canceledUploadGracePeriod)\n          .then([]() { return false; });\n\n      auto clean = co_await lengthGrace.exclusiveJoin(kj::mv(timeGrace));\n      if (clean && !closeAfterSend) {\n        // We recovered. Continue loop.\n        co_return CONTINUE_LOOP;\n      } else {\n        // Client still not done, or we sent Connection: close and so want to drop the\n        // connection anyway. Return broken.\n        co_return BREAK_LOOP_CONN_ERR;\n      }\n    }\n  }\n\n  kj::Own<kj::AsyncOutputStream> send(\n      uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers,\n      kj::Maybe<uint64_t> expectedBodySize) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    currentMethod = kj::none;\n\n    kj::StringPtr connectionHeaders[HttpHeaders::CONNECTION_HEADERS_COUNT];\n    kj::String lengthStr;\n\n    if (!closeAfterSend) {\n      // Check if application wants us to close connections.\n      //\n      // If the application used listenHttpCleanDrain() to listen, then it expects that after a\n      // clean drain, the connection is still open and can receive more requests. Otherwise, after\n      // receiving drain(), we will close the connection, so we should send a `Connection: close`\n      // header.\n      if (server.draining && !wantCleanDrain) {\n        closeAfterSend = true;\n      } else KJ_IF_SOME(c, server.settings.callbacks) {\n        // The application has registered its own callback to decide whether to send\n        // `Connection: close`.\n        if (c.shouldClose()) {\n          closeAfterSend = true;\n        }\n      }\n    }\n\n    if (closeAfterSend) {\n      connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"close\";\n    }\n\n    bool isHeadRequest = method.tryGet<HttpMethod>().map([](auto& m) {\n        return m == HttpMethod::HEAD;\n      }).orDefault(false);\n\n    if (statusCode == 204 || statusCode == 304) {\n      // No entity-body.\n    } else if (statusCode == 205) {\n      // Status code 205 also has no body, but unlike 204 and 304, it must explicitly encode an\n      // empty body, e.g. using content-length: 0. I'm guessing this is one of those things,\n      // where some early clients expected an explicit body while others assumed an empty body,\n      // and so the standard had to choose the common denominator.\n      //\n      // Spec: https://tools.ietf.org/html/rfc7231#section-6.3.6\n      connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = \"0\";\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      // HACK: We interpret a zero-length expected body length on responses to HEAD requests to\n      //   mean \"don't set a Content-Length header at all.\" This provides a way to omit a body\n      //   header on HEAD responses with non-null-body status codes. This is a hack that *only*\n      //   makes sense for HEAD responses.\n      if (!isHeadRequest || s > 0) {\n        lengthStr = kj::str(s);\n        connectionHeaders[HttpHeaders::BuiltinIndices::CONTENT_LENGTH] = lengthStr;\n      }\n    } else {\n      connectionHeaders[HttpHeaders::BuiltinIndices::TRANSFER_ENCODING] = \"chunked\";\n    }\n\n    // For HEAD requests, if the application specified a Content-Length or Transfer-Encoding\n    // header, use that instead of whatever we decided above.\n    kj::ArrayPtr<kj::StringPtr> connectionHeadersArray = connectionHeaders;\n    if (isHeadRequest) {\n      if (headers.get(HttpHeaderId::CONTENT_LENGTH) != kj::none ||\n          headers.get(HttpHeaderId::TRANSFER_ENCODING) != kj::none) {\n        connectionHeadersArray = connectionHeadersArray\n            .slice(0, HttpHeaders::HEAD_RESPONSE_CONNECTION_HEADERS_COUNT);\n      }\n    }\n\n    httpOutput.writeHeaders(headers.serializeResponse(\n        statusCode, statusText, connectionHeadersArray));\n\n    kj::Own<kj::AsyncOutputStream> bodyStream;\n    if (isHeadRequest) {\n      // Ignore entity-body.\n      httpOutput.finishBody();\n      return heap<HttpDiscardingEntityWriter>();\n    } else if (statusCode == 204 || statusCode == 205 || statusCode == 304) {\n      // No entity-body.\n      httpOutput.finishBody();\n      return heap<HttpNullEntityWriter>();\n    } else KJ_IF_SOME(s, expectedBodySize) {\n      return heap<HttpFixedLengthEntityWriter>(httpOutput, s);\n    } else {\n      return heap<HttpChunkedEntityWriter>(httpOutput);\n    }\n  }\n\n  kj::Own<WebSocket> acceptWebSocket(const HttpHeaders& headers) override {\n    auto& requestHeaders = httpInput.getHeaders();\n    KJ_REQUIRE(requestHeaders.isWebSocket(),\n        \"can't call acceptWebSocket() if the request headers didn't have Upgrade: WebSocket\");\n\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    KJ_REQUIRE(method.tryGet<HttpMethod>().map([](auto& m) {\n      return m == HttpMethod::GET;\n    }).orDefault(false), \"WebSocket must be initiated with a GET request.\");\n\n    if (requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_VERSION).orDefault(nullptr) != \"13\") {\n      return sendWebSocketError(\"The requested WebSocket version is not supported.\");\n    }\n\n    kj::String key;\n    KJ_IF_SOME(k, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_KEY)) {\n      key = kj::str(k);\n    } else {\n      return sendWebSocketError(\"Missing Sec-WebSocket-Key\");\n    }\n\n    kj::Maybe<CompressionParameters> acceptedParameters;\n    kj::String agreedParameters;\n    auto compressionMode = server.settings.webSocketCompressionMode;\n    if (compressionMode == HttpServerSettings::AUTOMATIC_COMPRESSION) {\n      // If AUTOMATIC_COMPRESSION is enabled, we ignore the `headers` passed by the application and\n      // strictly refer to the `requestHeaders` from the client.\n      KJ_IF_SOME(value, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // Perform compression parameter negotiation.\n        KJ_IF_SOME(config, _::tryParseExtensionOffers(value)) {\n          acceptedParameters = kj::mv(config);\n        }\n      }\n    } else if (compressionMode == HttpServerSettings::MANUAL_COMPRESSION) {\n      // If MANUAL_COMPRESSION is enabled, we use the `headers` passed in by the application, and\n      // try to find a configuration that respects both the server's preferred configuration,\n      // as well as the client's requested configuration.\n      KJ_IF_SOME(value, headers.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n        // First, we get the manual configuration using `headers`.\n        KJ_IF_SOME(manualConfig, _::tryParseExtensionOffers(value)) {\n          KJ_IF_SOME(requestOffers, requestHeaders.get(HttpHeaderId::SEC_WEBSOCKET_EXTENSIONS)) {\n            // Next, we to find a configuration that both the client and server can accept.\n            acceptedParameters = _::tryParseAllExtensionOffers(requestOffers, manualConfig);\n          }\n        }\n      }\n    }\n\n    auto websocketAccept = generateWebSocketAccept(key);\n\n    kj::StringPtr connectionHeaders[HttpHeaders::WEBSOCKET_CONNECTION_HEADERS_COUNT];\n    connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_ACCEPT] = websocketAccept;\n    connectionHeaders[HttpHeaders::BuiltinIndices::UPGRADE] = \"websocket\";\n    connectionHeaders[HttpHeaders::BuiltinIndices::CONNECTION] = \"Upgrade\";\n    KJ_IF_SOME(parameters, acceptedParameters) {\n      agreedParameters = _::generateExtensionResponse(parameters);\n      connectionHeaders[HttpHeaders::BuiltinIndices::SEC_WEBSOCKET_EXTENSIONS] = agreedParameters;\n    }\n\n    // Since we're about to write headers, we should nullify `currentMethod`. This tells\n    // `sendError(kj::Exception)` (called from `HttpServer::Connection::startLoop()`) not to expose\n    // the `HttpService::Response&` reference to the HttpServer's error `handleApplicationError()`\n    // callback. This prevents the error handler from inadvertently trying to send another error on\n    // the connection.\n    currentMethod = kj::none;\n\n    httpOutput.writeHeaders(headers.serializeResponse(\n        101, \"Switching Protocols\", connectionHeaders));\n\n    upgraded = true;\n    // We need to give the WebSocket an Own<AsyncIoStream>, but we only have a reference. This is\n    // safe because the application is expected to drop the WebSocket object before returning\n    // from the request handler. For some extra safety, we check that webSocketOrConnectClosed has\n    // been set true when the handler returns.\n    auto deferNoteClosed = kj::defer([this]() { webSocketOrConnectClosed = true; });\n    kj::Own<kj::AsyncIoStream> ownStream(&stream, kj::NullDisposer::instance);\n    return upgradeToWebSocket(ownStream.attach(kj::mv(deferNoteClosed)),\n                              httpInput, httpOutput, kj::none, kj::mv(acceptedParameters),\n                             server.settings.webSocketErrorHandler);\n  }\n\n  kj::Promise<LoopResult> sendError(HttpHeaders::ProtocolError protocolError) {\n    closeAfterSend = true;\n\n    // Client protocol errors always happen on request headers parsing, before we call into the\n    // HttpService, meaning no response has been sent and we can provide a Response object.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleClientProtocolError(\n        kj::mv(protocolError), *this);\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> sendError(kj::Exception&& exception) {\n    closeAfterSend = true;\n\n    // We only provide the Response object if we know we haven't already sent a response.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleApplicationError(\n        kj::mv(exception), currentMethod.map([this](auto&&) -> Response& { return *this; }));\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> sendError() {\n    closeAfterSend = true;\n\n    // We can provide a Response object, since none has already been sent.\n    auto promise = server.settings.errorHandler.orDefault(*this).handleNoResponse(*this);\n    return finishSendingError(kj::mv(promise));\n  }\n\n  kj::Promise<LoopResult> finishSendingError(kj::Promise<void> promise) {\n    co_await promise;\n    if (!httpOutput.isBroken()) {\n      // Skip flush for broken streams, since it will throw an exception that may be worse than\n      // the one we just handled.\n      co_await httpOutput.flush();\n    }\n    co_return BREAK_LOOP_CONN_ERR;\n  }\n\n  kj::Own<WebSocket> sendWebSocketError(StringPtr errorMessage) {\n    kj::Exception exception = KJ_EXCEPTION(FAILED,\n        \"received bad WebSocket handshake\", errorMessage);\n    webSocketError = sendError(\n        HttpHeaders::ProtocolError { 400, \"Bad Request\", errorMessage, nullptr });\n    kj::throwRecoverableException(kj::mv(exception));\n\n    // Fallback path when exceptions are disabled.\n    class BrokenWebSocket final: public WebSocket {\n    public:\n      BrokenWebSocket(kj::Exception exception): exception(kj::mv(exception)) {}\n\n      kj::Promise<void> send(kj::ArrayPtr<const byte> message) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> send(kj::ArrayPtr<const char> message) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> close(uint16_t code, kj::StringPtr reason) override {\n        return kj::cp(exception);\n      }\n      kj::Promise<void> disconnect() override {\n        return kj::cp(exception);\n      }\n      void abort() override {\n        kj::throwRecoverableException(kj::cp(exception));\n      }\n      kj::Promise<void> whenAborted() override {\n        return kj::cp(exception);\n      }\n      kj::Promise<Message> receive(size_t maxSize) override {\n        return kj::cp(exception);\n      }\n\n      uint64_t sentByteCount() override { KJ_FAIL_ASSERT(\"received bad WebSocket handshake\"); }\n      uint64_t receivedByteCount() override { KJ_FAIL_ASSERT(\"received bad WebSocket handshake\"); }\n\n    private:\n      kj::Exception exception;\n    };\n\n    return kj::heap<BrokenWebSocket>(KJ_EXCEPTION(FAILED,\n        \"received bad WebSocket handshake\", errorMessage));\n  }\n\n  kj::Own<kj::AsyncIoStream> getConnectStream() {\n    // Returns an AsyncIoStream over the internal stream but that waits for a Promise to be\n    // resolved to allow writes after either accept or reject are called. Reads are allowed\n    // immediately.\n    KJ_REQUIRE(tunnelWriteGuard == kj::none, \"the tunnel stream was already retrieved\");\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    tunnelWriteGuard = kj::mv(paf.fulfiller);\n\n    kj::Own<kj::AsyncIoStream> ownStream(&stream, kj::NullDisposer::instance);\n    auto releasedBuffer = httpInput.releaseBuffer();\n    auto deferNoteClosed = kj::defer([this]() { webSocketOrConnectClosed = true; });\n    return kj::heap<AsyncIoStreamWithGuards>(\n        kj::heap<AsyncIoStreamWithInitialBuffer>(\n            kj::mv(ownStream),\n            kj::mv(releasedBuffer.buffer),\n            releasedBuffer.leftover).attach(kj::mv(deferNoteClosed)),\n        kj::Maybe<HttpInputStreamImpl::ReleasedBuffer>(kj::none),\n        kj::mv(paf.promise));\n  }\n\n  void accept(uint statusCode, kj::StringPtr statusText, const HttpHeaders& headers) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    currentMethod = kj::none;\n    KJ_ASSERT(method.is<HttpConnectMethod>(), \"only use accept() with CONNECT requests\");\n    KJ_REQUIRE(statusCode >= 200 && statusCode < 300, \"the statusCode must be 2xx for accept\");\n    tunnelRejected = kj::none;\n\n    auto& fulfiller = KJ_ASSERT_NONNULL(tunnelWriteGuard, \"the tunnel stream was not initialized\");\n    httpOutput.writeHeaders(headers.serializeResponse(statusCode, statusText));\n    auto promise = httpOutput.flush().then([&fulfiller]() {\n      fulfiller->fulfill();\n    }).eagerlyEvaluate(nullptr);\n    fulfiller = fulfiller.attach(kj::mv(promise));\n  }\n\n  kj::Own<kj::AsyncOutputStream> reject(\n      uint statusCode,\n      kj::StringPtr statusText,\n      const HttpHeaders& headers,\n      kj::Maybe<uint64_t> expectedBodySize) override {\n    auto method = KJ_REQUIRE_NONNULL(currentMethod, \"already called send()\");\n    KJ_REQUIRE(method.is<HttpConnectMethod>(), \"Only use reject() with CONNECT requests.\");\n    KJ_REQUIRE(statusCode < 200 || statusCode >= 300, \"the statusCode must not be 2xx for reject.\");\n    tunnelRejected = Maybe<kj::Promise<LoopResult>>(BREAK_LOOP_CONN_OK);\n\n    auto& fulfiller = KJ_ASSERT_NONNULL(tunnelWriteGuard, \"the tunnel stream was not initialized\");\n    fulfiller->reject(KJ_EXCEPTION(DISCONNECTED, \"the tunnel request was rejected\"));\n    closeAfterSend = true;\n    return send(statusCode, statusText, headers, expectedBodySize);\n  }\n};\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       HttpService& service, Settings settings)\n    : HttpServer(timer, requestHeaderTable, &service, settings,\n                 kj::newPromiseAndFulfiller<void>()) {}\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       HttpServiceFactory serviceFactory, Settings settings)\n    : HttpServer(timer, requestHeaderTable, kj::mv(serviceFactory), settings,\n                 kj::newPromiseAndFulfiller<void>()) {}\n\nHttpServer::HttpServer(kj::Timer& timer, const HttpHeaderTable& requestHeaderTable,\n                       kj::OneOf<HttpService*, HttpServiceFactory> service,\n                       Settings settings, kj::PromiseFulfillerPair<void> paf)\n    : timer(timer), requestHeaderTable(requestHeaderTable), service(kj::mv(service)),\n      settings(settings), onDrain(paf.promise.fork()), drainFulfiller(kj::mv(paf.fulfiller)),\n      tasks(*this) {}\n\nkj::Promise<void> HttpServer::drain() {\n  KJ_REQUIRE(!draining, \"you can only call drain() once\");\n\n  draining = true;\n  drainFulfiller->fulfill();\n\n  if (connectionCount == 0) {\n    return kj::READY_NOW;\n  } else {\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    zeroConnectionsFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n}\n\nkj::Promise<void> HttpServer::listenHttp(kj::ConnectionReceiver& port) {\n  return listenLoop(port).exclusiveJoin(onDrain.addBranch());\n}\n\nkj::Promise<void> HttpServer::listenLoop(kj::ConnectionReceiver& port) {\n  for (;;) {\n    auto connection = co_await port.accept();\n    tasks.add(kj::evalNow([&]() { return listenHttp(kj::mv(connection)); }));\n  }\n}\n\nkj::Promise<void> HttpServer::listenHttp(kj::Own<kj::AsyncIoStream> connection) {\n  auto promise = listenHttpImpl(*connection, false /* wantCleanDrain */).ignoreResult();\n\n  // eagerlyEvaluate() to maintain historical guarantee that this method eagerly closes the\n  // connection when done.\n  return promise.attach(kj::mv(connection)).eagerlyEvaluate(nullptr);\n}\n\nkj::Promise<bool> HttpServer::listenHttpCleanDrain(kj::AsyncIoStream& connection) {\n  return listenHttpImpl(connection, true /* wantCleanDrain */);\n}\n\nkj::Promise<bool> HttpServer::listenHttpImpl(kj::AsyncIoStream& connection, bool wantCleanDrain) {\n  kj::Own<HttpService> srv;\n\n  KJ_SWITCH_ONEOF(service) {\n    KJ_CASE_ONEOF(ptr, HttpService*) {\n      // Fake Own okay because we can assume the HttpService outlives this HttpServer, and we can\n      // assume `this` HttpServer outlives the returned `listenHttpCleanDrain()` promise, which will\n      // own the fake Own.\n      srv = kj::Own<HttpService>(ptr, kj::NullDisposer::instance);\n    }\n    KJ_CASE_ONEOF(func, HttpServiceFactory) {\n      srv = func(connection);\n    }\n  }\n\n  KJ_ASSERT(srv.get() != nullptr);\n\n  return listenHttpImpl(connection, [srv = kj::mv(srv)](SuspendableRequest&) mutable {\n    // This factory function will be owned by the Connection object, meaning the Connection object\n    // will own the HttpService. We also know that the Connection object outlives all\n    // service.request() promises (service.request() is called from a Connection member function).\n    // The Owns we return from this function are attached to the service.request() promises,\n    // meaning this factory function will outlive all Owns we return. So, it's safe to return a fake\n    // Own.\n    return kj::Own<HttpService>(srv.get(), kj::NullDisposer::instance);\n  }, kj::none /* suspendedRequest */, wantCleanDrain);\n}\n\nkj::Promise<bool> HttpServer::listenHttpCleanDrain(kj::AsyncIoStream& connection,\n    SuspendableHttpServiceFactory factory,\n    kj::Maybe<SuspendedRequest> suspendedRequest) {\n  // Don't close on drain, because a \"clean drain\" means we return the connection to the\n  // application still-open between requests so that it can continue serving future HTTP requests\n  // on it.\n  return listenHttpImpl(connection, kj::mv(factory), kj::mv(suspendedRequest),\n                        true /* wantCleanDrain */);\n}\n\nkj::Promise<bool> HttpServer::listenHttpImpl(kj::AsyncIoStream& connection,\n    SuspendableHttpServiceFactory factory,\n    kj::Maybe<SuspendedRequest> suspendedRequest,\n    bool wantCleanDrain) {\n  Connection obj(*this, connection, kj::mv(factory), kj::mv(suspendedRequest), wantCleanDrain);\n\n  // Start reading requests and responding to them, but immediately cancel processing if the client\n  // disconnects.\n  co_return co_await obj\n      .startLoop()\n      .exclusiveJoin(connection.whenWriteDisconnected().then([]() {return false;}))\n      // Eagerly evaluate so that we drop the connection when the promise resolves, even if the caller\n      // doesn't eagerly evaluate.\n      .eagerlyEvaluate(nullptr);\n}\n\nnamespace {\nvoid defaultHandleListenLoopException(kj::Exception&& exception) {\n  KJ_LOG(ERROR, \"unhandled exception in HTTP server\", exception);\n}\n}  // namespace\n\nvoid HttpServer::taskFailed(kj::Exception&& exception) {\n  KJ_IF_SOME(handler, settings.errorHandler) {\n    handler.handleListenLoopException(kj::mv(exception));\n  } else {\n    defaultHandleListenLoopException(kj::mv(exception));\n  }\n}\n\nHttpServer::SuspendedRequest::SuspendedRequest(\n    kj::Array<byte> bufferParam, kj::ArrayPtr<byte> leftoverParam,\n    kj::OneOf<HttpMethod, HttpConnectMethod> method,\n    kj::StringPtr url, HttpHeaders headers)\n    : buffer(kj::mv(bufferParam)),\n      leftover(leftoverParam),\n      method(method),\n      url(url),\n      headers(kj::mv(headers)) {\n  if (leftover.size() > 0) {\n    // We have a `leftover`; make sure it is a slice of `buffer`.\n    KJ_ASSERT(leftover.begin() >= buffer.begin() && leftover.begin() <= buffer.end());\n    KJ_ASSERT(leftover.end() >= buffer.begin() && leftover.end() <= buffer.end());\n  } else {\n    // We have no `leftover`, but we still expect it to point into `buffer` somewhere. This is\n    // important so that `messageHeaderEnd` is initialized correctly in HttpInputStreamImpl's\n    // constructor.\n    KJ_ASSERT(leftover.begin() >= buffer.begin() && leftover.begin() <= buffer.end());\n  }\n}\n\nHttpServer::SuspendedRequest HttpServer::SuspendableRequest::suspend() {\n  return connection.suspend(*this);\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleClientProtocolError(\n    HttpHeaders::ProtocolError protocolError, kj::HttpService::Response& response) {\n  // Default error handler implementation.\n\n  HttpHeaderTable headerTable {};\n  HttpHeaders headers(headerTable);\n  headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n  auto errorMessage = kj::str(\"ERROR: \", protocolError.description);\n  auto body = response.send(protocolError.statusCode, protocolError.statusMessage,\n                            headers, errorMessage.size());\n\n  return body->write(errorMessage.begin(), errorMessage.size())\n      .attach(kj::mv(errorMessage), kj::mv(body));\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleApplicationError(\n    kj::Exception exception, kj::Maybe<kj::HttpService::Response&> response) {\n  // Default error handler implementation.\n\n  if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n    // How do we tell an HTTP client that there was a transient network error, and it should\n    // try again immediately? There's no HTTP status code for this (503 is meant for \"try\n    // again later, not now\"). Here's an idea: Don't send any response; just close the\n    // connection, so that it looks like the connection between the HTTP client and server\n    // was dropped. A good client should treat this exactly the way we want.\n    //\n    // We also bail here to avoid logging the disconnection, which isn't very interesting.\n    return kj::READY_NOW;\n  }\n\n  KJ_IF_SOME(r, response) {\n    KJ_LOG(INFO, \"threw exception while serving HTTP response\", exception);\n\n    HttpHeaderTable headerTable {};\n    HttpHeaders headers(headerTable);\n    headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n    kj::String errorMessage;\n    kj::Own<AsyncOutputStream> body;\n\n    if (exception.getType() == kj::Exception::Type::OVERLOADED) {\n      errorMessage = kj::str(\n          \"ERROR: The server is temporarily unable to handle your request. Details:\\n\\n\", exception);\n      body = r.send(503, \"Service Unavailable\", headers, errorMessage.size());\n    } else if (exception.getType() == kj::Exception::Type::UNIMPLEMENTED) {\n      errorMessage = kj::str(\n          \"ERROR: The server does not implement this operation. Details:\\n\\n\", exception);\n      body = r.send(501, \"Not Implemented\", headers, errorMessage.size());\n    } else {\n      errorMessage = kj::str(\n          \"ERROR: The server threw an exception. Details:\\n\\n\", exception);\n      body = r.send(500, \"Internal Server Error\", headers, errorMessage.size());\n    }\n\n    return body->write(errorMessage.begin(), errorMessage.size())\n        .attach(kj::mv(errorMessage), kj::mv(body));\n  }\n\n  KJ_LOG(ERROR, \"HttpService threw exception after generating a partial response\",\n                \"too late to report error to client\", exception);\n  return kj::READY_NOW;\n}\n\nvoid HttpServerErrorHandler::handleListenLoopException(kj::Exception&& exception) {\n  defaultHandleListenLoopException(kj::mv(exception));\n}\n\nkj::Promise<void> HttpServerErrorHandler::handleNoResponse(kj::HttpService::Response& response) {\n  HttpHeaderTable headerTable {};\n  HttpHeaders headers(headerTable);\n  headers.set(HttpHeaderId::CONTENT_TYPE, \"text/plain\");\n\n  constexpr auto errorMessage = \"ERROR: The HttpService did not generate a response.\"_kj;\n  auto body = response.send(500, \"Internal Server Error\", headers, errorMessage.size());\n\n  return body->write(errorMessage.begin(), errorMessage.size()).attach(kj::mv(body));\n}\n\n} // namespace kj\n"], "filenames": ["c++/src/kj/compat/http.c++"], "buggy_code_start_loc": [2763], "buggy_code_end_loc": [2866], "fixing_code_start_loc": [2764], "fixing_code_end_loc": [2874], "type": "CWE-787", "message": "Cap'n Proto is a data interchange format and capability-based RPC system. In versions 1.0 and 1.0.1, when using the KJ HTTP library with WebSocket compression enabled, a buffer underrun can be caused by a remote peer. The underrun always writes a constant value that is not attacker-controlled, likely resulting in a crash, enabling a remote denial-of-service attack. Most Cap'n Proto and KJ users are unlikely to have this functionality enabled and so unlikely to be affected. Maintainers suspect only the Cloudflare Workers Runtime is affected.\n\nIf KJ HTTP is used with WebSocket compression enabled, a malicious peer may be able to cause a buffer underrun on a heap-allocated buffer. KJ HTTP is an optional library bundled with Cap'n Proto, but is not directly used by Cap'n Proto. WebSocket compression is disabled by default. It must be enabled via a setting passed to the KJ HTTP library via `HttpClientSettings` or `HttpServerSettings`. The bytes written out-of-bounds are always a specific constant 4-byte string `{ 0x00, 0x00, 0xFF, 0xFF }`. Because this string is not controlled by the attacker, maintainers believe it is unlikely that remote code execution is possible. However, it cannot be ruled out. This functionality first appeared in Cap'n Proto 1.0. Previous versions are not affected.\n\nThis issue is fixed in Cap'n Proto 1.0.1.1.", "other": {"cve": {"id": "CVE-2023-48230", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-21T21:15:08.683", "lastModified": "2023-11-29T02:35:10.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cap'n Proto is a data interchange format and capability-based RPC system. In versions 1.0 and 1.0.1, when using the KJ HTTP library with WebSocket compression enabled, a buffer underrun can be caused by a remote peer. The underrun always writes a constant value that is not attacker-controlled, likely resulting in a crash, enabling a remote denial-of-service attack. Most Cap'n Proto and KJ users are unlikely to have this functionality enabled and so unlikely to be affected. Maintainers suspect only the Cloudflare Workers Runtime is affected.\n\nIf KJ HTTP is used with WebSocket compression enabled, a malicious peer may be able to cause a buffer underrun on a heap-allocated buffer. KJ HTTP is an optional library bundled with Cap'n Proto, but is not directly used by Cap'n Proto. WebSocket compression is disabled by default. It must be enabled via a setting passed to the KJ HTTP library via `HttpClientSettings` or `HttpServerSettings`. The bytes written out-of-bounds are always a specific constant 4-byte string `{ 0x00, 0x00, 0xFF, 0xFF }`. Because this string is not controlled by the attacker, maintainers believe it is unlikely that remote code execution is possible. However, it cannot be ruled out. This functionality first appeared in Cap'n Proto 1.0. Previous versions are not affected.\n\nThis issue is fixed in Cap'n Proto 1.0.1.1."}, {"lang": "es", "value": "Cap'n Proto es un formato de intercambio de datos y un sistema RPC basado en capacidades. En las versiones 1.0 y 1.0.1, cuando se utiliza la librer\u00eda HTTP KJ con la compresi\u00f3n WebSocket habilitada, un par remoto puede provocar una insuficiencia de datos del b\u00fafer. La insuficiencia de datos siempre escribe un valor constante que no est\u00e1 controlado por el atacante, lo que probablemente provoca un bloqueo y permite un ataque remoto de denegaci\u00f3n de servicio. Es poco probable que la mayor\u00eda de los usuarios de Cap'n Proto y KJ tengan habilitada esta funcionalidad y, por lo tanto, es poco probable que se vean afectados. Los mantenedores sospechan que Cloudflare Workers Runtime se ve afectado. Si se utiliza KJ HTTP con la compresi\u00f3n WebSocket habilitada, un par malintencionado puede provocar una insuficiencia de datos en un b\u00fafer asignado en heap. KJ HTTP es una librer\u00eda opcional incluida con Cap'n Proto, pero Cap'n Proto no la utiliza directamente. La compresi\u00f3n WebSocket est\u00e1 deshabilitada de forma predeterminada. Debe habilitarse mediante una configuraci\u00f3n pasada a la librer\u00eda HTTP KJ mediante `HttpClientSettings` o `HttpServerSettings`. Los bytes escritos fuera de los l\u00edmites son siempre una cadena constante espec\u00edfica de 4 bytes `{ 0x00, 0x00, 0xFF, 0xFF }`. Debido a que el atacante no controla esta cadena, los mantenedores creen que es poco probable que sea posible la ejecuci\u00f3n remota de c\u00f3digo. Sin embargo, no se puede descartar. Esta funcionalidad apareci\u00f3 por primera vez en Cap'n Proto 1.0. Las versiones anteriores no se ven afectadas. Este problema se solucion\u00f3 en Cap'n Proto 1.0.1.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-124"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:capnproto:capnproto:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "7CA487D0-FD4A-4967-A786-E193A410B278"}, {"vulnerable": true, "criteria": "cpe:2.3:a:capnproto:capnproto:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "C3CBABE2-2DD5-4576-B461-3D18E52DC2B2"}]}]}], "references": [{"url": "https://github.com/capnproto/capnproto/commit/75c5c1499aa6e7690b741204ff9af91cce526c59", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/capnproto/capnproto/commit/e7f22da9c01286a2b0e1e5fbdf3ec9ab3aa128ff", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/capnproto/capnproto/security/advisories/GHSA-r89h-f468-62w3", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/capnproto/capnproto/commit/75c5c1499aa6e7690b741204ff9af91cce526c59"}}