{"buggy_code": ["#include \"cache.h\"\n#include \"object.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"fsck.h\"\n#include \"refs.h\"\n#include \"utf8.h\"\n#include \"sha1-array.h\"\n#include \"decorate.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n#include \"submodule-config.h\"\n#include \"config.h\"\n\nstatic struct oidset gitmodules_found = OIDSET_INIT;\nstatic struct oidset gitmodules_done = OIDSET_INIT;\n\n#define FSCK_FATAL -1\n#define FSCK_INFO -2\n\n#define FOREACH_MSG_ID(FUNC) \\\n\t/* fatal errors */ \\\n\tFUNC(NUL_IN_HEADER, FATAL) \\\n\tFUNC(UNTERMINATED_HEADER, FATAL) \\\n\t/* errors */ \\\n\tFUNC(BAD_DATE, ERROR) \\\n\tFUNC(BAD_DATE_OVERFLOW, ERROR) \\\n\tFUNC(BAD_EMAIL, ERROR) \\\n\tFUNC(BAD_NAME, ERROR) \\\n\tFUNC(BAD_OBJECT_SHA1, ERROR) \\\n\tFUNC(BAD_PARENT_SHA1, ERROR) \\\n\tFUNC(BAD_TAG_OBJECT, ERROR) \\\n\tFUNC(BAD_TIMEZONE, ERROR) \\\n\tFUNC(BAD_TREE, ERROR) \\\n\tFUNC(BAD_TREE_SHA1, ERROR) \\\n\tFUNC(BAD_TYPE, ERROR) \\\n\tFUNC(DUPLICATE_ENTRIES, ERROR) \\\n\tFUNC(MISSING_AUTHOR, ERROR) \\\n\tFUNC(MISSING_COMMITTER, ERROR) \\\n\tFUNC(MISSING_EMAIL, ERROR) \\\n\tFUNC(MISSING_GRAFT, ERROR) \\\n\tFUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_OBJECT, ERROR) \\\n\tFUNC(MISSING_PARENT, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_TAG, ERROR) \\\n\tFUNC(MISSING_TAG_ENTRY, ERROR) \\\n\tFUNC(MISSING_TAG_OBJECT, ERROR) \\\n\tFUNC(MISSING_TREE, ERROR) \\\n\tFUNC(MISSING_TREE_OBJECT, ERROR) \\\n\tFUNC(MISSING_TYPE, ERROR) \\\n\tFUNC(MISSING_TYPE_ENTRY, ERROR) \\\n\tFUNC(MULTIPLE_AUTHORS, ERROR) \\\n\tFUNC(TAG_OBJECT_NOT_TAG, ERROR) \\\n\tFUNC(TREE_NOT_SORTED, ERROR) \\\n\tFUNC(UNKNOWN_TYPE, ERROR) \\\n\tFUNC(ZERO_PADDED_DATE, ERROR) \\\n\tFUNC(GITMODULES_MISSING, ERROR) \\\n\tFUNC(GITMODULES_BLOB, ERROR) \\\n\tFUNC(GITMODULES_PARSE, ERROR) \\\n\tFUNC(GITMODULES_NAME, ERROR) \\\n\tFUNC(GITMODULES_SYMLINK, ERROR) \\\n\tFUNC(GITMODULES_URL, ERROR) \\\n\t/* warnings */ \\\n\tFUNC(BAD_FILEMODE, WARN) \\\n\tFUNC(EMPTY_NAME, WARN) \\\n\tFUNC(FULL_PATHNAME, WARN) \\\n\tFUNC(HAS_DOT, WARN) \\\n\tFUNC(HAS_DOTDOT, WARN) \\\n\tFUNC(HAS_DOTGIT, WARN) \\\n\tFUNC(NULL_SHA1, WARN) \\\n\tFUNC(ZERO_PADDED_FILEMODE, WARN) \\\n\tFUNC(NUL_IN_COMMIT, WARN) \\\n\t/* infos (reported as warnings, but ignored by default) */ \\\n\tFUNC(BAD_TAG_NAME, INFO) \\\n\tFUNC(MISSING_TAGGER_ENTRY, INFO)\n\n#define MSG_ID(id, msg_type) FSCK_MSG_##id,\nenum fsck_msg_id {\n\tFOREACH_MSG_ID(MSG_ID)\n\tFSCK_MSG_MAX\n};\n#undef MSG_ID\n\n#define STR(x) #x\n#define MSG_ID(id, msg_type) { STR(id), NULL, FSCK_##msg_type },\nstatic struct {\n\tconst char *id_string;\n\tconst char *downcased;\n\tint msg_type;\n} msg_id_info[FSCK_MSG_MAX + 1] = {\n\tFOREACH_MSG_ID(MSG_ID)\n\t{ NULL, NULL, -1 }\n};\n#undef MSG_ID\n\nstatic int parse_msg_id(const char *text)\n{\n\tint i;\n\n\tif (!msg_id_info[0].downcased) {\n\t\t/* convert id_string to lower case, without underscores. */\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\t\tconst char *p = msg_id_info[i].id_string;\n\t\t\tint len = strlen(p);\n\t\t\tchar *q = xmalloc(len);\n\n\t\t\tmsg_id_info[i].downcased = q;\n\t\t\twhile (*p)\n\t\t\t\tif (*p == '_')\n\t\t\t\t\tp++;\n\t\t\t\telse\n\t\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int fsck_msg_type(enum fsck_msg_id msg_id,\n\tstruct fsck_options *options)\n{\n\tint msg_type;\n\n\tassert(msg_id >= 0 && msg_id < FSCK_MSG_MAX);\n\n\tif (options->msg_type)\n\t\tmsg_type = options->msg_type[msg_id];\n\telse {\n\t\tmsg_type = msg_id_info[msg_id].msg_type;\n\t\tif (options->strict && msg_type == FSCK_WARN)\n\t\t\tmsg_type = FSCK_ERROR;\n\t}\n\n\treturn msg_type;\n}\n\nstatic void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}\n\nstatic int parse_msg_type(const char *str)\n{\n\tif (!strcmp(str, \"error\"))\n\t\treturn FSCK_ERROR;\n\telse if (!strcmp(str, \"warn\"))\n\t\treturn FSCK_WARN;\n\telse if (!strcmp(str, \"ignore\"))\n\t\treturn FSCK_IGNORE;\n\telse\n\t\tdie(\"Unknown fsck message type: '%s'\", str);\n}\n\nint is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}\n\nvoid fsck_set_msg_type(struct fsck_options *options,\n\t\tconst char *msg_id, const char *msg_type)\n{\n\tint id = parse_msg_id(msg_id), type;\n\n\tif (id < 0)\n\t\tdie(\"Unhandled message id: %s\", msg_id);\n\ttype = parse_msg_type(msg_type);\n\n\tif (type != FSCK_ERROR && msg_id_info[id].msg_type == FSCK_FATAL)\n\t\tdie(\"Cannot demote %s to %s\", msg_id, msg_type);\n\n\tif (!options->msg_type) {\n\t\tint i;\n\t\tint *msg_type;\n\t\tALLOC_ARRAY(msg_type, FSCK_MSG_MAX);\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\t\tmsg_type[i] = fsck_msg_type(i, options);\n\t\toptions->msg_type = msg_type;\n\t}\n\n\toptions->msg_type[id] = type;\n}\n\nvoid fsck_set_msg_types(struct fsck_options *options, const char *values)\n{\n\tchar *buf = xstrdup(values), *to_free = buf;\n\tint done = 0;\n\n\twhile (!done) {\n\t\tint len = strcspn(buf, \" ,|\"), equal;\n\n\t\tdone = !buf[len];\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[len] = '\\0';\n\n\t\tfor (equal = 0;\n\t\t     equal < len && buf[equal] != '=' && buf[equal] != ':';\n\t\t     equal++)\n\t\t\tbuf[equal] = tolower(buf[equal]);\n\t\tbuf[equal] = '\\0';\n\n\t\tif (!strcmp(buf, \"skiplist\")) {\n\t\t\tif (equal == len)\n\t\t\t\tdie(\"skiplist requires a path\");\n\t\t\tinit_skiplist(options, buf + equal + 1);\n\t\t\tbuf += len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (equal == len)\n\t\t\tdie(\"Missing '=': '%s'\", buf);\n\n\t\tfsck_set_msg_type(options, buf, buf + equal + 1);\n\t\tbuf += len + 1;\n\t}\n\tfree(to_free);\n}\n\nstatic void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n\n__attribute__((format (printf, 4, 5)))\nstatic int report(struct fsck_options *options, struct object *object,\n\tenum fsck_msg_id id, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint msg_type = fsck_msg_type(id, options), result;\n\n\tif (msg_type == FSCK_IGNORE)\n\t\treturn 0;\n\n\tif (options->skiplist && object &&\n\t\t\toid_array_lookup(options->skiplist, &object->oid) >= 0)\n\t\treturn 0;\n\n\tif (msg_type == FSCK_FATAL)\n\t\tmsg_type = FSCK_ERROR;\n\telse if (msg_type == FSCK_INFO)\n\t\tmsg_type = FSCK_WARN;\n\n\tappend_msg_id(&sb, msg_id_info[id].id_string);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tresult = options->error_func(options, object, msg_type, sb.buf);\n\tstrbuf_release(&sb);\n\tva_end(ap);\n\n\treturn result;\n}\n\nstatic char *get_object_name(struct fsck_options *options, struct object *obj)\n{\n\tif (!options->object_names)\n\t\treturn NULL;\n\treturn lookup_decoration(options->object_names, obj);\n}\n\nstatic void put_object_name(struct fsck_options *options, struct object *obj,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *existing;\n\n\tif (!options->object_names)\n\t\treturn;\n\texisting = lookup_decoration(options->object_names, obj);\n\tif (existing)\n\t\treturn;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tadd_decoration(options->object_names, obj, strbuf_detach(&buf, NULL));\n\tva_end(ap);\n}\n\nstatic const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint res = 0;\n\tconst char *name;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tname = get_object_name(options, &tree->object);\n\tif (init_tree_desc_gently(&desc, tree->buffer, tree->size))\n\t\treturn -1;\n\twhile (tree_entry_gently(&desc, &entry)) {\n\t\tstruct object *obj;\n\t\tint result;\n\n\t\tif (S_ISGITLINK(entry.mode))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_tree(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s/\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_TREE, data, options);\n\t\t}\n\t\telse if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_blob(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_BLOB, data, options);\n\t\t}\n\t\telse {\n\t\t\tresult = error(\"in tree %s: entry %s has bad mode %.6o\",\n\t\t\t\t\tdescribe_object(options, &tree->object), entry.path, entry.mode);\n\t\t}\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)\n{\n\tint counter = 0, generation = 0, name_prefix_len = 0;\n\tstruct commit_list *parents;\n\tint res;\n\tint result;\n\tconst char *name;\n\n\tif (parse_commit(commit))\n\t\treturn -1;\n\n\tname = get_object_name(options, &commit->object);\n\tif (name)\n\t\tput_object_name(options, &commit->tree->object, \"%s:\", name);\n\n\tresult = options->walk((struct object *)commit->tree, OBJ_TREE, data, options);\n\tif (result < 0)\n\t\treturn result;\n\tres = result;\n\n\tparents = commit->parents;\n\tif (name && parents) {\n\t\tint len = strlen(name), power;\n\n\t\tif (len && name[len - 1] == '^') {\n\t\t\tgeneration = 1;\n\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t\telse { /* parse ~<generation> suffix */\n\t\t\tfor (generation = 0, power = 1;\n\t\t\t     len && isdigit(name[len - 1]);\n\t\t\t     power *= 10)\n\t\t\t\tgeneration += power * (name[--len] - '0');\n\t\t\tif (power > 1 && len && name[len - 1] == '~')\n\t\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t}\n\n\twhile (parents) {\n\t\tif (name) {\n\t\t\tstruct object *obj = &parents->item->object;\n\n\t\t\tif (++counter > 1)\n\t\t\t\tput_object_name(options, obj, \"%s^%d\",\n\t\t\t\t\tname, counter);\n\t\t\telse if (generation > 0)\n\t\t\t\tput_object_name(options, obj, \"%.*s~%d\",\n\t\t\t\t\tname_prefix_len, name, generation + 1);\n\t\t\telse\n\t\t\t\tput_object_name(options, obj, \"%s^\", name);\n\t\t}\n\t\tresult = options->walk((struct object *)parents->item, OBJ_COMMIT, data, options);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t\tparents = parents->next;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}\n\nint fsck_walk(struct object *obj, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (obj->type == OBJ_NONE)\n\t\tparse_object(&obj->oid);\n\n\tswitch (obj->type) {\n\tcase OBJ_BLOB:\n\t\treturn 0;\n\tcase OBJ_TREE:\n\t\treturn fsck_walk_tree((struct tree *)obj, data, options);\n\tcase OBJ_COMMIT:\n\t\treturn fsck_walk_commit((struct commit *)obj, data, options);\n\tcase OBJ_TAG:\n\t\treturn fsck_walk_tag((struct tag *)obj, data, options);\n\tdefault:\n\t\terror(\"Unknown object type for %s\", describe_object(options, obj));\n\t\treturn -1;\n\t}\n}\n\n/*\n * The entries in a tree are ordered in the _path_ order,\n * which means that a directory entry is ordered by adding\n * a slash to the end of it.\n *\n * So a directory called \"a\" is ordered _after_ a file\n * called \"a.c\", because \"a/\" sorts after \"a.c\".\n */\n#define TREE_UNORDERED (-1)\n#define TREE_HAS_DUPS  (-2)\n\nstatic int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\n\t/*\n\t * Ok, the first <len> characters are the same.\n\t * Now we need to order the next one, but turn\n\t * a '\\0' into a '/' for a directory entry.\n\t */\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\t/*\n\t\t * git-write-tree used to write out a nonsense tree that has\n\t\t * entries with the same name, one blob and one tree.  Make\n\t\t * sure we do not have duplicate entries.\n\t\t */\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}\n\nstatic int fsck_tree(struct tree *item, struct fsck_options *options)\n{\n\tint retval = 0;\n\tint has_null_sha1 = 0;\n\tint has_full_path = 0;\n\tint has_empty_name = 0;\n\tint has_dot = 0;\n\tint has_dotdot = 0;\n\tint has_dotgit = 0;\n\tint has_zero_pad = 0;\n\tint has_bad_modes = 0;\n\tint has_dup_entries = 0;\n\tint not_properly_sorted = 0;\n\tstruct tree_desc desc;\n\tunsigned o_mode;\n\tconst char *o_name;\n\n\tif (init_tree_desc_gently(&desc, item->buffer, item->size)) {\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\treturn retval;\n\t}\n\n\to_mode = 0;\n\to_name = NULL;\n\n\twhile (desc.size) {\n\t\tunsigned mode;\n\t\tconst char *name;\n\t\tconst struct object_id *oid;\n\n\t\toid = tree_entry_extract(&desc, &name, &mode);\n\n\t\thas_null_sha1 |= is_null_oid(oid);\n\t\thas_full_path |= !!strchr(name, '/');\n\t\thas_empty_name |= !*name;\n\t\thas_dot |= !strcmp(name, \".\");\n\t\thas_dotdot |= !strcmp(name, \"..\");\n\t\thas_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);\n\t\thas_zero_pad |= *(char *)desc.buffer == '0';\n\n\t\tif (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {\n\t\t\tif (!S_ISLNK(mode))\n\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\telse\n\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t}\n\n\t\tif (update_tree_entry_gently(&desc)) {\n\t\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mode) {\n\t\t/*\n\t\t * Standard modes..\n\t\t */\n\t\tcase S_IFREG | 0755:\n\t\tcase S_IFREG | 0644:\n\t\tcase S_IFLNK:\n\t\tcase S_IFDIR:\n\t\tcase S_IFGITLINK:\n\t\t\tbreak;\n\t\t/*\n\t\t * This is nonstandard, but we had a few of these\n\t\t * early on when we honored the full set of mode\n\t\t * bits..\n\t\t */\n\t\tcase S_IFREG | 0664:\n\t\t\tif (!options->strict)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\thas_bad_modes = 1;\n\t\t}\n\n\t\tif (o_name) {\n\t\t\tswitch (verify_ordered(o_mode, o_name, mode, name)) {\n\t\t\tcase TREE_UNORDERED:\n\t\t\t\tnot_properly_sorted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TREE_HAS_DUPS:\n\t\t\t\thas_dup_entries = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\to_mode = mode;\n\t\to_name = name;\n\t}\n\n\tif (has_null_sha1)\n\t\tretval += report(options, &item->object, FSCK_MSG_NULL_SHA1, \"contains entries pointing to null sha1\");\n\tif (has_full_path)\n\t\tretval += report(options, &item->object, FSCK_MSG_FULL_PATHNAME, \"contains full pathnames\");\n\tif (has_empty_name)\n\t\tretval += report(options, &item->object, FSCK_MSG_EMPTY_NAME, \"contains empty pathname\");\n\tif (has_dot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOT, \"contains '.'\");\n\tif (has_dotdot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTDOT, \"contains '..'\");\n\tif (has_dotgit)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTGIT, \"contains '.git'\");\n\tif (has_zero_pad)\n\t\tretval += report(options, &item->object, FSCK_MSG_ZERO_PADDED_FILEMODE, \"contains zero-padded file modes\");\n\tif (has_bad_modes)\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_FILEMODE, \"contains bad file modes\");\n\tif (has_dup_entries)\n\t\tretval += report(options, &item->object, FSCK_MSG_DUPLICATE_ENTRIES, \"contains duplicate file entries\");\n\tif (not_properly_sorted)\n\t\tretval += report(options, &item->object, FSCK_MSG_TREE_NOT_SORTED, \"not properly sorted\");\n\treturn retval;\n}\n\nstatic int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We did not find double-LF that separates the header\n\t * and the body.  Not having a body is not a crime but\n\t * we do want to see the terminating LF for the last header\n\t * line.\n\t */\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}\n\nstatic int fsck_ident(const char **ident, struct object *obj, struct fsck_options *options)\n{\n\tconst char *p = *ident;\n\tchar *end;\n\n\t*ident = strchrnul(*ident, '\\n');\n\tif (**ident == '\\n')\n\t\t(*ident)++;\n\n\tif (*p == '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p == '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_NAME, \"invalid author/committer line - bad name\");\n\tif (*p != '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_EMAIL, \"invalid author/committer line - missing email\");\n\tif (p[-1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp++;\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p != '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_EMAIL, \"invalid author/committer line - bad email\");\n\tp++;\n\tif (*p != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_DATE, \"invalid author/committer line - missing space before date\");\n\tp++;\n\tif (*p == '0' && p[1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_ZERO_PADDED_DATE, \"invalid author/committer line - zero-padded date\");\n\tif (date_overflows(parse_timestamp(p, &end, 10)))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE_OVERFLOW, \"invalid author/committer line - date causes integer overflow\");\n\tif ((end == p || *end != ' '))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE, \"invalid author/committer line - bad date\");\n\tp = end + 1;\n\tif ((*p != '+' && *p != '-') ||\n\t    !isdigit(p[1]) ||\n\t    !isdigit(p[2]) ||\n\t    !isdigit(p[3]) ||\n\t    !isdigit(p[4]) ||\n\t    (p[5] != '\\n'))\n\t\treturn report(options, obj, FSCK_MSG_BAD_TIMEZONE, \"invalid author/committer line - bad time zone\");\n\tp += 6;\n\treturn 0;\n}\n\nstatic int fsck_commit_buffer(struct commit *commit, const char *buffer,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char tree_sha1[20], sha1[20];\n\tstruct commit_graft *graft;\n\tunsigned parent_count, parent_line_count = 0, author_count;\n\tint err;\n\tconst char *buffer_begin = buffer;\n\n\tif (verify_headers(buffer, size, &commit->object, options))\n\t\treturn -1;\n\n\tif (!skip_prefix(buffer, \"tree \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_TREE, \"invalid format - expected 'tree' line\");\n\tif (get_sha1_hex(buffer, tree_sha1) || buffer[40] != '\\n') {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE_SHA1, \"invalid 'tree' line format - bad sha1\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbuffer += 41;\n\twhile (skip_prefix(buffer, \"parent \", &buffer)) {\n\t\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_BAD_PARENT_SHA1, \"invalid 'parent' line format - bad sha1\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbuffer += 41;\n\t\tparent_line_count++;\n\t}\n\tgraft = lookup_commit_graft(&commit->object.oid);\n\tparent_count = commit_list_count(commit->parents);\n\tif (graft) {\n\t\tif (graft->nr_parent == -1 && !parent_count)\n\t\t\t; /* shallow commit */\n\t\telse if (graft->nr_parent != parent_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_GRAFT, \"graft objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (parent_count != parent_line_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_PARENT, \"parent objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tauthor_count = 0;\n\twhile (skip_prefix(buffer, \"author \", &buffer)) {\n\t\tauthor_count++;\n\t\terr = fsck_ident(&buffer, &commit->object, options);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (author_count < 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_AUTHOR, \"invalid format - expected 'author' line\");\n\telse if (author_count > 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MULTIPLE_AUTHORS, \"invalid format - multiple 'author' lines\");\n\tif (err)\n\t\treturn err;\n\tif (!skip_prefix(buffer, \"committer \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_COMMITTER, \"invalid format - expected 'committer' line\");\n\terr = fsck_ident(&buffer, &commit->object, options);\n\tif (err)\n\t\treturn err;\n\tif (!commit->tree) {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE, \"could not load commit's tree %s\", sha1_to_hex(tree_sha1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (memchr(buffer_begin, '\\0', size)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_NUL_IN_COMMIT,\n\t\t\t     \"NUL byte in the commit object body\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}\n\nstatic int fsck_tag_buffer(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char sha1[20];\n\tint ret = 0;\n\tconst char *buffer;\n\tchar *to_free = NULL, *eol;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (data)\n\t\tbuffer = data;\n\telse {\n\t\tenum object_type type;\n\n\t\tbuffer = to_free =\n\t\t\tread_sha1_file(tag->object.oid.hash, &type, &size);\n\t\tif (!buffer)\n\t\t\treturn report(options, &tag->object,\n\t\t\t\tFSCK_MSG_MISSING_TAG_OBJECT,\n\t\t\t\t\"cannot read tag object\");\n\n\t\tif (type != OBJ_TAG) {\n\t\t\tret = report(options, &tag->object,\n\t\t\t\tFSCK_MSG_TAG_OBJECT_NOT_TAG,\n\t\t\t\t\"expected tag got %s\",\n\t\t\t    type_name(type));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = verify_headers(buffer, size, &tag->object, options);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!skip_prefix(buffer, \"object \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_OBJECT, \"invalid format - expected 'object' line\");\n\t\tgoto done;\n\t}\n\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_OBJECT_SHA1, \"invalid 'object' line format - bad sha1\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer += 41;\n\n\tif (!skip_prefix(buffer, \"type \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE_ENTRY, \"invalid format - expected 'type' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tif (type_from_string_gently(buffer, eol - buffer, 1) < 0)\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TYPE, \"invalid 'type' value\");\n\tif (ret)\n\t\tgoto done;\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tag \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG_ENTRY, \"invalid format - expected 'tag' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tstrbuf_addf(&sb, \"refs/tags/%.*s\", (int)(eol - buffer), buffer);\n\tif (check_refname_format(sb.buf, 0)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TAG_NAME,\n\t\t\t   \"invalid 'tag' name: %.*s\",\n\t\t\t   (int)(eol - buffer), buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tagger \", &buffer)) {\n\t\t/* early tags do not contain 'tagger' lines; warn only */\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAGGER_ENTRY, \"invalid format - expected 'tagger' line\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\telse\n\t\tret = fsck_ident(&buffer, &tag->object, options);\n\ndone:\n\tstrbuf_release(&sb);\n\tfree(to_free);\n\treturn ret;\n}\n\nstatic int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\n\treturn fsck_tag_buffer(tag, data, size, options);\n}\n\nstruct fsck_gitmodules_data {\n\tstruct object *obj;\n\tstruct fsck_options *options;\n\tint ret;\n};\n\nstatic int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n\nstatic int fsck_blob(struct blob *blob, const char *buf,\n\t\t     unsigned long size, struct fsck_options *options)\n{\n\tstruct fsck_gitmodules_data data;\n\n\tif (!oidset_contains(&gitmodules_found, &blob->object.oid))\n\t\treturn 0;\n\toidset_insert(&gitmodules_done, &blob->object.oid);\n\n\tif (!buf) {\n\t\t/*\n\t\t * A missing buffer here is a sign that the caller found the\n\t\t * blob too gigantic to load into memory. Let's just consider\n\t\t * that an error.\n\t\t */\n\t\treturn report(options, &blob->object,\n\t\t\t      FSCK_MSG_GITMODULES_PARSE,\n\t\t\t      \".gitmodules too large to parse\");\n\t}\n\n\tdata.obj = &blob->object;\n\tdata.options = options;\n\tdata.ret = 0;\n\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\t\t\t\t\".gitmodules\", buf, size, &data))\n\t\tdata.ret |= report(options, &blob->object,\n\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n\t\t\t\t   \"could not parse gitmodules blob\");\n\n\treturn data.ret;\n}\n\nint fsck_object(struct object *obj, void *data, unsigned long size,\n\tstruct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn report(options, obj, FSCK_MSG_BAD_OBJECT_SHA1, \"no valid object to fsck\");\n\n\tif (obj->type == OBJ_BLOB)\n\t\treturn fsck_blob((struct blob *)obj, data, size, options);\n\tif (obj->type == OBJ_TREE)\n\t\treturn fsck_tree((struct tree *) obj, options);\n\tif (obj->type == OBJ_COMMIT)\n\t\treturn fsck_commit((struct commit *) obj, (const char *) data,\n\t\t\tsize, options);\n\tif (obj->type == OBJ_TAG)\n\t\treturn fsck_tag((struct tag *) obj, (const char *) data,\n\t\t\tsize, options);\n\n\treturn report(options, obj, FSCK_MSG_UNKNOWN_TYPE, \"unknown type '%d' (internal fsck error)\",\n\t\t\t  obj->type);\n}\n\nint fsck_error_function(struct fsck_options *o,\n\tstruct object *obj, int msg_type, const char *message)\n{\n\tif (msg_type == FSCK_WARN) {\n\t\twarning(\"object %s: %s\", describe_object(o, obj), message);\n\t\treturn 0;\n\t}\n\terror(\"object %s: %s\", describe_object(o, obj), message);\n\treturn 1;\n}\n\nint fsck_finish(struct fsck_options *options)\n{\n\tint ret = 0;\n\tstruct oidset_iter iter;\n\tconst struct object_id *oid;\n\n\toidset_iter_init(&gitmodules_found, &iter);\n\twhile ((oid = oidset_iter_next(&iter))) {\n\t\tstruct blob *blob;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *buf;\n\n\t\tif (oidset_contains(&gitmodules_done, oid))\n\t\t\tcontinue;\n\n\t\tblob = lookup_blob(oid);\n\t\tif (!blob) {\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = read_sha1_file(oid->hash, &type, &size);\n\t\tif (!buf) {\n\t\t\tif (is_promisor_object(&blob->object.oid))\n\t\t\t\tcontinue;\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\t\t\t\t      \"unable to read .gitmodules blob\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\tret |= fsck_blob(blob, buf, size, options);\n\t\telse\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\tfree(buf);\n\t}\n\n\n\toidset_clear(&gitmodules_found);\n\toidset_clear(&gitmodules_done);\n\treturn ret;\n}\n", "#!/bin/sh\n\ntest_description='check handling of .gitmodule path with dash'\n. ./test-lib.sh\n\ntest_expect_success 'create submodule with dash in path' '\n\tgit init upstream &&\n\tgit -C upstream commit --allow-empty -m base &&\n\tgit submodule add ./upstream sub &&\n\tgit mv sub ./-sub &&\n\tgit commit -m submodule\n'\n\ntest_expect_success 'clone rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit clone --recurse-submodules . dst 2>err &&\n\ttest_i18ngrep ignoring err\n'\n\ntest_done\n"], "fixing_code": ["#include \"cache.h\"\n#include \"object.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"fsck.h\"\n#include \"refs.h\"\n#include \"utf8.h\"\n#include \"sha1-array.h\"\n#include \"decorate.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n#include \"submodule-config.h\"\n#include \"config.h\"\n\nstatic struct oidset gitmodules_found = OIDSET_INIT;\nstatic struct oidset gitmodules_done = OIDSET_INIT;\n\n#define FSCK_FATAL -1\n#define FSCK_INFO -2\n\n#define FOREACH_MSG_ID(FUNC) \\\n\t/* fatal errors */ \\\n\tFUNC(NUL_IN_HEADER, FATAL) \\\n\tFUNC(UNTERMINATED_HEADER, FATAL) \\\n\t/* errors */ \\\n\tFUNC(BAD_DATE, ERROR) \\\n\tFUNC(BAD_DATE_OVERFLOW, ERROR) \\\n\tFUNC(BAD_EMAIL, ERROR) \\\n\tFUNC(BAD_NAME, ERROR) \\\n\tFUNC(BAD_OBJECT_SHA1, ERROR) \\\n\tFUNC(BAD_PARENT_SHA1, ERROR) \\\n\tFUNC(BAD_TAG_OBJECT, ERROR) \\\n\tFUNC(BAD_TIMEZONE, ERROR) \\\n\tFUNC(BAD_TREE, ERROR) \\\n\tFUNC(BAD_TREE_SHA1, ERROR) \\\n\tFUNC(BAD_TYPE, ERROR) \\\n\tFUNC(DUPLICATE_ENTRIES, ERROR) \\\n\tFUNC(MISSING_AUTHOR, ERROR) \\\n\tFUNC(MISSING_COMMITTER, ERROR) \\\n\tFUNC(MISSING_EMAIL, ERROR) \\\n\tFUNC(MISSING_GRAFT, ERROR) \\\n\tFUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_OBJECT, ERROR) \\\n\tFUNC(MISSING_PARENT, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_TAG, ERROR) \\\n\tFUNC(MISSING_TAG_ENTRY, ERROR) \\\n\tFUNC(MISSING_TAG_OBJECT, ERROR) \\\n\tFUNC(MISSING_TREE, ERROR) \\\n\tFUNC(MISSING_TREE_OBJECT, ERROR) \\\n\tFUNC(MISSING_TYPE, ERROR) \\\n\tFUNC(MISSING_TYPE_ENTRY, ERROR) \\\n\tFUNC(MULTIPLE_AUTHORS, ERROR) \\\n\tFUNC(TAG_OBJECT_NOT_TAG, ERROR) \\\n\tFUNC(TREE_NOT_SORTED, ERROR) \\\n\tFUNC(UNKNOWN_TYPE, ERROR) \\\n\tFUNC(ZERO_PADDED_DATE, ERROR) \\\n\tFUNC(GITMODULES_MISSING, ERROR) \\\n\tFUNC(GITMODULES_BLOB, ERROR) \\\n\tFUNC(GITMODULES_PARSE, ERROR) \\\n\tFUNC(GITMODULES_NAME, ERROR) \\\n\tFUNC(GITMODULES_SYMLINK, ERROR) \\\n\tFUNC(GITMODULES_URL, ERROR) \\\n\tFUNC(GITMODULES_PATH, ERROR) \\\n\t/* warnings */ \\\n\tFUNC(BAD_FILEMODE, WARN) \\\n\tFUNC(EMPTY_NAME, WARN) \\\n\tFUNC(FULL_PATHNAME, WARN) \\\n\tFUNC(HAS_DOT, WARN) \\\n\tFUNC(HAS_DOTDOT, WARN) \\\n\tFUNC(HAS_DOTGIT, WARN) \\\n\tFUNC(NULL_SHA1, WARN) \\\n\tFUNC(ZERO_PADDED_FILEMODE, WARN) \\\n\tFUNC(NUL_IN_COMMIT, WARN) \\\n\t/* infos (reported as warnings, but ignored by default) */ \\\n\tFUNC(BAD_TAG_NAME, INFO) \\\n\tFUNC(MISSING_TAGGER_ENTRY, INFO)\n\n#define MSG_ID(id, msg_type) FSCK_MSG_##id,\nenum fsck_msg_id {\n\tFOREACH_MSG_ID(MSG_ID)\n\tFSCK_MSG_MAX\n};\n#undef MSG_ID\n\n#define STR(x) #x\n#define MSG_ID(id, msg_type) { STR(id), NULL, FSCK_##msg_type },\nstatic struct {\n\tconst char *id_string;\n\tconst char *downcased;\n\tint msg_type;\n} msg_id_info[FSCK_MSG_MAX + 1] = {\n\tFOREACH_MSG_ID(MSG_ID)\n\t{ NULL, NULL, -1 }\n};\n#undef MSG_ID\n\nstatic int parse_msg_id(const char *text)\n{\n\tint i;\n\n\tif (!msg_id_info[0].downcased) {\n\t\t/* convert id_string to lower case, without underscores. */\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\t\tconst char *p = msg_id_info[i].id_string;\n\t\t\tint len = strlen(p);\n\t\t\tchar *q = xmalloc(len);\n\n\t\t\tmsg_id_info[i].downcased = q;\n\t\t\twhile (*p)\n\t\t\t\tif (*p == '_')\n\t\t\t\t\tp++;\n\t\t\t\telse\n\t\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int fsck_msg_type(enum fsck_msg_id msg_id,\n\tstruct fsck_options *options)\n{\n\tint msg_type;\n\n\tassert(msg_id >= 0 && msg_id < FSCK_MSG_MAX);\n\n\tif (options->msg_type)\n\t\tmsg_type = options->msg_type[msg_id];\n\telse {\n\t\tmsg_type = msg_id_info[msg_id].msg_type;\n\t\tif (options->strict && msg_type == FSCK_WARN)\n\t\t\tmsg_type = FSCK_ERROR;\n\t}\n\n\treturn msg_type;\n}\n\nstatic void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}\n\nstatic int parse_msg_type(const char *str)\n{\n\tif (!strcmp(str, \"error\"))\n\t\treturn FSCK_ERROR;\n\telse if (!strcmp(str, \"warn\"))\n\t\treturn FSCK_WARN;\n\telse if (!strcmp(str, \"ignore\"))\n\t\treturn FSCK_IGNORE;\n\telse\n\t\tdie(\"Unknown fsck message type: '%s'\", str);\n}\n\nint is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}\n\nvoid fsck_set_msg_type(struct fsck_options *options,\n\t\tconst char *msg_id, const char *msg_type)\n{\n\tint id = parse_msg_id(msg_id), type;\n\n\tif (id < 0)\n\t\tdie(\"Unhandled message id: %s\", msg_id);\n\ttype = parse_msg_type(msg_type);\n\n\tif (type != FSCK_ERROR && msg_id_info[id].msg_type == FSCK_FATAL)\n\t\tdie(\"Cannot demote %s to %s\", msg_id, msg_type);\n\n\tif (!options->msg_type) {\n\t\tint i;\n\t\tint *msg_type;\n\t\tALLOC_ARRAY(msg_type, FSCK_MSG_MAX);\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\t\tmsg_type[i] = fsck_msg_type(i, options);\n\t\toptions->msg_type = msg_type;\n\t}\n\n\toptions->msg_type[id] = type;\n}\n\nvoid fsck_set_msg_types(struct fsck_options *options, const char *values)\n{\n\tchar *buf = xstrdup(values), *to_free = buf;\n\tint done = 0;\n\n\twhile (!done) {\n\t\tint len = strcspn(buf, \" ,|\"), equal;\n\n\t\tdone = !buf[len];\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[len] = '\\0';\n\n\t\tfor (equal = 0;\n\t\t     equal < len && buf[equal] != '=' && buf[equal] != ':';\n\t\t     equal++)\n\t\t\tbuf[equal] = tolower(buf[equal]);\n\t\tbuf[equal] = '\\0';\n\n\t\tif (!strcmp(buf, \"skiplist\")) {\n\t\t\tif (equal == len)\n\t\t\t\tdie(\"skiplist requires a path\");\n\t\t\tinit_skiplist(options, buf + equal + 1);\n\t\t\tbuf += len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (equal == len)\n\t\t\tdie(\"Missing '=': '%s'\", buf);\n\n\t\tfsck_set_msg_type(options, buf, buf + equal + 1);\n\t\tbuf += len + 1;\n\t}\n\tfree(to_free);\n}\n\nstatic void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n\n__attribute__((format (printf, 4, 5)))\nstatic int report(struct fsck_options *options, struct object *object,\n\tenum fsck_msg_id id, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint msg_type = fsck_msg_type(id, options), result;\n\n\tif (msg_type == FSCK_IGNORE)\n\t\treturn 0;\n\n\tif (options->skiplist && object &&\n\t\t\toid_array_lookup(options->skiplist, &object->oid) >= 0)\n\t\treturn 0;\n\n\tif (msg_type == FSCK_FATAL)\n\t\tmsg_type = FSCK_ERROR;\n\telse if (msg_type == FSCK_INFO)\n\t\tmsg_type = FSCK_WARN;\n\n\tappend_msg_id(&sb, msg_id_info[id].id_string);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tresult = options->error_func(options, object, msg_type, sb.buf);\n\tstrbuf_release(&sb);\n\tva_end(ap);\n\n\treturn result;\n}\n\nstatic char *get_object_name(struct fsck_options *options, struct object *obj)\n{\n\tif (!options->object_names)\n\t\treturn NULL;\n\treturn lookup_decoration(options->object_names, obj);\n}\n\nstatic void put_object_name(struct fsck_options *options, struct object *obj,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *existing;\n\n\tif (!options->object_names)\n\t\treturn;\n\texisting = lookup_decoration(options->object_names, obj);\n\tif (existing)\n\t\treturn;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tadd_decoration(options->object_names, obj, strbuf_detach(&buf, NULL));\n\tva_end(ap);\n}\n\nstatic const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint res = 0;\n\tconst char *name;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tname = get_object_name(options, &tree->object);\n\tif (init_tree_desc_gently(&desc, tree->buffer, tree->size))\n\t\treturn -1;\n\twhile (tree_entry_gently(&desc, &entry)) {\n\t\tstruct object *obj;\n\t\tint result;\n\n\t\tif (S_ISGITLINK(entry.mode))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_tree(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s/\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_TREE, data, options);\n\t\t}\n\t\telse if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_blob(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_BLOB, data, options);\n\t\t}\n\t\telse {\n\t\t\tresult = error(\"in tree %s: entry %s has bad mode %.6o\",\n\t\t\t\t\tdescribe_object(options, &tree->object), entry.path, entry.mode);\n\t\t}\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)\n{\n\tint counter = 0, generation = 0, name_prefix_len = 0;\n\tstruct commit_list *parents;\n\tint res;\n\tint result;\n\tconst char *name;\n\n\tif (parse_commit(commit))\n\t\treturn -1;\n\n\tname = get_object_name(options, &commit->object);\n\tif (name)\n\t\tput_object_name(options, &commit->tree->object, \"%s:\", name);\n\n\tresult = options->walk((struct object *)commit->tree, OBJ_TREE, data, options);\n\tif (result < 0)\n\t\treturn result;\n\tres = result;\n\n\tparents = commit->parents;\n\tif (name && parents) {\n\t\tint len = strlen(name), power;\n\n\t\tif (len && name[len - 1] == '^') {\n\t\t\tgeneration = 1;\n\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t\telse { /* parse ~<generation> suffix */\n\t\t\tfor (generation = 0, power = 1;\n\t\t\t     len && isdigit(name[len - 1]);\n\t\t\t     power *= 10)\n\t\t\t\tgeneration += power * (name[--len] - '0');\n\t\t\tif (power > 1 && len && name[len - 1] == '~')\n\t\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t}\n\n\twhile (parents) {\n\t\tif (name) {\n\t\t\tstruct object *obj = &parents->item->object;\n\n\t\t\tif (++counter > 1)\n\t\t\t\tput_object_name(options, obj, \"%s^%d\",\n\t\t\t\t\tname, counter);\n\t\t\telse if (generation > 0)\n\t\t\t\tput_object_name(options, obj, \"%.*s~%d\",\n\t\t\t\t\tname_prefix_len, name, generation + 1);\n\t\t\telse\n\t\t\t\tput_object_name(options, obj, \"%s^\", name);\n\t\t}\n\t\tresult = options->walk((struct object *)parents->item, OBJ_COMMIT, data, options);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t\tparents = parents->next;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}\n\nint fsck_walk(struct object *obj, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (obj->type == OBJ_NONE)\n\t\tparse_object(&obj->oid);\n\n\tswitch (obj->type) {\n\tcase OBJ_BLOB:\n\t\treturn 0;\n\tcase OBJ_TREE:\n\t\treturn fsck_walk_tree((struct tree *)obj, data, options);\n\tcase OBJ_COMMIT:\n\t\treturn fsck_walk_commit((struct commit *)obj, data, options);\n\tcase OBJ_TAG:\n\t\treturn fsck_walk_tag((struct tag *)obj, data, options);\n\tdefault:\n\t\terror(\"Unknown object type for %s\", describe_object(options, obj));\n\t\treturn -1;\n\t}\n}\n\n/*\n * The entries in a tree are ordered in the _path_ order,\n * which means that a directory entry is ordered by adding\n * a slash to the end of it.\n *\n * So a directory called \"a\" is ordered _after_ a file\n * called \"a.c\", because \"a/\" sorts after \"a.c\".\n */\n#define TREE_UNORDERED (-1)\n#define TREE_HAS_DUPS  (-2)\n\nstatic int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\n\t/*\n\t * Ok, the first <len> characters are the same.\n\t * Now we need to order the next one, but turn\n\t * a '\\0' into a '/' for a directory entry.\n\t */\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\t/*\n\t\t * git-write-tree used to write out a nonsense tree that has\n\t\t * entries with the same name, one blob and one tree.  Make\n\t\t * sure we do not have duplicate entries.\n\t\t */\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}\n\nstatic int fsck_tree(struct tree *item, struct fsck_options *options)\n{\n\tint retval = 0;\n\tint has_null_sha1 = 0;\n\tint has_full_path = 0;\n\tint has_empty_name = 0;\n\tint has_dot = 0;\n\tint has_dotdot = 0;\n\tint has_dotgit = 0;\n\tint has_zero_pad = 0;\n\tint has_bad_modes = 0;\n\tint has_dup_entries = 0;\n\tint not_properly_sorted = 0;\n\tstruct tree_desc desc;\n\tunsigned o_mode;\n\tconst char *o_name;\n\n\tif (init_tree_desc_gently(&desc, item->buffer, item->size)) {\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\treturn retval;\n\t}\n\n\to_mode = 0;\n\to_name = NULL;\n\n\twhile (desc.size) {\n\t\tunsigned mode;\n\t\tconst char *name;\n\t\tconst struct object_id *oid;\n\n\t\toid = tree_entry_extract(&desc, &name, &mode);\n\n\t\thas_null_sha1 |= is_null_oid(oid);\n\t\thas_full_path |= !!strchr(name, '/');\n\t\thas_empty_name |= !*name;\n\t\thas_dot |= !strcmp(name, \".\");\n\t\thas_dotdot |= !strcmp(name, \"..\");\n\t\thas_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);\n\t\thas_zero_pad |= *(char *)desc.buffer == '0';\n\n\t\tif (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {\n\t\t\tif (!S_ISLNK(mode))\n\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\telse\n\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t}\n\n\t\tif (update_tree_entry_gently(&desc)) {\n\t\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mode) {\n\t\t/*\n\t\t * Standard modes..\n\t\t */\n\t\tcase S_IFREG | 0755:\n\t\tcase S_IFREG | 0644:\n\t\tcase S_IFLNK:\n\t\tcase S_IFDIR:\n\t\tcase S_IFGITLINK:\n\t\t\tbreak;\n\t\t/*\n\t\t * This is nonstandard, but we had a few of these\n\t\t * early on when we honored the full set of mode\n\t\t * bits..\n\t\t */\n\t\tcase S_IFREG | 0664:\n\t\t\tif (!options->strict)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\thas_bad_modes = 1;\n\t\t}\n\n\t\tif (o_name) {\n\t\t\tswitch (verify_ordered(o_mode, o_name, mode, name)) {\n\t\t\tcase TREE_UNORDERED:\n\t\t\t\tnot_properly_sorted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TREE_HAS_DUPS:\n\t\t\t\thas_dup_entries = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\to_mode = mode;\n\t\to_name = name;\n\t}\n\n\tif (has_null_sha1)\n\t\tretval += report(options, &item->object, FSCK_MSG_NULL_SHA1, \"contains entries pointing to null sha1\");\n\tif (has_full_path)\n\t\tretval += report(options, &item->object, FSCK_MSG_FULL_PATHNAME, \"contains full pathnames\");\n\tif (has_empty_name)\n\t\tretval += report(options, &item->object, FSCK_MSG_EMPTY_NAME, \"contains empty pathname\");\n\tif (has_dot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOT, \"contains '.'\");\n\tif (has_dotdot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTDOT, \"contains '..'\");\n\tif (has_dotgit)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTGIT, \"contains '.git'\");\n\tif (has_zero_pad)\n\t\tretval += report(options, &item->object, FSCK_MSG_ZERO_PADDED_FILEMODE, \"contains zero-padded file modes\");\n\tif (has_bad_modes)\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_FILEMODE, \"contains bad file modes\");\n\tif (has_dup_entries)\n\t\tretval += report(options, &item->object, FSCK_MSG_DUPLICATE_ENTRIES, \"contains duplicate file entries\");\n\tif (not_properly_sorted)\n\t\tretval += report(options, &item->object, FSCK_MSG_TREE_NOT_SORTED, \"not properly sorted\");\n\treturn retval;\n}\n\nstatic int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We did not find double-LF that separates the header\n\t * and the body.  Not having a body is not a crime but\n\t * we do want to see the terminating LF for the last header\n\t * line.\n\t */\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}\n\nstatic int fsck_ident(const char **ident, struct object *obj, struct fsck_options *options)\n{\n\tconst char *p = *ident;\n\tchar *end;\n\n\t*ident = strchrnul(*ident, '\\n');\n\tif (**ident == '\\n')\n\t\t(*ident)++;\n\n\tif (*p == '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p == '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_NAME, \"invalid author/committer line - bad name\");\n\tif (*p != '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_EMAIL, \"invalid author/committer line - missing email\");\n\tif (p[-1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp++;\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p != '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_EMAIL, \"invalid author/committer line - bad email\");\n\tp++;\n\tif (*p != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_DATE, \"invalid author/committer line - missing space before date\");\n\tp++;\n\tif (*p == '0' && p[1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_ZERO_PADDED_DATE, \"invalid author/committer line - zero-padded date\");\n\tif (date_overflows(parse_timestamp(p, &end, 10)))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE_OVERFLOW, \"invalid author/committer line - date causes integer overflow\");\n\tif ((end == p || *end != ' '))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE, \"invalid author/committer line - bad date\");\n\tp = end + 1;\n\tif ((*p != '+' && *p != '-') ||\n\t    !isdigit(p[1]) ||\n\t    !isdigit(p[2]) ||\n\t    !isdigit(p[3]) ||\n\t    !isdigit(p[4]) ||\n\t    (p[5] != '\\n'))\n\t\treturn report(options, obj, FSCK_MSG_BAD_TIMEZONE, \"invalid author/committer line - bad time zone\");\n\tp += 6;\n\treturn 0;\n}\n\nstatic int fsck_commit_buffer(struct commit *commit, const char *buffer,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char tree_sha1[20], sha1[20];\n\tstruct commit_graft *graft;\n\tunsigned parent_count, parent_line_count = 0, author_count;\n\tint err;\n\tconst char *buffer_begin = buffer;\n\n\tif (verify_headers(buffer, size, &commit->object, options))\n\t\treturn -1;\n\n\tif (!skip_prefix(buffer, \"tree \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_TREE, \"invalid format - expected 'tree' line\");\n\tif (get_sha1_hex(buffer, tree_sha1) || buffer[40] != '\\n') {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE_SHA1, \"invalid 'tree' line format - bad sha1\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbuffer += 41;\n\twhile (skip_prefix(buffer, \"parent \", &buffer)) {\n\t\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_BAD_PARENT_SHA1, \"invalid 'parent' line format - bad sha1\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbuffer += 41;\n\t\tparent_line_count++;\n\t}\n\tgraft = lookup_commit_graft(&commit->object.oid);\n\tparent_count = commit_list_count(commit->parents);\n\tif (graft) {\n\t\tif (graft->nr_parent == -1 && !parent_count)\n\t\t\t; /* shallow commit */\n\t\telse if (graft->nr_parent != parent_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_GRAFT, \"graft objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (parent_count != parent_line_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_PARENT, \"parent objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tauthor_count = 0;\n\twhile (skip_prefix(buffer, \"author \", &buffer)) {\n\t\tauthor_count++;\n\t\terr = fsck_ident(&buffer, &commit->object, options);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (author_count < 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_AUTHOR, \"invalid format - expected 'author' line\");\n\telse if (author_count > 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MULTIPLE_AUTHORS, \"invalid format - multiple 'author' lines\");\n\tif (err)\n\t\treturn err;\n\tif (!skip_prefix(buffer, \"committer \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_COMMITTER, \"invalid format - expected 'committer' line\");\n\terr = fsck_ident(&buffer, &commit->object, options);\n\tif (err)\n\t\treturn err;\n\tif (!commit->tree) {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE, \"could not load commit's tree %s\", sha1_to_hex(tree_sha1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (memchr(buffer_begin, '\\0', size)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_NUL_IN_COMMIT,\n\t\t\t     \"NUL byte in the commit object body\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}\n\nstatic int fsck_tag_buffer(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char sha1[20];\n\tint ret = 0;\n\tconst char *buffer;\n\tchar *to_free = NULL, *eol;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (data)\n\t\tbuffer = data;\n\telse {\n\t\tenum object_type type;\n\n\t\tbuffer = to_free =\n\t\t\tread_sha1_file(tag->object.oid.hash, &type, &size);\n\t\tif (!buffer)\n\t\t\treturn report(options, &tag->object,\n\t\t\t\tFSCK_MSG_MISSING_TAG_OBJECT,\n\t\t\t\t\"cannot read tag object\");\n\n\t\tif (type != OBJ_TAG) {\n\t\t\tret = report(options, &tag->object,\n\t\t\t\tFSCK_MSG_TAG_OBJECT_NOT_TAG,\n\t\t\t\t\"expected tag got %s\",\n\t\t\t    type_name(type));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = verify_headers(buffer, size, &tag->object, options);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!skip_prefix(buffer, \"object \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_OBJECT, \"invalid format - expected 'object' line\");\n\t\tgoto done;\n\t}\n\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_OBJECT_SHA1, \"invalid 'object' line format - bad sha1\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer += 41;\n\n\tif (!skip_prefix(buffer, \"type \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE_ENTRY, \"invalid format - expected 'type' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tif (type_from_string_gently(buffer, eol - buffer, 1) < 0)\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TYPE, \"invalid 'type' value\");\n\tif (ret)\n\t\tgoto done;\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tag \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG_ENTRY, \"invalid format - expected 'tag' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tstrbuf_addf(&sb, \"refs/tags/%.*s\", (int)(eol - buffer), buffer);\n\tif (check_refname_format(sb.buf, 0)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TAG_NAME,\n\t\t\t   \"invalid 'tag' name: %.*s\",\n\t\t\t   (int)(eol - buffer), buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tagger \", &buffer)) {\n\t\t/* early tags do not contain 'tagger' lines; warn only */\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAGGER_ENTRY, \"invalid format - expected 'tagger' line\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\telse\n\t\tret = fsck_ident(&buffer, &tag->object, options);\n\ndone:\n\tstrbuf_release(&sb);\n\tfree(to_free);\n\treturn ret;\n}\n\nstatic int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\n\treturn fsck_tag_buffer(tag, data, size, options);\n}\n\nstruct fsck_gitmodules_data {\n\tstruct object *obj;\n\tstruct fsck_options *options;\n\tint ret;\n};\n\nstatic int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n\nstatic int fsck_blob(struct blob *blob, const char *buf,\n\t\t     unsigned long size, struct fsck_options *options)\n{\n\tstruct fsck_gitmodules_data data;\n\n\tif (!oidset_contains(&gitmodules_found, &blob->object.oid))\n\t\treturn 0;\n\toidset_insert(&gitmodules_done, &blob->object.oid);\n\n\tif (!buf) {\n\t\t/*\n\t\t * A missing buffer here is a sign that the caller found the\n\t\t * blob too gigantic to load into memory. Let's just consider\n\t\t * that an error.\n\t\t */\n\t\treturn report(options, &blob->object,\n\t\t\t      FSCK_MSG_GITMODULES_PARSE,\n\t\t\t      \".gitmodules too large to parse\");\n\t}\n\n\tdata.obj = &blob->object;\n\tdata.options = options;\n\tdata.ret = 0;\n\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\t\t\t\t\".gitmodules\", buf, size, &data))\n\t\tdata.ret |= report(options, &blob->object,\n\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n\t\t\t\t   \"could not parse gitmodules blob\");\n\n\treturn data.ret;\n}\n\nint fsck_object(struct object *obj, void *data, unsigned long size,\n\tstruct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn report(options, obj, FSCK_MSG_BAD_OBJECT_SHA1, \"no valid object to fsck\");\n\n\tif (obj->type == OBJ_BLOB)\n\t\treturn fsck_blob((struct blob *)obj, data, size, options);\n\tif (obj->type == OBJ_TREE)\n\t\treturn fsck_tree((struct tree *) obj, options);\n\tif (obj->type == OBJ_COMMIT)\n\t\treturn fsck_commit((struct commit *) obj, (const char *) data,\n\t\t\tsize, options);\n\tif (obj->type == OBJ_TAG)\n\t\treturn fsck_tag((struct tag *) obj, (const char *) data,\n\t\t\tsize, options);\n\n\treturn report(options, obj, FSCK_MSG_UNKNOWN_TYPE, \"unknown type '%d' (internal fsck error)\",\n\t\t\t  obj->type);\n}\n\nint fsck_error_function(struct fsck_options *o,\n\tstruct object *obj, int msg_type, const char *message)\n{\n\tif (msg_type == FSCK_WARN) {\n\t\twarning(\"object %s: %s\", describe_object(o, obj), message);\n\t\treturn 0;\n\t}\n\terror(\"object %s: %s\", describe_object(o, obj), message);\n\treturn 1;\n}\n\nint fsck_finish(struct fsck_options *options)\n{\n\tint ret = 0;\n\tstruct oidset_iter iter;\n\tconst struct object_id *oid;\n\n\toidset_iter_init(&gitmodules_found, &iter);\n\twhile ((oid = oidset_iter_next(&iter))) {\n\t\tstruct blob *blob;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *buf;\n\n\t\tif (oidset_contains(&gitmodules_done, oid))\n\t\t\tcontinue;\n\n\t\tblob = lookup_blob(oid);\n\t\tif (!blob) {\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = read_sha1_file(oid->hash, &type, &size);\n\t\tif (!buf) {\n\t\t\tif (is_promisor_object(&blob->object.oid))\n\t\t\t\tcontinue;\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\t\t\t\t      \"unable to read .gitmodules blob\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\tret |= fsck_blob(blob, buf, size, options);\n\t\telse\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\tfree(buf);\n\t}\n\n\n\toidset_clear(&gitmodules_found);\n\toidset_clear(&gitmodules_done);\n\treturn ret;\n}\n", "#!/bin/sh\n\ntest_description='check handling of .gitmodule path with dash'\n. ./test-lib.sh\n\ntest_expect_success 'create submodule with dash in path' '\n\tgit init upstream &&\n\tgit -C upstream commit --allow-empty -m base &&\n\tgit submodule add ./upstream sub &&\n\tgit mv sub ./-sub &&\n\tgit commit -m submodule\n'\n\ntest_expect_success 'clone rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit clone --recurse-submodules . dst 2>err &&\n\ttest_i18ngrep ignoring err\n'\n\ntest_expect_success 'fsck rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesPath err\n'\n\ntest_done\n"], "filenames": ["fsck.c", "t/t7417-submodule-path-url.sh"], "buggy_code_start_loc": [67, 19], "buggy_code_end_loc": [954, 19], "fixing_code_start_loc": [68, 20], "fixing_code_end_loc": [962, 28], "type": "CWE-88", "message": "Git before 2.14.5, 2.15.x before 2.15.3, 2.16.x before 2.16.5, 2.17.x before 2.17.2, 2.18.x before 2.18.1, and 2.19.x before 2.19.1 allows remote code execution during processing of a recursive \"git clone\" of a superproject if a .gitmodules file has a URL field beginning with a '-' character.", "other": {"cve": {"id": "CVE-2018-17456", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-06T14:29:00.300", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Git before 2.14.5, 2.15.x before 2.15.3, 2.16.x before 2.16.5, 2.17.x before 2.17.2, 2.18.x before 2.18.1, and 2.19.x before 2.19.1 allows remote code execution during processing of a recursive \"git clone\" of a superproject if a .gitmodules file has a URL field beginning with a '-' character."}, {"lang": "es", "value": "Git en versiones anteriores a la 2.14.5, versiones 2.15.x anteriores a la 2.15.3, versiones 2.16.x anteriores a la 2.16.5, versiones 2.17.x anteriores a la 2.17.2, versiones 2.18.x anteriores a la 2.18.1 y versiones 2.19.x anteriores a la 2.19.1 permite la ejecuci\u00f3n remota de c\u00f3digo durante el procesamiento de un \"clon de git\" recursivo de un superproyecto si un archivo .gitmodules tiene un campo URL que comienza por un car\u00e1cter \"-\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-88"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.14.0", "versionEndExcluding": "2.14.5", "matchCriteriaId": "ED8DE6FB-46B5-4C26-BE2F-55B171323C5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.15.0", "versionEndExcluding": "2.15.3", "matchCriteriaId": "58AFD1CE-ADE0-4051-B106-47B441FF267E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.16.0", "versionEndExcluding": "2.16.5", "matchCriteriaId": "40076AA1-1157-4A18-AF07-D1162A88B715"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.17.0", "versionEndExcluding": "2.17.2", "matchCriteriaId": "D51CF0E9-66B6-44BC-97A0-BDEDA2D82F8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.18.0", "versionEndExcluding": "2.18.1", "matchCriteriaId": "606CCC22-495F-4938-BFA7-30DA28AE0D8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.19.0", "versionEndExcluding": "2.19.1", "matchCriteriaId": "A96BE1EC-5270-4701-AEFB-7B038E204101"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_tower:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A5319543-0143-4E2E-AA77-B7F116C1336C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.7:*:*:*:*:*:*:*", "matchCriteriaId": "84FF61DF-D634-4FB5-8DF1-01F631BE1A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "B99A2411-7F6A-457F-A7BF-EB13C630F902"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "041F9200-4C01-4187-AE34-240E8277B54D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "4EB48767-F095-444F-9E05-D9AC345AB803"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5F6FA12B-504C-4DBF-A32E-0548557AA2ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00003.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/152173/Sourcetree-Git-Arbitrary-Code-Execution-URL-Handling.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/105523", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/107511", "source": "cve@mitre.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1041811", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3408", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3505", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3541", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0316", "source": "cve@mitre.org"}, {"url": "https://github.com/git/git/commit/1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://marc.info/?l=git&m=153875888916397&w=2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Mar/30", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3791-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4311", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45548/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/45631/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.openwall.com/lists/oss-security/2018/10/06/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404"}}