{"buggy_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2010-2021 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * decode_r2007.c: functions to decode R2007 (AC1021) sections\n * written by Till Heuschmann\n * modified by Reini Urban\n */\n\n#define IS_DECODER\n#define _GNU_SOURCE 1 /* for memmem on linux */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"decode.h\"\n#include \"dynapi.h\"\n\n/* The logging level for the read (decode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n#include \"dec_macros.h\"\n#include \"spec.h\"\n\n// only for temp. debugging, to abort on obviously wrong sizes.\n// should be a bit larger then the filesize.\n#define DBG_MAX_COUNT 0x100000\n#define DBG_MAX_SIZE 0xff0000 /* should be dat->size */\n\n/* page map */\ntypedef struct _r2007_page\n{\n  int64_t id;\n  uint64_t size;\n  uint64_t offset;\n  struct _r2007_page *next;\n} r2007_page;\n\n/* section page */\ntypedef struct _r2007_section_page\n{\n  uint64_t offset;\n  uint64_t size;\n  int64_t id;\n  uint64_t uncomp_size; // src_size\n  uint64_t comp_size;\n  uint64_t checksum;\n  uint64_t crc;\n} r2007_section_page;\n\n/* section map */\ntypedef struct _r2007_section\n{\n  uint64_t data_size; // max size of page\n  uint64_t max_size;\n  int64_t encrypted;\n  uint64_t hashcode;   // checksum in r2004\n  int64_t name_length; // 0x22\n  int64_t unknown;     // 0x00\n  int64_t encoded;\n  int64_t num_pages;\n  DWGCHAR *name;\n  Dwg_Section_Type type;\n  r2007_section_page **pages;\n  struct _r2007_section *next;\n} r2007_section;\n\n/* imported */\nint rs_decode_block (BITCODE_RC *blk, int fix);\n\n/* private */\nstatic r2007_section *get_section (r2007_section *sections_map,\n                                   Dwg_Section_Type sec_type);\nstatic r2007_page *get_page (r2007_page *pages_map, int64_t id);\nstatic void pages_destroy (r2007_page *page);\nstatic void sections_destroy (r2007_section *section);\nstatic r2007_section *read_sections_map (Bit_Chain *dat, int64_t size_comp,\n                                         int64_t size_uncomp,\n                                         int64_t correction) ATTRIBUTE_MALLOC;\nstatic int read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map,\n                              Dwg_Section_Type sec_type);\nstatic int read_2007_section_classes (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_header (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                     Dwg_Data *restrict dwg,\n                                     r2007_section *restrict sections_map,\n                                     r2007_page *restrict pages_map);\nstatic int read_2007_section_handles (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_summary (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_preview (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic r2007_page *read_pages_map (Bit_Chain *dat, int64_t size_comp,\n                                   int64_t size_uncomp,\n                                   int64_t correction) ATTRIBUTE_MALLOC;\nstatic int read_file_header (Bit_Chain *restrict dat,\n                             Dwg_R2007_Header *restrict file_header);\nstatic void read_instructions (BITCODE_RC *restrict *restrict src,\n                               BITCODE_RC *restrict opcode,\n                               uint32_t *restrict offset,\n                               uint32_t *restrict length);\nstatic inline BITCODE_RC *copy_bytes_2 (BITCODE_RC *restrict dst,\n                                        const BITCODE_RC *restrict src);\nstatic inline BITCODE_RC *copy_bytes_3 (BITCODE_RC *restrict dst,\n                                        const BITCODE_RC *restrict src);\nstatic void copy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset);\nstatic uint32_t read_literal_length (BITCODE_RC *restrict *restrict src,\n                                     unsigned char opcode);\nstatic void copy_compressed_bytes (BITCODE_RC *restrict dst,\n                                   BITCODE_RC *restrict src, int length);\nstatic BITCODE_RC *decode_rs (const BITCODE_RC *src, int block_count,\n                              int data_size,\n                              const unsigned src_size) ATTRIBUTE_MALLOC;\nstatic int decompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                             BITCODE_RC *restrict src, const unsigned src_size,\n                             const BITCODE_RC *restrict dst_end);\n\n#define copy_1(offset) *dst++ = *(src + offset);\n#define copy_2(offset) dst = copy_bytes_2 (dst, src + offset);\n#define copy_3(offset) dst = copy_bytes_3 (dst, src + offset)\n// 4 and 8 is not reverse, 16 is\n#define copy_n(n, offset)                                                     \\\n  memcpy (dst, &src[offset], n);                                              \\\n  dst += n\n\n#define copy_4(offset) copy_n (4, offset)\n#define copy_8(offset) copy_n (8, offset)\n#define copy_16(offset)                                                       \\\n  memcpy (dst, &src[offset + 8], 8);                                          \\\n  memcpy (&dst[8], &src[offset], 8);                                          \\\n  dst += 16\n\n/* Don't use restrict here: GH #141 broken for most newer compilers */\nstatic inline BITCODE_RC *\ncopy_bytes_2 (BITCODE_RC *dst, const BITCODE_RC *src)\n{\n  dst[0] = src[1];\n  dst[1] = src[0];\n  return dst + 2;\n}\n\nstatic inline BITCODE_RC *\ncopy_bytes_3 (BITCODE_RC *dst, const BITCODE_RC *src)\n{\n  dst[0] = src[2];\n  dst[1] = src[1];\n  dst[2] = src[0];\n  return dst + 3;\n}\n\nstatic void\ncopy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset)\n{\n  BITCODE_RC *src = dst - offset;\n\n  while (length-- > 0)\n    *dst++ = *src++;\n}\n\n/* See spec version 5.0 page 30 */\nstatic void\ncopy_compressed_bytes (BITCODE_RC *restrict dst, BITCODE_RC *restrict src,\n                       int length)\n{\n  while (length >= 32)\n    {\n      copy_16 (16);\n      copy_16 (0);\n\n      src += 32;\n      length -= 32;\n    }\n\n  switch (length)\n    {\n    case 0:\n      break;\n    case 1:\n      copy_1 (0);\n      break;\n    case 2:\n      copy_2 (0);\n      break;\n    case 3:\n      copy_3 (0);\n      break;\n    case 4:\n      copy_4 (0);\n      break;\n    case 5:\n      copy_1 (4);\n      copy_4 (0);\n      break;\n    case 6:\n      copy_1 (5);\n      copy_4 (1);\n      copy_1 (0);\n      break;\n    case 7:\n      copy_2 (5);\n      copy_4 (1);\n      copy_1 (0);\n      break;\n    case 8:\n      copy_8 (0);\n      break;\n    case 9:\n      copy_1 (8);\n      copy_8 (0);\n      break;\n    case 10:\n      copy_1 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 11:\n      copy_2 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 12:\n      copy_4 (8);\n      copy_8 (0);\n      break;\n    case 13:\n      copy_1 (12);\n      copy_4 (8);\n      copy_8 (0);\n      break;\n    case 14:\n      copy_1 (13);\n      copy_4 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 15:\n      copy_2 (13);\n      copy_4 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 16:\n      copy_16 (0);\n      break;\n    case 17:\n      copy_8 (9);\n      copy_1 (8);\n      copy_8 (0);\n      break;\n    case 18:\n      copy_1 (17);\n      copy_16 (1);\n      copy_1 (0);\n      break;\n    case 19:\n      copy_3 (16);\n      copy_16 (0);\n      break;\n    case 20:\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 21:\n      copy_1 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 22:\n      copy_2 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 23:\n      copy_3 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 24:\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 25:\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 26:\n      copy_1 (25);\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 27:\n      copy_2 (25);\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 28:\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 29:\n      copy_1 (28);\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 30:\n      copy_2 (28);\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 31:\n      copy_1 (30);\n      copy_4 (26);\n      copy_8 (18);\n      copy_16 (2);\n      copy_2 (0);\n      break;\n    default:\n      LOG_ERROR (\"Wrong length %d\", length);\n    }\n}\n\n/* See spec version 5.1 page 50 */\nstatic uint32_t\nread_literal_length (BITCODE_RC *restrict *src, unsigned char opcode)\n{\n  uint32_t length = opcode + 8;\n\n  if (length == 0x17)\n    {\n      int n = *(*src)++;\n\n      length += n;\n\n      if (n == 0xff)\n        {\n          do\n            {\n              n = *(*src)++;\n              n |= (*(*src)++ << 8);\n\n              length += n;\n            }\n          while (n == 0xFFFF);\n        }\n    }\n\n  return length;\n}\n\n/* See spec version 5.1 page 53 */\nstatic void\nread_instructions (BITCODE_RC *restrict *src, unsigned char *restrict opcode,\n                   uint32_t *restrict offset, uint32_t *restrict length)\n{\n  switch (*opcode >> 4)\n    {\n    case 0:\n      *length = (*opcode & 0xf) + 0x13;\n      *offset = *(*src)++;\n      *opcode = *(*src)++;\n      *length = ((*opcode >> 3) & 0x10) + *length;\n      *offset = ((*opcode & 0x78) << 5) + 1 + *offset;\n      break;\n\n    case 1:\n      *length = (*opcode & 0xf) + 3;\n      *offset = *(*src)++;\n      *opcode = *(*src)++;\n      *offset = ((*opcode & 0xf8) << 5) + 1 + *offset;\n      break;\n\n    case 2:\n      *offset = *(*src)++;\n      *offset = ((*(*src)++ << 8) & 0xff00) | *offset;\n      *length = *opcode & 7;\n\n      if ((*opcode & 8) == 0)\n        {\n          *opcode = *(*src)++;\n          *length = (*opcode & 0xf8) + *length;\n        }\n      else\n        {\n          (*offset)++;\n          *length = (*(*src)++ << 3) + *length;\n          *opcode = *(*src)++;\n          *length = (((*opcode & 0xf8) << 8) + *length) + 0x100;\n        }\n      break;\n\n    default:\n      *length = *opcode >> 4;\n      *offset = *opcode & 15;\n      *opcode = *(*src)++;\n      *offset = (((*opcode & 0xf8) << 1) + *offset) + 1;\n      break;\n    }\n}\n\n/* par 4.7 Compression, page 32 (same as format 2004)\n   TODO: replace by decompress_R2004_section(dat, decomp, comp_data_size)\n   Note that dst + dst_size might deviate from dst_end.\n*/\nstatic int\ndecompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                  BITCODE_RC *restrict src, const unsigned src_size,\n                  const BITCODE_RC *restrict dst_end)\n{\n  uint32_t length = 0;\n  uint32_t offset = 0;\n\n  BITCODE_RC *dst_start = dst;\n  BITCODE_RC *src_end = src + src_size;\n  unsigned char opcode;\n  if (!dst_end)\n    dst_end = dst + dst_size;\n\n  LOG_INSANE (\"decompress_r2007 (%p, %d, %p, %d)\\n\", dst, dst_size, src,\n              src_size);\n  if (!dst || !src || !dst_size || src_size < 2)\n    {\n      LOG_ERROR (\"Invalid argument to %s\\n\", __FUNCTION__);\n      return DWG_ERR_INTERNALERROR;\n    }\n\n  opcode = *src++;\n  if ((opcode & 0xf0) == 0x20)\n    {\n      src += 2;\n      length = *src++ & 0x07;\n      if (length == 0)\n        {\n          LOG_ERROR (\"Decompression error: zero length\")\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  while (src < src_end)\n    {\n      if (length == 0)\n        length = read_literal_length (&src, opcode);\n\n      if ((dst + length) > dst_end || (src + length) > src_end)\n        {\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n            {\n              if ((dst + length) > dst_end)\n                HANDLER (OUTPUT, \"copy_compressed_bytes: dst %p + %u >= %p\\n\",\n                         dst, (unsigned)length, dst_end);\n              else\n                HANDLER (OUTPUT, \"copy_compressed_bytes: src %p + %u > %p\\n\",\n                         src, (unsigned)length, src_end);\n            }\n          LOG_ERROR (\"Decompression error: length overflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n\n      LOG_INSANE (\n          \"copy_compressed_bytes (%p, %p, %u). remaining src: %ld, dst: %ld\\n\",\n          dst, src, (unsigned)length, (long)(src_end - src),\n          (long)(dst_end - dst));\n      copy_compressed_bytes (dst, src, length);\n\n      dst += length;\n      src += length;\n\n      length = 0;\n\n      if (src >= src_end)\n        return 0;\n\n      opcode = *src++;\n\n      read_instructions (&src, &opcode, &offset, &length);\n\n      while (1)\n        {\n          if ((dst + length) > dst_end)\n            {\n              LOG_HANDLE (\"copy_bytes: dst %p + %u > %p\\n\", dst,\n                          (unsigned)length, dst_end);\n              LOG_ERROR (\"Decompression error: length overflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          if (offset > (uint32_t)(dst - dst_start))\n            {\n              LOG_HANDLE (\"copy_bytes: offset %u > %p - %p\\n\",\n                          (unsigned)offset, dst, dst_start);\n              LOG_ERROR (\"Decompression error: offset underflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          LOG_INSANE (\"copy_bytes (%p, %u, [%u])\\n\", dst, (unsigned)length,\n                      (unsigned)offset);\n          copy_bytes (dst, length, offset);\n\n          dst += length;\n          length = (opcode & 7);\n\n          if (length != 0 || src >= src_end)\n            break;\n\n          opcode = *src++;\n\n          if ((opcode >> 4) == 0)\n            break;\n\n          if ((opcode >> 4) == 0x0f)\n            opcode &= 0xf;\n\n          read_instructions ((unsigned char **)&src, &opcode, &offset,\n                             &length);\n        }\n    }\n  return 0;\n}\n\n// reed-solomon (255, 239) encoding with factor 3\n// TODO: for now disabled, until we get proper data\nATTRIBUTE_MALLOC\nstatic BITCODE_RC *\ndecode_rs (const BITCODE_RC *src, int block_count, int data_size,\n           const unsigned src_size)\n{\n  int i, j;\n  const BITCODE_RC *src_base = src;\n  BITCODE_RC *dst_base, *dst;\n  // TODO: round up data_size from 239 to 255\n\n  if ((size_t)block_count * data_size > src_size)\n    {\n      LOG_ERROR (\"decode_rs src overflow: %ld > %u\",\n                 (long)block_count * data_size, src_size)\n      return NULL;\n    }\n  dst_base = dst = (BITCODE_RC *)calloc (block_count, data_size);\n  if (!dst)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return NULL;\n    }\n\n  for (i = 0; i < block_count; ++i)\n    {\n      for (j = 0; j < data_size; ++j)\n        {\n          *dst++ = *src;\n          src += block_count;\n        }\n\n      // rs_decode_block((unsigned char*)(dst_base + 239*i), 1);\n      src = ++src_base;\n    }\n\n  return dst_base;\n}\n\nstatic bool\nread_system_page (Bit_Chain *out, Bit_Chain *dat, int64_t size_comp,\n                  int64_t size_uncomp, int64_t repeat_count)\n{\n  int i;\n  int error = 0;\n\n  int64_t pesize;      // Pre RS encoded size\n  int64_t block_count; // Number of RS encoded blocks\n  int64_t page_size;\n  long pedata_size;\n\n  BITCODE_RC *rsdata;          // RS encoded data\n  BITCODE_RC *pedata;          // Pre RS encoded data\n  BITCODE_RC *data_end; // The data RS unencoded and uncompressed\n\n  if (repeat_count < 0 || repeat_count > DBG_MAX_COUNT\n      || (uint64_t)size_comp >= dat->size\n      || (uint64_t)size_uncomp >= dat->size)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: \"\n                 \"size_comp: %\" PRId64 \", size_uncomp: %\" PRId64\n                 \", repeat_count: %\" PRId64,\n                 size_comp, size_uncomp, repeat_count);\n      return false;\n    }\n  // Round to a multiple of 8\n  pesize = ((size_comp + 7) & ~7) * repeat_count;\n  // Divide pre encoded size by RS k-value (239)\n  block_count = (pesize + 238) / 239;\n  if (block_count <= 0 || block_count > DBG_MAX_COUNT)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: size_comp: %\" PRId64\n                 \", size_uncomp: %\" PRId64,\n                 size_comp, size_uncomp);\n      return false;\n    }\n  // Multiply with codeword size (255) and round to a multiple of 8\n  page_size = (block_count * 255 + 7) & ~7;\n  if ((uint64_t)page_size >= DBG_MAX_COUNT\n      || (size_t)page_size > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: page_size: %\" PRId64, page_size);\n      return false;\n    }\n  LOG_HANDLE (\"read_system_page: size_comp: %\" PRId64 \", size_uncomp: %\" PRId64\n              \", repeat_count: %\" PRId64 \"\\n\",\n              size_comp, size_uncomp, repeat_count);\n  assert ((uint64_t)size_comp < dat->size);\n  assert ((uint64_t)size_uncomp < dat->size);\n  assert ((uint64_t)repeat_count < DBG_MAX_COUNT);\n  assert ((uint64_t)page_size < DBG_MAX_COUNT);\n  bit_chain_init_dat (out, size_uncomp + page_size, dat);\n  //data = (BITCODE_RC *)calloc (size_uncomp + page_size, 1);\n  LOG_HANDLE (\"Alloc system page of size %\" PRId64 \"\\n\",\n              size_uncomp + page_size)\n    assert (out->size == (size_t)(size_uncomp + page_size));\n  if (!out->chain)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return false;\n    }\n  data_end = &out->chain[size_uncomp + page_size];\n\n  rsdata = &out->chain[size_uncomp];\n  bit_read_fixed (dat, rsdata, page_size);\n  pedata_size = block_count * 239;\n  pedata = decode_rs (rsdata, block_count, 239, page_size);\n  if (!pedata)\n    {\n      bit_chain_free (out);\n      return false;\n    }\n\n  if (size_comp < size_uncomp)\n    error = decompress_r2007 (out->chain, size_uncomp, pedata,\n                              MIN (pedata_size, size_comp), data_end);\n  else\n    {\n      if (out->byte + size_uncomp <= out->size)\n        memcpy (out->chain, pedata, size_uncomp);\n      else\n        {\n          LOG_ERROR (\"data overflow\")\n          error = DWG_ERR_CRITICAL;\n        }\n    }\n\n  free (pedata);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      bit_chain_free (out);\n      return false;\n    }\n  return true;\n}\n\nstatic int\nread_data_page (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                int64_t page_size, int64_t size_comp, int64_t size_uncomp,\n                BITCODE_RC *restrict decomp_end)\n{\n  int i;\n  int error = 0;\n\n  int64_t pesize;      // Pre RS encoded size\n  int64_t block_count; // Number of RS encoded blocks\n\n  BITCODE_RC *rsdata; // RS encoded data\n  BITCODE_RC *pedata; // Pre RS encoded data\n  long pedata_size;\n\n  // Round to a multiple of 8\n  pesize = ((size_comp + 7) & ~7);\n  block_count = (pesize + 0xFB - 1) / 0xFB;\n  pedata_size = block_count * 0xFB;\n\n  rsdata = (BITCODE_RC *)calloc (1, page_size);\n  if (rsdata == NULL)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return DWG_ERR_OUTOFMEM;\n    }\n  bit_read_fixed (dat, rsdata, page_size);\n  pedata = decode_rs (rsdata, block_count, 0xFB, page_size);\n  if (!pedata)\n    {\n      free (rsdata);\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  if (size_comp < size_uncomp)\n    error = decompress_r2007 (decomp, size_uncomp, pedata,\n                              MIN (pedata_size, size_comp), decomp_end);\n  else\n    {\n      if (decomp + size_uncomp <= decomp_end)\n        memcpy (decomp, pedata, size_uncomp);\n      else\n        {\n          LOG_ERROR (\"decomp overflow\")\n          free (pedata);\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  free (pedata);\n  free (rsdata);\n\n  return error;\n}\n\nstatic int\nread_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,\n                   r2007_section *restrict sections_map,\n                   r2007_page *restrict pages_map, Dwg_Section_Type sec_type)\n{\n  r2007_section *section;\n  r2007_page *page;\n  uint64_t max_decomp_size;\n  BITCODE_RC *decomp, *decomp_end;\n  int error = 0, i;\n\n  section = get_section (sections_map, sec_type);\n  sec_dat->chain = NULL;\n  if (section == NULL)\n    {\n      if (sec_type < SECTION_REVHISTORY && sec_type != SECTION_TEMPLATE\n          && sec_type != SECTION_OBJFREESPACE)\n        {\n          LOG_WARN (\"Failed to find section_info[%u]\", (int)sec_type)\n          return DWG_ERR_SECTIONNOTFOUND;\n        }\n      else\n        {\n          LOG_TRACE (\"Found no section_info[%u]\\n\", (int)sec_type)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n    }\n\n  max_decomp_size = section->data_size;\n  if (max_decomp_size > 0x2f000000) // 790Mb\n    {\n      LOG_ERROR (\"Invalid max decompression size %\" PRIu64, max_decomp_size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  decomp = (BITCODE_RC *)calloc (max_decomp_size, 1);\n  if (decomp == NULL)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return DWG_ERR_OUTOFMEM;\n    }\n  decomp_end = &decomp[max_decomp_size];\n  LOG_HANDLE (\"Alloc data section of size %\" PRIu64 \"\\n\", max_decomp_size)\n\n  // sec_dat->chain = decomp;\n  sec_dat->bit = 0;\n  sec_dat->byte = 0;\n  sec_dat->size = max_decomp_size;\n  sec_dat->version = dat->version;\n  sec_dat->from_version = dat->from_version;\n\n  for (i = 0; i < (int)section->num_pages; i++)\n    {\n      r2007_section_page *section_page = section->pages[i];\n      page = get_page (pages_map, section_page->id);\n      if (page == NULL)\n        {\n          free (decomp);\n          LOG_ERROR (\"Failed to find page %d\", (int)section_page->id)\n          return DWG_ERR_PAGENOTFOUND;\n        }\n      if (section_page->offset > max_decomp_size)\n        {\n          free (decomp);\n          LOG_ERROR (\"Invalid section_page->offset %ld > %ld\",\n                     (long)section_page->offset, (long)max_decomp_size)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      if (max_decomp_size < section_page->uncomp_size)\n        {\n          free (decomp);\n          LOG_ERROR (\"Invalid section size %ld < %ld\", (long)max_decomp_size,\n                     (long)section_page->uncomp_size)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      dat->byte = page->offset;\n      // only if compressed. TODO: Isn't there a compressed flag as with 2004+?\n      // theoretically the sizes could still be the same.\n      if (section_page->comp_size != section_page->uncomp_size)\n        {\n          error = read_data_page (dat, &decomp[section_page->offset],\n                                  page->size, section_page->comp_size,\n                                  section_page->uncomp_size, decomp_end);\n          if (error)\n            {\n              free (decomp);\n              LOG_ERROR (\"Failed to read compressed page\")\n              return error;\n            }\n        }\n      else\n        {\n          if (section_page->uncomp_size\n                  > max_decomp_size - section_page->offset\n              || section_page->uncomp_size > dat->size - dat->byte)\n            {\n              free (decomp);\n              LOG_ERROR (\"Invalid section size %ld\",\n                         (long)section_page->uncomp_size);\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          memcpy (&decomp[section_page->offset], &dat->chain[dat->byte],\n                  section_page->uncomp_size);\n        }\n    }\n  sec_dat->chain = decomp;\n  return 0;\n}\n\n#define LOG_POS_DAT(dat)                                \\\n  LOG_INSANE (\" @%zu.%u\", (dat)->byte, (dat)->bit)      \\\n  LOG_TRACE (\"\\n\")\n\nstatic r2007_section *\nread_sections_map (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,\n                   int64_t correction)\n{\n  BITCODE_RC *data;\n  r2007_section *sections = NULL, *last_section = NULL, *section = NULL;\n  //BITCODE_RC *ptr, *ptr_end;\n  Bit_Chain page = { 0 };\n  int i, j = 0;\n\n  if (!read_system_page (&page, dat, size_comp, size_uncomp, correction))\n    {\n      LOG_ERROR (\"Failed to read system page\")\n      return NULL;\n    }\n\n  LOG_TRACE (\"\\n=== System Section (Section Map) ===\\n\");\n  while (page.byte < (size_t)size_uncomp)\n    {\n      section = (r2007_section *)calloc (1, sizeof (r2007_section));\n      if (!section)\n        {\n          LOG_ERROR (\"Out of memory\");\n          bit_chain_free (&page);\n          sections_destroy (sections); // the root\n          return NULL;\n        }\n      LOG_TRACE (\"\\nSection [%d]:\\n\", j);\n      section->data_size = bit_read_RLL (&page);\n      section->max_size = bit_read_RLL (&page);\n      section->encrypted = bit_read_RLL (&page);\n      section->hashcode = bit_read_RLL (&page);\n      section->name_length = bit_read_RLL (&page);\n      section->unknown = bit_read_RLL (&page);\n      section->encoded = bit_read_RLL (&page);\n      section->num_pages = bit_read_RLL (&page);\n      LOG_TRACE (\"  data size:     %\" PRIu64 \"\\n\", section->data_size)\n      LOG_TRACE (\"  max size:      %\" PRIu64 \"\\n\", section->max_size)\n      LOG_TRACE (\"  encryption:    %\" PRIu64 \"\\n\", section->encrypted)\n      LOG_HANDLE (\"  hashcode:      %\" PRIx64 \"\\n\", section->hashcode)\n      LOG_HANDLE (\"  name length:   %\" PRIu64 \"\\n\", section->name_length)\n      LOG_TRACE (\"  unknown:       %\" PRIu64 \"\\n\", section->unknown)\n      LOG_TRACE (\"  encoding:      %\" PRIu64 \"\\n\", section->encoded)\n      LOG_TRACE (\"  num pages:     %\" PRIu64, section->num_pages);\n      LOG_POS_DAT (&page)\n      // debugging sanity\n#if 1\n      /* compressed */\n      if (section->data_size > 10 * dat->size\n          || section->name_length >= (int64_t)dat->size\n          || section->name_length >= 48)\n        {\n          LOG_ERROR (\"Invalid System Section\");\n          free (section);\n          bit_chain_free (&page);\n          sections_destroy (sections); // the root\n          return NULL;\n        }\n        // assert(section->data_size < dat->size + 0x100000);\n        // assert(section->max_size  < dat->size + 0x100000);\n        // assert(section->num_pages < DBG_MAX_COUNT);\n#endif\n      // section->next = NULL;\n      // section->pages = NULL;\n      // section->name = NULL;\n\n      if (!sections)\n        {\n          sections = last_section = section;\n        }\n      else\n        {\n          last_section->next = section;\n          last_section = section;\n        }\n\n      j++;\n      if (page.byte >= page.size)\n        break;\n\n      // Section Name (wchar)\n      {\n        uint64_t sz = section->name_length;\n        section->name = (DWGCHAR *)calloc (1, sz + 2);\n        bit_read_fixed (&page, (BITCODE_RC*)section->name, sz);\n      }\n#ifdef HAVE_NATIVE_WCHAR2\n      LOG_TRACE (\"  name:          \" FORMAT_TU, (BITCODE_TU)section->name)\n#else\n      LOG_TRACE (\"  name:          \")\n      LOG_TEXT_UNICODE (TRACE, section->name)\n#endif\n      LOG_POS_DAT (&page)\n      LOG_TRACE (\"\\n\")\n      section->type = dwg_section_wtype (section->name);\n\n      if (section->num_pages <= 0)\n        continue;\n      if (section->num_pages > 0xf0000)\n        {\n          LOG_ERROR (\"Invalid num_pages %zu, skip\",\n                     (size_t)section->num_pages);\n          continue;\n        }\n\n      section->pages = (r2007_section_page **)calloc (\n          (size_t)section->num_pages, sizeof (r2007_section_page *));\n      if (!section->pages)\n        {\n          LOG_ERROR (\"Out of memory\");\n          bit_chain_free (&page);\n          if (sections)\n            sections_destroy (sections); // the root\n          else\n            sections_destroy (section);\n          return NULL;\n        }\n\n      for (i = 0; i < section->num_pages; i++)\n        {\n          section->pages[i]\n              = (r2007_section_page *)calloc (1, sizeof (r2007_section_page));\n          if (!section->pages[i])\n            {\n              LOG_ERROR (\"Out of memory\");\n              bit_chain_free (&page);\n              if (sections)\n                sections_destroy (sections); // the root\n              else\n                sections_destroy (section);\n              return NULL;\n            }\n\n          if (page.byte + 56 > page.size)\n            {\n              LOG_ERROR (\"Section[%d]->pages[%d] overflow (%zu > %zu)\", j, i,\n                         page.byte + 56, page.size);\n              free (section->pages[i]);\n              section->num_pages = i; // skip this last section\n              break;\n            }\n\n          section->pages[i]->offset = bit_read_RLL (&page);\n          section->pages[i]->size = bit_read_RLL (&page);\n          section->pages[i]->id = (int64_t)bit_read_RLL (&page);\n          section->pages[i]->uncomp_size = bit_read_RLL (&page);\n          section->pages[i]->comp_size = bit_read_RLL (&page);\n          section->pages[i]->checksum = bit_read_RLL (&page);\n          section->pages[i]->crc = bit_read_RLL (&page);\n\n          LOG_TRACE (\" Page[%d]: \", i)\n          LOG_TRACE (\" offset: 0x%07\" PRIx64, section->pages[i]->offset);\n          LOG_TRACE (\" size: %5\" PRIu64, section->pages[i]->size);\n          LOG_TRACE (\" id: %4\" PRId64, section->pages[i]->id);\n          LOG_TRACE (\" uncomp_size: %5\" PRIu64 \"\\n\",\n                     section->pages[i]->uncomp_size);\n          LOG_HANDLE (\" comp_size: %5\" PRIu64, section->pages[i]->comp_size);\n          LOG_HANDLE (\" checksum: %016\" PRIx64, section->pages[i]->checksum);\n          LOG_HANDLE (\" crc64: %016\" PRIx64 \"\\n\", section->pages[i]->crc);\n          // debugging sanity\n          if (section->pages[i]->size >= DBG_MAX_SIZE\n              || section->pages[i]->uncomp_size >= DBG_MAX_SIZE\n              || section->pages[i]->comp_size >= DBG_MAX_SIZE)\n            {\n              LOG_ERROR (\"Invalid section->pages[%d] size\", i);\n              bit_chain_free (&page);\n              free (section->pages[i]);\n              section->num_pages = i; // skip this last section\n              return sections;\n            }\n          assert (section->pages[i]->size < DBG_MAX_SIZE);\n          assert (section->pages[i]->uncomp_size < DBG_MAX_SIZE);\n          assert (section->pages[i]->comp_size < DBG_MAX_SIZE);\n        }\n    }\n\n  bit_chain_free (&page);\n  return sections;\n}\n\nstatic r2007_page *\nread_pages_map (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,\n                int64_t correction)\n{\n  r2007_page *pages = NULL, *last_page = NULL, *page;\n  int64_t offset = 0x480; // dat->byte;\n  Bit_Chain sdat = { 0 };\n  // int64_t index;\n\n  if (!read_system_page (&sdat, dat, size_comp, size_uncomp, correction))\n    {\n      LOG_ERROR (\"Failed to read system page\")\n      return NULL;\n    }\n  LOG_TRACE (\"\\n=== System Section (Pages Map) ===\\n\")\n  while (sdat.byte < (size_t)size_uncomp)\n    {\n      page = (r2007_page *)malloc (sizeof (r2007_page));\n      if (page == NULL)\n        {\n          LOG_ERROR (\"Out of memory\")\n          bit_chain_free (&sdat);\n          pages_destroy (pages);\n          return NULL;\n        }\n      if (sdat.byte + 16 > sdat.size)\n        {\n          LOG_ERROR (\"Page out of bounds\")\n          bit_chain_free (&sdat);\n          pages_destroy (pages);\n          return NULL;\n        }\n      page->size = bit_read_RLL (&sdat);\n      page->id = (int64_t)bit_read_RLL (&sdat);\n      page->offset = offset;\n      offset += page->size;\n\n      // index = page->id > 0 ? page->id : -page->id;\n      LOG_TRACE (\"Page [%3\" PRId64 \"]: \", page->id)\n      LOG_TRACE (\"size: %6\" PRIu64 \" \", page->size)\n      LOG_TRACE (\"offset: 0x%\" PRIx64 \" \\n\", page->offset)\n\n      page->next = NULL;\n\n      if (pages == NULL)\n        pages = last_page = page;\n      else\n        {\n          last_page->next = page;\n          last_page = page;\n        }\n    }\n  bit_chain_free (&sdat);\n  return pages;\n}\n\n/* Lookup a page in the page map. The page is identified by its id.\n */\nstatic r2007_page *\nget_page (r2007_page *pages_map, int64_t id)\n{\n  r2007_page *page = pages_map;\n\n  while (page != NULL)\n    {\n      if (page->id == id)\n        break;\n      page = page->next;\n    }\n\n  return page;\n}\n\nstatic void\npages_destroy (r2007_page *page)\n{\n  r2007_page *next;\n\n  while (page != 0)\n    {\n      next = page->next;\n      free (page);\n      page = next;\n    }\n}\n\n/* Lookup a section in the section map.\n * The section is identified by its numeric type.\n */\nstatic r2007_section *\nget_section (r2007_section *sections_map, Dwg_Section_Type sec_type)\n{\n  r2007_section *section = sections_map;\n  while (section != NULL)\n    {\n      if (section->type == sec_type)\n        break;\n      section = section->next;\n    }\n\n  return section;\n}\n\nstatic void\nsections_destroy (r2007_section *section)\n{\n  r2007_section *next;\n\n  while (section != 0)\n    {\n      next = section->next;\n\n      if (section->pages)\n        {\n          while (section->num_pages-- > 0)\n            {\n              free (section->pages[section->num_pages]);\n            }\n          free (section->pages);\n        }\n\n      if (section->name)\n        free (section->name);\n\n      free (section);\n      section = next;\n    }\n}\n\nstatic int\nread_file_header (Bit_Chain *restrict dat,\n                  Dwg_R2007_Header *restrict file_header)\n{\n  BITCODE_RC data[0x3d8]; // 0x400 - 5 long\n  BITCODE_RC *pedata;\n  uint64_t seqence_crc;\n  uint64_t seqence_key;\n  uint64_t compr_crc;\n  int32_t compr_len, len2;\n  int i;\n  int error = 0, errcount = 0;\n  const int pedata_size = 3 * 239; // size of pedata\n\n  dat->byte = 0x80;\n  LOG_TRACE (\"\\n=== r2007 File header ===\\n\")\n  memset (file_header, 0, sizeof (Dwg_R2007_Header));\n  memset (data, 0, 0x3d8);\n  bit_read_fixed (dat, data, 0x3d8);\n  pedata = decode_rs (data, 3, 239, 0x3d8);\n  if (!pedata)\n    return DWG_ERR_OUTOFMEM;\n\n  seqence_crc = le64toh (*((uint64_t *)pedata));\n  seqence_key = le64toh (*((uint64_t *)&pedata[8]));\n  compr_crc = le64toh (*((uint64_t *)&pedata[16]));\n  compr_len = le32toh (*((int32_t *)&pedata[24]));\n  len2 = le32toh (*((int32_t *)&pedata[28]));\n  LOG_TRACE (\"seqence_crc64: %016\" PRIX64 \"\\n\", seqence_crc);\n  LOG_TRACE (\"seqence_key:   %016\" PRIX64 \"\\n\", seqence_key);\n  LOG_TRACE (\"compr_crc64:   %016\" PRIX64 \"\\n\", compr_crc);\n  LOG_TRACE (\"compr_len:     %d\\n\", (int)compr_len); // only this is used\n  LOG_TRACE (\"len2:          %d\\n\", (int)len2);      // 0 when compressed\n\n  if (compr_len > 0)\n    error = decompress_r2007 ((BITCODE_RC *)file_header,\n                              sizeof (Dwg_R2007_Header), &pedata[32],\n                              MIN (compr_len, pedata_size - 32), NULL);\n  else\n    memcpy (file_header, &pedata[32], sizeof (Dwg_R2007_Header));\n\n#ifdef WORDS_BIGENDIAN\n  {\n    uint64_t *fields  = (uint64_t *)file_header;\n    for (unsigned j = 0; j < sizeof (Dwg_R2007_Header) / 8; j++)\n      {\n        fields[j] = le64toh (fields[j]);\n      }\n  }\n#endif\n\n  // check validity, for debugging only\n  if (!error)\n    {\n\n#define VALID_SIZE(var)                                                       \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_SIZE\", __FUNCTION__, #var,          \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n#define VALID_COUNT(var)                                                      \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_COUNT\", __FUNCTION__, #var,         \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n\n      VALID_SIZE (file_header->header_size);\n      VALID_SIZE (file_header->file_size);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->header2_offset);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->pages_map_size_comp);\n      VALID_SIZE (file_header->pages_map_size_uncomp);\n      VALID_COUNT (file_header->pages_maxid);\n      VALID_COUNT (file_header->pages_amount);\n      VALID_COUNT (file_header->num_sections);\n    }\n\n  free (pedata);\n  return error;\n}\n\n/* Return the latest dat position for all three independent streams\n   data, handle and string.\n*/\nsize_t\nobj_stream_position (Bit_Chain *restrict dat, Bit_Chain *restrict hdl_dat,\n                     Bit_Chain *restrict str_dat)\n{\n  size_t p1 = bit_position (dat);\n  /* all 3 now relative to obj */\n  size_t p2 = bit_position (hdl_dat);\n  SINCE (R_2007)\n  { // but only since 2007 there is a separate string stream\n    size_t p3 = bit_position (str_dat);\n    if (p2 > p1)\n      return p3 > p2 ? p3 : p2;\n    else\n      return p3 > p1 ? p3 : p1;\n  }\n  else\n  {\n    return (p2 > p1) ? p2 : p1;\n  }\n}\n\nint\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  size_t old_size;                     // in byte\n  size_t old_byte;\n  // assert (dat != str); // r2007 objects are the same, just entities not\n  old_size = str->size;\n  old_byte = str->byte;\n\n  // str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_set_position (str, start);\n\n  if (str->byte > old_size - old_byte)\n    {\n      LOG_ERROR (\"obj_string_stream overflow, bitsize \" FORMAT_RL\n                 \" => \" FORMAT_RL \" (strpos %zu > diff %zu)\",\n                 obj->bitsize, obj->size * 8, str->byte, old_size - old_byte);\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      obj->bitsize = obj->size * 8;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\" obj string stream +\" FORMAT_RL \": @%zu.%u (%zu)\", start,\n              str->byte, str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\" has_strings: %d\\n\", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\" @%zu.%u\", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\" data_size: %u/0x%x [RS]\", (unsigned)data_size,\n              (unsigned)data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      LOG_HANDLE (\" @%zu.%u\", str->byte, str->bit & 7);\n      hi_size = bit_read_RS (str);\n      LOG_HANDLE (\" hi_size \" FORMAT_RS \"/\" FORMAT_RSx \" [RS]\", hi_size,\n                  hi_size);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\" => data_size: %u/0x%x\\n\", (unsigned)data_size,\n                  (unsigned)data_size);\n      // LOG_TRACE(\"  -33: @%zu\\n\", str->byte);\n    }\n  else\n    LOG_HANDLE (\"\\n\");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\"Invalid string stream data_size %u > bitsize %u at @%zu.%u\\n\",\n                (unsigned)data_size, (unsigned)obj->bitsize, str->byte,\n                str->bit & 7);\n      if (dat->from_version == R_2007)\n        {\n          return 0;\n        }\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  if (data_size < obj->bitsize)\n    {\n      obj->stringstream_size = data_size;\n      bit_advance_position (str, -(int)data_size);\n    }\n  else\n    {\n      bit_set_position (str, 0);\n    }\n  // bit_reset_chain (str);\n  // LOG_TRACE(\" %d: @%zu.%u (%zu)\\n\", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}\n\nvoid\nsection_string_stream (Dwg_Data *restrict dwg, Bit_Chain *restrict dat,\n                       BITCODE_RL bitsize, Bit_Chain *restrict str)\n{\n  BITCODE_RL start;     // in bits\n  BITCODE_RL data_size; // in bits\n  BITCODE_B endbit;\n  if (dwg->header.version < R_2010\n      || (dwg->header.version == R_2010 && dwg->header.maint_version < 3))\n    {\n      // r2007: + 24 bytes (sentinel+size+hsize) - 1 bit (endbit)\n      start = bitsize + 159;\n    }\n  else\n    {\n      // r2010: + 24 bytes (sentinel+size+hSize) - 1 bit (endbit)\n      start = bitsize + 191; /* 8*24 = 192 */\n    }\n  *str = *dat;\n  bit_set_position (str, start);\n  LOG_TRACE (\"section string stream\\n  pos: \" FORMAT_RL \", %zu/%u\\n\", start,\n             str->byte, str->bit);\n  endbit = bit_read_B (str);\n  LOG_HANDLE (\"  endbit: %d\\n\", (int)endbit);\n  if (!endbit)\n    return; // i.e. has no strings. without data_size should be 0\n  start -= 16;\n  bit_set_position (str, start);\n  LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu\\n\", start, str->byte);\n  // str->bit = start & 7;\n  data_size = bit_read_RS (str);\n  LOG_HANDLE (\"  data_size: \" FORMAT_RL \"\\n\", data_size);\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      start -= 16;\n      data_size &= 0x7FFF;\n      bit_set_position (str, start);\n      LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu\\n\", start, str->byte);\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"  hi_size: \" FORMAT_RS \", data_size: \" FORMAT_RL \"\\n\",\n                  hi_size, data_size);\n    }\n  start -= data_size;\n  bit_set_position (str, start);\n  LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu/%u\\n\", start, str->byte, str->bit);\n}\n\n// for string stream see p86\nstatic int\nread_2007_section_classes (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  BITCODE_RL size, i;\n  BITCODE_BS max_num;\n  Bit_Chain sec_dat = { 0 }, str = { 0 };\n  Dwg_Object *obj = NULL;\n  int error;\n  char c;\n\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_CLASSES);\n  if (error)\n    {\n      LOG_ERROR (\"Failed to read class section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN)))\n    {\n      BITCODE_RL bitsize = 0;\n      LOG_TRACE (\"\\nClasses\\n-------------------\\n\")\n      size = bit_read_RL (&sec_dat); // size of class data area\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", size)\n      /*\n      if (dat->from_version >= R_2010 && dwg->header.maint_version > 3)\n        {\n          BITCODE_RL hsize = bit_read_RL(&sec_dat);\n          LOG_TRACE(\"hsize: \" FORMAT_RL \" [RL]\\n\", hsize)\n        }\n      */\n      if (dat->from_version >= R_2007)\n        {\n          bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", bitsize)\n        }\n      max_num = bit_read_BS (&sec_dat); // Maximum class number\n      LOG_TRACE (\"max_num: \" FORMAT_BS \" [BS]\\n\", max_num)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_B (&sec_dat); // 1\n      LOG_HANDLE (\"c: \" FORMAT_B \" [B]\\n\", c);\n\n      dwg->layout_type = 0;\n      dwg->num_classes = max_num - 499;\n      if (max_num < 500 || max_num > 5000)\n        {\n          LOG_ERROR (\"Invalid max class number %d\", max_num)\n          dwg->num_classes = 0;\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      assert (max_num >= 500);\n      assert (max_num < 5000);\n\n      section_string_stream (dwg, &sec_dat, bitsize, &str);\n\n      dwg->dwg_class\n          = (Dwg_Class *)calloc (dwg->num_classes, sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_OUTOFMEM;\n        }\n\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          dwg->dwg_class[i].number = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].proxyflag = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].appname = (char *)bit_read_TU (&str);\n          dwg->dwg_class[i].cppname = (char *)bit_read_TU (&str);\n          dwg->dwg_class[i].dxfname_u = bit_read_TU (&str);\n          dwg->dwg_class[i].is_zombie = bit_read_B (&sec_dat); // DXF 280\n          // DXF 281, is_entity is 0x1f3\n          dwg->dwg_class[i].item_class_id = bit_read_BS (&sec_dat);\n\n          dwg->dwg_class[i].num_instances = bit_read_BL (&sec_dat); // DXF 91\n          dwg->dwg_class[i].dwg_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].maint_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat); // 0\n          dwg->dwg_class[i].unknown_2 = bit_read_BL (&sec_dat); // 0\n\n          LOG_TRACE (\"-------------------\\n\")\n          LOG_TRACE (\"Number:           %d\\n\", dwg->dwg_class[i].number)\n          LOG_TRACE (\"Proxyflag:        0x%x\\n\", dwg->dwg_class[i].proxyflag)\n          dwg_log_proxyflag (DWG_LOGLEVEL, DWG_LOGLEVEL_TRACE,\n                             dwg->dwg_class[i].proxyflag);\n          LOG_TRACE_TU (\"Application name\", dwg->dwg_class[i].appname, 0)\n          LOG_TRACE_TU (\"C++ class name  \", dwg->dwg_class[i].cppname, 0)\n          LOG_TRACE_TU (\"DXF record name \", dwg->dwg_class[i].dxfname_u, 0)\n          LOG_TRACE (\"Class ID:         0x%x \"\n                     \"(0x1f3 for object, 0x1f2 for entity)\\n\",\n                     dwg->dwg_class[i].item_class_id)\n          LOG_TRACE (\"instance count:   %u\\n\", dwg->dwg_class[i].num_instances)\n          LOG_TRACE (\"dwg version:      %u (%u)\\n\",\n                     dwg->dwg_class[i].dwg_version,\n                     dwg->dwg_class[i].maint_version)\n          LOG_HANDLE (\"unknown:          %u %u\\n\", dwg->dwg_class[i].unknown_1,\n                      dwg->dwg_class[i].unknown_2)\n\n          dwg->dwg_class[i].dxfname\n              = bit_convert_TU (dwg->dwg_class[i].dxfname_u);\n          if (dwg->dwg_class[i].dxfname\n              && strEQc (dwg->dwg_class[i].dxfname, \"LAYOUT\"))\n            dwg->layout_type = dwg->dwg_class[i].number;\n        }\n    }\n  else\n    {\n      LOG_ERROR (\"Failed to find class section sentinel\");\n      free (sec_dat.chain);\n      return DWG_ERR_CLASSESNOTFOUND;\n    }\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n\n  return 0;\n}\n\nstatic int\nread_2007_section_header (Bit_Chain *restrict dat, Bit_Chain *restrict hdl_dat,\n                          Dwg_Data *restrict dwg,\n                          r2007_section *restrict sections_map,\n                          r2007_page *restrict pages_map)\n{\n  Bit_Chain sec_dat = { 0 }, str_dat = { 0 };\n  int error;\n  LOG_TRACE (\"\\nSection Header\\n-------------------\\n\");\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_HEADER);\n  if (error)\n    {\n      LOG_ERROR (\"Failed to read header section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n  if (bit_search_sentinel (&sec_dat,\n                           dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN)))\n    {\n      BITCODE_RL endbits = 160; // start bit: 16 sentinel + 4 size\n      dwg->header_vars.size = bit_read_RL (&sec_dat);\n      LOG_TRACE (\"size: \" FORMAT_RL \"\\n\", dwg->header_vars.size);\n      *hdl_dat = sec_dat;\n      // unused: later versions re-use the 2004 section format\n      /*\n      if (dat->from_version >= R_2010 && dwg->header.maint_version > 3)\n        {\n          dwg->header_vars.bitsize_hi = bit_read_RL(&sec_dat);\n          LOG_TRACE(\"bitsize_hi: \" FORMAT_RL \" [RL]\\n\",\n      dwg->header_vars.bitsize_hi) endbits += 32;\n        }\n      */\n      if (dat->from_version == R_2007) // always true so far\n        {\n          dwg->header_vars.bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\",\n                     dwg->header_vars.bitsize);\n          endbits += dwg->header_vars.bitsize;\n          bit_set_position (hdl_dat, endbits);\n          section_string_stream (dwg, &sec_dat, dwg->header_vars.bitsize,\n                                 &str_dat);\n        }\n\n      dwg_decode_header_variables (&sec_dat, hdl_dat, &str_dat, dwg);\n    }\n  else\n    {\n      DEBUG_HERE;\n      error = DWG_ERR_SECTIONNOTFOUND;\n    }\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n\n  return error;\n}\n\nstatic int\nread_2007_section_handles (Bit_Chain *dat, Bit_Chain *hdl,\n                           Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain obj_dat = { 0 }, hdl_dat = { 0 };\n  BITCODE_RS section_size = 0;\n  size_t endpos;\n  int error;\n\n  error = read_data_section (&obj_dat, dat, sections_map, pages_map,\n                             SECTION_OBJECTS);\n  if (error >= DWG_ERR_CRITICAL || !obj_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read objects section\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nHandles\\n-------------------\\n\")\n  error = read_data_section (&hdl_dat, dat, sections_map, pages_map,\n                             SECTION_HANDLES);\n  if (error >= DWG_ERR_CRITICAL || !hdl_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read handles section\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      if (hdl_dat.chain)\n        free (hdl_dat.chain);\n      return error;\n    }\n\n  /* From here on the same code as in decode:read_2004_section_handles */\n  endpos = hdl_dat.byte + hdl_dat.size;\n  dwg->num_objects = 0;\n\n  do\n    {\n      size_t last_offset;\n      // uint64_t last_handle;\n      size_t oldpos = 0;\n      size_t startpos = hdl_dat.byte;\n      uint16_t crc1, crc2;\n\n      section_size = bit_read_RS_BE (&hdl_dat);\n      LOG_TRACE (\"\\nSection size: %u\\n\", section_size);\n      if (section_size > 2050)\n        {\n          LOG_ERROR (\"Object-map/handles section size greater than 2050!\");\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      last_offset = 0;\n      while ((long)(hdl_dat.byte - startpos) < (long)section_size)\n        {\n          int added;\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n\n          oldpos = hdl_dat.byte;\n          handleoff = bit_read_UMC (&hdl_dat);\n          offset = bit_read_MC (&hdl_dat);\n          last_offset += offset;\n          LOG_TRACE (\"\\nNext object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_TRACE (\"Handleoff: \" FORMAT_UMC \" [UMC] \"\n                     \"Offset: \" FORMAT_MC \" [MC] @%zu\\n\",\n                     handleoff, offset, last_offset)\n\n          if (hdl_dat.byte == oldpos)\n            break;\n\n          added = dwg_decode_add_object (dwg, &obj_dat, hdl, last_offset);\n          if (added > 0)\n            error |= added;\n        }\n\n      if (hdl_dat.byte == oldpos)\n        break;\n#if 0\n      if (!bit_check_CRC(&hdl_dat, startpos, 0xC0C1))\n        LOG_WARN(\"Handles section CRC mismatch at offset %lx\", startpos);\n#else\n      crc1 = bit_calc_CRC (0xC0C1, &(hdl_dat.chain[startpos]),\n                           hdl_dat.byte - startpos);\n      crc2 = bit_read_RS_BE (&hdl_dat);\n      if (crc1 == crc2)\n        {\n          LOG_INSANE (\"Handles section page CRC: %04X from %zx-%zx\\n\", crc2,\n                      startpos, hdl_dat.byte - 2);\n        }\n      else\n        {\n          LOG_WARN (\"Handles section page CRC mismatch: %04X vs calc. %04X \"\n                    \"from %zx-%zx\\n\",\n                    crc2, crc1, startpos, hdl_dat.byte - 2);\n          error |= DWG_ERR_WRONGCRC;\n        }\n#endif\n\n      if (hdl_dat.byte >= endpos)\n        break;\n    }\n  while (section_size > 2);\n\n  if (hdl_dat.chain)\n    free (hdl_dat.chain);\n  if (obj_dat.chain)\n    free (obj_dat.chain);\n  return error;\n}\n\n/* VBAProject Section\n */\nstatic int\nread_2007_section_vbaproject (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_VBAProject *_obj = &dwg->vbaproject;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  // BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_VBAPROJECT);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"VBAProject\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nVBAProject (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  DEBUG_HERE\n  _obj->size = dat->size & 0xFFFFFFFF;\n  _obj->unknown_bits = bit_read_TF (dat, _obj->size);\n  LOG_TRACE_TF (_obj->unknown_bits, _obj->size)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2007_section_summary (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain old_dat, sec_dat = { 0 };\n  Bit_Chain *str_dat;\n  Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  int error;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  old_dat = *dat;\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SUMMARYINFO);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read SummaryInfo section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.summaryinfo_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"summaryinfo_address mismatch: \" FORMAT_RL \" != %zu\",\n              dwg->header.summaryinfo_address, dat->byte);\n  LOG_TRACE (\"\\nSummaryInfo (%zu)\\n-------------------\\n\", sec_dat.size)\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* AppInfo Section\n */\nstatic int\nread_2007_section_appinfo (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  Bit_Chain *str_dat;\n  Dwg_AppInfo *_obj = &dwg->appinfo;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_APPINFO);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AppInfo\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAppInfo (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"appinfo.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* AuxHeader Section\n */\nstatic int\nread_2007_section_auxheader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                             r2007_section *restrict sections_map,\n                             r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_AuxHeader *_obj = &dwg->auxheader;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL vcount = 0, rcount1 = 0, rcount2 = 0;\n\n  // type: 2, compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_AUXHEADER);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AuxHeader\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAuxHeader (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"auxheader.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* Unknown AppInfoHistory Section\n */\nstatic int\nread_2007_section_appinfohistory (Bit_Chain *restrict dat,\n                                  Dwg_Data *restrict dwg,\n                                  r2007_section *restrict sections_map,\n                                  r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  // BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x580\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_APPINFOHISTORY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AppInfoHistory\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAppInfoHistory (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  DEBUG_HERE\n  _obj->size = dat->size & 0xFFFFFFFF;\n  _obj->unknown_bits = bit_read_TF (dat, _obj->size);\n  LOG_TRACE_TF (_obj->unknown_bits, _obj->size)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* RevHistory Section\n */\nstatic int\nread_2007_section_revhistory (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_RevHistory *_obj = &dwg->revhistory;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_REVHISTORY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"RevHistory\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nRevHistory (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"revhistory.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* ObjFreeSpace Section\n */\nstatic int\nread_2007_section_objfreespace (Bit_Chain *restrict dat,\n                                Dwg_Data *restrict dwg,\n                                r2007_section *restrict sections_map,\n                                r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_ObjFreeSpace *_obj = &dwg->objfreespace;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_OBJFREESPACE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"ObjFreeSpace\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nObjFreeSpace (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"objfreespace.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* Template Section. Optional r13-r15, mandatory r18+.\n   Contains the MEASUREMENT variable (0 = English, 1 = Metric).\n */\nstatic int\nread_2007_section_template (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                            r2007_section *restrict sections_map,\n                            r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_Template *_obj = &dwg->Template;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_TEMPLATE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"%s section not found\\n\", \"Template\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error | DWG_ERR_SECTIONNOTFOUND;\n    }\n\n  LOG_TRACE (\"\\nTemplate (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"template.spec\"\n  // clang-format on\n\n  dwg->header_vars.MEASUREMENT = _obj->MEASUREMENT;\n  LOG_TRACE (\"HEADER.MEASUREMENT: \" FORMAT_BS \" (0 English/1 Metric)\\n\",\n             dwg->header_vars.MEASUREMENT)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* r21 FileDepList Section\n */\nstatic int\nread_2007_section_filedeplist (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                               r2007_section *restrict sections_map,\n                               r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  Dwg_FileDepList *_obj = &dwg->filedeplist;\n  Dwg_Object *obj = NULL;\n  BITCODE_BL vcount;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80. 0xc or 0xd\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_FILEDEPLIST);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"FileDepList\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"FileDepList (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"filedeplist.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* r21 Security Section, if saved with password\n */\nstatic int\nread_2007_section_security (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                            r2007_section *restrict sections_map,\n                            r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  Dwg_Security *_obj = &dwg->security;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SECURITY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"Security\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"Security (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"security.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n#if 0\n/* Signature Section, not written nor documented by Teigha\n */\nstatic int\nread_2007_section_signature (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  struct Dwg_Signature *_obj = &dwg->signature;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SIGNATURE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"Signature\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"Signature (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  // clang-format off\n  #include \"signature.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n#endif\n\nstatic int\nacds_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain *str_dat = dat;\n  Dwg_AcDs *_obj = &dwg->acds;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_BL rcount1 = 0, rcount2 = 0;\n  BITCODE_BL rcount3 = 0, rcount4, vcount;\n\n// clang-format off\n  #include \"acds.spec\"\n  // clang-format on\n\n  return error;\n}\n\n/* r2013+ datastorage Section, if saved with binary ACIS SAB data\n */\nstatic int\nread_2007_section_acds (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                        r2007_section *restrict sections_map,\n                        r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  const char *secname = \"AcDsPrototype_1b\";\n  Dwg_AcDs *_obj = &dwg->acds;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, pagesize 0x7400, type 13\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_ACDS);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", secname);\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"AcDs datastorage (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  error |= acds_private (dat, dwg);\n  error &= ~DWG_ERR_SECTIONNOTFOUND;\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2007_section_preview (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain sec_dat = { 0 };\n  int error;\n  BITCODE_RL size;\n  BITCODE_RC type;\n  const unsigned char *sentinel;\n\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_PREVIEW);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"Preview\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.thumbnail_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"thumbnail_address mismatch: \" FORMAT_RL \" != %zu\",\n              dwg->header.thumbnail_address, dat->byte);\n  LOG_TRACE (\"\\nPreview (%zu)\\n-------------------\\n\", sec_dat.size)\n  if (!sec_dat.chain || sec_dat.size < 32)\n    {\n      LOG_WARN (\"Empty thumbnail\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  sentinel = dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN);\n  if (memcmp (sentinel, sec_dat.chain, 16))\n    {\n      LOG_WARN (\"thumbnail sentinel mismatch\");\n      return error |= DWG_ERR_WRONGCRC;\n    }\n\n  assert (sec_dat.size >= 32);\n  assert (sec_dat.chain);\n  dwg->thumbnail.size = sec_dat.size - 32; // 2x sentinel\n  dwg->thumbnail.chain = sec_dat.chain;\n  dwg->thumbnail.byte = 16; // sentinel\n\n  dwg_bmp (dwg, &size, &type);\n  if (abs ((int)((long)size - (long)dwg->thumbnail.size))\n      > 200) // various headers\n    LOG_WARN (\"thumbnail.size mismatch: %zu != \" FORMAT_RL,\n              dwg->thumbnail.size, size);\n\n  dat->byte += dwg->thumbnail.size;\n\n  return error;\n}\n\n/* exported */\nvoid\nread_r2007_init (Dwg_Data *restrict dwg)\n{\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n}\n\nint\nread_r2007_meta_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                      Dwg_Data *restrict dwg)\n{\n  Dwg_R2007_Header *file_header;\n  r2007_page *restrict pages_map = NULL, *restrict page;\n  r2007_section *restrict sections_map = NULL;\n  int error;\n#ifdef USE_TRACING\n  char *probe;\n#endif\n\n  read_r2007_init (dwg);\n#ifdef USE_TRACING\n  probe = getenv (\"LIBREDWG_TRACE\");\n  if (probe)\n    loglevel = atoi (probe);\n#endif\n  // @ 0x62\n  error = read_file_header (dat, &dwg->r2007_file_header);\n  if (error >= DWG_ERR_VALUEOUTOFBOUNDS)\n    return error;\n  file_header = &dwg->r2007_file_header;\n\n  // Pages Map\n  dat->byte += 0x28; // overread check data\n  dat->byte += file_header->pages_map_offset;\n  if ((size_t)file_header->pages_map_size_comp > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid pages_map_size_comp %zu > %zu bytes left\",\n                 __FUNCTION__, (size_t)file_header->pages_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  pages_map = read_pages_map (dat, file_header->pages_map_size_comp,\n                              file_header->pages_map_size_uncomp,\n                              file_header->pages_map_correction);\n  if (!pages_map)\n    return DWG_ERR_PAGENOTFOUND; // Error already logged\n\n  // Sections Map\n  page = get_page (pages_map, file_header->sections_map_id);\n  if (!page)\n    {\n      LOG_ERROR (\"Failed to find sections page map %d\",\n                 (int)file_header->sections_map_id);\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto error;\n    }\n  dat->byte = page->offset;\n  if ((size_t)file_header->sections_map_size_comp > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid comp_data_size %\" PRId64 \" > %zu bytes left\",\n                 __FUNCTION__, file_header->sections_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  sections_map = read_sections_map (dat, file_header->sections_map_size_comp,\n                                    file_header->sections_map_size_uncomp,\n                                    file_header->sections_map_correction);\n  if (!sections_map)\n    goto error;\n\n  error\n      = read_2007_section_header (dat, hdl_dat, dwg, sections_map, pages_map);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2007_section_summary (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_classes (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_handles (dat, hdl_dat, dwg, sections_map,\n                                      pages_map);\n  error |= read_2007_section_auxheader (dat, dwg, sections_map, pages_map);\n  if (dwg->header.thumbnail_address)\n    error |= read_2007_section_preview (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfo (dat, dwg, sections_map, pages_map);\n  error\n      |= read_2007_section_appinfohistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_filedeplist (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_security (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_revhistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_objfreespace (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_template (dat, dwg, sections_map, pages_map);\n  if (dwg->header.vbaproj_address)\n    error |= read_2007_section_vbaproject (dat, dwg, sections_map, pages_map);\n  // error |= read_2007_section_signature (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_acds (dat, dwg, sections_map, pages_map);\n  // read_2007_blocks (dat, hdl_dat, dwg, sections_map, pages_map);\n\nerror:\n  pages_destroy (pages_map);\n  if (sections_map)\n    sections_destroy (sections_map);\n\n  return error;\n}\n"], "fixing_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2010-2021 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * decode_r2007.c: functions to decode R2007 (AC1021) sections\n * written by Till Heuschmann\n * modified by Reini Urban\n */\n\n#define IS_DECODER\n#define _GNU_SOURCE 1 /* for memmem on linux */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"decode.h\"\n#include \"dynapi.h\"\n\n/* The logging level for the read (decode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n#include \"dec_macros.h\"\n#include \"spec.h\"\n\n// only for temp. debugging, to abort on obviously wrong sizes.\n// should be a bit larger then the filesize.\n#define DBG_MAX_COUNT 0x100000\n#define DBG_MAX_SIZE 0xff0000 /* should be dat->size */\n\n/* page map */\ntypedef struct _r2007_page\n{\n  int64_t id;\n  uint64_t size;\n  uint64_t offset;\n  struct _r2007_page *next;\n} r2007_page;\n\n/* section page */\ntypedef struct _r2007_section_page\n{\n  uint64_t offset;\n  uint64_t size;\n  int64_t id;\n  uint64_t uncomp_size; // src_size\n  uint64_t comp_size;\n  uint64_t checksum;\n  uint64_t crc;\n} r2007_section_page;\n\n/* section map */\ntypedef struct _r2007_section\n{\n  uint64_t data_size; // max size of page\n  uint64_t max_size;\n  int64_t encrypted;\n  uint64_t hashcode;   // checksum in r2004\n  int64_t name_length; // 0x22\n  int64_t unknown;     // 0x00\n  int64_t encoded;\n  int64_t num_pages;\n  DWGCHAR *name;\n  Dwg_Section_Type type;\n  r2007_section_page **pages;\n  struct _r2007_section *next;\n} r2007_section;\n\n/* imported */\nint rs_decode_block (BITCODE_RC *blk, int fix);\n\n/* private */\nstatic r2007_section *get_section (r2007_section *sections_map,\n                                   Dwg_Section_Type sec_type);\nstatic r2007_page *get_page (r2007_page *pages_map, int64_t id);\nstatic void pages_destroy (r2007_page *page);\nstatic void sections_destroy (r2007_section *section);\nstatic r2007_section *read_sections_map (Bit_Chain *dat, int64_t size_comp,\n                                         int64_t size_uncomp,\n                                         int64_t correction) ATTRIBUTE_MALLOC;\nstatic int read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map,\n                              Dwg_Section_Type sec_type);\nstatic int read_2007_section_classes (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_header (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                     Dwg_Data *restrict dwg,\n                                     r2007_section *restrict sections_map,\n                                     r2007_page *restrict pages_map);\nstatic int read_2007_section_handles (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_summary (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic int read_2007_section_preview (Bit_Chain *restrict dat,\n                                      Dwg_Data *restrict dwg,\n                                      r2007_section *restrict sections_map,\n                                      r2007_page *restrict pages_map);\nstatic r2007_page *read_pages_map (Bit_Chain *dat, int64_t size_comp,\n                                   int64_t size_uncomp,\n                                   int64_t correction) ATTRIBUTE_MALLOC;\nstatic int read_file_header (Bit_Chain *restrict dat,\n                             Dwg_R2007_Header *restrict file_header);\nstatic void read_instructions (BITCODE_RC *restrict *restrict src,\n                               BITCODE_RC *restrict opcode,\n                               uint32_t *restrict offset,\n                               uint32_t *restrict length);\nstatic inline BITCODE_RC *copy_bytes_2 (BITCODE_RC *restrict dst,\n                                        const BITCODE_RC *restrict src);\nstatic inline BITCODE_RC *copy_bytes_3 (BITCODE_RC *restrict dst,\n                                        const BITCODE_RC *restrict src);\nstatic void copy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset);\nstatic uint32_t read_literal_length (BITCODE_RC *restrict *restrict src,\n                                     unsigned char opcode);\nstatic void copy_compressed_bytes (BITCODE_RC *restrict dst,\n                                   BITCODE_RC *restrict src, int length);\nstatic BITCODE_RC *decode_rs (const BITCODE_RC *src, int block_count,\n                              int data_size,\n                              const unsigned src_size) ATTRIBUTE_MALLOC;\nstatic int decompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                             BITCODE_RC *restrict src, const unsigned src_size,\n                             const BITCODE_RC *restrict dst_end);\n\n#define copy_1(offset) *dst++ = *(src + offset);\n#define copy_2(offset) dst = copy_bytes_2 (dst, src + offset);\n#define copy_3(offset) dst = copy_bytes_3 (dst, src + offset)\n// 4 and 8 is not reverse, 16 is\n#define copy_n(n, offset)                                                     \\\n  memcpy (dst, &src[offset], n);                                              \\\n  dst += n\n\n#define copy_4(offset) copy_n (4, offset)\n#define copy_8(offset) copy_n (8, offset)\n#define copy_16(offset)                                                       \\\n  memcpy (dst, &src[offset + 8], 8);                                          \\\n  memcpy (&dst[8], &src[offset], 8);                                          \\\n  dst += 16\n\n/* Don't use restrict here: GH #141 broken for most newer compilers */\nstatic inline BITCODE_RC *\ncopy_bytes_2 (BITCODE_RC *dst, const BITCODE_RC *src)\n{\n  dst[0] = src[1];\n  dst[1] = src[0];\n  return dst + 2;\n}\n\nstatic inline BITCODE_RC *\ncopy_bytes_3 (BITCODE_RC *dst, const BITCODE_RC *src)\n{\n  dst[0] = src[2];\n  dst[1] = src[1];\n  dst[2] = src[0];\n  return dst + 3;\n}\n\nstatic void\ncopy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset)\n{\n  BITCODE_RC *src = dst - offset;\n\n  while (length-- > 0)\n    *dst++ = *src++;\n}\n\n/* See spec version 5.0 page 30 */\nstatic void\ncopy_compressed_bytes (BITCODE_RC *restrict dst, BITCODE_RC *restrict src,\n                       int length)\n{\n  while (length >= 32)\n    {\n      copy_16 (16);\n      copy_16 (0);\n\n      src += 32;\n      length -= 32;\n    }\n\n  switch (length)\n    {\n    case 0:\n      break;\n    case 1:\n      copy_1 (0);\n      break;\n    case 2:\n      copy_2 (0);\n      break;\n    case 3:\n      copy_3 (0);\n      break;\n    case 4:\n      copy_4 (0);\n      break;\n    case 5:\n      copy_1 (4);\n      copy_4 (0);\n      break;\n    case 6:\n      copy_1 (5);\n      copy_4 (1);\n      copy_1 (0);\n      break;\n    case 7:\n      copy_2 (5);\n      copy_4 (1);\n      copy_1 (0);\n      break;\n    case 8:\n      copy_8 (0);\n      break;\n    case 9:\n      copy_1 (8);\n      copy_8 (0);\n      break;\n    case 10:\n      copy_1 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 11:\n      copy_2 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 12:\n      copy_4 (8);\n      copy_8 (0);\n      break;\n    case 13:\n      copy_1 (12);\n      copy_4 (8);\n      copy_8 (0);\n      break;\n    case 14:\n      copy_1 (13);\n      copy_4 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 15:\n      copy_2 (13);\n      copy_4 (9);\n      copy_8 (1);\n      copy_1 (0);\n      break;\n    case 16:\n      copy_16 (0);\n      break;\n    case 17:\n      copy_8 (9);\n      copy_1 (8);\n      copy_8 (0);\n      break;\n    case 18:\n      copy_1 (17);\n      copy_16 (1);\n      copy_1 (0);\n      break;\n    case 19:\n      copy_3 (16);\n      copy_16 (0);\n      break;\n    case 20:\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 21:\n      copy_1 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 22:\n      copy_2 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 23:\n      copy_3 (20);\n      copy_4 (16);\n      copy_16 (0);\n      break;\n    case 24:\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 25:\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 26:\n      copy_1 (25);\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 27:\n      copy_2 (25);\n      copy_8 (17);\n      copy_1 (16);\n      copy_16 (0);\n      break;\n    case 28:\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 29:\n      copy_1 (28);\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 30:\n      copy_2 (28);\n      copy_4 (24);\n      copy_8 (16);\n      copy_16 (0);\n      break;\n    case 31:\n      copy_1 (30);\n      copy_4 (26);\n      copy_8 (18);\n      copy_16 (2);\n      copy_2 (0);\n      break;\n    default:\n      LOG_ERROR (\"Wrong length %d\", length);\n    }\n}\n\n/* See spec version 5.1 page 50 */\nstatic uint32_t\nread_literal_length (BITCODE_RC *restrict *src, unsigned char opcode)\n{\n  uint32_t length = opcode + 8;\n\n  if (length == 0x17)\n    {\n      int n = *(*src)++;\n\n      length += n;\n\n      if (n == 0xff)\n        {\n          do\n            {\n              n = *(*src)++;\n              n |= (*(*src)++ << 8);\n\n              length += n;\n            }\n          while (n == 0xFFFF);\n        }\n    }\n\n  return length;\n}\n\n/* See spec version 5.1 page 53 */\nstatic void\nread_instructions (BITCODE_RC *restrict *src, unsigned char *restrict opcode,\n                   uint32_t *restrict offset, uint32_t *restrict length)\n{\n  switch (*opcode >> 4)\n    {\n    case 0:\n      *length = (*opcode & 0xf) + 0x13;\n      *offset = *(*src)++;\n      *opcode = *(*src)++;\n      *length = ((*opcode >> 3) & 0x10) + *length;\n      *offset = ((*opcode & 0x78) << 5) + 1 + *offset;\n      break;\n\n    case 1:\n      *length = (*opcode & 0xf) + 3;\n      *offset = *(*src)++;\n      *opcode = *(*src)++;\n      *offset = ((*opcode & 0xf8) << 5) + 1 + *offset;\n      break;\n\n    case 2:\n      *offset = *(*src)++;\n      *offset = ((*(*src)++ << 8) & 0xff00) | *offset;\n      *length = *opcode & 7;\n\n      if ((*opcode & 8) == 0)\n        {\n          *opcode = *(*src)++;\n          *length = (*opcode & 0xf8) + *length;\n        }\n      else\n        {\n          (*offset)++;\n          *length = (*(*src)++ << 3) + *length;\n          *opcode = *(*src)++;\n          *length = (((*opcode & 0xf8) << 8) + *length) + 0x100;\n        }\n      break;\n\n    default:\n      *length = *opcode >> 4;\n      *offset = *opcode & 15;\n      *opcode = *(*src)++;\n      *offset = (((*opcode & 0xf8) << 1) + *offset) + 1;\n      break;\n    }\n}\n\n/* par 4.7 Compression, page 32 (same as format 2004)\n   TODO: replace by decompress_R2004_section(dat, decomp, comp_data_size)\n   Note that dst + dst_size might deviate from dst_end.\n*/\nstatic int\ndecompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                  BITCODE_RC *restrict src, const unsigned src_size,\n                  const BITCODE_RC *restrict dst_end)\n{\n  uint32_t length = 0;\n  uint32_t offset = 0;\n\n  BITCODE_RC *dst_start = dst;\n  BITCODE_RC *src_end = src + src_size;\n  unsigned char opcode;\n  if (!dst_end)\n    dst_end = dst + dst_size;\n\n  LOG_INSANE (\"decompress_r2007 (%p, %d, %p, %d)\\n\", dst, dst_size, src,\n              src_size);\n  if (!dst || !src || !dst_size || src_size < 2)\n    {\n      LOG_ERROR (\"Invalid argument to %s\\n\", __FUNCTION__);\n      return DWG_ERR_INTERNALERROR;\n    }\n\n  opcode = *src++;\n  if ((opcode & 0xf0) == 0x20)\n    {\n      src += 2;\n      length = *src++ & 0x07;\n      if (length == 0)\n        {\n          LOG_ERROR (\"Decompression error: zero length\")\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  while (src < src_end)\n    {\n      if (length == 0)\n        length = read_literal_length (&src, opcode);\n\n      if ((dst + length) > dst_end || (src + length) > src_end)\n        {\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n            {\n              if ((dst + length) > dst_end)\n                HANDLER (OUTPUT, \"copy_compressed_bytes: dst %p + %u >= %p\\n\",\n                         dst, (unsigned)length, dst_end);\n              else\n                HANDLER (OUTPUT, \"copy_compressed_bytes: src %p + %u > %p\\n\",\n                         src, (unsigned)length, src_end);\n            }\n          LOG_ERROR (\"Decompression error: length overflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n\n      LOG_INSANE (\n          \"copy_compressed_bytes (%p, %p, %u). remaining src: %ld, dst: %ld\\n\",\n          dst, src, (unsigned)length, (long)(src_end - src),\n          (long)(dst_end - dst));\n      copy_compressed_bytes (dst, src, length);\n\n      dst += length;\n      src += length;\n\n      length = 0;\n\n      if (src >= src_end)\n        return 0;\n\n      opcode = *src++;\n\n      read_instructions (&src, &opcode, &offset, &length);\n\n      while (1)\n        {\n          if ((dst + length) > dst_end)\n            {\n              LOG_HANDLE (\"copy_bytes: dst %p + %u > %p\\n\", dst,\n                          (unsigned)length, dst_end);\n              LOG_ERROR (\"Decompression error: length overflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          if (offset > (uint32_t)(dst - dst_start))\n            {\n              LOG_HANDLE (\"copy_bytes: offset %u > %p - %p\\n\",\n                          (unsigned)offset, dst, dst_start);\n              LOG_ERROR (\"Decompression error: offset underflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          LOG_INSANE (\"copy_bytes (%p, %u, [%u])\\n\", dst, (unsigned)length,\n                      (unsigned)offset);\n          copy_bytes (dst, length, offset);\n\n          dst += length;\n          length = (opcode & 7);\n\n          if (length != 0 || src >= src_end)\n            break;\n\n          opcode = *src++;\n\n          if ((opcode >> 4) == 0)\n            break;\n\n          if ((opcode >> 4) == 0x0f)\n            opcode &= 0xf;\n\n          read_instructions ((unsigned char **)&src, &opcode, &offset,\n                             &length);\n        }\n    }\n  return 0;\n}\n\n// reed-solomon (255, 239) encoding with factor 3\n// TODO: for now disabled, until we get proper data\nATTRIBUTE_MALLOC\nstatic BITCODE_RC *\ndecode_rs (const BITCODE_RC *src, int block_count, int data_size,\n           const unsigned src_size)\n{\n  int i, j;\n  const BITCODE_RC *src_base = src;\n  BITCODE_RC *dst_base, *dst;\n  // TODO: round up data_size from 239 to 255\n\n  if ((size_t)block_count * data_size > src_size)\n    {\n      LOG_ERROR (\"decode_rs src overflow: %ld > %u\",\n                 (long)block_count * data_size, src_size)\n      return NULL;\n    }\n  dst_base = dst = (BITCODE_RC *)calloc (block_count, data_size);\n  if (!dst)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return NULL;\n    }\n\n  for (i = 0; i < block_count; ++i)\n    {\n      for (j = 0; j < data_size; ++j)\n        {\n          *dst++ = *src;\n          src += block_count;\n        }\n\n      // rs_decode_block((unsigned char*)(dst_base + 239*i), 1);\n      src = ++src_base;\n    }\n\n  return dst_base;\n}\n\nstatic bool\nread_system_page (Bit_Chain *out, Bit_Chain *dat, int64_t size_comp,\n                  int64_t size_uncomp, int64_t repeat_count)\n{\n  int i;\n  int error = 0;\n\n  int64_t pesize;      // Pre RS encoded size\n  int64_t block_count; // Number of RS encoded blocks\n  int64_t page_size;\n  long pedata_size;\n\n  BITCODE_RC *rsdata;          // RS encoded data\n  BITCODE_RC *pedata;          // Pre RS encoded data\n  BITCODE_RC *data_end; // The data RS unencoded and uncompressed\n\n  if (repeat_count < 0 || repeat_count > DBG_MAX_COUNT\n      || (uint64_t)size_comp >= dat->size\n      || (uint64_t)size_uncomp >= dat->size)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: \"\n                 \"size_comp: %\" PRId64 \", size_uncomp: %\" PRId64\n                 \", repeat_count: %\" PRId64,\n                 size_comp, size_uncomp, repeat_count);\n      return false;\n    }\n  // Round to a multiple of 8\n  pesize = ((size_comp + 7) & ~7) * repeat_count;\n  // Divide pre encoded size by RS k-value (239)\n  block_count = (pesize + 238) / 239;\n  if (block_count <= 0 || block_count > DBG_MAX_COUNT)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: size_comp: %\" PRId64\n                 \", size_uncomp: %\" PRId64,\n                 size_comp, size_uncomp);\n      return false;\n    }\n  // Multiply with codeword size (255) and round to a multiple of 8\n  page_size = (block_count * 255 + 7) & ~7;\n  if ((uint64_t)page_size >= DBG_MAX_COUNT\n      || (size_t)page_size > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Invalid r2007 system page: page_size: %\" PRId64, page_size);\n      return false;\n    }\n  LOG_HANDLE (\"read_system_page: size_comp: %\" PRId64 \", size_uncomp: %\" PRId64\n              \", repeat_count: %\" PRId64 \"\\n\",\n              size_comp, size_uncomp, repeat_count);\n  assert ((uint64_t)size_comp < dat->size);\n  assert ((uint64_t)size_uncomp < dat->size);\n  assert ((uint64_t)repeat_count < DBG_MAX_COUNT);\n  assert ((uint64_t)page_size < DBG_MAX_COUNT);\n  bit_chain_init_dat (out, size_uncomp + page_size, dat);\n  //data = (BITCODE_RC *)calloc (size_uncomp + page_size, 1);\n  LOG_HANDLE (\"Alloc system page of size %\" PRId64 \"\\n\",\n              size_uncomp + page_size)\n    assert (out->size == (size_t)(size_uncomp + page_size));\n  if (!out->chain)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return false;\n    }\n  data_end = &out->chain[size_uncomp + page_size];\n\n  rsdata = &out->chain[size_uncomp];\n  bit_read_fixed (dat, rsdata, page_size);\n  pedata_size = block_count * 239;\n  pedata = decode_rs (rsdata, block_count, 239, page_size);\n  if (!pedata)\n    {\n      bit_chain_free (out);\n      return false;\n    }\n\n  if (size_comp < size_uncomp)\n    error = decompress_r2007 (out->chain, size_uncomp, pedata,\n                              MIN (pedata_size, size_comp), data_end);\n  else\n    {\n      if (out->byte + size_uncomp <= out->size)\n        memcpy (out->chain, pedata, size_uncomp);\n      else\n        {\n          LOG_ERROR (\"data overflow\")\n          error = DWG_ERR_CRITICAL;\n        }\n    }\n\n  free (pedata);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      bit_chain_free (out);\n      return false;\n    }\n  return true;\n}\n\nstatic int\nread_data_page (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                int64_t page_size, int64_t size_comp, int64_t size_uncomp,\n                BITCODE_RC *restrict decomp_end)\n{\n  int i;\n  int error = 0;\n\n  int64_t pesize;      // Pre RS encoded size\n  int64_t block_count; // Number of RS encoded blocks\n\n  BITCODE_RC *rsdata; // RS encoded data\n  BITCODE_RC *pedata; // Pre RS encoded data\n  long pedata_size;\n\n  // Round to a multiple of 8\n  pesize = ((size_comp + 7) & ~7);\n  block_count = (pesize + 0xFB - 1) / 0xFB;\n  pedata_size = block_count * 0xFB;\n\n  rsdata = (BITCODE_RC *)calloc (1, page_size);\n  if (rsdata == NULL)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return DWG_ERR_OUTOFMEM;\n    }\n  bit_read_fixed (dat, rsdata, page_size);\n  pedata = decode_rs (rsdata, block_count, 0xFB, page_size);\n  if (!pedata)\n    {\n      free (rsdata);\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  if (size_comp < size_uncomp)\n    error = decompress_r2007 (decomp, size_uncomp, pedata,\n                              MIN (pedata_size, size_comp), decomp_end);\n  else\n    {\n      if (decomp + size_uncomp <= decomp_end)\n        memcpy (decomp, pedata, size_uncomp);\n      else\n        {\n          LOG_ERROR (\"decomp overflow\")\n          free (pedata);\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  free (pedata);\n  free (rsdata);\n\n  return error;\n}\n\nstatic int\nread_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,\n                   r2007_section *restrict sections_map,\n                   r2007_page *restrict pages_map, Dwg_Section_Type sec_type)\n{\n  r2007_section *section;\n  r2007_page *page;\n  uint64_t max_decomp_size;\n  BITCODE_RC *decomp, *decomp_end;\n  int error = 0, i;\n\n  section = get_section (sections_map, sec_type);\n  sec_dat->chain = NULL;\n  if (section == NULL)\n    {\n      if (sec_type < SECTION_REVHISTORY && sec_type != SECTION_TEMPLATE\n          && sec_type != SECTION_OBJFREESPACE)\n        {\n          LOG_WARN (\"Failed to find section_info[%u]\", (int)sec_type)\n          return DWG_ERR_SECTIONNOTFOUND;\n        }\n      else\n        {\n          LOG_TRACE (\"Found no section_info[%u]\\n\", (int)sec_type)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n    }\n\n  max_decomp_size = section->data_size;\n  if (max_decomp_size > 0x2f000000) // 790Mb\n    {\n      LOG_ERROR (\"Invalid max decompression size %\" PRIu64, max_decomp_size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  decomp = (BITCODE_RC *)calloc (max_decomp_size, 1);\n  if (decomp == NULL)\n    {\n      LOG_ERROR (\"Out of memory\")\n      return DWG_ERR_OUTOFMEM;\n    }\n  decomp_end = &decomp[max_decomp_size];\n  LOG_HANDLE (\"Alloc data section of size %\" PRIu64 \"\\n\", max_decomp_size)\n\n  // sec_dat->chain = decomp;\n  sec_dat->bit = 0;\n  sec_dat->byte = 0;\n  sec_dat->size = max_decomp_size;\n  sec_dat->version = dat->version;\n  sec_dat->from_version = dat->from_version;\n\n  for (i = 0; i < (int)section->num_pages; i++)\n    {\n      r2007_section_page *section_page = section->pages[i];\n      if (!section_page)\n        {\n          free (decomp);\n          LOG_ERROR (\"Failed to find section page %d\", (int)i)\n          return DWG_ERR_PAGENOTFOUND;\n        }\n      page = get_page (pages_map, section_page->id);\n      if (page == NULL)\n        {\n          free (decomp);\n          LOG_ERROR (\"Failed to find page %d\", (int)section_page->id)\n          return DWG_ERR_PAGENOTFOUND;\n        }\n      if (section_page->offset > max_decomp_size)\n        {\n          free (decomp);\n          LOG_ERROR (\"Invalid section_page->offset %ld > %ld\",\n                     (long)section_page->offset, (long)max_decomp_size)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      if (max_decomp_size < section_page->uncomp_size)\n        {\n          free (decomp);\n          LOG_ERROR (\"Invalid section size %ld < %ld\", (long)max_decomp_size,\n                     (long)section_page->uncomp_size)\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      dat->byte = page->offset;\n      // only if compressed. TODO: Isn't there a compressed flag as with 2004+?\n      // theoretically the sizes could still be the same.\n      if (section_page->comp_size != section_page->uncomp_size)\n        {\n          error = read_data_page (dat, &decomp[section_page->offset],\n                                  page->size, section_page->comp_size,\n                                  section_page->uncomp_size, decomp_end);\n          if (error)\n            {\n              free (decomp);\n              LOG_ERROR (\"Failed to read compressed page\")\n              return error;\n            }\n        }\n      else\n        {\n          if (section_page->uncomp_size\n                  > max_decomp_size - section_page->offset\n              || section_page->uncomp_size > dat->size - dat->byte)\n            {\n              free (decomp);\n              LOG_ERROR (\"Invalid section size %ld\",\n                         (long)section_page->uncomp_size);\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          memcpy (&decomp[section_page->offset], &dat->chain[dat->byte],\n                  section_page->uncomp_size);\n        }\n    }\n  sec_dat->chain = decomp;\n  return 0;\n}\n\n#define LOG_POS_DAT(dat)                                \\\n  LOG_INSANE (\" @%zu.%u\", (dat)->byte, (dat)->bit)      \\\n  LOG_TRACE (\"\\n\")\n\nstatic r2007_section *\nread_sections_map (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,\n                   int64_t correction)\n{\n  BITCODE_RC *data;\n  r2007_section *sections = NULL, *last_section = NULL, *section = NULL;\n  //BITCODE_RC *ptr, *ptr_end;\n  Bit_Chain page = { 0 };\n  int i, j = 0;\n\n  if (!read_system_page (&page, dat, size_comp, size_uncomp, correction))\n    {\n      LOG_ERROR (\"Failed to read system page\")\n      return NULL;\n    }\n\n  LOG_TRACE (\"\\n=== System Section (Section Map) ===\\n\");\n  while (page.byte < (size_t)size_uncomp)\n    {\n      section = (r2007_section *)calloc (1, sizeof (r2007_section));\n      if (!section)\n        {\n          LOG_ERROR (\"Out of memory\");\n          bit_chain_free (&page);\n          sections_destroy (sections); // the root\n          return NULL;\n        }\n      LOG_TRACE (\"\\nSection [%d]:\\n\", j);\n      section->data_size = bit_read_RLL (&page);\n      section->max_size = bit_read_RLL (&page);\n      section->encrypted = bit_read_RLL (&page);\n      section->hashcode = bit_read_RLL (&page);\n      section->name_length = bit_read_RLL (&page);\n      section->unknown = bit_read_RLL (&page);\n      section->encoded = bit_read_RLL (&page);\n      section->num_pages = bit_read_RLL (&page);\n      LOG_TRACE (\"  data size:     %\" PRIu64 \"\\n\", section->data_size)\n      LOG_TRACE (\"  max size:      %\" PRIu64 \"\\n\", section->max_size)\n      LOG_TRACE (\"  encryption:    %\" PRIu64 \"\\n\", section->encrypted)\n      LOG_HANDLE (\"  hashcode:      %\" PRIx64 \"\\n\", section->hashcode)\n      LOG_HANDLE (\"  name length:   %\" PRIu64 \"\\n\", section->name_length)\n      LOG_TRACE (\"  unknown:       %\" PRIu64 \"\\n\", section->unknown)\n      LOG_TRACE (\"  encoding:      %\" PRIu64 \"\\n\", section->encoded)\n      LOG_TRACE (\"  num pages:     %\" PRIu64, section->num_pages);\n      LOG_POS_DAT (&page)\n      // debugging sanity\n#if 1\n      /* compressed */\n      if (section->data_size > 10 * dat->size\n          || section->name_length >= (int64_t)dat->size\n          || section->name_length >= 48)\n        {\n          LOG_ERROR (\"Invalid System Section\");\n          free (section);\n          bit_chain_free (&page);\n          sections_destroy (sections); // the root\n          return NULL;\n        }\n        // assert(section->data_size < dat->size + 0x100000);\n        // assert(section->max_size  < dat->size + 0x100000);\n        // assert(section->num_pages < DBG_MAX_COUNT);\n#endif\n      // section->next = NULL;\n      // section->pages = NULL;\n      // section->name = NULL;\n\n      if (!sections)\n        {\n          sections = last_section = section;\n        }\n      else\n        {\n          last_section->next = section;\n          last_section = section;\n        }\n\n      j++;\n      if (page.byte >= page.size)\n        break;\n\n      // Section Name (wchar)\n      {\n        uint64_t sz = section->name_length;\n        section->name = (DWGCHAR *)calloc (1, sz + 2);\n        bit_read_fixed (&page, (BITCODE_RC*)section->name, sz);\n      }\n#ifdef HAVE_NATIVE_WCHAR2\n      LOG_TRACE (\"  name:          \" FORMAT_TU, (BITCODE_TU)section->name)\n#else\n      LOG_TRACE (\"  name:          \")\n      LOG_TEXT_UNICODE (TRACE, section->name)\n#endif\n      LOG_POS_DAT (&page)\n      LOG_TRACE (\"\\n\")\n      section->type = dwg_section_wtype (section->name);\n\n      if (section->num_pages <= 0 || section->num_pages > 0xf0000)\n        {\n          LOG_ERROR (\"Invalid num_pages %zu, skip\",\n                     (size_t)section->num_pages);\n          section->num_pages = 0;\n          continue;\n        }\n\n      section->pages = (r2007_section_page **)calloc (\n          (size_t)section->num_pages, sizeof (r2007_section_page *));\n      if (!section->pages)\n        {\n          LOG_ERROR (\"Out of memory\");\n          bit_chain_free (&page);\n          if (sections)\n            sections_destroy (sections); // the root\n          else\n            sections_destroy (section);\n          return NULL;\n        }\n\n      for (i = 0; i < section->num_pages; i++)\n        {\n          section->pages[i]\n              = (r2007_section_page *)calloc (1, sizeof (r2007_section_page));\n          if (!section->pages[i])\n            {\n              LOG_ERROR (\"Out of memory\");\n              bit_chain_free (&page);\n              if (sections)\n                sections_destroy (sections); // the root\n              else\n                sections_destroy (section);\n              return NULL;\n            }\n\n          if (page.byte + 56 > page.size)\n            {\n              LOG_ERROR (\"Section[%d]->pages[%d] overflow (%zu > %zu)\", j, i,\n                         page.byte + 56, page.size);\n              free (section->pages[i]);\n              section->num_pages = i; // skip this last section\n              break;\n            }\n\n          section->pages[i]->offset = bit_read_RLL (&page);\n          section->pages[i]->size = bit_read_RLL (&page);\n          section->pages[i]->id = (int64_t)bit_read_RLL (&page);\n          section->pages[i]->uncomp_size = bit_read_RLL (&page);\n          section->pages[i]->comp_size = bit_read_RLL (&page);\n          section->pages[i]->checksum = bit_read_RLL (&page);\n          section->pages[i]->crc = bit_read_RLL (&page);\n\n          LOG_TRACE (\" Page[%d]: \", i)\n          LOG_TRACE (\" offset: 0x%07\" PRIx64, section->pages[i]->offset);\n          LOG_TRACE (\" size: %5\" PRIu64, section->pages[i]->size);\n          LOG_TRACE (\" id: %4\" PRId64, section->pages[i]->id);\n          LOG_TRACE (\" uncomp_size: %5\" PRIu64 \"\\n\",\n                     section->pages[i]->uncomp_size);\n          LOG_HANDLE (\" comp_size: %5\" PRIu64, section->pages[i]->comp_size);\n          LOG_HANDLE (\" checksum: %016\" PRIx64, section->pages[i]->checksum);\n          LOG_HANDLE (\" crc64: %016\" PRIx64 \"\\n\", section->pages[i]->crc);\n          // debugging sanity\n          if (section->pages[i]->size >= DBG_MAX_SIZE\n              || section->pages[i]->uncomp_size >= DBG_MAX_SIZE\n              || section->pages[i]->comp_size >= DBG_MAX_SIZE)\n            {\n              LOG_ERROR (\"Invalid section->pages[%d] size\", i);\n              bit_chain_free (&page);\n              free (section->pages[i]);\n              section->num_pages = i; // skip this last section\n              return sections;\n            }\n          assert (section->pages[i]->size < DBG_MAX_SIZE);\n          assert (section->pages[i]->uncomp_size < DBG_MAX_SIZE);\n          assert (section->pages[i]->comp_size < DBG_MAX_SIZE);\n        }\n    }\n\n  bit_chain_free (&page);\n  return sections;\n}\n\nstatic r2007_page *\nread_pages_map (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,\n                int64_t correction)\n{\n  r2007_page *pages = NULL, *last_page = NULL, *page;\n  int64_t offset = 0x480; // dat->byte;\n  Bit_Chain sdat = { 0 };\n  // int64_t index;\n\n  if (!read_system_page (&sdat, dat, size_comp, size_uncomp, correction))\n    {\n      LOG_ERROR (\"Failed to read system page\")\n      return NULL;\n    }\n  LOG_TRACE (\"\\n=== System Section (Pages Map) ===\\n\")\n  while (sdat.byte < (size_t)size_uncomp)\n    {\n      page = (r2007_page *)malloc (sizeof (r2007_page));\n      if (page == NULL)\n        {\n          LOG_ERROR (\"Out of memory\")\n          bit_chain_free (&sdat);\n          pages_destroy (pages);\n          return NULL;\n        }\n      if (sdat.byte + 16 > sdat.size)\n        {\n          LOG_ERROR (\"Page out of bounds\")\n          bit_chain_free (&sdat);\n          pages_destroy (pages);\n          return NULL;\n        }\n      page->size = bit_read_RLL (&sdat);\n      page->id = (int64_t)bit_read_RLL (&sdat);\n      page->offset = offset;\n      offset += page->size;\n\n      // index = page->id > 0 ? page->id : -page->id;\n      LOG_TRACE (\"Page [%3\" PRId64 \"]: \", page->id)\n      LOG_TRACE (\"size: %6\" PRIu64 \" \", page->size)\n      LOG_TRACE (\"offset: 0x%\" PRIx64 \" \\n\", page->offset)\n\n      page->next = NULL;\n\n      if (pages == NULL)\n        pages = last_page = page;\n      else\n        {\n          last_page->next = page;\n          last_page = page;\n        }\n    }\n  bit_chain_free (&sdat);\n  return pages;\n}\n\n/* Lookup a page in the page map. The page is identified by its id.\n */\nstatic r2007_page *\nget_page (r2007_page *pages_map, int64_t id)\n{\n  r2007_page *page = pages_map;\n\n  while (page != NULL)\n    {\n      if (page->id == id)\n        break;\n      page = page->next;\n    }\n\n  return page;\n}\n\nstatic void\npages_destroy (r2007_page *page)\n{\n  r2007_page *next;\n\n  while (page != 0)\n    {\n      next = page->next;\n      free (page);\n      page = next;\n    }\n}\n\n/* Lookup a section in the section map.\n * The section is identified by its numeric type.\n */\nstatic r2007_section *\nget_section (r2007_section *sections_map, Dwg_Section_Type sec_type)\n{\n  r2007_section *section = sections_map;\n  while (section != NULL)\n    {\n      if (section->type == sec_type)\n        break;\n      section = section->next;\n    }\n\n  return section;\n}\n\nstatic void\nsections_destroy (r2007_section *section)\n{\n  r2007_section *next;\n\n  while (section != 0)\n    {\n      next = section->next;\n\n      if (section->pages)\n        {\n          while (section->num_pages-- > 0)\n            {\n              free (section->pages[section->num_pages]);\n            }\n          free (section->pages);\n        }\n\n      if (section->name)\n        free (section->name);\n\n      free (section);\n      section = next;\n    }\n}\n\nstatic int\nread_file_header (Bit_Chain *restrict dat,\n                  Dwg_R2007_Header *restrict file_header)\n{\n  BITCODE_RC data[0x3d8]; // 0x400 - 5 long\n  BITCODE_RC *pedata;\n  uint64_t seqence_crc;\n  uint64_t seqence_key;\n  uint64_t compr_crc;\n  int32_t compr_len, len2;\n  int i;\n  int error = 0, errcount = 0;\n  const int pedata_size = 3 * 239; // size of pedata\n\n  dat->byte = 0x80;\n  LOG_TRACE (\"\\n=== r2007 File header ===\\n\")\n  memset (file_header, 0, sizeof (Dwg_R2007_Header));\n  memset (data, 0, 0x3d8);\n  bit_read_fixed (dat, data, 0x3d8);\n  pedata = decode_rs (data, 3, 239, 0x3d8);\n  if (!pedata)\n    return DWG_ERR_OUTOFMEM;\n\n  seqence_crc = le64toh (*((uint64_t *)pedata));\n  seqence_key = le64toh (*((uint64_t *)&pedata[8]));\n  compr_crc = le64toh (*((uint64_t *)&pedata[16]));\n  compr_len = le32toh (*((int32_t *)&pedata[24]));\n  len2 = le32toh (*((int32_t *)&pedata[28]));\n  LOG_TRACE (\"seqence_crc64: %016\" PRIX64 \"\\n\", seqence_crc);\n  LOG_TRACE (\"seqence_key:   %016\" PRIX64 \"\\n\", seqence_key);\n  LOG_TRACE (\"compr_crc64:   %016\" PRIX64 \"\\n\", compr_crc);\n  LOG_TRACE (\"compr_len:     %d\\n\", (int)compr_len); // only this is used\n  LOG_TRACE (\"len2:          %d\\n\", (int)len2);      // 0 when compressed\n\n  if (compr_len > 0)\n    error = decompress_r2007 ((BITCODE_RC *)file_header,\n                              sizeof (Dwg_R2007_Header), &pedata[32],\n                              MIN (compr_len, pedata_size - 32), NULL);\n  else\n    memcpy (file_header, &pedata[32], sizeof (Dwg_R2007_Header));\n\n#ifdef WORDS_BIGENDIAN\n  {\n    uint64_t *fields  = (uint64_t *)file_header;\n    for (unsigned j = 0; j < sizeof (Dwg_R2007_Header) / 8; j++)\n      {\n        fields[j] = le64toh (fields[j]);\n      }\n  }\n#endif\n\n  // check validity, for debugging only\n  if (!error)\n    {\n\n#define VALID_SIZE(var)                                                       \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_SIZE\", __FUNCTION__, #var,          \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n#define VALID_COUNT(var)                                                      \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_COUNT\", __FUNCTION__, #var,         \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n\n      VALID_SIZE (file_header->header_size);\n      VALID_SIZE (file_header->file_size);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->header2_offset);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->pages_map_size_comp);\n      VALID_SIZE (file_header->pages_map_size_uncomp);\n      VALID_COUNT (file_header->pages_maxid);\n      VALID_COUNT (file_header->pages_amount);\n      VALID_COUNT (file_header->num_sections);\n    }\n\n  free (pedata);\n  return error;\n}\n\n/* Return the latest dat position for all three independent streams\n   data, handle and string.\n*/\nsize_t\nobj_stream_position (Bit_Chain *restrict dat, Bit_Chain *restrict hdl_dat,\n                     Bit_Chain *restrict str_dat)\n{\n  size_t p1 = bit_position (dat);\n  /* all 3 now relative to obj */\n  size_t p2 = bit_position (hdl_dat);\n  SINCE (R_2007)\n  { // but only since 2007 there is a separate string stream\n    size_t p3 = bit_position (str_dat);\n    if (p2 > p1)\n      return p3 > p2 ? p3 : p2;\n    else\n      return p3 > p1 ? p3 : p1;\n  }\n  else\n  {\n    return (p2 > p1) ? p2 : p1;\n  }\n}\n\nint\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  size_t old_size;                     // in byte\n  size_t old_byte;\n  // assert (dat != str); // r2007 objects are the same, just entities not\n  old_size = str->size;\n  old_byte = str->byte;\n\n  // str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_set_position (str, start);\n\n  if (str->byte > old_size - old_byte)\n    {\n      LOG_ERROR (\"obj_string_stream overflow, bitsize \" FORMAT_RL\n                 \" => \" FORMAT_RL \" (strpos %zu > diff %zu)\",\n                 obj->bitsize, obj->size * 8, str->byte, old_size - old_byte);\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      obj->bitsize = obj->size * 8;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\" obj string stream +\" FORMAT_RL \": @%zu.%u (%zu)\", start,\n              str->byte, str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\" has_strings: %d\\n\", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\" @%zu.%u\", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\" data_size: %u/0x%x [RS]\", (unsigned)data_size,\n              (unsigned)data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      LOG_HANDLE (\" @%zu.%u\", str->byte, str->bit & 7);\n      hi_size = bit_read_RS (str);\n      LOG_HANDLE (\" hi_size \" FORMAT_RS \"/\" FORMAT_RSx \" [RS]\", hi_size,\n                  hi_size);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\" => data_size: %u/0x%x\\n\", (unsigned)data_size,\n                  (unsigned)data_size);\n      // LOG_TRACE(\"  -33: @%zu\\n\", str->byte);\n    }\n  else\n    LOG_HANDLE (\"\\n\");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\"Invalid string stream data_size %u > bitsize %u at @%zu.%u\\n\",\n                (unsigned)data_size, (unsigned)obj->bitsize, str->byte,\n                str->bit & 7);\n      if (dat->from_version == R_2007)\n        {\n          return 0;\n        }\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  if (data_size < obj->bitsize)\n    {\n      obj->stringstream_size = data_size;\n      bit_advance_position (str, -(int)data_size);\n    }\n  else\n    {\n      bit_set_position (str, 0);\n    }\n  // bit_reset_chain (str);\n  // LOG_TRACE(\" %d: @%zu.%u (%zu)\\n\", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}\n\nvoid\nsection_string_stream (Dwg_Data *restrict dwg, Bit_Chain *restrict dat,\n                       BITCODE_RL bitsize, Bit_Chain *restrict str)\n{\n  BITCODE_RL start;     // in bits\n  BITCODE_RL data_size; // in bits\n  BITCODE_B endbit;\n  if (dwg->header.version < R_2010\n      || (dwg->header.version == R_2010 && dwg->header.maint_version < 3))\n    {\n      // r2007: + 24 bytes (sentinel+size+hsize) - 1 bit (endbit)\n      start = bitsize + 159;\n    }\n  else\n    {\n      // r2010: + 24 bytes (sentinel+size+hSize) - 1 bit (endbit)\n      start = bitsize + 191; /* 8*24 = 192 */\n    }\n  *str = *dat;\n  bit_set_position (str, start);\n  LOG_TRACE (\"section string stream\\n  pos: \" FORMAT_RL \", %zu/%u\\n\", start,\n             str->byte, str->bit);\n  endbit = bit_read_B (str);\n  LOG_HANDLE (\"  endbit: %d\\n\", (int)endbit);\n  if (!endbit)\n    return; // i.e. has no strings. without data_size should be 0\n  start -= 16;\n  bit_set_position (str, start);\n  LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu\\n\", start, str->byte);\n  // str->bit = start & 7;\n  data_size = bit_read_RS (str);\n  LOG_HANDLE (\"  data_size: \" FORMAT_RL \"\\n\", data_size);\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      start -= 16;\n      data_size &= 0x7FFF;\n      bit_set_position (str, start);\n      LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu\\n\", start, str->byte);\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"  hi_size: \" FORMAT_RS \", data_size: \" FORMAT_RL \"\\n\",\n                  hi_size, data_size);\n    }\n  start -= data_size;\n  bit_set_position (str, start);\n  LOG_HANDLE (\"  pos: \" FORMAT_RL \", %zu/%u\\n\", start, str->byte, str->bit);\n}\n\n// for string stream see p86\nstatic int\nread_2007_section_classes (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  BITCODE_RL size, i;\n  BITCODE_BS max_num;\n  Bit_Chain sec_dat = { 0 }, str = { 0 };\n  Dwg_Object *obj = NULL;\n  int error;\n  char c;\n\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_CLASSES);\n  if (error)\n    {\n      LOG_ERROR (\"Failed to read class section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN)))\n    {\n      BITCODE_RL bitsize = 0;\n      LOG_TRACE (\"\\nClasses\\n-------------------\\n\")\n      size = bit_read_RL (&sec_dat); // size of class data area\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", size)\n      /*\n      if (dat->from_version >= R_2010 && dwg->header.maint_version > 3)\n        {\n          BITCODE_RL hsize = bit_read_RL(&sec_dat);\n          LOG_TRACE(\"hsize: \" FORMAT_RL \" [RL]\\n\", hsize)\n        }\n      */\n      if (dat->from_version >= R_2007)\n        {\n          bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", bitsize)\n        }\n      max_num = bit_read_BS (&sec_dat); // Maximum class number\n      LOG_TRACE (\"max_num: \" FORMAT_BS \" [BS]\\n\", max_num)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_B (&sec_dat); // 1\n      LOG_HANDLE (\"c: \" FORMAT_B \" [B]\\n\", c);\n\n      dwg->layout_type = 0;\n      dwg->num_classes = max_num - 499;\n      if (max_num < 500 || max_num > 5000)\n        {\n          LOG_ERROR (\"Invalid max class number %d\", max_num)\n          dwg->num_classes = 0;\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      assert (max_num >= 500);\n      assert (max_num < 5000);\n\n      section_string_stream (dwg, &sec_dat, bitsize, &str);\n\n      dwg->dwg_class\n          = (Dwg_Class *)calloc (dwg->num_classes, sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_OUTOFMEM;\n        }\n\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          dwg->dwg_class[i].number = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].proxyflag = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].appname = (char *)bit_read_TU (&str);\n          dwg->dwg_class[i].cppname = (char *)bit_read_TU (&str);\n          dwg->dwg_class[i].dxfname_u = bit_read_TU (&str);\n          dwg->dwg_class[i].is_zombie = bit_read_B (&sec_dat); // DXF 280\n          // DXF 281, is_entity is 0x1f3\n          dwg->dwg_class[i].item_class_id = bit_read_BS (&sec_dat);\n\n          dwg->dwg_class[i].num_instances = bit_read_BL (&sec_dat); // DXF 91\n          dwg->dwg_class[i].dwg_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].maint_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat); // 0\n          dwg->dwg_class[i].unknown_2 = bit_read_BL (&sec_dat); // 0\n\n          LOG_TRACE (\"-------------------\\n\")\n          LOG_TRACE (\"Number:           %d\\n\", dwg->dwg_class[i].number)\n          LOG_TRACE (\"Proxyflag:        0x%x\\n\", dwg->dwg_class[i].proxyflag)\n          dwg_log_proxyflag (DWG_LOGLEVEL, DWG_LOGLEVEL_TRACE,\n                             dwg->dwg_class[i].proxyflag);\n          LOG_TRACE_TU (\"Application name\", dwg->dwg_class[i].appname, 0)\n          LOG_TRACE_TU (\"C++ class name  \", dwg->dwg_class[i].cppname, 0)\n          LOG_TRACE_TU (\"DXF record name \", dwg->dwg_class[i].dxfname_u, 0)\n          LOG_TRACE (\"Class ID:         0x%x \"\n                     \"(0x1f3 for object, 0x1f2 for entity)\\n\",\n                     dwg->dwg_class[i].item_class_id)\n          LOG_TRACE (\"instance count:   %u\\n\", dwg->dwg_class[i].num_instances)\n          LOG_TRACE (\"dwg version:      %u (%u)\\n\",\n                     dwg->dwg_class[i].dwg_version,\n                     dwg->dwg_class[i].maint_version)\n          LOG_HANDLE (\"unknown:          %u %u\\n\", dwg->dwg_class[i].unknown_1,\n                      dwg->dwg_class[i].unknown_2)\n\n          dwg->dwg_class[i].dxfname\n              = bit_convert_TU (dwg->dwg_class[i].dxfname_u);\n          if (dwg->dwg_class[i].dxfname\n              && strEQc (dwg->dwg_class[i].dxfname, \"LAYOUT\"))\n            dwg->layout_type = dwg->dwg_class[i].number;\n        }\n    }\n  else\n    {\n      LOG_ERROR (\"Failed to find class section sentinel\");\n      free (sec_dat.chain);\n      return DWG_ERR_CLASSESNOTFOUND;\n    }\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n\n  return 0;\n}\n\nstatic int\nread_2007_section_header (Bit_Chain *restrict dat, Bit_Chain *restrict hdl_dat,\n                          Dwg_Data *restrict dwg,\n                          r2007_section *restrict sections_map,\n                          r2007_page *restrict pages_map)\n{\n  Bit_Chain sec_dat = { 0 }, str_dat = { 0 };\n  int error;\n  LOG_TRACE (\"\\nSection Header\\n-------------------\\n\");\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_HEADER);\n  if (error)\n    {\n      LOG_ERROR (\"Failed to read header section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n  if (bit_search_sentinel (&sec_dat,\n                           dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN)))\n    {\n      BITCODE_RL endbits = 160; // start bit: 16 sentinel + 4 size\n      dwg->header_vars.size = bit_read_RL (&sec_dat);\n      LOG_TRACE (\"size: \" FORMAT_RL \"\\n\", dwg->header_vars.size);\n      *hdl_dat = sec_dat;\n      // unused: later versions re-use the 2004 section format\n      /*\n      if (dat->from_version >= R_2010 && dwg->header.maint_version > 3)\n        {\n          dwg->header_vars.bitsize_hi = bit_read_RL(&sec_dat);\n          LOG_TRACE(\"bitsize_hi: \" FORMAT_RL \" [RL]\\n\",\n      dwg->header_vars.bitsize_hi) endbits += 32;\n        }\n      */\n      if (dat->from_version == R_2007) // always true so far\n        {\n          dwg->header_vars.bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\",\n                     dwg->header_vars.bitsize);\n          endbits += dwg->header_vars.bitsize;\n          bit_set_position (hdl_dat, endbits);\n          section_string_stream (dwg, &sec_dat, dwg->header_vars.bitsize,\n                                 &str_dat);\n        }\n\n      dwg_decode_header_variables (&sec_dat, hdl_dat, &str_dat, dwg);\n    }\n  else\n    {\n      DEBUG_HERE;\n      error = DWG_ERR_SECTIONNOTFOUND;\n    }\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n\n  return error;\n}\n\nstatic int\nread_2007_section_handles (Bit_Chain *dat, Bit_Chain *hdl,\n                           Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain obj_dat = { 0 }, hdl_dat = { 0 };\n  BITCODE_RS section_size = 0;\n  size_t endpos;\n  int error;\n\n  error = read_data_section (&obj_dat, dat, sections_map, pages_map,\n                             SECTION_OBJECTS);\n  if (error >= DWG_ERR_CRITICAL || !obj_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read objects section\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nHandles\\n-------------------\\n\")\n  error = read_data_section (&hdl_dat, dat, sections_map, pages_map,\n                             SECTION_HANDLES);\n  if (error >= DWG_ERR_CRITICAL || !hdl_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read handles section\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      if (hdl_dat.chain)\n        free (hdl_dat.chain);\n      return error;\n    }\n\n  /* From here on the same code as in decode:read_2004_section_handles */\n  endpos = hdl_dat.byte + hdl_dat.size;\n  dwg->num_objects = 0;\n\n  do\n    {\n      size_t last_offset;\n      // uint64_t last_handle;\n      size_t oldpos = 0;\n      size_t startpos = hdl_dat.byte;\n      uint16_t crc1, crc2;\n\n      section_size = bit_read_RS_BE (&hdl_dat);\n      LOG_TRACE (\"\\nSection size: %u\\n\", section_size);\n      if (section_size > 2050)\n        {\n          LOG_ERROR (\"Object-map/handles section size greater than 2050!\");\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      last_offset = 0;\n      while ((long)(hdl_dat.byte - startpos) < (long)section_size)\n        {\n          int added;\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n\n          oldpos = hdl_dat.byte;\n          handleoff = bit_read_UMC (&hdl_dat);\n          offset = bit_read_MC (&hdl_dat);\n          last_offset += offset;\n          LOG_TRACE (\"\\nNext object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_TRACE (\"Handleoff: \" FORMAT_UMC \" [UMC] \"\n                     \"Offset: \" FORMAT_MC \" [MC] @%zu\\n\",\n                     handleoff, offset, last_offset)\n\n          if (hdl_dat.byte == oldpos)\n            break;\n\n          added = dwg_decode_add_object (dwg, &obj_dat, hdl, last_offset);\n          if (added > 0)\n            error |= added;\n        }\n\n      if (hdl_dat.byte == oldpos)\n        break;\n#if 0\n      if (!bit_check_CRC(&hdl_dat, startpos, 0xC0C1))\n        LOG_WARN(\"Handles section CRC mismatch at offset %lx\", startpos);\n#else\n      crc1 = bit_calc_CRC (0xC0C1, &(hdl_dat.chain[startpos]),\n                           hdl_dat.byte - startpos);\n      crc2 = bit_read_RS_BE (&hdl_dat);\n      if (crc1 == crc2)\n        {\n          LOG_INSANE (\"Handles section page CRC: %04X from %zx-%zx\\n\", crc2,\n                      startpos, hdl_dat.byte - 2);\n        }\n      else\n        {\n          LOG_WARN (\"Handles section page CRC mismatch: %04X vs calc. %04X \"\n                    \"from %zx-%zx\\n\",\n                    crc2, crc1, startpos, hdl_dat.byte - 2);\n          error |= DWG_ERR_WRONGCRC;\n        }\n#endif\n\n      if (hdl_dat.byte >= endpos)\n        break;\n    }\n  while (section_size > 2);\n\n  if (hdl_dat.chain)\n    free (hdl_dat.chain);\n  if (obj_dat.chain)\n    free (obj_dat.chain);\n  return error;\n}\n\n/* VBAProject Section\n */\nstatic int\nread_2007_section_vbaproject (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_VBAProject *_obj = &dwg->vbaproject;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  // BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_VBAPROJECT);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"VBAProject\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nVBAProject (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  DEBUG_HERE\n  _obj->size = dat->size & 0xFFFFFFFF;\n  _obj->unknown_bits = bit_read_TF (dat, _obj->size);\n  LOG_TRACE_TF (_obj->unknown_bits, _obj->size)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2007_section_summary (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain old_dat, sec_dat = { 0 };\n  Bit_Chain *str_dat;\n  Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  int error;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  old_dat = *dat;\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SUMMARYINFO);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read SummaryInfo section\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.summaryinfo_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"summaryinfo_address mismatch: \" FORMAT_RL \" != %zu\",\n              dwg->header.summaryinfo_address, dat->byte);\n  LOG_TRACE (\"\\nSummaryInfo (%zu)\\n-------------------\\n\", sec_dat.size)\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* AppInfo Section\n */\nstatic int\nread_2007_section_appinfo (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  Bit_Chain *str_dat;\n  Dwg_AppInfo *_obj = &dwg->appinfo;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_APPINFO);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AppInfo\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAppInfo (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"appinfo.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* AuxHeader Section\n */\nstatic int\nread_2007_section_auxheader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                             r2007_section *restrict sections_map,\n                             r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_AuxHeader *_obj = &dwg->auxheader;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL vcount = 0, rcount1 = 0, rcount2 = 0;\n\n  // type: 2, compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_AUXHEADER);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AuxHeader\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAuxHeader (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"auxheader.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* Unknown AppInfoHistory Section\n */\nstatic int\nread_2007_section_appinfohistory (Bit_Chain *restrict dat,\n                                  Dwg_Data *restrict dwg,\n                                  r2007_section *restrict sections_map,\n                                  r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  // BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x580\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_APPINFOHISTORY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"AppInfoHistory\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nAppInfoHistory (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  DEBUG_HERE\n  _obj->size = dat->size & 0xFFFFFFFF;\n  _obj->unknown_bits = bit_read_TF (dat, _obj->size);\n  LOG_TRACE_TF (_obj->unknown_bits, _obj->size)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* RevHistory Section\n */\nstatic int\nread_2007_section_revhistory (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                              r2007_section *restrict sections_map,\n                              r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_RevHistory *_obj = &dwg->revhistory;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_REVHISTORY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"RevHistory\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nRevHistory (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"revhistory.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* ObjFreeSpace Section\n */\nstatic int\nread_2007_section_objfreespace (Bit_Chain *restrict dat,\n                                Dwg_Data *restrict dwg,\n                                r2007_section *restrict sections_map,\n                                r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_ObjFreeSpace *_obj = &dwg->objfreespace;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_OBJFREESPACE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"ObjFreeSpace\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  LOG_TRACE (\"\\nObjFreeSpace (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"objfreespace.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* Template Section. Optional r13-r15, mandatory r18+.\n   Contains the MEASUREMENT variable (0 = English, 1 = Metric).\n */\nstatic int\nread_2007_section_template (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                            r2007_section *restrict sections_map,\n                            r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  // Bit_Chain *str_dat;\n  Dwg_Template *_obj = &dwg->Template;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_TEMPLATE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"%s section not found\\n\", \"Template\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error | DWG_ERR_SECTIONNOTFOUND;\n    }\n\n  LOG_TRACE (\"\\nTemplate (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"template.spec\"\n  // clang-format on\n\n  dwg->header_vars.MEASUREMENT = _obj->MEASUREMENT;\n  LOG_TRACE (\"HEADER.MEASUREMENT: \" FORMAT_BS \" (0 English/1 Metric)\\n\",\n             dwg->header_vars.MEASUREMENT)\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* r21 FileDepList Section\n */\nstatic int\nread_2007_section_filedeplist (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                               r2007_section *restrict sections_map,\n                               r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  Dwg_FileDepList *_obj = &dwg->filedeplist;\n  Dwg_Object *obj = NULL;\n  BITCODE_BL vcount;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // not compressed, page size: 0x80. 0xc or 0xd\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_FILEDEPLIST);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"FileDepList\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"FileDepList (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"filedeplist.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n/* r21 Security Section, if saved with password\n */\nstatic int\nread_2007_section_security (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                            r2007_section *restrict sections_map,\n                            r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  Dwg_Security *_obj = &dwg->security;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SECURITY);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"Security\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"Security (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n// clang-format off\n  #include \"security.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\n#if 0\n/* Signature Section, not written nor documented by Teigha\n */\nstatic int\nread_2007_section_signature (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  struct Dwg_Signature *_obj = &dwg->signature;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, page size: 0x7400\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_SIGNATURE);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", \"Signature\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"Signature (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  // clang-format off\n  #include \"signature.spec\"\n  // clang-format on\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n#endif\n\nstatic int\nacds_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain *str_dat = dat;\n  Dwg_AcDs *_obj = &dwg->acds;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n  BITCODE_BL rcount1 = 0, rcount2 = 0;\n  BITCODE_BL rcount3 = 0, rcount4, vcount;\n\n// clang-format off\n  #include \"acds.spec\"\n  // clang-format on\n\n  return error;\n}\n\n/* r2013+ datastorage Section, if saved with binary ACIS SAB data\n */\nstatic int\nread_2007_section_acds (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                        r2007_section *restrict sections_map,\n                        r2007_page *restrict pages_map)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error;\n  Bit_Chain *str_dat;\n  const char *secname = \"AcDsPrototype_1b\";\n  Dwg_AcDs *_obj = &dwg->acds;\n  Dwg_Object *obj = NULL;\n  BITCODE_RL rcount1 = 0, rcount2 = 0;\n\n  // compressed, pagesize 0x7400, type 13\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_ACDS);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_INFO (\"%s section not found\\n\", secname);\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return 0;\n    }\n\n  LOG_TRACE (\"AcDs datastorage (%zu)\\n-------------------\\n\", sec_dat.size)\n  old_dat = *dat;\n  str_dat = dat = &sec_dat; // restrict in size\n  bit_chain_set_version (&old_dat, dat);\n\n  error |= acds_private (dat, dwg);\n  error &= ~DWG_ERR_SECTIONNOTFOUND;\n\n  LOG_TRACE (\"\\n\")\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2007_section_preview (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                           r2007_section *restrict sections_map,\n                           r2007_page *restrict pages_map)\n{\n  static Bit_Chain sec_dat = { 0 };\n  int error;\n  BITCODE_RL size;\n  BITCODE_RC type;\n  const unsigned char *sentinel;\n\n  error = read_data_section (&sec_dat, dat, sections_map, pages_map,\n                             SECTION_PREVIEW);\n  if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"Preview\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.thumbnail_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"thumbnail_address mismatch: \" FORMAT_RL \" != %zu\",\n              dwg->header.thumbnail_address, dat->byte);\n  LOG_TRACE (\"\\nPreview (%zu)\\n-------------------\\n\", sec_dat.size)\n  if (!sec_dat.chain || sec_dat.size < 32)\n    {\n      LOG_WARN (\"Empty thumbnail\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  sentinel = dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN);\n  if (memcmp (sentinel, sec_dat.chain, 16))\n    {\n      LOG_WARN (\"thumbnail sentinel mismatch\");\n      return error |= DWG_ERR_WRONGCRC;\n    }\n\n  assert (sec_dat.size >= 32);\n  assert (sec_dat.chain);\n  dwg->thumbnail.size = sec_dat.size - 32; // 2x sentinel\n  dwg->thumbnail.chain = sec_dat.chain;\n  dwg->thumbnail.byte = 16; // sentinel\n\n  dwg_bmp (dwg, &size, &type);\n  if (abs ((int)((long)size - (long)dwg->thumbnail.size))\n      > 200) // various headers\n    LOG_WARN (\"thumbnail.size mismatch: %zu != \" FORMAT_RL,\n              dwg->thumbnail.size, size);\n\n  dat->byte += dwg->thumbnail.size;\n\n  return error;\n}\n\n/* exported */\nvoid\nread_r2007_init (Dwg_Data *restrict dwg)\n{\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n}\n\nint\nread_r2007_meta_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                      Dwg_Data *restrict dwg)\n{\n  Dwg_R2007_Header *file_header;\n  r2007_page *restrict pages_map = NULL, *restrict page;\n  r2007_section *restrict sections_map = NULL;\n  int error;\n#ifdef USE_TRACING\n  char *probe;\n#endif\n\n  read_r2007_init (dwg);\n#ifdef USE_TRACING\n  probe = getenv (\"LIBREDWG_TRACE\");\n  if (probe)\n    loglevel = atoi (probe);\n#endif\n  // @ 0x62\n  error = read_file_header (dat, &dwg->r2007_file_header);\n  if (error >= DWG_ERR_VALUEOUTOFBOUNDS)\n    return error;\n  file_header = &dwg->r2007_file_header;\n\n  // Pages Map\n  dat->byte += 0x28; // overread check data\n  dat->byte += file_header->pages_map_offset;\n  if ((size_t)file_header->pages_map_size_comp > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid pages_map_size_comp %zu > %zu bytes left\",\n                 __FUNCTION__, (size_t)file_header->pages_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  pages_map = read_pages_map (dat, file_header->pages_map_size_comp,\n                              file_header->pages_map_size_uncomp,\n                              file_header->pages_map_correction);\n  if (!pages_map)\n    return DWG_ERR_PAGENOTFOUND; // Error already logged\n\n  // Sections Map\n  page = get_page (pages_map, file_header->sections_map_id);\n  if (!page)\n    {\n      LOG_ERROR (\"Failed to find sections page map %d\",\n                 (int)file_header->sections_map_id);\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto error;\n    }\n  dat->byte = page->offset;\n  if ((size_t)file_header->sections_map_size_comp > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid comp_data_size %\" PRId64 \" > %zu bytes left\",\n                 __FUNCTION__, file_header->sections_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  sections_map = read_sections_map (dat, file_header->sections_map_size_comp,\n                                    file_header->sections_map_size_uncomp,\n                                    file_header->sections_map_correction);\n  if (!sections_map)\n    goto error;\n\n  error\n      = read_2007_section_header (dat, hdl_dat, dwg, sections_map, pages_map);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2007_section_summary (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_classes (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_handles (dat, hdl_dat, dwg, sections_map,\n                                      pages_map);\n  error |= read_2007_section_auxheader (dat, dwg, sections_map, pages_map);\n  if (dwg->header.thumbnail_address)\n    error |= read_2007_section_preview (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfo (dat, dwg, sections_map, pages_map);\n  error\n      |= read_2007_section_appinfohistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_filedeplist (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_security (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_revhistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_objfreespace (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_template (dat, dwg, sections_map, pages_map);\n  if (dwg->header.vbaproj_address)\n    error |= read_2007_section_vbaproject (dat, dwg, sections_map, pages_map);\n  // error |= read_2007_section_signature (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_acds (dat, dwg, sections_map, pages_map);\n  // read_2007_blocks (dat, hdl_dat, dwg, sections_map, pages_map);\n\nerror:\n  pages_destroy (pages_map);\n  if (sections_map)\n    sections_destroy (sections_map);\n\n  return error;\n}\n"], "filenames": ["src/decode_r2007.c"], "buggy_code_start_loc": [800], "buggy_code_end_loc": [962], "fixing_code_start_loc": [801], "fixing_code_end_loc": [968], "type": "CWE-125", "message": "Versions of the package libredwg before 0.12.5.6384 are vulnerable to Denial of Service (DoS) due to an out-of-bounds read involving section->num_pages in decode_r2007.c.", "other": {"cve": {"id": "CVE-2023-26157", "sourceIdentifier": "report@snyk.io", "published": "2024-01-02T05:15:08.160", "lastModified": "2024-01-08T19:33:27.113", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package libredwg before 0.12.5.6384 are vulnerable to Denial of Service (DoS) due to an out-of-bounds read involving section->num_pages in decode_r2007.c."}, {"lang": "es", "value": "Las versiones del paquete libredwg anteriores a 0.12.5.6384 son vulnerables a la Denegaci\u00f3n de Servicio (DoS) debido a una lectura fuera de los l\u00edmites que involucra section-&gt;num_pages en decode_r2007.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.5.6384", "matchCriteriaId": "C0D7618D-9F7C-4654-822E-48A907537B85"}]}]}], "references": [{"url": "https://github.com/LibreDWG/libredwg/commit/c8cf03ce4c2315b146caf582ea061c0460193bcc", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/LibreDWG/libredwg/issues/850", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch"]}, {"url": "https://security.snyk.io/vuln/SNYK-UNMANAGED-LIBREDWG-6070730", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/c8cf03ce4c2315b146caf582ea061c0460193bcc"}}